namespace pointer;
public import numeric::integral -;
public import meta m;
public import meta::vararg v;
public import meta::family mf;

public threaded      struct extern "pxcrt::ptr"   "ptr"   {t} ptr   { } 
public threaded      struct extern "pxcrt::cptr"  "cptr"  {t} cptr  { }
public valuetype     struct extern "pxcrt::iptr"  "iptr"  {t} iptr  { }
public multithreaded struct extern "pxcrt::tptr"  "tptr"  {t} tptr  { }
public multithreaded struct extern "pxcrt::tcptr" "tcptr" {t} tcptr { }
public tsvaluetype   struct extern "pxcrt::tiptr" "tiptr" {t} tiptr { }

public mtvaluetype struct extern "pxcrt::lock_guard" "lock_guard" {t}
lock_guard {
  public function extern "wait" void wait();
  public function extern "notify_one" void notify_one();
  public function extern "notify_all" void notify_all();
}
public mtvaluetype struct extern "pxcrt::lock_cguard" "lock_cguard" {t}
lock_cguard {
  public function extern "wait" void wait();
  public function extern "notify_one" void notify_one();
  public function extern "notify_all" void notify_all();
}

public threaded function {t, tis} ptr{t} to_ptr(expand(argdecls{tis}))
{ return box_pointer{ptr{t}, tis}(expand(a: argnames{tis}; a)); }
public threaded function {t, tis} cptr{t} to_cptr(expand(argdecls{tis}))
{ return box_pointer{cptr{t}, tis}(expand(a: argnames{tis}; a)); }
public threaded function {t, tis} iptr{t} to_iptr(expand(argdecls{tis}))
{ return box_pointer{iptr{t}, tis}(expand(a: argnames{tis}; a)); }
public threaded function {t, tis} tptr{t} to_tptr(expand(argdecls{tis}))
{ return box_pointer{tptr{t}, tis}(expand(a: argnames{tis}; a)); }
public threaded function {t, tis} tcptr{t} to_tcptr(expand(argdecls{tis}))
{ return box_pointer{tcptr{t}, tis}(expand(a: argnames{tis}; a)); }
public threaded function {t, tis} tiptr{t} to_tiptr(expand(argdecls{tis}))
{ return box_pointer{tiptr{t}, tis}(expand(a: argnames{tis}; a)); }

private metafunction argdecls{tis} v::arg_decls_bycref{tis};
private metafunction argnames{tis} v::arg_names{m::size{tis}};

public threaded function {tp, tis} tp box_pointer(expand(argdecls{tis}))
{
  if (m::eq{m::list{m::at0{tp}}, m::map{tis, m::at0}}) {
    tp r = tp(a0);
    return r;
  } else {
    tp r = tp(m::at0{tp}(expand(a: argnames{tis}; a)));
    return r;
  }
}

public threaded function extern "pxcrt::downcast_const" {tto, tfrom}
check_polymorphic{tto, tfrom} const& downcast_const(tfrom const& x);

public threaded function extern "pxcrt::downcast_mutable" {tto, tfrom}
check_polymorphic{tto, tfrom} mutable& downcast_mutable(tfrom mutable& x);

public threaded function extern "pxcrt::instanceof" {t, tobj}
bool instanceof(check_polymorphic{tobj, t} const& x);

public threaded function extern "pxcrt::pointer_downcast" {tto, tfrom}
check_pointer_downcast{tto, tfrom} pointer_downcast(tfrom const& x);

private metafunction check_polymorphic{t1, t2}
  m::cond{
    m::and{m::is_polymorphic_type{t1}, m::is_polymorphic_type{t2}},
    t1,
    m::error{"polymorphic type expected"}};

private metafunction check_pointer_downcast{tto, tfrom}
  m::cond{
    m::and{
      m::eq{m::family{tto}, m::family{tfrom}},
      mf::is_pointer_family{m::family{tto}},
      m::is_polymorphic_type{m::at0{tfrom}},
      m::is_polymorphic_type{m::at0{tto}}},
    tto,
    m::error{"invalid pointer_downcast"}};

extern "types" inline

#include <string>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>

#ifdef PXCRT_DBG_RC
#define DBG_RC(x) x
#else
#define DBG_RC(x)
#endif
#ifdef PXCRT_DBG_MTX
#define DBG_MTX(x) x
#else
#define DBG_MTX(x)
#endif
#ifdef PXCRT_DBG_COND
#define DBG_COND(x) x
#else
#define DBG_COND(x)
#endif
#ifdef PXCRT_DBG_POOL
#define DBG_POOL(x) x
#else
#define DBG_POOL(x)
#endif

#ifdef __APPLE__
#define NO_LOCAL_POOL
#endif

#include <cstdlib>

namespace pxcrt {

void clear_local_pool();

#ifndef NO_LOCAL_POOL

extern __thread void *local_pool_blocks;

template <size_t sz> struct local_pool {
  static void *allocate() {
    if (free_list != 0) {
      void *r = free_list;
      free_list = *(void **)free_list;
      DBG_POOL(fprintf(stderr, "a %zu %p\n", sz, r));
      return r;
    }
    extend();
    void *r = free_list;
    free_list = *(void **)free_list;
    DBG_POOL(fprintf(stderr, "A %zu %p\n", sz, r));
    return r;
  }
  static void deallocate(void *p) {
    DBG_POOL(fprintf(stderr, "d %zu %p\n", sz, p));
    append_free_list(p);
  }
  static void append_free_list(void *p) {
    *(void **)p = free_list;
    free_list = p;
  }
private:
  static void extend() {
    DBG_POOL(fprintf(stderr, "X %zu\n", sz));
    char *b = (char *)malloc(sizeof(void *) + pool_size);
    *(void **)(b) = local_pool_blocks; /* segv if null */
    local_pool_blocks = b;
    b += sizeof(void *);
    size_t const bsz = pool_size / sz;
    for (size_t i = 0; i < bsz; ++i) {
      append_free_list(b + i * sz);
    }
  }
private:
  enum { pool_size = 2000 };
  static __thread void *free_list;
};

template <size_t sz> __thread void *local_pool<sz>::free_list = 0;

template <bool is_small> struct local_pool_allocator;

template <> struct local_pool_allocator<true> {
  template <size_t sz> static void *allocate() {
    enum { pool_block_sz = ((sz + 7) / 8) * 8 };
    return local_pool<pool_block_sz>::allocate();
  }
  template <size_t sz> static void deallocate(void *ptr) {
    enum { pool_block_sz = ((sz + 7) / 8) * 8 };
    return local_pool<pool_block_sz>::deallocate(ptr);
  }
};

template <> struct local_pool_allocator<false> {
  template <size_t sz> static void *allocate() {
    return malloc(sz);
  }
  template <size_t sz> static void deallocate(void *ptr) {
    free(ptr);
  }
};

template <typename T> static inline T *local_allocate() {
  enum { is_small = sizeof(T) <= 64 ? true : false };
  return static_cast<T *>(
    local_pool_allocator<is_small>::template allocate<sizeof(T)>());
}

template <typename T> static inline void local_deallocate(const T *ptr) {
  enum { is_small = sizeof(T) <= 64 ? true : false };
  local_pool_allocator<is_small>::template deallocate<sizeof(T)>(
    const_cast<T *>(ptr));
}

#else

template <typename T> static inline T *local_allocate() {
  return static_cast<T *>(malloc(sizeof(T)));
}

template <typename T> static inline void local_deallocate(const T *ptr) {
  return free(const_cast<T *>(ptr));
}

#endif

template <typename T> static inline T *allocate_single() {
  return reinterpret_cast<T *>(malloc(sizeof(T)));
}

template <typename T> static inline void deallocate_single(const T *ptr) {
  free(const_cast<T *>(ptr));
}

struct condition_variable;

struct mutex {
  friend struct condition_variable;
  mutex() {
    init();
  }
  mutex(const mutex&) {
    init();
  }
  mutex& operator =(const mutex&) {
    return *this;
  }
  ~mutex() {
    const int __attribute__((unused)) e = pthread_mutex_destroy(&mtx);
    assert(e == 0);
  }
  void lock() {
    DBG_MTX(fprintf(stderr, "lock %p\n", &mtx));
    const int __attribute__((unused)) e = pthread_mutex_lock(&mtx);
    assert(e == 0);
  }
  void unlock() {
    DBG_MTX(fprintf(stderr, "unlock %p\n", &mtx));
    const int __attribute__((unused)) e = pthread_mutex_unlock(&mtx);
    assert(e == 0);
  }
private:
  void init() {
    pthread_mutexattr_t mattr;
    pthread_mutexattr_init(&mattr);
    pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);
    const int e = pthread_mutex_init(&mtx, &mattr);
    pthread_mutexattr_destroy(&mattr);
    if (e != 0) {
      throw std::runtime_error("pthread_mutex_init"); // TODO
    }
  }
private:
  pthread_mutex_t mtx;
};

struct condition_variable {
  condition_variable() {
    init();
  }
  condition_variable(const condition_variable&) {
    init();
  }
  condition_variable& operator =(const condition_variable&) {
    return *this;
  }
  ~condition_variable() {
    DBG_COND(fprintf(stderr, "cond destroy %p\n", &cond));
    const int __attribute__((unused)) e = pthread_cond_destroy(&cond);
    assert(e == 0);
  }
  void wait(mutex& mtx) {
    const int __attribute__((unused)) e = pthread_cond_wait(&cond, &mtx.mtx);
    assert(e == 0);
  }
  bool timedwait(mutex& mtx, const ::timespec& ts) {
    const int e = pthread_cond_timedwait(&cond, &mtx.mtx, &ts);
    if (e == ETIMEDOUT) {
      return false;
    }
    assert(e == 0);
    return true;
  }
  void notify_one() {
    const int __attribute__((unused)) e = pthread_cond_signal(&cond);
    assert(e == 0);
  }
  void notify_all() {
    const int __attribute__((unused)) e = pthread_cond_broadcast(&cond);
    assert(e == 0);
  }
private:
  void init() {
    const int e = pthread_cond_init(&cond, 0);
    DBG_COND(fprintf(stderr, "cond init %p %d\n", &cond, e));
    if (e != 0) {
      throw std::runtime_error("pthread_cond_init"); // TODO
    }
  }
private:
  pthread_cond_t cond;
};

struct monitor {
  mutex mtx;
  condition_variable cond;
};

struct mtcount { /* reference counter for multi-threaded shared objects */ 
  mtcount() : count$z(1) { }
  void incref$z() { __sync_fetch_and_add(&count$z, 1); } /* gcc >= 4 */
  bool decref$z() { return (__sync_fetch_and_add(&count$z, -1) == 1); }
public:
  long count$z;
};

struct stcount { /* reference counter for single-threaded shared objects */
  stcount() : count$z(1) { }
  void incref$z() { ++count$z; }
  bool decref$z() { return (--count$z == 0); }
public:
  long count$z;
};

template <typename T>
struct rcval {
  /* rcval: single threaded, mutable and immutable */
  typedef T value_type;
  rcval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit rcval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  rcval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  rcval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  rcval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, get_count$z()));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, get_count$z()));
    if (count$z.decref$z()) {
      this->~rcval<T>();
      this->deallocate(this);
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  size_t get_count$z() const { return count$z.count$z; }
  /* void lock$z() const { } */
  /* void unlock$z() const { } */
  /* void wait$z() const { } */
  /* void notify_one$z() const { } */
  /* void notify_all$z() const { } */
  static rcval<T> *allocate() {
    return local_allocate< rcval<T> >();
  }
  static void deallocate(const rcval<T> *ptr) {
    local_deallocate< rcval<T> >(ptr);
  }
public:
  mutable stcount count$z;
public:
  T value$z;
private:
  rcval(const rcval&);
  rcval& operator =(const rcval&);
};

template <typename T>
struct trcval {
  /* trcval: multithreaded, mutable */
  typedef T value_type;
  trcval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit trcval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  trcval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  trcval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  trcval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, get_count$z()));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, get_count$z()));
    if (count$z.decref$z()) {
      this->~trcval<T>();
      this->deallocate(this);
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  size_t get_count$z() const { return count$z.count$z; }
  void lock$z() const { monitor$z.mtx.lock(); }
  void unlock$z() const { monitor$z.mtx.unlock(); }
  void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
  void notify_one$z() const { monitor$z.cond.notify_one(); }
  void notify_all$z() const { monitor$z.cond.notify_all(); }
  static trcval<T> *allocate() {
    return allocate_single< trcval<T> >();
  }
  static void deallocate(const trcval<T> *ptr) {
    deallocate_single< trcval<T> >(ptr);
  }
public:
  mutable mtcount count$z;
  mutable monitor monitor$z;
public:
  T value$z;
private:
  trcval(const trcval&);
  trcval& operator =(const trcval&);
};

template <typename T>
struct tircval {
  /* tircval: multithreded, immutable */
  typedef T value_type;
  tircval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit tircval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  tircval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  tircval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  tircval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (count$z.decref$z()) {
      this->~tircval<T>();
      this->deallocate(this);
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  size_t get_count$z() const { return count$z.count$z; }
  /* void lock$z() const { } */
  /* void unlock$z() const { } */
  /* void wait$z() const { } */
  static tircval<T> *allocate() {
    return allocate_single< tircval<T> >();
  }
  static void deallocate(const tircval<T> *ptr) {
    deallocate_single< tircval<T> >(ptr);
  }
public:
  mutable mtcount count$z;
public:
  T value$z;
private:
  tircval(const tircval&);
  tircval& operator =(const tircval&);
};

template <typename T>
struct rcptr { /* T must have an intrusive count */
  typedef T target_type;
  typedef void range_type; /* guard object requires this */
  typedef void crange_type; /* guard object requires this */
  template <typename Tx> friend struct rcptr;
  rcptr(T *rawptr) : ptr(rawptr) { } /* for fast boxing constr */
  rcptr(const rcptr& x) : ptr(x.ptr) { ptr->incref$z(); }
  /* ptr{foo} to ptr{ifoo} */
  template <typename Tx> rcptr(const rcptr<Tx>& x) : ptr(x.get()) {
    ptr->incref$z();
  }
  /* boxing foo to ptr{ifoo} */
  template <typename Tx> explicit rcptr(const Tx& x)
    : ptr(create_rawptr(x)) { }
  ~rcptr() { ptr->decref$z(); }
  rcptr& operator =(T *x) { return set(x); }
  template <typename Tx> rcptr& operator =(Tx *x) { return set(x); }
  rcptr& operator =(const rcptr& x) { return set(x.ptr); }
  template <typename Tx> rcptr& operator =(const rcptr<Tx>& x) {
    return set(x.ptr);
  }
  T *get() const { return ptr; }
  T& operator *() const { return *ptr; }
  T *operator ->() const { return ptr; }
  void inc_invalidate_guard() const { ptr->lock$z(); }
  void dec_invalidate_guard() const { ptr->unlock$z(); }
  template <typename Tx> static inline T *create_rawptr(const Tx& x) {
    T *p = T::allocate();
    try {
      new (p) T(x);
    } catch (...) {
      T::deallocate(p);
      throw;
    }
    return p;
  }
private:
  T *ptr; /* not nullable */
private:
  rcptr& set(T *x) {
    x->incref$z();
    ptr->decref$z();
    ptr = x;
    return *this;
  }
};

template <typename T> struct lock_guard
{
  lock_guard(const rcptr<T>& p) : ptr(p), objref(*p) { objref.lock$z(); }
  ~lock_guard() { objref.unlock$z(); }
  T *get() const { return &objref; }
  T& operator *() const { return objref; }
  T *operator ->() const { return &objref; }
  void wait() { objref.wait$z(); }
  void notify_one() { objref.notify_one$z(); }
  void notify_all() { objref.notify_all$z(); }
private:
  lock_guard(const lock_guard&);
  lock_guard& operator =(const lock_guard&);
private:
  rcptr<T> ptr;
  T& objref;
};

template <typename T> struct lock_cguard
{
  lock_cguard(const rcptr<const T>& p) : ptr(p), objref(*p)
    { objref.lock$z(); }
  ~lock_cguard() { objref.unlock$z(); }
  const T *get() const { return &objref; }
  const T& operator *() const { return objref; }
  const T *operator ->() const { return &objref; }
  void wait() { objref.wait$z(); }
  void notify_one() { objref.notify_one$z(); }
  void notify_all() { objref.notify_all$z(); }
private:
  lock_cguard(const lock_cguard&);
  lock_cguard& operator =(const lock_cguard&);
private:
  rcptr<const T> ptr;
  const T& objref;
};

template <typename T> typename T::value_type deref_value$z(const rcptr<T>& p)
{
  return p->value$z;
}

template <typename T> T deref(const rcptr<T>& p)
{
  return *p;
}

template <typename Tto, typename Tfrom> Tto const&
downcast_const(Tfrom const& from) {
  return dynamic_cast<Tto const&>(from);
}

template <typename Tto, typename Tfrom> Tto&
downcast_mutable(Tfrom& from) {
  return dynamic_cast<Tto&>(from);
}

template <typename T, typename Tobj> bool
instanceof(Tobj const& x) {
  return dynamic_cast<T const *>(&x) != 0;
}

template <typename Tto, typename Tfrom> Tto
pointer_downcast(Tfrom const& from) {
  typename Tto::target_type& ref = dynamic_cast<typename Tto::target_type&>(
    *(from.get()));
  ref.incref$z();
  return Tto(&ref);
}

}; // namespace pxcrt
;

extern "functions" inline
namespace pxcrt {
}; // namespace pxcrt
;

extern "implementation" inline
namespace pxcrt {

#ifndef NO_LOCAL_POOL

__thread void *local_pool_blocks;

void __attribute__((destructor(101))) clear_local_pool()
{
  while (local_pool_blocks != 0) {
    void *next = *(void **)local_pool_blocks;
    free(local_pool_blocks);
    local_pool_blocks = next;
  }
}

#else

void clear_local_pool()
{
}

#endif

}; // namespace pxcrt
;

