namespace text::impl::positional_fp "use-unsafe";
public import numeric::integral -;
public import numeric::fp -;
public import container::array -;
public import numeric::cast -;
public import numeric::limit lim;
public import numeric::fp -;
public import container::algorithm algo;
public import meta m;
public import container::impl::util;

public threaded function {t} void fp_to_decimal(t x, string mutable& buf)
{ m::symbol{m::concat{"fp_to_decimal_", t}}(x, buf); }
public threaded function {t} t decimal_to_fp_nocheck(cstrref const& buf)
{ return m::symbol{m::concat{"decimal_to_fp_nocheck_", t}}(buf); }
public threaded function {t} t
decimal_to_fp(cstrref mutable& buf)
{ return m::symbol{m::concat{"decimal_to_fp_", t}}(buf); }

public threaded function extern "text::fp_to_decimal_bt_float"
void fp_to_decimal_bt_float(float v, string mutable& buf);
public threaded function extern "text::fp_to_decimal_bt_double"
void fp_to_decimal_bt_double(double v, string mutable& buf);
public threaded function extern "text::decimal_to_fp_nocheck_bt_float"
float decimal_to_fp_nocheck_bt_float(cstrref const& buf);
public threaded function extern "text::decimal_to_fp_nocheck_bt_double"
double decimal_to_fp_nocheck_bt_double(cstrref const& buf);
public threaded function extern "text::decimal_to_fp_bt_float"
float decimal_to_fp_bt_float(cstrref mutable& buf);
public threaded function extern "text::decimal_to_fp_bt_double"
double decimal_to_fp_bt_double(cstrref mutable& buf);

extern "implementation" inline
namespace text {
using namespace pxcrt;
static void fp_to_decimal_internal(const char *fmt, bt_double x, bt_string& s)
{
  const size_t osz = s.size();
  char *buf = reinterpret_cast<char *>(s.reserve_back<1>(10));
  int len = snprintf(buf, 10, fmt, x);
  if (len < 0) {
    return;
  }
  if (len < 10) {
    s.rawarr_set_valid_len(osz + len);
    return;
  }
  const int alen = len;
  buf = reinterpret_cast<char *>(s.reserve_back<1>(alen + 1));
  len = snprintf(buf, alen + 1, fmt, x);
  if (len < 0) {
    return;
  }
  s.rawarr_set_valid_len(osz + len);
}
static cstrref get_decimal_part(cstrref const& buf)
{
  const size_t n = buf.size();
  const bt_uchar *const p = buf.rawarr();
  size_t i = 0;
  for (; i < n; ++i) {
    const bt_uchar ch = p[i];
    if ((ch >= '0' && ch <= '9') ||
      /*
      (ch >= 'a' && ch <= 'z') ||
      (ch >= 'A' && ch <= 'Z') ||
      */
      ch == '+' || ch == '-' || ch == '.') {
    } else {
      break;
    }
  }
  return cstrref(p, i);
}
void fp_to_decimal_bt_double(bt_double x, bt_string& buf)
{ fp_to_decimal_internal("%.16f", x, buf); }
void fp_to_decimal_bt_float(bt_float x, bt_string& buf)
{ fp_to_decimal_internal("%.7f", x, buf); }
bt_double decimal_to_fp_nocheck_bt_double(cstrref const& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, pbuf);
  double r = 0;
  sscanf(buf_nt.get(), "%lf", &r);
  return r;
}
bt_float decimal_to_fp_nocheck_bt_float(cstrref const& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, pbuf);
  float r = 0;
  sscanf(buf_nt.get(), "%f", &r);
  return r;
}
bt_double decimal_to_fp_bt_double(cstrref& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, buf);
  double r = 0;
  int n = 0;
  sscanf(buf_nt.get(), "%lf%n", &r, &n);
  if (n > 0) {
    buf.pop_front(n);
  }
  return r;
}
bt_float decimal_to_fp_bt_float(cstrref& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, buf);
  float r = 0;
  int n = 0;
  sscanf(buf_nt.get(), "%f%n", &r, &n);
  if (n > 0) {
    buf.pop_front(n);
  }
  return r;
}
}; // namespace string
;
