threaded namespace text::positional "use-unsafe";
public import numeric::integral -;
public import container::array -;
public import numeric::cast -;
public import numeric::limit lim;
public import numeric::fp -;
public import meta m;
public import container::impl::util;

/* positional notation */

public threaded function {t} void integral_to_decimal(t v, string mutable& buf)
{
  if (v == 0) {
    buf.push_back('0');
    return;
  }
  size_t pos0 = buf.size();
  if (v < 0) {
    buf.push_back('-');
    pos0 += 1;
    while (v != 0) {
      t rem = v % 10;
      v /= 10;
      buf.push_back(- static_cast{uchar, t}(rem) + '0');
    }
  } else {
    while (v != 0) {
      t rem = v % 10;
      v /= 10;
      buf.push_back(static_cast{uchar, t}(rem) + '0');
    }
  }
  reverse(buf[pos0 .. buf.size()]);
}

public threaded function {t} t decimal_to_integral_nocheck(cstrref const& buf)
{
  if (buf.size() == 0) {
    return t();
  }
  uchar const ch = buf[0];
  if (ch == '-') {
    return decimal_to_integral_nocheck_internal{t, 1}(buf[1 .. buf.size()]);
  } else if (ch == '+') {
    return decimal_to_integral_nocheck_internal{t, 0}(buf[1 .. buf.size()]);
  } else {
    return decimal_to_integral_nocheck_internal{t, 0}(buf);
  }
}

private threaded function {t, negative} t
decimal_to_integral_nocheck_internal(cstrref const& buf)
{
  t r;
  for (size_t idx, uchar v : buf) {
    if (v >= '0' && v <= '9') {
      r *= 10;
      t const dig = static_cast{t, uchar}(v - '0');
      if (negative) {
	r -= dig;
      } else {
	r += dig;
      }
    } else {
      break;
    }
  }
  return r;
}

public threaded function {t} t
decimal_to_integral(cstrref mutable& buf)
{
  if (buf.size() == 0) {
    return t();
  }
  uchar const ch = buf[0];
  if (ch == '-') {
    buf.next_front(1);
    return decimal_to_integral_internal{t, 1}(buf);
  } else if (ch == '+') {
    buf.next_front(1);
    return decimal_to_integral_internal{t, 0}(buf);
  } else {
    return decimal_to_integral_internal{t, 0}(buf);
  }
}

private threaded function {t, negative} t
decimal_to_integral_internal(cstrref mutable& buf)
{
  t r;
  for (size_t idx, uchar v : buf) {
    if (v >= '0' && v <= '9') {
      if (negative) {
	if (r < (lim::lowest{t}() / 10)) {
	  buf.next_front(idx);
	  return r;
	}
      } else {
	if (r > (lim::highest{t}() / 10)) {
	  buf.next_front(idx);
	  return r;
	}
      }
      r *= 10;
      t const dig = static_cast{t, uchar}(v - '0');
      if (negative) {
	t const nr = r - dig;
	if (nr > r) {
	  buf.next_front(idx);
	  return r;
	}
	r = nr;
      } else {
	t const nr = r + dig;
	if (nr < r) {
	  buf.next_front(idx);
	  return r;
	}
	r = nr;
      }
    } else {
      buf.next_front(idx);
      return r;
    }
  }
  buf.next_front(buf.size());
  return r;
}

public threaded function {t} void fp_to_decimal(t x, string mutable& buf)
{ m::symbol{m::concat{"fp_to_decimal_", t}}(x, buf); }
public threaded function {t} t decimal_to_fp_nocheck(cstrref const& buf)
{ return m::symbol{m::concat{"decimal_to_fp_nocheck_", t}}(buf); }
public threaded function {t} t
decimal_to_fp(cstrref mutable& buf)
{ return m::symbol{m::concat{"decimal_to_fp_", t}}(buf); }

public threaded function extern "text::fp_to_decimal_float"
void fp_to_decimal_float(float v, string mutable& buf);
public threaded function extern "text::fp_to_decimal_double"
void fp_to_decimal_double(double v, string mutable& buf);
public threaded function extern "text::decimal_to_fp_nocheck_float"
float decimal_to_fp_nocheck_float(cstrref const& buf);
public threaded function extern "text::decimal_to_fp_nocheck_double"
double decimal_to_fp_nocheck_double(cstrref const& buf);
public threaded function extern "text::decimal_to_fp_float"
float decimal_to_fp_float(cstrref mutable& buf);
public threaded function extern "text::decimal_to_fp_double"
double decimal_to_fp_double(cstrref mutable& buf);

extern "implementation" inline
namespace text {
using namespace pxcrt;

static void fp_to_decimal_internal(const char *fmt, bt_double x, bt_string& s)
{
  const size_t osz = s.size();
  char *buf = reinterpret_cast<char *>(s.reserve_back<1>(10));
  int len = snprintf(buf, 10, fmt, x);
  if (len < 0) {
    return;
  }
  if (len < 10) {
    s.rawarr_set_valid_len(osz + len);
    return;
  }
  const int alen = len;
  buf = reinterpret_cast<char *>(s.reserve_back<1>(alen + 1));
  len = snprintf(buf, alen + 1, fmt, x);
  if (len < 0) {
    return;
  }
  s.rawarr_set_valid_len(osz + len);
}

static cstrref get_decimal_part(cstrref const& buf)
{
  const size_t n = buf.size();
  const bt_uchar *const p = buf.rawarr();
  size_t i = 0;
  for (; i < n; ++i) {
    const bt_uchar ch = p[i];
    if ((ch >= '0' && ch <= '9') ||
      /*
      (ch >= 'a' && ch <= 'z') ||
      (ch >= 'A' && ch <= 'Z') ||
      */
      ch == '+' || ch == '-' || ch == '.') {
    } else {
      break;
    }
  }
  return cstrref(p, i);
}

void fp_to_decimal_double(bt_double x, bt_string& buf)
{ fp_to_decimal_internal("%.16f", x, buf); }

void fp_to_decimal_float(bt_float x, bt_string& buf)
{ fp_to_decimal_internal("%.7f", x, buf); }

bt_double decimal_to_fp_nocheck_double(cstrref const& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, pbuf);
  double r = 0;
  sscanf(buf_nt.get(), "%lf", &r);
  return r;
}

bt_float decimal_to_fp_nocheck_float(cstrref const& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, pbuf);
  float r = 0;
  sscanf(buf_nt.get(), "%f", &r);
  return r;
}

bt_double decimal_to_fp_double(cstrref& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, buf);
  double r = 0;
  int n = 0;
  sscanf(buf_nt.get(), "%lf%n", &r, &n);
  if (n > 0) {
    buf.next_front(n);
  }
  return r;
}

bt_float decimal_to_fp_float(cstrref& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, buf);
  float r = 0;
  int n = 0;
  sscanf(buf_nt.get(), "%f%n", &r, &n);
  if (n > 0) {
    buf.next_front(n);
  }
  return r;
}

};
;
