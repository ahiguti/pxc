namespace text::conversion;
public import numeric::integral -;
public import container::array -;
public import meta m;
public import meta::family mf;
public import numeric::cast n;
public import text::positional p;
public import text::serialize -;
public import text::minimal_encode e;

public threaded function {t} string to_string(t const& x)
{
  if (mf::is_string_or_slice_type{t}) {
    return x;
  } else {
    string s;
    serialize_to_string(x, s);
    return s;
  }
}

public threaded function {t} void serialize_to_string(t const& x,
  string mutable& out)
{
  serialize{serialize_tpl, t}(x, out);
}

public threaded function {t} t from_string(cstrref const& s)
{
  if (mf::is_string_or_slice_type{t}) {
    return s;
  } else {
    cstrref s1 = s;
    return deserialize_from_string{t}(s1);
  }
}

public threaded function {t} t deserialize_from_string(cstrref mutable& s)
{
  return deserialize{deserialize_tpl, t}(s);
}

private threaded function void bool_to_string(bool v, string mutable& buf)
{
  if (v) {
    buf.append("1");
  } else {
    buf.append("0");
  }
}

private threaded function {t} void string_append_escape(t const& x,
  string mutable& v)
{
  e::minimal_encode(v, x);
}
private threaded function {t} void string_append_noesc(t const& x,
  string mutable& v)
{
  v.append(x);
}
private threaded function void string_append_brace_open(string mutable& v)
{ v.push_back('{'); }
private threaded function void string_append_brace_close(string mutable& v)
{ v.push_back('}'); }
private threaded function void string_append_sep(string mutable& v)
{ v.push_back(','); }
private threaded function void string_append_none(string mutable& v)
{ } 
private threaded function {t} void string_append_star(t const& x,
  string mutable& v)
{ v.push_back('*'); }
private threaded function {t} void string_append_unknown(t const& x,
  string mutable& v)
{ v.push_back('?'); }

private threaded struct serialize_tpl {
  metafunction target_type string;
  metafunction symstr{t} m::concat{t, "_append_to_string"};
  metafunction sym{t} m::symbol{symstr{t}, t};
  metafunction has_specialized_symbol{t}
    m::eq{m::to_string{sym{t}}, symstr{t}};
  metafunction specialized_func{t}
    m::cond{has_specialized_symbol{t}, sym{t},
    m::cond{mf::is_string_or_slice_type{t}, string_append_escape{t},
    m::cond{mf::is_integral_type{t}, p::integral_to_decimal,
    m::cond{mf::is_fp_type{t}, p::fp_to_decimal,
    m::cond{m::eq{t, bool}, bool_to_string,
    m::cond{m::eq{t, unit}, string_append_star,
    0}}}}}};
  metafunction array_begin string_append_brace_open;
  metafunction array_end string_append_brace_close;
  metafunction array_sep string_append_sep;
  metafunction map_begin string_append_brace_open;
  metafunction map_end string_append_brace_close;
  metafunction map_sep string_append_sep;
  metafunction map_entry_sep string_append_sep;
  metafunction pointer_begin string_append_brace_open;
  metafunction pointer_end string_append_brace_close;
  metafunction struct_begin string_append_brace_open;
  metafunction struct_end string_append_brace_close;
  metafunction struct_sep string_append_sep;
  metafunction struct_entry_sep string_append_sep;
  metafunction struct_field_name string_append_noesc;
  metafunction union_begin string_append_brace_open;
  metafunction union_end string_append_brace_close;
  metafunction union_entry_sep string_append_sep;
  metafunction union_field_name string_append_noesc;
  metafunction unknown{fam} string_append_unknown;
}

private threaded function size_t token_length(cstrref const& s)
{
  for (size_t i, uchar ch : s) {
    if (ch == '{') {
      if (i == 0) {
	return find_brace_close(s[1 .. s.size()]) + 1;
      } else {
	return i;
      }
    }
    if (ch == '}' || ch == ',') {
      return i;
    }
  }
  return s.size();
}
private threaded function size_t find_brace_close(cstrref const& s)
{
  size_t level = 1;
  for (size_t i, uchar ch : s) {
    if (ch == '}') {
      if (--level == 0) {
	return i + 1;
      }
    } else if (ch == '{') {
      ++level;
    }
  }
  return s.size();
}
private threaded function {t, f} t string_parse_token(cstrref mutable& s)
{
  size_t const toklen = token_length(s);
  cstrref stok = s[0 .. toklen];
  s.next_front(toklen);
  return f(stok);
}
private threaded function string string_parse_string_unescape(
  cstrref mutable& s)
{
  return string_parse_token{string, str_decode}(s);
  threaded function string str_decode(cstrref const& stok) {
    string r;
    e::minimal_decode(r, stok);
    return r;
  }
}
private threaded function {t} t string_parse_integral(cstrref mutable& s)
{
  return string_parse_token{t, p::decimal_to_integral{t}}(s);
}
private threaded function {t} t string_parse_fp(cstrref mutable& s)
{
  return string_parse_token{t, p::decimal_to_fp{t}}(s);
}
private threaded function bool string_parse_bool(cstrref mutable& s)
{
  return string_parse_token{bool, parse_bool}(s);
  threaded function bool parse_bool(cstrref const& stok) {
    if (stok.empty() || stok == "0") {
      return false;
    } else {
      return true;
    }
  }
}
private threaded function unit string_parse_unit(cstrref mutable& s)
{
  return unit();
}
private threaded function void string_parse_symbol_peek(cstrref mutable& stok)
{
  size_t const sz = stok.size();
  size_t const toklen = token_length(stok);
  stok.prev_back(sz - toklen);
}
private threaded function void string_parse_symbol(cstrref mutable& stok,
  cstrref mutable& s)
{
  size_t const sz = stok.size();
  size_t const toklen = token_length(stok);
  stok.prev_back(sz - toklen);
  s.next_front(toklen);
}
private threaded function bool string_parse_char_cond(cstrref mutable& s,
  uchar ch)
{
  if (s.size() > 0 && s[0] == ch) {
    s.next_front(1);
    return true;
  } else {
    return false;
  }
}
private threaded function void string_parse_brace_close_skip(
  cstrref mutable& s)
{
  size_t level = 1;
  for (size_t i, uchar ch : s) {
    if (ch == '}') {
      if (--level == 0) {
	s.next_front(i + 1);
	return;
      }
    } else if (ch == '{') {
      ++level;
    }
  }
}
private threaded function void string_parse_token_skip(cstrref mutable& s)
{
  size_t const toklen = token_length(s);
  s.next_front(toklen);
}
private threaded function bool string_parse_brace_open_cond(cstrref mutable& s)
{ return string_parse_char_cond(s, '{'); }
private threaded function bool string_parse_brace_close_peek_cond(
  cstrref mutable& s)
{ return s.size() > 0 && s[0] == '}'; }
private threaded function bool string_parse_brace_close_cond(
  cstrref mutable& s)
{ return string_parse_char_cond(s, '}'); }
private threaded function bool string_parse_sep_cond(cstrref mutable& s)
{ return string_parse_char_cond(s, ','); }
private threaded struct deserialize_tpl {
  metafunction source_type cstrref;
  metafunction symstr{t} m::concat{t, "_parse_from_string"};
  metafunction sym{t} m::symbol{symstr{t}, t};
  metafunction has_specialized_symbol{t}
    m::eq{m::to_string{sym{t}}, symstr{t}};
  metafunction specialized_func{t}
    m::cond{has_specialized_symbol{t}, string_parse_token{t, sym{t}},
    m::cond{mf::is_string_or_slice_type{t}, string_parse_string_unescape,
    m::cond{mf::is_integral_type{t}, string_parse_integral{t},
    m::cond{mf::is_fp_type{t}, string_parse_fp{t},
    m::cond{m::eq{t, bool}, string_parse_bool,
    m::cond{m::eq{t, unit}, string_parse_unit,
    0}}}}}};
  metafunction array_begin_cond string_parse_brace_open_cond;
  metafunction array_end_cond string_parse_brace_close_cond;
  metafunction array_end_skip string_parse_brace_close_skip;
  metafunction array_sep_cond string_parse_sep_cond;
  metafunction map_begin_cond string_parse_brace_open_cond;
  metafunction map_end_cond string_parse_brace_close_cond;
  metafunction map_end_skip string_parse_brace_close_skip;
  metafunction map_sep_cond string_parse_sep_cond;
  metafunction map_entry_sep_cond string_parse_sep_cond;
  metafunction pointer_begin_cond string_parse_brace_open_cond;
  metafunction pointer_end_skip string_parse_brace_close_skip;
  metafunction struct_begin_cond string_parse_brace_open_cond;
  metafunction struct_end_peek_cond string_parse_brace_close_peek_cond;
  metafunction struct_end_skip string_parse_brace_close_skip;
  metafunction struct_sep_cond string_parse_sep_cond;
  metafunction struct_entry_sep_cond string_parse_sep_cond;
  metafunction struct_field_name_peek string_parse_symbol_peek;
  metafunction union_begin_cond string_parse_brace_open_cond;
  metafunction union_end_cond string_parse_brace_close_cond;
  metafunction union_end_skip string_parse_brace_close_skip;
  metafunction union_sep_cond string_parse_sep_cond;
  metafunction union_entry_sep_cond string_parse_sep_cond;
  metafunction union_field_name string_parse_symbol;
  metafunction unknown{fam} string_parse_token_skip;
  metafunction value_skip string_parse_token_skip;
}

