namespace GL::base "use-unsafe";
import common -;
import meta m;

public metafunction GLvoid void;
public metafunction GLchar char;
public metafunction GLbyte char;
public metafunction GLubyte uchar;
public metafunction GLshort short;
public metafunction GLushort ushort;
public metafunction GLint int;
public metafunction GLuint uint;
public metafunction GLint64 long;
public metafunction GLuint64 ulong;
public metafunction GLfloat float;
public metafunction GLdouble double;
public metafunction GLboolean uchar;
public metafunction GLsizei int;

public tsvaluetype struct extern "GLenum" "extenum" GLenum { }
public tsvaluetype struct extern "GLbitfield" "extbitmask" GLbitfield { }
public tsvaluetype struct extern "GLsizeiptr" "extint" GLsizeiptr { }
public tsvaluetype struct extern "GLintptr" "extint" GLintptr { }
public tsvaluetype struct extern "GLfixed" "extint" GLfixed { }
public tsvaluetype struct extern "GLclampx" "extint" GLclampx { }
public tsvaluetype struct extern "GLDEBUGPROC" GLDEBUGPROC { }
public tsvaluetype struct extern "GLsync" "noncopyable" GLsync { }

expand (s : m::list{m::list{"", m::eq{m::profile{"platform"}, "macos"}}}) {
extern "ldflags" "-lGL -lm";
extern "ldflags" "-framework OpenGL -lm";
}

extern "types" inline

#ifndef GL_GLEXT_PROTOTYPES
#define GL_GLEXT_PROTOTYPES
#endif

#ifdef __APPLE__
#include <OpenGL/gl.h>
#include <OpenGL/glext.h>
#elif defined ANDROID
#include <GLES/gl.h>
#include <GLES/glext.h>
#else
#include <GL/gl.h>
#include <GL/glext.h>
#endif

namespace gl {

};
;

public function extern "gl::offset_to_void_cp" crawptr{void}
offset_to_void_cp(size_t x); /* used for glVertexPointer() with VBO */

extern "functions" inline
namespace gl {
using namespace pxcrt;

static inline const void *offset_to_void_cp(bt_size_t x)
{ return reinterpret_cast<const void *>(x); }

};
;

private metafunction type_alist m::list{
  /* m::list{str, rettype, argtype} */
  m::list{"v", GLvoid, GLvoid}, /* 0 */
  m::list{"e", GLenum, GLenum},
  m::list{"m", GLbitfield, GLbitfield},
  m::list{"f", GLfloat, GLfloat},
  m::list{"d", GLdouble, GLdouble},
  m::list{"b", GLboolean, GLboolean},
  m::list{"by", GLbyte, GLbyte},
  m::list{"uby", GLubyte, GLubyte},
  m::list{"s", GLshort, GLshort},
  m::list{"us", GLushort, GLushort},
  m::list{"i", GLint}, /* 10 */
  m::list{"ui", GLuint},
  m::list{"l", GLint64},
  m::list{"szi", GLsizei},
  m::list{"ip", GLintptr},
  m::list{"szip", GLsizeiptr},
  m::list{"fx", GLfixed},
  m::list{"cx", GLclampx},
  m::list{"DP", GLDEBUGPROC},
  m::list{"sync", GLsync},
  m::list{"*", voidptr}, /* 20 */
  m::list{"v*", voidptr},
  m::list{"e*", rawptr{GLenum}},
  m::list{"f*", rawptr{GLfloat}},
  m::list{"d*", rawptr{GLdouble}},
  m::list{"b*", rawptr{GLboolean}},
  m::list{"c*", charptr},
  m::list{"uby*", rawptr{GLubyte}},
  m::list{"s*", rawptr{GLshort}},
  m::list{"us*", rawptr{GLushort}},
  m::list{"i*", rawptr{GLint}}, /* 30 */
  m::list{"ui*", rawptr{GLuint}},
  m::list{"l*", rawptr{GLint64}},
  m::list{"ul*", rawptr{GLuint64}},
  m::list{"szi*", rawptr{GLsizei}},
  m::list{"fx*", rawptr{GLfixed}},
  m::list{"_*", cvoidptr},
  m::list{"_v*", cvoidptr},
  m::list{"_e*", crawptr{GLenum}},
  m::list{"_f*", crawptr{GLfloat}},
  m::list{"_d*", crawptr{GLdouble}}, /* 40 */
  m::list{"_b*", crawptr{GLboolean}},
  m::list{"_c*", ccharptr},
  m::list{"_by*", crawptr{GLbyte}},
  m::list{"_uby*", crawptr{GLubyte}},
  m::list{"_s*", crawptr{GLshort}},
  m::list{"_us*", crawptr{GLushort}},
  m::list{"_i*", crawptr{GLint}},
  m::list{"_ui*", crawptr{GLuint}},
  m::list{"_szi*", crawptr{GLsizei}},
  m::list{"_ip*", crawptr{GLintptr}}, /* 50 */
  m::list{"_szip*", crawptr{GLsizeiptr}},
  m::list{"_fx*", crawptr{GLfixed}},
  m::list{"v**", rawptr{voidptr}},
  m::list{"_v*_*", crawptr{cvoidptr}},
  m::list{"_c*_*", crawptr{ccharptr}}};

public metafunction find_type{s} m::at{type_alist, s};
public metafunction ent_to_rettype{ent}
  m::at1{find_type{m::at1{ent}}};
public metafunction ent_to_argdefs{ent}
  m::map{
    m::slice{ent, 2},
    metafunction{x} m::apply{
      metafunction{xt} m::list{
	/* name */ m::at0{x},
	/* type */ m::at1{xt},
	/* byref - if it's a slice-wrapper */ 0,
	/* mutable */ 0},
      /* xt := */ find_type{m::at1{x}}}};

