threaded namespace thread "use-unsafe";
public import numeric::integral -;
public import pointer -;
public import container::array;
public import exception;
public import meta -;

public multithreaded struct extern "pxcthread::thread_ptr" "nodefault"
thread { }

public threaded function {targs} thread make_thread(targs const& args)
{
  tptr{thrdata} r = make_tptr{thrdata_impl{targs}}(thrdata_impl{targs}(args));
  return make_thread_impl(r);
}

public threaded function extern "pxcthread::thread_join"
  void thread_join(thread const& thr);


/* private */

private multithreaded interface thrdata {
  function void main();
}
private multithreaded struct {targs} thrdata_impl(targs const& a)
  <thrdata>
{
  targs args = a;
  function void main() {
    args.main();
  }
}
private threaded function extern "pxcthread::make_thread_impl"
  thread make_thread_impl(tptr{thrdata} const& f);

extern "types" inline

namespace pxcthread {

struct thread_rep;

typedef pxcrt::rcptr< pxcrt::trcval<thread_rep> > thread_ptr;
};

;

extern "functions" inline

namespace pxcthread {

typedef pxcrt::rcptr< thread$n::thrdata$i > thrdata_ptr;
typedef thread$n::thrdata$i *thrdata_rawptr;

struct thread_rep {
  thread_rep(thrdata_ptr const& m) : tid(), need_join(false), mptr(m) { }
  ~thread_rep() { join(); }
  void join();
  pthread_t tid;
  bool need_join;
  thrdata_ptr mptr;
private:
  thread_rep(const thread_rep&);
  thread_rep& operator =(const thread_rep&);
};

thread_ptr make_thread_impl(thrdata_ptr const& m);
void thread_join(thread_ptr const& t);

};

;

extern "implementation" inline

#define PXC_THREAD_DBG(x)

namespace pxcthread {

void *pxc_thread_child_main(void *arg)
{
  thrdata_rawptr m = static_cast<thrdata_rawptr>(arg);
    /* no need to lock m */
  PXC_TRY {
    PXC_TRY {
      m->main$f();
    } PXC_CATCH(const std::exception& ex) {
      #if !PXC_NOEXCEPTIONS
      pxcrt::c_exception_log_stderr(ex);
      #endif
    }
  } PXC_CATCH(...) {
    const char *const mess = "PXCTHREAD: Uncaught exception\n";
    ::write(2, mess, strlen(mess));
  }
  pxcrt::clear_local_pool();
  return 0;
}

thread_ptr make_thread_impl(thrdata_ptr const& m)
{
  thread_ptr thr(thread_ptr::make_rawptr(m));
  thread_rep& impl = thr->value;
  if (pthread_create(&impl.tid, 0, pxc_thread_child_main, m.get()) != 0) {
    PXC_THREAD_DBG(fprintf(stderr, "failed to create thread\n"));
  } else {
    PXC_THREAD_DBG(fprintf(stderr, "thread create\n"));
    impl.need_join = true;
  }
  return thr;
}

void thread_join(thread_ptr const& t)
{
  if (t.get() == 0) {
    return;
  }
  pxcrt::guard_val<thread_ptr> grd(t);
  grd.get()->value.join();
}

void thread_rep::join()
{
  if (!need_join) {
    PXC_THREAD_DBG(fprintf(stderr, "no need to join\n"));
    return;
  }
  if (tid == pthread_self()) {
    PXC_THREAD_DBG(fprintf(stderr, "detach\n"));
    const int e = pthread_detach(tid);
    assert(e == 0);
  } else {
    PXC_THREAD_DBG(fprintf(stderr, "join\n"));
    const int e = pthread_join(tid, 0);
    assert(e == 0);
  }
  need_join = false;
}

};

#undef PXC_THREAD_DBG

;

