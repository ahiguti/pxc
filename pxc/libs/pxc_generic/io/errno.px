namespace io::errno "use-unsafe";
public import numeric::integral -;
public import container::array -;
public import io +;

public tsvaluetype struct extern "int" "extenum" errno_t { }

public tsvaluetype union {t} errno_or_value {
  errno_t errno;
  t value;
}

public threaded function extern "pxcio::io_get_errno"
errno_t io_get_errno(io const& sys);
public threaded function extern "pxcio::io_set_errno"
void io_set_errno(io const& sys, errno_t e);
public threaded function extern "pxcio::errno_t_append_to_string"
void errno_t_append_to_string(errno_t e, string mutable& s);

public extern "0" errno_t EOK;

extern "implementation" inline
#include <errno.h>
namespace pxcio {
using namespace pxcrt;

int io_get_errno(io const& sys)
{
  return errno;
}

void io_set_errno(io const& sys, int e)
{
  errno = e;
}

#if defined(__linux) && !defined(ANDROID)
#if (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE
#define HAVE_XSI_STRERROR_R
#endif
#else
#define HAVE_XSI_STRERROR_R
#endif

void errno_t_append_to_string(int err, bt_string& s)
{
  char buf[257];
  #ifdef HAVE_XSI_STRERROR_R
  /* XSI version */
  int len = strerror_r(err, buf, 256);
  const char *p = buf;
  #else
  /* GNU version */
  const char *p = strerror_r(err, buf, 256);
  #endif
  s.append(reinterpret_cast<const bt_uchar *>(p), strlen(p));
}

}; // namespace pxcio
;

