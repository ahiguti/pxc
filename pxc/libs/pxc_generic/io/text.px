namespace io::text;
public import numeric::integral -;
public import container::array -;
public import io +;
public import io::file +;
public import io::errno -;
public import text::split -;
public import meta m;

public threaded function {cb, opt} errno_t file_read_lines(file const& ifile)
{
  metafunction line_delim get_opt{opt, "line_delim", '\n'};
  metafunction read_block_size get_opt{opt, "read_block_size", 16384};
  string buffer;
  bool cont_flag = true;
  while (cont_flag) {
    size_t pos = buffer.size();
    size_t rlen = read_block_size;
    const e = ifile.read(buffer, rlen);
    if (e != EOK) {
      return e;
    }
    if (rlen == 0) {
      break;
    }
    while (cont_flag) {
      const uchar delim = line_delim;
      size_t const p = find_mapped{string}(buffer, pos, delim);
      if (p == buffer.size()) {
	break;
      }
      cstrref sr = buffer[pos .. p + 1];
      cont_flag = cb(sr);
      pos = p + 1;
    }
    buffer.erase(0, pos);
  }
  return EOK;
}

public threaded function bool is_space_or_tab(uchar ch)
{
  return ch == ' ' || ch == '\t';
}

public threaded function {cb, opt} errno_t
file_read_records(file const& ifile)
{
  metafunction enttype m::argtype{cb, 0};
  metafunction column_delim get_opt{opt, "column_delim", is_space_or_tab};
  const err = file_read_lines{parse_line, opt}(ifile);
  threaded function bool parse_line(cstrref const& line) {
    enttype e;
    string_split{column_delim}(line,
      expand(fld: m::field_names{enttype}; e.fld));
    return cb(e);
  }
  return err;
}

public threaded function {opt, t} errno_t
file_read_append_records(file const& ifile, t mutable& v)
{
  return ifile.read_records{record_cb, opt}();
  threaded function bool record_cb(t:mapped_type const& e) {
    v.push_back(e);
  }
}

public threaded function {cb, opt} errno_t
io_read_records(io const& sys, cstrref const& fn)
{
  const ef = sys.open(fn, O_RDONLY, 0);
  if (const e : ef.errno) {
    return e;
  }
  return ef.value.read_records{cb, opt}();
}

public threaded function {opt, t} errno_t
io_read_append_records(io const& sys, cstrref const& fn, t mutable& v)
{
  const ef = sys.open(fn, O_RDONLY, 0);
  if (const e : ef.errno) {
    return e;
  }
  return ef.value.read_append_records{opt, t}(v);
}

private metafunction get_opt{opt, k, def}
  m::cond{m::is_type{opt}, m::local{opt, k}, def};

