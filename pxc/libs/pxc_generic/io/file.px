threaded namespace io::file "use-unsafe";
public import numeric::integral -;
public import container::array -;
public import meta -;
public import pointer -;
public import io +;
public import io::errno -;
public import io::time -;
public import meta m;
public import exception;
public import operator -;

public multithreaded struct extern "pxcio::file" "nodefault" file { }
  /* while pxcio::file is implemented as an immutable pointer, it is
   * defiend as 'multithreaded' instead of 'tsvaluetype', because it is
   * not transitively immutable. */

public tsvaluetype struct extern "::off_t" "extint" off_t { }         //SQUAD?
public tsvaluetype struct extern "::dev_t" "extuint" dev_t { }        //UQUAD
public tsvaluetype struct extern "::ino_t" "extuint" ino_t { }        //ULONGW
public tsvaluetype struct extern "::mode_t " "extbitmask" mode_t { }  //U32
public tsvaluetype struct extern "::nlink_t" "extuint" nlink_t { }    //UWORD
public tsvaluetype struct extern "::uid_t" "extuint" uid_t { }        //U32
public tsvaluetype struct extern "::gid_t" "extuint" gid_t { }        // U32
public tsvaluetype struct extern "::blksize_t" "extint" blksize_t { } //SLONGW
public tsvaluetype struct extern "::blkcnt_t" "extint" blkcnt_t { }   //SQUAD?
public tsvaluetype struct extern "::ssize_t" "extint" ssize_t { }     //SWORD?
public tsvaluetype struct extern "int" "extbitmask" open_flags_t { }
public tsvaluetype struct extern "int" "extenum" whence_t { }

public tsvaluetype struct extern "pxcio::statbuf" statbuf {
  dev_t st_dev;
  ino_t st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  off_t st_size;
  blksize_t st_blksize;
  blkcnt_t st_blocks;
  time_t st_atime;
  time_t st_mtime;
  time_t st_ctime;
}

public extern "O_RDONLY"	open_flags_t O_RDONLY;
public extern "O_WRONLY"	open_flags_t O_WRONLY;
public extern "O_RDWR"		open_flags_t O_RDWR;
public extern "O_CREAT"		open_flags_t O_CREAT;
public extern "O_EXCL"		open_flags_t O_EXCL;
public extern "O_TRUNC"		open_flags_t O_TRUNC;
public extern "O_APPEND"	open_flags_t O_APPEND;
public extern "O_NONBLOCK"	open_flags_t O_NONBLOCK;
public extern "O_SYNC"		open_flags_t O_SYNC;
public extern "O_FSYNC"		open_flags_t O_FSYNC;
public extern "O_ASYNC"		open_flags_t O_ASYNC;
public extern "SEEK_SET"	whence_t SEEK_SET;
public extern "SEEK_CUR"	whence_t SEEK_CUR;
public extern "SEEK_END"	whence_t SEEK_END;
public extern "S_IRWXU"		mode_t S_IRWXU;
public extern "S_IRUSR"		mode_t S_IRUSR;
public extern "S_IWUSR"		mode_t S_IWUSR;
public extern "S_IXUSR"		mode_t S_IXUSR;
public extern "S_IRWXG"		mode_t S_IRWXG;
public extern "S_IRGRP"		mode_t S_IRGRP;
public extern "S_IWGRP"		mode_t S_IWGRP;
public extern "S_IXGRP"		mode_t S_IXGRP;
public extern "S_IRWXO"		mode_t S_IRWXO;
public extern "S_IROTH"		mode_t S_IROTH;
public extern "S_IWOTH"		mode_t S_IWOTH;
public extern "S_IXOTH"		mode_t S_IXOTH;

public metafunction open_t errno_or_value{file};

public threaded function open_t
io_open(io const& iop, cstrref const& fn, open_flags_t flags, mode_t md)
{
  open_t r;
  int fd = io_open_fd(iop, fn, flags, md);
  if (fd >= 0) {
    r.value = iop.make_file(fd);
  } else {
    r.errno = iop.get_errno();
  }
  return r;
}

/* file descriptors are hidden */
private threaded function extern "pxcio::io_open_fd"
int io_open_fd(io const& iop, cstrref const& fn, open_flags_t flags,
  mode_t md);
private threaded function extern "pxcio::io_make_file"
file io_make_file(io const& iop, int fd);

/*
public threaded function extern "pxcio::io_open"
file io_open(io const& iop, cstrref const& fn, open_flags_t flags, mode_t md);
*/
private threaded function extern "pxcio::file_read_impl" errno_t
file_read_impl(file const& f, string mutable& buf, size_t mutable& len);

public threaded function errno_or_value{size_t}
file_read(file const& f, string mutable& buf, size_t len)
{
  errno_or_value{size_t} r;
  const e = file_read_impl(f, buf, len);
  if (e != EOK) {
    r.errno = e;
  } else {
    r.value = len;
  }
  return r;
}

public threaded function extern "pxcio::file_write_impl" errno_t
file_write_impl(file const& f, cstrref const& buf, size_t mutable& len_r);

public threaded function errno_or_value{size_t}
file_write(file const& f, cstrref const& buf)
{
  errno_or_value{size_t} r;
  size_t len = 0;
  const e = file_write_impl(f, buf, len);
  if (e != EOK) {
    r.errno = e;
  } else {
    r.value = len;
  }
  return r;
}

public threaded function extern "pxcio::file_lseek_impl" errno_t
file_lseek_impl(file const& f, off_t mutable& offset, whence_t whence);

public threaded function errno_or_value{off_t}
file_lseek(file const& f, off_t offset, whence_t whence)
{
  errno_or_value{off_t} r;
  const e = file_lseek_impl(f, offset, whence);
  if (e != EOK) {
    r.errno = e;
  } else {
    r.value = offset;
  }
  return r;
}

public threaded function extern "pxcio::io_stat" errno_t
io_stat(io const& iop, cstrref const& fn, statbuf mutable& buf);
public threaded function extern "pxcio::io_sleep" uint
io_sleep(io const& iop, uint sec);
public threaded function extern "pxcio::io_usleep" uint
io_usleep(io const& iop, uint usec);

public threaded function errno_or_value{size_t}
file_read_all(file const& f, string mutable& buf)
{
  size_t rlen = 0;
  while (true) {
    size_t const len = 16384; /* TODO */
    const r = file_read(f, buf, len);
    if (const rl : r.value) {
      if (rl == 0) {
	break;
      }
      rlen += rl;
    } else {
      return r;
    }
  }
  errno_or_value{size_t} r;
  r.value = rlen;
  return r;
}
public threaded function errno_or_value{size_t}
file_write_all(file const& f, cstrref const& buf)
{
  size_t len_r = 0;
  size_t curpos = 0;
  size_t endpos = buf.size();
  while (curpos != endpos) {
    const r = file_write(f, buf[curpos .. endpos]);
    if (case r.errno) {
      return r;
    }
    const size_t wlen = r.value;
    if (wlen == 0) {
      break;
    }
    curpos += wlen;
    len_r += wlen;
  }
  errno_or_value{size_t} r;
  r.value = len_r;
  return r;
}

public threaded function errno_or_value{ptr{string}}
io_read_file(io const& iop, cstrref const& fn)
{
  errno_or_value{ptr{string}} r;
  const f = io_open(iop, fn, O_RDONLY, 0);
  if (const err: f.errno) {
    r.errno = err;
  } else {
    const buf = make_ptr{string}();
    const ra = file_read_all(f.value, *buf);
    if (const err: ra.errno) {
      r.errno = err;
    } else {
      r.value = buf;
    }
  }
  return r;
}
public threaded function errno_or_value{size_t}
io_write_file(io const& iop, cstrref const& fn, cstrref const& buf)
{
  errno_or_value{size_t} r;
  const f = io_open(iop, fn, O_WRONLY | O_CREAT | O_TRUNC,
    S_IRWXU | S_IRWXG | S_IRWXO);
  if (const err: f.errno) {
    r.errno = err;
  } else {
    r = file_write_all(f.value, buf);
  }
  return r;
}

extern "types" inline
#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
namespace pxcio {
using namespace pxcrt;

typedef struct ::stat statbuf;

struct file_rep {
  file_rep(int fd) : fd(fd) { }
  ~file_rep() { if (fd > 2) close(fd); } /* don't close stdin/out/err */
  int get() const { return fd; }
private:
  const int fd;
  file_rep(const file_rep&);
  file_rep& operator =(const file_rep&);
};

/* immutable value, multi-thread safe refcount */
typedef ::pxcrt::rcptr< pxcrt::tircval<file_rep> > file;

};
;

extern "functions" inline
namespace pxcio {

file make_file(int fd); /* can be called from other io::* namespaces */

};
;

extern "implementation" inline
namespace pxcio {

typedef int errno_t;

bt_int io_open_fd(io const& iop, cstrref const& fn, int flags, ::mode_t md)
{
  PXCRT_ALLOCA_NTSTRING(fn_nt, fn);
  return ::open(fn_nt.get(), flags, md);
}

file io_make_file(io const& iop, bt_int fd)
{
  return make_file(fd);
}

file make_file(bt_int fd)
{
  PXC_TRY {
    file r(file::make_rawptr(fd)); /* throws */
    return r;
  } PXC_CATCH(...) {
    if (fd >= 2) {
      file_rep f(fd); /* closes fd */
    }
    PXC_RETHROW;
  }
}

errno_t file_read_impl(file const& f, bt_string& buf, size_t& len)
{
  int const fd = f->value.get();
  bt_size_t sz = len;
  if (sz > SSIZE_MAX) {
    sz = SSIZE_MAX;
  }
  bt_size_t osz = buf.size();
  void *const ptr = buf.reserve_back<1>(sz);
  const ssize_t rlen = ::read(fd, ptr, sz);
  if (rlen < 0) {
    return errno;
  }
  buf.rawarr_set_valid_len(osz + rlen);
  len = rlen;
  return 0;
}

errno_t file_write_impl(file const& f, cstrref const& buf, size_t& len_r)
{
  int const fd = f->value.get();
  bt_size_t sz = buf.size();
  if (sz > SSIZE_MAX) {
    sz = SSIZE_MAX;
  }
  const unsigned char *const ptr = buf.rawarr();
  const ssize_t wlen = ::write(fd, ptr, sz);
  if (wlen < 0) {
    return errno;
  }
  len_r = wlen;
  return 0;
}

errno_t file_lseek_impl(file const& f, ::off_t& offset, int whence)
{
  int const fd = f->value.get();
  off_t r = ::lseek(fd, offset, whence);
  if (r == (off_t)-1) {
    offset = 0;
    return errno;
  }
  offset = r;
  return 0;
}

errno_t io_stat(io const& iop, cstrref const& fn, pxcio::statbuf& buf)
{
  PXCRT_ALLOCA_NTSTRING(fn_nt, fn);
  const int e = ::stat(fn_nt.get(), &buf);
  if (e != 0) {
    return errno;
  }
  return 0;
}

bt_uint io_sleep(io const& iop, bt_uint sec)
{
  return ::sleep(sec);
}

bt_uint io_usleep(io const& iop, bt_uint usec)
{
  return ::usleep(usec);
}

};
;

