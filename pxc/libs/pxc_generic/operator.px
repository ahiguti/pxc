threaded namespace operator;
public import numeric::integral -;
public import meta::family -;
public import meta m;

threaded function {t} t add(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x + y; } else { return x.__add(y); } }
threaded function {t} t sub(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x - y; } else { return x.__sub(y); } }
threaded function {t} t mul(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x * y; } else { return x.__mul(y); } }
threaded function {t} t div(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x / y; } else { return x.__div(y); } }
threaded function {t} t mod(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x % y; } else { return x.__mod(y); } }

threaded function {t} t or(t const& x, t const& y)
{ if (is_boolean_type{t}) { return x | y; } else { return x.__or(y); } }
threaded function {t} t and(t const& x, t const& y)
{ if (is_boolean_type{t}) { return x & y; } else { return x.__and(y); } }
threaded function {t} t xor(t const& x, t const& y)
{ if (is_boolean_type{t}) { return x ^ y; } else { return x.__xor(y); } }

threaded function {t} t eq(t const& x, t const& y)
{ if (is_equality_type{t}) { return x == y; } else { return x.__eq(y); } }
threaded function {t} t ne(t const& x, t const& y)
{ if (is_equality_type{t}) { return x != y; } else { return x.__ne(y); } }

threaded function {t} t shiftl(t const& x, t const& y)
{ if (is_integral_type{t}) { return x << y; } else { return x.__shiftl(y); } }
threaded function {t} t shiftr(t const& x, t const& y)
{ if (is_integral_type{t}) { return x >> y; } else { return x.__shiftr(y); } }

threaded function {tx, ty} void adda(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x += y; } else { x.__adda(y); } }
threaded function {tx, ty} void suba(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x -= y; } else { x.__suba(y); } }
threaded function {tx, ty} void mula(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x *= y; } else { x.__mula(y); } }
threaded function {tx, ty} void diva(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x /= y; } else { x.__diva(y); } }
threaded function {tx, ty} void moda(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x %= y; } else { x.__moda(y); } }
threaded function {tx, ty} void ora(tx mutable& x, ty const& y)
{ if (is_boolean_type{tx}) { x |= y; } else { x.__ora(y); } }
threaded function {tx, ty} void anda(tx mutable& x, ty const& y)
{ if (is_boolean_type{tx}) { x &= y; } else { x.__anda(y); } }
threaded function {tx, ty} void xora(tx mutable& x, ty const& y)
{ if (is_boolean_type{tx}) { x ^= y; } else { x.__xora(y); } }
threaded function {tx, ty} void shiftla(tx mutable& x, ty const& y)
{ if (is_integral_type{tx}) { x <<= y; } else { x.__shiftla(y); } }
threaded function {tx, ty} void shiftra(tx mutable& x, ty const& y)
{ if (is_integral_tyep{tx}) { x >>= y; } else { x.__shiftra(y); } }

threaded function {t} t plus(t const& x)
{ if (is_numeric_type{t}) { return x; } else { return x.__plus(); } }
threaded function {t} t minus(t const& x)
{ if (is_numeric_type{t}) { return -x; } else { return x.__minus(); } }
threaded function {t} t neg(t const& x)
{ if (is_boolean_type{t}) { return ~x; } else { return x.__neg(); } }
threaded function {t} t not(t const& x)
{ if (is_boolean_type{t}) { return !x; } else { return x.__not(); } }

threaded function {tx, ty} mapped_type{tx}
getelem(tx const& x, ty const& y)
{
  if (is_container_or_range_type{tx}) { return x[y]; }
  else { return x.__getelem(y); }
}
threaded function {tx, ty, tz} void
setelem(tx mutable& x, ty const& y, tz const& z)
{
  if (is_container_or_range_type{tx}) { x[y] = z; }
  else { x.__setelem(y, z); }
}

private metafunction mapped_type{t}
  m::cond{
    is_container_or_range_type{t},
    m::local{t, "mapped_type"},
    m::rettype{m::local{t, "__getelem"}}};

