threaded namespace operator;
public import numeric::integral -;
public import meta::family -;
public import meta m;

threaded function {t} t add(t const& x, t const& y)
// { if (is_numeric_type{t}) { return x + y; } else { return x.__add(y); } }
{
  if (is_numeric_type{t}) { return x + y; }
  else { return binop{t, "add"}(x, y); }
}

threaded function {t} t sub(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x - y; } else { return x.__sub(y); } }
threaded function {t} t mul(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x * y; } else { return x.__mul(y); } }
threaded function {t} t div(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x / y; } else { return x.__div(y); } }
threaded function {t} t mod(t const& x, t const& y)
{ if (is_numeric_type{t}) { return x % y; } else { return x.__mod(y); } }

threaded function {t} t or(t const& x, t const& y)
{ if (is_boolean_type{t}) { return x | y; } else { return x.__or(y); } }
threaded function {t} t and(t const& x, t const& y)
{ if (is_boolean_type{t}) { return x & y; } else { return x.__and(y); } }
threaded function {t} t xor(t const& x, t const& y)
{ if (is_boolean_type{t}) { return x ^ y; } else { return x.__xor(y); } }

threaded function {t} t eq(t const& x, t const& y)
{ if (is_equality_type{t}) { return x == y; } else { return x.__eq(y); } }
threaded function {t} t ne(t const& x, t const& y)
{ if (is_equality_type{t}) { return x != y; } else { return x.__ne(y); } }

threaded function {t} t shiftl(t const& x, t const& y)
{ if (is_integral_type{t}) { return x << y; } else { return x.__shiftl(y); } }
threaded function {t} t shiftr(t const& x, t const& y)
{ if (is_integral_type{t}) { return x >> y; } else { return x.__shiftr(y); } }

threaded function {tx, ty} void adda(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x += y; } else { x.__adda(y); } }
threaded function {tx, ty} void suba(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x -= y; } else { x.__suba(y); } }
threaded function {tx, ty} void mula(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x *= y; } else { x.__mula(y); } }
threaded function {tx, ty} void diva(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x /= y; } else { x.__diva(y); } }
threaded function {tx, ty} void moda(tx mutable& x, ty const& y)
{ if (is_numeric_type{tx}) { x %= y; } else { x.__moda(y); } }
threaded function {tx, ty} void ora(tx mutable& x, ty const& y)
{ if (is_boolean_type{tx}) { x |= y; } else { x.__ora(y); } }
threaded function {tx, ty} void anda(tx mutable& x, ty const& y)
{ if (is_boolean_type{tx}) { x &= y; } else { x.__anda(y); } }
threaded function {tx, ty} void xora(tx mutable& x, ty const& y)
{ if (is_boolean_type{tx}) { x ^= y; } else { x.__xora(y); } }
threaded function {tx, ty} void shiftla(tx mutable& x, ty const& y)
{ if (is_integral_type{tx}) { x <<= y; } else { x.__shiftla(y); } }
threaded function {tx, ty} void shiftra(tx mutable& x, ty const& y)
{ if (is_integral_tyep{tx}) { x >>= y; } else { x.__shiftra(y); } }

threaded function {t} t plus(t const& x)
{ if (is_numeric_type{t}) { return x; } else { return x.__plus(); } }
threaded function {t} t minus(t const& x)
{ if (is_numeric_type{t}) { return -x; } else { return x.__minus(); } }
threaded function {t} t neg(t const& x)
{ if (is_boolean_type{t}) { return ~x; } else { return x.__neg(); } }
threaded function {t} t not(t const& x)
{ if (is_boolean_type{t}) { return !x; } else { return x.__not(); } }

threaded function {tx, ty} mapped_type{tx}
getelem(tx const& x, ty const& y)
{
  if (is_container_or_range_type{tx}) { return x[y]; }
  else { return x.__getelem(y); }
}
threaded function {tx, ty, tz} void
setelem(tx mutable& x, ty const& y, tz const& z)
{
  if (is_container_or_range_type{tx}) { x[y] = z; }
  else { x.__setelem(y, z); }
}

private metafunction mapped_type{t}
  m::cond{
    is_container_or_range_type{t},
    m::local{t, "mapped_type"},
    m::rettype{m::local{t, "__getelem"}}};

threaded function {t, opstr} t binop(t const& x, t const& y)
{
  metafunction opstr_bin m::concat{"__", opstr};
  metafunction op_bin m::symbol{opstr_bin, t};
  metafunction opstr_assign m::concat{"__", opstr, "a"};
  metafunction op_assign m::symbol{opstr_assign, t};
  metafunction fstr_bin m::concat{t, "___", opstr};
  metafunction f_bin m::symbol{fstr_bin};
  metafunction fstr_assign m::concat{t, "___", opstr};
  metafunction f_assign m::symbol{fstr_assign};
  if (m::eq{m::to_string{op_bin}, opstr_bin}) {
    expand(sym: m::list{opstr_bin}) { return x.sym(y); }
  } else if (m::eq{m::to_string{op_assign}, opstr_assign}) {
    t r = x;
    expand(sym: m::list{opstr_assign}) { r.sym(y); }
    return r;
  } else if (m::eq{m::to_string{f_bin}, fstr_bin}) {
    expand(sym: m::list{f_bin}) { return sym(x, y); }
  } else if (m::eq{m::to_string{f_assign}, f_assign}) {
    t r = x;
    expand(sym: m::list{f_assign}) { f_assign(r, y); }
    return r;
  } else if (is_struct_type{t}) {
    metafunction op m::symbol{add, "operator"};
    return t(expand(fld: m::field_names{t}; op(x.fld, y.fld)));
  } else {
    return m::error{m::concat{"operator ", opstr, " not defined"}};
  }
}

public metafunction implicit_conversion{tto, tfrom}
  m::cond{
    m::eq{
      m::to_string{m::symbol{conv_funcname_nons{tto, tfrom}, tfrom}},
      conv_funcname_nons{tto, tfrom}},
    implicit_conversion_from{tto, tfrom},
    //m::apply{m::symbol{conv_funcname_nons{tto, tfrom}, tfrom}, tto, tfrom},
    0};

private metafunction conv_funcname_nons{tto, tfrom}
  m::concat{m::to_string{tfrom}, "___to"};

private threaded function {tto, tfrom} tto
implicit_conversion_from(tfrom const& from)
{
  return m::apply{
    m::symbol{conv_funcname_nons{tto, tfrom}, tfrom},
    tto,
    tfrom}(from);
}

