namespace operator;
public import numeric::integral -;
public import meta m;

threaded function {t} t add(t const& x, t const& y) { return x.__add(y); }
threaded function {t} t sub(t const& x, t const& y) { return x.__sub(y); }
threaded function {t} t mul(t const& x, t const& y) { return x.__mul(y); }
threaded function {t} t div(t const& x, t const& y) { return x.__div(y); }

threaded function {t} t mod(t const& x, t const& y) { return x.__mod(y); }
threaded function {t} t or(t const& x, t const& y) { return x.__or(y); }
threaded function {t} t and(t const& x, t const& y) { return x.__and(y); }
threaded function {t} t xor(t const& x, t const& y) { return x.__xor(y); }

threaded function {t} t eq(t const& x, t const& y) { return x.__eq(y); }
threaded function {t} t ne(t const& x, t const& y) { return x.__ne(y); }

threaded function {t} t
shiftl(t const& x, t const& y) { return x.__shiftl(y); }
threaded function {t} t
shiftr(t const& x, t const& y) { return x.__shiftr(y); }

threaded function {tx, ty} void
adda(tx mutable& x, ty const& y) { x.__adda(y); }
threaded function {tx, ty} void
suba(tx mutable& x, ty const& y) { x.__suba(y); }
threaded function {tx, ty} void
mula(tx mutable& x, ty const& y) { x.__mula(y); }
threaded function {tx, ty} void
diva(tx mutable& x, ty const& y) { x.__diva(y); }
threaded function {tx, ty} void
moda(tx mutable& x, ty const& y) { x.__moda(y); }
threaded function {tx, ty} void
ora(tx mutable& x, ty const& y) { x.__ora(y); }
threaded function {tx, ty} void
anda(tx mutable& x, ty const& y) { x.__anda(y); }
threaded function {tx, ty} void
xora(tx mutable& x, ty const& y) { x.__xora(y); }
threaded function {tx, ty} void
shiftla(tx mutable& x, ty const& y) { x.__shiftla(y); }
threaded function {tx, ty} void
shiftra(tx mutable& x, ty const& y) { x.__shiftra(y); }

threaded function {t} t plus(t const& x) { return x.__plus(); }
threaded function {t} t minus(t const& x) { return x.__minus(); }
threaded function {t} t neg(t const& x) { return x.__neg(); }
threaded function {t} t not(t const& x) { return x.__not(); }

threaded function {tx, ty} m::rettype{m::local{tx, "__getelem"}}
getelem(tx const& x, ty const& y) { return x.__getelem(y); }
threaded function {tx, ty, tz} void
setelem(tx mutable& x, ty const& y, tz const& z) { x.__setelem(y, z); }

