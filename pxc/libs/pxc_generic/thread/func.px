threaded namespace thread::func;
public import thread -;
public import numeric::integral -;
public import pointer -;
public import meta m;
public import algebraic -;

public multithreaded interface {t} uneval {
  function t eval();
}

public threaded function {f} ptr{uneval{func_ret{f}}}
make_thread_func(expand(m::args{f}))
{
  const p = to_ptr(uneval_thread{f}(
    to_tptr(make_tuple(expand(a : m::map{m::args{f}, m::at0}; a)))));
  return p;
}

private metafunction func_arg{f} tuple{m::argtypes{f}};
private metafunction func_ret{f} type_map{m::rettype{f}};
private metafunction type_map{t} m::cond{m::eq{t, void}, unit, t};

private multithreaded struct {f}
uneval_thread_params(tptr{func_arg{f}} const& a, tptr{func_ret{f}} const& r)
{
  tptr{func_arg{f}} argp = a;
  tptr{func_ret{f}} retp = r;
  function void main() {
    func_arg{f} const& arg = *argp;
    if (m::eq{func_ret{f}, unit}) {
      f(expand(a: m::field_names{func_arg{f}}; arg.a));
    } else {
      *retp = f(expand(a: m::field_names{func_arg{f}}; arg.a));
    }
  }
}

private multithreaded struct {f}
uneval_thread(tptr{func_arg{f}} const& a)
  <uneval{func_ret{f}}>
{
  tptr{func_ret{f}} retp = to_tptr{func_ret{f}}();
  thread thr = make_thread(uneval_thread_params{f}(a, retp));
  function func_ret{f} eval() {
    thr.join();
    return *retp;
  }
}

