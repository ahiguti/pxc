threaded namespace SDL2 "use-unsafe";
public import common -;
public import exception -;
public import meta m;

extern "cflags" "`sdl2-config --cflags`";
extern "ldflags" "`sdl2-config --libs`";

/* SDL_Init */

public struct extern "SDL2::Init" "nodefault"
SDL_Init(SDL_InitFlags flags) { }

public tsvaluetype struct extern "Uint32" "extbitmask" SDL_InitFlags { }
expand(sym : m::map{m::list{
  "AUDIO", "VIDEO", "CDROM", "TIMER", "EVERYTHING"
}, metafunction{x} m::concat{"SDL_INIT_", x}}) {
  public extern "%" SDL_InitFlags sym;
}

/* SDL_Window */

public function option{ptr{SDL_Window}}
SDL_CreateWindow(cstrref const& title, int x, int y, int w, int h,
  SDL_WindowFlags f)
{
  ptr{SDL_Window} p = to_ptr{SDL_Window}();
  option{ptr{SDL_Window}} r;
  if (CreateWindow(*p, title, x, y, w, h, f) == 0) {
    r.some = p;
  }
  return r;
}

public struct extern "SDL2::Window" "noncopyable"
SDL_Window private() { }

public extern "%" int SDL_WINDOWPOS_UNDEFINED;

public tsvaluetype struct extern "Uint32" "extbitmask" SDL_WindowFlags { }
expand(sym : m::map{m::list{
  "FULLSCREEN", "OPENGL", "SHOWN", "HIDDEN", "BORDERLESS", "RESIZABLE",
  "MINIMIZED", "MAXIMIZED", "INPUT_GRABBED", "INPUT_FOCUS", "MOUSE_FOCUS",
  "FULLSCREEN_DESKTOP"
}, metafunction{x} m::concat{"SDL_WINDOW_", x}}) {
  public extern "%" SDL_WindowFlags sym;
}

public function extern "SDL2::GetWindowSize" void
SDL_GetWindowSize(ptr{SDL_Window} const& wnd, int mutable& w, int mutable& h);

private function extern "SDL2::CreateWindow" int
CreateWindow(SDL_Window mutable& wnd, cstrref const& title, int x, int y,
  int w, int h, SDL_WindowFlags f);

/* SDL_Renderer */

public function option{ptr{SDL_Renderer}}
SDL_CreateRenderer(ptr{SDL_Window} const& wnd, int index, SDL_RendererFlags f)
{
  ptr{SDL_Renderer} p = to_ptr{SDL_Renderer}();
  option{ptr{SDL_Renderer}} r;
  if (CreateRenderer(*p, *wnd, index, f) == 0) {
    r.some = p;
  }
  return r;
}

public struct extern "SDL2::Renderer" "noncopyable"
SDL_Renderer private () { }

public tsvaluetype struct extern "Uint32" "extbitmask" SDL_RendererFlags { }
expand(sym : m::map{m::list{
  "SOFTWARE", "ACCELERATED", "PRESENTVSYNC", "TARGETTEXTURE"
}, metafunction{x} m::concat{"SDL_RENDERER_", x}}) {
  public extern "%" SDL_RendererFlags sym;
}

public struct extern "SDL_Rect" SDL_Rect {
  int x;
  int y;
  int w;
  int h;
}

public function extern "SDL2::RenderClear" int
SDL_RenderClear(ptr{SDL_Renderer} const& rnd);
public function extern "SDL2::RenderPresent" void
SDL_RenderPresent(ptr{SDL_Renderer} const& rnd);
public function extern "SDL2::RenderCopy" int
SDL_RenderCopy(ptr{SDL_Renderer} const& rnd,
  ptr{SDL_Texture} const& tx, SDL_Rect const& src, SDL_Rect const& dst);

private function extern "SDL2::CreateRenderer" int
CreateRenderer(SDL_Renderer mutable& rnd, SDL_Window const& wnd,
  int index, SDL_RendererFlags f);

/* SDL_Surface */

public struct extern "SDL2::Surface" "noncopyable"
SDL_Surface private () { }

public function option{ptr{SDL_Surface}} SDL_LoadBMP(cstrref const& filename)
{
  ptr{SDL_Surface} p = to_ptr{SDL_Surface}();
  option{ptr{SDL_Surface}} r;
  if (LoadBMP(*p, filename) == 0) {
    r.some = p;
  }
  return r;
}

private function extern "SDL2::LoadBMP" int
LoadBMP(SDL_Surface mutable& sur, cstrref const& filename);

public function extern "SDL2::Surface_W" uint
SDL_Surface_W(ptr{SDL_Surface} const& sur);
public function extern "SDL2::Surface_H" uint
SDL_Surface_H(ptr{SDL_Surface} const& sur);
public function extern "SDL2::Surface_Pitch" uint
SDL_Surface_Pitch(ptr{SDL_Surface} const& sur);
public function extern "SDL2::Surface_BytesPerPixel" uint
SDL_Surface_BytesPerPixel(ptr{SDL_Surface} const& sur);
public function extern "SDL2::Surface_Pixels" strref
SDL_Surface_Pixels(ptr{SDL_Surface} const& sur);

/* SDL_Texture */

public function option{ptr{SDL_Texture}}
SDL_CreateTextureFromSurface(ptr{SDL_Renderer} const& rnd,
  ptr{SDL_Surface} const& sur)
{
  ptr{SDL_Texture} p = to_ptr{SDL_Texture}();
  option{ptr{SDL_Texture}} r;
  if (CreateTextureFromSurface(*p, rnd, sur) == 0) {
    r.some = p;
  }
  return r;
}

public struct extern "SDL2::Texture" "noncopyable"
SDL_Texture private () { }

public function extern "SDL2::CreateTextureFromSurface" int
CreateTextureFromSurface(SDL_Texture mutable& tx, ptr{SDL_Renderer} const& rnd,
  ptr{SDL_Surface} const& sur);

/* SDL_Event */

public tsvaluetype struct extern "SDL_Event" SDL_Event {
  /* union */
  SDL_EventType const type;
  SDL_CommonEvent const common;
  SDL_WindowEvent const window;
  SDL_KeyboardEvent const key;
  SDL_TextEditingEvent const edit;
  SDL_TextInputEvent const text;
  SDL_MouseMotionEvent const motion;
  SDL_MouseButtonEvent const button;
  SDL_MouseWheelEvent const wheel;
  SDL_JoyAxisEvent const jaxis;
  SDL_JoyBallEvent const jball;
  SDL_JoyHatEvent const jhat;
  SDL_JoyButtonEvent const jbutton;
  SDL_JoyDeviceEvent const jdevice;
  SDL_ControllerAxisEvent const caxis;
  SDL_ControllerButtonEvent const cbutton;
  SDL_ControllerDeviceEvent const cdevice;
  SDL_QuitEvent const quit;
  SDL_UserEvent const user;
  SDL_SysWMEvent const syswm;
  SDL_TouchFingerEvent const tfinger;
  SDL_MultiGestureEvent const mgesture;
  SDL_DollarGestureEvent const dgesture;
  SDL_DropEvent const drop;
}
public tsvaluetype struct extern "SDL_CommonEvent" SDL_CommonEvent {
  SDL_EventType const type;
  uint const timestamp;
}
public tsvaluetype struct extern "SDL_WindowEvent" SDL_WindowEvent {
  SDL_EventType const type;
  uint const timestamp;
  uint const windowID;
  SDL_WindowEventID const event;
  int const data1;
  int const data2;
}
public tsvaluetype struct extern "SDL_KeyboardEvent"
SDL_KeyboardEvent { }
public tsvaluetype struct extern "SDL_TextEditingEvent"
SDL_TextEditingEvent { }
public tsvaluetype struct extern "SDL_TextInputEvent"
SDL_TextInputEvent { }
public tsvaluetype struct extern "SDL_MouseMotionEvent"
SDL_MouseMotionEvent { }
public tsvaluetype struct extern "SDL_MouseButtonEvent"
SDL_MouseButtonEvent { }
public tsvaluetype struct extern "SDL_MouseWheelEvent"
SDL_MouseWheelEvent { }
public tsvaluetype struct extern "SDL_JoyAxisEvent"
SDL_JoyAxisEvent { }
public tsvaluetype struct extern "SDL_JoyBallEvent"
SDL_JoyBallEvent { }
public tsvaluetype struct extern "SDL_JoyHatEvent"
SDL_JoyHatEvent { }
public tsvaluetype struct extern "SDL_JoyButtonEvent"
SDL_JoyButtonEvent { }
public tsvaluetype struct extern "SDL_JoyDeviceEvent"
SDL_JoyDeviceEvent { }
public tsvaluetype struct extern "SDL_ControllerAxisEvent"
SDL_ControllerAxisEvent { }
public tsvaluetype struct extern "SDL_ControllerButtonEvent"
SDL_ControllerButtonEvent { }
public tsvaluetype struct extern "SDL_ControllerDeviceEvent"
SDL_ControllerDeviceEvent { }
public tsvaluetype struct extern "SDL_QuitEvent"
SDL_QuitEvent { }
public tsvaluetype struct extern "SDL_UserEvent"
SDL_UserEvent { }
public tsvaluetype struct extern "SDL_SysWMEvent"
SDL_SysWMEvent { }
public tsvaluetype struct extern "SDL_TouchFingerEvent"
SDL_TouchFingerEvent {
  SDL_EventType const type;
  uint const timestamp;
  float x;
  float y;
  float dx;
  float dy;
  float pressure;
}
public tsvaluetype struct extern "SDL_MultiGestureEvent"
SDL_MultiGestureEvent {
  SDL_EventType const type;
  uint const timestamp;
  float dTheta;
  float dDist;
  float x;
  float y;
  ushort numFingers;
}
public tsvaluetype struct extern "SDL_DollarGestureEvent"
SDL_DollarGestureEvent { }
public tsvaluetype struct extern "SDL_DropEvent" SDL_DropEvent { }

public function extern "SDL2::PollEvent" bool
SDL_PollEvent(SDL_Event mutable& ev);

public tsvaluetype struct extern "Uint32" /* SDL_EventType */ "extenum"
SDL_EventType { }
expand(sym : m::map{m::list{
  "QUIT", "APP_TERMINATING", "APP_LOWMEMORY", "APP_WILLENTERBACKGROUND",
  "APP_DIDENTERBACKGROUND", "APP_WILLENTERFOREGROUND",
  "APP_DIDENTERFOREGROUND", "WINDOWEVENT", "SYSWMEVENT", "KEYDOWN", "KEYUP",
  "TEXTEDITING", "TEXTINPUT", "MOUSEMOTION", "MOUSEBUTTONDOWN",
  "MOUSEBUTTONUP", "MOUSEWHEEL", "JOYAXISMOTION", "JOYBALLMOTION",
  "JOYHATMOTION", "JOYBUTTONDOWN", "JOYBUTTONUP", "JOYDEVICEADDED",
  "JOYDEVICEREMOTED", "CONTROLLERAXISMOTION", "CONTROLLERBUTTONDOWN",
  "CONTROLLERBUTTONUP", "CONTROLLERDEVICEADDED", "CONTROLLERDEVICEREMOVED",
  "CONTROLLERDEVICEREMAPPED", "FINGERDOWN", "FINGERUP", "FINGERMOTION",
  "DOLLARGESTURE", "DOLLARRECORD", "MULTIGESTURE", "CLIPBOARDUPDATE",
  "DROPFILE", "USEREVENT", "LASTEVENT"
}, metafunction{x} m::concat{"SDL_", x}}) {
  public extern "%" SDL_EventType sym;
}

public tsvaluetype struct extern "Uint8" "extenum" SDL_WindowEventID { }
expand (sym : m::map{m::list{
  "MOVED", "RESIZED"
}, metafunction{x} m::concat{"SDL_WINDOWEVENT_", x}}) {
  public extern "%" SDL_WindowEventID sym;
}

public struct extern "SDL_GLattr" "extenum" SDL_GLattr { }
expand (sym : m::map{m::list{
  "DOUBLEBUFFER", "CONTEXT_MAJOR_VERSION", "CONTEXT_MINOR_VERSION"
}, metafunction{x} m::concat{"SDL_GL_", x}}) {
  public extern "%" SDL_GLattr sym;
}

public function option{ptr{SDL_GLContext}}
SDL_GL_CreateContext(ptr{SDL_Window} const& wnd)
{
  ptr{SDL_GLContext} p = to_ptr{SDL_GLContext}();
  option{ptr{SDL_GLContext}} r;
  if (GL_CreateContext(*p, *wnd) == 0) {
    r.some = p;
  }
  return r;
}

public struct extern "SDL2::GLContext" "noncopyable"
SDL_GLContext private () { }

public function extern "SDL_GL_SetAttribute" void
SDL_GL_SetAttribute(SDL_GLattr attr, int value);
public function extern "SDL2::GL_SwapWindow" void
SDL_GL_SwapWindow(ptr{SDL_Window} const& wnd);
public function extern "SDL_GL_SetSwapInterval" void
SDL_GL_SetSwapInterval(int v);

private function extern "SDL2::GL_CreateContext" int
GL_CreateContext(SDL_GLContext mutable& glctx, SDL_Window const& wnd);

/* SDL_KeyboardState */

public struct extern "SDL2::KeyboardState" "noncopyable"
SDL_KeyboardState() { }

public function extern "SDL2::KeyboardState_Key" uint
SDL_KeyboardState_Key(SDL_KeyboardState const& ks, SDL_Scancode code);

/* SDL_Scancode */

public struct extern "SDL_Scancode" "extenum" SDL_Scancode { }
expand (sym : m::map{m::list{
  "UNKNOWN", "RIGHT", "LEFT", "DOWN", "UP", "ESCAPE", "SPACE"
}, metafunction{x} m::concat{"SDL_SCANCODE_", x}}) {
  public extern "%" SDL_Scancode sym;
}

/* SDL_log */

public struct extern "int" "extenum" SDL_LogCategory { }
expand (sym : m::map{m::list{
  "APPLICATION", "ERROR", "ASSERT", "SYSTEM", "AUDIO", "VIDEO", "RENDER",
  "INPUT", "TEST"
}, metafunction{x} m::concat{"SDL_LOG_CATEGORY_", x}}) {
  public extern "%" SDL_LogCategory sym;
}

public function extern "SDL2::Log" void SDL_Log(cstrref const& mess);
public function extern "SDL2::LogInfo" void SDL_LogInfo(SDL_LogCategory cat,
  cstrref const& mess);
public function extern "SDL2::LogWarn" void SDL_LogWarn(SDL_LogCategory cat,
  cstrref const& mess);
public function extern "SDL2::LogError" void SDL_LogError(SDL_LogCategory cat,
  cstrref const& mess);

/* timer */

public function extern "SDL_GetTicks" uint SDL_GetTicks();
public function extern "SDL_Delay" void SDL_Delay(uint ms);

extern "types" inline
#include <SDL.h>
namespace SDL2 {
using namespace pxcrt;

struct Init {
  Init(Uint32 flags);
  Init();
  Init(Init const& x);
  ~Init();
private:
  Init& operator =(Init const& x);
  static int init_count;
};

struct Window : private noncopyable {
  Window();
  ~Window();
  const Init ini;
  SDL_Window *ptr;
};

struct Renderer : private noncopyable {
  Renderer();
  ~Renderer();
  const Init ini;
  SDL_Renderer *ptr;
};

struct Surface : private noncopyable {
  Surface();
  ~Surface();
  const Init ini;
  /* ptr must not be invalidated so that Surface_Pixels() returns a valid
   * slice */
  SDL_Surface *ptr;
};

struct Texture : private noncopyable {
  Texture();
  ~Texture();
  const Init ini;
  SDL_Texture *ptr;
};

struct GLContext : private noncopyable {
  GLContext();
  ~GLContext();
  const Init ini;
  SDL_GLContext ptr;
};

struct KeyboardState : private noncopyable {
  KeyboardState();
  const Uint8 *keyboardstate;
  int num;
  const Init ini;
private:
};

}; // namespace SDL2
;

extern "implementation" inline
namespace SDL2 {
using namespace pxcrt;

int Init::init_count = 0;

Init::Init(Uint32 flags)
{
  if (++init_count == 1) {
    SDL_Init(flags);
  }
}

Init::Init()
{
  if (++init_count == 1) {
    SDL_Init(0);
  }
}

Init::~Init()
{
  if (--init_count == 0) {
    SDL_Quit();
  }
}

Init::Init(Init const& x)
{
  ++init_count;
}

Window::Window()
  : ptr(0)
{
}

Window::~Window()
{
  if (ptr != 0) {
    SDL_DestroyWindow(ptr);
  }
}

bt_int CreateWindow(Window& wnd, cstrref const& title, bt_int x, bt_int y,
  bt_int w, bt_int h, Uint32 f)
{
  PXCRT_ALLOCA_NTSTRING(title_nt, title);
  wnd.ptr = SDL_CreateWindow(title_nt.get(), x, y, w, h, f);
  return (wnd.ptr != 0) ? 0 : -1;
}

typedef rcptr< rcval<Window> > Window_ptr;

void GetWindowSize(Window_ptr const& wnd, int& w, int& h)
{
  SDL_GetWindowSize(wnd->value.ptr, &w, &h);
}

Renderer::Renderer()
  : ptr(0)
{
}

Renderer::~Renderer()
{
  if (ptr != 0) {
    SDL_DestroyRenderer(ptr);
  }
}

bt_int CreateRenderer(Renderer& rnd, Window const& wnd, int index, Uint32 f)
{
  rnd.ptr = SDL_CreateRenderer(wnd.ptr, index, f);
  return (rnd.ptr != 0) ? 0 : -1;
}

Surface::Surface()
  : ptr(0)
{
}

Surface::~Surface()
{
  if (ptr != 0) {
    SDL_FreeSurface(ptr);
  }
}

bt_int LoadBMP(Surface& sur, cstrref const& filename)
{
  PXCRT_ALLOCA_NTSTRING(filename_nt, filename);
  sur.ptr = SDL_LoadBMP(filename_nt.get());
  return (sur.ptr != 0) ? 0 : -1;
}

typedef rcptr< rcval<Surface> > Surface_ptr;

bt_uint Surface_W(Surface_ptr const& sur)
{
  return sur->value.ptr->w;
}

bt_uint Surface_H(Surface_ptr const& sur)
{
  return sur->value.ptr->h;
}

bt_uint Surface_Pitch(Surface_ptr const& sur)
{
  return sur->value.ptr->pitch;
}

bt_uint Surface_BytesPerPixel(Surface_ptr const& sur)
{
  return sur->value.ptr->format->BytesPerPixel;
}

strref Surface_Pixels(Surface_ptr const& sur)
{
  SDL_Surface *const p = sur->value.ptr;
  size_t const len = p->pitch * p->h;
  return strref(static_cast<unsigned char *>(sur->value.ptr->pixels), len);
}

Texture::Texture()
  : ptr(0)
{
}

Texture::~Texture()
{
  if (ptr != 0) {
    SDL_DestroyTexture(ptr);
  }
}

typedef rcptr< rcval<Renderer> > Renderer_ptr;
typedef rcptr< rcval<Surface> > Surface_ptr;

bt_int CreateTextureFromSurface(Texture& tx, Renderer_ptr const& rnd,
  Surface_ptr const& sur)
{
  tx.ptr = SDL_CreateTextureFromSurface(rnd->value.ptr, sur->value.ptr);
  return (tx.ptr != 0) ? 0 : -1;
}

typedef rcptr< rcval<Texture> > Texture_ptr;

bt_int RenderClear(Renderer_ptr const& rnd)
{
  return SDL_RenderClear(rnd->value.ptr);
}

void RenderPresent(Renderer_ptr const& rnd)
{
  SDL_RenderPresent(rnd->value.ptr);
}

bt_int RenderCopy(Renderer_ptr const& rnd, Texture_ptr const& tx,
  SDL_Rect const& src, SDL_Rect const& dst)
{
  return SDL_RenderCopy(rnd->value.ptr, tx->value.ptr, &src, &dst);
}

GLContext::GLContext()
  : ptr(0)
{
}

GLContext::~GLContext()
{
  if (ptr != 0) {
    ::SDL_GL_DeleteContext(ptr);
  }
}

bt_int GL_CreateContext(GLContext& glctx, Window const& wnd)
{
  glctx.ptr = SDL_GL_CreateContext(wnd.ptr);
  return (glctx.ptr != 0) ? 0 : -1;
}

KeyboardState::KeyboardState()
{
  keyboardstate = ::SDL_GetKeyboardState(&num);
}

bt_bool PollEvent(SDL_Event& ev)
{
  return ::SDL_PollEvent(&ev);
}

void GL_SwapWindow(Window_ptr const& wnd)
{
  ::SDL_GL_SwapWindow(wnd->value.ptr);
}

SDL_EventType Event_Type(SDL_Event const& e)
{
  return SDL_EventType(e.type);
}

SDL_WindowEventID Event_WindowEventID(SDL_Event const& e)
{
  return static_cast<SDL_WindowEventID>(e.window.event);
}

bt_int Event_WindowEventData1(SDL_Event const& e)
{
  return e.window.data1;
}

bt_int Event_WindowEventData2(SDL_Event const& e)
{
  return e.window.data2;
}

bt_uchar Event_KeyboardEventState(SDL_Event const& e)
{
  return e.key.state;
}

bt_uchar Event_KeyboardEventRepeat(SDL_Event const& e)
{
  return e.key.repeat;
}

bt_uint KeyboardState_Key(KeyboardState const& ks, SDL_Scancode key)
{
  if (key < ks.num) {
    return ks.keyboardstate[key];
  } else {
    return 0;
  }
}

void Log(cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_Log("%s", mess_nt.get());
}

void LogInfo(int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogInfo(cat, "%s", mess_nt.get());
}

void LogWarn(int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogWarn(cat, "%s", mess_nt.get());
}

void LogError(int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogError(cat, "%s", mess_nt.get());
}

}; // namespace SDL2
;

