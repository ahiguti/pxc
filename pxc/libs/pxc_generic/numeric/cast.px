namespace numeric::cast;
public import numeric::integral -;
public import numeric::fp -;
public import meta m;

public metafunction is_numeric{t}
  is_numeric_family{t, m::family{t}};
public metafunction is_numeric_enum_bitmask{t}
  is_numeric_enum_bitmask_family{t, m::family{t}};
public metafunction is_integral{t}
  is_integral_family{t, m::family{t}};
public metafunction is_integral_enum_bitmask{t}
  is_integral_enum_bitmask_family{t, m::family{t}};
public metafunction is_signed_integral{t}
  is_signed_integral_family{t, m::family{t}};
public metafunction is_unsigned_integral{t}
  is_unsigned_integral_family{t, m::family{t}};
public metafunction is_unsigned_integral_enum_bitmask{t}
  is_unsigned_integral_enum_bitmask_family{t, m::family{t}};
public metafunction is_enum{t}
  is_enum_family{t, m::family{t}};
public metafunction is_bitmask{t}
  is_bitmask_family{t, m::family{t}};
public metafunction is_fp{t} is_fp_family{t, m::family{t}};

public threaded function {tto, tfrom} tto numeric_cast(tfrom const& x)
{
  if (m::and{is_numeric_enum_bitmask{tfrom}, is_numeric_enum_bitmask{tto}}) {
    numeric_cast_impl{tto, tfrom} c;
    return c.convert(x);
  } else {
    return m::error{"invalid numeric cast"};
  }
}

public threaded function {tto, tfrom} tto static_cast(tfrom const& x)
{
  if (m::and{is_numeric_enum_bitmask{tfrom}, is_numeric_enum_bitmask{tto}}) {
    static_cast_impl{tto, tfrom} c;
    return c.convert(x);
  } else {
    return m::error{"invalid numeric cast"};
  }
}

private metafunction is_signed_integral_family{t, fam}
  m::or{
    m::eq{t, char},
    m::eq{t, short},
    m::eq{t, int},
    m::eq{t, long},
    m::eq{fam, "extint"}};

private metafunction is_unsigned_integral_family{t, fam}
  m::or{
    m::eq{t, uchar},
    m::eq{t, ushort},
    m::eq{t, uint},
    m::eq{t, ulong},
    m::eq{t, size_t},
    m::eq{fam, "extuint"}};

private metafunction is_enum_family{t, fam}
  m::or{
    m::eq{fam, "enum"},
    m::eq{fam, "extenum"}};

private metafunction is_bitmask_family{t, fam}
  m::or{
    m::eq{fam, "bitmask"},
    m::eq{fam, "extbitmask"}};

private metafunction is_unsigned_integral_enum_bitmask_family{t, fam}
  m::or{
    is_unsigned_integral_family{t, fam},
    is_enum_family{t, fam},
    is_bitmask_family{t, fam}};

private metafunction is_integral_family{t, fam}
  m::or{
    is_signed_integral_family{t, fam},
    is_unsigned_integral_family{t, fam}};

private metafunction is_integral_enum_bitmask_family{t, fam}
  m::or{
    is_integral_family{t, fam},
    is_enum_family{t, fam},
    is_bitmask_family{t, fam}};

private metafunction is_fp_family{t, fam}
  m::or{
    m::eq{t, float},
    m::eq{t, double},
    m::eq{fam, "extfloat"}};

private metafunction is_numeric_family{t, fam}
  m::or{
    is_integral_family{t, fam},
    is_fp_family{t, fam},
    m::eq{fam, "extnumeric"}};

private metafunction is_numeric_enum_bitmask_family{t, fam}
  m::or{
    is_numeric_family{t, fam},
    is_enum_family{t, fam},
    is_bitmask_family{t, fam}};

private threaded struct extern "numeric::numeric_cast_impl" {tto, tfrom}
numeric_cast_impl {
  function extern "convert" tto convert(tfrom const& x);
}

private threaded struct extern "numeric::static_cast_impl" {tto, tfrom}
static_cast_impl {
  function extern "convert" tto convert(tfrom const& x);
}

extern "types" inline
#include <boost/cast.hpp>
namespace numeric {
template <typename Tto, typename Tfrom> struct numeric_cast_impl {
  Tto convert(Tfrom const& x) const {
    return boost::numeric_cast<Tto>(x);
  }
};
template <typename Tto, typename Tfrom> struct static_cast_impl {
  Tto convert(Tfrom const& x) const {
    return static_cast<Tto>(x);
  }
};
}; // namespace numeric
;

