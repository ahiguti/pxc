public threaded namespace GL::glm "use-unsafe";
public import common -;
public import meta m;
private import pointer::raw -;

public metafunction vec2 tvec2{float};
public metafunction vec3 tvec3{float};
public metafunction vec4 tvec4{float};
public metafunction mat2 tmat2{float};
public metafunction mat3 tmat3{float};
public metafunction mat4 tmat4{float};
public metafunction quat tquat{float};

public tsvaluetype struct extern "pxcglm::tvec2<>::type" {t} tvec2 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public t x;
  public t y;
}

public tsvaluetype struct extern "pxcglm::tvec3<>::type" {t} tvec3 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public t x;
  public t y;
  public t z;
}

public tsvaluetype struct extern "pxcglm::tvec3<>::type" {t} tvec4 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public t x;
  public t y;
  public t z;
  public t w;
}

public tsvaluetype struct extern "pxcglm::tquat<>::type" {t} tquat {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public t x;
  public t y;
  public t z;
  public t w;
}

public tsvaluetype struct extern "pxcglm::tmat2<>::type" {t} tmat2 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public metafunction varray_type tvec2{t};
}

public tsvaluetype struct extern "pxcglm::tmat3<>::type" {t} tmat3 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public metafunction varray_type tvec3{t};
}

public tsvaluetype struct extern "pxcglm::tmat4<>::type" {t} tmat4 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public metafunction varray_type tvec4{t};
}

public metafunction make_vec2 make_tvec2{float};
public metafunction make_vec3 make_tvec3{float};
public metafunction make_vec4 make_tvec4{float};
public metafunction make_mat2 make_tmat2{float};
public metafunction make_mat3 make_tmat3{float};
public metafunction make_mat4 make_tmat4{float};
public metafunction make_quat_wxyz make_tquat_wxyz{float};
public metafunction make_quat_angle_axis make_tquat_angle_axis{float};

public threaded function extern "pxcglm::make_tvec2" {t}
tvec2{t} make_tvec2(t x, t y);
public threaded function extern "pxcglm::make_tvec3" {t}
tvec3{t} make_tvec3(t x, t y, t z);
public threaded function extern "pxcglm::make_tvec4" {t}
tvec4{t} make_tvec4(t x, t y, t z, t w);
public threaded function extern "pxcglm::make_tmat2" {t}
tmat2{t} make_tmat2(t x);
public threaded function extern "pxcglm::make_tmat3" {t}
tmat3{t} make_tmat3(t x);
public threaded function extern "pxcglm::make_tmat4" {t}
tmat4{t} make_tmat4(t x);
public threaded function extern "pxcglm::make_tquat_wxyz" {t}
tquat{t} make_tquat_wxyz(t w, t x, t y, t z);
public threaded function extern "pxcglm::make_tquat_angle_axis" {t}
tquat{t} make_tquat_angle_axis(t angle_degrees, t x, t y, t z);

public threaded function extern "pxcglm::tvec2_cslice" {t}
cslice{t} tvec2_cslice(tvec2{t} const& x);
public threaded function extern "pxcglm::tvec3_cslice" {t}
cslice{t} tvec3_cslice(tvec3{t} const& x);
public threaded function extern "pxcglm::tvec4_cslice" {t}
cslice{t} tvec4_cslice(tvec4{t} const& x);
public threaded function extern "pxcglm::tmat2_cslice" {t}
cslice{t} tmat2_cslice(tmat2{t} const& x);
public threaded function extern "pxcglm::tmat3_cslice" {t}
cslice{t} tmat3_cslice(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat4_cslice" {t}
cslice{t} tmat4_cslice(tmat4{t} const& x);
public threaded function extern "pxcglm::tquat_cslice" {t}
cslice{t} tquat_cslice(tquat{t} const& x);

public threaded function extern "pxcglm::tvec2_slice" {t}
slice{t} tvec2_slice(tvec2{t} mutable& x);
public threaded function extern "pxcglm::tvec3_slice" {t}
slice{t} tvec3_slice(tvec3{t} mutable& x);
public threaded function extern "pxcglm::tvec4_slice" {t}
slice{t} tvec4_slice(tvec4{t} mutable& x);
public threaded function extern "pxcglm::tmat2_slice" {t}
slice{t} tmat2_slice(tmat2{t} mutable& x);
public threaded function extern "pxcglm::tmat3_slice" {t}
slice{t} tmat3_slice(tmat3{t} mutable& x);
public threaded function extern "pxcglm::tmat4_slice" {t}
slice{t} tmat4_slice(tmat4{t} mutable& x);
public threaded function extern "pxcglm::tquat_slice" {t}
slice{t} tquat_slice(tquat{t} mutable& x);

public threaded function extern "pxcglm::tvec2_crawptr" {t}
crawptr{t} tvec2_crawptr(tvec2{t} const& x);
public threaded function extern "pxcglm::tvec3_crawptr" {t}
crawptr{t} tvec3_crawptr(tvec3{t} const& x);
public threaded function extern "pxcglm::tvec4_crawptr" {t}
crawptr{t} tvec4_crawptr(tvec4{t} const& x);
public threaded function extern "pxcglm::tmat2_crawptr" {t}
crawptr{t} tmat2_crawptr(tmat2{t} const& x);
public threaded function extern "pxcglm::tmat3_crawptr" {t}
crawptr{t} tmat3_crawptr(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat4_crawptr" {t}
crawptr{t} tmat4_crawptr(tmat4{t} const& x);
public threaded function extern "pxcglm::tquat_crawptr" {t}
crawptr{t} tquat_crawptr(tquat{t} const& x);

public threaded function extern "pxcglm::tvec2_rawptr" {t}
rawptr{t} tvec2_rawptr(tvec2{t} mutable& x);
public threaded function extern "pxcglm::tvec3_rawptr" {t}
rawptr{t} tvec3_rawptr(tvec3{t} mutable& x);
public threaded function extern "pxcglm::tvec4_rawptr" {t}
rawptr{t} tvec4_rawptr(tvec4{t} mutable& x);
public threaded function extern "pxcglm::tmat2_rawptr" {t}
rawptr{t} tmat2_rawptr(tmat2{t} mutable& x);
public threaded function extern "pxcglm::tmat3_rawptr" {t}
rawptr{t} tmat3_rawptr(tmat3{t} mutable& x);
public threaded function extern "pxcglm::tmat4_rawptr" {t}
rawptr{t} tmat4_rawptr(tmat4{t} mutable& x);
public threaded function extern "pxcglm::tquat_rawptr" {t}
rawptr{t} tquat_rawptr(tquat{t} mutable& x);

public threaded function extern "pxcglm::tvec2_to_farray" {t}
farray{t, 2} tvec2_to_farray(tvec2{t} const& x);
public threaded function extern "pxcglm::tvec3_to_farray" {t}
farray{t, 3} tvec3_to_farray(tvec3{t} const& x);
public threaded function extern "pxcglm::tvec4_to_farray" {t}
farray{t, 4} tvec4_to_farray(tvec4{t} const& x);
public threaded function extern "pxcglm::tmat2_to_farray" {t}
farray{t, 4} tmat2_to_farray(tmat2{t} const& x);
public threaded function extern "pxcglm::tmat3_to_farray" {t}
farray{t, 9} tmat3_to_farray(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat4_to_farray" {t}
farray{t, 16} tmat4_to_farray(tmat4{t} const& x);
public threaded function extern "pxcglm::tquat_to_farray" {t}
farray{t, 4} tquat_to_farray(tmat4{t} const& x);

public metafunction tvec2___add{tx, ty} op_add{tx};
public metafunction tvec3___add{tx, ty} op_add{tx};
public metafunction tvec4___add{tx, ty} op_add{tx};
public metafunction tquat___add{tx, ty} op_add{tx};

public metafunction tvec2___adda{tx, ty} op_adda{tx};
public metafunction tvec3___adda{tx, ty} op_adda{tx};
public metafunction tvec4___adda{tx, ty} op_adda{tx};
public metafunction tquat___adda{tx, ty} op_adda{tx};

public metafunction tvec2___sub{tx, ty} op_sub{tx};
public metafunction tvec3___sub{tx, ty} op_sub{tx};
public metafunction tvec4___sub{tx, ty} op_sub{tx};
public metafunction tquat___sub{tx, ty} op_sub{tx};

public metafunction tvec2___suba{tx, ty} op_suba{tx};
public metafunction tvec3___suba{tx, ty} op_suba{tx};
public metafunction tvec4___suba{tx, ty} op_suba{tx};
public metafunction tquat___suba{tx, ty} op_suba{tx};

public metafunction tvec2___eq{tx, ty} op_eq{tx};
public metafunction tvec3___eq{tx, ty} op_eq{tx};
public metafunction tvec4___eq{tx, ty} op_eq{tx};
public metafunction tquat___eq{tx, ty} op_eq{tx};

public metafunction tvec2___ne{tx, ty} op_ne{tx};
public metafunction tvec3___ne{tx, ty} op_ne{tx};
public metafunction tvec4___ne{tx, ty} op_ne{tx};
public metafunction tquat___ne{tx, ty} op_ne{tx};

public metafunction tvec2___minus{tx} op_minus{tx};
public metafunction tvec3___minus{tx} op_minus{tx};
public metafunction tvec4___minus{tx} op_minus{tx};
public metafunction tquat___minus{tx} op_minus{tx};

public metafunction tvec2___mul{tx, ty} op_mul{tx, ty, tx};
public metafunction tvec3___mul{tx, ty} op_mul{tx, ty, tx};
public metafunction tvec4___mul{tx, ty} op_mul{tx, ty, tx};
public metafunction tmat2___mul{tx, ty} op_mul{tx, ty, ty};
public metafunction tmat3___mul{tx, ty} op_mul{tx, ty, ty};
public metafunction tmat4___mul{tx, ty} op_mul{tx, ty, ty};
public metafunction tquat___mul{tx, ty} op_mul{tx, ty, ty};

public metafunction tvec2___div{tx, ty} op_div{tx, ty};
public metafunction tvec3___div{tx, ty} op_div{tx, ty};
public metafunction tvec4___div{tx, ty} op_div{tx, ty};
public metafunction tquat___div{tx, ty} op_div{tx, ty};

private threaded function extern "pxcglm::op_add" {t}
check_tvec_tquat_type{t} op_add(t const& x, t const& y);
private threaded function extern "pxcglm::op_sub" {t}
check_tvec_tquat_type{t} op_sub(t const& x, t const& y);
private threaded function extern "pxcglm::op_add" {t}
m::cond{check_tvec_tquat_type{t}, void, void}
op_adda(t mutable& x, t const& y);
private threaded function extern "pxcglm::op_sub" {t}
m::cond{check_tvec_tquat_type{t}, void, void}
op_suba(t mutable& x, t const& y);
private threaded function extern "pxcglm::op_eq" {t}
m::cond{check_tvec_tquat_type{t}, bool, bool}
op_eq(t const& x, t const& y);
private threaded function extern "pxcglm::op_ne" {t}
m::cond{check_tvec_tquat_type{t}, bool, bool}
op_ne(t const& x, t const& y);
private threaded function extern "pxcglm::op_minus" {t}
check_tvec_tquat_type{t}
op_minus(t const& x);

public threaded function extern "pxcglm::length" {t}
m::symbol{check_tvec_tquat_type{t}, "value_type"} length(t const& x);

public threaded function extern "pxcglm::dot" {t}
m::symbol{check_tvec_tquat_type{t}, "value_type"} dot(t const& x, t const& y);

public threaded function extern "pxcglm::distance" {t}
m::symbol{check_tvec_type{t}, "value_type"} distance(t const& x, t const& y);

public threaded function extern "glm::normalize" {t}
tvec2{t} tvec2_normalize(tvec2{t} const& x);
public threaded function extern "glm::normalize" {t}
tvec3{t} tvec3_normalize(tvec3{t} const& x);
public threaded function extern "glm::normalize" {t}
tvec4{t} tvec4_normalize(tvec4{t} const& x);
public threaded function extern "glm::normalize" {t}
tquat{t} tquat_normalize(tquat{t} const& x);

public threaded function extern "glm::cross" {t}
tvec3{t} cross(tvec3{t} const& x, tvec3{t} const& y);

public threaded function extern "glm::determinant" {t}
t tmat2_determinant(tmat2{t} const& x);
public threaded function extern "glm::determinant" {t}
t tmat3_determinant(tmat3{t} const& x);
public threaded function extern "glm::determinant" {t}
t tmat4_determinant(tmat4{t} const& x);

public threaded function extern "pxcglm::tmat2_to_3" {t}
tmat3{t} tmat2_to_3(tmat2{t} const& x);
public threaded function extern "pxcglm::tmat3_to_2" {t}
tmat2{t} tmat3_to_2(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat3_to_4" {t}
tmat4{t} tmat3_to_4(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat4_to_3" {t}
tmat3{t} tmat4_to_3(tmat4{t} const& x);

public threaded function extern "glm::mat3_cast" {t}
tmat3{t} tquat_to_mat3(tquat{t} const& x);
public threaded function extern "glm::mat4_cast" {t}
tmat4{t} tquat_to_mat4(tquat{t} const& x);

public threaded function extern "glm::quat_cast" {t}
tquat{t} mat3_to_tquat(tmat3{t} const& x);
public threaded function extern "glm::quat_cast" {t}
tquat{t} mat4_to_tquat(tmat4{t} const& x);

public threaded function extern "glm::rotate" {t}
tmat2{t} tmat2_rotate(tmat2{t} const& x, t angle, tvec2{t} const& axis);
public threaded function extern "glm::rotate" {t}
tmat3{t} tmat3_rotate(tmat3{t} const& x, t angle, tvec3{t} const& axis);
public threaded function extern "glm::rotate" {t}
tmat4{t} tmat4_rotate(tmat4{t} const& x, t angle, tvec3{t} const& axis);

public threaded function extern "glm::transpose" {t}
tmat2{t} tmat2_transpose(tmat2{t} const& x);
public threaded function extern "glm::transpose" {t}
tmat3{t} tmat3_transpose(tmat3{t} const& x);
public threaded function extern "glm::transpose" {t}
tmat4{t} tmat4_transpose(tmat4{t} const& x);

public threaded function extern "glm::inverse" {t}
tmat2{t} tmat2_inverse(tmat2{t} const& x);
public threaded function extern "glm::inverse" {t}
tmat3{t} tmat3_inverse(tmat3{t} const& x);
public threaded function extern "glm::inverse" {t}
tmat4{t} tmat4_inverse(tmat4{t} const& x);
public threaded function extern "glm::inverse" {t}
tquat{t} tquat_inverse(tquat{t} const& x);

public threaded function extern "glm::conjugate" {t}
tquat{t} tquat_conjugate(tquat{t} const& x);

public threaded function extern "glm::scale" {t}
tmat4{t} tmat4_scale(tmat4{t} const& m, tvec3{t} const& fa);

public threaded function extern "glm::translate" {t}
tmat4{t} tmat4_translate(tmat4{t} const& m, tvec3{t} const& tr);

public threaded function extern "glm::frustum" {t}
tmat4{t} frustum(t left, t right, t bottom, t top, t near, t far);

public threaded function extern "glm::ortho" {t}
tmat4{t} ortho(t left, t right, t bottom, t top, t near, t far);

public threaded function extern "glm::lookAt" {t}
tmat4{t} lookAt(tvec3{t} const& e, tvec3{t} const& c, tvec3{t} const& u);

public threaded function extern "glm::ortho" {t}
tmat4{t} ortho2D(t left, t right, t bottom, t top);

public threaded function extern "glm::perspective" {t}
tmat4{t} perspective(t fovy, t aspect, t zNear, t zFar);

/* private */

private threaded function extern "pxcglm::op_mul" {tx, ty, tr}
check_mul_type{tx, ty} op_mul(tx const& x, ty const& y);

private metafunction check_mul_type{tx, ty}
  m::cond{
    /* (mat * mat) or (mat * vec) */
    m::and{is_tmat_type{tx},
      m::or{
	m::eq{tx, ty},
	m::eq{m::symbol{tx, "varray_type"}, ty}}},
    ty,
    /* (vec * sca) */
    m::and{is_tvec_type{tx}, m::eq{m::symbol{tx, "value_type"}, ty}},
    tx,
    /* (quat * quat) */
    m::and{is_tquat_type{tx}, m::eq{tx, ty}},
    tx,
    m::error{m::concat{ty, ": invalid type for operator mul"}}};

private threaded function extern "pxcglm::op_div" {tx, ty}
check_div_type{tx, ty} op_div(tx const& x, ty const& y);

private metafunction check_div_type{tx, ty}
  m::cond{
    /* (vec / sca) */
    m::and{is_tvec_type{tx}, m::eq{m::symbol{tx, "value_type"}, ty}},
    tx, 
    m::error{m::concat{ty, ": invalid type for operator div"}}};

private metafunction check_param_type{t}
  m::cond{
    is_param_type{t},
    t,
    m::error{m::concat{t, ": invalid type (float or double expected)"}}};

private metafunction check_tvec_type{t}
  m::cond{
    is_tvec_type{t},
    t,
    m::error{m::concat{t, ": invalid type (tvec expected)"}}};

private metafunction check_tvec_tquat_type{t}
  m::cond{
    is_tvec_type{t},
    t,
    is_tquat_type{t},
    t,
    m::error{m::concat{t, ": invalid type (tvec or tquat expected)"}}};

private metafunction check_tmat_type{t}
  m::cond{
    is_tmat_type{t},
    t,
    m::error{m::concat{t, ": invalid type (tmat expected)"}}};

private metafunction is_param_type{t}
  m::or{m::eq{t, float}, m::eq{t, double}};

private metafunction is_tvec_type{t}
  m::and{
    m::or{
      m::eq{m::nameof{t}, "GL::glm::tvec2"},
      m::eq{m::nameof{t}, "GL::glm::tvec3"},
      m::eq{m::nameof{t}, "GL::glm::tvec4"}},
    is_param_type{m::symbol{t, "value_type"}}};

private metafunction is_tmat_type{t}
  m::and{
    m::or{
      m::eq{m::nameof{t}, "GL::glm::tmat2"},
      m::eq{m::nameof{t}, "GL::glm::tmat3"},
      m::eq{m::nameof{t}, "GL::glm::tmat4"}},
    is_param_type{m::symbol{t, "value_type"}}};

private metafunction is_tquat_type{t}
  m::and{
    m::eq{m::nameof{t}, "GL::glm::tquat"},
    is_param_type{m::symbol{t, "value_type"}}};

extern "types" inline

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/quaternion.hpp>

namespace pxcglm {

template <typename T> struct tvec2 {
  typedef glm::vec2 type;
};
template <typename T> struct tvec3 {
  typedef glm::vec3 type;
};
template <typename T> struct tvec4 {
  typedef glm::vec4 type;
};
template <typename T> struct tmat2 {
  typedef glm::mat2 type;
};
template <typename T> struct tmat3 {
  typedef glm::mat3 type;
};
template <typename T> struct tmat4 {
  typedef glm::mat4 type;
};
template <typename T> struct tquat {
  typedef glm::quat type;
};

};

;

extern "functions" inline

namespace pxcglm {

template <typename T> static inline typename tvec2<T>::type
make_tvec2(T x, T y)
{ return typename tvec2<T>::type(x, y); }
template <typename T> static inline typename tvec3<T>::type
make_tvec3(T x, T y, T z)
{ return typename tvec3<T>::type(x, y, z); }
template <typename T> static inline typename tvec4<T>::type
make_tvec4(T x, T y, T z, T w)
{ return typename tvec4<T>::type(x, y, z, w); }
template <typename T> static inline typename tmat2<T>::type
make_tmat2(T x)
{ return typename tmat2<T>::type(x); }
template <typename T> static inline typename tmat3<T>::type
make_tmat3(T x)
{ return typename tmat3<T>::type(x); }
template <typename T> static inline typename tmat4<T>::type
make_tmat4(T x)
{ return typename tmat4<T>::type(x); }
template <typename T> static inline typename tquat<T>::type
make_tquat_wxyz(T w, T x, T y, T z)
{ return typename tquat<T>::type(w, x, y, z); }
template <typename T> static inline typename tquat<T>::type
make_tquat_angle_axis(T angle_degrees, T x, T y, T z)
{ return glm::angleAxis(angle_degrees, typename tvec3<T>::type(x, y, z)); }

template <typename T> static inline pxcrt::bt_cslice<T>
tvec2_cslice(typename tvec2<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 2); }
template <typename T> static inline pxcrt::bt_cslice<T>
tvec3_cslice(typename tvec3<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 3); }
template <typename T> static inline pxcrt::bt_cslice<T>
tvec4_cslice(typename tvec4<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat2_cslice(typename tmat2<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat3_cslice(typename tmat3<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 9); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat4_cslice(typename tmat4<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 16); }
template <typename T> static inline pxcrt::bt_cslice<T>
tquat_cslice(typename tquat<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }

template <typename T> static inline pxcrt::bt_slice<T>
tvec2_slice(typename tvec2<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 2); }
template <typename T> static inline pxcrt::bt_slice<T>
tvec3_slice(typename tvec3<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 3); }
template <typename T> static inline pxcrt::bt_slice<T>
tvec4_slice(typename tvec4<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat2_slice(typename tmat2<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat3_slice(typename tmat3<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 9); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat4_slice(typename tmat4<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 16); }
template <typename T> static inline pxcrt::bt_slice<T>
tquat_slice(typename tquat<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }

template <typename T> static inline T const *
tvec2_crawptr(typename tvec2<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tvec3_crawptr(typename tvec3<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tvec4_crawptr(typename tvec4<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat2_crawptr(typename tmat2<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat3_crawptr(typename tmat3<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat4_crawptr(typename tmat4<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tquat_crawptr(typename tquat<T>::type const& x)
{ return glm::value_ptr(x); }

template <typename T> static inline T *
tvec2_rawptr(typename tvec2<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tvec3_rawptr(typename tvec3<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tvec4_rawptr(typename tvec4<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat2_rawptr(typename tmat2<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat3_rawptr(typename tmat3<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat4_rawptr(typename tmat4<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tquat_rawptr(typename tquat<T>::type& x)
{ return glm::value_ptr(x); }

template <typename T> static inline pxcrt::farray<T, 2>
tvec2_to_farray(typename tvec2<T>::type const& x)
{
  pxcrt::farray<T, 2> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 2 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 3>
tvec3_to_farray(typename tvec3<T>::type const& x)
{
  pxcrt::farray<T, 3> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 3 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 4>
tvec4_to_farray(typename tvec4<T>::type const& x)
{
  pxcrt::farray<T, 4> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 4 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 4>
tmat2_to_farray(typename tmat2<T>::type const& x)
{
  pxcrt::farray<T, 4> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 4 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 9>
tmat3_to_farray(typename tmat3<T>::type const& x)
{
  pxcrt::farray<T, 9> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 9 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 16>
tmat4_to_farray(typename tmat4<T>::type const& x)
{
  pxcrt::farray<T, 16> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 16 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 4>
tquat_to_farray(typename tquat<T>::type const& x)
{
  pxcrt::farray<T, 4> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 4 * sizeof(T));
  return r;
}

template <typename T> static inline typename tmat3<T>::type
tmat2_to_3(typename tmat2<T>::type const& x)
{ return typename tmat3<T>::type(x); }

template <typename T> static inline typename tmat2<T>::type
tmat3_to_2(typename tmat3<T>::type const& x)
{ return typename tmat2<T>::type(x); }

template <typename T> static inline typename tmat4<T>::type
tmat3_to_4(typename tmat3<T>::type const& x)
{ return typename tmat4<T>::type(x); }

template <typename T> static inline typename tmat3<T>::type
tmat4_to_3(typename tmat4<T>::type const& x)
{ return typename tmat3<T>::type(x); }

template <typename T> static inline T op_add(T const& x, T const& y)
{ return x + y; }

template <typename T> static inline T op_sub(T const& x, T const& y)
{ return x - y; }

template <typename T> static inline void op_adda(T& x, T const& y)
{ x += y; }

template <typename T> static inline void op_suba(T& x, T const& y)
{ x -= y; }

template <typename T> static inline bool op_eq(T const& x, T const& y)
{ return x == y; }

template <typename T> static inline bool op_ne(T const& x, T const& y)
{ return x != y; }

template <typename T> static inline T op_minus(T const& x)
{ return -x; }

template <typename Tx, typename Ty, typename Tr> static inline Tr
op_mul(Tx const& x, Ty const& y)
{ return x * y; }

template <typename Tx, typename Ty> static inline Tx
op_div(Tx const& x, Ty const& y)
{ return x / y; }

template <typename T> static inline typename T::value_type
length(T const& x, T const& y) { return glm::length(x, y); }

template <typename T> static inline typename T::value_type
distance(T const& x, T const& y) { return glm::distance(x, y); }

template <typename T> static inline typename T::value_type
dot(T const& x, T const& y) { return glm::dot(x, y); }

};

;

