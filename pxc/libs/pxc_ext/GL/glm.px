public threaded namespace GL::glm "use-unsafe";
public import common -;
public import meta m;

public metafunction vec2 tvec2{float};
public metafunction vec3 tvec3{float};
public metafunction vec4 tvec4{float};
public metafunction mat2 tmat2{float};
public metafunction mat3 tmat3{float};
public metafunction mat4 tmat4{float};

public tsvaluetype struct extern "glm::detail::tvec2" {t} tvec2 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public t x;
  public t y;
}

public tsvaluetype struct extern "glm::detail::tvec3" {t} tvec3 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public t x;
  public t y;
  public t z;
}

public tsvaluetype struct extern "glm::detail::tvec4" {t} tvec4 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public t x;
  public t y;
  public t z;
  public t w;
}

public tsvaluetype struct extern "glm::detail::tmat2x2" {t} tmat2 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public metafunction vector_type tvec2{t};
}

public tsvaluetype struct extern "glm::detail::tmat3x3" {t} tmat3 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public metafunction vector_type tvec3{t};
}

public tsvaluetype struct extern "glm::detail::tmat4x4" {t} tmat4 {
  public metafunction __static_assert__ check_param_type{t};
  public metafunction value_type t;
  public metafunction vector_type tvec4{t};
}

public metafunction make_vec2 make_tvec2{float};
public metafunction make_vec3 make_tvec3{float};
public metafunction make_vec4 make_tvec4{float};
public metafunction make_mat2 make_tmat2{float};
public metafunction make_mat3 make_tmat3{float};
public metafunction make_mat4 make_tmat4{float};

public threaded function extern "pxcglm::make_tvec2" {t}
tvec2{t} make_tvec2(t x, t y);
public threaded function extern "pxcglm::make_tvec3" {t}
tvec3{t} make_tvec3(t x, t y, t z);
public threaded function extern "pxcglm::make_tvec4" {t}
tvec4{t} make_tvec4(t x, t y, t z, t w);
public threaded function extern "pxcglm::make_tmat2" {t}
tmat2{t} make_tmat2(t x);
public threaded function extern "pxcglm::make_tmat3" {t}
tmat3{t} make_tmat3(t x);
public threaded function extern "pxcglm::make_tmat4" {t}
tmat4{t} make_tmat4(t x);

public threaded function extern "pxcglm::tvec2_cslice" {t}
cslice{t} tvec2_cslice(tvec2{t} const& x);
public threaded function extern "pxcglm::tvec3_cslice" {t}
cslice{t} tvec3_cslice(tvec3{t} const& x);
public threaded function extern "pxcglm::tvec4_cslice" {t}
cslice{t} tvec4_cslice(tvec4{t} const& x);
public threaded function extern "pxcglm::tmat2_cslice" {t}
cslice{t} tmat2_cslice(tmat2{t} const& x);
public threaded function extern "pxcglm::tmat3_cslice" {t}
cslice{t} tmat3_cslice(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat4_cslice" {t}
cslice{t} tmat4_cslice(tmat4{t} const& x);
public threaded function extern "pxcglm::tvec2_slice" {t}
slice{t} tvec2_slice(tvec2{t} mutable& x);
public threaded function extern "pxcglm::tvec3_slice" {t}
slice{t} tvec3_slice(tvec3{t} mutable& x);
public threaded function extern "pxcglm::tvec4_slice" {t}
slice{t} tvec4_slice(tvec4{t} mutable& x);
public threaded function extern "pxcglm::tmat2_slice" {t}
slice{t} tmat2_slice(tmat2{t} mutable& x);
public threaded function extern "pxcglm::tmat3_slice" {t}
slice{t} tmat3_slice(tmat3{t} mutable& x);
public threaded function extern "pxcglm::tmat4_slice" {t}
slice{t} tmat4_slice(tmat4{t} mutable& x);

public threaded function extern "pxcglm::tvec2_crawptr" {t}
crawptr{t} tvec2_crawptr(tvec2{t} const& x);
public threaded function extern "pxcglm::tvec3_crawptr" {t}
crawptr{t} tvec3_crawptr(tvec3{t} const& x);
public threaded function extern "pxcglm::tvec4_crawptr" {t}
crawptr{t} tvec4_crawptr(tvec4{t} const& x);
public threaded function extern "pxcglm::tmat3_crawptr" {t}
crawptr{t} tmat3_crawptr(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat4_crawptr" {t}
crawptr{t} tmat4_crawptr(tmat4{t} const& x);
public threaded function extern "pxcglm::tvec2_rawptr" {t}
rawptr{t} tvec2_rawptr(tvec2{t} mutable& x);
public threaded function extern "pxcglm::tvec3_rawptr" {t}
rawptr{t} tvec3_rawptr(tvec3{t} mutable& x);
public threaded function extern "pxcglm::tvec4_rawptr" {t}
rawptr{t} tvec4_rawptr(tvec4{t} mutable& x);
public threaded function extern "pxcglm::tmat2_rawptr" {t}
rawptr{t} tmat2_rawptr(tmat2{t} mutable& x);
public threaded function extern "pxcglm::tmat3_rawptr" {t}
rawptr{t} tmat3_rawptr(tmat3{t} mutable& x);
public threaded function extern "pxcglm::tmat4_rawptr" {t}
rawptr{t} tmat4_rawptr(tmat4{t} mutable& x);

public threaded function extern "pxcglm::tvec2_to_farray" {t}
farray{t, 2} tvec2_to_farray(tvec2{t} const& x);
public threaded function extern "pxcglm::tvec3_to_farray" {t}
farray{t, 3} tvec3_to_farray(tvec3{t} const& x);
public threaded function extern "pxcglm::tvec4_to_farray" {t}
farray{t, 4} tvec4_to_farray(tvec4{t} const& x);
public threaded function extern "pxcglm::tmat2_to_farray" {t}
farray{t, 4} tmat2_to_farray(tmat2{t} const& x);
public threaded function extern "pxcglm::tmat3_to_farray" {t}
farray{t, 9} tmat3_to_farray(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat4_to_farray" {t}
farray{t, 16} tmat4_to_farray(tmat4{t} const& x);

public metafunction tvec2___add{tx, ty} op_add{tx};
public metafunction tvec2___sub{tx, ty} op_sub{tx};
public metafunction tvec2___adda{tx, ty} op_adda{tx};
public metafunction tvec2___suba{tx, ty} op_suba{tx};
public metafunction tvec2___eq{tx, ty} op_eq{tx};
public metafunction tvec2___ne{tx, ty} op_ne{tx};
public metafunction tvec2___minus{tx} op_minus{tx};

public metafunction tvec3___add{tx, ty} op_add{tx};
public metafunction tvec3___sub{tx, ty} op_sub{tx};
public metafunction tvec3___adda{tx, ty} op_adda{tx};
public metafunction tvec3___suba{tx, ty} op_suba{tx};
public metafunction tvec3___eq{tx, ty} op_eq{tx};
public metafunction tvec3___ne{tx, ty} op_ne{tx};
public metafunction tvec3___minus{tx} op_minus{tx};

public metafunction tvec4___add{tx, ty} op_add{tx};
public metafunction tvec4___sub{tx, ty} op_sub{tx};
public metafunction tvec4___adda{tx, ty} op_adda{tx};
public metafunction tvec4___suba{tx, ty} op_suba{tx};
public metafunction tvec4___eq{tx, ty} op_eq{tx};
public metafunction tvec4___ne{tx, ty} op_ne{tx};
public metafunction tvec4___minus{tx} op_minus{tx};

private threaded function extern "pxcglm::op_add" {t}
check_tvec_type{t} op_add(t const& x, t const& y);
private threaded function extern "pxcglm::op_sub" {t}
check_tvec_type{t} op_sub(t const& x, t const& y);
private threaded function extern "pxcglm::op_add" {t}
m::cond{check_tvec_type{t}, void, void} op_adda(t mutable& x, t const& y);
private threaded function extern "pxcglm::op_sub" {t}
m::cond{check_tvec_type{t}, void, void} op_suba(t mutable& x, t const& y);
private threaded function extern "pxcglm::op_eq" {t}
m::cond{check_tvec_type{t}, bool, bool} op_eq(t const& x, t const& y);
private threaded function extern "pxcglm::op_ne" {t}
m::cond{check_tvec_type{t}, bool, bool} op_ne(t const& x, t const& y);
private threaded function extern "pxcglm::op_minus" {t}
check_tvec_type{t} op_minus(t const& x);

public threaded function extern "pxcglm::length" {t}
m::symbol{check_tvec_type{t}, "value_type"} length(t const& x);
public threaded function extern "pxcglm::distance" {t}
m::symbol{check_tvec_type{t}, "value_type"} distance(t const& x, t const& y);
public threaded function extern "pxcglm::dot" {t}
m::symbol{check_tvec_type{t}, "value_type"} dot(t const& x, t const& y);

public threaded function extern "glm::normalize" {t}
tvec2{t} tvec2_normalize(tvec2{t} const& x);
public threaded function extern "glm::normalize" {t}
tvec3{t} tvec3_normalize(tvec3{t} const& x);
public threaded function extern "glm::normalize" {t}
tvec4{t} tvec4_normalize(tvec4{t} const& x);

public threaded function extern "glm::cross" {t}
tvec3{t} cross(tvec3{t} const& x, tvec3{t} const& y);

public threaded function extern "glm::determinant" {t}
t tmat2_determinant(tmat2{t} const& x);
public threaded function extern "glm::determinant" {t}
t tmat3_determinant(tmat3{t} const& x);
public threaded function extern "glm::determinant" {t}
t tmat4_determinant(tmat4{t} const& x);

public threaded function extern "pxcglm::tmat2_to_3" {t}
tmat3{t} tmat2_to_3(tmat2{t} const& x);
public threaded function extern "pxcglm::tmat3_to_2" {t}
tmat2{t} tmat3_to_2(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat3_to_4" {t}
tmat4{t} tmat3_to_4(tmat3{t} const& x);
public threaded function extern "pxcglm::tmat4_to_3" {t}
tmat3{t} tmat4_to_3(tmat4{t} const& x);

public threaded function extern "glm::rotate" {t}
tmat2{t} tmat2_rotate(tmat2{t} const& m, t angle, tvec2{t} const& axis);
public threaded function extern "glm::transpose" {t}
tmat2{t} tmat2_transpose(tmat2{t} const& m);
public threaded function extern "glm::inverse" {t}
tmat2{t} tmat2_inverse(tmat2{t} const& m);

public threaded function extern "glm::rotate" {t}
tmat3{t} tmat3_rotate(tmat3{t} const& m, t angle, tvec3{t} const& axis);
public threaded function extern "glm::transpose" {t}
tmat3{t} tmat3_transpose(tmat3{t} const& m);
public threaded function extern "glm::inverse" {t}
tmat3{t} tmat3_inverse(tmat3{t} const& m);

public threaded function extern "glm::rotate" {t}
tmat4{t} tmat4_rotate(tmat4{t} const& m, t angle, tvec3{t} const& axis);
public threaded function extern "glm::transpose" {t}
tmat4{t} tmat4_transpose(tmat4{t} const& m);
public threaded function extern "glm::inverse" {t}
tmat4{t} tmat4_inverse(tmat4{t} const& m);

public metafunction tmat2___mul{tx, ty} op_mul{tx, ty};
public metafunction tmat3___mul{tx, ty} op_mul{tx, ty};
public metafunction tmat4___mul{tx, ty} op_mul{tx, ty};

private threaded function extern "pxcglm::op_mul" {tx, ty}
check_mul_type{tx, ty} op_mul(tx const& x, ty const& y);

private metafunction check_mul_type{tx, ty}
  m::cond{
    m::and{check_tmat_type{tx},
      m::or{
	m::eq{tx, ty},
	m::eq{m::symbol{tx, "vector_type"}, ty}}},
    ty,
    m::error{m::concat{ty, ": invalid type for operator mul"}}};

public threaded function extern "glm::scale" {t}
tmat4{t} tmat4_scale(tmat4{t} const& m, tvec3{t} const& fa);
public threaded function extern "glm::translate" {t}
tmat4{t} tmat4_translate(tmat4{t} const& m, tvec3{t} const& tr);
public threaded function extern "glm::frustum" {t}

tmat4{t} frustum(t left, t right, t bottom, t top, t near, t far);
public threaded function extern "glm::ortho" {t}
tmat4{t} ortho(t left, t right, t bottom, t top, t near, t far);
public threaded function extern "glm::lookAt" {t}
tmat4{t} lookAt(tvec3{t} const& e, tvec3{t} const& c, tvec3{t} const& u);
public threaded function extern "glm::ortho" {t}
tmat4{t} ortho2D(t left, t right, t bottom, t top);
public threaded function extern "glm::perspective" {t}
tmat4{t} perspective(t fovy, t aspect, t zNear, t zFar);

private metafunction check_param_type{t}
  m::cond{
    m::eq{t, float}, t,
    m::eq{t, double}, t,
    m::error{m::concat{t, ": invalid type"}}};

private metafunction check_tvec_type{t}
  m::cond{
    m::and{
      m::or{
	m::eq{m::nameof{t}, "GL::glm::tvec2"},
	m::eq{m::nameof{t}, "GL::glm::tvec3"},
	m::eq{m::nameof{t}, "GL::glm::tvec4"}},
      check_param_type{m::symbol{t, "value_type"}}},
    t,
    m::error{m::concat{t, ": invalid type"}}};

private metafunction check_tmat_type{t}
  m::cond{
    m::and{
      m::or{
	m::eq{m::nameof{t}, "GL::glm::tmat2"},
	m::eq{m::nameof{t}, "GL::glm::tmat3"},
	m::eq{m::nameof{t}, "GL::glm::tmat4"}},
      check_param_type{m::symbol{t, "value_type"}}},
    t,
    m::error{m::concat{t, ": invalid type"}}};

extern "types" inline
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
;

extern "functions" inline
namespace pxcglm {

template <typename T> static inline glm::detail::tvec2<T>
make_tvec2(T x, T y)
{ return glm::detail::tvec2<T>(x, y); }
template <typename T> static inline glm::detail::tvec3<T>
make_tvec3(T x, T y, T z)
{ return glm::detail::tvec3<T>(x, y, z); }
template <typename T> static inline glm::detail::tvec4<T>
make_tvec4(T x, T y, T z, T w)
{ return glm::detail::tvec4<T>(x, y, z, w); }
template <typename T> static inline glm::detail::tmat2x2<T>
make_tmat2(T x)
{ return glm::detail::tmat2x2<T>(x); }
template <typename T> static inline glm::detail::tmat3x3<T>
make_tmat3(T x)
{ return glm::detail::tmat3x3<T>(x); }
template <typename T> static inline glm::detail::tmat4x4<T>
make_tmat4(T x)
{ return glm::detail::tmat4x4<T>(x); }

template <typename T> static inline pxcrt::bt_cslice<T>
tvec2_cslice(glm::detail::tvec2<T> const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 2); }
template <typename T> static inline pxcrt::bt_cslice<T>
tvec3_cslice(glm::detail::tvec3<T> const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 3); }
template <typename T> static inline pxcrt::bt_cslice<T>
tvec4_cslice(glm::detail::tvec4<T> const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat2_cslice(glm::detail::tmat2x2<T> const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat3_cslice(glm::detail::tmat3x3<T> const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 9); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat4_cslice(glm::detail::tmat4x4<T> const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 16); }

template <typename T> static inline pxcrt::bt_slice<T>
tvec2_slice(glm::detail::tvec2<T>& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 2); }
template <typename T> static inline pxcrt::bt_slice<T>
tvec3_slice(glm::detail::tvec3<T>& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 3); }
template <typename T> static inline pxcrt::bt_slice<T>
tvec4_slice(glm::detail::tvec4<T>& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat2_slice(glm::detail::tmat2x2<T>& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat3_slice(glm::detail::tmat3x3<T>& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 9); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat4_slice(glm::detail::tmat4x4<T>& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 16); }

template <typename T> static inline T const *
tvec2_crawptr(glm::detail::tvec2<T> const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tvec3_crawptr(glm::detail::tvec3<T> const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tvec4_crawptr(glm::detail::tvec4<T> const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat2_crawptr(glm::detail::tmat2x2<T> const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat3_crawptr(glm::detail::tmat3x3<T> const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat4_crawptr(glm::detail::tmat4x4<T> const& x)
{ return glm::value_ptr(x); }

template <typename T> static inline T *
tvec2_rawptr(glm::detail::tvec2<T>& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tvec3_rawptr(glm::detail::tvec3<T>& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tvec4_rawptr(glm::detail::tvec4<T>& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat2_rawptr(glm::detail::tmat2x2<T>& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat3_rawptr(glm::detail::tmat3x3<T>& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat4_rawptr(glm::detail::tmat4x4<T>& x)
{ return glm::value_ptr(x); }

template <typename T> static inline pxcrt::farray<T, 2>
tvec2_to_farray(glm::detail::tvec2<T> const& x)
{
  pxcrt::farray<T, 2> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 2 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 3>
tvec3_to_farray(glm::detail::tvec3<T> const& x)
{
  pxcrt::farray<T, 3> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 3 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 4>
tvec4_to_farray(glm::detail::tvec4<T> const& x)
{
  pxcrt::farray<T, 4> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 4 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 4>
tmat2_to_farray(glm::detail::tmat2x2<T> const& x)
{
  pxcrt::farray<T, 4> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 4 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 9>
tmat3_to_farray(glm::detail::tmat3x3<T> const& x)
{
  pxcrt::farray<T, 9> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 9 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 16>
tmat4_to_farray(glm::detail::tmat4x4<T> const& x)
{
  pxcrt::farray<T, 16> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 16 * sizeof(T));
  return r;
}

template <typename T> static inline glm::detail::tmat3x3<T>
tmat2_to_3(glm::detail::tmat2x2<T> const& x)
{ return glm::detail::tmat3x3<T>(x); }

template <typename T> static inline glm::detail::tmat2x2<T>
tmat3_to_2(glm::detail::tmat3x3<T> const& x)
{ return glm::detail::tmat2x2<T>(x); }

template <typename T> static inline glm::detail::tmat4x4<T>
tmat3_to_4(glm::detail::tmat3x3<T> const& x)
{ return glm::detail::tmat4x4<T>(x); }

template <typename T> static inline glm::detail::tmat3x3<T>
tmat4_to_3(glm::detail::tmat4x4<T> const& x)
{ return glm::detail::tmat3x3<T>(x); }

template <typename T> static inline T op_add(T const& x, T const& y)
{ return x + y; }

template <typename T> static inline T op_sub(T const& x, T const& y)
{ return x - y; }

template <typename T> static inline void op_adda(T& x, T const& y)
{ x += y; }

template <typename T> static inline void op_suba(T& x, T const& y)
{ x -= y; }

template <typename T> static inline bool op_eq(T const& x, T const& y)
{ return x == y; }

template <typename T> static inline bool op_ne(T const& x, T const& y)
{ return x != y; }

template <typename T> static inline T op_minus(T const& x)
{ return -x; }

template <typename Tx, typename Ty> static inline Ty
op_mul(Tx const& x, Ty const& y)
{ return x * y; }

template <typename T> static inline typename T::value_type
length(T const& x, T const& y) { return glm::length(x, y); }

template <typename T> static inline typename T::value_type
distance(T const& x, T const& y) { return glm::distance(x, y); }

template <typename T> static inline typename T::value_type
dot(T const& x, T const& y) { return glm::dot(x, y); }

};
;
