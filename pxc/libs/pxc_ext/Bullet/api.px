public namespace Bullet::api "export-unsafe";
public import common -;
public import Bullet::base -;
public import container::raw -;
public import meta m;
public import meta::vararg va;
public metafunction BvhSubtreeInfoArray btAlignedObjectArray_btBvhSubtreeInfo;
public metafunction IndexedMeshArray btAlignedObjectArray_btIndexedMesh;
public tsvaluetype struct extern "::PHY_ScalarType" "extenum" PHY_ScalarType { }
public extern "PHY_FLOAT" PHY_ScalarType PHY_FLOAT;
public extern "PHY_DOUBLE" PHY_ScalarType PHY_DOUBLE;
public extern "PHY_INTEGER" PHY_ScalarType PHY_INTEGER;
public extern "PHY_SHORT" PHY_ScalarType PHY_SHORT;
public extern "PHY_FIXEDPOINT88" PHY_ScalarType PHY_FIXEDPOINT88;
public extern "PHY_UCHAR" PHY_ScalarType PHY_UCHAR;
public metafunction QuantizedNodeArray btAlignedObjectArray_btQuantizedBvhNode;
public threaded struct extern "::bt32BitAxisSweep3" "nodefault" bt32BitAxisSweep3(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, uint maxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator)  {
  public metafunction __base__ {btBroadphaseInterface, btAxisSweep3Internal_unsigned_int};
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "addHandle" uint addHandle(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} pOwner, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public function extern "printStats" void printStats();
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "removeHandle" void removeHandle(uint handle, rptr{btDispatcher} dispatcher);
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "quantize" void quantize(rptr{uint} out, btVector3 const& point, int isMax) const;
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "getNumHandles" uint getNumHandles() const;
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "updateHandle" void updateHandle(uint handle, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_int_Handle} getHandle(uint index) const;
}
public tsvaluetype struct extern "::bt6DofFlags" "extenum" bt6DofFlags { }
public extern "BT_6DOF_FLAGS_CFM_NORM" bt6DofFlags BT_6DOF_FLAGS_CFM_NORM;
public extern "BT_6DOF_FLAGS_CFM_STOP" bt6DofFlags BT_6DOF_FLAGS_CFM_STOP;
public extern "BT_6DOF_FLAGS_ERP_STOP" bt6DofFlags BT_6DOF_FLAGS_ERP_STOP;
public threaded struct extern "::btActionInterface" "nonmovable" btActionInterface {
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld, btScalar deltaTimeStep);
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer);
}
public threaded struct extern "::btActivatingCollisionAlgorithm" "nodefault" btActivatingCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0, rptr{btCollisionObject} body1, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
}
public metafunction btAlignedAllocFunc meta::list{rptr{void}, size_t, int};
public threaded struct extern "::btAlignedAllocator<btActionInterface*, 16u>" btAlignedAllocator_btActionInterface_p_16u {
  public function extern "construct" void construct(rptr{rptr{btActionInterface}} ptr, rptr{btActionInterface} const& value);
  public function extern "destroy" void destroy(rptr{rptr{btActionInterface}} ptr);
  public function extern "deallocate" void deallocate(rptr{rptr{btActionInterface}} ptr);
  public function extern "address" rptr{rptr{btActionInterface}} address(rptr{btActionInterface} mutable& ref) const;
  public function extern "allocate" rptr{rptr{btActionInterface}} allocate(size_type n, rptr{crptr{rptr{btActionInterface}}} hint);
}
public threaded struct extern "::btAlignedAllocator<btBroadphaseInterface*, 16u>" btAlignedAllocator_btBroadphaseInterface_p_16u {
  public function extern "allocate" rptr{rptr{btBroadphaseInterface}} allocate(size_type n, rptr{crptr{rptr{btBroadphaseInterface}}} hint);
  public function extern "address" rptr{rptr{btBroadphaseInterface}} address(rptr{btBroadphaseInterface} mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{rptr{btBroadphaseInterface}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btBroadphaseInterface}} ptr);
  public function extern "construct" void construct(rptr{rptr{btBroadphaseInterface}} ptr, rptr{btBroadphaseInterface} const& value);
}
public threaded struct extern "::btAlignedAllocator<btBroadphasePair, 16u>" btAlignedAllocator_btBroadphasePair_16u {
  public function extern "allocate" rptr{btBroadphasePair} allocate(size_type n, rptr{crptr{btBroadphasePair}} hint);
  public function extern "address" rptr{btBroadphasePair} address(btBroadphasePair mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{btBroadphasePair} ptr);
  public function extern "destroy" void destroy(rptr{btBroadphasePair} ptr);
  public function extern "construct" void construct(rptr{btBroadphasePair} ptr, btBroadphasePair const& value);
}
public threaded struct extern "::btAlignedAllocator<btBvhSubtreeInfo, 16u>" btAlignedAllocator_btBvhSubtreeInfo_16u {
  public function extern "construct" void construct(rptr{btBvhSubtreeInfo} ptr, btBvhSubtreeInfo const& value);
  public function extern "destroy" void destroy(rptr{btBvhSubtreeInfo} ptr);
  public function extern "deallocate" void deallocate(rptr{btBvhSubtreeInfo} ptr);
  public function extern "address" rptr{btBvhSubtreeInfo} address(btBvhSubtreeInfo mutable& ref) const;
  public function extern "allocate" rptr{btBvhSubtreeInfo} allocate(size_type n, rptr{crptr{btBvhSubtreeInfo}} hint);
}
public threaded struct extern "::btAlignedAllocator<btChunk*, 16u>" btAlignedAllocator_btChunk_p_16u {
  public function extern "deallocate" void deallocate(rptr{rptr{btChunk}} ptr);
  public function extern "construct" void construct(rptr{rptr{btChunk}} ptr, rptr{btChunk} const& value);
  public function extern "destroy" void destroy(rptr{rptr{btChunk}} ptr);
  public function extern "allocate" rptr{rptr{btChunk}} allocate(size_type n, rptr{crptr{rptr{btChunk}}} hint);
  public function extern "address" rptr{rptr{btChunk}} address(rptr{btChunk} mutable& ref) const;
}
public threaded struct extern "::btAlignedAllocator<btCollisionObject const*, 16u>" btAlignedAllocator_btCollisionObject_const_p_16u {
  public function extern "address" rptr{crptr{btCollisionObject}} address(crptr{btCollisionObject} mutable& ref) const;
  public function extern "allocate" rptr{crptr{btCollisionObject}} allocate(size_type n, rptr{crptr{crptr{btCollisionObject}}} hint);
  public function extern "destroy" void destroy(rptr{crptr{btCollisionObject}} ptr);
  public function extern "construct" void construct(rptr{crptr{btCollisionObject}} ptr, crptr{btCollisionObject} const& value);
  public function extern "deallocate" void deallocate(rptr{crptr{btCollisionObject}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btCollisionObject*, 16u>" btAlignedAllocator_btCollisionObject_p_16u {
  public function extern "address" rptr{rptr{btCollisionObject}} address(rptr{btCollisionObject} mutable& ref) const;
  public function extern "allocate" rptr{rptr{btCollisionObject}} allocate(size_type n, rptr{crptr{rptr{btCollisionObject}}} hint);
  public function extern "destroy" void destroy(rptr{rptr{btCollisionObject}} ptr);
  public function extern "construct" void construct(rptr{rptr{btCollisionObject}} ptr, rptr{btCollisionObject} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btCollisionObject}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btCompoundShapeChild, 16u>" btAlignedAllocator_btCompoundShapeChild_16u {
  public function extern "allocate" rptr{btCompoundShapeChild} allocate(size_type n, rptr{crptr{btCompoundShapeChild}} hint);
  public function extern "address" rptr{btCompoundShapeChild} address(btCompoundShapeChild mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{btCompoundShapeChild} ptr);
  public function extern "construct" void construct(rptr{btCompoundShapeChild} ptr, btCompoundShapeChild const& value);
  public function extern "destroy" void destroy(rptr{btCompoundShapeChild} ptr);
}
public threaded struct extern "::btAlignedAllocator<btDbvtNode const*, 16u>" btAlignedAllocator_btDbvtNode_const_p_16u {
  public function extern "allocate" rptr{crptr{btDbvtNode}} allocate(size_type n, rptr{crptr{crptr{btDbvtNode}}} hint);
  public function extern "address" rptr{crptr{btDbvtNode}} address(crptr{btDbvtNode} mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{crptr{btDbvtNode}} ptr);
  public function extern "destroy" void destroy(rptr{crptr{btDbvtNode}} ptr);
  public function extern "construct" void construct(rptr{crptr{btDbvtNode}} ptr, crptr{btDbvtNode} const& value);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNN, 16u>" btAlignedAllocator_btDbvt_sStkNN_16u {
  public function extern "address" rptr{btDbvt_sStkNN} address(btDbvt_sStkNN mutable& ref) const;
  public function extern "allocate" rptr{btDbvt_sStkNN} allocate(size_type n, rptr{crptr{btDbvt_sStkNN}} hint);
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNN} ptr);
  public function extern "construct" void construct(rptr{btDbvt_sStkNN} ptr, btDbvt_sStkNN const& value);
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNN} ptr);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNPS, 16u>" btAlignedAllocator_btDbvt_sStkNPS_16u {
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNPS} ptr);
  public function extern "construct" void construct(rptr{btDbvt_sStkNPS} ptr, btDbvt_sStkNPS const& value);
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNPS} ptr);
  public function extern "address" rptr{btDbvt_sStkNPS} address(btDbvt_sStkNPS mutable& ref) const;
  public function extern "allocate" rptr{btDbvt_sStkNPS} allocate(size_type n, rptr{crptr{btDbvt_sStkNPS}} hint);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNP, 16u>" btAlignedAllocator_btDbvt_sStkNP_16u {
  public function extern "allocate" rptr{btDbvt_sStkNP} allocate(size_type n, rptr{crptr{btDbvt_sStkNP}} hint);
  public function extern "address" rptr{btDbvt_sStkNP} address(btDbvt_sStkNP mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNP} ptr);
  public function extern "construct" void construct(rptr{btDbvt_sStkNP} ptr, btDbvt_sStkNP const& value);
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNP} ptr);
}
public threaded struct extern "::btAlignedAllocator<btHashInt, 16u>" btAlignedAllocator_btHashInt_16u {
  public function extern "construct" void construct(rptr{btHashInt} ptr, btHashInt const& value);
  public function extern "destroy" void destroy(rptr{btHashInt} ptr);
  public function extern "deallocate" void deallocate(rptr{btHashInt} ptr);
  public function extern "address" rptr{btHashInt} address(btHashInt mutable& ref) const;
  public function extern "allocate" rptr{btHashInt} allocate(size_type n, rptr{crptr{btHashInt}} hint);
}
public threaded struct extern "::btAlignedAllocator<btHashPtr, 16u>" btAlignedAllocator_btHashPtr_16u {
  public function extern "deallocate" void deallocate(rptr{btHashPtr} ptr);
  public function extern "destroy" void destroy(rptr{btHashPtr} ptr);
  public function extern "construct" void construct(rptr{btHashPtr} ptr, btHashPtr const& value);
  public function extern "allocate" rptr{btHashPtr} allocate(size_type n, rptr{crptr{btHashPtr}} hint);
  public function extern "address" rptr{btHashPtr} address(btHashPtr mutable& ref) const;
}
public threaded struct extern "::btAlignedAllocator<btHashString, 16u>" btAlignedAllocator_btHashString_16u {
  public function extern "destroy" void destroy(rptr{btHashString} ptr);
  public function extern "construct" void construct(rptr{btHashString} ptr, btHashString const& value);
  public function extern "deallocate" void deallocate(rptr{btHashString} ptr);
  public function extern "address" rptr{btHashString} address(btHashString mutable& ref) const;
  public function extern "allocate" rptr{btHashString} allocate(size_type n, rptr{crptr{btHashString}} hint);
}
public threaded struct extern "::btAlignedAllocator<btIndexedMesh, 16u>" btAlignedAllocator_btIndexedMesh_16u {
  public function extern "address" rptr{btIndexedMesh} address(btIndexedMesh mutable& ref) const;
  public function extern "allocate" rptr{btIndexedMesh} allocate(size_type n, rptr{crptr{btIndexedMesh}} hint);
  public function extern "construct" void construct(rptr{btIndexedMesh} ptr, btIndexedMesh const& value);
  public function extern "destroy" void destroy(rptr{btIndexedMesh} ptr);
  public function extern "deallocate" void deallocate(rptr{btIndexedMesh} ptr);
}
public threaded struct extern "::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>" btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16u {
  public function extern "construct" void construct(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr, rptr{btMultiSapBroadphase_btBridgeProxy} const& value);
  public function extern "destroy" void destroy(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr);
  public function extern "deallocate" void deallocate(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr);
  public function extern "address" rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} address(rptr{btMultiSapBroadphase_btBridgeProxy} mutable& ref) const;
  public function extern "allocate" rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} allocate(size_type n, rptr{crptr{rptr{btMultiSapBroadphase_btBridgeProxy}}} hint);
}
public threaded struct extern "::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>" btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16u {
  public function extern "construct" void construct(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr, rptr{btMultiSapBroadphase_btMultiSapProxy} const& value);
  public function extern "destroy" void destroy(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr);
  public function extern "deallocate" void deallocate(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr);
  public function extern "address" rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} address(rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& ref) const;
  public function extern "allocate" rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} allocate(size_type n, rptr{crptr{rptr{btMultiSapBroadphase_btMultiSapProxy}}} hint);
}
public threaded struct extern "::btAlignedAllocator<btOptimizedBvhNode, 16u>" btAlignedAllocator_btOptimizedBvhNode_16u {
  public function extern "destroy" void destroy(rptr{btOptimizedBvhNode} ptr);
  public function extern "construct" void construct(rptr{btOptimizedBvhNode} ptr, btOptimizedBvhNode const& value);
  public function extern "deallocate" void deallocate(rptr{btOptimizedBvhNode} ptr);
  public function extern "address" rptr{btOptimizedBvhNode} address(btOptimizedBvhNode mutable& ref) const;
  public function extern "allocate" rptr{btOptimizedBvhNode} allocate(size_type n, rptr{crptr{btOptimizedBvhNode}} hint);
}
public threaded struct extern "::btAlignedAllocator<btPersistentManifold*, 16u>" btAlignedAllocator_btPersistentManifold_p_16u {
  public function extern "construct" void construct(rptr{rptr{btPersistentManifold}} ptr, rptr{btPersistentManifold} const& value);
  public function extern "destroy" void destroy(rptr{rptr{btPersistentManifold}} ptr);
  public function extern "deallocate" void deallocate(rptr{rptr{btPersistentManifold}} ptr);
  public function extern "address" rptr{rptr{btPersistentManifold}} address(rptr{btPersistentManifold} mutable& ref) const;
  public function extern "allocate" rptr{rptr{btPersistentManifold}} allocate(size_type n, rptr{crptr{rptr{btPersistentManifold}}} hint);
}
public threaded struct extern "::btAlignedAllocator<btPointerUid, 16u>" btAlignedAllocator_btPointerUid_16u {
  public function extern "destroy" void destroy(rptr{btPointerUid} ptr);
  public function extern "construct" void construct(rptr{btPointerUid} ptr, btPointerUid const& value);
  public function extern "deallocate" void deallocate(rptr{btPointerUid} ptr);
  public function extern "address" rptr{btPointerUid} address(btPointerUid mutable& ref) const;
  public function extern "allocate" rptr{btPointerUid} allocate(size_type n, rptr{crptr{btPointerUid}} hint);
}
public threaded struct extern "::btAlignedAllocator<btQuantizedBvhNode, 16u>" btAlignedAllocator_btQuantizedBvhNode_16u {
  public function extern "deallocate" void deallocate(rptr{btQuantizedBvhNode} ptr);
  public function extern "construct" void construct(rptr{btQuantizedBvhNode} ptr, btQuantizedBvhNode const& value);
  public function extern "destroy" void destroy(rptr{btQuantizedBvhNode} ptr);
  public function extern "allocate" rptr{btQuantizedBvhNode} allocate(size_type n, rptr{crptr{btQuantizedBvhNode}} hint);
  public function extern "address" rptr{btQuantizedBvhNode} address(btQuantizedBvhNode mutable& ref) const;
}
public threaded struct extern "::btAlignedAllocator<btRigidBody*, 16u>" btAlignedAllocator_btRigidBody_p_16u {
  public function extern "address" rptr{rptr{btRigidBody}} address(rptr{btRigidBody} mutable& ref) const;
  public function extern "allocate" rptr{rptr{btRigidBody}} allocate(size_type n, rptr{crptr{rptr{btRigidBody}}} hint);
  public function extern "destroy" void destroy(rptr{rptr{btRigidBody}} ptr);
  public function extern "construct" void construct(rptr{rptr{btRigidBody}} ptr, rptr{btRigidBody} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btRigidBody}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btSolverBody, 16u>" btAlignedAllocator_btSolverBody_16u {
  public function extern "address" rptr{btSolverBody} address(btSolverBody mutable& ref) const;
  public function extern "allocate" rptr{btSolverBody} allocate(size_type n, rptr{crptr{btSolverBody}} hint);
  public function extern "construct" void construct(rptr{btSolverBody} ptr, btSolverBody const& value);
  public function extern "destroy" void destroy(rptr{btSolverBody} ptr);
  public function extern "deallocate" void deallocate(rptr{btSolverBody} ptr);
}
public threaded struct extern "::btAlignedAllocator<btSolverConstraint, 16u>" btAlignedAllocator_btSolverConstraint_16u {
  public function extern "deallocate" void deallocate(rptr{btSolverConstraint} ptr);
  public function extern "construct" void construct(rptr{btSolverConstraint} ptr, btSolverConstraint const& value);
  public function extern "destroy" void destroy(rptr{btSolverConstraint} ptr);
  public function extern "allocate" rptr{btSolverConstraint} allocate(size_type n, rptr{crptr{btSolverConstraint}} hint);
  public function extern "address" rptr{btSolverConstraint} address(btSolverConstraint mutable& ref) const;
}
public threaded struct extern "::btAlignedAllocator<btTriangleInfo, 16u>" btAlignedAllocator_btTriangleInfo_16u {
  public function extern "allocate" rptr{btTriangleInfo} allocate(size_type n, rptr{crptr{btTriangleInfo}} hint);
  public function extern "address" rptr{btTriangleInfo} address(btTriangleInfo mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{btTriangleInfo} ptr);
  public function extern "construct" void construct(rptr{btTriangleInfo} ptr, btTriangleInfo const& value);
  public function extern "destroy" void destroy(rptr{btTriangleInfo} ptr);
}
public threaded struct extern "::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>" btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u {
  public function extern "deallocate" void deallocate(rptr{btTypedConstraint_btConstraintInfo1} ptr);
  public function extern "construct" void construct(rptr{btTypedConstraint_btConstraintInfo1} ptr, btTypedConstraint_btConstraintInfo1 const& value);
  public function extern "destroy" void destroy(rptr{btTypedConstraint_btConstraintInfo1} ptr);
  public function extern "allocate" rptr{btTypedConstraint_btConstraintInfo1} allocate(size_type n, rptr{crptr{btTypedConstraint_btConstraintInfo1}} hint);
  public function extern "address" rptr{btTypedConstraint_btConstraintInfo1} address(btTypedConstraint_btConstraintInfo1 mutable& ref) const;
}
public threaded struct extern "::btAlignedAllocator<btTypedConstraint*, 16u>" btAlignedAllocator_btTypedConstraint_p_16u {
  public function extern "allocate" rptr{rptr{btTypedConstraint}} allocate(size_type n, rptr{crptr{rptr{btTypedConstraint}}} hint);
  public function extern "address" rptr{rptr{btTypedConstraint}} address(rptr{btTypedConstraint} mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{rptr{btTypedConstraint}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btTypedConstraint}} ptr);
  public function extern "construct" void construct(rptr{rptr{btTypedConstraint}} ptr, rptr{btTypedConstraint} const& value);
}
public threaded struct extern "::btAlignedAllocator<btVector3, 16u>" btAlignedAllocator_btVector3_16u {
  public function extern "address" rptr{btVector3} address(btVector3 mutable& ref) const;
  public function extern "allocate" rptr{btVector3} allocate(size_type n, rptr{crptr{btVector3}} hint);
  public function extern "destroy" void destroy(rptr{btVector3} ptr);
  public function extern "construct" void construct(rptr{btVector3} ptr, btVector3 const& value);
  public function extern "deallocate" void deallocate(rptr{btVector3} ptr);
}
public threaded struct extern "::btAlignedAllocator<btWheelInfo, 16u>" btAlignedAllocator_btWheelInfo_16u {
  public function extern "allocate" rptr{btWheelInfo} allocate(size_type n, rptr{crptr{btWheelInfo}} hint);
  public function extern "address" rptr{btWheelInfo} address(btWheelInfo mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{btWheelInfo} ptr);
  public function extern "destroy" void destroy(rptr{btWheelInfo} ptr);
  public function extern "construct" void construct(rptr{btWheelInfo} ptr, btWheelInfo const& value);
}
public threaded struct extern "::btAlignedAllocator<char const*, 16u>" btAlignedAllocator_char_const_p_16u {
  public function extern "deallocate" void deallocate(rptr{crptr{char}} ptr);
  public function extern "construct" void construct(rptr{crptr{char}} ptr, crptr{char} const& value);
  public function extern "destroy" void destroy(rptr{crptr{char}} ptr);
  public function extern "allocate" rptr{crptr{char}} allocate(size_type n, rptr{crptr{crptr{char}}} hint);
  public function extern "address" rptr{crptr{char}} address(crptr{char} mutable& ref) const;
}
public threaded struct extern "::btAlignedAllocator<char*, 16u>" btAlignedAllocator_char_p_16u {
  public function extern "allocate" rptr{rptr{char}} allocate(size_type n, rptr{crptr{rptr{char}}} hint);
  public function extern "address" rptr{rptr{char}} address(rptr{char} mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{rptr{char}} ptr);
  public function extern "construct" void construct(rptr{rptr{char}} ptr, rptr{char} const& value);
  public function extern "destroy" void destroy(rptr{rptr{char}} ptr);
}
public threaded struct extern "::btAlignedAllocator<float, 16u>" btAlignedAllocator_float_16u {
  public function extern "allocate" rptr{float} allocate(size_type n, rptr{crptr{float}} hint);
  public function extern "address" rptr{float} address(float mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{float} ptr);
  public function extern "destroy" void destroy(rptr{float} ptr);
  public function extern "construct" void construct(rptr{float} ptr, float const& value);
}
public threaded struct extern "::btAlignedAllocator<int, 16u>" btAlignedAllocator_int_16u {
  public function extern "allocate" rptr{int} allocate(size_type n, rptr{crptr{int}} hint);
  public function extern "address" rptr{int} address(int mutable& ref) const;
  public function extern "deallocate" void deallocate(rptr{int} ptr);
  public function extern "destroy" void destroy(rptr{int} ptr);
  public function extern "construct" void construct(rptr{int} ptr, int const& value);
}
public threaded struct extern "::btAlignedAllocator<short, 16u>" btAlignedAllocator_short_16u {
  public function extern "destroy" void destroy(rptr{short} ptr);
  public function extern "construct" void construct(rptr{short} ptr, short const& value);
  public function extern "deallocate" void deallocate(rptr{short} ptr);
  public function extern "address" rptr{short} address(short mutable& ref) const;
  public function extern "allocate" rptr{short} allocate(size_type n, rptr{crptr{short}} hint);
}
public threaded struct extern "::btAlignedAllocator<short*, 16u>" btAlignedAllocator_short_p_16u {
  public function extern "address" rptr{rptr{short}} address(rptr{short} mutable& ref) const;
  public function extern "allocate" rptr{rptr{short}} allocate(size_type n, rptr{crptr{rptr{short}}} hint);
  public function extern "destroy" void destroy(rptr{rptr{short}} ptr);
  public function extern "construct" void construct(rptr{rptr{short}} ptr, rptr{short} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{short}} ptr);
}
public threaded struct extern "::btAlignedAllocator<unsigned int, 16u>" btAlignedAllocator_unsigned_int_16u {
  public function extern "construct" void construct(rptr{uint} ptr, uint const& value);
  public function extern "destroy" void destroy(rptr{uint} ptr);
  public function extern "deallocate" void deallocate(rptr{uint} ptr);
  public function extern "address" rptr{uint} address(uint mutable& ref) const;
  public function extern "allocate" rptr{uint} allocate(size_type n, rptr{crptr{uint}} hint);
}
public threaded struct extern "::btAlignedAllocator<unsigned short, 16u>" btAlignedAllocator_unsigned_short_16u {
  public function extern "construct" void construct(rptr{ushort} ptr, ushort const& value);
  public function extern "destroy" void destroy(rptr{ushort} ptr);
  public function extern "deallocate" void deallocate(rptr{ushort} ptr);
  public function extern "address" rptr{ushort} address(ushort mutable& ref) const;
  public function extern "allocate" rptr{ushort} allocate(size_type n, rptr{crptr{ushort}} hint);
}
public threaded struct extern "::btAlignedAllocator<void*, 16u>" btAlignedAllocator_void_p_16u {
  public function extern "deallocate" void deallocate(rptr{rptr{void}} ptr);
  public function extern "construct" void construct(rptr{rptr{void}} ptr, rptr{void} const& value);
  public function extern "destroy" void destroy(rptr{rptr{void}} ptr);
  public function extern "allocate" rptr{rptr{void}} allocate(size_type n, rptr{crptr{rptr{void}}} hint);
  public function extern "address" rptr{rptr{void}} address(rptr{void} mutable& ref) const;
}
public metafunction btAlignedFreeFunc meta::list{void, rptr{void}};
public threaded struct extern "::btAlignedObjectArray<btActionInterface*>" btAlignedObjectArray_btActionInterface_p {
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "remove" void remove(rptr{btActionInterface} const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "push_back" void push_back(rptr{btActionInterface} const& _Val);
  public function extern "resize" void resize(int newsize, rptr{btActionInterface} const& fillData);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btActionInterface} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "at" rptr{btActionInterface} mutable& at(int n);
  public function extern "at" rptr{btActionInterface} const& cat(int n) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{btActionInterface} mutable& expand_(rptr{btActionInterface} const& fillValue);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btActionInterface} const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{btActionInterface} mutable& expandNonInitializing();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btActionInterface_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btActionInterface*>::less" "nodefault" btAlignedObjectArray_btActionInterface_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btBroadphaseInterface*>" btAlignedObjectArray_btBroadphaseInterface_p {
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBroadphaseInterface_p const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btBroadphaseInterface} const& key) const;
  public function extern "expandNonInitializing" rptr{btBroadphaseInterface} mutable& expandNonInitializing();
  public function extern "at" rptr{btBroadphaseInterface} mutable& at(int n);
  public function extern "at" rptr{btBroadphaseInterface} const& cat(int n) const;
  public function extern "expand" rptr{btBroadphaseInterface} mutable& expand_(rptr{btBroadphaseInterface} const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "push_back" void push_back(rptr{btBroadphaseInterface} const& _Val);
  public function extern "resize" void resize(int newsize, rptr{btBroadphaseInterface} const& fillData);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btBroadphaseInterface} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "remove" void remove(rptr{btBroadphaseInterface} const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btBroadphaseInterface*>::less" "nodefault" btAlignedObjectArray_btBroadphaseInterface_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btBroadphasePair>" btAlignedObjectArray_btBroadphasePair {
  public function extern "at" btBroadphasePair mutable& at(int n);
  public function extern "at" btBroadphasePair const& cat(int n) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" btBroadphasePair mutable& expand_(btBroadphasePair const& fillValue);
  public function extern "findLinearSearch" int findLinearSearch(btBroadphasePair const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btBroadphasePair mutable& expandNonInitializing();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBroadphasePair const& otherArray);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "remove" void remove(btBroadphasePair const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "push_back" void push_back(btBroadphasePair const& _Val);
  public function extern "resize" void resize(int newsize, btBroadphasePair const& fillData);
  public function extern "findBinarySearch" int findBinarySearch(btBroadphasePair const& key) const;
  public function extern "reserve" void reserve(int _Count);
}
public threaded struct extern "::btAlignedObjectArray<btBroadphasePair>::less" "nodefault" btAlignedObjectArray_btBroadphasePair_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btBvhSubtreeInfo>" btAlignedObjectArray_btBvhSubtreeInfo {
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btBvhSubtreeInfo const& key);
  public function extern "findBinarySearch" int findBinarySearch(btBvhSubtreeInfo const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "resize" void resize(int newsize, btBvhSubtreeInfo const& fillData);
  public function extern "push_back" void push_back(btBvhSubtreeInfo const& _Val);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBvhSubtreeInfo const& otherArray);
  public function extern "capacity" int capacity() const;
  public function extern "expand" btBvhSubtreeInfo mutable& expand_(btBvhSubtreeInfo const& fillValue);
  public function extern "at" btBvhSubtreeInfo const& cat(int n) const;
  public function extern "at" btBvhSubtreeInfo mutable& at(int n);
  public function extern "expandNonInitializing" btBvhSubtreeInfo mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btBvhSubtreeInfo const& key) const;
}
public threaded struct extern "::btAlignedObjectArray<btBvhSubtreeInfo>::less" "nodefault" btAlignedObjectArray_btBvhSubtreeInfo_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btChunk*>" btAlignedObjectArray_btChunk_p {
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{btChunk} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "resize" void resize(int newsize, rptr{btChunk} const& fillData);
  public function extern "push_back" void push_back(rptr{btChunk} const& _Val);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(rptr{btChunk} const& key);
  public function extern "expandNonInitializing" rptr{btChunk} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btChunk} const& key) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{btChunk} mutable& expand_(rptr{btChunk} const& fillValue);
  public function extern "at" rptr{btChunk} const& cat(int n) const;
  public function extern "at" rptr{btChunk} mutable& at(int n);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btChunk_p const& otherArray);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
}
public threaded struct extern "::btAlignedObjectArray<btChunk*>::less" "nodefault" btAlignedObjectArray_btChunk_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject const*>" btAlignedObjectArray_btCollisionObject_const_p {
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionObject_const_p const& otherArray);
  public function extern "capacity" int capacity() const;
  public function extern "expand" crptr{btCollisionObject} mutable& expand_(crptr{btCollisionObject} const& fillValue);
  public function extern "at" crptr{btCollisionObject} mutable& at(int n);
  public function extern "at" crptr{btCollisionObject} const& cat(int n) const;
  public function extern "expandNonInitializing" crptr{btCollisionObject} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(crptr{btCollisionObject} const& key) const;
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(crptr{btCollisionObject} const& key);
  public function extern "findBinarySearch" int findBinarySearch(crptr{btCollisionObject} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "resize" void resize(int newsize, crptr{btCollisionObject} const& fillData);
  public function extern "push_back" void push_back(crptr{btCollisionObject} const& _Val);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject const*>::less" "nodefault" btAlignedObjectArray_btCollisionObject_const_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject*>" btAlignedObjectArray_btCollisionObject_p {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionObject_p const& otherArray);
  public function extern "at" rptr{btCollisionObject} mutable& at(int n);
  public function extern "at" rptr{btCollisionObject} const& cat(int n) const;
  public function extern "expand" rptr{btCollisionObject} mutable& expand_(rptr{btCollisionObject} const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionObject} const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{btCollisionObject} mutable& expandNonInitializing();
  public function extern "remove" void remove(rptr{btCollisionObject} const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "push_back" void push_back(rptr{btCollisionObject} const& _Val);
  public function extern "resize" void resize(int newsize, rptr{btCollisionObject} const& fillData);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionObject} const& key) const;
  public function extern "size" int size() const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject*>::less" "nodefault" btAlignedObjectArray_btCollisionObject_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btCompoundShapeChild>" btAlignedObjectArray_btCompoundShapeChild {
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCompoundShapeChild const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btCompoundShapeChild const& key) const;
  public function extern "expandNonInitializing" btCompoundShapeChild mutable& expandNonInitializing();
  public function extern "at" btCompoundShapeChild mutable& at(int n);
  public function extern "at" btCompoundShapeChild const& cat(int n) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" btCompoundShapeChild mutable& expand_(btCompoundShapeChild const& fillValue);
  public function extern "push_back" void push_back(btCompoundShapeChild const& _Val);
  public function extern "resize" void resize(int newsize, btCompoundShapeChild const& fillData);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btCompoundShapeChild const& key) const;
  public function extern "remove" void remove(btCompoundShapeChild const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btCompoundShapeChild>::less" "nodefault" btAlignedObjectArray_btCompoundShapeChild_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvtNode const*>" btAlignedObjectArray_btDbvtNode_const_p {
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(crptr{btDbvtNode} const& key);
  public function extern "findBinarySearch" int findBinarySearch(crptr{btDbvtNode} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "resize" void resize(int newsize, crptr{btDbvtNode} const& fillData);
  public function extern "push_back" void push_back(crptr{btDbvtNode} const& _Val);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvtNode_const_p const& otherArray);
  public function extern "capacity" int capacity() const;
  public function extern "expand" crptr{btDbvtNode} mutable& expand_(crptr{btDbvtNode} const& fillValue);
  public function extern "at" crptr{btDbvtNode} mutable& at(int n);
  public function extern "at" crptr{btDbvtNode} const& cat(int n) const;
  public function extern "expandNonInitializing" crptr{btDbvtNode} mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(crptr{btDbvtNode} const& key) const;
  public function extern "pop_back" void pop_back();
}
public threaded struct extern "::btAlignedObjectArray<btDbvtNode const*>::less" "nodefault" btAlignedObjectArray_btDbvtNode_const_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvtProxy*>" "nodefault" btAlignedObjectArray_btDbvtProxy_p private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNN>" btAlignedObjectArray_btDbvt_sStkNN {
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNN const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "resize" void resize(int newsize, btDbvt_sStkNN const& fillData);
  public function extern "push_back" void push_back(btDbvt_sStkNN const& _Val);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btDbvt_sStkNN const& key);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNN const& otherArray);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "expandNonInitializing" btDbvt_sStkNN mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNN const& key) const;
  public function extern "expand" btDbvt_sStkNN mutable& expand_(btDbvt_sStkNN const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "at" btDbvt_sStkNN const& cat(int n) const;
  public function extern "at" btDbvt_sStkNN mutable& at(int n);
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNN>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNN_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNP>" btAlignedObjectArray_btDbvt_sStkNP {
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "remove" void remove(btDbvt_sStkNP const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNP const& key) const;
  public function extern "push_back" void push_back(btDbvt_sStkNP const& _Val);
  public function extern "resize" void resize(int newsize, btDbvt_sStkNP const& fillData);
  public function extern "capacity" int capacity() const;
  public function extern "expand" btDbvt_sStkNP mutable& expand_(btDbvt_sStkNP const& fillValue);
  public function extern "at" btDbvt_sStkNP mutable& at(int n);
  public function extern "at" btDbvt_sStkNP const& cat(int n) const;
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNP const& key) const;
  public function extern "expandNonInitializing" btDbvt_sStkNP mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNP const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNPS>" btAlignedObjectArray_btDbvt_sStkNPS {
  public function extern "resize" void resize(int newsize, btDbvt_sStkNPS const& fillData);
  public function extern "push_back" void push_back(btDbvt_sStkNPS const& _Val);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNPS const& key) const;
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btDbvt_sStkNPS const& key);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNPS const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "expandNonInitializing" btDbvt_sStkNPS mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNPS const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "at" btDbvt_sStkNPS mutable& at(int n);
  public function extern "at" btDbvt_sStkNPS const& cat(int n) const;
  public function extern "expand" btDbvt_sStkNPS mutable& expand_(btDbvt_sStkNPS const& fillValue);
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNPS>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNPS_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNP>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNP_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btHashInt>" btAlignedObjectArray_btHashInt {
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "remove" void remove(btHashInt const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "push_back" void push_back(btHashInt const& _Val);
  public function extern "resize" void resize(int newsize, btHashInt const& fillData);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btHashInt const& key) const;
  public function extern "at" btHashInt const& cat(int n) const;
  public function extern "at" btHashInt mutable& at(int n);
  public function extern "expand" btHashInt mutable& expand_(btHashInt const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btHashInt const& key) const;
  public function extern "expandNonInitializing" btHashInt mutable& expandNonInitializing();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashInt const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btHashInt>::less" "nodefault" btAlignedObjectArray_btHashInt_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btHashPtr>" btAlignedObjectArray_btHashPtr {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashPtr const& otherArray);
  public function extern "at" btHashPtr const& cat(int n) const;
  public function extern "at" btHashPtr mutable& at(int n);
  public function extern "capacity" int capacity() const;
  public function extern "expand" btHashPtr mutable& expand_(btHashPtr const& fillValue);
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btHashPtr const& key) const;
  public function extern "expandNonInitializing" btHashPtr mutable& expandNonInitializing();
  public function extern "remove" void remove(btHashPtr const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "push_back" void push_back(btHashPtr const& _Val);
  public function extern "resize" void resize(int newsize, btHashPtr const& fillData);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btHashPtr const& key) const;
  public function extern "size" int size() const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btHashPtr>::less" "nodefault" btAlignedObjectArray_btHashPtr_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btHashString>" btAlignedObjectArray_btHashString {
  public function extern "expand" btHashString mutable& expand_(btHashString const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "at" btHashString mutable& at(int n);
  public function extern "at" btHashString const& cat(int n) const;
  public function extern "expandNonInitializing" btHashString mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(btHashString const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashString const& otherArray);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btHashString const& key);
  public function extern "findBinarySearch" int findBinarySearch(btHashString const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "resize" void resize(int newsize, btHashString const& fillData);
  public function extern "push_back" void push_back(btHashString const& _Val);
}
public threaded struct extern "::btAlignedObjectArray<btHashString>::less" "nodefault" btAlignedObjectArray_btHashString_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btIndexedMesh>" btAlignedObjectArray_btIndexedMesh {
  public function extern "remove" void remove(btIndexedMesh const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "push_back" void push_back(btIndexedMesh const& _Val);
  public function extern "resize" void resize(int newsize, btIndexedMesh const& fillData);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btIndexedMesh const& key) const;
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btIndexedMesh const& otherArray);
  public function extern "at" btIndexedMesh const& cat(int n) const;
  public function extern "at" btIndexedMesh mutable& at(int n);
  public function extern "expand" btIndexedMesh mutable& expand_(btIndexedMesh const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btIndexedMesh const& key) const;
  public function extern "expandNonInitializing" btIndexedMesh mutable& expandNonInitializing();
}
public threaded struct extern "::btAlignedObjectArray<btIndexedMesh>::less" "nodefault" btAlignedObjectArray_btIndexedMesh_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>" btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p {
  public function extern "remove" void remove(rptr{btMultiSapBroadphase_btBridgeProxy} const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMultiSapBroadphase_btBridgeProxy} const& key) const;
  public function extern "push_back" void push_back(rptr{btMultiSapBroadphase_btBridgeProxy} const& _Val);
  public function extern "resize" void resize(int newsize, rptr{btMultiSapBroadphase_btBridgeProxy} const& fillData);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p const& otherArray);
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& expand_(rptr{btMultiSapBroadphase_btBridgeProxy} const& fillValue);
  public function extern "at" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& at(int n);
  public function extern "at" rptr{btMultiSapBroadphase_btBridgeProxy} const& cat(int n) const;
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMultiSapBroadphase_btBridgeProxy} const& key) const;
  public function extern "expandNonInitializing" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& expandNonInitializing();
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::less" "nodefault" btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>" btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p {
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key);
  public function extern "resize" void resize(int newsize, rptr{btMultiSapBroadphase_btMultiSapProxy} const& fillData);
  public function extern "push_back" void push_back(rptr{btMultiSapBroadphase_btMultiSapProxy} const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p const& otherArray);
  public function extern "at" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& at(int n);
  public function extern "at" rptr{btMultiSapBroadphase_btMultiSapProxy} const& cat(int n) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& expand_(rptr{btMultiSapBroadphase_btMultiSapProxy} const& fillValue);
  public function extern "expandNonInitializing" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key) const;
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::less" "nodefault" btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btOptimizedBvhNode>" btAlignedObjectArray_btOptimizedBvhNode {
  public function extern "expand" btOptimizedBvhNode mutable& expand_(btOptimizedBvhNode const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "at" btOptimizedBvhNode const& cat(int n) const;
  public function extern "at" btOptimizedBvhNode mutable& at(int n);
  public function extern "expandNonInitializing" btOptimizedBvhNode mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btOptimizedBvhNode const& key) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btOptimizedBvhNode const& otherArray);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btOptimizedBvhNode const& key);
  public function extern "findBinarySearch" int findBinarySearch(btOptimizedBvhNode const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "resize" void resize(int newsize, btOptimizedBvhNode const& fillData);
  public function extern "push_back" void push_back(btOptimizedBvhNode const& _Val);
}
public threaded struct extern "::btAlignedObjectArray<btOptimizedBvhNode>::less" "nodefault" btAlignedObjectArray_btOptimizedBvhNode_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btPersistentManifold*>" btAlignedObjectArray_btPersistentManifold_p {
  public function extern "at" rptr{btPersistentManifold} mutable& at(int n);
  public function extern "at" rptr{btPersistentManifold} const& cat(int n) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{btPersistentManifold} mutable& expand_(rptr{btPersistentManifold} const& fillValue);
  public function extern "expandNonInitializing" rptr{btPersistentManifold} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btPersistentManifold} const& key) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btPersistentManifold_p const& otherArray);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(rptr{btPersistentManifold} const& key);
  public function extern "resize" void resize(int newsize, rptr{btPersistentManifold} const& fillData);
  public function extern "push_back" void push_back(rptr{btPersistentManifold} const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btPersistentManifold} const& key) const;
  public function extern "reserve" void reserve(int _Count);
}
public threaded struct extern "::btAlignedObjectArray<btPersistentManifold*>::less" "nodefault" btAlignedObjectArray_btPersistentManifold_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btPointerUid>" btAlignedObjectArray_btPointerUid {
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btPointerUid const& key) const;
  public function extern "resize" void resize(int newsize, btPointerUid const& fillData);
  public function extern "push_back" void push_back(btPointerUid const& _Val);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btPointerUid const& key);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btPointerUid const& otherArray);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "expandNonInitializing" btPointerUid mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btPointerUid const& key) const;
  public function extern "expand" btPointerUid mutable& expand_(btPointerUid const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "at" btPointerUid mutable& at(int n);
  public function extern "at" btPointerUid const& cat(int n) const;
}
public threaded struct extern "::btAlignedObjectArray<btPointerUid>::less" "nodefault" btAlignedObjectArray_btPointerUid_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btQuantizedBvhNode>" btAlignedObjectArray_btQuantizedBvhNode {
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btQuantizedBvhNode const& key) const;
  public function extern "resize" void resize(int newsize, btQuantizedBvhNode const& fillData);
  public function extern "push_back" void push_back(btQuantizedBvhNode const& _Val);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btQuantizedBvhNode const& key);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btQuantizedBvhNode const& otherArray);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "expandNonInitializing" btQuantizedBvhNode mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btQuantizedBvhNode const& key) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" btQuantizedBvhNode mutable& expand_(btQuantizedBvhNode const& fillValue);
  public function extern "at" btQuantizedBvhNode const& cat(int n) const;
  public function extern "at" btQuantizedBvhNode mutable& at(int n);
}
public threaded struct extern "::btAlignedObjectArray<btQuantizedBvhNode>::less" "nodefault" btAlignedObjectArray_btQuantizedBvhNode_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btRigidBody*>" btAlignedObjectArray_btRigidBody_p {
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(rptr{btRigidBody} const& key);
  public function extern "resize" void resize(int newsize, rptr{btRigidBody} const& fillData);
  public function extern "push_back" void push_back(rptr{btRigidBody} const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btRigidBody} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "at" rptr{btRigidBody} mutable& at(int n);
  public function extern "at" rptr{btRigidBody} const& cat(int n) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{btRigidBody} mutable& expand_(rptr{btRigidBody} const& fillValue);
  public function extern "expandNonInitializing" rptr{btRigidBody} mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btRigidBody} const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btRigidBody_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btRigidBody*>::less" "nodefault" btAlignedObjectArray_btRigidBody_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btSolverBody>" btAlignedObjectArray_btSolverBody {
  public function extern "at" btSolverBody const& cat(int n) const;
  public function extern "at" btSolverBody mutable& at(int n);
  public function extern "capacity" int capacity() const;
  public function extern "expand" btSolverBody mutable& expand_(btSolverBody const& fillValue);
  public function extern "expandNonInitializing" btSolverBody mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btSolverBody const& key) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSolverBody const& otherArray);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btSolverBody const& key);
  public function extern "resize" void resize(int newsize, btSolverBody const& fillData);
  public function extern "push_back" void push_back(btSolverBody const& _Val);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btSolverBody const& key) const;
}
public threaded struct extern "::btAlignedObjectArray<btSolverBody>::less" "nodefault" btAlignedObjectArray_btSolverBody_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btSolverConstraint>" btAlignedObjectArray_btSolverConstraint {
  public function extern "expand" btSolverConstraint mutable& expand_(btSolverConstraint const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "at" btSolverConstraint mutable& at(int n);
  public function extern "at" btSolverConstraint const& cat(int n) const;
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btSolverConstraint const& key) const;
  public function extern "expandNonInitializing" btSolverConstraint mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSolverConstraint const& otherArray);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "remove" void remove(btSolverConstraint const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btSolverConstraint const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "push_back" void push_back(btSolverConstraint const& _Val);
  public function extern "resize" void resize(int newsize, btSolverConstraint const& fillData);
}
public threaded struct extern "::btAlignedObjectArray<btSolverConstraint>::less" "nodefault" btAlignedObjectArray_btSolverConstraint_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btTriangleInfo>" btAlignedObjectArray_btTriangleInfo {
  public function extern "resize" void resize(int newsize, btTriangleInfo const& fillData);
  public function extern "push_back" void push_back(btTriangleInfo const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(btTriangleInfo const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btTriangleInfo const& key);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTriangleInfo const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "expandNonInitializing" btTriangleInfo mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btTriangleInfo const& key) const;
  public function extern "at" btTriangleInfo mutable& at(int n);
  public function extern "at" btTriangleInfo const& cat(int n) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" btTriangleInfo mutable& expand_(btTriangleInfo const& fillValue);
}
public threaded struct extern "::btAlignedObjectArray<btTriangleInfo>::less" "nodefault" btAlignedObjectArray_btTriangleInfo_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>" btAlignedObjectArray_btTypedConstraint_btConstraintInfo1 {
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "resize" void resize(int newsize, btTypedConstraint_btConstraintInfo1 const& fillData);
  public function extern "push_back" void push_back(btTypedConstraint_btConstraintInfo1 const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(btTypedConstraint_btConstraintInfo1 const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btTypedConstraint_btConstraintInfo1 const& key);
  public function extern "expandNonInitializing" btTypedConstraint_btConstraintInfo1 mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btTypedConstraint_btConstraintInfo1 const& key) const;
  public function extern "at" btTypedConstraint_btConstraintInfo1 mutable& at(int n);
  public function extern "at" btTypedConstraint_btConstraintInfo1 const& cat(int n) const;
  public function extern "expand" btTypedConstraint_btConstraintInfo1 mutable& expand_(btTypedConstraint_btConstraintInfo1 const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTypedConstraint_btConstraintInfo1 const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::less" "nodefault" btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint*>" btAlignedObjectArray_btTypedConstraint_p {
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(rptr{btTypedConstraint} const& key);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTypedConstraint} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "resize" void resize(int newsize, rptr{btTypedConstraint} const& fillData);
  public function extern "push_back" void push_back(rptr{btTypedConstraint} const& _Val);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTypedConstraint_p const& otherArray);
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{btTypedConstraint} mutable& expand_(rptr{btTypedConstraint} const& fillValue);
  public function extern "at" rptr{btTypedConstraint} mutable& at(int n);
  public function extern "at" rptr{btTypedConstraint} const& cat(int n) const;
  public function extern "expandNonInitializing" rptr{btTypedConstraint} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTypedConstraint} const& key) const;
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint*>::less" "nodefault" btAlignedObjectArray_btTypedConstraint_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btVector3>" btAlignedObjectArray_btVector3 {
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btVector3 const& key);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btVector3 const& key) const;
  public function extern "resize" void resize(int newsize, btVector3 const& fillData);
  public function extern "push_back" void push_back(btVector3 const& _Val);
  public function extern "expand" btVector3 mutable& expand_(btVector3 const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "at" btVector3 const& cat(int n) const;
  public function extern "at" btVector3 mutable& at(int n);
  public function extern "expandNonInitializing" btVector3 mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(btVector3 const& key) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btVector3 const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btVector3>::less" "nodefault" btAlignedObjectArray_btVector3_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btWheelInfo>" btAlignedObjectArray_btWheelInfo {
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btWheelInfo const& otherArray);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "expandNonInitializing" btWheelInfo mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(btWheelInfo const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "expand" btWheelInfo mutable& expand_(btWheelInfo const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "at" btWheelInfo mutable& at(int n);
  public function extern "at" btWheelInfo const& cat(int n) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(btWheelInfo const& key) const;
  public function extern "resize" void resize(int newsize, btWheelInfo const& fillData);
  public function extern "push_back" void push_back(btWheelInfo const& _Val);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(btWheelInfo const& key);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<btWheelInfo>::less" "nodefault" btAlignedObjectArray_btWheelInfo_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<char const*>" btAlignedObjectArray_char_const_p {
  public function extern "resize" void resize(int newsize, crptr{char} const& fillData);
  public function extern "push_back" void push_back(crptr{char} const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(crptr{char} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(crptr{char} const& key);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_char_const_p const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "expandNonInitializing" crptr{char} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(crptr{char} const& key) const;
  public function extern "at" crptr{char} mutable& at(int n);
  public function extern "at" crptr{char} const& cat(int n) const;
  public function extern "expand" crptr{char} mutable& expand_(crptr{char} const& fillValue);
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<char const*>::less" "nodefault" btAlignedObjectArray_char_const_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<char*>" btAlignedObjectArray_char_p {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_char_p const& otherArray);
  public function extern "at" rptr{char} mutable& at(int n);
  public function extern "at" rptr{char} const& cat(int n) const;
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{char} mutable& expand_(rptr{char} const& fillValue);
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(rptr{char} const& key) const;
  public function extern "expandNonInitializing" rptr{char} mutable& expandNonInitializing();
  public function extern "remove" void remove(rptr{char} const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "push_back" void push_back(rptr{char} const& _Val);
  public function extern "resize" void resize(int newsize, rptr{char} const& fillData);
  public function extern "findBinarySearch" int findBinarySearch(rptr{char} const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<char*>::less" "nodefault" btAlignedObjectArray_char_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<float>" btAlignedObjectArray_float {
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_float const& otherArray);
  public function extern "expand" float mutable& expand_(float const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "at" float const& cat(int n) const;
  public function extern "at" float mutable& at(int n);
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(float const& key) const;
  public function extern "expandNonInitializing" float mutable& expandNonInitializing();
  public function extern "remove" void remove(float const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(float const& key) const;
  public function extern "push_back" void push_back(float const& _Val);
  public function extern "resize" void resize(int newsize, float const& fillData);
  public function extern "clear" void clear();
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<float>::less" "nodefault" btAlignedObjectArray_float_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<int>" btAlignedObjectArray_int {
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "resize" void resize(int newsize, int const& fillData);
  public function extern "push_back" void push_back(int const& _Val);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(int const& key) const;
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(int const& key);
  public function extern "expandNonInitializing" int mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(int const& key) const;
  public function extern "at" int const& cat(int n) const;
  public function extern "at" int mutable& at(int n);
  public function extern "expand" int mutable& expand_(int const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_int const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
}
public threaded struct extern "::btAlignedObjectArray<int>::less" "nodefault" btAlignedObjectArray_int_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<short>" btAlignedObjectArray_short {
  public function extern "at" short const& cat(int n) const;
  public function extern "at" short mutable& at(int n);
  public function extern "capacity" int capacity() const;
  public function extern "expand" short mutable& expand_(short const& fillValue);
  public function extern "expandNonInitializing" short mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(short const& key) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_short const& otherArray);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(short const& key);
  public function extern "resize" void resize(int newsize, short const& fillData);
  public function extern "push_back" void push_back(short const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(short const& key) const;
  public function extern "reserve" void reserve(int _Count);
}
public threaded struct extern "::btAlignedObjectArray<short>::less" "nodefault" btAlignedObjectArray_short_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<short*>" btAlignedObjectArray_short_p {
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_short_p const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "expandNonInitializing" rptr{short} mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(rptr{short} const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{short} const& cat(int n) const;
  public function extern "at" rptr{short} mutable& at(int n);
  public function extern "capacity" int capacity() const;
  public function extern "expand" rptr{short} mutable& expand_(rptr{short} const& fillValue);
  public function extern "resize" void resize(int newsize, rptr{short} const& fillData);
  public function extern "push_back" void push_back(rptr{short} const& _Val);
  public function extern "reserve" void reserve(int _Count);
  public function extern "findBinarySearch" int findBinarySearch(rptr{short} const& key) const;
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(rptr{short} const& key);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<short*>::less" "nodefault" btAlignedObjectArray_short_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<unsigned int>" btAlignedObjectArray_unsigned_int {
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_unsigned_int const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "expandNonInitializing" uint mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(uint const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "at" uint const& cat(int n) const;
  public function extern "at" uint mutable& at(int n);
  public function extern "expand" uint mutable& expand_(uint const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize, uint const& fillData);
  public function extern "push_back" void push_back(uint const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(uint const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(uint const& key);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<unsigned int>::less" "nodefault" btAlignedObjectArray_unsigned_int_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<unsigned short>" btAlignedObjectArray_unsigned_short {
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_unsigned_short const& otherArray);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "findLinearSearch" int findLinearSearch(ushort const& key) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" ushort mutable& expandNonInitializing();
  public function extern "at" ushort mutable& at(int n);
  public function extern "at" ushort const& cat(int n) const;
  public function extern "expand" ushort mutable& expand_(ushort const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "push_back" void push_back(ushort const& _Val);
  public function extern "resize" void resize(int newsize, ushort const& fillData);
  public function extern "findBinarySearch" int findBinarySearch(ushort const& key) const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "remove" void remove(ushort const& key);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<unsigned short>::less" "nodefault" btAlignedObjectArray_unsigned_short_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<void*>" btAlignedObjectArray_void_p {
  public function extern "at" rptr{void} mutable& at(int n);
  public function extern "at" rptr{void} const& cat(int n) const;
  public function extern "expand" rptr{void} mutable& expand_(rptr{void} const& fillValue);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" rptr{void} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "findLinearSearch" int findLinearSearch(rptr{void} const& key) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_void_p const& otherArray);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "swap" void swap(int index0, int index1);
  public function extern "remove" void remove(rptr{void} const& key);
  public function extern "resize" void resize(int newsize, rptr{void} const& fillData);
  public function extern "push_back" void push_back(rptr{void} const& _Val);
  public function extern "findBinarySearch" int findBinarySearch(rptr{void} const& key) const;
  public function extern "reserve" void reserve(int _Count);
}
public threaded struct extern "::btAlignedObjectArray<void*>::less" "nodefault" btAlignedObjectArray_void_p_less private()  {
}
public metafunction btAllocFunc meta::list{rptr{void}, size_t};
public threaded struct extern "::btAngularLimit" btAngularLimit {
  public function extern "set" void set(btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
  public function extern "fit" void fit(btScalar mutable& angle) const;
  public function extern "getRelaxationFactor" btScalar getRelaxationFactor() const;
  public function extern "test" void test(btScalar const angle);
  public function extern "getCorrection" btScalar getCorrection() const;
  public function extern "getSoftness" btScalar getSoftness() const;
  public function extern "getHigh" btScalar getHigh() const;
  public function extern "getError" btScalar getError() const;
  public function extern "getHalfRange" btScalar getHalfRange() const;
  public function extern "getLow" btScalar getLow() const;
  public function extern "isLimit" bool isLimit() const;
  public function extern "getSign" btScalar getSign() const;
  public function extern "getBiasFactor" btScalar getBiasFactor() const;
}
public threaded struct extern "::btAxisSweep3" "nodefault" btAxisSweep3(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, ushort maxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator)  {
  public metafunction __base__ {btBroadphaseInterface, btAxisSweep3Internal_unsigned_short};
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "addHandle" ushort addHandle(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} pOwner, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback);
  public function extern "printStats" void printStats();
  public function extern "removeHandle" void removeHandle(ushort handle, rptr{btDispatcher} dispatcher);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "getNumHandles" ushort getNumHandles() const;
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "quantize" void quantize(rptr{ushort} out, btVector3 const& point, int isMax) const;
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_short_Handle} getHandle(ushort index) const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "updateHandle" void updateHandle(ushort handle, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>" "nodefault" btAxisSweep3Internal_unsigned_int(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, uint handleMask, uint handleSentinel, uint userMaxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "addHandle" uint addHandle(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} pOwner, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} _0);
  public function extern "printStats" void printStats();
  public function extern "removeHandle" void removeHandle(uint handle, rptr{btDispatcher} dispatcher);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "quantize" void quantize(rptr{uint} out, btVector3 const& point, int isMax) const;
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback);
  public function extern "getNumHandles" uint getNumHandles() const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "updateHandle" void updateHandle(uint handle, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_int_Handle} getHandle(uint index) const;
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>::Edge" "nodefault" btAxisSweep3Internal_unsigned_int_Edge private()  {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>::Handle" "nodefault" btAxisSweep3Internal_unsigned_int_Handle private()  {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>" "nodefault" btAxisSweep3Internal_unsigned_short(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, ushort handleMask, ushort handleSentinel, ushort userMaxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "addHandle" ushort addHandle(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} pOwner, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} _0);
  public function extern "printStats" void printStats();
  public function extern "removeHandle" void removeHandle(ushort handle, rptr{btDispatcher} dispatcher);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "quantize" void quantize(rptr{ushort} out, btVector3 const& point, int isMax) const;
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback);
  public function extern "getNumHandles" ushort getNumHandles() const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "updateHandle" void updateHandle(ushort handle, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_short_Handle} getHandle(ushort index) const;
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>::Edge" "nodefault" btAxisSweep3Internal_unsigned_short_Edge private()  {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>::Handle" "nodefault" btAxisSweep3Internal_unsigned_short_Handle private()  {
}
public threaded struct extern "::btBU_Simplex1to4" "nonmovable" btBU_Simplex1to4 {
  public metafunction __base__ {btConvexInternalShape, btPolyhedralConvexShape, btPolyhedralConvexAabbCachingShape, btConvexShape, btCollisionShape};
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "getIndex" int getIndex(int i) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax, btScalar margin) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin);
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "addVertex" void addVertex(btVector3 const& pt);
  public function extern "isConvex" bool isConvex() const;
  public function extern "reset" void reset();
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
}
public threaded struct extern "::btBlock" btBlock {
  public rptr{btBlock} previous;
  public rptr{uchar} address;
}
public threaded struct extern "::btBoxShape" "nodefault" btBoxShape(btVector3 const& boxHalfExtents)  {
  public metafunction __base__ {btConvexShape, btPolyhedralConvexShape, btConvexInternalShape, btCollisionShape};
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "getPlaneEquation" void getPlaneEquation(btVector4 mutable& plane, int i) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin);
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
}
public threaded struct extern "::btBroadphaseAabbCallback" "nonmovable" btBroadphaseAabbCallback {
  public function extern "process" bool process(crptr{btBroadphaseProxy} proxy);
}
public threaded struct extern "::btBroadphaseInterface" "nonmovable" btBroadphaseInterface {
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public function extern "printStats" void printStats();
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
}
public threaded struct extern "::btBroadphasePair" btBroadphasePair {
  public rptr{btCollisionAlgorithm} m_algorithm;
  public rptr{btBroadphaseProxy} m_pProxy1;
  public rptr{btBroadphaseProxy} m_pProxy0;
}
public metafunction btBroadphasePairArray btAlignedObjectArray_btBroadphasePair;
public threaded struct extern "::btBroadphasePairSortPredicate" btBroadphasePairSortPredicate {
}
/* skip btBroadphasePair_27 : unnamed */
public threaded struct extern "::btBroadphaseProxy" btBroadphaseProxy {
  public function extern "getUid" int getUid() const;
  public btVector3 m_aabbMin;
  public int m_uniqueId;
  public rptr{void} m_clientObject;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
  public short m_collisionFilterGroup;
  public btVector3 m_aabbMax;
}
public threaded struct extern "::btBroadphaseRayCallback" btBroadphaseRayCallback {
  public metafunction __base__ {btBroadphaseAabbCallback};
  public function extern "process" bool process(crptr{btBroadphaseProxy} proxy);
  public btVector3 m_rayDirectionInverse;
  public btScalar m_lambda_max;
  public rawarray{uint, 3} m_signs;
}
public threaded struct extern "::btBvhSubtreeInfo" btBvhSubtreeInfo {
  public function extern "setAabbFromQuantizeNode" void setAabbFromQuantizeNode(btQuantizedBvhNode const& quantizedNode);
  public int m_subtreeSize;
  public int m_rootNodeIndex;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{int, 3} m_padding;
}
public threaded struct extern "::btBvhSubtreeInfoData" btBvhSubtreeInfoData {
  public int m_subtreeSize;
  public int m_rootNodeIndex;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public rawarray{ushort, 3} m_quantizedAabbMin;
}
public threaded struct extern "::btBvhTriangleMeshShape" "nodefault" btBvhTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface, bool useQuantizedAabbCompression, bool buildBvh)  {
  public metafunction __base__ {btCollisionShape, btConcaveShape, btTriangleMeshShape};
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getOptimizedBvh" rptr{btOptimizedBvh} getOptimizedBvh();
  public function extern "isCompound" bool isCompound() const;
  public function extern "buildOptimizedBvh" void buildOptimizedBvh();
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "usesQuantizedAabbCompression" bool usesQuantizedAabbCompression() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "partialRefitTree" void partialRefitTree(btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "serializeSingleBvh" void serializeSingleBvh(rptr{btSerializer} serializer) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "serializeSingleTriangleInfoMap" void serializeSingleTriangleInfoMap(rptr{btSerializer} serializer) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "isConvex" bool isConvex() const;
  public function extern "performRaycast" void performRaycast(rptr{btTriangleCallback} callback, btVector3 const& raySource, btVector3 const& rayTarget);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getTriangleInfoMap" crptr{btTriangleInfoMap} cgetTriangleInfoMap() const;
  public function extern "getTriangleInfoMap" rptr{btTriangleInfoMap} getTriangleInfoMap();
  public function extern "setOptimizedBvh" void setOptimizedBvh(rptr{btOptimizedBvh} bvh, btVector3 const& localScaling);
  public function extern "performConvexcast" void performConvexcast(rptr{btTriangleCallback} callback, btVector3 const& boxSource, btVector3 const& boxTarget, btVector3 const& boxMin, btVector3 const& boxMax);
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setTriangleInfoMap" void setTriangleInfoMap(rptr{btTriangleInfoMap} triangleInfoMap);
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "refitTree" void refitTree(btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getOwnsBvh" bool getOwnsBvh() const;
}
public threaded struct extern "::btCapsuleShape" "nodefault" btCapsuleShape(btScalar radius, btScalar height)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCollisionShape};
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
}
public threaded struct extern "::btCapsuleShapeData" btCapsuleShapeData {
  public rawarray{char, 4} m_padding;
  public int m_upAxis;
  public btConvexInternalShapeData m_convexInternalShapeData;
}
public threaded struct extern "::btCapsuleShapeX" "nodefault" btCapsuleShapeX(btScalar radius, btScalar height)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCapsuleShape, btCollisionShape};
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "getRadius" btScalar getRadius() const;
}
public threaded struct extern "::btCapsuleShapeZ" "nodefault" btCapsuleShapeZ(btScalar radius, btScalar height)  {
  public metafunction __base__ {btCollisionShape, btConvexShape, btConvexInternalShape, btCapsuleShape};
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
}
public threaded struct extern "::btCharIndexTripletData" btCharIndexTripletData {
  public rawarray{uchar, 3} m_values;
  public char m_pad;
}
public threaded struct extern "::btChunk" btChunk {
  public int m_length;
  public int m_dna_nr;
  public int m_number;
  public rptr{void} m_oldPtr;
  public int m_chunkCode;
}
public threaded struct extern "::btClock" btClock {
  public function extern "getTimeMicroseconds" ulong getTimeMicroseconds();
  public function extern "reset" void reset();
  public function extern "getTimeMilliseconds" ulong getTimeMilliseconds();
}
public threaded struct extern "::btClockData" "nodefault" btClockData private()  {
}
public threaded struct extern "::btCollisionAlgorithm" "nonmovable" btCollisionAlgorithm {
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0, rptr{btCollisionObject} body1, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
}
public threaded struct extern "::btCollisionAlgorithmConstructionInfo" btCollisionAlgorithmConstructionInfo {
  public rptr{btPersistentManifold} m_manifold;
  public rptr{btDispatcher} m_dispatcher1;
}
public threaded struct extern "::btCollisionAlgorithmCreateFunc" "nonmovable" btCollisionAlgorithmCreateFunc {
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap);
  public bool m_swapped;
}
public threaded struct extern "::btCollisionConfiguration" "nonmovable" btCollisionConfiguration {
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0, int proxyType1);
  public function extern "getStackAllocator" rptr{btStackAlloc} getStackAllocator();
}
public threaded struct extern "::btCollisionDispatcher" "nodefault" btCollisionDispatcher(rptr{btCollisionConfiguration} collisionConfiguration)  {
  public metafunction __base__ {btDispatcher};
  public function extern "getNewManifold" rptr{btPersistentManifold} getNewManifold(crptr{btCollisionObject} b0, crptr{btCollisionObject} b1);
  public function extern "setDispatcherFlags" void setDispatcherFlags(int flags);
  public function extern "setCollisionConfiguration" void setCollisionConfiguration(rptr{btCollisionConfiguration} config);
  public function extern "getInternalManifoldPointer" rptr{rptr{btPersistentManifold}} getInternalManifoldPointer();
  public function extern "getInternalManifoldPool" rptr{btPoolAllocator} getInternalManifoldPool();
  public function extern "getInternalManifoldPool" crptr{btPoolAllocator} cgetInternalManifoldPool() const;
  public function extern "dispatchAllCollisionPairs" void dispatchAllCollisionPairs(rptr{btOverlappingPairCache} pairCache, btDispatcherInfo const& dispatchInfo, rptr{btDispatcher} dispatcher);
  public function extern "getNearCallback" btNearCallback getNearCallback() const;
  public function extern "clearManifold" void clearManifold(rptr{btPersistentManifold} manifold);
  public function extern "findAlgorithm" rptr{btCollisionAlgorithm} findAlgorithm(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, rptr{btPersistentManifold} sharedManifold);
  public function extern "getManifoldByIndexInternal" rptr{btPersistentManifold} getManifoldByIndexInternal(int index);
  public function extern "getManifoldByIndexInternal" crptr{btPersistentManifold} cgetManifoldByIndexInternal(int index) const;
  public function extern "needsResponse" bool needsResponse(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "registerCollisionCreateFunc" void registerCollisionCreateFunc(int proxyType0, int proxyType1, rptr{btCollisionAlgorithmCreateFunc} createFunc);
  public function extern "freeCollisionAlgorithm" void freeCollisionAlgorithm(rptr{void} ptr);
  public function extern "getDispatcherFlags" int getDispatcherFlags() const;
  public function extern "setNearCallback" void setNearCallback(btNearCallback nearCallback);
  public function extern "releaseManifold" void releaseManifold(rptr{btPersistentManifold} manifold);
  public function extern "needsCollision" bool needsCollision(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "getCollisionConfiguration" rptr{btCollisionConfiguration} getCollisionConfiguration();
  public function extern "getCollisionConfiguration" crptr{btCollisionConfiguration} cgetCollisionConfiguration() const;
  public function extern "allocateCollisionAlgorithm" rptr{void} allocateCollisionAlgorithm(int size);
  public function extern "getNumManifolds" int getNumManifolds() const;
}
public threaded struct extern "::btCollisionObject" "nonmovable" btCollisionObject {
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer);
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle);
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer) const;
  public function extern "isActive" bool isActive() const;
  public function extern "setCollisionFlags" void setCollisionFlags(int flags);
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "getInternalType" int getInternalType() const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans);
  public function extern "setCompanionId" void setCompanionId(int id);
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode) const;
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co) const;
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time);
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold);
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction);
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "activate" void activate(bool forceActivation) const;
  public function extern "setActivationState" void setActivationState(int newState) const;
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict);
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "setFriction" void setFriction(btScalar frict);
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "forceActivationState" void forceActivationState(int newState) const;
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "setRestitution" void setRestitution(btScalar rest);
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius);
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans);
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold);
  public function extern "setIslandTag" void setIslandTag(int tag);
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction, int frictionMode);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape);
}
public metafunction btCollisionObjectArray btAlignedObjectArray_btCollisionObject_p;
public threaded struct extern "::btCollisionObjectDoubleData" btCollisionObjectDoubleData {
  public btTransformDoubleData m_interpolationWorldTransform;
  public double m_contactProcessingThreshold;
  public rptr{void} m_broadphaseHandle;
  public double m_hitFraction;
  public btTransformDoubleData m_worldTransform;
  public int m_internalType;
  public int m_collisionFlags;
  public int m_islandTag1;
  public btVector3DoubleData m_interpolationAngularVelocity;
  public rptr{char} m_name;
  public double m_rollingFriction;
  public double m_friction;
  public int m_companionId;
  public rptr{btCollisionShapeData} m_rootCollisionShape;
  public double m_restitution;
  public int m_hasAnisotropicFriction;
  public int m_activationState1;
  public rptr{void} m_collisionShape;
  public double m_deactivationTime;
  public int m_checkCollideWith;
  public btVector3DoubleData m_anisotropicFriction;
  public double m_ccdSweptSphereRadius;
  public rawarray{char, 4} m_padding;
  public double m_ccdMotionThreshold;
  public btVector3DoubleData m_interpolationLinearVelocity;
}
public threaded struct extern "::btCollisionObjectFloatData" btCollisionObjectFloatData {
  public btTransformFloatData m_worldTransform;
  public float m_hitFraction;
  public rptr{void} m_broadphaseHandle;
  public btTransformFloatData m_interpolationWorldTransform;
  public float m_contactProcessingThreshold;
  public float m_friction;
  public float m_rollingFriction;
  public rptr{char} m_name;
  public int m_islandTag1;
  public btVector3FloatData m_interpolationAngularVelocity;
  public int m_internalType;
  public int m_collisionFlags;
  public int m_activationState1;
  public rptr{void} m_collisionShape;
  public btVector3FloatData m_anisotropicFriction;
  public int m_checkCollideWith;
  public float m_deactivationTime;
  public float m_restitution;
  public int m_hasAnisotropicFriction;
  public int m_companionId;
  public rptr{btCollisionShapeData} m_rootCollisionShape;
  public btVector3FloatData m_interpolationLinearVelocity;
  public rawarray{char, 4} m_padding;
  public float m_ccdMotionThreshold;
  public float m_ccdSweptSphereRadius;
}
public threaded struct extern "::btCollisionObjectWrapper" "nodefault" btCollisionObjectWrapper(crptr{btCollisionObjectWrapper} parent, crptr{btCollisionShape} shape, crptr{btCollisionObject} collisionObject, btTransform const& worldTransform)  {
  public function extern "getCollisionShape" crptr{btCollisionShape} getCollisionShape() const;
  public function extern "getWorldTransform" btTransform const& getWorldTransform() const;
  public function extern "getCollisionObject" crptr{btCollisionObject} getCollisionObject() const;
  public crptr{btCollisionShape} m_shape;
  public crptr{btCollisionObjectWrapper} m_parent;
  public crptr{btCollisionObject} m_collisionObject;
}
public threaded struct extern "::btCollisionResult" "nodefault" btCollisionResult private()  {
}
public threaded struct extern "::btCollisionShape" "nonmovable" btCollisionShape {
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
}
public threaded struct extern "::btCollisionShapeData" btCollisionShapeData {
  public rawarray{char, 4} m_padding;
  public int m_shapeType;
  public rptr{char} m_name;
}
public threaded struct extern "::btCollisionWorld" "nodefault" btCollisionWorld(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} broadphasePairCache, rptr{btCollisionConfiguration} collisionConfiguration)  {
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer);
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj);
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform, crptr{btCollisionShape} shape, btVector3 const& color);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape, btTransform const& from, btTransform const& to, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedCcdPenetration) const;
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache);
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld, btVector3 const& rayToWorld, btCollisionWorld_RayResultCallback mutable& resultCallback) const;
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "updateAabbs" void updateAabbs();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA, rptr{btCollisionObject} colObjB, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject, short collisionFilterGroup, short collisionFilterMask);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject);
  public function extern "debugDrawWorld" void debugDrawWorld();
}
public threaded struct extern "::btCollisionWorld::AllHitsRayResultCallback" "nodefault" btCollisionWorld_AllHitsRayResultCallback(btVector3 const& rayFromWorld, btVector3 const& rayToWorld)  {
  public metafunction __base__ {btCollisionWorld_RayResultCallback};
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public function extern "hasHit" bool hasHit() const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult, bool normalInWorldSpace);
  public btAlignedObjectArray_float m_hitFractions;
  public short m_collisionFilterMask;
  public crptr{btCollisionObject} m_collisionObject;
  public btVector3 m_rayToWorld;
  public uint m_flags;
  public btAlignedObjectArray_btCollisionObject_const_p m_collisionObjects;
  public btScalar m_closestHitFraction;
  public short m_collisionFilterGroup;
  public btVector3 m_rayFromWorld;
  public btAlignedObjectArray_btVector3 m_hitNormalWorld;
  public btAlignedObjectArray_btVector3 m_hitPointWorld;
}
public threaded struct extern "::btCollisionWorld::ClosestConvexResultCallback" "nodefault" btCollisionWorld_ClosestConvexResultCallback(btVector3 const& convexFromWorld, btVector3 const& convexToWorld)  {
  public metafunction __base__ {btCollisionWorld_ConvexResultCallback};
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalConvexResult mutable& convexResult, bool normalInWorldSpace);
  public function extern "hasHit" bool hasHit() const;
  public crptr{btCollisionObject} m_hitCollisionObject;
  public btVector3 m_convexFromWorld;
  public short m_collisionFilterMask;
  public short m_collisionFilterGroup;
  public btVector3 m_convexToWorld;
  public btScalar m_closestHitFraction;
  public btVector3 m_hitPointWorld;
  public btVector3 m_hitNormalWorld;
}
public threaded struct extern "::btCollisionWorld::ClosestRayResultCallback" "nodefault" btCollisionWorld_ClosestRayResultCallback(btVector3 const& rayFromWorld, btVector3 const& rayToWorld)  {
  public metafunction __base__ {btCollisionWorld_RayResultCallback};
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult, bool normalInWorldSpace);
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public btVector3 m_hitPointWorld;
  public btVector3 m_hitNormalWorld;
  public btVector3 m_rayFromWorld;
  public short m_collisionFilterGroup;
  public btScalar m_closestHitFraction;
  public uint m_flags;
  public crptr{btCollisionObject} m_collisionObject;
  public short m_collisionFilterMask;
  public btVector3 m_rayToWorld;
}
public threaded struct extern "::btCollisionWorld::ContactResultCallback" "nonmovable" btCollisionWorld_ContactResultCallback {
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public function extern "addSingleResult" btScalar addSingleResult(btManifoldPoint mutable& cp, crptr{btCollisionObjectWrapper} colObj0Wrap, int partId0, int index0, crptr{btCollisionObjectWrapper} colObj1Wrap, int partId1, int index1);
  public short m_collisionFilterMask;
  public short m_collisionFilterGroup;
}
public threaded struct extern "::btCollisionWorld::ConvexResultCallback" "nonmovable" btCollisionWorld_ConvexResultCallback {
  public function extern "hasHit" bool hasHit() const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalConvexResult mutable& convexResult, bool normalInWorldSpace);
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public short m_collisionFilterMask;
  public btScalar m_closestHitFraction;
  public short m_collisionFilterGroup;
}
public threaded struct extern "::btCollisionWorld::LocalConvexResult" "nodefault" btCollisionWorld_LocalConvexResult(crptr{btCollisionObject} hitCollisionObject, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo, btVector3 const& hitNormalLocal, btVector3 const& hitPointLocal, btScalar hitFraction)  {
  public rptr{btCollisionWorld_LocalShapeInfo} m_localShapeInfo;
  public btVector3 m_hitNormalLocal;
  public btScalar m_hitFraction;
  public btVector3 m_hitPointLocal;
  public crptr{btCollisionObject} m_hitCollisionObject;
}
public threaded struct extern "::btCollisionWorld::LocalRayResult" "nodefault" btCollisionWorld_LocalRayResult(crptr{btCollisionObject} collisionObject, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo, btVector3 const& hitNormalLocal, btScalar hitFraction)  {
  public crptr{btCollisionObject} m_collisionObject;
  public rptr{btCollisionWorld_LocalShapeInfo} m_localShapeInfo;
  public btScalar m_hitFraction;
  public btVector3 m_hitNormalLocal;
}
public threaded struct extern "::btCollisionWorld::LocalShapeInfo" btCollisionWorld_LocalShapeInfo {
  public int m_triangleIndex;
  public int m_shapePart;
}
public threaded struct extern "::btCollisionWorld::RayResultCallback" "nonmovable" btCollisionWorld_RayResultCallback {
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult, bool normalInWorldSpace);
  public function extern "hasHit" bool hasHit() const;
  public short m_collisionFilterMask;
  public crptr{btCollisionObject} m_collisionObject;
  public uint m_flags;
  public btScalar m_closestHitFraction;
  public short m_collisionFilterGroup;
}
public threaded struct extern "::btCompoundShape" "nodefault" btCompoundShape(bool enableDynamicAabbTree)  {
  public metafunction __base__ {btCollisionShape};
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "getChildList" rptr{btCompoundShapeChild} getChildList();
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getDynamicAabbTree" crptr{btDbvt} cgetDynamicAabbTree() const;
  public function extern "getDynamicAabbTree" rptr{btDbvt} getDynamicAabbTree();
  public function extern "getNumChildShapes" int getNumChildShapes() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "recalculateLocalAabb" void recalculateLocalAabb();
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculatePrincipalAxisTransform" void calculatePrincipalAxisTransform(rptr{btScalar} masses, btTransform mutable& principal, btVector3 mutable& inertia) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getChildTransform" btTransform const& cgetChildTransform(int index) const;
  public function extern "getChildTransform" btTransform mutable& getChildTransform(int index);
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "addChildShape" void addChildShape(btTransform const& localTransform, rptr{btCollisionShape} shape);
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "removeChildShape" void removeChildShape(rptr{btCollisionShape} shape);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "updateChildTransform" void updateChildTransform(int childIndex, btTransform const& newChildTransform, bool shouldRecalculateLocalAabb);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getUpdateRevision" int getUpdateRevision() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index);
  public function extern "getChildShape" crptr{btCollisionShape} cgetChildShape(int index) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "createAabbTreeFromChildren" void createAabbTreeFromChildren();
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "removeChildShapeByIndex" void removeChildShapeByIndex(int childShapeindex);
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
}
public threaded struct extern "::btCompoundShapeChild" btCompoundShapeChild {
  public btScalar m_childMargin;
  public rptr{btCollisionShape} m_childShape;
  public rptr{btDbvtNode} m_node;
  public btTransform m_transform;
  public int m_childShapeType;
}
public threaded struct extern "::btCompoundShapeChildData" btCompoundShapeChildData {
  public rptr{btCollisionShapeData} m_childShape;
  public float m_childMargin;
  public int m_childShapeType;
  public btTransformFloatData m_transform;
}
public threaded struct extern "::btCompoundShapeData" btCompoundShapeData {
  public float m_collisionMargin;
  public rptr{btCompoundShapeChildData} m_childShapePtr;
  public int m_numChildShapes;
  public btCollisionShapeData m_collisionShapeData;
}
public threaded struct extern "::btConcaveShape" "nonmovable" btConcaveShape {
  public metafunction __base__ {btCollisionShape};
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
}
public threaded struct extern "::btConeShape" "nodefault" btConeShape(btScalar radius, btScalar height)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCollisionShape};
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex);
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
}
public threaded struct extern "::btConeShapeX" "nodefault" btConeShapeX(btScalar radius, btScalar height)  {
  public metafunction __base__ {btConvexShape, btConeShape, btConvexInternalShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex);
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
}
public threaded struct extern "::btConeShapeZ" "nodefault" btConeShapeZ(btScalar radius, btScalar height)  {
  public metafunction __base__ {btCollisionShape, btConvexShape, btConvexInternalShape, btConeShape};
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex);
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
}
public threaded struct extern "::btConeTwistConstraint" "nodefault" btConeTwistConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& rbAFrame, btTransform const& rbBFrame)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint};
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "GetPointForAngle" btVector3 GetPointForAngle(btScalar fAngleInRadians, btScalar fLength) const;
  public function extern "getTwistLimitSign" btScalar getTwistLimitSign();
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "calcAngleInfo" void calcAngleInfo();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getTwistSpan" btScalar getTwistSpan();
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getAFrame" btTransform const& getAFrame();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getFrameOffsetA" btTransform const& getFrameOffsetA() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "setMotorTargetInConstraintSpace" void setMotorTargetInConstraintSpace(btQuaternion const& q);
  public function extern "getSolveTwistLimit" int getSolveTwistLimit();
  public function extern "getSwingSpan1" btScalar getSwingSpan1();
  public function extern "calcAngleInfo2" void calcAngleInfo2(btTransform const& transA, btTransform const& transB, btMatrix3x3 const& invInertiaWorldA, btMatrix3x3 const& invInertiaWorldB);
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getUid" int getUid() const;
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btMatrix3x3 const& invInertiaWorldA, btMatrix3x3 const& invInertiaWorldB);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "setMaxMotorImpulseNormalized" void setMaxMotorImpulseNormalized(btScalar maxMotorImpulse);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getBFrame" btTransform const& getBFrame();
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "getSwingSpan2" btScalar getSwingSpan2();
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "setDamping" void setDamping(btScalar damping);
  public function extern "getFixThresh" btScalar getFixThresh();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& bodyA, btSolverBody mutable& bodyB, btScalar timeStep);
  public function extern "setLimit" void setLimit2(int limitIndex, btScalar limitValue);
  public function extern "setLimit" void setLimit6(btScalar _swingSpan1, btScalar _swingSpan2, btScalar _twistSpan, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
  public function extern "getFrameOffsetB" btTransform const& getFrameOffsetB() const;
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "getTwistAngle" btScalar getTwistAngle();
  public function extern "setMotorTarget" void setMotorTarget(btQuaternion const& q);
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "isPastSwingLimit" bool isPastSwingLimit();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "getSolveSwingLimit" int getSolveSwingLimit();
  public function extern "setFixThresh" void setFixThresh(btScalar fixThresh);
  public function extern "enableMotor" void enableMotor(bool b);
  public int m_objectType;
}
public threaded struct extern "::btConeTwistConstraintData" btConeTwistConstraintData {
  public float m_relaxationFactor;
  public float m_damping;
  public rawarray{char, 4} m_pad;
  public float m_biasFactor;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public btTypedConstraintData m_typeConstraintData;
  public float m_limitSoftness;
  public float m_swingSpan1;
  public float m_swingSpan2;
  public float m_twistSpan;
}
public tsvaluetype struct extern "::btConeTwistFlags" "extenum" btConeTwistFlags { }
public extern "BT_CONETWIST_FLAGS_LIN_CFM" btConeTwistFlags BT_CONETWIST_FLAGS_LIN_CFM;
public extern "BT_CONETWIST_FLAGS_LIN_ERP" btConeTwistFlags BT_CONETWIST_FLAGS_LIN_ERP;
public extern "BT_CONETWIST_FLAGS_ANG_CFM" btConeTwistFlags BT_CONETWIST_FLAGS_ANG_CFM;
public metafunction btConstraintArray btAlignedObjectArray_btSolverConstraint;
public tsvaluetype struct extern "::btConstraintParams" "extenum" btConstraintParams { }
public extern "BT_CONSTRAINT_ERP" btConstraintParams BT_CONSTRAINT_ERP;
public extern "BT_CONSTRAINT_STOP_ERP" btConstraintParams BT_CONSTRAINT_STOP_ERP;
public extern "BT_CONSTRAINT_CFM" btConstraintParams BT_CONSTRAINT_CFM;
public extern "BT_CONSTRAINT_STOP_CFM" btConstraintParams BT_CONSTRAINT_STOP_CFM;
public threaded struct extern "::btConstraintRow" btConstraintRow {
  public rawarray{btScalar, 3} m_normal;
  public btScalar m_rhs;
  public btScalar m_accumImpulse;
  public btScalar m_lowerLimit;
  public btScalar m_upperLimit;
  public btScalar m_jacDiagInv;
}
public threaded struct extern "::btConstraintSetting" btConstraintSetting {
  public btScalar m_impulseClamp;
  public btScalar m_tau;
  public btScalar m_damping;
}
public threaded struct extern "::btConstraintSolver" "nonmovable" btConstraintSolver {
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies, int numBodies, rptr{rptr{btPersistentManifold}} manifold, int numManifolds, rptr{rptr{btTypedConstraint}} constraints, int numConstraints, btContactSolverInfo const& info, rptr{btIDebugDraw} debugDrawer, rptr{btStackAlloc} stackAlloc, rptr{btDispatcher} dispatcher);
  public function extern "reset" void reset();
  public function extern "prepareSolve" void prepareSolve(int _0, int _1);
  public function extern "allSolved" void allSolved(btContactSolverInfo const& _0, rptr{btIDebugDraw} _1, rptr{btStackAlloc} _2);
}
public tsvaluetype struct extern "::btContactManifoldTypes" "extenum" btContactManifoldTypes { }
public extern "MIN_CONTACT_MANIFOLD_TYPE" btContactManifoldTypes MIN_CONTACT_MANIFOLD_TYPE;
public extern "BT_PERSISTENT_MANIFOLD_TYPE" btContactManifoldTypes BT_PERSISTENT_MANIFOLD_TYPE;
public threaded struct extern "::btContactSolverInfo" btContactSolverInfo {
  public metafunction __base__ {btContactSolverInfoData};
  public btScalar m_splitImpulsePenetrationThreshold;
  public btScalar m_globalCfm;
  public btScalar m_friction;
  public btScalar m_maxErrorReduction;
  public btScalar m_sor;
  public btScalar m_timeStep;
  public int m_numIterations;
  public int m_restingContactRestitutionThreshold;
  public btScalar m_maxGyroscopicForce;
  public btScalar m_tau;
  public btScalar m_warmstartingFactor;
  public btScalar m_linearSlop;
  public int m_splitImpulse;
  public int m_solverMode;
  public btScalar m_erp;
  public btScalar m_erp2;
  public btScalar m_damping;
  public btScalar m_restitution;
  public btScalar m_splitImpulseTurnErp;
  public btScalar m_singleAxisRollingFrictionThreshold;
  public int m_minimumSolverBatchSize;
}
public threaded struct extern "::btContactSolverInfoData" btContactSolverInfoData {
  public btScalar m_globalCfm;
  public btScalar m_friction;
  public btScalar m_maxErrorReduction;
  public btScalar m_splitImpulsePenetrationThreshold;
  public btScalar m_sor;
  public btScalar m_timeStep;
  public int m_numIterations;
  public btScalar m_maxGyroscopicForce;
  public int m_restingContactRestitutionThreshold;
  public btScalar m_linearSlop;
  public btScalar m_warmstartingFactor;
  public btScalar m_tau;
  public btScalar m_erp;
  public btScalar m_damping;
  public btScalar m_erp2;
  public int m_solverMode;
  public int m_splitImpulse;
  public btScalar m_singleAxisRollingFrictionThreshold;
  public int m_minimumSolverBatchSize;
  public btScalar m_splitImpulseTurnErp;
  public btScalar m_restitution;
}
public threaded struct extern "::btContactSolverInfoDoubleData" btContactSolverInfoDoubleData {
  public double m_timeStep;
  public double m_sor;
  public int m_numIterations;
  public double m_maxErrorReduction;
  public double m_globalCfm;
  public double m_friction;
  public double m_splitImpulsePenetrationThreshold;
  public double m_damping;
  public double m_erp2;
  public double m_erp;
  public int m_splitImpulse;
  public int m_solverMode;
  public int m_minimumSolverBatchSize;
  public double m_singleAxisRollingFrictionThreshold;
  public double m_splitImpulseTurnErp;
  public double m_restitution;
  public double m_tau;
  public double m_warmstartingFactor;
  public double m_linearSlop;
  public int m_restingContactRestitutionThreshold;
  public rawarray{char, 4} m_padding;
  public double m_maxGyroscopicForce;
}
public threaded struct extern "::btContactSolverInfoFloatData" btContactSolverInfoFloatData {
  public float m_splitImpulsePenetrationThreshold;
  public float m_friction;
  public float m_globalCfm;
  public float m_maxErrorReduction;
  public int m_numIterations;
  public float m_sor;
  public float m_timeStep;
  public rawarray{char, 4} m_padding;
  public int m_restingContactRestitutionThreshold;
  public float m_maxGyroscopicForce;
  public float m_warmstartingFactor;
  public float m_tau;
  public float m_linearSlop;
  public float m_splitImpulseTurnErp;
  public float m_restitution;
  public float m_singleAxisRollingFrictionThreshold;
  public int m_minimumSolverBatchSize;
  public int m_splitImpulse;
  public int m_solverMode;
  public float m_erp;
  public float m_damping;
  public float m_erp2;
}
public threaded struct extern "::btConvexHullShape" "nodefault" btConvexHullShape(crptr{btScalar} points, int numPoints, int stride)  {
  public metafunction __base__ {btConvexInternalShape, btPolyhedralConvexShape, btPolyhedralConvexAabbCachingShape, btConvexShape, btCollisionShape};
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "project" void project6(btTransform const& trans, btVector3 const& dir, btScalar mutable& minProj, btScalar mutable& maxProj, btVector3 mutable& witnesPtMin, btVector3 mutable& witnesPtMax) const;
  public function extern "project" void project4(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin);
  public function extern "getNumPoints" int getNumPoints() const;
  public function extern "getUnscaledPoints" rptr{btVector3} getUnscaledPoints();
  public function extern "getUnscaledPoints" crptr{btVector3} cgetUnscaledPoints() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax, btScalar margin) const;
  public function extern "getPoints" crptr{btVector3} getPoints() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getScaledPoint" btVector3 getScaledPoint(int i) const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "addPoint" void addPoint(btVector3 const& point);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
}
public threaded struct extern "::btConvexHullShapeData" btConvexHullShapeData {
  public rawarray{char, 4} m_padding3;
  public int m_numUnscaledPoints;
  public rptr{btVector3FloatData} m_unscaledPointsFloatPtr;
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rptr{btVector3DoubleData} m_unscaledPointsDoublePtr;
}
public threaded struct extern "::btConvexInternalAabbCachingShape" "nodefault" btConvexInternalAabbCachingShape private()  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCollisionShape};
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
}
public threaded struct extern "::btConvexInternalShape" "nodefault" btConvexInternalShape private()  {
  public metafunction __base__ {btCollisionShape, btConvexShape};
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
}
public threaded struct extern "::btConvexInternalShapeData" btConvexInternalShapeData {
  public int m_padding;
  public float m_collisionMargin;
  public btVector3FloatData m_localScaling;
  public btCollisionShapeData m_collisionShapeData;
  public btVector3FloatData m_implicitShapeDimensions;
}
public threaded struct extern "::btConvexPenetrationDepthSolver" "nodefault" btConvexPenetrationDepthSolver private()  {
}
public threaded struct extern "::btConvexPolyhedron" "nodefault" btConvexPolyhedron private()  {
}
public threaded struct extern "::btConvexSeparatingDistanceUtil" "nodefault" btConvexSeparatingDistanceUtil(btScalar boundingRadiusA, btScalar boundingRadiusB)  {
  public function extern "updateSeparatingDistance" void updateSeparatingDistance(btTransform const& transA, btTransform const& transB);
  public function extern "initSeparatingDistance" void initSeparatingDistance(btVector3 const& separatingVector, btScalar separatingDistance, btTransform const& transA, btTransform const& transB);
  public function extern "getConservativeSeparatingDistance" btScalar getConservativeSeparatingDistance();
}
public threaded struct extern "::btConvexShape" "nonmovable" btConvexShape {
  public metafunction __base__ {btCollisionShape};
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
}
public threaded struct extern "::btConvexTriangleMeshShape" "nodefault" btConvexTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface, bool calcAabb)  {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btPolyhedralConvexAabbCachingShape, btConvexShape, btCollisionShape};
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax, btScalar margin) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "calculatePrincipalAxisTransform" void calculatePrincipalAxisTransform(btTransform mutable& principal, btVector3 mutable& inertia, btScalar mutable& volume) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin);
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
}
public threaded struct extern "::btCylinderShape" "nodefault" btCylinderShape(btVector3 const& halfExtents)  {
  public metafunction __base__ {btCollisionShape, btConvexShape, btConvexInternalShape};
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
}
public threaded struct extern "::btCylinderShapeData" btCylinderShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rawarray{char, 4} m_padding;
  public int m_upAxis;
}
public threaded struct extern "::btCylinderShapeX" "nodefault" btCylinderShapeX(btVector3 const& halfExtents)  {
  public metafunction __base__ {btCollisionShape, btCylinderShape, btConvexInternalShape, btConvexShape};
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
}
public threaded struct extern "::btCylinderShapeZ" "nodefault" btCylinderShapeZ(btVector3 const& halfExtents)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape, btCylinderShape};
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isNonMoving" bool isNonMoving() const;
}
public threaded struct extern "::btDbvt" "nonmovable" btDbvt {
  public function extern "insert" rptr{btDbvtNode} insert(btDbvtVolume const& box, rptr{void} data);
  public function extern "collideTV" void collideTV(crptr{btDbvtNode} root, btDbvtVolume const& vol, btDbvt_ICollide mutable& policy) const;
  public function extern "empty" bool empty() const;
  public function extern "clone" void clone(btDbvt mutable& dest, rptr{btDbvt_IClone} iclone) const;
  public function extern "optimizeIncremental" void optimizeIncremental(int passes);
  public function extern "clear" void clear();
  public function extern "update" void update_btDbvtNode_p_btDbvtVolume(rptr{btDbvtNode} leaf, btDbvtVolume mutable& volume);
  public function extern "update" void update_btDbvtNode_p_int(rptr{btDbvtNode} leaf, int lookahead);
  public function extern "update" bool update4(rptr{btDbvtNode} leaf, btDbvtVolume mutable& volume, btVector3 const& velocity, btScalar margin);
  public function extern "update" bool update_btDbvtNode_p_btDbvtVolume_btVector3(rptr{btDbvtNode} leaf, btDbvtVolume mutable& volume, btVector3 const& velocity);
  public function extern "update" bool update_btDbvtNode_p_btDbvtVolume_btScalar(rptr{btDbvtNode} leaf, btDbvtVolume mutable& volume, btScalar margin);
  public function extern "collideTTpersistentStack" void collideTTpersistentStack(crptr{btDbvtNode} root0, crptr{btDbvtNode} root1, btDbvt_ICollide mutable& policy);
  public function extern "collideTT" void collideTT(crptr{btDbvtNode} root0, crptr{btDbvtNode} root1, btDbvt_ICollide mutable& policy);
  public function extern "rayTestInternal" void rayTestInternal(crptr{btDbvtNode} root, btVector3 const& rayFrom, btVector3 const& rayTo, btVector3 const& rayDirectionInverse, rptr{uint} signs, btScalar lambda_max, btVector3 const& aabbMin, btVector3 const& aabbMax, btDbvt_ICollide mutable& policy) const;
  public function extern "optimizeBottomUp" void optimizeBottomUp();
  public function extern "remove" void remove(rptr{btDbvtNode} leaf);
  public function extern "optimizeTopDown" void optimizeTopDown(int bu_treshold);
  public function extern "write" void write(rptr{btDbvt_IWriter} iwriter) const;
  public rptr{btDbvtNode} m_free;
  public btAlignedObjectArray_btDbvt_sStkNN m_stkStack;
  public rptr{btDbvtNode} m_root;
  public uint m_opath;
  public int m_lkhd;
  public btAlignedObjectArray_btDbvtNode_const_p m_rayTestStack;
  public int m_leaves;
}
public threaded struct extern "::btDbvtAabbMm" btDbvtAabbMm {
  public function extern "SignedExpand" void SignedExpand(btVector3 const& e);
  public function extern "Maxs" btVector3 const& Maxs() const;
  public function extern "Expand" void Expand(btVector3 const& e);
  public function extern "Center" btVector3 Center() const;
  public function extern "Extents" btVector3 Extents() const;
  public function extern "Contain" bool Contain(btDbvtAabbMm const& a) const;
  public function extern "Mins" btVector3 const& Mins() const;
  public function extern "Lengths" btVector3 Lengths() const;
  public function extern "ProjectMinimum" btScalar ProjectMinimum(btVector3 const& v, uint signs) const;
  public function extern "Classify" int Classify(btVector3 const& n, btScalar o, int s) const;
  public function extern "tMins" btVector3 mutable& tMins();
  public function extern "tMaxs" btVector3 mutable& tMaxs();
}
public threaded struct extern "::btDbvtBroadphase" "nodefault" btDbvtBroadphase(rptr{btOverlappingPairCache} paircache)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "setAabbForceUpdate" void setAabbForceUpdate(rptr{btBroadphaseProxy} absproxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} _3);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public function extern "printStats" void printStats();
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "collide" void collide(rptr{btDispatcher} dispatcher);
  public function extern "getVelocityPrediction" btScalar getVelocityPrediction() const;
  public function extern "performDeferredRemoval" void performDeferredRemoval(rptr{btDispatcher} dispatcher);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "setVelocityPrediction" void setVelocityPrediction(btScalar prediction);
  public function extern "optimize" void optimize();
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public rawarray{btDbvt, 2} m_sets;
  public int m_stageCurrent;
  public int m_fupdates;
  public bool m_needcleanup;
  public btScalar m_updates_ratio;
  public int m_newpairs;
  public int m_dupdates;
  public int m_cid;
  public int m_cupdates;
  public int m_gid;
  public rptr{btOverlappingPairCache} m_paircache;
  public int m_pid;
  public btScalar m_prediction;
  public int m_fixedleft;
  public rawarray{rptr{btDbvtProxy}, 3} m_stageRoots;
  public bool m_deferedcollide;
  public uint m_updates_done;
  public uint m_updates_call;
  public bool m_releasepaircache;
}
public threaded struct extern "::btDbvtNode" btDbvtNode {
  public function extern "isleaf" bool isleaf() const;
  public function extern "isinternal" bool isinternal() const;
  public btDbvtVolume volume;
  public rptr{btDbvtNode} parent;
}
/* skip btDbvtNode_30 : unnamed */
public threaded struct extern "::btDbvtProxy" "nodefault" btDbvtProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask)  {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "getUid" int getUid() const;
  public rptr{void} m_multiSapParentProxy;
  public short m_collisionFilterMask;
  public btVector3 m_aabbMin;
  public int stage;
  public rptr{btDbvtNode} leaf;
  public short m_collisionFilterGroup;
  public rptr{void} m_clientObject;
  public int m_uniqueId;
  public btVector3 m_aabbMax;
  public rawarray{rptr{btDbvtProxy}, 2} links;
}
public metafunction btDbvtProxyArray btAlignedObjectArray_btDbvtProxy_p;
public metafunction btDbvtVolume btDbvtAabbMm;
public threaded struct extern "::btDbvt::IClone" "nonmovable" btDbvt_IClone {
  public function extern "CloneLeaf" void CloneLeaf(rptr{btDbvtNode} _0);
}
public threaded struct extern "::btDbvt::ICollide" "nonmovable" btDbvt_ICollide {
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n, btScalar _1);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} _0, crptr{btDbvtNode} _1);
  public function extern "Process" void Process1(crptr{btDbvtNode} _0);
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
}
public threaded struct extern "::btDbvt::IWriter" "nonmovable" btDbvt_IWriter {
  public function extern "Prepare" void Prepare(crptr{btDbvtNode} root, int numnodes);
  public function extern "WriteLeaf" void WriteLeaf(crptr{btDbvtNode} _0, int index, int parent);
  public function extern "WriteNode" void WriteNode(crptr{btDbvtNode} _0, int index, int parent, int child0, int child1);
}
public threaded struct extern "::btDbvt::sStkCLN" "nodefault" btDbvt_sStkCLN(crptr{btDbvtNode} n, rptr{btDbvtNode} p)  {
  public crptr{btDbvtNode} node;
  public rptr{btDbvtNode} parent;
}
public threaded struct extern "::btDbvt::sStkNN" btDbvt_sStkNN {
  public crptr{btDbvtNode} b;
  public crptr{btDbvtNode} a;
}
public threaded struct extern "::btDbvt::sStkNP" "nodefault" btDbvt_sStkNP(crptr{btDbvtNode} n, uint m)  {
  public crptr{btDbvtNode} node;
  public int mask;
}
public threaded struct extern "::btDbvt::sStkNPS" btDbvt_sStkNPS {
  public btScalar value;
  public crptr{btDbvtNode} node;
  public int mask;
}
public threaded struct extern "::btDefaultCollisionConfiguration" "nodefault" btDefaultCollisionConfiguration(btDefaultCollisionConstructionInfo const& constructionInfo)  {
  public metafunction __base__ {btCollisionConfiguration};
  public function extern "getStackAllocator" rptr{btStackAlloc} getStackAllocator();
  public function extern "setPlaneConvexMultipointIterations" void setPlaneConvexMultipointIterations(int numPerturbationIterations, int minimumPointsPerturbationThreshold);
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0, int proxyType1);
  public function extern "getSimplexSolver" rptr{btVoronoiSimplexSolver} getSimplexSolver();
  public function extern "setConvexConvexMultipointIterations" void setConvexConvexMultipointIterations(int numPerturbationIterations, int minimumPointsPerturbationThreshold);
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
}
public threaded struct extern "::btDefaultCollisionConstructionInfo" btDefaultCollisionConstructionInfo {
  public rptr{btPoolAllocator} m_persistentManifoldPool;
  public int m_useEpaPenetrationAlgorithm;
  public rptr{btPoolAllocator} m_collisionAlgorithmPool;
  public rptr{btStackAlloc} m_stackAlloc;
  public int m_defaultMaxCollisionAlgorithmPoolSize;
  public int m_defaultStackAllocatorSize;
  public int m_customCollisionAlgorithmMaxElementSize;
  public int m_defaultMaxPersistentManifoldPoolSize;
}
public threaded struct extern "::btDefaultMotionState" "nodefault" btDefaultMotionState(btTransform const& startTrans, btTransform const& centerOfMassOffset)  {
  public metafunction __base__ {btMotionState};
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& centerOfMassWorldTrans);
  public function extern "getWorldTransform" void getWorldTransform(btTransform mutable& centerOfMassWorldTrans) const;
  public btTransform m_startWorldTrans;
  public btTransform m_centerOfMassOffset;
  public rptr{void} m_userPointer;
  public btTransform m_graphicsWorldTrans;
}
public threaded struct extern "::btDefaultSerializer" "nodefault" btDefaultSerializer(int totalSize)  {
  public metafunction __base__ {btSerializer};
  public function extern "registerNameForPointer" void registerNameForPointer(crptr{void} ptr, crptr{char} name);
  public function extern "serializeName" void serializeName(crptr{char} name);
  public function extern "findPointer" rptr{void} findPointer(rptr{void} oldPtr);
  public function extern "finishSerialization" void finishSerialization();
  public function extern "findNameForPointer" crptr{char} findNameForPointer(crptr{void} ptr) const;
  public function extern "allocate" rptr{btChunk} allocate(size_t size, int numElements);
  public function extern "getBufferPointer" crptr{uchar} getBufferPointer() const;
  public function extern "getCurrentBufferSize" int getCurrentBufferSize() const;
  public function extern "setSerializationFlags" void setSerializationFlags(int flags);
  public function extern "getUniquePointer" rptr{void} getUniquePointer(rptr{void} oldPtr);
  public function extern "internalAlloc" rptr{uchar} internalAlloc(size_t size);
  public function extern "writeHeader" void writeHeader(rptr{uchar} buffer) const;
  public function extern "startSerialization" void startSerialization();
  public function extern "finalizeChunk" void finalizeChunk(rptr{btChunk} chunk, crptr{char} structType, int chunkCode, rptr{void} oldPtr);
  public function extern "getSerializationFlags" int getSerializationFlags() const;
}
public threaded struct extern "::btDefaultVehicleRaycaster" "nodefault" btDefaultVehicleRaycaster(rptr{btDynamicsWorld} world)  {
  public metafunction __base__ {btVehicleRaycaster};
  public function extern "castRay" rptr{void} castRay(btVector3 const& from, btVector3 const& to, btVehicleRaycaster_btVehicleRaycasterResult mutable& result);
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface" "nonmovable" btDiscreteCollisionDetectorInterface {
  public function extern "getClosestPoints" void getClosestPoints(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input, btDiscreteCollisionDetectorInterface_Result mutable& output, rptr{btIDebugDraw} debugDraw, bool swapResults);
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface::ClosestPointInput" btDiscreteCollisionDetectorInterface_ClosestPointInput {
  public btTransform m_transformB;
  public btScalar m_maximumDistanceSquared;
  public btTransform m_transformA;
  public rptr{btStackAlloc} m_stackAlloc;
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface::Result" "nonmovable" btDiscreteCollisionDetectorInterface_Result {
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1, int index1);
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0, int index0);
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld, btVector3 const& pointInWorld, btScalar depth);
}
public threaded struct extern "::btDiscreteDynamicsWorld" "nodefault" btDiscreteDynamicsWorld(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} pairCache, rptr{btConstraintSolver} constraintSolver, rptr{btCollisionConfiguration} collisionConfiguration)  {
  public metafunction __base__ {btCollisionWorld, btDynamicsWorld};
  public function extern "applyGravity" void applyGravity();
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer);
  public function extern "synchronizeSingleMotionState" void synchronizeSingleMotionState(rptr{btRigidBody} body);
  public function extern "setGravity" void setGravity(btVector3 const& gravity);
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache);
  public function extern "getCollisionWorld" rptr{btCollisionWorld} getCollisionWorld();
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "setApplySpeculativeContactRestitution" void setApplySpeculativeContactRestitution(bool enable);
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint, bool disableCollisionsBetweenLinkedBodies);
  public function extern "updateVehicles" void updateVehicles(btScalar timeStep);
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld, btVector3 const& rayToWorld, btCollisionWorld_RayResultCallback mutable& resultCallback) const;
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb, rptr{void} worldUserInfo, bool isPreTick);
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo);
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "updateAabbs" void updateAabbs();
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform, crptr{btCollisionShape} shape, btVector3 const& color);
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj);
  public function extern "setSynchronizeAllMotionStates" void setSynchronizeAllMotionStates(bool synchronizeAll);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape, btTransform const& from, btTransform const& to, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedCcdPenetration) const;
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver);
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle);
  public function extern "getSynchronizeAllMotionStates" bool getSynchronizeAllMotionStates() const;
  public function extern "addAction" void addAction(rptr{btActionInterface} _0);
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index) const;
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index);
  public function extern "clearForces" void clearForces();
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body, short group, short mask);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body);
  public function extern "getApplySpeculativeContactRestitution" bool getApplySpeculativeContactRestitution() const;
  public function extern "setNumTasks" void setNumTasks(int numTasks);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject, short collisionFilterGroup, short collisionFilterMask);
  public function extern "removeAction" void removeAction(rptr{btActionInterface} _0);
  public function extern "getSimulationIslandManager" rptr{btSimulationIslandManager} getSimulationIslandManager();
  public function extern "getSimulationIslandManager" crptr{btSimulationIslandManager} cgetSimulationIslandManager() const;
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer);
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA, rptr{btCollisionObject} colObjB, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "debugDrawConstraint" void debugDrawConstraint(rptr{btTypedConstraint} constraint);
}
public threaded struct extern "::btDispatcher" "nonmovable" btDispatcher {
  public function extern "needsCollision" bool needsCollision(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "allocateCollisionAlgorithm" rptr{void} allocateCollisionAlgorithm(int size);
  public function extern "getNumManifolds" int getNumManifolds() const;
  public function extern "findAlgorithm" rptr{btCollisionAlgorithm} findAlgorithm(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, rptr{btPersistentManifold} sharedManifold);
  public function extern "clearManifold" void clearManifold(rptr{btPersistentManifold} manifold);
  public function extern "dispatchAllCollisionPairs" void dispatchAllCollisionPairs(rptr{btOverlappingPairCache} pairCache, btDispatcherInfo const& dispatchInfo, rptr{btDispatcher} dispatcher);
  public function extern "getInternalManifoldPointer" rptr{rptr{btPersistentManifold}} getInternalManifoldPointer();
  public function extern "getManifoldByIndexInternal" rptr{btPersistentManifold} getManifoldByIndexInternal(int index);
  public function extern "releaseManifold" void releaseManifold(rptr{btPersistentManifold} manifold);
  public function extern "freeCollisionAlgorithm" void freeCollisionAlgorithm(rptr{void} ptr);
  public function extern "getNewManifold" rptr{btPersistentManifold} getNewManifold(crptr{btCollisionObject} b0, crptr{btCollisionObject} b1);
  public function extern "getInternalManifoldPool" rptr{btPoolAllocator} getInternalManifoldPool();
  public function extern "getInternalManifoldPool" crptr{btPoolAllocator} cgetInternalManifoldPool() const;
  public function extern "needsResponse" bool needsResponse(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
}
public threaded struct extern "::btDispatcherInfo" btDispatcherInfo {
  public bool m_useConvexConservativeDistanceUtil;
  public rptr{btIDebugDraw} m_debugDraw;
  public btScalar m_convexConservativeDistanceThreshold;
  public bool m_useEpa;
  public btScalar m_timeOfImpact;
  public int m_stepCount;
  public int m_dispatchFunc;
  public btScalar m_timeStep;
  public bool m_enableSPU;
  public btScalar m_allowedCcdPenetration;
  public bool m_enableSatConvex;
  public rptr{btStackAlloc} m_stackAllocator;
  public bool m_useContinuous;
}
public threaded struct extern "::btDynamicsWorld" "nodefault" btDynamicsWorld(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} broadphase, rptr{btCollisionConfiguration} collisionConfiguration)  {
  public metafunction __base__ {btCollisionWorld};
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache);
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "setGravity" void setGravity(btVector3 const& gravity);
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer);
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "updateAabbs" void updateAabbs();
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo);
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb, rptr{void} worldUserInfo, bool isPreTick);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body);
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld, btVector3 const& rayToWorld, btCollisionWorld_RayResultCallback mutable& resultCallback) const;
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint, bool disableCollisionsBetweenLinkedBodies);
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle);
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape, btTransform const& from, btTransform const& to, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedCcdPenetration) const;
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep);
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj);
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform, crptr{btCollisionShape} shape, btVector3 const& color);
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA, rptr{btCollisionObject} colObjB, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer);
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject, short collisionFilterGroup, short collisionFilterMask);
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body, short group, short mask);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body);
  public function extern "clearForces" void clearForces();
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index) const;
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index);
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "addAction" void addAction(rptr{btActionInterface} action);
}
public threaded struct extern "::btDynamicsWorldDoubleData" btDynamicsWorldDoubleData {
  public btContactSolverInfoDoubleData m_solverInfo;
  public btVector3DoubleData m_gravity;
}
public threaded struct extern "::btDynamicsWorldFloatData" btDynamicsWorldFloatData {
  public btVector3FloatData m_gravity;
  public btContactSolverInfoFloatData m_solverInfo;
}
public tsvaluetype struct extern "::btDynamicsWorldType" "extenum" btDynamicsWorldType { }
public extern "BT_SIMPLE_DYNAMICS_WORLD" btDynamicsWorldType BT_SIMPLE_DYNAMICS_WORLD;
public extern "BT_DISCRETE_DYNAMICS_WORLD" btDynamicsWorldType BT_DISCRETE_DYNAMICS_WORLD;
public extern "BT_CONTINUOUS_DYNAMICS_WORLD" btDynamicsWorldType BT_CONTINUOUS_DYNAMICS_WORLD;
public extern "BT_SOFT_RIGID_DYNAMICS_WORLD" btDynamicsWorldType BT_SOFT_RIGID_DYNAMICS_WORLD;
public threaded struct extern "::btEmptyShape" "nonmovable" btEmptyShape {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} _0, btVector3 const& _1, btVector3 const& _2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
}
public metafunction btFreeFunc meta::list{void, rptr{void}};
public threaded struct extern "::btGearConstraint" "nodefault" btGearConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& axisInA, btVector3 const& axisInB, btScalar ratio)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getUid" int getUid() const;
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public int m_objectType;
}
public threaded struct extern "::btGeneric6DofConstraint" "nodefault" btGeneric6DofConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index);
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower);
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getAxis" btVector3 getAxis(int axis_index) const;
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper);
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower);
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "isLimited" bool isLimited(int limitIndex);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower);
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "setAxis" void setAxis(btVector3 const& axis1, btVector3 const& axis2);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index) const;
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA, btTransform const& transB);
  public function extern "getUid" int getUid() const;
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getAngle" btScalar getAngle(int axis_index) const;
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper);
  public function extern "setLimit" void setLimit(int axis, btScalar lo, btScalar hi);
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB, rptr{btTypedConstraint_btConstraintInfo2} info, int row, btVector3 mutable& ax1, int rotational, int rotAllowed);
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public bool m_useSolveConstraintObsolete;
  public int m_objectType;
}
public threaded struct extern "::btGeneric6DofConstraintData" btGeneric6DofConstraintData {
  public btVector3FloatData m_angularLowerLimit;
  public btVector3FloatData m_linearUpperLimit;
  public btVector3FloatData m_angularUpperLimit;
  public btTypedConstraintData m_typeConstraintData;
  public btVector3FloatData m_linearLowerLimit;
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
  public btTransformFloatData m_rbBFrame;
  public btTransformFloatData m_rbAFrame;
}
public threaded struct extern "::btGeneric6DofSpringConstraint" "nodefault" btGeneric6DofSpringConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject, btGeneric6DofConstraint};
  public function extern "isLimited" bool isLimited(int limitIndex);
  public function extern "getAxis" btVector3 getAxis(int axis_index) const;
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower);
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper);
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower);
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper);
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB, rptr{btTypedConstraint_btConstraintInfo2} info, int row, btVector3 mutable& ax1, int rotational, int rotAllowed);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper);
  public function extern "setLimit" void setLimit(int axis, btScalar lo, btScalar hi);
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "getAngle" btScalar getAngle(int axis_index) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "setStiffness" void setStiffness(int index, btScalar stiffness);
  public function extern "setDamping" void setDamping(int index, btScalar damping);
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index) const;
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA, btTransform const& transB);
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "setAxis" void setAxis(btVector3 const& axis1, btVector3 const& axis2);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getUid" int getUid() const;
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint0();
  public function extern "setEquilibriumPoint" void setEquilibriumPoint2(int index, btScalar val);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint1(int index);
  public function extern "enableSpring" void enableSpring(int index, bool onOff);
  public int m_objectType;
  public bool m_useSolveConstraintObsolete;
}
public threaded struct extern "::btGeneric6DofSpringConstraintData" btGeneric6DofSpringConstraintData {
  public btGeneric6DofConstraintData m_6dofData;
  public rawarray{int, 6} m_springEnabled;
  public rawarray{float, 6} m_springStiffness;
  public rawarray{float, 6} m_springDamping;
  public rawarray{float, 6} m_equilibriumPoint;
}
public threaded struct extern "::btHashInt" "nodefault" btHashInt(int uid)  {
  public function extern "setUid1" void setUid1(int uid);
  public function extern "getHash" uint getHash() const;
  public function extern "equals" bool equals(btHashInt const& other) const;
  public function extern "getUid1" int getUid1() const;
}
public threaded struct extern "::btHashMap<btHashInt, btTriangleInfo>" btHashMap_btHashInt_btTriangleInfo {
  public function extern "clear" void clear();
  public function extern "remove" void remove(btHashInt const& key);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{btTriangleInfo} cgetAtIndex(int index) const;
  public function extern "getAtIndex" rptr{btTriangleInfo} getAtIndex(int index);
  public function extern "insert" void insert(btHashInt const& key, btTriangleInfo const& value);
  public function extern "find" crptr{btTriangleInfo} cfind(btHashInt const& key) const;
  public function extern "find" rptr{btTriangleInfo} find(btHashInt const& key);
  public function extern "findIndex" int findIndex(btHashInt const& key) const;
}
public threaded struct extern "::btHashMap<btHashInt, int>" btHashMap_btHashInt_int {
  public function extern "insert" void insert(btHashInt const& key, int const& value);
  public function extern "findIndex" int findIndex(btHashInt const& key) const;
  public function extern "find" crptr{int} cfind(btHashInt const& key) const;
  public function extern "find" rptr{int} find(btHashInt const& key);
  public function extern "size" int size() const;
  public function extern "remove" void remove(btHashInt const& key);
  public function extern "getAtIndex" rptr{int} getAtIndex(int index);
  public function extern "getAtIndex" crptr{int} cgetAtIndex(int index) const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btHashMap<btHashPtr, btPointerUid>" btHashMap_btHashPtr_btPointerUid {
  public function extern "findIndex" int findIndex(btHashPtr const& key) const;
  public function extern "find" rptr{btPointerUid} find(btHashPtr const& key);
  public function extern "find" crptr{btPointerUid} cfind(btHashPtr const& key) const;
  public function extern "insert" void insert(btHashPtr const& key, btPointerUid const& value);
  public function extern "getAtIndex" crptr{btPointerUid} cgetAtIndex(int index) const;
  public function extern "getAtIndex" rptr{btPointerUid} getAtIndex(int index);
  public function extern "size" int size() const;
  public function extern "remove" void remove(btHashPtr const& key);
  public function extern "clear" void clear();
}
public threaded struct extern "::btHashMap<btHashPtr, char const*>" btHashMap_btHashPtr_char_const_p {
  public function extern "clear" void clear();
  public function extern "size" int size() const;
  public function extern "remove" void remove(btHashPtr const& key);
  public function extern "getAtIndex" crptr{crptr{char}} cgetAtIndex(int index) const;
  public function extern "getAtIndex" rptr{crptr{char}} getAtIndex(int index);
  public function extern "insert" void insert(btHashPtr const& key, crptr{char} const& value);
  public function extern "findIndex" int findIndex(btHashPtr const& key) const;
  public function extern "find" rptr{crptr{char}} find(btHashPtr const& key);
  public function extern "find" crptr{crptr{char}} cfind(btHashPtr const& key) const;
}
public threaded struct extern "::btHashMap<btHashPtr, void*>" btHashMap_btHashPtr_void_p {
  public function extern "clear" void clear();
  public function extern "remove" void remove(btHashPtr const& key);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{rptr{void}} cgetAtIndex(int index) const;
  public function extern "getAtIndex" rptr{rptr{void}} getAtIndex(int index);
  public function extern "insert" void insert(btHashPtr const& key, rptr{void} const& value);
  public function extern "find" rptr{rptr{void}} find(btHashPtr const& key);
  public function extern "find" crptr{rptr{void}} cfind(btHashPtr const& key) const;
  public function extern "findIndex" int findIndex(btHashPtr const& key) const;
}
public threaded struct extern "::btHashMap<btHashString, int>" btHashMap_btHashString_int {
  public function extern "getAtIndex" crptr{int} cgetAtIndex(int index) const;
  public function extern "getAtIndex" rptr{int} getAtIndex(int index);
  public function extern "remove" void remove(btHashString const& key);
  public function extern "size" int size() const;
  public function extern "clear" void clear();
  public function extern "find" rptr{int} find(btHashString const& key);
  public function extern "find" crptr{int} cfind(btHashString const& key) const;
  public function extern "findIndex" int findIndex(btHashString const& key) const;
  public function extern "insert" void insert(btHashString const& key, int const& value);
}
public threaded struct extern "::btHashPtr" "nodefault" btHashPtr(crptr{void} ptr)  {
  public function extern "getPointer" crptr{void} getPointer() const;
  public function extern "getHash" uint getHash() const;
  public function extern "equals" bool equals(btHashPtr const& other) const;
}
/* skip btHashPtr_28 : unnamed */
public threaded struct extern "::btHashString" "nodefault" btHashString(crptr{char} name)  {
  public function extern "portableStringCompare" int portableStringCompare(crptr{char} src, crptr{char} dst) const;
  public function extern "getHash" uint getHash() const;
  public function extern "equals" bool equals(btHashString const& other) const;
  public uint m_hash;
  public crptr{char} m_string;
}
public threaded struct extern "::btHashedOverlappingPairCache" "nonmovable" btHashedOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCache, btOverlappingPairCallback};
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher);
  public function extern "GetCount" int GetCount() const;
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "needsBroadphaseCollision" bool needsBroadphaseCollision(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1) const;
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair, rptr{btDispatcher} dispatcher);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1, rptr{btDispatcher} dispatcher);
  public function extern "getOverlappingPairArray" btBroadphasePairArray const& cgetOverlappingPairArray() const;
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "getOverlapFilterCallback" rptr{btOverlapFilterCallback} getOverlapFilterCallback();
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
}
public threaded struct extern "::btHinge2Constraint" "nodefault" btHinge2Constraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 mutable& anchor, btVector3 mutable& axis1, btVector3 mutable& axis2)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint, btGeneric6DofSpringConstraint, btGeneric6DofConstraint};
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getAxis2" btVector3 const& getAxis2();
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower);
  public function extern "getAxis1" btVector3 const& getAxis1();
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "setLowerLimit" void setLowerLimit(btScalar ang1min);
  public function extern "getAnchor2" btVector3 const& getAnchor2();
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "getAngle1" btScalar getAngle1();
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "isLimited" bool isLimited(int limitIndex);
  public function extern "getAngle2" btScalar getAngle2();
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper);
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower);
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "getAxis" btVector3 getAxis(int axis_index) const;
  public function extern "getAnchor" btVector3 const& getAnchor();
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "setDamping" void setDamping(int index, btScalar damping);
  public function extern "setStiffness" void setStiffness(int index, btScalar stiffness);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getUid" int getUid() const;
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "setAxis" void setAxis(btVector3 const& axis1, btVector3 const& axis2);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index) const;
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA, btTransform const& transB);
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "setEquilibriumPoint" void setEquilibriumPoint0();
  public function extern "setEquilibriumPoint" void setEquilibriumPoint2(int index, btScalar val);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint1(int index);
  public function extern "enableSpring" void enableSpring(int index, bool onOff);
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index);
  public function extern "setUpperLimit" void setUpperLimit(btScalar ang1max);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper);
  public function extern "setLimit" void setLimit(int axis, btScalar lo, btScalar hi);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper);
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB, rptr{btTypedConstraint_btConstraintInfo2} info, int row, btVector3 mutable& ax1, int rotational, int rotAllowed);
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getAngle" btScalar getAngle(int axis_index) const;
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public bool m_useSolveConstraintObsolete;
  public int m_objectType;
}
public threaded struct extern "::btHingeConstraint" "nodefault" btHingeConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& pivotInA, btVector3 const& pivotInB, btVector3 const& axisInA, btVector3 const& axisInB, bool useReferenceFrameA)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint};
  public function extern "testLimit" void testLimit(btTransform const& transA, btTransform const& transB);
  public function extern "getSolveLimit" int getSolveLimit();
  public function extern "getUpperLimit" btScalar getUpperLimit() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getAFrame" btTransform const& cgetAFrame() const;
  public function extern "getAFrame" btTransform mutable& getAFrame();
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getInfo2InternalUsingFrameOffset" void getInfo2InternalUsingFrameOffset(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getLimitSign" btScalar getLimitSign();
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getLowerLimit" btScalar getLowerLimit() const;
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "setLimit" void setLimit(btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
  public function extern "getMotorTargetVelosity" btScalar getMotorTargetVelosity();
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getMaxMotorImpulse" btScalar getMaxMotorImpulse();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public function extern "setMotorTarget" void setMotorTarget_btScalar_btScalar(btScalar targetAngle, btScalar dt);
  public function extern "setMotorTarget" void setMotorTarget_btQuaternion_btScalar(btQuaternion const& qAinB, btScalar dt);
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getHingeAngle" btScalar getHingeAngle2(btTransform const& transA, btTransform const& transB);
  public function extern "getHingeAngle" btScalar getHingeAngle0();
  public function extern "enableAngularMotor" void enableAngularMotor(bool enableMotor, btScalar targetVelocity, btScalar maxMotorImpulse);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "getInfo2Internal" void getInfo2Internal(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "getAngularOnly" bool getAngularOnly();
  public function extern "enableMotor" void enableMotor(bool enableMotor);
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "setAxis" void setAxis(btVector3 mutable& axisInA);
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getUid" int getUid() const;
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getBFrame" btTransform mutable& getBFrame();
  public function extern "getBFrame" btTransform const& cgetBFrame() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "getEnableAngularMotor" bool getEnableAngularMotor();
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly);
  public int m_objectType;
}
public threaded struct extern "::btHingeConstraintDoubleData" btHingeConstraintDoubleData {
  public float m_limitSoftness;
  public int m_useReferenceFrameA;
  public btTypedConstraintData m_typeConstraintData;
  public float m_motorTargetVelocity;
  public int m_enableAngularMotor;
  public int m_angularOnly;
  public float m_upperLimit;
  public float m_lowerLimit;
  public float m_maxMotorImpulse;
  public float m_relaxationFactor;
  public btTransformDoubleData m_rbBFrame;
  public btTransformDoubleData m_rbAFrame;
  public float m_biasFactor;
}
public threaded struct extern "::btHingeConstraintFloatData" btHingeConstraintFloatData {
  public float m_biasFactor;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public float m_relaxationFactor;
  public float m_maxMotorImpulse;
  public float m_lowerLimit;
  public float m_upperLimit;
  public int m_angularOnly;
  public int m_enableAngularMotor;
  public float m_motorTargetVelocity;
  public btTypedConstraintData m_typeConstraintData;
  public int m_useReferenceFrameA;
  public float m_limitSoftness;
}
public tsvaluetype struct extern "::btHingeFlags" "extenum" btHingeFlags { }
public extern "BT_HINGE_FLAGS_CFM_STOP" btHingeFlags BT_HINGE_FLAGS_CFM_STOP;
public extern "BT_HINGE_FLAGS_ERP_STOP" btHingeFlags BT_HINGE_FLAGS_ERP_STOP;
public extern "BT_HINGE_FLAGS_CFM_NORM" btHingeFlags BT_HINGE_FLAGS_CFM_NORM;
public threaded struct extern "::btIDebugDraw" "nonmovable" btIDebugDraw {
  public function extern "drawSpherePatch" void drawSpherePatch(btVector3 const& center, btVector3 const& up, btVector3 const& axis, btScalar radius, btScalar minTh, btScalar maxTh, btScalar minPs, btScalar maxPs, btVector3 const& color, btScalar stepDegrees);
  public function extern "drawBox" void drawBox3(btVector3 const& bbMin, btVector3 const& bbMax, btVector3 const& color);
  public function extern "drawBox" void drawBox4(btVector3 const& bbMin, btVector3 const& bbMax, btTransform const& trans, btVector3 const& color);
  public function extern "drawSphere" void drawSphere_btScalar_btTransform_btVector3(btScalar radius, btTransform const& transform, btVector3 const& color);
  public function extern "drawSphere" void drawSphere_btVector3_btScalar_btVector3(btVector3 const& p, btScalar radius, btVector3 const& color);
  public function extern "drawTriangle" void drawTriangle8(btVector3 const& v0, btVector3 const& v1, btVector3 const& v2, btVector3 const& _3, btVector3 const& _4, btVector3 const& _5, btVector3 const& color, btScalar alpha);
  public function extern "drawTriangle" void drawTriangle5(btVector3 const& v0, btVector3 const& v1, btVector3 const& v2, btVector3 const& color, btScalar _4);
  public function extern "drawCapsule" void drawCapsule(btScalar radius, btScalar halfHeight, int upAxis, btTransform const& transform, btVector3 const& color);
  public function extern "setDebugMode" void setDebugMode(int debugMode);
  public function extern "drawCone" void drawCone(btScalar radius, btScalar height, int upAxis, btTransform const& transform, btVector3 const& color);
  public function extern "getDebugMode" int getDebugMode() const;
  public function extern "drawAabb" void drawAabb(btVector3 const& from, btVector3 const& to, btVector3 const& color);
  public function extern "drawLine" void drawLine3(btVector3 const& from, btVector3 const& to, btVector3 const& color);
  public function extern "drawLine" void drawLine4(btVector3 const& from, btVector3 const& to, btVector3 const& fromColor, btVector3 const& toColor);
  public function extern "drawArc" void drawArc(btVector3 const& center, btVector3 const& normal, btVector3 const& axis, btScalar radiusA, btScalar radiusB, btScalar minAngle, btScalar maxAngle, btVector3 const& color, bool drawSect, btScalar stepDegrees);
  public function extern "drawTransform" void drawTransform(btTransform const& transform, btScalar orthoLen);
  public function extern "drawCylinder" void drawCylinder(btScalar radius, btScalar halfHeight, int upAxis, btTransform const& transform, btVector3 const& color);
  public function extern "drawContactPoint" void drawContactPoint(btVector3 const& PointOnB, btVector3 const& normalOnB, btScalar distance, int lifeTime, btVector3 const& color);
  public function extern "reportErrorWarning" void reportErrorWarning(crptr{char} warningString);
  public function extern "drawPlane" void drawPlane(btVector3 const& planeNormal, btScalar planeConst, btTransform const& transform, btVector3 const& color);
  public function extern "draw3dText" void draw3dText(btVector3 const& location, crptr{char} textString);
}
public threaded struct extern "::btIndexedMesh" btIndexedMesh {
  public crptr{uchar} m_triangleIndexBase;
  public int m_numTriangles;
  public int m_numVertices;
  public PHY_ScalarType m_indexType;
  public PHY_ScalarType m_vertexType;
  public int m_vertexStride;
  public int m_triangleIndexStride;
  public crptr{uchar} m_vertexBase;
}
public threaded struct extern "::btIntIndexData" btIntIndexData {
  public int m_value;
}
public metafunction btInternalTickCallback rptr{meta::list{void, rptr{btDynamicsWorld}, btScalar}};
public threaded struct extern "::btInternalTriangleIndexCallback" "nonmovable" btInternalTriangleIndexCallback {
  public function extern "internalProcessTriangleIndex" void internalProcessTriangleIndex(rptr{btVector3} triangle, int partId, int triangleIndex);
}
public metafunction btInternalTriangleInfoMap btHashMap_btHashInt_btTriangleInfo;
public threaded struct extern "::btJacobianEntry" btJacobianEntry {
  public function extern "getNonDiagonal" btScalar getNonDiagonal3(btJacobianEntry const& jacB, btScalar const massInvA, btScalar const massInvB) const;
  public function extern "getNonDiagonal" btScalar getNonDiagonal2(btJacobianEntry const& jacB, btScalar const massInvA) const;
  public function extern "getRelativeVelocity" btScalar getRelativeVelocity(btVector3 const& linvelA, btVector3 const& angvelA, btVector3 const& linvelB, btVector3 const& angvelB);
  public function extern "getDiagonal" btScalar getDiagonal() const;
  public btScalar m_Adiag;
  public btVector3 m_linearJointAxis;
  public btVector3 m_0MinvJt;
  public btVector3 m_aJ;
  public btVector3 m_1MinvJt;
  public btVector3 m_bJ;
}
public threaded struct extern "::btJointFeedback" btJointFeedback {
  public btVector3 m_appliedForceBodyB;
  public btVector3 m_appliedTorqueBodyB;
  public btVector3 m_appliedForceBodyA;
  public btVector3 m_appliedTorqueBodyA;
}
public metafunction btManifoldArray btAlignedObjectArray_btPersistentManifold_p;
public threaded struct extern "::btManifoldPoint" btManifoldPoint {
  public function extern "setDistance" void setDistance(btScalar dist);
  public function extern "getPositionWorldOnB" btVector3 const& getPositionWorldOnB() const;
  public function extern "getPositionWorldOnA" btVector3 const& getPositionWorldOnA() const;
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getLifeTime" int getLifeTime() const;
  public function extern "getDistance" btScalar getDistance() const;
  public btVector3 m_lateralFrictionDir2;
  public btScalar m_appliedImpulse;
  public int m_lifeTime;
  public btScalar m_contactMotion2;
  public btVector3 m_localPointB;
  public btVector3 m_localPointA;
  public btScalar m_contactMotion1;
  public int m_index0;
  public int m_index1;
  public btScalar m_combinedRollingFriction;
  public btVector3 m_positionWorldOnA;
  public btScalar m_appliedImpulseLateral2;
  public btVector3 m_positionWorldOnB;
  public int m_partId0;
  public btVector3 m_lateralFrictionDir1;
  public btScalar m_appliedImpulseLateral1;
  public btScalar m_contactCFM2;
  public int m_partId1;
  public btScalar m_combinedFriction;
  public btScalar m_contactCFM1;
  public rptr{void} m_userPersistentData;
  public btVector3 m_normalWorldOnB;
  public btScalar m_distance1;
  public btScalar m_combinedRestitution;
  public bool m_lateralFrictionInitialized;
}
public threaded struct extern "::btManifoldResult" "nonmovable" btManifoldResult {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
  public function extern "setPersistentManifold" void setPersistentManifold(rptr{btPersistentManifold} manifoldPtr);
  public function extern "getBody0Internal" crptr{btCollisionObject} getBody0Internal() const;
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0, int index0);
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld, btVector3 const& pointInWorld, btScalar depth);
  public function extern "setBody1Wrap" void setBody1Wrap(crptr{btCollisionObjectWrapper} obj1Wrap);
  public function extern "getBody1Internal" crptr{btCollisionObject} getBody1Internal() const;
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1, int index1);
  public function extern "getBody0Wrap" crptr{btCollisionObjectWrapper} getBody0Wrap() const;
  public function extern "getPersistentManifold" rptr{btPersistentManifold} getPersistentManifold();
  public function extern "getPersistentManifold" crptr{btPersistentManifold} cgetPersistentManifold() const;
  public function extern "getBody1Wrap" crptr{btCollisionObjectWrapper} getBody1Wrap() const;
  public function extern "setBody0Wrap" void setBody0Wrap(crptr{btCollisionObjectWrapper} obj0Wrap);
  public function extern "refreshContactPoints" void refreshContactPoints();
}
public threaded struct extern "::btMatrix3x3" btMatrix3x3 {
  public function extern "getOpenGLSubMatrix" void getOpenGLSubMatrix(rptr{btScalar} m) const;
  public function extern "transposeTimes" btMatrix3x3 transposeTimes(btMatrix3x3 const& m) const;
  public function extern "setValue" void setValue(btScalar const& xx, btScalar const& xy, btScalar const& xz, btScalar const& yx, btScalar const& yy, btScalar const& yz, btScalar const& zx, btScalar const& zy, btScalar const& zz);
  public function extern "determinant" btScalar determinant() const;
  public function extern "deSerialize" void deSerialize(btMatrix3x3FloatData const& dataIn);
  public function extern "tdotx" btScalar tdotx(btVector3 const& v) const;
  public function extern "deSerializeFloat" void deSerializeFloat(btMatrix3x3FloatData const& dataIn);
  public function extern "scaled" btMatrix3x3 scaled(btVector3 const& s) const;
  public function extern "deSerializeDouble" void deSerializeDouble(btMatrix3x3DoubleData const& dataIn);
  public function extern "setFromOpenGLSubMatrix" void setFromOpenGLSubMatrix(crptr{btScalar} m);
  public function extern "setRotation" void setRotation(btQuaternion const& q);
  public function extern "getEulerZYX" void getEulerZYX(btScalar mutable& yaw, btScalar mutable& pitch, btScalar mutable& roll, uint solution_number) const;
  public function extern "getRotation" void getRotation(btQuaternion mutable& q) const;
  public function extern "timesTranspose" btMatrix3x3 timesTranspose(btMatrix3x3 const& m) const;
  public function extern "setIdentity" void setIdentity();
  public function extern "tdotz" btScalar tdotz(btVector3 const& v) const;
  public function extern "tdoty" btScalar tdoty(btVector3 const& v) const;
  public function extern "cofac" btScalar cofac(int r1, int c1, int r2, int c2) const;
  public function extern "setEulerYPR" void setEulerYPR(btScalar const& yaw, btScalar const& pitch, btScalar const& roll);
  public function extern "getRow" btVector3 const& getRow(int i) const;
  public function extern "adjoint" btMatrix3x3 adjoint() const;
  public function extern "serialize" void serialize(btMatrix3x3FloatData mutable& dataOut) const;
  public function extern "setEulerZYX" void setEulerZYX(btScalar eulerX, btScalar eulerY, btScalar eulerZ);
  public function extern "inverse" btMatrix3x3 inverse() const;
  public function extern "getColumn" btVector3 getColumn(int i) const;
  public function extern "diagonalize" void diagonalize(btMatrix3x3 mutable& rot, btScalar threshold, int maxSteps);
  public function extern "serializeFloat" void serializeFloat(btMatrix3x3FloatData mutable& dataOut) const;
  public function extern "transpose" btMatrix3x3 transpose() const;
  public function extern "getEulerYPR" void getEulerYPR(btScalar mutable& yaw, btScalar mutable& pitch, btScalar mutable& roll) const;
  public function extern "absolute" btMatrix3x3 absolute() const;
}
public threaded struct extern "::btMatrix3x3DoubleData" btMatrix3x3DoubleData {
  public rawarray{btVector3DoubleData, 3} m_el;
}
public threaded struct extern "::btMatrix3x3FloatData" btMatrix3x3FloatData {
  public rawarray{btVector3FloatData, 3} m_el;
}
public threaded struct extern "::btMeshPartData" btMeshPartData {
  public rptr{btShortIntIndexTripletData} m_3indices16;
  public rptr{btIntIndexData} m_indices32;
  public rptr{btVector3FloatData} m_vertices3f;
  public rptr{btVector3DoubleData} m_vertices3d;
  public rptr{btShortIntIndexData} m_indices16;
  public int m_numVertices;
  public int m_numTriangles;
  public rptr{btCharIndexTripletData} m_3indices8;
}
public threaded struct extern "::btMotionState" "nonmovable" btMotionState {
  public function extern "getWorldTransform" void getWorldTransform(btTransform mutable& worldTrans) const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans);
}
public threaded struct extern "::btMultiSapBroadphase" "nodefault" btMultiSapBroadphase(int maxProxies, rptr{btOverlappingPairCache} pairCache)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "addToChildBroadphase" void addToChildBroadphase(rptr{btMultiSapBroadphase_btMultiSapProxy} parentMultiSapProxy, rptr{btBroadphaseProxy} childProxy, rptr{btBroadphaseInterface} childBroadphase);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "quicksort" void quicksort(btBroadphasePairArray mutable& a, int lo, int hi);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "printStats" void printStats();
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "buildTree" void buildTree(btVector3 const& bvhAabbMin, btVector3 const& bvhAabbMax);
  public function extern "getBroadphaseArray" btSapBroadphaseArray mutable& getBroadphaseArray();
  public function extern "getBroadphaseArray" btSapBroadphaseArray const& cgetBroadphaseArray() const;
}
public threaded struct extern "::btMultiSapBroadphase::btBridgeProxy" "nodefault" btMultiSapBroadphase_btBridgeProxy private()  {
}
public threaded struct extern "::btMultiSapBroadphase::btMultiSapProxy" "nodefault" btMultiSapBroadphase_btMultiSapProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask)  {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "getUid" int getUid() const;
  public rptr{void} m_multiSapParentProxy;
  public short m_collisionFilterMask;
  public btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p m_bridgeProxies;
  public int m_shapeType;
  public short m_collisionFilterGroup;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
  public rptr{void} m_clientObject;
  public int m_uniqueId;
}
public threaded struct extern "::btMultiSphereShape" "nodefault" btMultiSphereShape(crptr{btVector3} positions, crptr{btScalar} radi, int numSpheres)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btConvexInternalAabbCachingShape, btCollisionShape};
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getSphereRadius" btScalar getSphereRadius(int index) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getSpherePosition" btVector3 const& getSpherePosition(int index) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getSphereCount" int getSphereCount() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
}
public threaded struct extern "::btMultiSphereShapeData" btMultiSphereShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rawarray{char, 4} m_padding;
  public int m_localPositionArraySize;
  public rptr{btPositionAndRadius} m_localPositionArrayPtr;
}
public metafunction btNearCallback rptr{meta::list{void, rawref{btBroadphasePair}, rawref{btCollisionDispatcher}, crawref{btDispatcherInfo}}};
public threaded struct extern "::btNodeOverlapCallback" "nonmovable" btNodeOverlapCallback {
  public function extern "processNode" void processNode(int subPart, int triangleIndex);
}
public threaded struct extern "::btNullPairCache" "nonmovable" btNullPairCache {
  public metafunction __base__ {btOverlappingPairCache, btOverlappingPairCallback};
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} _1);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} _0);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} _0, rptr{btDispatcher} _1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} _0);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1, rptr{btDispatcher} _2);
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} _0, rptr{btDispatcher} _1);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& _0, rptr{btDispatcher} _1);
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1);
}
public threaded struct extern "::btOptimizedBvh" "nonmovable" btOptimizedBvh {
  public metafunction __base__ {btQuantizedBvh};
  public function extern "buildInternal" void buildInternal();
  public function extern "reportRayOverlappingNodex" void reportRayOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& raySource, btVector3 const& rayTarget) const;
  public function extern "build" void build(rptr{btStridingMeshInterface} triangles, bool useQuantizedAabbCompression, btVector3 const& bvhAabbMin, btVector3 const& bvhAabbMax);
  public function extern "reportBoxCastOverlappingNodex" void reportBoxCastOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& raySource, btVector3 const& rayTarget, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "deSerializeDouble" void deSerializeDouble(btQuantizedBvhDoubleData mutable& quantizedBvhDoubleData);
  public function extern "setTraversalMode" void setTraversalMode(btTraversalMode traversalMode);
  public function extern "deSerializeFloat" void deSerializeFloat(btQuantizedBvhFloatData mutable& quantizedBvhFloatData);
  public function extern "unQuantize" btVector3 unQuantize(crptr{ushort} vecIn) const;
  public function extern "quantizeWithClamp" void quantizeWithClamp(rptr{ushort} out, btVector3 const& point2, int isMax) const;
  public function extern "updateBvhNodes" void updateBvhNodes(rptr{btStridingMeshInterface} meshInterface, int firstNode, int endNode, int index);
  public function extern "reportAabbOverlappingNodex" void reportAabbOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "serializeInPlace" bool serializeInPlace(rptr{void} o_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian) const;
  public function extern "quantize" void quantize(rptr{ushort} out, btVector3 const& point, int isMax) const;
  public function extern "calculateSerializeBufferSizeNew" int calculateSerializeBufferSizeNew() const;
  public function extern "getSubtreeInfoArray" BvhSubtreeInfoArray mutable& getSubtreeInfoArray();
  public function extern "setQuantizationValues" void setQuantizationValues(btVector3 const& bvhAabbMin, btVector3 const& bvhAabbMax, btScalar quantizationMargin);
  public function extern "getLeafNodeArray" QuantizedNodeArray mutable& getLeafNodeArray();
  public function extern "isQuantized" bool isQuantized();
  public function extern "refit" void refit(rptr{btStridingMeshInterface} triangles, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "getQuantizedNodeArray" QuantizedNodeArray mutable& getQuantizedNodeArray();
  public function extern "serialize" bool serialize3(rptr{void} o_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian) const;
  public function extern "serialize" crptr{char} serialize2(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "refitPartial" void refitPartial(rptr{btStridingMeshInterface} triangles, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "calculateSerializeBufferSize" uint calculateSerializeBufferSize() const;
}
public threaded struct extern "::btOptimizedBvhNode" btOptimizedBvhNode {
  public rawarray{char, 20} m_padding;
  public int m_subPart;
  public btVector3 m_aabbMaxOrg;
  public int m_escapeIndex;
  public int m_triangleIndex;
  public btVector3 m_aabbMinOrg;
}
public threaded struct extern "::btOptimizedBvhNodeDoubleData" btOptimizedBvhNodeDoubleData {
  public int m_escapeIndex;
  public int m_triangleIndex;
  public btVector3DoubleData m_aabbMaxOrg;
  public btVector3DoubleData m_aabbMinOrg;
  public rawarray{char, 4} m_pad;
  public int m_subPart;
}
public threaded struct extern "::btOptimizedBvhNodeFloatData" btOptimizedBvhNodeFloatData {
  public rawarray{char, 4} m_pad;
  public int m_subPart;
  public btVector3FloatData m_aabbMinOrg;
  public int m_escapeIndex;
  public int m_triangleIndex;
  public btVector3FloatData m_aabbMaxOrg;
}
public threaded struct extern "::btOverlapCallback" "nonmovable" btOverlapCallback {
  public function extern "processOverlap" bool processOverlap(btBroadphasePair mutable& pair);
}
public threaded struct extern "::btOverlapFilterCallback" "nonmovable" btOverlapFilterCallback {
  public function extern "needBroadphaseCollision" bool needBroadphaseCollision(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1) const;
}
public threaded struct extern "::btOverlappingPairCache" "nonmovable" btOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCallback};
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1, rptr{btDispatcher} dispatcher);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair, rptr{btDispatcher} dispatcher);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0, rptr{btDispatcher} dispatcher);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback);
}
public threaded struct extern "::btOverlappingPairCallback" "nonmovable" btOverlappingPairCallback {
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1, rptr{btDispatcher} dispatcher);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0, rptr{btDispatcher} dispatcher);
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
}
public threaded struct extern "::btPersistentManifold" btPersistentManifold {
  public metafunction __base__ {btTypedObject};
  public function extern "getBody1" crptr{btCollisionObject} getBody1() const;
  public function extern "setNumContacts" void setNumContacts(int cachedPoints);
  public function extern "setBodies" void setBodies(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "refreshContactPoints" void refreshContactPoints(btTransform const& trA, btTransform const& trB);
  public function extern "removeContactPoint" void removeContactPoint(int index);
  public function extern "setContactBreakingThreshold" void setContactBreakingThreshold(btScalar contactBreakingThreshold);
  public function extern "getBody0" crptr{btCollisionObject} getBody0() const;
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "addManifoldPoint" int addManifoldPoint(btManifoldPoint const& newPoint, bool isPredictive);
  public function extern "replaceContactPoint" void replaceContactPoint(btManifoldPoint const& newPoint, int insertIndex);
  public function extern "clearManifold" void clearManifold();
  public function extern "getNumContacts" int getNumContacts() const;
  public function extern "getContactPoint" btManifoldPoint mutable& getContactPoint(int index);
  public function extern "getContactPoint" btManifoldPoint const& cgetContactPoint(int index) const;
  public function extern "validContactDistance" bool validContactDistance(btManifoldPoint const& pt) const;
  public function extern "getCacheEntry" int getCacheEntry(btManifoldPoint const& newPoint) const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "clearUserCache" void clearUserCache(btManifoldPoint mutable& pt);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold() const;
  public int m_companionIdA;
  public int m_objectType;
  public int m_companionIdB;
  public int m_index1a;
}
public threaded struct extern "::btPoint2PointConstraint" "nodefault" btPoint2PointConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& pivotInA, btVector3 const& pivotInB)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getPivotInA" btVector3 const& getPivotInA() const;
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& body0_trans, btTransform const& body1_trans);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getUid" int getUid() const;
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getPivotInB" btVector3 const& getPivotInB() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "setPivotB" void setPivotB(btVector3 const& pivotB);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setPivotA" void setPivotA(btVector3 const& pivotA);
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public int m_objectType;
  public btConstraintSetting m_setting;
  public bool m_useSolveConstraintObsolete;
}
public threaded struct extern "::btPoint2PointConstraintDoubleData" btPoint2PointConstraintDoubleData {
  public btTypedConstraintData m_typeConstraintData;
  public btVector3DoubleData m_pivotInB;
  public btVector3DoubleData m_pivotInA;
}
public threaded struct extern "::btPoint2PointConstraintFloatData" btPoint2PointConstraintFloatData {
  public btTypedConstraintData m_typeConstraintData;
  public btVector3FloatData m_pivotInB;
  public btVector3FloatData m_pivotInA;
}
public tsvaluetype struct extern "::btPoint2PointFlags" "extenum" btPoint2PointFlags { }
public extern "BT_P2P_FLAGS_ERP" btPoint2PointFlags BT_P2P_FLAGS_ERP;
public extern "BT_P2P_FLAGS_CFM" btPoint2PointFlags BT_P2P_FLAGS_CFM;
public threaded struct extern "::btPointerUid" btPointerUid {
}
/* skip btPointerUid_29 : unnamed */
public threaded struct extern "::btPolyhedralConvexAabbCachingShape" "nonmovable" btPolyhedralConvexAabbCachingShape {
  public metafunction __base__ {btConvexInternalShape, btPolyhedralConvexShape, btConvexShape, btCollisionShape};
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin);
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax, btScalar margin) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
}
public threaded struct extern "::btPolyhedralConvexShape" "nonmovable" btPolyhedralConvexShape {
  public metafunction __base__ {btCollisionShape, btConvexInternalShape, btConvexShape};
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin);
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
}
public threaded struct extern "::btPoolAllocator" "nodefault" btPoolAllocator private()  {
}
public threaded struct extern "::btPositionAndRadius" btPositionAndRadius {
  public float m_radius;
  public btVector3FloatData m_pos;
}
public threaded struct extern "::btQuadWord" btQuadWord {
  public function extern "setW" void setW(btScalar _w);
  public function extern "getY" btScalar const& getY() const;
  public function extern "x" btScalar const& x() const;
  public function extern "setX" void setX(btScalar _x);
  public function extern "setY" void setY(btScalar _y);
  public function extern "getX" btScalar const& getX() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "z" btScalar const& z() const;
  public function extern "setValue" void setValue4(btScalar const& _x, btScalar const& _y, btScalar const& _z, btScalar const& _w);
  public function extern "setValue" void setValue3(btScalar const& _x, btScalar const& _y, btScalar const& _z);
  public function extern "y" btScalar const& y() const;
  public function extern "setMin" void setMin(btQuadWord const& other);
  public function extern "setZ" void setZ(btScalar _z);
  public function extern "w" btScalar const& w() const;
  public function extern "setMax" void setMax(btQuadWord const& other);
}
public threaded struct extern "::btQuantizedBvh" "nonmovable" btQuantizedBvh {
  public function extern "calculateSerializeBufferSizeNew" int calculateSerializeBufferSizeNew() const;
  public function extern "getSubtreeInfoArray" BvhSubtreeInfoArray mutable& getSubtreeInfoArray();
  public function extern "setQuantizationValues" void setQuantizationValues(btVector3 const& bvhAabbMin, btVector3 const& bvhAabbMax, btScalar quantizationMargin);
  public function extern "quantizeWithClamp" void quantizeWithClamp(rptr{ushort} out, btVector3 const& point2, int isMax) const;
  public function extern "quantize" void quantize(rptr{ushort} out, btVector3 const& point, int isMax) const;
  public function extern "reportAabbOverlappingNodex" void reportAabbOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "serialize" crptr{char} serialize2(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "serialize" bool serialize3(rptr{void} o_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian) const;
  public function extern "isQuantized" bool isQuantized();
  public function extern "getQuantizedNodeArray" QuantizedNodeArray mutable& getQuantizedNodeArray();
  public function extern "calculateSerializeBufferSize" uint calculateSerializeBufferSize() const;
  public function extern "getLeafNodeArray" QuantizedNodeArray mutable& getLeafNodeArray();
  public function extern "reportRayOverlappingNodex" void reportRayOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& raySource, btVector3 const& rayTarget) const;
  public function extern "buildInternal" void buildInternal();
  public function extern "setTraversalMode" void setTraversalMode(btTraversalMode traversalMode);
  public function extern "deSerializeFloat" void deSerializeFloat(btQuantizedBvhFloatData mutable& quantizedBvhFloatData);
  public function extern "deSerializeDouble" void deSerializeDouble(btQuantizedBvhDoubleData mutable& quantizedBvhDoubleData);
  public function extern "unQuantize" btVector3 unQuantize(crptr{ushort} vecIn) const;
  public function extern "reportBoxCastOverlappingNodex" void reportBoxCastOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& raySource, btVector3 const& rayTarget, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
}
public threaded struct extern "::btQuantizedBvhDoubleData" btQuantizedBvhDoubleData {
  public int m_useQuantization;
  public int m_numQuantizedContiguousNodes;
  public int m_numContiguousLeafNodes;
  public btVector3DoubleData m_bvhQuantization;
  public rptr{btBvhSubtreeInfoData} m_subTreeInfoPtr;
  public int m_traversalMode;
  public btVector3DoubleData m_bvhAabbMax;
  public int m_curNodeIndex;
  public rptr{btQuantizedBvhNodeData} m_quantizedContiguousNodesPtr;
  public btVector3DoubleData m_bvhAabbMin;
  public int m_numSubtreeHeaders;
  public rptr{btOptimizedBvhNodeDoubleData} m_contiguousNodesPtr;
}
public threaded struct extern "::btQuantizedBvhFloatData" btQuantizedBvhFloatData {
  public int m_useQuantization;
  public int m_numQuantizedContiguousNodes;
  public btVector3FloatData m_bvhQuantization;
  public int m_numContiguousLeafNodes;
  public rptr{btBvhSubtreeInfoData} m_subTreeInfoPtr;
  public int m_traversalMode;
  public int m_curNodeIndex;
  public btVector3FloatData m_bvhAabbMax;
  public rptr{btQuantizedBvhNodeData} m_quantizedContiguousNodesPtr;
  public rptr{btOptimizedBvhNodeFloatData} m_contiguousNodesPtr;
  public int m_numSubtreeHeaders;
  public btVector3FloatData m_bvhAabbMin;
}
public threaded struct extern "::btQuantizedBvhNode" btQuantizedBvhNode {
  public function extern "getPartId" int getPartId() const;
  public function extern "getTriangleIndex" int getTriangleIndex() const;
  public function extern "getEscapeIndex" int getEscapeIndex() const;
  public function extern "isLeafNode" bool isLeafNode() const;
  public int m_escapeIndexOrTriangleIndex;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public rawarray{ushort, 3} m_quantizedAabbMin;
}
public threaded struct extern "::btQuantizedBvhNodeData" btQuantizedBvhNodeData {
  public int m_escapeIndexOrTriangleIndex;
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
}
public threaded struct extern "::btQuaternion" btQuaternion {
  public metafunction __base__ {btQuadWord};
  public function extern "dot" btScalar dot(btQuaternion const& q) const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "setRotation" void setRotation(btVector3 const& axis, btScalar const& _angle);
  public function extern "farthest" btQuaternion farthest(btQuaternion const& qd) const;
  public function extern "z" btScalar const& z() const;
  public function extern "setValue" void setValue3(btScalar const& _x, btScalar const& _y, btScalar const& _z);
  public function extern "setValue" void setValue4(btScalar const& _x, btScalar const& _y, btScalar const& _z, btScalar const& _w);
  public function extern "x" btScalar const& x() const;
  public function extern "angle" btScalar angle(btQuaternion const& q) const;
  public function extern "setW" void setW(btScalar _w);
  public function extern "getAxis" btVector3 getAxis() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "length2" btScalar length2() const;
  public function extern "setX" void setX(btScalar _x);
  public function extern "setY" void setY(btScalar _y);
  public function extern "normalized" btQuaternion normalized() const;
  public function extern "setEulerZYX" void setEulerZYX(btScalar const& yaw, btScalar const& pitch, btScalar const& roll);
  public function extern "length" btScalar length() const;
  public function extern "getW" btScalar const& getW() const;
  public function extern "inverse" btQuaternion inverse() const;
  public function extern "setEuler" void setEuler(btScalar const& yaw, btScalar const& pitch, btScalar const& roll);
  public function extern "setMax" void setMax(btQuadWord const& other);
  public function extern "setMin" void setMin(btQuadWord const& other);
  public function extern "setZ" void setZ(btScalar _z);
  public function extern "y" btScalar const& y() const;
  public function extern "w" btScalar const& w() const;
  public function extern "nearest" btQuaternion nearest(btQuaternion const& qd) const;
  public function extern "normalize" btQuaternion mutable& normalize();
  public function extern "slerp" btQuaternion slerp(btQuaternion const& q, btScalar const& t) const;
  public function extern "getAngle" btScalar getAngle() const;
}
public threaded struct extern "::btRaycastVehicle" "nodefault" btRaycastVehicle(btRaycastVehicle_btVehicleTuning const& tuning, rptr{btRigidBody} chassis, rptr{btVehicleRaycaster} raycaster)  {
  public metafunction __base__ {btActionInterface};
  public function extern "applyEngineForce" void applyEngineForce(btScalar force, int wheel);
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld, btScalar step);
  public function extern "setBrake" void setBrake(btScalar brake, int wheelIndex);
  public function extern "setSteeringValue" void setSteeringValue(btScalar steering, int wheel);
  public function extern "updateFriction" void updateFriction(btScalar timeStep);
  public function extern "resetSuspension" void resetSuspension();
  public function extern "getNumWheels" int getNumWheels() const;
  public function extern "getWheelInfo" btWheelInfo const& cgetWheelInfo(int index) const;
  public function extern "getWheelInfo" btWheelInfo mutable& getWheelInfo(int index);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "rayCast" btScalar rayCast(btWheelInfo mutable& wheel);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "getRightAxis" int getRightAxis() const;
  public function extern "getCurrentSpeedKmHour" btScalar getCurrentSpeedKmHour() const;
  public function extern "setPitchControl" void setPitchControl(btScalar pitch);
  public function extern "getSteeringValue" btScalar getSteeringValue(int wheel) const;
  public function extern "getWheelTransformWS" btTransform const& getWheelTransformWS(int wheelIndex) const;
  public function extern "updateVehicle" void updateVehicle(btScalar step);
  public function extern "getForwardVector" btVector3 getForwardVector() const;
  public function extern "getRigidBody" crptr{btRigidBody} cgetRigidBody() const;
  public function extern "getRigidBody" rptr{btRigidBody} getRigidBody();
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getChassisWorldTransform" btTransform const& getChassisWorldTransform() const;
  public function extern "addWheel" btWheelInfo mutable& addWheel(btVector3 const& connectionPointCS0, btVector3 const& wheelDirectionCS0, btVector3 const& wheelAxleCS, btScalar suspensionRestLength, btScalar wheelRadius, btRaycastVehicle_btVehicleTuning const& tuning, bool isFrontWheel);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "updateWheelTransform" void updateWheelTransform(int wheelIndex, bool interpolatedTransform);
  public function extern "updateSuspension" void updateSuspension(btScalar deltaTime);
  public function extern "setCoordinateSystem" void setCoordinateSystem(int rightIndex, int upIndex, int forwardIndex);
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer);
  public function extern "updateWheelTransformsWS" void updateWheelTransformsWS(btWheelInfo mutable& wheel, bool interpolatedTransform);
  public function extern "getForwardAxis" int getForwardAxis() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public btAlignedObjectArray_btWheelInfo m_wheelInfo;
}
public threaded struct extern "::btRaycastVehicle::btVehicleTuning" btRaycastVehicle_btVehicleTuning {
  public btScalar m_suspensionCompression;
  public btScalar m_suspensionDamping;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_maxSuspensionForce;
  public btScalar m_frictionSlip;
  public btScalar m_suspensionStiffness;
}
public threaded struct extern "::btRigidBody" "nodefault" btRigidBody(btRigidBody_btRigidBodyConstructionInfo const& constructionInfo)  {
  public metafunction __base__ {btCollisionObject};
  public function extern "checkCollideWithOverride" bool checkCollideWithOverride(crptr{btCollisionObject} co) const;
  public function extern "getCenterOfMassPosition" btVector3 const& getCenterOfMassPosition() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer);
  public function extern "getAngularFactor" btVector3 const& getAngularFactor() const;
  public function extern "setCollisionFlags" void setCollisionFlags(int flags);
  public function extern "getInvInertiaTensorWorld" btMatrix3x3 const& getInvInertiaTensorWorld() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode) const;
  public function extern "getInternalType" int getInternalType() const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co) const;
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "updateDeactivation" void updateDeactivation(btScalar timeStep);
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getNumConstraintRefs" int getNumConstraintRefs() const;
  public function extern "setMotionState" void setMotionState(rptr{btMotionState} motionState);
  public function extern "getTotalTorque" btVector3 const& getTotalTorque() const;
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "getOrientation" btQuaternion getOrientation() const;
  public function extern "getInvMass" btScalar getInvMass() const;
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time);
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "setFlags" void setFlags(int flags);
  public function extern "predictIntegratedTransform" void predictIntegratedTransform(btScalar step, btTransform mutable& predictedTransform);
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "activate" void activate(bool forceActivation) const;
  public function extern "getConstraintRef" rptr{btTypedConstraint} getConstraintRef(int index);
  public function extern "setActivationState" void setActivationState(int newState) const;
  public function extern "setNewBroadphaseProxy" void setNewBroadphaseProxy(rptr{btBroadphaseProxy} broadphaseProxy);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setGravity" void setGravity(btVector3 const& acceleration);
  public function extern "getLinearSleepingThreshold" btScalar getLinearSleepingThreshold() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAngularVelocity" btVector3 const& getAngularVelocity() const;
  public function extern "updateInertiaTensor" void updateInertiaTensor();
  public function extern "applyGravity" void applyGravity();
  public function extern "getCenterOfMassTransform" btTransform const& getCenterOfMassTransform() const;
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getLinearFactor" btVector3 const& getLinearFactor() const;
  public function extern "setDamping" void setDamping(btScalar lin_damping, btScalar ang_damping);
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "setRestitution" void setRestitution(btScalar rest);
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "applyCentralForce" void applyCentralForce(btVector3 const& force);
  public function extern "getBroadphaseProxy" crptr{btBroadphaseProxy} cgetBroadphaseProxy() const;
  public function extern "getBroadphaseProxy" rptr{btBroadphaseProxy} getBroadphaseProxy();
  public function extern "getAngularSleepingThreshold" btScalar getAngularSleepingThreshold() const;
  public function extern "computeImpulseDenominator" btScalar computeImpulseDenominator(btVector3 const& pos, btVector3 const& normal) const;
  public function extern "applyCentralImpulse" void applyCentralImpulse(btVector3 const& impulse);
  public function extern "getLinearDamping" btScalar getLinearDamping() const;
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape);
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction, int frictionMode);
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "setSleepingThresholds" void setSleepingThresholds(btScalar linear, btScalar angular);
  public function extern "isInWorld" bool isInWorld() const;
  public function extern "applyTorque" void applyTorque(btVector3 const& torque);
  public function extern "removeConstraintRef" void removeConstraintRef(rptr{btTypedConstraint} c);
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "getAngularDamping" btScalar getAngularDamping() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "proceedToTransform" void proceedToTransform(btTransform const& newTrans);
  public function extern "clearForces" void clearForces();
  public function extern "getInvInertiaDiagLocal" btVector3 const& getInvInertiaDiagLocal() const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer) const;
  public function extern "isActive" bool isActive() const;
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle);
  public function extern "getMotionState" crptr{btMotionState} cgetMotionState() const;
  public function extern "getMotionState" rptr{btMotionState} getMotionState();
  public function extern "setCompanionId" void setCompanionId(int id);
  public function extern "computeGyroscopicForce" btVector3 computeGyroscopicForce(btScalar maxGyroscopicForce) const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans);
  public function extern "saveKinematicState" void saveKinematicState(btScalar step);
  public function extern "getGravity" btVector3 const& getGravity() const;
  public function extern "translate" void translate(btVector3 const& v);
  public function extern "applyDamping" void applyDamping(btScalar timeStep);
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "applyImpulse" void applyImpulse(btVector3 const& impulse, btVector3 const& rel_pos);
  public function extern "applyForce" void applyForce(btVector3 const& force, btVector3 const& rel_pos);
  public function extern "getFlags" int getFlags() const;
  public function extern "integrateVelocities" void integrateVelocities(btScalar step);
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction);
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel);
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold);
  public function extern "computeAngularImpulseDenominator" btScalar computeAngularImpulseDenominator(btVector3 const& axis) const;
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "setAngularFactor" void setAngularFactor_btScalar(btScalar angFac);
  public function extern "setAngularFactor" void setAngularFactor_btVector3(btVector3 const& angFac);
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "applyTorqueImpulse" void applyTorqueImpulse(btVector3 const& torque);
  public function extern "getVelocityInLocalPoint" btVector3 getVelocityInLocalPoint(btVector3 const& rel_pos) const;
  public function extern "setLinearVelocity" void setLinearVelocity(btVector3 const& lin_vel);
  public function extern "setInvInertiaDiagLocal" void setInvInertiaDiagLocal(btVector3 const& diagInvInertia);
  public function extern "setAngularVelocity" void setAngularVelocity(btVector3 const& ang_vel);
  public function extern "getTotalForce" btVector3 const& getTotalForce() const;
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict);
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "forceActivationState" void forceActivationState(int newState) const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "setCenterOfMassTransform" void setCenterOfMassTransform(btTransform const& xform);
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "addConstraintRef" void addConstraintRef(rptr{btTypedConstraint} c);
  public function extern "setLinearFactor" void setLinearFactor(btVector3 const& linearFactor);
  public function extern "setFriction" void setFriction(btScalar frict);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold);
  public function extern "setIslandTag" void setIslandTag(int tag);
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer);
  public function extern "setMassProps" void setMassProps(btScalar mass, btVector3 const& inertia);
  public function extern "wantsSleeping" bool wantsSleeping();
  public function extern "getLinearVelocity" btVector3 const& getLinearVelocity() const;
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel);
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans);
  public int m_contactSolverType;
  public int m_frictionSolverType;
}
public threaded struct extern "::btRigidBodyDoubleData" btRigidBodyDoubleData {
  public double m_angularDamping;
  public double m_additionalAngularDampingThresholdSqr;
  public double m_linearSleepingThreshold;
  public btCollisionObjectDoubleData m_collisionObjectData;
  public btVector3DoubleData m_linearFactor;
  public double m_additionalDampingFactor;
  public btVector3DoubleData m_gravity;
  public btVector3DoubleData m_gravity_acceleration;
  public btMatrix3x3DoubleData m_invInertiaTensorWorld;
  public rawarray{char, 4} m_padding;
  public double m_additionalAngularDampingFactor;
  public btVector3DoubleData m_totalForce;
  public int m_additionalDamping;
  public btVector3DoubleData m_angularVelocity;
  public double m_linearDamping;
  public btVector3DoubleData m_totalTorque;
  public btVector3DoubleData m_invInertiaLocal;
  public double m_inverseMass;
  public btVector3DoubleData m_angularFactor;
  public double m_angularSleepingThreshold;
  public double m_additionalLinearDampingThresholdSqr;
  public btVector3DoubleData m_linearVelocity;
}
public tsvaluetype struct extern "::btRigidBodyFlags" "extenum" btRigidBodyFlags { }
public extern "BT_DISABLE_WORLD_GRAVITY" btRigidBodyFlags BT_DISABLE_WORLD_GRAVITY;
public extern "BT_ENABLE_GYROPSCOPIC_FORCE" btRigidBodyFlags BT_ENABLE_GYROPSCOPIC_FORCE;
public threaded struct extern "::btRigidBodyFloatData" btRigidBodyFloatData {
  public float m_angularDamping;
  public btVector3FloatData m_linearFactor;
  public float m_linearSleepingThreshold;
  public btCollisionObjectFloatData m_collisionObjectData;
  public float m_additionalAngularDampingThresholdSqr;
  public btVector3FloatData m_gravity_acceleration;
  public btVector3FloatData m_gravity;
  public float m_additionalDampingFactor;
  public btVector3FloatData m_totalForce;
  public float m_additionalAngularDampingFactor;
  public btMatrix3x3FloatData m_invInertiaTensorWorld;
  public float m_linearDamping;
  public btVector3FloatData m_angularVelocity;
  public int m_additionalDamping;
  public float m_inverseMass;
  public btVector3FloatData m_invInertiaLocal;
  public btVector3FloatData m_totalTorque;
  public btVector3FloatData m_angularFactor;
  public float m_additionalLinearDampingThresholdSqr;
  public btVector3FloatData m_linearVelocity;
  public float m_angularSleepingThreshold;
}
public threaded struct extern "::btRigidBody::btRigidBodyConstructionInfo" "nodefault" btRigidBody_btRigidBodyConstructionInfo(btScalar mass, rptr{btMotionState} motionState, rptr{btCollisionShape} collisionShape, btVector3 const& localInertia)  {
  public btScalar m_linearDamping;
  public bool m_additionalDamping;
  public btScalar m_friction;
  public btScalar m_rollingFriction;
  public btScalar m_additionalLinearDampingThresholdSqr;
  public btScalar m_angularSleepingThreshold;
  public btTransform m_startWorldTransform;
  public btScalar m_mass;
  public rptr{btCollisionShape} m_collisionShape;
  public btScalar m_angularDamping;
  public rptr{btMotionState} m_motionState;
  public btScalar m_restitution;
  public btScalar m_linearSleepingThreshold;
  public btScalar m_additionalAngularDampingThresholdSqr;
  public btScalar m_additionalDampingFactor;
  public btScalar m_additionalAngularDampingFactor;
  public btVector3 m_localInertia;
}
public threaded struct extern "::btRotationalLimitMotor" btRotationalLimitMotor {
  public function extern "isLimited" bool isLimited();
  public function extern "testLimitValue" int testLimitValue(btScalar test_value);
  public function extern "needApplyTorques" bool needApplyTorques();
  public function extern "solveAngularLimits" btScalar solveAngularLimits(btScalar timeStep, btVector3 mutable& axis, btScalar jacDiagABInv, rptr{btRigidBody} body0, rptr{btRigidBody} body1);
  public btScalar m_maxLimitForce;
  public btScalar m_normalCFM;
  public btScalar m_maxMotorForce;
  public btScalar m_stopCFM;
  public bool m_enableMotor;
  public btScalar m_limitSoftness;
  public btScalar m_currentPosition;
  public btScalar m_hiLimit;
  public int m_currentLimit;
  public btScalar m_accumulatedImpulse;
  public btScalar m_currentLimitError;
  public btScalar m_bounce;
  public btScalar m_loLimit;
  public btScalar m_stopERP;
  public btScalar m_damping;
  public btScalar m_targetVelocity;
}
public metafunction btSapBroadphaseArray btAlignedObjectArray_btBroadphaseInterface_p;
public metafunction btScalar float;
public threaded struct extern "::btScaledBvhTriangleMeshShape" "nodefault" btScaledBvhTriangleMeshShape(rptr{btBvhTriangleMeshShape} childShape, btVector3 const& localScaling)  {
  public metafunction __base__ {btCollisionShape, btConcaveShape};
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getChildShape" rptr{btBvhTriangleMeshShape} getChildShape();
  public function extern "getChildShape" crptr{btBvhTriangleMeshShape} cgetChildShape() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
}
public threaded struct extern "::btScaledTriangleMeshShapeData" btScaledTriangleMeshShapeData {
  public btVector3FloatData m_localScaling;
  public btTriangleMeshShapeData m_trimeshShapeData;
}
public threaded struct extern "::btSequentialImpulseConstraintSolver" "nonmovable" btSequentialImpulseConstraintSolver {
  public metafunction __base__ {btConstraintSolver};
  public function extern "prepareSolve" void prepareSolve(int _0, int _1);
  public function extern "getRandSeed" ulong getRandSeed() const;
  public function extern "allSolved" void allSolved(btContactSolverInfo const& _0, rptr{btIDebugDraw} _1, rptr{btStackAlloc} _2);
  public function extern "setRandSeed" void setRandSeed(ulong seed);
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies, int numBodies, rptr{rptr{btPersistentManifold}} manifold, int numManifolds, rptr{rptr{btTypedConstraint}} constraints, int numConstraints, btContactSolverInfo const& info, rptr{btIDebugDraw} debugDrawer, rptr{btStackAlloc} stackAlloc, rptr{btDispatcher} dispatcher);
  public function extern "btRand2" ulong btRand2();
  public function extern "reset" void reset();
  public function extern "btRandInt2" int btRandInt2(int n);
}
public tsvaluetype struct extern "::btSerializationFlags" "extenum" btSerializationFlags { }
public extern "BT_SERIALIZE_NO_BVH" btSerializationFlags BT_SERIALIZE_NO_BVH;
public extern "BT_SERIALIZE_NO_TRIANGLEINFOMAP" btSerializationFlags BT_SERIALIZE_NO_TRIANGLEINFOMAP;
public extern "BT_SERIALIZE_NO_DUPLICATE_ASSERT" btSerializationFlags BT_SERIALIZE_NO_DUPLICATE_ASSERT;
public threaded struct extern "::btSerializer" "nonmovable" btSerializer {
  public function extern "findPointer" rptr{void} findPointer(rptr{void} oldPtr);
  public function extern "findNameForPointer" crptr{char} findNameForPointer(crptr{void} ptr) const;
  public function extern "finishSerialization" void finishSerialization();
  public function extern "serializeName" void serializeName(crptr{char} ptr);
  public function extern "registerNameForPointer" void registerNameForPointer(crptr{void} ptr, crptr{char} name);
  public function extern "getUniquePointer" rptr{void} getUniquePointer(rptr{void} oldPtr);
  public function extern "allocate" rptr{btChunk} allocate(size_t size, int numElements);
  public function extern "getBufferPointer" crptr{uchar} getBufferPointer() const;
  public function extern "setSerializationFlags" void setSerializationFlags(int flags);
  public function extern "getCurrentBufferSize" int getCurrentBufferSize() const;
  public function extern "startSerialization" void startSerialization();
  public function extern "finalizeChunk" void finalizeChunk(rptr{btChunk} chunk, crptr{char} structType, int chunkCode, rptr{void} oldPtr);
  public function extern "getSerializationFlags" int getSerializationFlags() const;
}
public threaded struct extern "::btShortIntIndexData" btShortIntIndexData {
  public short m_value;
  public rawarray{char, 2} m_pad;
}
public threaded struct extern "::btShortIntIndexTripletData" btShortIntIndexTripletData {
  public rawarray{char, 2} m_pad;
  public rawarray{short, 3} m_values;
}
public threaded struct extern "::btSimpleBroadphase" "nodefault" btSimpleBroadphase(int maxProxies, rptr{btOverlappingPairCache} overlappingPairCache)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "printStats" void printStats();
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
}
public threaded struct extern "::btSimpleBroadphaseProxy" btSimpleBroadphaseProxy {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "SetNextFree" void SetNextFree(int next);
  public function extern "GetNextFree" int GetNextFree() const;
  public function extern "getUid" int getUid() const;
  public btVector3 m_aabbMax;
  public int m_uniqueId;
  public int m_nextFree;
  public rptr{void} m_clientObject;
  public short m_collisionFilterGroup;
  public btVector3 m_aabbMin;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
}
public threaded struct extern "::btSimpleDynamicsWorld" "nodefault" btSimpleDynamicsWorld(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} pairCache, rptr{btConstraintSolver} constraintSolver, rptr{btCollisionConfiguration} collisionConfiguration)  {
  public metafunction __base__ {btCollisionWorld, btDynamicsWorld};
  public function extern "setGravity" void setGravity(btVector3 const& gravity);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer);
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs);
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache);
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint, bool disableCollisionsBetweenLinkedBodies);
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld, btVector3 const& rayToWorld, btCollisionWorld_RayResultCallback mutable& resultCallback) const;
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb, rptr{void} worldUserInfo, bool isPreTick);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject);
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "updateAabbs" void updateAabbs();
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo);
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform, crptr{btCollisionShape} shape, btVector3 const& color);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle);
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character);
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver);
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape, btTransform const& from, btTransform const& to, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedCcdPenetration) const;
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "addAction" void addAction(rptr{btActionInterface} action);
  public function extern "clearForces" void clearForces();
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index);
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index) const;
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body);
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body, short group, short mask);
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject, short collisionFilterGroup, short collisionFilterMask);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA, rptr{btCollisionObject} colObjB, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer);
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action);
}
public threaded struct extern "::btSimulationIslandManager" "nodefault" btSimulationIslandManager private()  {
}
public threaded struct extern "::btSliderConstraint" "nodefault" btSliderConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint};
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "setTargetLinMotorVelocity" void setTargetLinMotorVelocity(btScalar targetLinMotorVelocity);
  public function extern "getSoftnessOrthoAng" btScalar getSoftnessOrthoAng();
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "getLowerLinLimit" btScalar getLowerLinLimit();
  public function extern "testAngLimits" void testAngLimits();
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "setUpperLinLimit" void setUpperLinLimit(btScalar upperLimit);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "setRestitutionOrthoLin" void setRestitutionOrthoLin(btScalar restitutionOrthoLin);
  public function extern "setTargetAngMotorVelocity" void setTargetAngMotorVelocity(btScalar targetAngMotorVelocity);
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getDampingDirLin" btScalar getDampingDirLin();
  public function extern "getPoweredAngMotor" bool getPoweredAngMotor();
  public function extern "setRestitutionLimAng" void setRestitutionLimAng(btScalar restitutionLimAng);
  public function extern "getMaxLinMotorForce" btScalar getMaxLinMotorForce();
  public function extern "getSolveLinLimit" bool getSolveLinLimit();
  public function extern "setPoweredLinMotor" void setPoweredLinMotor(bool onOff);
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getMaxAngMotorForce" btScalar getMaxAngMotorForce();
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getUpperLinLimit" btScalar getUpperLinLimit();
  public function extern "setLowerLinLimit" void setLowerLinLimit(btScalar lowerLimit);
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "setSoftnessLimAng" void setSoftnessLimAng(btScalar softnessLimAng);
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getRestitutionDirAng" btScalar getRestitutionDirAng();
  public function extern "getSoftnessLimLin" btScalar getSoftnessLimLin();
  public function extern "setRestitutionDirLin" void setRestitutionDirLin(btScalar restitutionDirLin);
  public function extern "setMaxLinMotorForce" void setMaxLinMotorForce(btScalar maxLinMotorForce);
  public function extern "setDampingDirLin" void setDampingDirLin(btScalar dampingDirLin);
  public function extern "setDampingOrthoAng" void setDampingOrthoAng(btScalar dampingOrthoAng);
  public function extern "setMaxAngMotorForce" void setMaxAngMotorForce(btScalar maxAngMotorForce);
  public function extern "getRestitutionLimLin" btScalar getRestitutionLimLin();
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "getDampingLimLin" btScalar getDampingLimLin();
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "calculateTransforms" void calculateTransforms(btTransform const& transA, btTransform const& transB);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "setSoftnessDirLin" void setSoftnessDirLin(btScalar softnessDirLin);
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getAncorInB" btVector3 getAncorInB();
  public function extern "getSoftnessDirAng" btScalar getSoftnessDirAng();
  public function extern "setLowerAngLimit" void setLowerAngLimit(btScalar lowerLimit);
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getAngularPos" btScalar getAngularPos() const;
  public function extern "getUid" int getUid() const;
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btScalar rbAinvMass, btScalar rbBinvMass);
  public function extern "testLinLimits" void testLinLimits();
  public function extern "setUpperAngLimit" void setUpperAngLimit(btScalar upperLimit);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "getLinDepth" btScalar getLinDepth();
  public function extern "setRestitutionDirAng" void setRestitutionDirAng(btScalar restitutionDirAng);
  public function extern "setSoftnessLimLin" void setSoftnessLimLin(btScalar softnessLimLin);
  public function extern "setRestitutionOrthoAng" void setRestitutionOrthoAng(btScalar restitutionOrthoAng);
  public function extern "getTargetLinMotorVelocity" btScalar getTargetLinMotorVelocity();
  public function extern "getLinearPos" btScalar getLinearPos() const;
  public function extern "getUpperAngLimit" btScalar getUpperAngLimit();
  public function extern "setRestitutionLimLin" void setRestitutionLimLin(btScalar restitutionLimLin);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "getSoftnessOrthoLin" btScalar getSoftnessOrthoLin();
  public function extern "getTargetAngMotorVelocity" btScalar getTargetAngMotorVelocity();
  public function extern "setDampingDirAng" void setDampingDirAng(btScalar dampingDirAng);
  public function extern "getRestitutionDirLin" btScalar getRestitutionDirLin();
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "getDampingLimAng" btScalar getDampingLimAng();
  public function extern "setDampingLimLin" void setDampingLimLin(btScalar dampingLimLin);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getSoftnessDirLin" btScalar getSoftnessDirLin();
  public function extern "setSoftnessDirAng" void setSoftnessDirAng(btScalar softnessDirAng);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getRestitutionOrthoLin" btScalar getRestitutionOrthoLin();
  public function extern "setDampingLimAng" void setDampingLimAng(btScalar dampingLimAng);
  public function extern "getAncorInA" btVector3 getAncorInA();
  public function extern "getRestitutionOrthoAng" btScalar getRestitutionOrthoAng();
  public function extern "getSoftnessLimAng" btScalar getSoftnessLimAng();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getUseLinearReferenceFrameA" bool getUseLinearReferenceFrameA();
  public function extern "getDampingDirAng" btScalar getDampingDirAng();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public function extern "getDampingOrthoAng" btScalar getDampingOrthoAng();
  public function extern "getPoweredLinMotor" bool getPoweredLinMotor();
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "setSoftnessOrthoAng" void setSoftnessOrthoAng(btScalar softnessOrthoAng);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getDampingOrthoLin" btScalar getDampingOrthoLin();
  public function extern "getLowerAngLimit" btScalar getLowerAngLimit();
  public function extern "getRestitutionLimAng" btScalar getRestitutionLimAng();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "setDampingOrthoLin" void setDampingOrthoLin(btScalar dampingOrthoLin);
  public function extern "getSolveAngLimit" bool getSolveAngLimit();
  public function extern "setPoweredAngMotor" void setPoweredAngMotor(bool onOff);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "getAngDepth" btScalar getAngDepth();
  public function extern "setSoftnessOrthoLin" void setSoftnessOrthoLin(btScalar softnessOrthoLin);
  public int m_objectType;
}
public threaded struct extern "::btSliderConstraintData" btSliderConstraintData {
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
  public btTransformFloatData m_rbBFrame;
  public btTransformFloatData m_rbAFrame;
  public float m_angularLowerLimit;
  public float m_linearUpperLimit;
  public float m_angularUpperLimit;
  public btTypedConstraintData m_typeConstraintData;
  public float m_linearLowerLimit;
}
public tsvaluetype struct extern "::btSliderFlags" "extenum" btSliderFlags { }
public extern "BT_SLIDER_FLAGS_CFM_DIRLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_DIRLIN;
public extern "BT_SLIDER_FLAGS_ERP_DIRLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_DIRLIN;
public extern "BT_SLIDER_FLAGS_CFM_DIRANG" btSliderFlags BT_SLIDER_FLAGS_CFM_DIRANG;
public extern "BT_SLIDER_FLAGS_ERP_DIRANG" btSliderFlags BT_SLIDER_FLAGS_ERP_DIRANG;
public extern "BT_SLIDER_FLAGS_CFM_ORTLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_ORTLIN;
public extern "BT_SLIDER_FLAGS_ERP_ORTLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_ORTLIN;
public extern "BT_SLIDER_FLAGS_CFM_ORTANG" btSliderFlags BT_SLIDER_FLAGS_CFM_ORTANG;
public extern "BT_SLIDER_FLAGS_ERP_ORTANG" btSliderFlags BT_SLIDER_FLAGS_ERP_ORTANG;
public extern "BT_SLIDER_FLAGS_CFM_LIMLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_LIMLIN;
public extern "BT_SLIDER_FLAGS_ERP_LIMLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_LIMLIN;
public extern "BT_SLIDER_FLAGS_CFM_LIMANG" btSliderFlags BT_SLIDER_FLAGS_CFM_LIMANG;
public extern "BT_SLIDER_FLAGS_ERP_LIMANG" btSliderFlags BT_SLIDER_FLAGS_ERP_LIMANG;
public threaded struct extern "::btSolverBody" btSolverBody {
  public function extern "applyImpulse" void applyImpulse(btVector3 const& linearComponent, btVector3 const& angularComponent, btScalar const impulseMagnitude);
  public function extern "writebackVelocity" void writebackVelocity();
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTransform);
  public function extern "getPushVelocity" btVector3 const& getPushVelocity() const;
  public function extern "internalGetVelocityInLocalPointObsolete" void internalGetVelocityInLocalPointObsolete(btVector3 const& rel_pos, btVector3 mutable& velocity) const;
  public function extern "internalGetAngularFactor" btVector3 const& internalGetAngularFactor() const;
  public function extern "internalGetTurnVelocity" btVector3 mutable& internalGetTurnVelocity();
  public function extern "getDeltaLinearVelocity" btVector3 const& getDeltaLinearVelocity() const;
  public function extern "internalGetInvMass" btVector3 const& internalGetInvMass() const;
  public function extern "internalApplyImpulse" void internalApplyImpulse(btVector3 const& linearComponent, btVector3 const& angularComponent, btScalar const impulseMagnitude);
  public function extern "internalGetDeltaLinearVelocity" btVector3 mutable& internalGetDeltaLinearVelocity();
  public function extern "getDeltaAngularVelocity" btVector3 const& getDeltaAngularVelocity() const;
  public function extern "internalGetDeltaAngularVelocity" btVector3 mutable& internalGetDeltaAngularVelocity();
  public function extern "getTurnVelocity" btVector3 const& getTurnVelocity() const;
  public function extern "getWorldTransform" btTransform const& getWorldTransform() const;
  public function extern "internalApplyPushImpulse" void internalApplyPushImpulse(btVector3 const& linearComponent, btVector3 const& angularComponent, btScalar impulseMagnitude);
  public function extern "internalGetPushVelocity" btVector3 mutable& internalGetPushVelocity();
  public function extern "internalGetAngularVelocity" void internalGetAngularVelocity(btVector3 mutable& angVel) const;
  public function extern "internalSetInvMass" void internalSetInvMass(btVector3 const& invMass);
  public function extern "writebackVelocityAndTransform" void writebackVelocityAndTransform(btScalar timeStep, btScalar splitImpulseTurnErp);
  public function extern "getVelocityInLocalPointObsolete" void getVelocityInLocalPointObsolete(btVector3 const& rel_pos, btVector3 mutable& velocity) const;
  public function extern "getAngularVelocity" void getAngularVelocity(btVector3 mutable& angVel) const;
  public btVector3 m_linearVelocity;
  public btVector3 m_turnVelocity;
  public btVector3 m_deltaAngularVelocity;
  public btVector3 m_angularFactor;
  public btVector3 m_invMass;
  public btVector3 m_deltaLinearVelocity;
  public btVector3 m_pushVelocity;
  public btTransform m_worldTransform;
  public btVector3 m_angularVelocity;
  public btVector3 m_linearFactor;
  public rptr{btRigidBody} m_originalBody;
}
public threaded struct extern "::btSolverConstraint" btSolverConstraint {
  public btScalar m_jacDiagABInv;
  public btVector3 m_angularComponentB;
  public int m_solverBodyIdA;
  public int m_overrideNumSolverIterations;
  public btScalar m_appliedImpulse;
  public btScalar m_upperLimit;
  public btVector3 m_relpos1CrossNormal;
  public btScalar m_friction;
  public btScalar m_lowerLimit;
  public btScalar m_rhs;
  public btScalar m_rhsPenetration;
  public btVector3 m_relpos2CrossNormal;
  public btScalar m_cfm;
  public int m_frictionIndex;
  public int m_solverBodyIdB;
  public btScalar m_appliedPushImpulse;
  public btVector3 m_angularComponentA;
  public btVector3 m_contactNormal;
}
public tsvaluetype struct extern "::btSolverConstraintType" "extenum" btSolverConstraintType { }
public extern "BT_SOLVER_CONTACT_1D" btSolverConstraintType BT_SOLVER_CONTACT_1D;
public extern "BT_SOLVER_FRICTION_1D" btSolverConstraintType BT_SOLVER_FRICTION_1D;
/* skip btSolverConstraint_33 : unnamed */
public tsvaluetype struct extern "::btSolverMode" "extenum" btSolverMode { }
public extern "SOLVER_RANDMIZE_ORDER" btSolverMode SOLVER_RANDMIZE_ORDER;
public extern "SOLVER_FRICTION_SEPARATE" btSolverMode SOLVER_FRICTION_SEPARATE;
public extern "SOLVER_USE_WARMSTARTING" btSolverMode SOLVER_USE_WARMSTARTING;
public extern "SOLVER_USE_2_FRICTION_DIRECTIONS" btSolverMode SOLVER_USE_2_FRICTION_DIRECTIONS;
public extern "SOLVER_ENABLE_FRICTION_DIRECTION_CACHING" btSolverMode SOLVER_ENABLE_FRICTION_DIRECTION_CACHING;
public extern "SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION" btSolverMode SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION;
public extern "SOLVER_CACHE_FRIENDLY" btSolverMode SOLVER_CACHE_FRIENDLY;
public extern "SOLVER_SIMD" btSolverMode SOLVER_SIMD;
public extern "SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS" btSolverMode SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS;
public extern "SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS" btSolverMode SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS;
public threaded struct extern "::btSortedOverlappingPairCache" "nonmovable" btSortedOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCallback, btOverlappingPairCache};
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "needsBroadphaseCollision" bool needsBroadphaseCollision(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1) const;
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback);
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "getOverlapFilterCallback" rptr{btOverlapFilterCallback} getOverlapFilterCallback();
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "getOverlappingPairArray" btBroadphasePairArray const& cgetOverlappingPairArray() const;
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1, rptr{btDispatcher} dispatcher);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair, rptr{btDispatcher} dispatcher);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
}
public threaded struct extern "::btSphereShape" "nodefault" btSphereShape(btScalar radius)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCollisionShape};
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUnscaledRadius" void setUnscaledRadius(btScalar radius);
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
}
public threaded struct extern "::btSphereSphereCollisionAlgorithm" "nodefault" btSphereSphereCollisionAlgorithm(rptr{btPersistentManifold} mf, btCollisionAlgorithmConstructionInfo const& ci, crptr{btCollisionObjectWrapper} col0Wrap, crptr{btCollisionObjectWrapper} col1Wrap)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0, rptr{btCollisionObject} body1, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
}
public threaded struct extern "::btSphereSphereCollisionAlgorithm::CreateFunc" "nonmovable" btSphereSphereCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci, crptr{btCollisionObjectWrapper} col0Wrap, crptr{btCollisionObjectWrapper} col1Wrap);
  public bool m_swapped;
}
public threaded struct extern "::btStackAlloc" "nodefault" btStackAlloc(uint size)  {
  public function extern "allocate" rptr{uchar} allocate(uint size);
  public function extern "destroy" void destroy();
  public function extern "getAvailableMemory" int getAvailableMemory() const;
  public function extern "endBlock" void endBlock(rptr{btBlock} block);
  public function extern "beginBlock" rptr{btBlock} beginBlock();
  public function extern "create" void create(uint size);
}
public threaded struct extern "::btStaticPlaneShape" "nodefault" btStaticPlaneShape(btVector3 const& planeNormal, btScalar planeConstant)  {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "getName" crptr{char} getName() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "getPlaneNormal" btVector3 const& getPlaneNormal() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getPlaneConstant" btScalar const& getPlaneConstant() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
}
public threaded struct extern "::btStaticPlaneShapeData" btStaticPlaneShapeData {
  public btVector3FloatData m_localScaling;
  public rawarray{char, 4} m_pad;
  public btVector3FloatData m_planeNormal;
  public float m_planeConstant;
  public btCollisionShapeData m_collisionShapeData;
}
public threaded struct extern "::btStorageResult" "nonmovable" btStorageResult {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0, int index0);
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld, btVector3 const& pointInWorld, btScalar depth);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1, int index1);
  public btVector3 m_closestPointInB;
  public btVector3 m_normalOnSurfaceB;
  public btScalar m_distance;
}
public threaded struct extern "::btStridingMeshInterface" "nonmovable" btStridingMeshInterface {
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling);
  public function extern "preallocateVertices" void preallocateVertices(int numverts);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& stride, rptr{crptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& stride, rptr{rptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart);
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "preallocateIndices" void preallocateIndices(int numindices);
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax);
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin, rptr{btVector3} aabbMax) const;
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart) const;
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
}
public threaded struct extern "::btStridingMeshInterfaceData" btStridingMeshInterfaceData {
  public rawarray{char, 4} m_padding;
  public btVector3FloatData m_scaling;
  public rptr{btMeshPartData} m_meshPartsPtr;
  public int m_numMeshParts;
}
public threaded struct extern "::btTransform" btTransform {
  public function extern "getOrigin" btVector3 mutable& getOrigin();
  public function extern "getOrigin" btVector3 const& cgetOrigin() const;
  public function extern "setIdentity" void setIdentity();
  public function extern "getRotation" btQuaternion getRotation() const;
  public function extern "setOrigin" void setOrigin(btVector3 const& origin);
  public function extern "invXform" btVector3 invXform(btVector3 const& inVec) const;
  public function extern "getBasis" btMatrix3x3 mutable& getBasis();
  public function extern "getBasis" btMatrix3x3 const& cgetBasis() const;
  public function extern "setRotation" void setRotation(btQuaternion const& q);
  public function extern "setFromOpenGLMatrix" void setFromOpenGLMatrix(crptr{btScalar} m);
  public function extern "deSerializeDouble" void deSerializeDouble(btTransformDoubleData const& dataIn);
  public function extern "getOpenGLMatrix" void getOpenGLMatrix(rptr{btScalar} m) const;
  public function extern "deSerialize" void deSerialize(btTransformFloatData const& dataIn);
  public function extern "deSerializeFloat" void deSerializeFloat(btTransformFloatData const& dataIn);
  public function extern "serializeFloat" void serializeFloat(btTransformFloatData mutable& dataOut) const;
  public function extern "inverseTimes" btTransform inverseTimes(btTransform const& t) const;
  public function extern "mult" void mult(btTransform const& t1, btTransform const& t2);
  public function extern "setBasis" void setBasis(btMatrix3x3 const& basis);
  public function extern "inverse" btTransform inverse() const;
  public function extern "serialize" void serialize(btTransformFloatData mutable& dataOut) const;
}
public threaded struct extern "::btTransformDoubleData" btTransformDoubleData {
  public btMatrix3x3DoubleData m_basis;
  public btVector3DoubleData m_origin;
}
public threaded struct extern "::btTransformFloatData" btTransformFloatData {
  public btMatrix3x3FloatData m_basis;
  public btVector3FloatData m_origin;
}
public threaded struct extern "::btTransformUtil" btTransformUtil {
}
public threaded struct extern "::btTranslationalLimitMotor" btTranslationalLimitMotor {
  public function extern "needApplyForce" bool needApplyForce(int limitIndex);
  public function extern "testLimitValue" int testLimitValue(int limitIndex, btScalar test_value);
  public function extern "solveLinearAxis" btScalar solveLinearAxis(btScalar timeStep, btScalar jacDiagABInv, btRigidBody mutable& body1, btVector3 const& pointInA, btRigidBody mutable& body2, btVector3 const& pointInB, int limit_index, btVector3 const& axis_normal_on_a, btVector3 const& anchorPos);
  public function extern "isLimited" bool isLimited(int limitIndex);
  public btVector3 m_upperLimit;
  public btVector3 m_normalCFM;
  public btVector3 m_lowerLimit;
  public btScalar m_limitSoftness;
  public btVector3 m_stopCFM;
  public rawarray{bool, 3} m_enableMotor;
  public btVector3 m_currentLinearDiff;
  public btVector3 m_maxMotorForce;
  public btVector3 m_currentLimitError;
  public rawarray{int, 3} m_currentLimit;
  public btVector3 m_accumulatedImpulse;
  public btVector3 m_targetVelocity;
  public btScalar m_damping;
  public btVector3 m_stopERP;
  public btScalar m_restitution;
}
public tsvaluetype struct extern "::btTraversalMode" "extenum" btTraversalMode { }
public extern "TRAVERSAL_STACKLESS" btTraversalMode TRAVERSAL_STACKLESS;
public extern "TRAVERSAL_STACKLESS_CACHE_FRIENDLY" btTraversalMode TRAVERSAL_STACKLESS_CACHE_FRIENDLY;
public extern "TRAVERSAL_RECURSIVE" btTraversalMode TRAVERSAL_RECURSIVE;
public threaded struct extern "::btTriangleCallback" "nonmovable" btTriangleCallback {
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle, int partId, int triangleIndex);
}
public threaded struct extern "::btTriangleIndexVertexArray" "nonmovable" btTriangleIndexVertexArray {
  public metafunction __base__ {btStridingMeshInterface};
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax);
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh, PHY_ScalarType indexType);
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling);
  public function extern "preallocateVertices" void preallocateVertices(int numverts);
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "preallocateIndices" void preallocateIndices(int numindices);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& vertexStride, rptr{crptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart);
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& vertexStride, rptr{rptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart);
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin, rptr{btVector3} aabbMax) const;
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart) const;
  public function extern "getIndexedMeshArray" IndexedMeshArray mutable& getIndexedMeshArray();
  public function extern "getIndexedMeshArray" IndexedMeshArray const& cgetIndexedMeshArray() const;
}
public threaded struct extern "::btTriangleInfo" btTriangleInfo {
  public int m_flags;
  public btScalar m_edgeV2V0Angle;
  public btScalar m_edgeV1V2Angle;
  public btScalar m_edgeV0V1Angle;
}
public threaded struct extern "::btTriangleInfoData" btTriangleInfoData {
  public int m_flags;
  public float m_edgeV2V0Angle;
  public float m_edgeV0V1Angle;
  public float m_edgeV1V2Angle;
}
public threaded struct extern "::btTriangleInfoMap" "nonmovable" btTriangleInfoMap {
  public metafunction __base__ {btHashMap_btHashInt_btTriangleInfo};
  public function extern "find" rptr{btTriangleInfo} find(btHashInt const& key);
  public function extern "find" crptr{btTriangleInfo} cfind(btHashInt const& key) const;
  public function extern "deSerialize" void deSerialize(btTriangleInfoMapData mutable& tmapData);
  public function extern "findIndex" int findIndex(btHashInt const& key) const;
  public function extern "insert" void insert(btHashInt const& key, btTriangleInfo const& value);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "clear" void clear();
  public function extern "getAtIndex" rptr{btTriangleInfo} getAtIndex(int index);
  public function extern "getAtIndex" crptr{btTriangleInfo} cgetAtIndex(int index) const;
  public function extern "remove" void remove(btHashInt const& key);
  public function extern "size" int size() const;
  public btScalar m_convexEpsilon;
  public btScalar m_planarEpsilon;
  public btScalar m_equalVertexThreshold;
  public btScalar m_maxEdgeAngleThreshold;
  public btScalar m_zeroAreaThreshold;
  public btScalar m_edgeDistanceThreshold;
}
public threaded struct extern "::btTriangleInfoMapData" btTriangleInfoMapData {
  public int m_nextSize;
  public int m_numValues;
  public int m_numKeys;
  public float m_zeroAreaThreshold;
  public float m_edgeDistanceThreshold;
  public rptr{int} m_hashTablePtr;
  public rptr{btTriangleInfoData} m_valueArrayPtr;
  public float m_convexEpsilon;
  public float m_planarEpsilon;
  public rptr{int} m_keyArrayPtr;
  public rptr{int} m_nextPtr;
  public float m_equalVertexThreshold;
  public rawarray{char, 4} m_padding;
  public int m_hashTableSize;
}
public threaded struct extern "::btTriangleMesh" "nodefault" btTriangleMesh(bool use32bitIndices, bool use4componentVertices)  {
  public metafunction __base__ {btTriangleIndexVertexArray, btStridingMeshInterface};
  public function extern "getIndexedMeshArray" IndexedMeshArray const& cgetIndexedMeshArray() const;
  public function extern "getIndexedMeshArray" IndexedMeshArray mutable& getIndexedMeshArray();
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart) const;
  public function extern "addTriangle" void addTriangle(btVector3 const& vertex0, btVector3 const& vertex1, btVector3 const& vertex2, bool removeDuplicateVertices);
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin, rptr{btVector3} aabbMax) const;
  public function extern "getUse32bitIndices" bool getUse32bitIndices() const;
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "findOrAddVertex" int findOrAddVertex(btVector3 const& vertex, bool removeDuplicateVertices);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& vertexStride, rptr{crptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart);
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& vertexStride, rptr{rptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart);
  public function extern "addIndex" void addIndex(int index);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "preallocateIndices" void preallocateIndices(int numindices);
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling);
  public function extern "preallocateVertices" void preallocateVertices(int numverts);
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh, PHY_ScalarType indexType);
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "getUse4componentVertices" bool getUse4componentVertices() const;
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax);
  public function extern "getNumTriangles" int getNumTriangles() const;
  public btScalar m_weldingThreshold;
}
public threaded struct extern "::btTriangleMeshShape" "nodefault" btTriangleMeshShape private()  {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
}
public threaded struct extern "::btTriangleMeshShapeData" btTriangleMeshShapeData {
  public rawarray{char, 4} m_pad3;
  public btStridingMeshInterfaceData m_meshInterface;
  public float m_collisionMargin;
  public rptr{btQuantizedBvhDoubleData} m_quantizedDoubleBvh;
  public btCollisionShapeData m_collisionShapeData;
  public rptr{btQuantizedBvhFloatData} m_quantizedFloatBvh;
  public rptr{btTriangleInfoMapData} m_triangleInfoMap;
}
public threaded struct extern "::btTypedConstraint" "nodefault" btTypedConstraint(btTypedConstraintType type, btRigidBody mutable& rbA)  {
  public metafunction __base__ {btTypedObject};
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "getUid" int getUid() const;
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "buildJacobian" void buildJacobian();
  public int m_objectType;
}
public threaded struct extern "::btTypedConstraintData" btTypedConstraintData {
  public int m_userConstraintId;
  public float m_breakingImpulseThreshold;
  public rptr{btRigidBodyFloatData} m_rbB;
  public int m_userConstraintType;
  public rptr{btRigidBodyFloatData} m_rbA;
  public int m_needsFeedback;
  public int m_isEnabled;
  public rptr{char} m_name;
  public int m_disableCollisionsBetweenLinkedBodies;
  public int m_objectType;
  public int m_overrideNumSolverIterations;
  public float m_appliedImpulse;
  public float m_dbgDrawSize;
}
public tsvaluetype struct extern "::btTypedConstraintType" "extenum" btTypedConstraintType { }
public extern "POINT2POINT_CONSTRAINT_TYPE" btTypedConstraintType POINT2POINT_CONSTRAINT_TYPE;
public extern "HINGE_CONSTRAINT_TYPE" btTypedConstraintType HINGE_CONSTRAINT_TYPE;
public extern "CONETWIST_CONSTRAINT_TYPE" btTypedConstraintType CONETWIST_CONSTRAINT_TYPE;
public extern "D6_CONSTRAINT_TYPE" btTypedConstraintType D6_CONSTRAINT_TYPE;
public extern "SLIDER_CONSTRAINT_TYPE" btTypedConstraintType SLIDER_CONSTRAINT_TYPE;
public extern "CONTACT_CONSTRAINT_TYPE" btTypedConstraintType CONTACT_CONSTRAINT_TYPE;
public extern "D6_SPRING_CONSTRAINT_TYPE" btTypedConstraintType D6_SPRING_CONSTRAINT_TYPE;
public extern "GEAR_CONSTRAINT_TYPE" btTypedConstraintType GEAR_CONSTRAINT_TYPE;
public extern "MAX_CONSTRAINT_TYPE" btTypedConstraintType MAX_CONSTRAINT_TYPE;
/* skip btTypedConstraint_34 : unnamed */
public threaded struct extern "::btTypedConstraint::btConstraintInfo1" btTypedConstraint_btConstraintInfo1 {
  public int m_numConstraintRows;
  public int nub;
}
public threaded struct extern "::btTypedConstraint::btConstraintInfo2" btTypedConstraint_btConstraintInfo2 {
  public btScalar fps;
  public rptr{btScalar} m_J1linearAxis;
  public btScalar erp;
  public int rowskip;
  public btScalar m_damping;
  public rptr{btScalar} m_lowerLimit;
  public rptr{btScalar} cfm;
  public rptr{btScalar} m_constraintError;
  public rptr{int} findex;
  public rptr{btScalar} m_upperLimit;
  public rptr{btScalar} m_J2linearAxis;
  public rptr{btScalar} m_J1angularAxis;
  public int m_numIterations;
  public rptr{btScalar} m_J2angularAxis;
}
public threaded struct extern "::btTypedObject" "nodefault" btTypedObject(int objectType)  {
  public function extern "getObjectType" int getObjectType() const;
  public int m_objectType;
}
public threaded struct extern "::btUniformScalingShape" "nodefault" btUniformScalingShape(rptr{btConvexShape} convexChildShape, btScalar uniformScalingFactor)  {
  public metafunction __base__ {btConvexShape, btCollisionShape};
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getChildShape" rptr{btConvexShape} getChildShape();
  public function extern "getChildShape" crptr{btConvexShape} cgetChildShape() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getUniformScalingFactor" btScalar getUniformScalingFactor() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
}
public threaded struct extern "::btUniversalConstraint" "nodefault" btUniversalConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& anchor, btVector3 const& axis1, btVector3 const& axis2)  {
  public metafunction __base__ {btGeneric6DofConstraint, btTypedConstraint, btTypedObject};
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index);
  public function extern "setLowerLimit" void setLowerLimit(btScalar ang1min, btScalar ang2min);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "getAngle1" btScalar getAngle1();
  public function extern "getAnchor2" btVector3 const& getAnchor2();
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getAxis1" btVector3 const& getAxis1();
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower);
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getAxis2" btVector3 const& getAxis2();
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower);
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getAnchor" btVector3 const& getAnchor();
  public function extern "getAxis" btVector3 getAxis(int axis_index) const;
  public function extern "isLimited" bool isLimited(int limitIndex);
  public function extern "getAngle2" btScalar getAngle2();
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "getUid" int getUid() const;
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index) const;
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA, btTransform const& transB);
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "setAxis" void setAxis(btVector3 const& axis1, btVector3 const& axis2);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper);
  public function extern "getAngle" btScalar getAngle(int axis_index) const;
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper);
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB, rptr{btTypedConstraint_btConstraintInfo2} info, int row, btVector3 mutable& ax1, int rotational, int rotAllowed);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper);
  public function extern "setLimit" void setLimit(int axis, btScalar lo, btScalar hi);
  public function extern "setUpperLimit" void setUpperLimit(btScalar ang1max, btScalar ang2max);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index);
  public int m_objectType;
  public bool m_useSolveConstraintObsolete;
}
public threaded struct extern "::btVector3" btVector3 {
  public function extern "deSerializeFloat" void deSerializeFloat(btVector3FloatData const& dataIn);
  public function extern "deSerialize" void deSerialize(btVector3FloatData const& dataIn);
  public function extern "deSerializeDouble" void deSerializeDouble(btVector3DoubleData const& dataIn);
  public function extern "rotate" btVector3 rotate(btVector3 const& wAxis, btScalar const _angle) const;
  public function extern "dot" btScalar dot(btVector3 const& v) const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "triple" btScalar triple(btVector3 const& v1, btVector3 const& v2) const;
  public function extern "setZero" void setZero();
  public function extern "lerp" btVector3 lerp(btVector3 const& v, btScalar const& t) const;
  public function extern "z" btScalar const& z() const;
  public function extern "setValue" void setValue(btScalar const& _x, btScalar const& _y, btScalar const& _z);
  public function extern "furthestAxis" int furthestAxis() const;
  public function extern "isZero" bool isZero() const;
  public function extern "dot3" btVector3 dot3(btVector3 const& v0, btVector3 const& v1, btVector3 const& v2) const;
  public function extern "x" btScalar const& x() const;
  public function extern "maxDot" long maxDot(crptr{btVector3} array, long array_count, btScalar mutable& dotOut) const;
  public function extern "angle" btScalar angle(btVector3 const& v) const;
  public function extern "setW" void setW(btScalar _w);
  public function extern "getY" btScalar const& getY() const;
  public function extern "maxAxis" int maxAxis() const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "length2" btScalar length2() const;
  public function extern "setX" void setX(btScalar _x);
  public function extern "setY" void setY(btScalar _y);
  public function extern "normalized" btVector3 normalized() const;
  public function extern "serialize" void serialize(btVector3FloatData mutable& dataOut) const;
  public function extern "length" btScalar length() const;
  public function extern "distance" btScalar distance(btVector3 const& v) const;
  public function extern "getSkewSymmetricMatrix" void getSkewSymmetricMatrix(rptr{btVector3} v0, rptr{btVector3} v1, rptr{btVector3} v2) const;
  public function extern "setMax" void setMax(btVector3 const& other);
  public function extern "closestAxis" int closestAxis() const;
  public function extern "cross" btVector3 cross(btVector3 const& v) const;
  public function extern "absolute" btVector3 absolute() const;
  public function extern "setInterpolate3" void setInterpolate3(btVector3 const& v0, btVector3 const& v1, btScalar rt);
  public function extern "setMin" void setMin(btVector3 const& other);
  public function extern "safeNormalize" btVector3 mutable& safeNormalize();
  public function extern "serializeDouble" void serializeDouble(btVector3DoubleData mutable& dataOut) const;
  public function extern "setZ" void setZ(btScalar _z);
  public function extern "distance2" btScalar distance2(btVector3 const& v) const;
  public function extern "minAxis" int minAxis() const;
  public function extern "y" btScalar const& y() const;
  public function extern "fuzzyZero" bool fuzzyZero() const;
  public function extern "w" btScalar const& w() const;
  public function extern "serializeFloat" void serializeFloat(btVector3FloatData mutable& dataOut) const;
  public function extern "minDot" long minDot(crptr{btVector3} array, long array_count, btScalar mutable& dotOut) const;
  public function extern "normalize" btVector3 mutable& normalize();
  public rawarray{btScalar, 4} m_floats;
}
public threaded struct extern "::btVector3DoubleData" btVector3DoubleData {
  public rawarray{double, 4} m_floats;
}
public threaded struct extern "::btVector3FloatData" btVector3FloatData {
  public rawarray{float, 4} m_floats;
}
public threaded struct extern "::btVector4" btVector4 {
  public metafunction __base__ {btVector3};
  public function extern "fuzzyZero" bool fuzzyZero() const;
  public function extern "y" btScalar const& y() const;
  public function extern "minAxis" int minAxis() const;
  public function extern "distance2" btScalar distance2(btVector3 const& v) const;
  public function extern "setZ" void setZ(btScalar _z);
  public function extern "serializeDouble" void serializeDouble(btVector3DoubleData mutable& dataOut) const;
  public function extern "setMin" void setMin(btVector3 const& other);
  public function extern "safeNormalize" btVector3 mutable& safeNormalize();
  public function extern "setInterpolate3" void setInterpolate3(btVector3 const& v0, btVector3 const& v1, btScalar rt);
  public function extern "absolute" btVector3 absolute() const;
  public function extern "normalize" btVector3 mutable& normalize();
  public function extern "minDot" long minDot(crptr{btVector3} array, long array_count, btScalar mutable& dotOut) const;
  public function extern "serializeFloat" void serializeFloat(btVector3FloatData mutable& dataOut) const;
  public function extern "w" btScalar const& w() const;
  public function extern "getSkewSymmetricMatrix" void getSkewSymmetricMatrix(rptr{btVector3} v0, rptr{btVector3} v1, rptr{btVector3} v2) const;
  public function extern "distance" btScalar distance(btVector3 const& v) const;
  public function extern "getW" btScalar getW() const;
  public function extern "length" btScalar length() const;
  public function extern "serialize" void serialize(btVector3FloatData mutable& dataOut) const;
  public function extern "absolute4" btVector4 absolute4() const;
  public function extern "cross" btVector3 cross(btVector3 const& v) const;
  public function extern "closestAxis" int closestAxis() const;
  public function extern "maxAxis4" int maxAxis4() const;
  public function extern "setMax" void setMax(btVector3 const& other);
  public function extern "maxAxis" int maxAxis() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "setW" void setW(btScalar _w);
  public function extern "angle" btScalar angle(btVector3 const& v) const;
  public function extern "maxDot" long maxDot(crptr{btVector3} array, long array_count, btScalar mutable& dotOut) const;
  public function extern "minAxis4" int minAxis4() const;
  public function extern "x" btScalar const& x() const;
  public function extern "normalized" btVector3 normalized() const;
  public function extern "setY" void setY(btScalar _y);
  public function extern "setX" void setX(btScalar _x);
  public function extern "closestAxis4" int closestAxis4() const;
  public function extern "length2" btScalar length2() const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "dot" btScalar dot(btVector3 const& v) const;
  public function extern "rotate" btVector3 rotate(btVector3 const& wAxis, btScalar const _angle) const;
  public function extern "deSerializeDouble" void deSerializeDouble(btVector3DoubleData const& dataIn);
  public function extern "deSerialize" void deSerialize(btVector3FloatData const& dataIn);
  public function extern "deSerializeFloat" void deSerializeFloat(btVector3FloatData const& dataIn);
  public function extern "dot3" btVector3 dot3(btVector3 const& v0, btVector3 const& v1, btVector3 const& v2) const;
  public function extern "isZero" bool isZero() const;
  public function extern "furthestAxis" int furthestAxis() const;
  public function extern "setValue" void setValue4(btScalar const& _x, btScalar const& _y, btScalar const& _z, btScalar const& _w);
  public function extern "setValue" void setValue3(btScalar const& _x, btScalar const& _y, btScalar const& _z);
  public function extern "z" btScalar const& z() const;
  public function extern "lerp" btVector3 lerp(btVector3 const& v, btScalar const& t) const;
  public function extern "setZero" void setZero();
  public function extern "triple" btScalar triple(btVector3 const& v1, btVector3 const& v2) const;
  public rawarray{btScalar, 4} m_floats;
}
public threaded struct extern "::btVehicleRaycaster" "nonmovable" btVehicleRaycaster {
  public function extern "castRay" rptr{void} castRay(btVector3 const& from, btVector3 const& to, btVehicleRaycaster_btVehicleRaycasterResult mutable& result);
}
public threaded struct extern "::btVehicleRaycaster::btVehicleRaycasterResult" btVehicleRaycaster_btVehicleRaycasterResult {
  public btScalar m_distFraction;
  public btVector3 m_hitPointInWorld;
  public btVector3 m_hitNormalInWorld;
}
public threaded struct extern "::btVehicleTuning" "nodefault" btVehicleTuning private()  {
}
public threaded struct extern "::btVoronoiSimplexSolver" "nodefault" btVoronoiSimplexSolver private()  {
}
public threaded struct extern "::btWheelInfo" "nodefault" btWheelInfo(btWheelInfoConstructionInfo mutable& ci)  {
  public function extern "updateWheel" void updateWheel(btRigidBody const& chassis, btWheelInfo_RaycastInfo mutable& raycastInfo);
  public function extern "getSuspensionRestLength" btScalar getSuspensionRestLength() const;
  public btScalar m_wheelsDampingRelaxation;
  public bool m_bIsFrontWheel;
  public btScalar m_suspensionStiffness;
  public btTransform m_worldTransform;
  public btScalar m_suspensionRelativeVelocity;
  public btScalar m_wheelsDampingCompression;
  public btScalar m_steering;
  public btScalar m_brake;
  public btScalar m_deltaRotation;
  public btScalar m_suspensionRestLength1;
  public btScalar m_skidInfo;
  public btScalar m_clippedInvContactDotSuspension;
  public rptr{void} m_clientInfo;
  public btScalar m_maxSuspensionForce;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_frictionSlip;
  public btVector3 m_wheelDirectionCS;
  public btVector3 m_chassisConnectionPointCS;
  public btScalar m_wheelsRadius;
  public btScalar m_rotation;
  public btScalar m_rollInfluence;
  public btVector3 m_wheelAxleCS;
  public btWheelInfo_RaycastInfo m_raycastInfo;
  public btScalar m_engineForce;
  public btScalar m_wheelsSuspensionForce;
}
public threaded struct extern "::btWheelInfoConstructionInfo" btWheelInfoConstructionInfo {
  public btScalar m_wheelRadius;
  public bool m_bIsFrontWheel;
  public btScalar m_wheelsDampingRelaxation;
  public btScalar m_suspensionStiffness;
  public btScalar m_wheelsDampingCompression;
  public btVector3 m_wheelAxleCS;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_maxSuspensionForce;
  public btScalar m_frictionSlip;
  public btScalar m_suspensionRestLength;
  public btVector3 m_wheelDirectionCS;
  public btVector3 m_chassisConnectionCS;
}
public threaded struct extern "::btWheelInfo::RaycastInfo" btWheelInfo_RaycastInfo {
  public btVector3 m_wheelDirectionWS;
  public bool m_isInContact;
  public btScalar m_suspensionLength;
  public btVector3 m_wheelAxleWS;
  public btVector3 m_hardPointWS;
  public btVector3 m_contactNormalWS;
  public btVector3 m_contactPointWS;
  public rptr{void} m_groundObject;
}
public metafunction size_type int;
public threaded function extern "::btRigidBody::btRigidBodyConstructionInfo" "nocdecl" btRigidBody_btRigidBodyConstructionInfo btRigidBody_btRigidBodyConstructionInfo4(btScalar mass, rptr{btMotionState} motionState, rptr{btCollisionShape} collisionShape, btVector3 const& localInertia);
public threaded function extern "::btQuantizedBvh::deSerializeInPlace" "nocdecl" rptr{btQuantizedBvh} btQuantizedBvh_deSerializeInPlace(rptr{void} i_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian);
public threaded function extern "::btAlignedFreeInternal" void btAlignedFreeInternal(rptr{void} ptr);
public threaded function extern "::btAlignedAllocSetCustom" void btAlignedAllocSetCustom(rptr{btAllocFunc} allocFunc, rptr{btFreeFunc} freeFunc);
public threaded function extern "::btIsNegative" int btIsNegative(btScalar x);
public threaded function extern "::btDefaultCollisionConfiguration" "nocdecl" btDefaultCollisionConfiguration btDefaultCollisionConfiguration1(btDefaultCollisionConstructionInfo const& constructionInfo);
public threaded function extern "::btFabs" btScalar btFabs(btScalar x);
public threaded function extern "::btCollisionWorld::AllHitsRayResultCallback" "nocdecl" btCollisionWorld_AllHitsRayResultCallback btCollisionWorld_AllHitsRayResultCallback2(btVector3 const& rayFromWorld, btVector3 const& rayToWorld);
public threaded function extern "::btCapsuleShape" "nocdecl" btCapsuleShape btCapsuleShape2(btScalar radius, btScalar height);
public threaded function extern "::btRigidBody" "nocdecl" btRigidBody btRigidBody4(btScalar mass, rptr{btMotionState} motionState, rptr{btCollisionShape} collisionShape, btVector3 const& localInertia);
public threaded function extern "::btRigidBody" "nocdecl" btRigidBody btRigidBody1(btRigidBody_btRigidBodyConstructionInfo const& constructionInfo);
public threaded function extern "::btFmod" btScalar btFmod(btScalar x, btScalar y);
public threaded function extern "::btMachineIsLittleEndian" bool btMachineIsLittleEndian();
public threaded function extern "::btGearConstraint" "nocdecl" btGearConstraint btGearConstraint5(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& axisInA, btVector3 const& axisInB, btScalar ratio);
public threaded function extern "::btUnSwapVector3Endian" void btUnSwapVector3Endian(btVector3 mutable& vector);
public threaded function extern "::btConeTwistConstraint" "nocdecl" btConeTwistConstraint btConeTwistConstraint2(btRigidBody mutable& rbA, btTransform const& rbAFrame);
public threaded function extern "::btConeTwistConstraint" "nocdecl" btConeTwistConstraint btConeTwistConstraint4(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& rbAFrame, btTransform const& rbBFrame);
public threaded function extern "::btTypedConstraint" "nocdecl" btTypedConstraint btTypedConstraint3(btTypedConstraintType type, btRigidBody mutable& rbA, btRigidBody mutable& rbB);
public threaded function extern "::btTypedConstraint" "nocdecl" btTypedConstraint btTypedConstraint2(btTypedConstraintType type, btRigidBody mutable& rbA);
public threaded function extern "::btBroadphaseProxy::isConcave" "nocdecl" bool btBroadphaseProxy_isConcave(int proxyType);
public threaded function extern "::btDbvt::sStkNN" "nocdecl" btDbvt_sStkNN btDbvt_sStkNN2(crptr{btDbvtNode} na, crptr{btDbvtNode} nb);
public threaded function extern "::btCollisionDispatcher::defaultNearCallback" "nocdecl" void btCollisionDispatcher_defaultNearCallback(btBroadphasePair mutable& collisionPair, btCollisionDispatcher mutable& dispatcher, btDispatcherInfo const& dispatchInfo);
public threaded function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion3(btScalar const& yaw, btScalar const& pitch, btScalar const& roll);
public threaded function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion2(btVector3 const& _axis, btScalar const& _angle);
public threaded function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion4(btScalar const& _x, btScalar const& _y, btScalar const& _z, btScalar const& _w);
public threaded function extern "::btTriangleIndexVertexArray" "nocdecl" btTriangleIndexVertexArray btTriangleIndexVertexArray6(int numTriangles, rptr{int} triangleIndexBase, int triangleIndexStride, int numVertices, rptr{btScalar} vertexBase, int vertexStride);
public threaded function extern "::btSimpleBroadphaseProxy" "nocdecl" btSimpleBroadphaseProxy btSimpleBroadphaseProxy7(btVector3 const& minpt, btVector3 const& maxpt, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{void} multiSapProxy);
public threaded function extern "::btDegrees" btScalar btDegrees(btScalar x);
public threaded function extern "::btCollisionWorld::LocalRayResult" "nocdecl" btCollisionWorld_LocalRayResult btCollisionWorld_LocalRayResult4(crptr{btCollisionObject} collisionObject, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo, btVector3 const& hitNormalLocal, btScalar hitFraction);
public threaded function extern "::btCylinderShapeX" "nocdecl" btCylinderShapeX btCylinderShapeX1(btVector3 const& halfExtents);
public threaded function extern "::btAtan2" btScalar btAtan2(btScalar x, btScalar y);
public threaded function extern "::btDbvt::extractLeaves" "nocdecl" void btDbvt_extractLeaves(crptr{btDbvtNode} node, btAlignedObjectArray_btDbvtNode_const_p mutable& leaves);
public threaded function extern "::btConvexTriangleMeshShape" "nocdecl" btConvexTriangleMeshShape btConvexTriangleMeshShape2(rptr{btStridingMeshInterface} meshInterface, bool calcAabb);
public threaded function extern "::btUniformScalingShape" "nocdecl" btUniformScalingShape btUniformScalingShape2(rptr{btConvexShape} convexChildShape, btScalar uniformScalingFactor);
public threaded function extern "::btDbvt::collideOCL" "nocdecl" void btDbvt_collideOCL(crptr{btDbvtNode} root, crptr{btVector3} normals, crptr{btScalar} offsets, btVector3 const& sortaxis, int count, btDbvt_ICollide mutable& policy, bool fsort);
public threaded function extern "::btPow" btScalar btPow(btScalar x, btScalar y);
public threaded function extern "::btDbvt::enumLeaves" "nocdecl" void btDbvt_enumLeaves(crptr{btDbvtNode} root, btDbvt_ICollide mutable& policy);
public threaded function extern "::btAlignedAllocInternal" rptr{void} btAlignedAllocInternal(size_t size, int alignment);
public threaded function extern "::btGeneric6DofConstraint" "nocdecl" btGeneric6DofConstraint btGeneric6DofConstraint5(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA);
public threaded function extern "::btGeneric6DofConstraint" "nocdecl" btGeneric6DofConstraint btGeneric6DofConstraint3(btRigidBody mutable& rbB, btTransform const& frameInB, bool useLinearReferenceFrameB);
public threaded function extern "::btSin" btScalar btSin(btScalar x);
public threaded function extern "::btActivatingCollisionAlgorithm" "nocdecl" btActivatingCollisionAlgorithm btActivatingCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci);
public threaded function extern "::btActivatingCollisionAlgorithm" "nocdecl" btActivatingCollisionAlgorithm btActivatingCollisionAlgorithm3(btCollisionAlgorithmConstructionInfo const& ci, crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap);
public threaded function extern "::btSelect" int btSelect_uint_int_int(uint condition, int valueIfConditionNonZero, int valueIfConditionZero);
public threaded function extern "::btSelect" uint btSelect_uint_uint_uint(uint condition, uint valueIfConditionNonZero, uint valueIfConditionZero);
public threaded function extern "::btSelect" float btSelect_uint_float_float(uint condition, float valueIfConditionNonZero, float valueIfConditionZero);
public threaded function extern "::btRayAabb" bool btRayAabb(btVector3 const& rayFrom, btVector3 const& rayTo, btVector3 const& aabbMin, btVector3 const& aabbMax, btScalar mutable& param, btVector3 mutable& normal);
public threaded function extern "::btMultiSphereShape" "nocdecl" btMultiSphereShape btMultiSphereShape3(crptr{btVector3} positions, crptr{btScalar} radi, int numSpheres);
public threaded function extern "::btCollisionWorld::objectQuerySingleInternal" "nocdecl" void btCollisionWorld_objectQuerySingleInternal(crptr{btConvexShape} castShape, btTransform const& convexFromTrans, btTransform const& convexToTrans, crptr{btCollisionObjectWrapper} colObjWrap, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedPenetration);
public threaded function extern "::btQuantizedBvh::getAlignmentSerializationPadding" "nocdecl" uint btQuantizedBvh_getAlignmentSerializationPadding();
public threaded function extern "::btAcos" btScalar btAcos(btScalar x);
public threaded function extern "::btCollisionWorld::ClosestRayResultCallback" "nocdecl" btCollisionWorld_ClosestRayResultCallback btCollisionWorld_ClosestRayResultCallback2(btVector3 const& rayFromWorld, btVector3 const& rayToWorld);
public threaded function extern "::btBroadphaseProxy::isConvex2d" "nocdecl" bool btBroadphaseProxy_isConvex2d(int proxyType);
public threaded function extern "::btDistance" btScalar btDistance(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btBroadphaseProxy::isPolyhedral" "nocdecl" bool btBroadphaseProxy_isPolyhedral(int proxyType);
public threaded function extern "::btDot" btScalar btDot(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btCollisionAlgorithmConstructionInfo" "nocdecl" btCollisionAlgorithmConstructionInfo btCollisionAlgorithmConstructionInfo2(rptr{btDispatcher} dispatcher, int temp);
public threaded function extern "::btTypedObject" "nocdecl" btTypedObject btTypedObject1(int objectType);
public threaded function extern "::btSqrt" btScalar btSqrt(btScalar y);
public threaded function extern "::btGetVersion" int btGetVersion();
public threaded function extern "::btAdjustAngleToLimits" btScalar btAdjustAngleToLimits(btScalar angleInRadians, btScalar angleLowerLimitInRadians, btScalar angleUpperLimitInRadians);
public threaded function extern "::btDbvt::maxdepth" "nocdecl" int btDbvt_maxdepth(crptr{btDbvtNode} node);
public threaded function extern "::btDbvtBroadphase::benchmark" "nocdecl" void btDbvtBroadphase_benchmark(rptr{btBroadphaseInterface} _0);
public threaded function extern "::btAtan2Fast" btScalar btAtan2Fast(btScalar y, btScalar x);
public threaded function extern "::btSwapScalarEndian" void btSwapScalarEndian(btScalar const& sourceVal, btScalar mutable& destVal);
public threaded function extern "::btDefaultSerializer" "nocdecl" btDefaultSerializer btDefaultSerializer1(int totalSize);
public threaded function extern "::btCos" btScalar btCos(btScalar x);
public threaded function extern "::btDistance2" btScalar btDistance2(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btDefaultVehicleRaycaster" "nocdecl" btDefaultVehicleRaycaster btDefaultVehicleRaycaster1(rptr{btDynamicsWorld} world);
public threaded function extern "::btTransform" "nocdecl" btTransform btTransform_btQuaternion_btVector3(btQuaternion const& q, btVector3 const& c);
public threaded function extern "::btTransform" "nocdecl" btTransform btTransform_btMatrix3x3_btVector3(btMatrix3x3 const& b, btVector3 const& c);
public threaded function extern "::btStaticPlaneShape" "nocdecl" btStaticPlaneShape btStaticPlaneShape2(btVector3 const& planeNormal, btScalar planeConstant);
public threaded function extern "::btOutcode" int btOutcode(btVector3 const& p, btVector3 const& halfExtent);
public threaded function extern "::btDiscreteDynamicsWorld" "nocdecl" btDiscreteDynamicsWorld btDiscreteDynamicsWorld4(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} pairCache, rptr{btConstraintSolver} constraintSolver, rptr{btCollisionConfiguration} collisionConfiguration);
public threaded function extern "::btLog" btScalar btLog(btScalar x);
public threaded function extern "::btConeShape" "nocdecl" btConeShape btConeShape2(btScalar radius, btScalar height);
public threaded function extern "::btUnswapEndianFloat" float btUnswapEndianFloat(uint a);
public threaded function extern "::btBoxShape" "nocdecl" btBoxShape btBoxShape1(btVector3 const& boxHalfExtents);
public threaded function extern "::btOptimizedBvh::deSerializeInPlace" "nocdecl" rptr{btOptimizedBvh} btOptimizedBvh_deSerializeInPlace(rptr{void} i_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian);
public threaded function extern "::btWheelInfo" "nocdecl" btWheelInfo btWheelInfo1(btWheelInfoConstructionInfo mutable& ci);
public threaded function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_1(btVector3 const& pt0);
public threaded function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_2(btVector3 const& pt0, btVector3 const& pt1);
public threaded function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_3(btVector3 const& pt0, btVector3 const& pt1, btVector3 const& pt2);
public threaded function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_4(btVector3 const& pt0, btVector3 const& pt1, btVector3 const& pt2, btVector3 const& pt3);
public threaded function extern "::btCollisionWorld::ClosestConvexResultCallback" "nocdecl" btCollisionWorld_ClosestConvexResultCallback btCollisionWorld_ClosestConvexResultCallback2(btVector3 const& convexFromWorld, btVector3 const& convexToWorld);
public threaded function extern "::btDbvtAabbMm::FromCE" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromCE(btVector3 const& c, btVector3 const& e);
public threaded function extern "::btTransformUtil::integrateTransform" "nocdecl" void btTransformUtil_integrateTransform(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btTransform mutable& predictedTransform);
public threaded function extern "::btSimpleBroadphase" "nocdecl" btSimpleBroadphase btSimpleBroadphase2(int maxProxies, rptr{btOverlappingPairCache} overlappingPairCache);
public threaded function extern "::btVector3" "nocdecl" btVector3 btVector3_3(btScalar const& _x, btScalar const& _y, btScalar const& _z);
public threaded function extern "::btDbvt::rayTest" "nocdecl" void btDbvt_rayTest(crptr{btDbvtNode} root, btVector3 const& rayFrom, btVector3 const& rayTo, btDbvt_ICollide mutable& policy);
public threaded function extern "::btDbvt::collideTU" "nocdecl" void btDbvt_collideTU(crptr{btDbvtNode} root, btDbvt_ICollide mutable& policy);
public threaded function extern "::btSimpleDynamicsWorld" "nocdecl" btSimpleDynamicsWorld btSimpleDynamicsWorld4(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} pairCache, rptr{btConstraintSolver} constraintSolver, rptr{btCollisionConfiguration} collisionConfiguration);
public threaded function extern "::btManifoldResult::calculateCombinedRestitution" "nocdecl" btScalar btManifoldResult_calculateCombinedRestitution(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
public threaded function extern "::btRadians" btScalar btRadians(btScalar x);
public threaded function extern "::btBroadphaseProxy::isNonMoving" "nocdecl" bool btBroadphaseProxy_isNonMoving(int proxyType);
public threaded function extern "::btTransformUtil::calculateDiffAxisAngle" "nocdecl" void btTransformUtil_calculateDiffAxisAngle(btTransform const& transform0, btTransform const& transform1, btVector3 mutable& axis, btScalar mutable& angle);
public threaded function extern "::btCylinderShapeZ" "nocdecl" btCylinderShapeZ btCylinderShapeZ1(btVector3 const& halfExtents);
public threaded function extern "::btDbvtAabbMm::FromMM" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromMM(btVector3 const& mi, btVector3 const& mx);
public threaded function extern "::btFuzzyZero" bool btFuzzyZero(btScalar x);
public threaded function extern "::btEqual" bool btEqual(btScalar a, btScalar eps);
public threaded function extern "::btAngle" btScalar btAngle_btVector3_btVector3(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btAngle" btScalar btAngle_btQuaternion_btQuaternion(btQuaternion const& q1, btQuaternion const& q2);
public threaded function extern "::btTriple" btScalar btTriple(btVector3 const& v1, btVector3 const& v2, btVector3 const& v3);
public threaded function extern "::btCollisionWorld::LocalConvexResult" "nocdecl" btCollisionWorld_LocalConvexResult btCollisionWorld_LocalConvexResult5(crptr{btCollisionObject} hitCollisionObject, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo, btVector3 const& hitNormalLocal, btVector3 const& hitPointLocal, btScalar hitFraction);
public threaded function extern "::btDbvtAabbMm::FromPoints" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromPoints_btVector3_cp_int(crptr{btVector3} pts, int n);
public threaded function extern "::btDbvtAabbMm::FromPoints" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromPoints_btVector3_cp_p_int(rptr{crptr{btVector3}} ppts, int n);
public threaded function extern "::btDbvtAabbMm::FromCR" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromCR(btVector3 const& c, btScalar r);
public threaded function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry6(btMatrix3x3 const& world2A, btVector3 const& rel_pos1, btVector3 const& rel_pos2, btVector3 const& jointAxis, btVector3 const& inertiaInvA, btScalar const massInvA);
public threaded function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry9(btMatrix3x3 const& world2A, btMatrix3x3 const& world2B, btVector3 const& rel_pos1, btVector3 const& rel_pos2, btVector3 const& jointAxis, btVector3 const& inertiaInvA, btScalar const massInvA, btVector3 const& inertiaInvB, btScalar const massInvB);
public threaded function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry5(btVector3 const& jointAxis, btMatrix3x3 const& world2A, btMatrix3x3 const& world2B, btVector3 const& inertiaInvA, btVector3 const& inertiaInvB);
public threaded function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry4(btVector3 const& axisInA, btVector3 const& axisInB, btVector3 const& inertiaInvA, btVector3 const& inertiaInvB);
public threaded function extern "::btTypedConstraint::getFixedBody" "nocdecl" btRigidBody mutable& btTypedConstraint_getFixedBody();
public threaded function extern "::btGeneric6DofSpringConstraint" "nocdecl" btGeneric6DofSpringConstraint btGeneric6DofSpringConstraint3(btRigidBody mutable& rbB, btTransform const& frameInB, bool useLinearReferenceFrameB);
public threaded function extern "::btGeneric6DofSpringConstraint" "nocdecl" btGeneric6DofSpringConstraint btGeneric6DofSpringConstraint5(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA);
public threaded function extern "::btCylinderShape" "nocdecl" btCylinderShape btCylinderShape1(btVector3 const& halfExtents);
public threaded function extern "::btDbvt::enumNodes" "nocdecl" void btDbvt_enumNodes(crptr{btDbvtNode} root, btDbvt_ICollide mutable& policy);
public threaded function extern "::btHashInt" "nocdecl" btHashInt btHashInt1(int uid);
public threaded function extern "::btCross" btVector3 btCross(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btHashPtr" "nocdecl" btHashPtr btHashPtr1(crptr{void} ptr);
public threaded function extern "::btUnswapEndianDouble" double btUnswapEndianDouble(crptr{uchar} src);
public threaded function extern "::btBroadphaseProxy::isConvex" "nocdecl" bool btBroadphaseProxy_isConvex(int proxyType);
public threaded function extern "::btUniversalConstraint" "nocdecl" btUniversalConstraint btUniversalConstraint5(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& anchor, btVector3 const& axis1, btVector3 const& axis2);
public threaded function extern "::btGreaterEqual" bool btGreaterEqual(btScalar a, btScalar eps);
public threaded function extern "::btExp" btScalar btExp(btScalar x);
public threaded function extern "::btCollisionObjectWrapper" "nocdecl" btCollisionObjectWrapper btCollisionObjectWrapper4(crptr{btCollisionObjectWrapper} parent, crptr{btCollisionShape} shape, crptr{btCollisionObject} collisionObject, btTransform const& worldTransform);
public threaded function extern "::btManifoldResult::calculateCombinedFriction" "nocdecl" btScalar btManifoldResult_calculateCombinedFriction(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
public threaded function extern "::btScaledBvhTriangleMeshShape" "nocdecl" btScaledBvhTriangleMeshShape btScaledBvhTriangleMeshShape2(rptr{btBvhTriangleMeshShape} childShape, btVector3 const& localScaling);
public threaded function extern "::btRaycastVehicle" "nocdecl" btRaycastVehicle btRaycastVehicle3(btRaycastVehicle_btVehicleTuning const& tuning, rptr{btRigidBody} chassis, rptr{btVehicleRaycaster} raycaster);
public threaded function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint5(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& rbAFrame, btTransform const& rbBFrame, bool useReferenceFrameA);
public threaded function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint7(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& pivotInA, btVector3 const& pivotInB, btVector3 const& axisInA, btVector3 const& axisInB, bool useReferenceFrameA);
public threaded function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint4(btRigidBody mutable& rbA, btVector3 const& pivotInA, btVector3 const& axisInA, bool useReferenceFrameA);
public threaded function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint3(btRigidBody mutable& rbA, btTransform const& rbAFrame, bool useReferenceFrameA);
public threaded function extern "::btTransformUtil::calculateVelocityQuaternion" "nocdecl" void btTransformUtil_calculateVelocityQuaternion(btVector3 const& pos0, btVector3 const& pos1, btQuaternion const& orn0, btQuaternion const& orn1, btScalar timeStep, btVector3 mutable& linVel, btVector3 mutable& angVel);
public threaded function extern "::btDbvt::sStkNPS" "nocdecl" btDbvt_sStkNPS btDbvt_sStkNPS3(crptr{btDbvtNode} n, uint m, btScalar v);
public threaded function extern "::btBroadphaseProxy::isSoftBody" "nocdecl" bool btBroadphaseProxy_isSoftBody(int proxyType);
public threaded function extern "::btSphereSphereCollisionAlgorithm" "nocdecl" btSphereSphereCollisionAlgorithm btSphereSphereCollisionAlgorithm4(rptr{btPersistentManifold} mf, btCollisionAlgorithmConstructionInfo const& ci, crptr{btCollisionObjectWrapper} col0Wrap, crptr{btCollisionObjectWrapper} col1Wrap);
public threaded function extern "::btSphereSphereCollisionAlgorithm" "nocdecl" btSphereSphereCollisionAlgorithm btSphereSphereCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci);
public threaded function extern "::btCollisionWorld::rayTestSingle" "nocdecl" void btCollisionWorld_rayTestSingle(btTransform const& rayFromTrans, btTransform const& rayToTrans, rptr{btCollisionObject} collisionObject, crptr{btCollisionShape} collisionShape, btTransform const& colObjWorldTransform, btCollisionWorld_RayResultCallback mutable& resultCallback);
public threaded function extern "::btCapsuleShapeZ" "nocdecl" btCapsuleShapeZ btCapsuleShapeZ2(btScalar radius, btScalar height);
public threaded function extern "::btBroadphaseProxy" "nocdecl" btBroadphaseProxy btBroadphaseProxy6(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{void} multiSapParentProxy);
public threaded function extern "::btDefaultMotionState" "nocdecl" btDefaultMotionState btDefaultMotionState2(btTransform const& startTrans, btTransform const& centerOfMassOffset);
public threaded function extern "::btDbvtProxy" "nocdecl" btDbvtProxy btDbvtProxy5(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask);
public threaded function extern "::btSwapVector3Endian" void btSwapVector3Endian(btVector3 const& sourceVec, btVector3 mutable& destVec);
public threaded function extern "::btFsel" btScalar btFsel(btScalar a, btScalar b, btScalar c);
public threaded function extern "::btCollisionWorld::rayTestSingleInternal" "nocdecl" void btCollisionWorld_rayTestSingleInternal(btTransform const& rayFromTrans, btTransform const& rayToTrans, crptr{btCollisionObjectWrapper} collisionObjectWrap, btCollisionWorld_RayResultCallback mutable& resultCallback);
public threaded function extern "::btTriangleMesh" "nocdecl" btTriangleMesh btTriangleMesh2(bool use32bitIndices, bool use4componentVertices);
public threaded function extern "::btManifoldResult" "nocdecl" btManifoldResult btManifoldResult2(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap);
public threaded function extern "::btConvexHullShape" "nocdecl" btConvexHullShape btConvexHullShape3(crptr{btScalar} points, int numPoints, int stride);
public threaded function extern "::btConvexSeparatingDistanceUtil" "nocdecl" btConvexSeparatingDistanceUtil btConvexSeparatingDistanceUtil2(btScalar boundingRadiusA, btScalar boundingRadiusB);
public threaded function extern "::btCollisionWorld" "nocdecl" btCollisionWorld btCollisionWorld3(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} broadphasePairCache, rptr{btCollisionConfiguration} collisionConfiguration);
public threaded function extern "::btSwapEndianFloat" uint btSwapEndianFloat(float d);
public threaded function extern "::btCollisionAlgorithm" "nocdecl" btCollisionAlgorithm btCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci);
public threaded function extern "::btAtan" btScalar btAtan(btScalar x);
public threaded function extern "::btDbvt::benchmark" "nocdecl" void btDbvt_benchmark();
public threaded function extern "::btAabbSupport" btVector3 btAabbSupport(btVector3 const& halfExtents, btVector3 const& supportDir);
public threaded function extern "::btMatrix3x3::getIdentity" "nocdecl" btMatrix3x3 const& btMatrix3x3_getIdentity();
public threaded function extern "::btDynamicsWorld" "nocdecl" btDynamicsWorld btDynamicsWorld3(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} broadphase, rptr{btCollisionConfiguration} collisionConfiguration);
public threaded function extern "::btDbvt::allocate" "nocdecl" int btDbvt_allocate(btAlignedObjectArray_int mutable& ifree, btAlignedObjectArray_btDbvt_sStkNPS mutable& stock, btDbvt_sStkNPS const& value);
public threaded function extern "::btMultiSapBroadphase" "nocdecl" btMultiSapBroadphase btMultiSapBroadphase2(int maxProxies, rptr{btOverlappingPairCache} pairCache);
public threaded function extern "::btTan" btScalar btTan(btScalar x);
public threaded function extern "::btMultiSapBroadphase::btMultiSapProxy" "nocdecl" btMultiSapBroadphase_btMultiSapProxy btMultiSapBroadphase_btMultiSapProxy6(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask);
public threaded function extern "::btCompoundShape" "nocdecl" btCompoundShape btCompoundShape1(bool enableDynamicAabbTree);
public threaded function extern "::btMatrix3x3" "nocdecl" btMatrix3x3 btMatrix3x3_1(btQuaternion const& q);
public threaded function extern "::btMatrix3x3" "nocdecl" btMatrix3x3 btMatrix3x3_9(btScalar const& xx, btScalar const& xy, btScalar const& xz, btScalar const& yx, btScalar const& yy, btScalar const& yz, btScalar const& zx, btScalar const& zy, btScalar const& zz);
public threaded function extern "::btManifoldPoint" "nocdecl" btManifoldPoint btManifoldPoint4(btVector3 const& pointA, btVector3 const& pointB, btVector3 const& normal, btScalar distance);
public threaded function extern "::btCollisionWorld::objectQuerySingle" "nocdecl" void btCollisionWorld_objectQuerySingle(crptr{btConvexShape} castShape, btTransform const& rayFromTrans, btTransform const& rayToTrans, rptr{btCollisionObject} collisionObject, crptr{btCollisionShape} collisionShape, btTransform const& colObjWorldTransform, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedPenetration);
public threaded function extern "::btHinge2Constraint" "nocdecl" btHinge2Constraint btHinge2Constraint5(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 mutable& anchor, btVector3 mutable& axis1, btVector3 mutable& axis2);
public threaded function extern "::btDbvtBroadphase" "nocdecl" btDbvtBroadphase btDbvtBroadphase1(rptr{btOverlappingPairCache} paircache);
public threaded function extern "::btDbvt::countLeaves" "nocdecl" int btDbvt_countLeaves(crptr{btDbvtNode} node);
public threaded function extern "::btDbvt::collideKDOP" "nocdecl" void btDbvt_collideKDOP(crptr{btDbvtNode} root, crptr{btVector3} normals, crptr{btScalar} offsets, int count, btDbvt_ICollide mutable& policy);
public threaded function extern "::btConeShapeX" "nocdecl" btConeShapeX btConeShapeX2(btScalar radius, btScalar height);
public threaded function extern "::btVector4" "nocdecl" btVector4 btVector4_4(btScalar const& _x, btScalar const& _y, btScalar const& _z, btScalar const& _w);
public threaded function extern "::btAxisSweep3Internal<unsigned short>" "nocdecl" btAxisSweep3Internal_unsigned_short btAxisSweep3Internal_unsigned_short7(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, ushort handleMask, ushort handleSentinel, ushort userMaxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator);
public threaded function extern "::btCapsuleShapeX" "nocdecl" btCapsuleShapeX btCapsuleShapeX2(btScalar radius, btScalar height);
public threaded function extern "::btNormalizeAngle" btScalar btNormalizeAngle(btScalar angleInRadians);
public threaded function extern "::btRigidBody::upcast" "nocdecl" crptr{btRigidBody} btRigidBody_upcast_btCollisionObject_cp(crptr{btCollisionObject} colObj);
public threaded function extern "::btRigidBody::upcast" "nocdecl" rptr{btRigidBody} btRigidBody_upcast_btCollisionObject_p(rptr{btCollisionObject} colObj);
public threaded function extern "::btDbvt::sStkCLN" "nocdecl" btDbvt_sStkCLN btDbvt_sStkCLN2(crptr{btDbvtNode} n, rptr{btDbvtNode} p);
public threaded function extern "::btStrLen" int btStrLen(crptr{char} str);
public threaded function extern "::btHashString" "nocdecl" btHashString btHashString1(crptr{char} name);
public threaded function extern "::btDbvt::nearest" "nocdecl" int btDbvt_nearest(crptr{int} i, crptr{btDbvt_sStkNPS} a, btScalar v, int l, int h);
public threaded function extern "::btTransformUtil::calculateVelocity" "nocdecl" void btTransformUtil_calculateVelocity(btTransform const& transform0, btTransform const& transform1, btScalar timeStep, btVector3 mutable& linVel, btVector3 mutable& angVel);
public threaded function extern "::btConeShapeZ" "nocdecl" btConeShapeZ btConeShapeZ2(btScalar radius, btScalar height);
public threaded function extern "::btPoint2PointConstraint" "nocdecl" btPoint2PointConstraint btPoint2PointConstraint2(btRigidBody mutable& rbA, btVector3 const& pivotInA);
public threaded function extern "::btPoint2PointConstraint" "nocdecl" btPoint2PointConstraint btPoint2PointConstraint4(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& pivotInA, btVector3 const& pivotInB);
public threaded function extern "::btBroadphasePair" "nocdecl" btBroadphasePair btBroadphasePair2(btBroadphaseProxy mutable& proxy0, btBroadphaseProxy mutable& proxy1);
public threaded function extern "::btTransformUtil::calculateDiffAxisAngleQuaternion" "nocdecl" void btTransformUtil_calculateDiffAxisAngleQuaternion(btQuaternion const& orn0, btQuaternion const& orn1a, btVector3 mutable& axis, btScalar mutable& angle);
public threaded function extern "::btStackAlloc" "nocdecl" btStackAlloc btStackAlloc1(uint size);
public threaded function extern "::btSliderConstraint" "nocdecl" btSliderConstraint btSliderConstraint3(btRigidBody mutable& rbB, btTransform const& frameInB, bool useLinearReferenceFrameA);
public threaded function extern "::btSliderConstraint" "nocdecl" btSliderConstraint btSliderConstraint5(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA);
public threaded function extern "::btBroadphaseProxy::isInfinite" "nocdecl" bool btBroadphaseProxy_isInfinite(int proxyType);
public threaded function extern "::btTransform::getIdentity" "nocdecl" btTransform const& btTransform_getIdentity();
public threaded function extern "::btAsin" btScalar btAsin(btScalar x);
public threaded function extern "::btCollisionDispatcher" "nocdecl" btCollisionDispatcher btCollisionDispatcher1(rptr{btCollisionConfiguration} collisionConfiguration);
public threaded function extern "::btAxisSweep3Internal<unsigned int>" "nocdecl" btAxisSweep3Internal_unsigned_int btAxisSweep3Internal_unsigned_int7(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, uint handleMask, uint handleSentinel, uint userMaxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator);
public threaded function extern "::btSwapEndian" uint btSwapEndian_int(int val);
public threaded function extern "::btSwapEndian" uint btSwapEndian_uint(uint val);
public threaded function extern "::btSwapEndian" ushort btSwapEndian_short(short val);
public threaded function extern "::btSwapEndian" ushort btSwapEndian_ushort(ushort val);
public threaded function extern "::btQuadWord" "nocdecl" btQuadWord btQuadWord4(btScalar const& _x, btScalar const& _y, btScalar const& _z, btScalar const& _w);
public threaded function extern "::btQuadWord" "nocdecl" btQuadWord btQuadWord3(btScalar const& _x, btScalar const& _y, btScalar const& _z);
public threaded function extern "::btQuaternion::getIdentity" "nocdecl" btQuaternion const& btQuaternion_getIdentity();
public threaded function extern "::btTransformAabb" void btTransformAabb6(btVector3 const& localAabbMin, btVector3 const& localAabbMax, btScalar margin, btTransform const& trans, btVector3 mutable& aabbMinOut, btVector3 mutable& aabbMaxOut);
public threaded function extern "::btTransformAabb" void btTransformAabb5(btVector3 const& halfExtents, btScalar margin, btTransform const& t, btVector3 mutable& aabbMinOut, btVector3 mutable& aabbMaxOut);
public threaded function extern "::btPersistentManifold" "nocdecl" btPersistentManifold btPersistentManifold5(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1, int _2, btScalar contactBreakingThreshold, btScalar contactProcessingThreshold);
public threaded function extern "::btSwapEndianDouble" void btSwapEndianDouble(double d, rptr{uchar} dst);
public threaded function extern "::btSphereShape" "nocdecl" btSphereShape btSphereShape1(btScalar radius);
public threaded function extern "::btAlignedAllocSetCustomAligned" void btAlignedAllocSetCustomAligned(rptr{btAlignedAllocFunc} allocFunc, rptr{btAlignedFreeFunc} freeFunc);
public threaded function extern "::btAxisSweep3" "nocdecl" btAxisSweep3 btAxisSweep3_5(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, ushort maxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator);
public threaded function extern "::btDbvt::sStkNP" "nocdecl" btDbvt_sStkNP btDbvt_sStkNP2(crptr{btDbvtNode} n, uint m);
public threaded function extern "::btRayAabb2" bool btRayAabb2(btVector3 const& rayFrom, btVector3 const& rayInvDirection, crptr{uint} raySign, crptr{btVector3} bounds, btScalar mutable& tmin, btScalar lambda_min, btScalar lambda_max);
public threaded function extern "::btBroadphaseProxy::isCompound" "nocdecl" bool btBroadphaseProxy_isCompound(int proxyType);
public threaded function extern "::btBvhTriangleMeshShape" "nocdecl" btBvhTriangleMeshShape btBvhTriangleMeshShape3(rptr{btStridingMeshInterface} meshInterface, bool useQuantizedAabbCompression, bool buildBvh);
public threaded function extern "::btBvhTriangleMeshShape" "nocdecl" btBvhTriangleMeshShape btBvhTriangleMeshShape5(rptr{btStridingMeshInterface} meshInterface, bool useQuantizedAabbCompression, btVector3 const& bvhAabbMin, btVector3 const& bvhAabbMax, bool buildBvh);
public threaded function extern "::btSimpleBroadphase::aabbOverlap" "nocdecl" bool btSimpleBroadphase_aabbOverlap(rptr{btSimpleBroadphaseProxy} proxy0, rptr{btSimpleBroadphaseProxy} proxy1);
public threaded function extern "::bt32BitAxisSweep3" "nocdecl" bt32BitAxisSweep3 bt32BitAxisSweep3_5(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, uint maxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator);
private metafunction bt32BitAxisSweep3_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{bt32BitAxisSweep3, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{bt32BitAxisSweep3, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
bt32BitAxisSweep3_getOverlappingPairCache__rt{tis}
bt32BitAxisSweep3_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btAlignedObjectArray_btActionInterface_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btActionInterface_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btActionInterface_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btActionInterface_p_at__rt{tis}
btAlignedObjectArray_btActionInterface_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBroadphaseInterface_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphaseInterface_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphaseInterface_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btBroadphaseInterface_p_at__rt{tis}
btAlignedObjectArray_btBroadphaseInterface_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBroadphasePair_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphasePair, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphasePair, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btBroadphasePair_at__rt{tis}
btAlignedObjectArray_btBroadphasePair_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBvhSubtreeInfo_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBvhSubtreeInfo, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBvhSubtreeInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btBvhSubtreeInfo_at__rt{tis}
btAlignedObjectArray_btBvhSubtreeInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btChunk_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btChunk_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btChunk_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btChunk_p_at__rt{tis}
btAlignedObjectArray_btChunk_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionObject_const_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_const_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_const_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btCollisionObject_const_p_at__rt{tis}
btAlignedObjectArray_btCollisionObject_const_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionObject_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btCollisionObject_p_at__rt{tis}
btAlignedObjectArray_btCollisionObject_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCompoundShapeChild_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCompoundShapeChild, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCompoundShapeChild, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btCompoundShapeChild_at__rt{tis}
btAlignedObjectArray_btCompoundShapeChild_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvtNode_const_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvtNode_const_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvtNode_const_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btDbvtNode_const_p_at__rt{tis}
btAlignedObjectArray_btDbvtNode_const_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNN_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNN, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNN, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btDbvt_sStkNN_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNN_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNP_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNP, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNP, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btDbvt_sStkNP_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNP_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNPS_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNPS, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNPS, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btDbvt_sStkNPS_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNPS_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashInt_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashInt, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashInt, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btHashInt_at__rt{tis}
btAlignedObjectArray_btHashInt_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashPtr_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashPtr, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashPtr, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btHashPtr_at__rt{tis}
btAlignedObjectArray_btHashPtr_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashString_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashString, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashString, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btHashString_at__rt{tis}
btAlignedObjectArray_btHashString_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btIndexedMesh_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btIndexedMesh, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btIndexedMesh, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btIndexedMesh_at__rt{tis}
btAlignedObjectArray_btIndexedMesh_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at__rt{tis}
btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at__rt{tis}
btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btOptimizedBvhNode_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvhNode, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvhNode, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btOptimizedBvhNode_at__rt{tis}
btAlignedObjectArray_btOptimizedBvhNode_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btPersistentManifold_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPersistentManifold_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPersistentManifold_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btPersistentManifold_p_at__rt{tis}
btAlignedObjectArray_btPersistentManifold_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btPointerUid_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPointerUid, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPointerUid, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btPointerUid_at__rt{tis}
btAlignedObjectArray_btPointerUid_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btQuantizedBvhNode_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhNode, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhNode, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btQuantizedBvhNode_at__rt{tis}
btAlignedObjectArray_btQuantizedBvhNode_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btRigidBody_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBody_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBody_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btRigidBody_p_at__rt{tis}
btAlignedObjectArray_btRigidBody_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSolverBody_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverBody, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverBody, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSolverBody_at__rt{tis}
btAlignedObjectArray_btSolverBody_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSolverConstraint_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverConstraint, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverConstraint, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSolverConstraint_at__rt{tis}
btAlignedObjectArray_btSolverConstraint_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriangleInfo_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleInfo, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTriangleInfo_at__rt{tis}
btAlignedObjectArray_btTriangleInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_btConstraintInfo1, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_btConstraintInfo1, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at__rt{tis}
btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraint_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTypedConstraint_p_at__rt{tis}
btAlignedObjectArray_btTypedConstraint_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btVector3_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btVector3_at__rt{tis}
btAlignedObjectArray_btVector3_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btWheelInfo_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btWheelInfo, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btWheelInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btWheelInfo_at__rt{tis}
btAlignedObjectArray_btWheelInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_char_const_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_const_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_const_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_char_const_p_at__rt{tis}
btAlignedObjectArray_char_const_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_char_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_char_p_at__rt{tis}
btAlignedObjectArray_char_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_float_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_float, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_float, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_float_at__rt{tis}
btAlignedObjectArray_float_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_int_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_int_at__rt{tis}
btAlignedObjectArray_int_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_short_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_short_at__rt{tis}
btAlignedObjectArray_short_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_short_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_short_p_at__rt{tis}
btAlignedObjectArray_short_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_unsigned_int_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_int, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_int, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_unsigned_int_at__rt{tis}
btAlignedObjectArray_unsigned_int_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_unsigned_short_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_short, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_short, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_unsigned_short_at__rt{tis}
btAlignedObjectArray_unsigned_short_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_void_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_void_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_void_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_void_p_at__rt{tis}
btAlignedObjectArray_void_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAxisSweep3_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btAxisSweep3, "getOverlappingPairCache"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btAxisSweep3, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3_getOverlappingPairCache__rt{tis}
btAxisSweep3_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btAxisSweep3Internal_unsigned_int_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_int, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_int, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3Internal_unsigned_int_getOverlappingPairCache__rt{tis}
btAxisSweep3Internal_unsigned_int_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btAxisSweep3Internal_unsigned_short_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_short, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_short, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3Internal_unsigned_short_getOverlappingPairCache__rt{tis}
btAxisSweep3Internal_unsigned_short_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btBU_Simplex1to4_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBU_Simplex1to4, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBU_Simplex1to4, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBU_Simplex1to4_setSafeMargin__rt{tis}
btBU_Simplex1to4_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btBoxShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBoxShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBoxShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBoxShape_setSafeMargin__rt{tis}
btBoxShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btBroadphaseInterface_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btBroadphaseInterface, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btBroadphaseInterface, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBroadphaseInterface_getOverlappingPairCache__rt{tis}
btBroadphaseInterface_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btBvhTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBvhTriangleMeshShape_getMeshInterface__rt{tis}
btBvhTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btBvhTriangleMeshShape_getTriangleInfoMap__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getTriangleInfoMap"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getTriangleInfoMap"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBvhTriangleMeshShape_getTriangleInfoMap__rt{tis}
btBvhTriangleMeshShape_getTriangleInfoMap(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getTriangleInfoMap();
  } else if (match_args{tis, {1}}) {
    return a0.getTriangleInfoMap();
  }
}
private metafunction btCapsuleShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShape_setSafeMargin__rt{tis}
btCapsuleShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btCapsuleShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeX, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeX, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShapeX_setSafeMargin__rt{tis}
btCapsuleShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btCapsuleShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeZ, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeZ, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShapeZ_setSafeMargin__rt{tis}
btCapsuleShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btCollisionDispatcher_getInternalManifoldPool__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getInternalManifoldPool"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getInternalManifoldPool"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionDispatcher_getInternalManifoldPool__rt{tis}
btCollisionDispatcher_getInternalManifoldPool(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInternalManifoldPool();
  } else if (match_args{tis, {0}}) {
    return a0.getInternalManifoldPool();
  }
}
private metafunction btCollisionDispatcher_getManifoldByIndexInternal__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getManifoldByIndexInternal"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getManifoldByIndexInternal"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionDispatcher_getManifoldByIndexInternal__rt{tis}
btCollisionDispatcher_getManifoldByIndexInternal(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getManifoldByIndexInternal(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getManifoldByIndexInternal(a1);
  }
}
private metafunction btCollisionDispatcher_getCollisionConfiguration__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getCollisionConfiguration"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getCollisionConfiguration"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionDispatcher_getCollisionConfiguration__rt{tis}
btCollisionDispatcher_getCollisionConfiguration(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionConfiguration();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionConfiguration();
  }
}
private metafunction btCollisionObject_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getBroadphaseHandle"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObject_getBroadphaseHandle__rt{tis}
btCollisionObject_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btCollisionObject_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getCollisionShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObject_getCollisionShape__rt{tis}
btCollisionObject_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btCollisionObject_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getInterpolationWorldTransform"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObject_getInterpolationWorldTransform__rt{tis}
btCollisionObject_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btCollisionObject_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObject_getWorldTransform__rt{tis}
btCollisionObject_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btCollisionWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getBroadphase"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_getBroadphase__rt{tis}
btCollisionWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  }
}
private metafunction btCollisionWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatcher"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_getDispatcher__rt{tis}
btCollisionWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  }
}
private metafunction btCollisionWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getCollisionObjectArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_getCollisionObjectArray__rt{tis}
btCollisionWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btCollisionWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_getDispatchInfo__rt{tis}
btCollisionWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btCompoundShape_getDynamicAabbTree__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCompoundShape, "getDynamicAabbTree"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCompoundShape, "getDynamicAabbTree"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundShape_getDynamicAabbTree__rt{tis}
btCompoundShape_getDynamicAabbTree(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDynamicAabbTree();
  } else if (match_args{tis, {1}}) {
    return a0.getDynamicAabbTree();
  }
}
private metafunction btCompoundShape_getChildTransform__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildTransform"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundShape_getChildTransform__rt{tis}
btCompoundShape_getChildTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildTransform(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildTransform(a1);
  }
}
private metafunction btCompoundShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildShape"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundShape_getChildShape__rt{tis}
btCompoundShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildShape(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildShape(a1);
  }
}
private metafunction btConeShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShape_setSafeMargin__rt{tis}
btConeShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConeShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeX, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeX, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShapeX_setSafeMargin__rt{tis}
btConeShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConeShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeZ, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeZ, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShapeZ_setSafeMargin__rt{tis}
btConeShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btConeTwistConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint_getJointFeedback__rt{tis}
btConeTwistConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btConeTwistConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint_getRigidBodyB__rt{tis}
btConeTwistConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btConeTwistConstraint_setLimit__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeTwistConstraint, "setLimit2"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeTwistConstraint, "setLimit6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint_setLimit__rt{tis}
btConeTwistConstraint_setLimit(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0},{btScalar,0}}}) {
    return a0.setLimit2(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setLimit6(a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btConeTwistConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint_getRigidBodyA__rt{tis}
btConeTwistConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btConvexHullShape_project__rt{tis}
  m::cond{
    match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{btConvexHullShape, "project6"}},
    match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1}}},
    m::ret_type{m::symbol{btConvexHullShape, "project4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullShape_project__rt{tis}
btConvexHullShape_project(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1},{btVector3,1},{btVector3,1}}}) {
    return a0.project6(a1,a2,a3,a4,a5,a6);
  } else if (match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1}}}) {
    return a0.project4(a1,a2,a3,a4);
  }
}
private metafunction btConvexHullShape_getUnscaledPoints__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvexHullShape, "getUnscaledPoints"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvexHullShape, "getUnscaledPoints"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullShape_getUnscaledPoints__rt{tis}
btConvexHullShape_getUnscaledPoints(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getUnscaledPoints();
  } else if (match_args{tis, {0}}) {
    return a0.getUnscaledPoints();
  }
}
private metafunction btConvexHullShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullShape_setSafeMargin__rt{tis}
btConvexHullShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btConvexInternalAabbCachingShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalAabbCachingShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalAabbCachingShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexInternalAabbCachingShape_setSafeMargin__rt{tis}
btConvexInternalAabbCachingShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btConvexInternalShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexInternalShape_setSafeMargin__rt{tis}
btConvexInternalShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btConvexTriangleMeshShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexTriangleMeshShape_setSafeMargin__rt{tis}
btConvexTriangleMeshShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConvexTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexTriangleMeshShape_getMeshInterface__rt{tis}
btConvexTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btCylinderShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShape_setSafeMargin__rt{tis}
btCylinderShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCylinderShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeX, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeX, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShapeX_setSafeMargin__rt{tis}
btCylinderShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btCylinderShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeZ, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeZ, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShapeZ_setSafeMargin__rt{tis}
btCylinderShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btDbvt_update__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{int,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_int"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt, "update4"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume_btVector3"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_update__rt{tis}
btDbvt_update(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume(a1,a2);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{int,0}}}) {
    return a0.update_btDbvtNode_p_int(a1,a2);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0},{btScalar,0}}}) {
    return a0.update4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume_btVector3(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btScalar,0}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume_btScalar(a1,a2,a3);
  }
}
private metafunction btDbvtBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDbvtBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDbvtBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvtBroadphase_getOverlappingPairCache__rt{tis}
btDbvtBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btDbvt_ICollide_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process_btDbvtNode_cp_btScalar"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_ICollide_Process__rt{tis}
btDbvt_ICollide_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  }
}
private metafunction btDiscreteDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatcher"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getDispatcher__rt{tis}
btDiscreteDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  }
}
private metafunction btDiscreteDynamicsWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getCollisionObjectArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getCollisionObjectArray__rt{tis}
btDiscreteDynamicsWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btDiscreteDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getBroadphase"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getBroadphase__rt{tis}
btDiscreteDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  }
}
private metafunction btDiscreteDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getConstraint"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getConstraint__rt{tis}
btDiscreteDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btDiscreteDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "addRigidBody3"}},
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "addRigidBody1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_addRigidBody__rt{tis}
btDiscreteDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  }
}
private metafunction btDiscreteDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getDispatchInfo__rt{tis}
btDiscreteDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btDiscreteDynamicsWorld_getSimulationIslandManager__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getSimulationIslandManager"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getSimulationIslandManager"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getSimulationIslandManager__rt{tis}
btDiscreteDynamicsWorld_getSimulationIslandManager(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getSimulationIslandManager();
  } else if (match_args{tis, {0}}) {
    return a0.getSimulationIslandManager();
  }
}
private metafunction btDispatcher_getInternalManifoldPool__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDispatcher, "getInternalManifoldPool"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDispatcher, "getInternalManifoldPool"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDispatcher_getInternalManifoldPool__rt{tis}
btDispatcher_getInternalManifoldPool(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInternalManifoldPool();
  } else if (match_args{tis, {0}}) {
    return a0.getInternalManifoldPool();
  }
}
private metafunction btDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatcher"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getDispatcher__rt{tis}
btDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  }
}
private metafunction btDynamicsWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getCollisionObjectArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getCollisionObjectArray__rt{tis}
btDynamicsWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getBroadphase"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getBroadphase__rt{tis}
btDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  }
}
private metafunction btDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getDispatchInfo__rt{tis}
btDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "addRigidBody3"}},
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "addRigidBody1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_addRigidBody__rt{tis}
btDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  }
}
private metafunction btDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "getConstraint"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getConstraint__rt{tis}
btDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btGearConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGearConstraint_getRigidBodyA__rt{tis}
btGearConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGearConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGearConstraint_getRigidBodyB__rt{tis}
btGearConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGearConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGearConstraint_getJointFeedback__rt{tis}
btGearConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGeneric6DofConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getJointFeedback__rt{tis}
btGeneric6DofConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGeneric6DofConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getFrameOffsetA__rt{tis}
btGeneric6DofConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btGeneric6DofConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getRigidBodyB__rt{tis}
btGeneric6DofConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGeneric6DofConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "calculateTransforms0"}},
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "calculateTransforms2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_calculateTransforms__rt{tis}
btGeneric6DofConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  } else if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  }
}
private metafunction btGeneric6DofConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getRigidBodyA__rt{tis}
btGeneric6DofConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGeneric6DofConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getFrameOffsetB__rt{tis}
btGeneric6DofConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btGeneric6DofSpringConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getRigidBodyB__rt{tis}
btGeneric6DofSpringConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGeneric6DofSpringConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getFrameOffsetA__rt{tis}
btGeneric6DofSpringConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btGeneric6DofSpringConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getJointFeedback__rt{tis}
btGeneric6DofSpringConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGeneric6DofSpringConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getFrameOffsetB__rt{tis}
btGeneric6DofSpringConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btGeneric6DofSpringConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getRigidBodyA__rt{tis}
btGeneric6DofSpringConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGeneric6DofSpringConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "calculateTransforms2"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "calculateTransforms0"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_calculateTransforms__rt{tis}
btGeneric6DofSpringConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  } else if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  }
}
private metafunction btGeneric6DofSpringConstraint_setEquilibriumPoint__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint0"}},
    match_args{tis, {1,{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint2"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_setEquilibriumPoint__rt{tis}
btGeneric6DofSpringConstraint_setEquilibriumPoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.setEquilibriumPoint0();
  } else if (match_args{tis, {1,{int,0},{btScalar,0}}}) {
    return a0.setEquilibriumPoint2(a1,a2);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.setEquilibriumPoint1(a1);
  }
}
private metafunction btHashMap_btHashInt_btTriangleInfo_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashInt_btTriangleInfo_getAtIndex__rt{tis}
btHashMap_btHashInt_btTriangleInfo_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashInt_btTriangleInfo_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "find"}},
    match_args{tis, {1,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashInt_btTriangleInfo_find__rt{tis}
btHashMap_btHashInt_btTriangleInfo_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashInt,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashInt,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashInt_int_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "find"}},
    match_args{tis, {1,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashInt_int_find__rt{tis}
btHashMap_btHashInt_int_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashInt,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashInt,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashInt_int_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashInt_int_getAtIndex__rt{tis}
btHashMap_btHashInt_int_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btPointerUid_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btPointerUid_find__rt{tis}
btHashMap_btHashPtr_btPointerUid_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btPointerUid_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btPointerUid_getAtIndex__rt{tis}
btHashMap_btHashPtr_btPointerUid_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_char_const_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_char_const_p, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_char_const_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_char_const_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_char_const_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_char_const_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_char_const_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_char_const_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_char_const_p_find__rt{tis}
btHashMap_btHashPtr_char_const_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_void_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_void_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_void_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_void_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_void_p_find__rt{tis}
btHashMap_btHashPtr_void_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashString_int_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_int_getAtIndex__rt{tis}
btHashMap_btHashString_int_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashString_int_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "find"}},
    match_args{tis, {0,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_int_find__rt{tis}
btHashMap_btHashString_int_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashString,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashString,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashedOverlappingPairCache_getOverlappingPairArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashedOverlappingPairCache_getOverlappingPairArray__rt{tis}
btHashedOverlappingPairCache_getOverlappingPairArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArray();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArray();
  }
}
private metafunction btHashedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btHashedOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btHinge2Constraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getJointFeedback__rt{tis}
btHinge2Constraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btHinge2Constraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getRigidBodyB__rt{tis}
btHinge2Constraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btHinge2Constraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getFrameOffsetA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getFrameOffsetA__rt{tis}
btHinge2Constraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btHinge2Constraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btHinge2Constraint, "calculateTransforms2"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "calculateTransforms0"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_calculateTransforms__rt{tis}
btHinge2Constraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  } else if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  }
}
private metafunction btHinge2Constraint_setEquilibriumPoint__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "setEquilibriumPoint0"}},
    match_args{tis, {1,{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHinge2Constraint, "setEquilibriumPoint2"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHinge2Constraint, "setEquilibriumPoint1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_setEquilibriumPoint__rt{tis}
btHinge2Constraint_setEquilibriumPoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.setEquilibriumPoint0();
  } else if (match_args{tis, {1,{int,0},{btScalar,0}}}) {
    return a0.setEquilibriumPoint2(a1,a2);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.setEquilibriumPoint1(a1);
  }
}
private metafunction btHinge2Constraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getFrameOffsetB__rt{tis}
btHinge2Constraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btHinge2Constraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getRigidBodyA__rt{tis}
btHinge2Constraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btHingeConstraint_getAFrame__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getAFrame"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getAFrame"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getAFrame__rt{tis}
btHingeConstraint_getAFrame(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getAFrame();
  } else if (match_args{tis, {1}}) {
    return a0.getAFrame();
  }
}
private metafunction btHingeConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getRigidBodyB__rt{tis}
btHingeConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btHingeConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getJointFeedback__rt{tis}
btHingeConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btHingeConstraint_setMotorTarget__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "setMotorTarget_btScalar_btScalar"}},
    match_args{tis, {1,{btQuaternion,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "setMotorTarget_btQuaternion_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_setMotorTarget__rt{tis}
btHingeConstraint_setMotorTarget(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setMotorTarget_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btQuaternion,0},{btScalar,0}}}) {
    return a0.setMotorTarget_btQuaternion_btScalar(a1,a2);
  }
}
private metafunction btHingeConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getRigidBodyA__rt{tis}
btHingeConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btHingeConstraint_getHingeAngle__rt{tis}
  m::cond{
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "getHingeAngle2"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getHingeAngle0"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getHingeAngle__rt{tis}
btHingeConstraint_getHingeAngle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.getHingeAngle2(a1,a2);
  } else if (match_args{tis, {1}}) {
    return a0.getHingeAngle0();
  }
}
private metafunction btHingeConstraint_getBFrame__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getBFrame"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getBFrame"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getBFrame__rt{tis}
btHingeConstraint_getBFrame(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBFrame();
  } else if (match_args{tis, {0}}) {
    return a0.getBFrame();
  }
}
private metafunction btIDebugDraw_drawBox__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawBox3"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btTransform,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawBox4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btIDebugDraw_drawBox__rt{tis}
btIDebugDraw_drawBox(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawBox3(a1,a2,a3);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btTransform,0},{btVector3,0}}}) {
    return a0.drawBox4(a1,a2,a3,a4);
  }
}
private metafunction btIDebugDraw_drawSphere__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btTransform,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawSphere_btScalar_btTransform_btVector3"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawSphere_btVector3_btScalar_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btIDebugDraw_drawSphere__rt{tis}
btIDebugDraw_drawSphere(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btTransform,0},{btVector3,0}}}) {
    return a0.drawSphere_btScalar_btTransform_btVector3(a1,a2,a3);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0},{btVector3,0}}}) {
    return a0.drawSphere_btVector3_btScalar_btVector3(a1,a2,a3);
  }
}
private metafunction btIDebugDraw_drawTriangle__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawTriangle8"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawTriangle5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btIDebugDraw_drawTriangle__rt{tis}
btIDebugDraw_drawTriangle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return a0.drawTriangle8(a1,a2,a3,a4,a5,a6,a7,a8);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return a0.drawTriangle5(a1,a2,a3,a4,a5);
  }
}
private metafunction btIDebugDraw_drawLine__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawLine3"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawLine4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btIDebugDraw_drawLine__rt{tis}
btIDebugDraw_drawLine(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawLine3(a1,a2,a3);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawLine4(a1,a2,a3,a4);
  }
}
private metafunction btJacobianEntry_getNonDiagonal__rt{tis}
  m::cond{
    match_args{tis, {0,{btJacobianEntry,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btJacobianEntry, "getNonDiagonal3"}},
    match_args{tis, {0,{btJacobianEntry,0},{btScalar,0}}},
    m::ret_type{m::symbol{btJacobianEntry, "getNonDiagonal2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btJacobianEntry_getNonDiagonal__rt{tis}
btJacobianEntry_getNonDiagonal(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btJacobianEntry,0},{btScalar,0},{btScalar,0}}}) {
    return a0.getNonDiagonal3(a1,a2,a3);
  } else if (match_args{tis, {0,{btJacobianEntry,0},{btScalar,0}}}) {
    return a0.getNonDiagonal2(a1,a2);
  }
}
private metafunction btManifoldResult_getPersistentManifold__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btManifoldResult, "getPersistentManifold"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btManifoldResult, "getPersistentManifold"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btManifoldResult_getPersistentManifold__rt{tis}
btManifoldResult_getPersistentManifold(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getPersistentManifold();
  } else if (match_args{tis, {0}}) {
    return a0.getPersistentManifold();
  }
}
private metafunction btMultiSapBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSapBroadphase_getOverlappingPairCache__rt{tis}
btMultiSapBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btMultiSapBroadphase_getBroadphaseArray__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getBroadphaseArray"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getBroadphaseArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSapBroadphase_getBroadphaseArray__rt{tis}
btMultiSapBroadphase_getBroadphaseArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseArray();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseArray();
  }
}
private metafunction btMultiSphereShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMultiSphereShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMultiSphereShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSphereShape_setSafeMargin__rt{tis}
btMultiSphereShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btNullPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btNullPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btNullPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btNullPairCache_getOverlappingPairArrayPtr__rt{tis}
btNullPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btOptimizedBvh_serialize__rt{tis}
  m::cond{
    match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}},
    m::ret_type{m::symbol{btOptimizedBvh, "serialize3"}},
    match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}},
    m::ret_type{m::symbol{btOptimizedBvh, "serialize2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btOptimizedBvh_serialize__rt{tis}
btOptimizedBvh_serialize(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}}) {
    return a0.serialize3(a1,a2,a3);
  } else if (match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}}) {
    return a0.serialize2(a1,a2);
  }
}
private metafunction btOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btPersistentManifold_getContactPoint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btPersistentManifold, "getContactPoint"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btPersistentManifold, "getContactPoint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPersistentManifold_getContactPoint__rt{tis}
btPersistentManifold_getContactPoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getContactPoint(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getContactPoint(a1);
  }
}
private metafunction btPoint2PointConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoint2PointConstraint_getRigidBodyA__rt{tis}
btPoint2PointConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btPoint2PointConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoint2PointConstraint_getJointFeedback__rt{tis}
btPoint2PointConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btPoint2PointConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoint2PointConstraint_getRigidBodyB__rt{tis}
btPoint2PointConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btPolyhedralConvexAabbCachingShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexAabbCachingShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexAabbCachingShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPolyhedralConvexAabbCachingShape_setSafeMargin__rt{tis}
btPolyhedralConvexAabbCachingShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btPolyhedralConvexShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPolyhedralConvexShape_setSafeMargin__rt{tis}
btPolyhedralConvexShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btQuadWord_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuadWord, "setValue4"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuadWord, "setValue3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuadWord_setValue__rt{tis}
btQuadWord_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  }
}
private metafunction btQuantizedBvh_serialize__rt{tis}
  m::cond{
    match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}},
    m::ret_type{m::symbol{btQuantizedBvh, "serialize2"}},
    match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}},
    m::ret_type{m::symbol{btQuantizedBvh, "serialize3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuantizedBvh_serialize__rt{tis}
btQuantizedBvh_serialize(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}}) {
    return a0.serialize2(a1,a2);
  } else if (match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}}) {
    return a0.serialize3(a1,a2,a3);
  }
}
private metafunction btQuaternion_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuaternion, "setValue3"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuaternion, "setValue4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuaternion_setValue__rt{tis}
btQuaternion_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  }
}
private metafunction btRaycastVehicle_getWheelInfo__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btRaycastVehicle, "getWheelInfo"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btRaycastVehicle, "getWheelInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRaycastVehicle_getWheelInfo__rt{tis}
btRaycastVehicle_getWheelInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getWheelInfo(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getWheelInfo(a1);
  }
}
private metafunction btRaycastVehicle_getRigidBody__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRaycastVehicle, "getRigidBody"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRaycastVehicle, "getRigidBody"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRaycastVehicle_getRigidBody__rt{tis}
btRaycastVehicle_getRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBody();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBody();
  }
}
private metafunction btRigidBody_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getInterpolationWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getInterpolationWorldTransform__rt{tis}
btRigidBody_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btRigidBody_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getWorldTransform__rt{tis}
btRigidBody_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btRigidBody_getBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseProxy"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseProxy"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getBroadphaseProxy__rt{tis}
btRigidBody_getBroadphaseProxy(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphaseProxy();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphaseProxy();
  }
}
private metafunction btRigidBody_getMotionState__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getMotionState"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getMotionState"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getMotionState__rt{tis}
btRigidBody_getMotionState(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getMotionState();
  } else if (match_args{tis, {1}}) {
    return a0.getMotionState();
  }
}
private metafunction btRigidBody_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseHandle"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getBroadphaseHandle__rt{tis}
btRigidBody_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btRigidBody_setAngularFactor__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0}}},
    m::ret_type{m::symbol{btRigidBody, "setAngularFactor_btScalar"}},
    match_args{tis, {1,{btVector3,0}}},
    m::ret_type{m::symbol{btRigidBody, "setAngularFactor_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_setAngularFactor__rt{tis}
btRigidBody_setAngularFactor(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0}}}) {
    return a0.setAngularFactor_btScalar(a1);
  } else if (match_args{tis, {1,{btVector3,0}}}) {
    return a0.setAngularFactor_btVector3(a1);
  }
}
private metafunction btRigidBody_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getCollisionShape"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getCollisionShape__rt{tis}
btRigidBody_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btScaledBvhTriangleMeshShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btScaledBvhTriangleMeshShape, "getChildShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btScaledBvhTriangleMeshShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btScaledBvhTriangleMeshShape_getChildShape__rt{tis}
btScaledBvhTriangleMeshShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getChildShape();
  } else if (match_args{tis, {0}}) {
    return a0.getChildShape();
  }
}
private metafunction btSimpleBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleBroadphase_getOverlappingPairCache__rt{tis}
btSimpleBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btSimpleDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatcher"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getDispatcher__rt{tis}
btSimpleDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  }
}
private metafunction btSimpleDynamicsWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getCollisionObjectArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getCollisionObjectArray__rt{tis}
btSimpleDynamicsWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btSimpleDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getBroadphase"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getBroadphase__rt{tis}
btSimpleDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  }
}
private metafunction btSimpleDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getConstraint"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getConstraint__rt{tis}
btSimpleDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btSimpleDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "addRigidBody1"}},
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "addRigidBody3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_addRigidBody__rt{tis}
btSimpleDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  }
}
private metafunction btSimpleDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getDispatchInfo__rt{tis}
btSimpleDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btSliderConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getJointFeedback__rt{tis}
btSliderConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btSliderConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getFrameOffsetA__rt{tis}
btSliderConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btSliderConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getRigidBodyB__rt{tis}
btSliderConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btSliderConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getFrameOffsetB__rt{tis}
btSliderConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btSliderConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getRigidBodyA__rt{tis}
btSliderConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btSortedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSortedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btSortedOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btSortedOverlappingPairCache_getOverlappingPairArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSortedOverlappingPairCache_getOverlappingPairArray__rt{tis}
btSortedOverlappingPairCache_getOverlappingPairArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArray();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArray();
  }
}
private metafunction btSphereShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSphereShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSphereShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSphereShape_setSafeMargin__rt{tis}
btSphereShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btTransform_getOrigin__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTransform, "getOrigin"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTransform, "getOrigin"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTransform_getOrigin__rt{tis}
btTransform_getOrigin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOrigin();
  } else if (match_args{tis, {0}}) {
    return a0.getOrigin();
  }
}
private metafunction btTransform_getBasis__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTransform, "getBasis"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTransform, "getBasis"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTransform_getBasis__rt{tis}
btTransform_getBasis(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBasis();
  } else if (match_args{tis, {0}}) {
    return a0.getBasis();
  }
}
private metafunction btTriangleIndexVertexArray_getIndexedMeshArray__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTriangleIndexVertexArray, "getIndexedMeshArray"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTriangleIndexVertexArray, "getIndexedMeshArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleIndexVertexArray_getIndexedMeshArray__rt{tis}
btTriangleIndexVertexArray_getIndexedMeshArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getIndexedMeshArray();
  } else if (match_args{tis, {0}}) {
    return a0.getIndexedMeshArray();
  }
}
private metafunction btTriangleInfoMap_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashInt,0}}},
    m::ret_type{m::symbol{btTriangleInfoMap, "find"}},
    match_args{tis, {0,{btHashInt,0}}},
    m::ret_type{m::symbol{btTriangleInfoMap, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleInfoMap_find__rt{tis}
btTriangleInfoMap_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashInt,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashInt,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btTriangleInfoMap_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btTriangleInfoMap, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btTriangleInfoMap, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleInfoMap_getAtIndex__rt{tis}
btTriangleInfoMap_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btTriangleMesh_getIndexedMeshArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTriangleMesh, "getIndexedMeshArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTriangleMesh, "getIndexedMeshArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleMesh_getIndexedMeshArray__rt{tis}
btTriangleMesh_getIndexedMeshArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getIndexedMeshArray();
  } else if (match_args{tis, {1}}) {
    return a0.getIndexedMeshArray();
  }
}
private metafunction btTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleMeshShape_getMeshInterface__rt{tis}
btTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btTypedConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedConstraint_getRigidBodyB__rt{tis}
btTypedConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btTypedConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedConstraint_getJointFeedback__rt{tis}
btTypedConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btTypedConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedConstraint_getRigidBodyA__rt{tis}
btTypedConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btUniformScalingShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniformScalingShape, "getChildShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniformScalingShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniformScalingShape_getChildShape__rt{tis}
btUniformScalingShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getChildShape();
  } else if (match_args{tis, {0}}) {
    return a0.getChildShape();
  }
}
private metafunction btUniversalConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getJointFeedback__rt{tis}
btUniversalConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btUniversalConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getFrameOffsetA__rt{tis}
btUniversalConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btUniversalConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getRigidBodyB__rt{tis}
btUniversalConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btUniversalConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btUniversalConstraint, "calculateTransforms2"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "calculateTransforms0"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_calculateTransforms__rt{tis}
btUniversalConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  } else if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  }
}
private metafunction btUniversalConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getRigidBodyA__rt{tis}
btUniversalConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btUniversalConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getFrameOffsetB__rt{tis}
btUniversalConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btVector4_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btVector4, "setValue4"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btVector4, "setValue3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btVector4_setValue__rt{tis}
btVector4_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  }
}
private metafunction btRigidBody_btRigidBodyConstructionInfo__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody_btRigidBodyConstructionInfo4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_btRigidBodyConstructionInfo__rt{tis}
btRigidBody_btRigidBodyConstructionInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}}) {
    return btRigidBody_btRigidBodyConstructionInfo4(a0,a1,a2,a3);
  }
}
private metafunction btDefaultCollisionConfiguration__rt{tis}
  m::cond{
    match_args{tis, {{btDefaultCollisionConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDefaultCollisionConfiguration1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultCollisionConfiguration__rt{tis}
btDefaultCollisionConfiguration_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btDefaultCollisionConstructionInfo,0}}}) {
    return btDefaultCollisionConfiguration1(a0);
  }
}
private metafunction btCollisionWorld_AllHitsRayResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_AllHitsRayResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_AllHitsRayResultCallback__rt{tis}
btCollisionWorld_AllHitsRayResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_AllHitsRayResultCallback2(a0,a1);
  }
}
private metafunction btCapsuleShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCapsuleShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShape__rt{tis}
btCapsuleShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShape2(a0,a1);
  }
}
private metafunction btRigidBody__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody4"}},
    match_args{tis, {{btRigidBody_btRigidBodyConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody__rt{tis}
btRigidBody_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}}) {
    return btRigidBody4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btRigidBody_btRigidBodyConstructionInfo,0}}}) {
    return btRigidBody1(a0);
  }
}
private metafunction btGearConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGearConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGearConstraint__rt{tis}
btGearConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btGearConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btConeTwistConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeTwistConstraint2"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeTwistConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint__rt{tis}
btConeTwistConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0}}}) {
    return btConeTwistConstraint2(a0,a1);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}}) {
    return btConeTwistConstraint4(a0,a1,a2,a3);
  }
}
private metafunction btTypedConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1},{btRigidBody,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btTypedConstraint3"}},
    match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btTypedConstraint2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedConstraint__rt{tis}
btTypedConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1},{btRigidBody,1}}}) {
    return btTypedConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1}}}) {
    return btTypedConstraint2(a0,a1);
  }
}
private metafunction btDbvt_sStkNN__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvt_sStkNN2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_sStkNN__rt{tis}
btDbvt_sStkNN_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return btDbvt_sStkNN2(a0,a1);
  }
}
private metafunction btQuaternion__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuaternion3"}},
    match_args{tis, {{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuaternion2"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuaternion4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuaternion__rt{tis}
btQuaternion_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuaternion3(a0,a1,a2);
  } else if (match_args{tis, {{btVector3,0},{btScalar,0}}}) {
    return btQuaternion2(a0,a1);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuaternion4(a0,a1,a2,a3);
  }
}
private metafunction btTriangleIndexVertexArray__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleIndexVertexArray6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleIndexVertexArray__rt{tis}
btTriangleIndexVertexArray_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0}}}) {
    return btTriangleIndexVertexArray6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btSimpleBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSimpleBroadphaseProxy7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleBroadphaseProxy__rt{tis}
btSimpleBroadphaseProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}}) {
    return btSimpleBroadphaseProxy7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btCollisionWorld_LocalRayResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_LocalRayResult4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_LocalRayResult__rt{tis}
btCollisionWorld_LocalRayResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btScalar,0}}}) {
    return btCollisionWorld_LocalRayResult4(a0,a1,a2,a3);
  }
}
private metafunction btCylinderShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCylinderShapeX1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShapeX__rt{tis}
btCylinderShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShapeX1(a0);
  }
}
private metafunction btConvexTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexTriangleMeshShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexTriangleMeshShape__rt{tis}
btConvexTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0}}}) {
    return btConvexTriangleMeshShape2(a0,a1);
  }
}
private metafunction btUniformScalingShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btConvexShape},0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btUniformScalingShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniformScalingShape__rt{tis}
btUniformScalingShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btConvexShape},0},{btScalar,0}}}) {
    return btUniformScalingShape2(a0,a1);
  }
}
private metafunction btGeneric6DofConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGeneric6DofConstraint5"}},
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGeneric6DofConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint__rt{tis}
btGeneric6DofConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofConstraint5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofConstraint3(a0,a1,a2);
  }
}
private metafunction btActivatingCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btActivatingCollisionAlgorithm1"}},
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btActivatingCollisionAlgorithm3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btActivatingCollisionAlgorithm__rt{tis}
btActivatingCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btActivatingCollisionAlgorithm1(a0);
  } else if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btActivatingCollisionAlgorithm3(a0,a1,a2);
  }
}
private metafunction btSelect__rt{tis}
  m::cond{
    match_args{tis, {{uint,0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSelect_uint_int_int"}},
    match_args{tis, {{uint,0},{uint,0},{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSelect_uint_uint_uint"}},
    match_args{tis, {{uint,0},{float,0},{float,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSelect_uint_float_float"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSelect__rt{tis}
btSelect(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{uint,0},{int,0},{int,0}}}) {
    return btSelect_uint_int_int(a0,a1,a2);
  } else if (match_args{tis, {{uint,0},{uint,0},{uint,0}}}) {
    return btSelect_uint_uint_uint(a0,a1,a2);
  } else if (match_args{tis, {{uint,0},{float,0},{float,0}}}) {
    return btSelect_uint_float_float(a0,a1,a2);
  }
}
private metafunction btMultiSphereShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btVector3},0},{crptr{btScalar},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMultiSphereShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSphereShape__rt{tis}
btMultiSphereShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btVector3},0},{crptr{btScalar},0},{int,0}}}) {
    return btMultiSphereShape3(a0,a1,a2);
  }
}
private metafunction btCollisionWorld_ClosestRayResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_ClosestRayResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_ClosestRayResultCallback__rt{tis}
btCollisionWorld_ClosestRayResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_ClosestRayResultCallback2(a0,a1);
  }
}
private metafunction btCollisionAlgorithmConstructionInfo__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionAlgorithmConstructionInfo2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionAlgorithmConstructionInfo__rt{tis}
btCollisionAlgorithmConstructionInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{int,0}}}) {
    return btCollisionAlgorithmConstructionInfo2(a0,a1);
  }
}
private metafunction btTypedObject__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTypedObject1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedObject__rt{tis}
btTypedObject_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btTypedObject1(a0);
  }
}
private metafunction btDefaultSerializer__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDefaultSerializer1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultSerializer__rt{tis}
btDefaultSerializer_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btDefaultSerializer1(a0);
  }
}
private metafunction btDefaultVehicleRaycaster__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDynamicsWorld},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDefaultVehicleRaycaster1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultVehicleRaycaster__rt{tis}
btDefaultVehicleRaycaster_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDynamicsWorld},0}}}) {
    return btDefaultVehicleRaycaster1(a0);
  }
}
private metafunction btTransform__rt{tis}
  m::cond{
    match_args{tis, {{btQuaternion,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTransform_btQuaternion_btVector3"}},
    match_args{tis, {{btMatrix3x3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTransform_btMatrix3x3_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTransform__rt{tis}
btTransform_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btQuaternion,0},{btVector3,0}}}) {
    return btTransform_btQuaternion_btVector3(a0,a1);
  } else if (match_args{tis, {{btMatrix3x3,0},{btVector3,0}}}) {
    return btTransform_btMatrix3x3_btVector3(a0,a1);
  }
}
private metafunction btStaticPlaneShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btStaticPlaneShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btStaticPlaneShape__rt{tis}
btStaticPlaneShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btScalar,0}}}) {
    return btStaticPlaneShape2(a0,a1);
  }
}
private metafunction btDiscreteDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDiscreteDynamicsWorld4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld__rt{tis}
btDiscreteDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}}) {
    return btDiscreteDynamicsWorld4(a0,a1,a2,a3);
  }
}
private metafunction btConeShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShape__rt{tis}
btConeShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShape2(a0,a1);
  }
}
private metafunction btBoxShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBoxShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBoxShape__rt{tis}
btBoxShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btBoxShape1(a0);
  }
}
private metafunction btWheelInfo__rt{tis}
  m::cond{
    match_args{tis, {{btWheelInfoConstructionInfo,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btWheelInfo1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btWheelInfo__rt{tis}
btWheelInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btWheelInfoConstructionInfo,1}}}) {
    return btWheelInfo1(a0);
  }
}
private metafunction btBU_Simplex1to4__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBU_Simplex1to4_1"}},
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBU_Simplex1to4_2"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBU_Simplex1to4_3"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBU_Simplex1to4_4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBU_Simplex1to4__rt{tis}
btBU_Simplex1to4_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btBU_Simplex1to4_1(a0);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_2(a0,a1);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_3(a0,a1,a2);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_4(a0,a1,a2,a3);
  }
}
private metafunction btCollisionWorld_ClosestConvexResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_ClosestConvexResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_ClosestConvexResultCallback__rt{tis}
btCollisionWorld_ClosestConvexResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_ClosestConvexResultCallback2(a0,a1);
  }
}
private metafunction btSimpleBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSimpleBroadphase2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleBroadphase__rt{tis}
btSimpleBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}}) {
    return btSimpleBroadphase2(a0,a1);
  }
}
private metafunction btVector3__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btVector3_3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btVector3__rt{tis}
btVector3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btVector3_3(a0,a1,a2);
  }
}
private metafunction btSimpleDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSimpleDynamicsWorld4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld__rt{tis}
btSimpleDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}}) {
    return btSimpleDynamicsWorld4(a0,a1,a2,a3);
  }
}
private metafunction btCylinderShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCylinderShapeZ1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShapeZ__rt{tis}
btCylinderShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShapeZ1(a0);
  }
}
private metafunction btAngle__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAngle_btVector3_btVector3"}},
    match_args{tis, {{btQuaternion,0},{btQuaternion,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAngle_btQuaternion_btQuaternion"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAngle__rt{tis}
btAngle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btAngle_btVector3_btVector3(a0,a1);
  } else if (match_args{tis, {{btQuaternion,0},{btQuaternion,0}}}) {
    return btAngle_btQuaternion_btQuaternion(a0,a1);
  }
}
private metafunction btCollisionWorld_LocalConvexResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_LocalConvexResult5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_LocalConvexResult__rt{tis}
btCollisionWorld_LocalConvexResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btCollisionWorld_LocalConvexResult5(a0,a1,a2,a3,a4);
  }
}
private metafunction btDbvtAabbMm_FromPoints__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btVector3},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvtAabbMm_FromPoints_btVector3_cp_int"}},
    match_args{tis, {{rptr{crptr{btVector3}},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvtAabbMm_FromPoints_btVector3_cp_p_int"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvtAabbMm_FromPoints__rt{tis}
btDbvtAabbMm_FromPoints(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btVector3},0},{int,0}}}) {
    return btDbvtAabbMm_FromPoints_btVector3_cp_int(a0,a1);
  } else if (match_args{tis, {{rptr{crptr{btVector3}},0},{int,0}}}) {
    return btDbvtAabbMm_FromPoints_btVector3_cp_p_int(a0,a1);
  }
}
private metafunction btJacobianEntry__rt{tis}
  m::cond{
    match_args{tis, {{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btJacobianEntry6"}},
    match_args{tis, {{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btJacobianEntry9"}},
    match_args{tis, {{btVector3,0},{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btJacobianEntry5"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btJacobianEntry4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btJacobianEntry__rt{tis}
btJacobianEntry_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btJacobianEntry6(a0,a1,a2,a3,a4,a5);
  } else if (match_args{tis, {{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0},{btVector3,0},{btScalar,0}}}) {
    return btJacobianEntry9(a0,a1,a2,a3,a4,a5,a6,a7,a8);
  } else if (match_args{tis, {{btVector3,0},{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0}}}) {
    return btJacobianEntry5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btJacobianEntry4(a0,a1,a2,a3);
  }
}
private metafunction btGeneric6DofSpringConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGeneric6DofSpringConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGeneric6DofSpringConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint__rt{tis}
btGeneric6DofSpringConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofSpringConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofSpringConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btCylinderShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCylinderShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShape__rt{tis}
btCylinderShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShape1(a0);
  }
}
private metafunction btHashInt__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHashInt1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashInt__rt{tis}
btHashInt_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btHashInt1(a0);
  }
}
private metafunction btHashPtr__rt{tis}
  m::cond{
    match_args{tis, {{crptr{void},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHashPtr1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashPtr__rt{tis}
btHashPtr_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{void},0}}}) {
    return btHashPtr1(a0);
  }
}
private metafunction btUniversalConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btUniversalConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint__rt{tis}
btUniversalConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btUniversalConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btCollisionObjectWrapper__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionShape},0},{crptr{btCollisionObject},0},{btTransform,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionObjectWrapper4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObjectWrapper__rt{tis}
btCollisionObjectWrapper_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionShape},0},{crptr{btCollisionObject},0},{btTransform,0}}}) {
    return btCollisionObjectWrapper4(a0,a1,a2,a3);
  }
}
private metafunction btScaledBvhTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btBvhTriangleMeshShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btScaledBvhTriangleMeshShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btScaledBvhTriangleMeshShape__rt{tis}
btScaledBvhTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btBvhTriangleMeshShape},0},{btVector3,0}}}) {
    return btScaledBvhTriangleMeshShape2(a0,a1);
  }
}
private metafunction btRaycastVehicle__rt{tis}
  m::cond{
    match_args{tis, {{btRaycastVehicle_btVehicleTuning,0},{rptr{btRigidBody},0},{rptr{btVehicleRaycaster},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRaycastVehicle3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRaycastVehicle__rt{tis}
btRaycastVehicle_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRaycastVehicle_btVehicleTuning,0},{rptr{btRigidBody},0},{rptr{btVehicleRaycaster},0}}}) {
    return btRaycastVehicle3(a0,a1,a2);
  }
}
private metafunction btHingeConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHingeConstraint5"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHingeConstraint7"}},
    match_args{tis, {{btRigidBody,1},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHingeConstraint4"}},
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHingeConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint__rt{tis}
btHingeConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btHingeConstraint5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btHingeConstraint7(a0,a1,a2,a3,a4,a5,a6);
  } else if (match_args{tis, {{btRigidBody,1},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btHingeConstraint4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btHingeConstraint3(a0,a1,a2);
  }
}
private metafunction btDbvt_sStkNPS__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{uint,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvt_sStkNPS3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_sStkNPS__rt{tis}
btDbvt_sStkNPS_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{uint,0},{btScalar,0}}}) {
    return btDbvt_sStkNPS3(a0,a1,a2);
  }
}
private metafunction btSphereSphereCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereSphereCollisionAlgorithm4"}},
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereSphereCollisionAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSphereSphereCollisionAlgorithm__rt{tis}
btSphereSphereCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btSphereSphereCollisionAlgorithm4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btSphereSphereCollisionAlgorithm1(a0);
  }
}
private metafunction btCapsuleShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCapsuleShapeZ2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShapeZ__rt{tis}
btCapsuleShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShapeZ2(a0,a1);
  }
}
private metafunction btBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBroadphaseProxy6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBroadphaseProxy__rt{tis}
btBroadphaseProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}}) {
    return btBroadphaseProxy6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btDefaultMotionState__rt{tis}
  m::cond{
    match_args{tis, {{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDefaultMotionState2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultMotionState__rt{tis}
btDefaultMotionState_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btTransform,0},{btTransform,0}}}) {
    return btDefaultMotionState2(a0,a1);
  }
}
private metafunction btDbvtProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvtProxy5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvtProxy__rt{tis}
btDbvtProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0}}}) {
    return btDbvtProxy5(a0,a1,a2,a3,a4);
  }
}
private metafunction btTriangleMesh__rt{tis}
  m::cond{
    match_args{tis, {{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleMesh2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleMesh__rt{tis}
btTriangleMesh_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{bool,0},{bool,0}}}) {
    return btTriangleMesh2(a0,a1);
  }
}
private metafunction btManifoldResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btManifoldResult2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btManifoldResult__rt{tis}
btManifoldResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btManifoldResult2(a0,a1);
  }
}
private metafunction btConvexHullShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btScalar},0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexHullShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullShape__rt{tis}
btConvexHullShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btScalar},0},{int,0},{int,0}}}) {
    return btConvexHullShape3(a0,a1,a2);
  }
}
private metafunction btConvexSeparatingDistanceUtil__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexSeparatingDistanceUtil2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexSeparatingDistanceUtil__rt{tis}
btConvexSeparatingDistanceUtil_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConvexSeparatingDistanceUtil2(a0,a1);
  }
}
private metafunction btCollisionWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld__rt{tis}
btCollisionWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}}) {
    return btCollisionWorld3(a0,a1,a2);
  }
}
private metafunction btCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionAlgorithm__rt{tis}
btCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btCollisionAlgorithm1(a0);
  }
}
private metafunction btDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDynamicsWorld3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld__rt{tis}
btDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}}) {
    return btDynamicsWorld3(a0,a1,a2);
  }
}
private metafunction btMultiSapBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMultiSapBroadphase2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSapBroadphase__rt{tis}
btMultiSapBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}}) {
    return btMultiSapBroadphase2(a0,a1);
  }
}
private metafunction btMultiSapBroadphase_btMultiSapProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMultiSapBroadphase_btMultiSapProxy6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSapBroadphase_btMultiSapProxy__rt{tis}
btMultiSapBroadphase_btMultiSapProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0}}}) {
    return btMultiSapBroadphase_btMultiSapProxy6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btCompoundShape__rt{tis}
  m::cond{
    match_args{tis, {{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCompoundShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundShape__rt{tis}
btCompoundShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{bool,0}}}) {
    return btCompoundShape1(a0);
  }
}
private metafunction btMatrix3x3__rt{tis}
  m::cond{
    match_args{tis, {{btQuaternion,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMatrix3x3_1"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMatrix3x3_9"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMatrix3x3__rt{tis}
btMatrix3x3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btQuaternion,0}}}) {
    return btMatrix3x3_1(a0);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btMatrix3x3_9(a0,a1,a2,a3,a4,a5,a6,a7,a8);
  }
}
private metafunction btManifoldPoint__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btManifoldPoint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btManifoldPoint__rt{tis}
btManifoldPoint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btManifoldPoint4(a0,a1,a2,a3);
  }
}
private metafunction btHinge2Constraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,1},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btHinge2Constraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint__rt{tis}
btHinge2Constraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,1},{btVector3,1},{btVector3,1}}}) {
    return btHinge2Constraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btDbvtBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvtBroadphase1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvtBroadphase__rt{tis}
btDbvtBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btOverlappingPairCache},0}}}) {
    return btDbvtBroadphase1(a0);
  }
}
private metafunction btConeShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeShapeX2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShapeX__rt{tis}
btConeShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShapeX2(a0,a1);
  }
}
private metafunction btVector4__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btVector4_4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btVector4__rt{tis}
btVector4_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btVector4_4(a0,a1,a2,a3);
  }
}
private metafunction btAxisSweep3Internal_unsigned_short__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{ushort,0},{ushort,0},{ushort,0},{rptr{btOverlappingPairCache},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAxisSweep3Internal_unsigned_short7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3Internal_unsigned_short__rt{tis}
btAxisSweep3Internal_unsigned_short_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{ushort,0},{ushort,0},{ushort,0},{rptr{btOverlappingPairCache},0},{bool,0}}}) {
    return btAxisSweep3Internal_unsigned_short7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btCapsuleShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCapsuleShapeX2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShapeX__rt{tis}
btCapsuleShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShapeX2(a0,a1);
  }
}
private metafunction btRigidBody_upcast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody_upcast_btCollisionObject_cp"}},
    match_args{tis, {{rptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody_upcast_btCollisionObject_p"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_upcast__rt{tis}
btRigidBody_upcast(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0}}}) {
    return btRigidBody_upcast_btCollisionObject_cp(a0);
  } else if (match_args{tis, {{rptr{btCollisionObject},0}}}) {
    return btRigidBody_upcast_btCollisionObject_p(a0);
  }
}
private metafunction btDbvt_sStkCLN__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{rptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvt_sStkCLN2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_sStkCLN__rt{tis}
btDbvt_sStkCLN_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{rptr{btDbvtNode},0}}}) {
    return btDbvt_sStkCLN2(a0,a1);
  }
}
private metafunction btHashString__rt{tis}
  m::cond{
    match_args{tis, {{crptr{char},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHashString1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashString__rt{tis}
btHashString_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{char},0}}}) {
    return btHashString1(a0);
  }
}
private metafunction btConeShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeShapeZ2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShapeZ__rt{tis}
btConeShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShapeZ2(a0,a1);
  }
}
private metafunction btPoint2PointConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btPoint2PointConstraint2"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btPoint2PointConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoint2PointConstraint__rt{tis}
btPoint2PointConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btVector3,0}}}) {
    return btPoint2PointConstraint2(a0,a1);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}}) {
    return btPoint2PointConstraint4(a0,a1,a2,a3);
  }
}
private metafunction btBroadphasePair__rt{tis}
  m::cond{
    match_args{tis, {{btBroadphaseProxy,1},{btBroadphaseProxy,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btBroadphasePair2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBroadphasePair__rt{tis}
btBroadphasePair_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btBroadphaseProxy,1},{btBroadphaseProxy,1}}}) {
    return btBroadphasePair2(a0,a1);
  }
}
private metafunction btStackAlloc__rt{tis}
  m::cond{
    match_args{tis, {{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btStackAlloc1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btStackAlloc__rt{tis}
btStackAlloc_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{uint,0}}}) {
    return btStackAlloc1(a0);
  }
}
private metafunction btSliderConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSliderConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSliderConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint__rt{tis}
btSliderConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btSliderConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btSliderConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btCollisionDispatcher__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionDispatcher1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionDispatcher__rt{tis}
btCollisionDispatcher_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btCollisionConfiguration},0}}}) {
    return btCollisionDispatcher1(a0);
  }
}
private metafunction btAxisSweep3Internal_unsigned_int__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{uint,0},{uint,0},{uint,0},{rptr{btOverlappingPairCache},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAxisSweep3Internal_unsigned_int7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3Internal_unsigned_int__rt{tis}
btAxisSweep3Internal_unsigned_int_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{uint,0},{uint,0},{uint,0},{rptr{btOverlappingPairCache},0},{bool,0}}}) {
    return btAxisSweep3Internal_unsigned_int7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btSwapEndian__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSwapEndian_int"}},
    match_args{tis, {{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSwapEndian_uint"}},
    match_args{tis, {{short,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSwapEndian_short"}},
    match_args{tis, {{ushort,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSwapEndian_ushort"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSwapEndian__rt{tis}
btSwapEndian(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btSwapEndian_int(a0);
  } else if (match_args{tis, {{uint,0}}}) {
    return btSwapEndian_uint(a0);
  } else if (match_args{tis, {{short,0}}}) {
    return btSwapEndian_short(a0);
  } else if (match_args{tis, {{ushort,0}}}) {
    return btSwapEndian_ushort(a0);
  }
}
private metafunction btQuadWord__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuadWord4"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuadWord3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuadWord__rt{tis}
btQuadWord_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuadWord4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuadWord3(a0,a1,a2);
  }
}
private metafunction btTransformAabb__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btTransformAabb6"}},
    match_args{tis, {{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btTransformAabb5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTransformAabb__rt{tis}
btTransformAabb(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}}) {
    return btTransformAabb6(a0,a1,a2,a3,a4,a5);
  } else if (match_args{tis, {{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}}) {
    return btTransformAabb5(a0,a1,a2,a3,a4);
  }
}
private metafunction btPersistentManifold__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{crptr{btCollisionObject},0},{int,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btPersistentManifold5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPersistentManifold__rt{tis}
btPersistentManifold_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{crptr{btCollisionObject},0},{int,0},{btScalar,0},{btScalar,0}}}) {
    return btPersistentManifold5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSphereShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSphereShape__rt{tis}
btSphereShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0}}}) {
    return btSphereShape1(a0);
  }
}
private metafunction btAxisSweep3__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{ushort,0},{rptr{btOverlappingPairCache},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAxisSweep3_5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3__rt{tis}
btAxisSweep3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{ushort,0},{rptr{btOverlappingPairCache},0},{bool,0}}}) {
    return btAxisSweep3_5(a0,a1,a2,a3,a4);
  }
}
private metafunction btDbvt_sStkNP__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvt_sStkNP2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_sStkNP__rt{tis}
btDbvt_sStkNP_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{uint,0}}}) {
    return btDbvt_sStkNP2(a0,a1);
  }
}
private metafunction btBvhTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBvhTriangleMeshShape3"}},
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBvhTriangleMeshShape5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBvhTriangleMeshShape__rt{tis}
btBvhTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}}) {
    return btBvhTriangleMeshShape3(a0,a1,a2);
  } else if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btBvhTriangleMeshShape5(a0,a1,a2,a3,a4);
  }
}
private metafunction bt32BitAxisSweep3__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{uint,0},{rptr{btOverlappingPairCache},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "bt32BitAxisSweep3_5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
bt32BitAxisSweep3__rt{tis}
bt32BitAxisSweep3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{uint,0},{rptr{btOverlappingPairCache},0},{bool,0}}}) {
    return bt32BitAxisSweep3_5(a0,a1,a2,a3,a4);
  }
}
