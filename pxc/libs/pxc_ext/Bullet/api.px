public namespace Bullet::api "export-unsafe";
public import common -;
public import Bullet::base -;
public import container::raw -;
public import meta m;
public import meta::vararg va;
public metafunction BvhSubtreeInfoArray btAlignedObjectArray_btBvhSubtreeInfo;
public metafunction IndexedMeshArray btAlignedObjectArray_btIndexedMesh;
public tsvaluetype struct extern "::PHY_ScalarType" "extenum" PHY_ScalarType { }
public extern "PHY_FLOAT" PHY_ScalarType PHY_FLOAT;
public extern "PHY_DOUBLE" PHY_ScalarType PHY_DOUBLE;
public extern "PHY_INTEGER" PHY_ScalarType PHY_INTEGER;
public extern "PHY_SHORT" PHY_ScalarType PHY_SHORT;
public extern "PHY_FIXEDPOINT88" PHY_ScalarType PHY_FIXEDPOINT88;
public extern "PHY_UCHAR" PHY_ScalarType PHY_UCHAR;
public metafunction QuantizedNodeArray btAlignedObjectArray_btQuantizedBvhNode;
public threaded struct extern "::bt32BitAxisSweep3" "nodefault" bt32BitAxisSweep3(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, uint maxHandles_2, rptr{btOverlappingPairCache} pairCache_3, bool disableRaycastAccelerator_4)  {
  public metafunction __base__ {btAxisSweep3Internal_unsigned_int, btBroadphaseInterface};
  public function extern "resetPool" void resetPool(rptr{btDispatcher} _0);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback_0);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "quantize" void quantize(rptr{uint} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "printStats" void printStats();
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "getNumHandles" uint getNumHandles() const;
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "addHandle" uint addHandle(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} pOwner_2, short collisionFilterGroup_3, short collisionFilterMask_4, rptr{btDispatcher} dispatcher_5, rptr{void} multiSapProxy_6);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback_0);
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "updateHandle" void updateHandle(uint handle_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "removeHandle" void removeHandle(uint handle_0, rptr{btDispatcher} dispatcher_1);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_int_Handle} getHandle(uint index_0) const;
}
public tsvaluetype struct extern "::bt6DofFlags" "extenum" bt6DofFlags { }
public extern "BT_6DOF_FLAGS_CFM_NORM" bt6DofFlags BT_6DOF_FLAGS_CFM_NORM;
public extern "BT_6DOF_FLAGS_CFM_STOP" bt6DofFlags BT_6DOF_FLAGS_CFM_STOP;
public extern "BT_6DOF_FLAGS_ERP_STOP" bt6DofFlags BT_6DOF_FLAGS_ERP_STOP;
public threaded struct extern "::btAABB" btAABB {
  public function extern "has_collision" bool has_collision(btAABB const& other_0) const;
  public function extern "get_center_extend" void get_center_extend(btVector3 mutable& center_0, btVector3 mutable& extend_1) const;
  public function extern "collide_plane" bool collide_plane(btVector4 const& plane_0) const;
  public function extern "projection_interval" void projection_interval(btVector3 const& direction_0, btScalar mutable& vmin_1, btScalar mutable& vmax_2) const;
  public function extern "merge" void merge(btAABB const& box_0);
  public function extern "find_intersection" void find_intersection(btAABB const& other_0, btAABB mutable& intersection_1) const;
  public function extern "collide_ray" bool collide_ray(btVector3 const& vorigin_0, btVector3 const& vdir_1) const;
  public function extern "overlapping_trans_conservative" bool overlapping_trans_conservative(btAABB const& box_0, btTransform mutable& trans1_to_0_1) const;
  public function extern "invalidate" void invalidate();
  public function extern "appy_transform" void appy_transform(btTransform const& trans_0);
  public function extern "collide_triangle_exact" bool collide_triangle_exact(btVector3 const& p1_0, btVector3 const& p2_1, btVector3 const& p3_2, btVector4 const& triangle_plane_3) const;
  public function extern "increment_margin" void increment_margin(btScalar margin_0);
  public function extern "copy_with_margin" void copy_with_margin(btAABB const& other_0, btScalar margin_1);
  public btVector3 m_min;
  public btVector3 m_max;
}
public threaded struct extern "::btActionInterface" "nonmovable" btActionInterface {
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld_0, btScalar deltaTimeStep_1);
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer_0);
}
public threaded struct extern "::btActivatingCollisionAlgorithm" "nodefault" btActivatingCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public metafunction btAlignedAllocFunc meta::list{rptr{void}, size_t, int};
public threaded struct extern "::btAlignedAllocator<BT_QUANTIZED_BVH_NODE, 16u>" btAlignedAllocator_BT_QUANTIZED_BVH_NODE_16u {
}
public threaded struct extern "::btAlignedAllocator<CHull*, 16u>" btAlignedAllocator_CHull_p_16u {
}
public threaded struct extern "::btAlignedAllocator<GIM_BVH_DATA, 16u>" btAlignedAllocator_GIM_BVH_DATA_16u {
}
public threaded struct extern "::btAlignedAllocator<GIM_BVH_TREE_NODE, 16u>" btAlignedAllocator_GIM_BVH_TREE_NODE_16u {
}
public threaded struct extern "::btAlignedAllocator<GIM_PAIR, 16u>" btAlignedAllocator_GIM_PAIR_16u {
}
public threaded struct extern "::btAlignedAllocator<GrahamVector3, 16u>" btAlignedAllocator_GrahamVector3_16u {
}
public threaded struct extern "::btAlignedAllocator<bParse::bChunkInd, 16u>" btAlignedAllocator_bParse_bChunkInd_16u {
}
public threaded struct extern "::btAlignedAllocator<bParse::bNameInfo, 16u>" btAlignedAllocator_bParse_bNameInfo_16u {
}
public threaded struct extern "::btAlignedAllocator<bParse::bStructHandle*, 16u>" btAlignedAllocator_bParse_bStructHandle_p_16u {
}
public threaded struct extern "::btAlignedAllocator<bool, 16u>" btAlignedAllocator_bool_16u {
  public function extern "deallocate" void deallocate(rptr{bool} ptr_0);
  public function extern "destroy" void destroy(rptr{bool} ptr_0);
  public function extern "address" rptr{bool} address(bool mutable& ref_0) const;
  public function extern "allocate" rptr{bool} allocate(size_type n_0, rptr{crptr{bool}} hint_1);
  public function extern "construct" void construct(rptr{bool} ptr_0, bool const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btActionInterface*, 16u>" btAlignedAllocator_btActionInterface_p_16u {
  public function extern "construct" void construct(rptr{rptr{btActionInterface}} ptr_0, rptr{btActionInterface} const& value_1);
  public function extern "allocate" rptr{rptr{btActionInterface}} allocate(size_type n_0, rptr{crptr{rptr{btActionInterface}}} hint_1);
  public function extern "address" rptr{rptr{btActionInterface}} address(rptr{btActionInterface} mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{rptr{btActionInterface}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btActionInterface}} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btAlignedObjectArray<int>, 16u>" btAlignedAllocator_btAlignedObjectArray_int_16u {
  public function extern "allocate" rptr{btAlignedObjectArray_int} allocate(size_type n_0, rptr{crptr{btAlignedObjectArray_int}} hint_1);
  public function extern "construct" void construct(rptr{btAlignedObjectArray_int} ptr_0, btAlignedObjectArray_int const& value_1);
  public function extern "destroy" void destroy(rptr{btAlignedObjectArray_int} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btAlignedObjectArray_int} ptr_0);
  public function extern "address" rptr{btAlignedObjectArray_int} address(btAlignedObjectArray_int mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btBroadphaseInterface*, 16u>" btAlignedAllocator_btBroadphaseInterface_p_16u {
  public function extern "address" rptr{rptr{btBroadphaseInterface}} address(rptr{btBroadphaseInterface} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{btBroadphaseInterface}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btBroadphaseInterface}} ptr_0);
  public function extern "allocate" rptr{rptr{btBroadphaseInterface}} allocate(size_type n_0, rptr{crptr{rptr{btBroadphaseInterface}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btBroadphaseInterface}} ptr_0, rptr{btBroadphaseInterface} const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btBroadphasePair, 16u>" btAlignedAllocator_btBroadphasePair_16u {
  public function extern "destroy" void destroy(rptr{btBroadphasePair} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btBroadphasePair} ptr_0);
  public function extern "address" rptr{btBroadphasePair} address(btBroadphasePair mutable& ref_0) const;
  public function extern "construct" void construct(rptr{btBroadphasePair} ptr_0, btBroadphasePair const& value_1);
  public function extern "allocate" rptr{btBroadphasePair} allocate(size_type n_0, rptr{crptr{btBroadphasePair}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btBvhSubtreeInfo, 16u>" btAlignedAllocator_btBvhSubtreeInfo_16u {
  public function extern "destroy" void destroy(rptr{btBvhSubtreeInfo} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btBvhSubtreeInfo} ptr_0);
  public function extern "address" rptr{btBvhSubtreeInfo} address(btBvhSubtreeInfo mutable& ref_0) const;
  public function extern "construct" void construct(rptr{btBvhSubtreeInfo} ptr_0, btBvhSubtreeInfo const& value_1);
  public function extern "allocate" rptr{btBvhSubtreeInfo} allocate(size_type n_0, rptr{crptr{btBvhSubtreeInfo}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btChunk*, 16u>" btAlignedAllocator_btChunk_p_16u {
  public function extern "address" rptr{rptr{btChunk}} address(rptr{btChunk} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{btChunk}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btChunk}} ptr_0);
  public function extern "allocate" rptr{rptr{btChunk}} allocate(size_type n_0, rptr{crptr{rptr{btChunk}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btChunk}} ptr_0, rptr{btChunk} const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btCollisionAlgorithm*, 16u>" btAlignedAllocator_btCollisionAlgorithm_p_16u {
  public function extern "address" rptr{rptr{btCollisionAlgorithm}} address(rptr{btCollisionAlgorithm} mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{rptr{btCollisionAlgorithm}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btCollisionAlgorithm}} ptr_0);
  public function extern "allocate" rptr{rptr{btCollisionAlgorithm}} allocate(size_type n_0, rptr{crptr{rptr{btCollisionAlgorithm}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btCollisionAlgorithm}} ptr_0, rptr{btCollisionAlgorithm} const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btCollisionObject const*, 16u>" btAlignedAllocator_btCollisionObject_const_p_16u {
  public function extern "address" rptr{crptr{btCollisionObject}} address(crptr{btCollisionObject} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{crptr{btCollisionObject}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{crptr{btCollisionObject}} ptr_0);
  public function extern "construct" void construct(rptr{crptr{btCollisionObject}} ptr_0, crptr{btCollisionObject} const& value_1);
  public function extern "allocate" rptr{crptr{btCollisionObject}} allocate(size_type n_0, rptr{crptr{crptr{btCollisionObject}}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btCollisionObject*, 16u>" btAlignedAllocator_btCollisionObject_p_16u {
  public function extern "address" rptr{rptr{btCollisionObject}} address(rptr{btCollisionObject} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{btCollisionObject}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btCollisionObject}} ptr_0);
  public function extern "construct" void construct(rptr{rptr{btCollisionObject}} ptr_0, rptr{btCollisionObject} const& value_1);
  public function extern "allocate" rptr{rptr{btCollisionObject}} allocate(size_type n_0, rptr{crptr{rptr{btCollisionObject}}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btCollisionShape*, 16u>" btAlignedAllocator_btCollisionShape_p_16u {
  public function extern "address" rptr{rptr{btCollisionShape}} address(rptr{btCollisionShape} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{btCollisionShape}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btCollisionShape}} ptr_0);
  public function extern "allocate" rptr{rptr{btCollisionShape}} allocate(size_type n_0, rptr{crptr{rptr{btCollisionShape}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btCollisionShape}} ptr_0, rptr{btCollisionShape} const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btCompoundShapeChild, 16u>" btAlignedAllocator_btCompoundShapeChild_16u {
  public function extern "address" rptr{btCompoundShapeChild} address(btCompoundShapeChild mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btCompoundShapeChild} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btCompoundShapeChild} ptr_0);
  public function extern "construct" void construct(rptr{btCompoundShapeChild} ptr_0, btCompoundShapeChild const& value_1);
  public function extern "allocate" rptr{btCompoundShapeChild} allocate(size_type n_0, rptr{crptr{btCompoundShapeChild}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btConvexHullComputer::Edge, 16u>" btAlignedAllocator_btConvexHullComputer_Edge_16u {
  public function extern "destroy" void destroy(rptr{btConvexHullComputer_Edge} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btConvexHullComputer_Edge} ptr_0);
  public function extern "address" rptr{btConvexHullComputer_Edge} address(btConvexHullComputer_Edge mutable& ref_0) const;
  public function extern "allocate" rptr{btConvexHullComputer_Edge} allocate(size_type n_0, rptr{crptr{btConvexHullComputer_Edge}} hint_1);
  public function extern "construct" void construct(rptr{btConvexHullComputer_Edge} ptr_0, btConvexHullComputer_Edge const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btDbvtNode const*, 16u>" btAlignedAllocator_btDbvtNode_const_p_16u {
  public function extern "allocate" rptr{crptr{btDbvtNode}} allocate(size_type n_0, rptr{crptr{crptr{btDbvtNode}}} hint_1);
  public function extern "construct" void construct(rptr{crptr{btDbvtNode}} ptr_0, crptr{btDbvtNode} const& value_1);
  public function extern "address" rptr{crptr{btDbvtNode}} address(crptr{btDbvtNode} mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{crptr{btDbvtNode}} ptr_0);
  public function extern "destroy" void destroy(rptr{crptr{btDbvtNode}} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNN, 16u>" btAlignedAllocator_btDbvt_sStkNN_16u {
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNN} ptr_0);
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNN} ptr_0);
  public function extern "address" rptr{btDbvt_sStkNN} address(btDbvt_sStkNN mutable& ref_0) const;
  public function extern "allocate" rptr{btDbvt_sStkNN} allocate(size_type n_0, rptr{crptr{btDbvt_sStkNN}} hint_1);
  public function extern "construct" void construct(rptr{btDbvt_sStkNN} ptr_0, btDbvt_sStkNN const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNPS, 16u>" btAlignedAllocator_btDbvt_sStkNPS_16u {
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNPS} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNPS} ptr_0);
  public function extern "address" rptr{btDbvt_sStkNPS} address(btDbvt_sStkNPS mutable& ref_0) const;
  public function extern "allocate" rptr{btDbvt_sStkNPS} allocate(size_type n_0, rptr{crptr{btDbvt_sStkNPS}} hint_1);
  public function extern "construct" void construct(rptr{btDbvt_sStkNPS} ptr_0, btDbvt_sStkNPS const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNP, 16u>" btAlignedAllocator_btDbvt_sStkNP_16u {
  public function extern "address" rptr{btDbvt_sStkNP} address(btDbvt_sStkNP mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNP} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNP} ptr_0);
  public function extern "construct" void construct(rptr{btDbvt_sStkNP} ptr_0, btDbvt_sStkNP const& value_1);
  public function extern "allocate" rptr{btDbvt_sStkNP} allocate(size_type n_0, rptr{crptr{btDbvt_sStkNP}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btElement, 16u>" btAlignedAllocator_btElement_16u {
  public function extern "allocate" rptr{btElement} allocate(size_type n_0, rptr{crptr{btElement}} hint_1);
  public function extern "construct" void construct(rptr{btElement} ptr_0, btElement const& value_1);
  public function extern "deallocate" void deallocate(rptr{btElement} ptr_0);
  public function extern "destroy" void destroy(rptr{btElement} ptr_0);
  public function extern "address" rptr{btElement} address(btElement mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btFace, 16u>" btAlignedAllocator_btFace_16u {
  public function extern "construct" void construct(rptr{btFace} ptr_0, btFace const& value_1);
  public function extern "allocate" rptr{btFace} allocate(size_type n_0, rptr{crptr{btFace}} hint_1);
  public function extern "address" rptr{btFace} address(btFace mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btFace} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btFace} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btGImpactMeshShapePart::TrimeshPrimitiveManager, 16u>" btAlignedAllocator_btGImpactMeshShapePart_TrimeshPrimitiveManager_16u {
  public function extern "construct" void construct(rptr{btGImpactMeshShapePart_TrimeshPrimitiveManager} ptr_0, btGImpactMeshShapePart_TrimeshPrimitiveManager const& value_1);
  public function extern "allocate" rptr{btGImpactMeshShapePart_TrimeshPrimitiveManager} allocate(size_type n_0, rptr{crptr{btGImpactMeshShapePart_TrimeshPrimitiveManager}} hint_1);
  public function extern "address" rptr{btGImpactMeshShapePart_TrimeshPrimitiveManager} address(btGImpactMeshShapePart_TrimeshPrimitiveManager mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btGImpactMeshShapePart_TrimeshPrimitiveManager} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btGImpactMeshShapePart_TrimeshPrimitiveManager} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btGImpactMeshShapePart*, 16u>" btAlignedAllocator_btGImpactMeshShapePart_p_16u {
  public function extern "construct" void construct(rptr{rptr{btGImpactMeshShapePart}} ptr_0, rptr{btGImpactMeshShapePart} const& value_1);
  public function extern "allocate" rptr{rptr{btGImpactMeshShapePart}} allocate(size_type n_0, rptr{crptr{rptr{btGImpactMeshShapePart}}} hint_1);
  public function extern "destroy" void destroy(rptr{rptr{btGImpactMeshShapePart}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btGImpactMeshShapePart}} ptr_0);
  public function extern "address" rptr{rptr{btGImpactMeshShapePart}} address(rptr{btGImpactMeshShapePart} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btHashInt, 16u>" btAlignedAllocator_btHashInt_16u {
  public function extern "address" rptr{btHashInt} address(btHashInt mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{btHashInt} ptr_0);
  public function extern "destroy" void destroy(rptr{btHashInt} ptr_0);
  public function extern "construct" void construct(rptr{btHashInt} ptr_0, btHashInt const& value_1);
  public function extern "allocate" rptr{btHashInt} allocate(size_type n_0, rptr{crptr{btHashInt}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btHashKey<btTriIndex>, 16u>" btAlignedAllocator_btHashKey_btTriIndex_16u {
  public function extern "destroy" void destroy(rptr{btHashKey_btTriIndex} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btHashKey_btTriIndex} ptr_0);
  public function extern "address" rptr{btHashKey_btTriIndex} address(btHashKey_btTriIndex mutable& ref_0) const;
  public function extern "construct" void construct(rptr{btHashKey_btTriIndex} ptr_0, btHashKey_btTriIndex const& value_1);
  public function extern "allocate" rptr{btHashKey_btTriIndex} allocate(size_type n_0, rptr{crptr{btHashKey_btTriIndex}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btHashPtr, 16u>" btAlignedAllocator_btHashPtr_16u {
  public function extern "allocate" rptr{btHashPtr} allocate(size_type n_0, rptr{crptr{btHashPtr}} hint_1);
  public function extern "construct" void construct(rptr{btHashPtr} ptr_0, btHashPtr const& value_1);
  public function extern "address" rptr{btHashPtr} address(btHashPtr mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{btHashPtr} ptr_0);
  public function extern "destroy" void destroy(rptr{btHashPtr} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btHashString, 16u>" btAlignedAllocator_btHashString_16u {
  public function extern "construct" void construct(rptr{btHashString} ptr_0, btHashString const& value_1);
  public function extern "allocate" rptr{btHashString} allocate(size_type n_0, rptr{crptr{btHashString}} hint_1);
  public function extern "address" rptr{btHashString} address(btHashString mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{btHashString} ptr_0);
  public function extern "destroy" void destroy(rptr{btHashString} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btIndexedMesh, 16u>" btAlignedAllocator_btIndexedMesh_16u {
  public function extern "allocate" rptr{btIndexedMesh} allocate(size_type n_0, rptr{crptr{btIndexedMesh}} hint_1);
  public function extern "construct" void construct(rptr{btIndexedMesh} ptr_0, btIndexedMesh const& value_1);
  public function extern "address" rptr{btIndexedMesh} address(btIndexedMesh mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btIndexedMesh} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btIndexedMesh} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btMaterialProperties, 16u>" btAlignedAllocator_btMaterialProperties_16u {
  public function extern "construct" void construct(rptr{btMaterialProperties} ptr_0, btMaterialProperties const& value_1);
  public function extern "allocate" rptr{btMaterialProperties} allocate(size_type n_0, rptr{crptr{btMaterialProperties}} hint_1);
  public function extern "destroy" void destroy(rptr{btMaterialProperties} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btMaterialProperties} ptr_0);
  public function extern "address" rptr{btMaterialProperties} address(btMaterialProperties mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btMaterial*, 16u>" btAlignedAllocator_btMaterial_p_16u {
  public function extern "construct" void construct(rptr{rptr{btMaterial}} ptr_0, rptr{btMaterial} const& value_1);
  public function extern "allocate" rptr{rptr{btMaterial}} allocate(size_type n_0, rptr{crptr{rptr{btMaterial}}} hint_1);
  public function extern "deallocate" void deallocate(rptr{rptr{btMaterial}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btMaterial}} ptr_0);
  public function extern "address" rptr{rptr{btMaterial}} address(rptr{btMaterial} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>" btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16u {
  public function extern "allocate" rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} allocate(size_type n_0, rptr{crptr{rptr{btMultiSapBroadphase_btBridgeProxy}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr_0, rptr{btMultiSapBroadphase_btBridgeProxy} const& value_1);
  public function extern "destroy" void destroy(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr_0);
  public function extern "address" rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} address(rptr{btMultiSapBroadphase_btBridgeProxy} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>" btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16u {
  public function extern "construct" void construct(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr_0, rptr{btMultiSapBroadphase_btMultiSapProxy} const& value_1);
  public function extern "allocate" rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} allocate(size_type n_0, rptr{crptr{rptr{btMultiSapBroadphase_btMultiSapProxy}}} hint_1);
  public function extern "deallocate" void deallocate(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr_0);
  public function extern "address" rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} address(rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btOptimizedBvhNode, 16u>" btAlignedAllocator_btOptimizedBvhNode_16u {
  public function extern "allocate" rptr{btOptimizedBvhNode} allocate(size_type n_0, rptr{crptr{btOptimizedBvhNode}} hint_1);
  public function extern "construct" void construct(rptr{btOptimizedBvhNode} ptr_0, btOptimizedBvhNode const& value_1);
  public function extern "destroy" void destroy(rptr{btOptimizedBvhNode} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btOptimizedBvhNode} ptr_0);
  public function extern "address" rptr{btOptimizedBvhNode} address(btOptimizedBvhNode mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btOptimizedBvh*, 16u>" btAlignedAllocator_btOptimizedBvh_p_16u {
  public function extern "address" rptr{rptr{btOptimizedBvh}} address(rptr{btOptimizedBvh} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{btOptimizedBvh}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btOptimizedBvh}} ptr_0);
  public function extern "construct" void construct(rptr{rptr{btOptimizedBvh}} ptr_0, rptr{btOptimizedBvh} const& value_1);
  public function extern "allocate" rptr{rptr{btOptimizedBvh}} allocate(size_type n_0, rptr{crptr{rptr{btOptimizedBvh}}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btPersistentManifold*, 16u>" btAlignedAllocator_btPersistentManifold_p_16u {
  public function extern "address" rptr{rptr{btPersistentManifold}} address(rptr{btPersistentManifold} mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{rptr{btPersistentManifold}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btPersistentManifold}} ptr_0);
  public function extern "construct" void construct(rptr{rptr{btPersistentManifold}} ptr_0, rptr{btPersistentManifold} const& value_1);
  public function extern "allocate" rptr{rptr{btPersistentManifold}} allocate(size_type n_0, rptr{crptr{rptr{btPersistentManifold}}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btPointerUid, 16u>" btAlignedAllocator_btPointerUid_16u {
  public function extern "construct" void construct(rptr{btPointerUid} ptr_0, btPointerUid const& value_1);
  public function extern "allocate" rptr{btPointerUid} allocate(size_type n_0, rptr{crptr{btPointerUid}} hint_1);
  public function extern "destroy" void destroy(rptr{btPointerUid} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btPointerUid} ptr_0);
  public function extern "address" rptr{btPointerUid} address(btPointerUid mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btQuantizedBvhNode, 16u>" btAlignedAllocator_btQuantizedBvhNode_16u {
  public function extern "construct" void construct(rptr{btQuantizedBvhNode} ptr_0, btQuantizedBvhNode const& value_1);
  public function extern "allocate" rptr{btQuantizedBvhNode} allocate(size_type n_0, rptr{crptr{btQuantizedBvhNode}} hint_1);
  public function extern "address" rptr{btQuantizedBvhNode} address(btQuantizedBvhNode mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btQuantizedBvhNode} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btQuantizedBvhNode} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btRigidBody*, 16u>" btAlignedAllocator_btRigidBody_p_16u {
  public function extern "allocate" rptr{rptr{btRigidBody}} allocate(size_type n_0, rptr{crptr{rptr{btRigidBody}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btRigidBody}} ptr_0, rptr{btRigidBody} const& value_1);
  public function extern "address" rptr{rptr{btRigidBody}} address(rptr{btRigidBody} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{btRigidBody}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btRigidBody}} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btSimplePair, 16u>" btAlignedAllocator_btSimplePair_16u {
  public function extern "deallocate" void deallocate(rptr{btSimplePair} ptr_0);
  public function extern "destroy" void destroy(rptr{btSimplePair} ptr_0);
  public function extern "address" rptr{btSimplePair} address(btSimplePair mutable& ref_0) const;
  public function extern "construct" void construct(rptr{btSimplePair} ptr_0, btSimplePair const& value_1);
  public function extern "allocate" rptr{btSimplePair} allocate(size_type n_0, rptr{crptr{btSimplePair}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Anchor, 16u>" btAlignedAllocator_btSoftBody_Anchor_16u {
  public function extern "address" rptr{btSoftBody_Anchor} address(btSoftBody_Anchor mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btSoftBody_Anchor} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btSoftBody_Anchor} ptr_0);
  public function extern "construct" void construct(rptr{btSoftBody_Anchor} ptr_0, btSoftBody_Anchor const& value_1);
  public function extern "allocate" rptr{btSoftBody_Anchor} allocate(size_type n_0, rptr{crptr{btSoftBody_Anchor}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Cluster*, 16u>" btAlignedAllocator_btSoftBody_Cluster_p_16u {
  public function extern "allocate" rptr{rptr{btSoftBody_Cluster}} allocate(size_type n_0, rptr{crptr{rptr{btSoftBody_Cluster}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btSoftBody_Cluster}} ptr_0, rptr{btSoftBody_Cluster} const& value_1);
  public function extern "address" rptr{rptr{btSoftBody_Cluster}} address(rptr{btSoftBody_Cluster} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{btSoftBody_Cluster}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btSoftBody_Cluster}} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Face, 16u>" btAlignedAllocator_btSoftBody_Face_16u {
  public function extern "construct" void construct(rptr{btSoftBody_Face} ptr_0, btSoftBody_Face const& value_1);
  public function extern "allocate" rptr{btSoftBody_Face} allocate(size_type n_0, rptr{crptr{btSoftBody_Face}} hint_1);
  public function extern "address" rptr{btSoftBody_Face} address(btSoftBody_Face mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btSoftBody_Face} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btSoftBody_Face} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Joint*, 16u>" btAlignedAllocator_btSoftBody_Joint_p_16u {
  public function extern "destroy" void destroy(rptr{rptr{btSoftBody_Joint}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btSoftBody_Joint}} ptr_0);
  public function extern "address" rptr{rptr{btSoftBody_Joint}} address(rptr{btSoftBody_Joint} mutable& ref_0) const;
  public function extern "allocate" rptr{rptr{btSoftBody_Joint}} allocate(size_type n_0, rptr{crptr{rptr{btSoftBody_Joint}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btSoftBody_Joint}} ptr_0, rptr{btSoftBody_Joint} const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Link, 16u>" btAlignedAllocator_btSoftBody_Link_16u {
  public function extern "address" rptr{btSoftBody_Link} address(btSoftBody_Link mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{btSoftBody_Link} ptr_0);
  public function extern "destroy" void destroy(rptr{btSoftBody_Link} ptr_0);
  public function extern "allocate" rptr{btSoftBody_Link} allocate(size_type n_0, rptr{crptr{btSoftBody_Link}} hint_1);
  public function extern "construct" void construct(rptr{btSoftBody_Link} ptr_0, btSoftBody_Link const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Material*, 16u>" btAlignedAllocator_btSoftBody_Material_p_16u {
  public function extern "destroy" void destroy(rptr{rptr{btSoftBody_Material}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btSoftBody_Material}} ptr_0);
  public function extern "address" rptr{rptr{btSoftBody_Material}} address(rptr{btSoftBody_Material} mutable& ref_0) const;
  public function extern "allocate" rptr{rptr{btSoftBody_Material}} allocate(size_type n_0, rptr{crptr{rptr{btSoftBody_Material}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btSoftBody_Material}} ptr_0, rptr{btSoftBody_Material} const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Node, 16u>" btAlignedAllocator_btSoftBody_Node_16u {
  public function extern "deallocate" void deallocate(rptr{btSoftBody_Node} ptr_0);
  public function extern "destroy" void destroy(rptr{btSoftBody_Node} ptr_0);
  public function extern "address" rptr{btSoftBody_Node} address(btSoftBody_Node mutable& ref_0) const;
  public function extern "construct" void construct(rptr{btSoftBody_Node} ptr_0, btSoftBody_Node const& value_1);
  public function extern "allocate" rptr{btSoftBody_Node} allocate(size_type n_0, rptr{crptr{btSoftBody_Node}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Node*, 16u>" btAlignedAllocator_btSoftBody_Node_p_16u {
  public function extern "deallocate" void deallocate(rptr{rptr{btSoftBody_Node}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btSoftBody_Node}} ptr_0);
  public function extern "address" rptr{rptr{btSoftBody_Node}} address(rptr{btSoftBody_Node} mutable& ref_0) const;
  public function extern "construct" void construct(rptr{rptr{btSoftBody_Node}} ptr_0, rptr{btSoftBody_Node} const& value_1);
  public function extern "allocate" rptr{rptr{btSoftBody_Node}} allocate(size_type n_0, rptr{crptr{rptr{btSoftBody_Node}}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Note, 16u>" btAlignedAllocator_btSoftBody_Note_16u {
  public function extern "deallocate" void deallocate(rptr{btSoftBody_Note} ptr_0);
  public function extern "destroy" void destroy(rptr{btSoftBody_Note} ptr_0);
  public function extern "address" rptr{btSoftBody_Note} address(btSoftBody_Note mutable& ref_0) const;
  public function extern "allocate" rptr{btSoftBody_Note} allocate(size_type n_0, rptr{crptr{btSoftBody_Note}} hint_1);
  public function extern "construct" void construct(rptr{btSoftBody_Note} ptr_0, btSoftBody_Note const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::RContact, 16u>" btAlignedAllocator_btSoftBody_RContact_16u {
  public function extern "allocate" rptr{btSoftBody_RContact} allocate(size_type n_0, rptr{crptr{btSoftBody_RContact}} hint_1);
  public function extern "construct" void construct(rptr{btSoftBody_RContact} ptr_0, btSoftBody_RContact const& value_1);
  public function extern "deallocate" void deallocate(rptr{btSoftBody_RContact} ptr_0);
  public function extern "destroy" void destroy(rptr{btSoftBody_RContact} ptr_0);
  public function extern "address" rptr{btSoftBody_RContact} address(btSoftBody_RContact mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::SContact, 16u>" btAlignedAllocator_btSoftBody_SContact_16u {
  public function extern "allocate" rptr{btSoftBody_SContact} allocate(size_type n_0, rptr{crptr{btSoftBody_SContact}} hint_1);
  public function extern "construct" void construct(rptr{btSoftBody_SContact} ptr_0, btSoftBody_SContact const& value_1);
  public function extern "deallocate" void deallocate(rptr{btSoftBody_SContact} ptr_0);
  public function extern "destroy" void destroy(rptr{btSoftBody_SContact} ptr_0);
  public function extern "address" rptr{btSoftBody_SContact} address(btSoftBody_SContact mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::Tetra, 16u>" btAlignedAllocator_btSoftBody_Tetra_16u {
  public function extern "destroy" void destroy(rptr{btSoftBody_Tetra} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btSoftBody_Tetra} ptr_0);
  public function extern "address" rptr{btSoftBody_Tetra} address(btSoftBody_Tetra mutable& ref_0) const;
  public function extern "construct" void construct(rptr{btSoftBody_Tetra} ptr_0, btSoftBody_Tetra const& value_1);
  public function extern "allocate" rptr{btSoftBody_Tetra} allocate(size_type n_0, rptr{crptr{btSoftBody_Tetra}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::ePSolver::_, 16u>" btAlignedAllocator_btSoftBody_ePSolver_16u {
}
public threaded struct extern "::btAlignedAllocator<btSoftBody::eVSolver::_, 16u>" btAlignedAllocator_btSoftBody_eVSolver_16u {
}
public threaded struct extern "::btAlignedAllocator<btSoftBody*, 16u>" btAlignedAllocator_btSoftBody_p_16u {
  public function extern "allocate" rptr{rptr{btSoftBody}} allocate(size_type n_0, rptr{crptr{rptr{btSoftBody}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btSoftBody}} ptr_0, rptr{btSoftBody} const& value_1);
  public function extern "deallocate" void deallocate(rptr{rptr{btSoftBody}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btSoftBody}} ptr_0);
  public function extern "address" rptr{rptr{btSoftBody}} address(rptr{btSoftBody} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btSolverBody, 16u>" btAlignedAllocator_btSolverBody_16u {
  public function extern "allocate" rptr{btSolverBody} allocate(size_type n_0, rptr{crptr{btSolverBody}} hint_1);
  public function extern "construct" void construct(rptr{btSolverBody} ptr_0, btSolverBody const& value_1);
  public function extern "deallocate" void deallocate(rptr{btSolverBody} ptr_0);
  public function extern "destroy" void destroy(rptr{btSolverBody} ptr_0);
  public function extern "address" rptr{btSolverBody} address(btSolverBody mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btSolverConstraint, 16u>" btAlignedAllocator_btSolverConstraint_16u {
  public function extern "address" rptr{btSolverConstraint} address(btSolverConstraint mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{btSolverConstraint} ptr_0);
  public function extern "destroy" void destroy(rptr{btSolverConstraint} ptr_0);
  public function extern "allocate" rptr{btSolverConstraint} allocate(size_type n_0, rptr{crptr{btSolverConstraint}} hint_1);
  public function extern "construct" void construct(rptr{btSolverConstraint} ptr_0, btSolverConstraint const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btSparseSdf<3>::Cell*, 16u>" btAlignedAllocator_btSparseSdf_3_Cell_p_16u {
  public function extern "construct" void construct(rptr{rptr{btSparseSdf_3_Cell}} ptr_0, rptr{btSparseSdf_3_Cell} const& value_1);
  public function extern "allocate" rptr{rptr{btSparseSdf_3_Cell}} allocate(size_type n_0, rptr{crptr{rptr{btSparseSdf_3_Cell}}} hint_1);
  public function extern "destroy" void destroy(rptr{rptr{btSparseSdf_3_Cell}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btSparseSdf_3_Cell}} ptr_0);
  public function extern "address" rptr{rptr{btSparseSdf_3_Cell}} address(rptr{btSparseSdf_3_Cell} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btStridingMeshInterfaceData*, 16u>" btAlignedAllocator_btStridingMeshInterfaceData_p_16u {
  public function extern "allocate" rptr{rptr{btStridingMeshInterfaceData}} allocate(size_type n_0, rptr{crptr{rptr{btStridingMeshInterfaceData}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btStridingMeshInterfaceData}} ptr_0, rptr{btStridingMeshInterfaceData} const& value_1);
  public function extern "address" rptr{rptr{btStridingMeshInterfaceData}} address(rptr{btStridingMeshInterfaceData} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{btStridingMeshInterfaceData}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btStridingMeshInterfaceData}} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btTransform, 16u>" btAlignedAllocator_btTransform_16u {
  public function extern "allocate" rptr{btTransform} allocate(size_type n_0, rptr{crptr{btTransform}} hint_1);
  public function extern "construct" void construct(rptr{btTransform} ptr_0, btTransform const& value_1);
  public function extern "address" rptr{btTransform} address(btTransform mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btTransform} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btTransform} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<btTriIndex, 16u>" btAlignedAllocator_btTriIndex_16u {
  public function extern "destroy" void destroy(rptr{btTriIndex} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btTriIndex} ptr_0);
  public function extern "address" rptr{btTriIndex} address(btTriIndex mutable& ref_0) const;
  public function extern "construct" void construct(rptr{btTriIndex} ptr_0, btTriIndex const& value_1);
  public function extern "allocate" rptr{btTriIndex} allocate(size_type n_0, rptr{crptr{btTriIndex}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btTriangleIndexVertexArray*, 16u>" btAlignedAllocator_btTriangleIndexVertexArray_p_16u {
  public function extern "deallocate" void deallocate(rptr{rptr{btTriangleIndexVertexArray}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btTriangleIndexVertexArray}} ptr_0);
  public function extern "address" rptr{rptr{btTriangleIndexVertexArray}} address(rptr{btTriangleIndexVertexArray} mutable& ref_0) const;
  public function extern "construct" void construct(rptr{rptr{btTriangleIndexVertexArray}} ptr_0, rptr{btTriangleIndexVertexArray} const& value_1);
  public function extern "allocate" rptr{rptr{btTriangleIndexVertexArray}} allocate(size_type n_0, rptr{crptr{rptr{btTriangleIndexVertexArray}}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btTriangleInfoMap*, 16u>" btAlignedAllocator_btTriangleInfoMap_p_16u {
  public function extern "deallocate" void deallocate(rptr{rptr{btTriangleInfoMap}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{btTriangleInfoMap}} ptr_0);
  public function extern "address" rptr{rptr{btTriangleInfoMap}} address(rptr{btTriangleInfoMap} mutable& ref_0) const;
  public function extern "construct" void construct(rptr{rptr{btTriangleInfoMap}} ptr_0, rptr{btTriangleInfoMap} const& value_1);
  public function extern "allocate" rptr{rptr{btTriangleInfoMap}} allocate(size_type n_0, rptr{crptr{rptr{btTriangleInfoMap}}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btTriangleInfo, 16u>" btAlignedAllocator_btTriangleInfo_16u {
  public function extern "destroy" void destroy(rptr{btTriangleInfo} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btTriangleInfo} ptr_0);
  public function extern "address" rptr{btTriangleInfo} address(btTriangleInfo mutable& ref_0) const;
  public function extern "allocate" rptr{btTriangleInfo} allocate(size_type n_0, rptr{crptr{btTriangleInfo}} hint_1);
  public function extern "construct" void construct(rptr{btTriangleInfo} ptr_0, btTriangleInfo const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btTriangle, 16u>" btAlignedAllocator_btTriangle_16u {
  public function extern "destroy" void destroy(rptr{btTriangle} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btTriangle} ptr_0);
  public function extern "address" rptr{btTriangle} address(btTriangle mutable& ref_0) const;
  public function extern "construct" void construct(rptr{btTriangle} ptr_0, btTriangle const& value_1);
  public function extern "allocate" rptr{btTriangle} allocate(size_type n_0, rptr{crptr{btTriangle}} hint_1);
}
public threaded struct extern "::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>" btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u {
  public function extern "deallocate" void deallocate(rptr{btTypedConstraint_btConstraintInfo1} ptr_0);
  public function extern "destroy" void destroy(rptr{btTypedConstraint_btConstraintInfo1} ptr_0);
  public function extern "address" rptr{btTypedConstraint_btConstraintInfo1} address(btTypedConstraint_btConstraintInfo1 mutable& ref_0) const;
  public function extern "allocate" rptr{btTypedConstraint_btConstraintInfo1} allocate(size_type n_0, rptr{crptr{btTypedConstraint_btConstraintInfo1}} hint_1);
  public function extern "construct" void construct(rptr{btTypedConstraint_btConstraintInfo1} ptr_0, btTypedConstraint_btConstraintInfo1 const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btTypedConstraint*, 16u>" btAlignedAllocator_btTypedConstraint_p_16u {
  public function extern "construct" void construct(rptr{rptr{btTypedConstraint}} ptr_0, rptr{btTypedConstraint} const& value_1);
  public function extern "allocate" rptr{rptr{btTypedConstraint}} allocate(size_type n_0, rptr{crptr{rptr{btTypedConstraint}}} hint_1);
  public function extern "destroy" void destroy(rptr{rptr{btTypedConstraint}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btTypedConstraint}} ptr_0);
  public function extern "address" rptr{rptr{btTypedConstraint}} address(rptr{btTypedConstraint} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btVector3DoubleData*, 16u>" btAlignedAllocator_btVector3DoubleData_p_16u {
  public function extern "allocate" rptr{rptr{btVector3DoubleData}} allocate(size_type n_0, rptr{crptr{rptr{btVector3DoubleData}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btVector3DoubleData}} ptr_0, rptr{btVector3DoubleData} const& value_1);
  public function extern "destroy" void destroy(rptr{rptr{btVector3DoubleData}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btVector3DoubleData}} ptr_0);
  public function extern "address" rptr{rptr{btVector3DoubleData}} address(rptr{btVector3DoubleData} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<btVector3FloatData*, 16u>" btAlignedAllocator_btVector3FloatData_p_16u {
  public function extern "destroy" void destroy(rptr{rptr{btVector3FloatData}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{btVector3FloatData}} ptr_0);
  public function extern "address" rptr{rptr{btVector3FloatData}} address(rptr{btVector3FloatData} mutable& ref_0) const;
  public function extern "allocate" rptr{rptr{btVector3FloatData}} allocate(size_type n_0, rptr{crptr{rptr{btVector3FloatData}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{btVector3FloatData}} ptr_0, rptr{btVector3FloatData} const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btVector3, 16u>" btAlignedAllocator_btVector3_16u {
  public function extern "address" rptr{btVector3} address(btVector3 mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btVector3} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btVector3} ptr_0);
  public function extern "allocate" rptr{btVector3} allocate(size_type n_0, rptr{crptr{btVector3}} hint_1);
  public function extern "construct" void construct(rptr{btVector3} ptr_0, btVector3 const& value_1);
}
public threaded struct extern "::btAlignedAllocator<btWheelInfo, 16u>" btAlignedAllocator_btWheelInfo_16u {
  public function extern "construct" void construct(rptr{btWheelInfo} ptr_0, btWheelInfo const& value_1);
  public function extern "allocate" rptr{btWheelInfo} allocate(size_type n_0, rptr{crptr{btWheelInfo}} hint_1);
  public function extern "address" rptr{btWheelInfo} address(btWheelInfo mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{btWheelInfo} ptr_0);
  public function extern "deallocate" void deallocate(rptr{btWheelInfo} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<char const*, 16u>" btAlignedAllocator_char_const_p_16u {
  public function extern "construct" void construct(rptr{crptr{char}} ptr_0, crptr{char} const& value_1);
  public function extern "allocate" rptr{crptr{char}} allocate(size_type n_0, rptr{crptr{crptr{char}}} hint_1);
  public function extern "deallocate" void deallocate(rptr{crptr{char}} ptr_0);
  public function extern "destroy" void destroy(rptr{crptr{char}} ptr_0);
  public function extern "address" rptr{crptr{char}} address(crptr{char} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<char*, 16u>" btAlignedAllocator_char_p_16u {
  public function extern "construct" void construct(rptr{rptr{char}} ptr_0, rptr{char} const& value_1);
  public function extern "allocate" rptr{rptr{char}} allocate(size_type n_0, rptr{crptr{rptr{char}}} hint_1);
  public function extern "destroy" void destroy(rptr{rptr{char}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{char}} ptr_0);
  public function extern "address" rptr{rptr{char}} address(rptr{char} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<double, 16u>" btAlignedAllocator_double_16u {
  public function extern "address" rptr{double} address(double mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{double} ptr_0);
  public function extern "destroy" void destroy(rptr{double} ptr_0);
  public function extern "allocate" rptr{double} allocate(size_type n_0, rptr{crptr{double}} hint_1);
  public function extern "construct" void construct(rptr{double} ptr_0, double const& value_1);
}
public threaded struct extern "::btAlignedAllocator<float, 16u>" btAlignedAllocator_float_16u {
  public function extern "allocate" rptr{float} allocate(size_type n_0, rptr{crptr{float}} hint_1);
  public function extern "construct" void construct(rptr{float} ptr_0, float const& value_1);
  public function extern "destroy" void destroy(rptr{float} ptr_0);
  public function extern "deallocate" void deallocate(rptr{float} ptr_0);
  public function extern "address" rptr{float} address(float mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<int, 16u>" btAlignedAllocator_int_16u {
  public function extern "construct" void construct(rptr{int} ptr_0, int const& value_1);
  public function extern "allocate" rptr{int} allocate(size_type n_0, rptr{crptr{int}} hint_1);
  public function extern "deallocate" void deallocate(rptr{int} ptr_0);
  public function extern "destroy" void destroy(rptr{int} ptr_0);
  public function extern "address" rptr{int} address(int mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<int*, 16u>" btAlignedAllocator_int_p_16u {
  public function extern "construct" void construct(rptr{rptr{int}} ptr_0, rptr{int} const& value_1);
  public function extern "allocate" rptr{rptr{int}} allocate(size_type n_0, rptr{crptr{rptr{int}}} hint_1);
  public function extern "address" rptr{rptr{int}} address(rptr{int} mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{rptr{int}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{int}} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<short, 16u>" btAlignedAllocator_short_16u {
  public function extern "allocate" rptr{short} allocate(size_type n_0, rptr{crptr{short}} hint_1);
  public function extern "construct" void construct(rptr{short} ptr_0, short const& value_1);
  public function extern "address" rptr{short} address(short mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{short} ptr_0);
  public function extern "destroy" void destroy(rptr{short} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<short*, 16u>" btAlignedAllocator_short_p_16u {
  public function extern "construct" void construct(rptr{rptr{short}} ptr_0, rptr{short} const& value_1);
  public function extern "allocate" rptr{rptr{short}} allocate(size_type n_0, rptr{crptr{rptr{short}}} hint_1);
  public function extern "deallocate" void deallocate(rptr{rptr{short}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{short}} ptr_0);
  public function extern "address" rptr{rptr{short}} address(rptr{short} mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<unsigned char*, 16u>" btAlignedAllocator_unsigned_char_p_16u {
  public function extern "construct" void construct(rptr{rptr{uchar}} ptr_0, rptr{uchar} const& value_1);
  public function extern "allocate" rptr{rptr{uchar}} allocate(size_type n_0, rptr{crptr{rptr{uchar}}} hint_1);
  public function extern "address" rptr{rptr{uchar}} address(rptr{uchar} mutable& ref_0) const;
  public function extern "deallocate" void deallocate(rptr{rptr{uchar}} ptr_0);
  public function extern "destroy" void destroy(rptr{rptr{uchar}} ptr_0);
}
public threaded struct extern "::btAlignedAllocator<unsigned int, 16u>" btAlignedAllocator_unsigned_int_16u {
  public function extern "construct" void construct(rptr{uint} ptr_0, uint const& value_1);
  public function extern "allocate" rptr{uint} allocate(size_type n_0, rptr{crptr{uint}} hint_1);
  public function extern "deallocate" void deallocate(rptr{uint} ptr_0);
  public function extern "destroy" void destroy(rptr{uint} ptr_0);
  public function extern "address" rptr{uint} address(uint mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<unsigned short, 16u>" btAlignedAllocator_unsigned_short_16u {
  public function extern "allocate" rptr{ushort} allocate(size_type n_0, rptr{crptr{ushort}} hint_1);
  public function extern "construct" void construct(rptr{ushort} ptr_0, ushort const& value_1);
  public function extern "destroy" void destroy(rptr{ushort} ptr_0);
  public function extern "deallocate" void deallocate(rptr{ushort} ptr_0);
  public function extern "address" rptr{ushort} address(ushort mutable& ref_0) const;
}
public threaded struct extern "::btAlignedAllocator<void*, 16u>" btAlignedAllocator_void_p_16u {
  public function extern "address" rptr{rptr{void}} address(rptr{void} mutable& ref_0) const;
  public function extern "destroy" void destroy(rptr{rptr{void}} ptr_0);
  public function extern "deallocate" void deallocate(rptr{rptr{void}} ptr_0);
  public function extern "allocate" rptr{rptr{void}} allocate(size_type n_0, rptr{crptr{rptr{void}}} hint_1);
  public function extern "construct" void construct(rptr{rptr{void}} ptr_0, rptr{void} const& value_1);
}
public metafunction btAlignedFreeFunc meta::list{void, rptr{void}};
public threaded struct extern "::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>" btAlignedObjectArray_BT_QUANTIZED_BVH_NODE {
  public function extern "capacity" int capacity() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_BT_QUANTIZED_BVH_NODE const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
}
public threaded struct extern "::btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>::less" "nodefault" btAlignedObjectArray_BT_QUANTIZED_BVH_NODE_less private {
}
public threaded struct extern "::btAlignedObjectArray<CHull*>" btAlignedObjectArray_CHull_p {
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "capacity" int capacity() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_CHull_p const& otherArray_0);
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<CHull*>::less" "nodefault" btAlignedObjectArray_CHull_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<GIM_BVH_DATA>" btAlignedObjectArray_GIM_BVH_DATA {
  public function extern "capacity" int capacity() const;
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_GIM_BVH_DATA const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
}
public threaded struct extern "::btAlignedObjectArray<GIM_BVH_DATA>::less" "nodefault" btAlignedObjectArray_GIM_BVH_DATA_less private {
}
public threaded struct extern "::btAlignedObjectArray<GIM_BVH_TREE_NODE>" btAlignedObjectArray_GIM_BVH_TREE_NODE {
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_GIM_BVH_TREE_NODE const& otherArray_0);
}
public threaded struct extern "::btAlignedObjectArray<GIM_BVH_TREE_NODE>::less" "nodefault" btAlignedObjectArray_GIM_BVH_TREE_NODE_less private {
}
public threaded struct extern "::btAlignedObjectArray<GIM_PAIR>" btAlignedObjectArray_GIM_PAIR {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_GIM_PAIR const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "pop_back" void pop_back();
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<GIM_PAIR>::less" "nodefault" btAlignedObjectArray_GIM_PAIR_less private {
}
public threaded struct extern "::btAlignedObjectArray<GrahamVector3>" btAlignedObjectArray_GrahamVector3 {
  public function extern "capacity" int capacity() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "pop_back" void pop_back();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_GrahamVector3 const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<GrahamVector3>::less" "nodefault" btAlignedObjectArray_GrahamVector3_less private {
}
public threaded struct extern "::btAlignedObjectArray<bParse::bChunkInd>" btAlignedObjectArray_bParse_bChunkInd {
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_bParse_bChunkInd const& otherArray_0);
}
public threaded struct extern "::btAlignedObjectArray<bParse::bChunkInd>::less" "nodefault" btAlignedObjectArray_bParse_bChunkInd_less private {
}
public threaded struct extern "::btAlignedObjectArray<bParse::bNameInfo>" btAlignedObjectArray_bParse_bNameInfo {
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "pop_back" void pop_back();
  public function extern "capacity" int capacity() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_bParse_bNameInfo const& otherArray_0);
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<bParse::bNameInfo>::less" "nodefault" btAlignedObjectArray_bParse_bNameInfo_less private {
}
public threaded struct extern "::btAlignedObjectArray<bParse::bStructHandle*>" btAlignedObjectArray_bParse_bStructHandle_p {
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_bParse_bStructHandle_p const& otherArray_0);
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<bParse::bStructHandle*>::less" "nodefault" btAlignedObjectArray_bParse_bStructHandle_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<bool>" btAlignedObjectArray_bool {
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, bool const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(bool const& key_0) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(bool const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" bool const& cat(int n_0) const;
  public function extern "at" bool mutable& at(int n_0);
  public function extern "expandNonInitializing" bool mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(bool const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_bool const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(bool const& key_0);
  public function extern "expand" bool mutable& expand_(bool const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
}
public threaded struct extern "::btAlignedObjectArray<bool>::less" "nodefault" btAlignedObjectArray_bool_less private {
}
public threaded struct extern "::btAlignedObjectArray<btActionInterface*>" btAlignedObjectArray_btActionInterface_p {
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btActionInterface_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btActionInterface} const& key_0) const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" rptr{btActionInterface} mutable& expand_(rptr{btActionInterface} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(rptr{btActionInterface} const& key_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btActionInterface} const& key_0) const;
  public function extern "resize" void resize(int newsize_0, rptr{btActionInterface} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" rptr{btActionInterface} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btActionInterface} mutable& at(int n_0);
  public function extern "at" rptr{btActionInterface} const& cat(int n_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btActionInterface} const& _Val_0);
}
public threaded struct extern "::btAlignedObjectArray<btActionInterface*>::less" "nodefault" btAlignedObjectArray_btActionInterface_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btAlignedObjectArray<int> >" btAlignedObjectArray_btAlignedObjectArray_int_ {
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btAlignedObjectArray_int const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btAlignedObjectArray_int mutable& expand_(btAlignedObjectArray_int const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btAlignedObjectArray_int const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btAlignedObjectArray_int_ const& otherArray_0);
  public function extern "pop_back" void pop_back();
  public function extern "at" btAlignedObjectArray_int const& cat(int n_0) const;
  public function extern "at" btAlignedObjectArray_int mutable& at(int n_0);
  public function extern "expandNonInitializing" btAlignedObjectArray_int mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btAlignedObjectArray_int const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(btAlignedObjectArray_int const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btAlignedObjectArray_int const& fillData_1);
}
public threaded struct extern "::btAlignedObjectArray<btAlignedObjectArray<int> >::less" "nodefault" btAlignedObjectArray_btAlignedObjectArray_int_less private {
}
public threaded struct extern "::btAlignedObjectArray<btBroadphaseInterface*>" btAlignedObjectArray_btBroadphaseInterface_p {
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" rptr{btBroadphaseInterface} mutable& expand_(rptr{btBroadphaseInterface} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(rptr{btBroadphaseInterface} const& key_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBroadphaseInterface_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btBroadphaseInterface} const& key_0) const;
  public function extern "expandNonInitializing" rptr{btBroadphaseInterface} mutable& expandNonInitializing();
  public function extern "at" rptr{btBroadphaseInterface} mutable& at(int n_0);
  public function extern "at" rptr{btBroadphaseInterface} const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{btBroadphaseInterface} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btBroadphaseInterface} const& key_0) const;
  public function extern "resize" void resize(int newsize_0, rptr{btBroadphaseInterface} const& fillData_1);
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<btBroadphaseInterface*>::less" "nodefault" btAlignedObjectArray_btBroadphaseInterface_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btBroadphasePair>" btAlignedObjectArray_btBroadphasePair {
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btBroadphasePair const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btBroadphasePair const& key_0) const;
  public function extern "push_back" void push_back(btBroadphasePair const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" btBroadphasePair mutable& at(int n_0);
  public function extern "at" btBroadphasePair const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btBroadphasePair mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(btBroadphasePair const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBroadphasePair const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(btBroadphasePair const& key_0);
  public function extern "expand" btBroadphasePair mutable& expand_(btBroadphasePair const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
}
public threaded struct extern "::btAlignedObjectArray<btBroadphasePair>::less" "nodefault" btAlignedObjectArray_btBroadphasePair_less private {
}
public threaded struct extern "::btAlignedObjectArray<btBvhSubtreeInfo>" btAlignedObjectArray_btBvhSubtreeInfo {
  public function extern "expandNonInitializing" btBvhSubtreeInfo mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" btBvhSubtreeInfo mutable& at(int n_0);
  public function extern "at" btBvhSubtreeInfo const& cat(int n_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btBvhSubtreeInfo const& _Val_0);
  public function extern "findBinarySearch" int findBinarySearch(btBvhSubtreeInfo const& key_0) const;
  public function extern "resize" void resize(int newsize_0, btBvhSubtreeInfo const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" btBvhSubtreeInfo mutable& expand_(btBvhSubtreeInfo const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(btBvhSubtreeInfo const& key_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBvhSubtreeInfo const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btBvhSubtreeInfo const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btBvhSubtreeInfo>::less" "nodefault" btAlignedObjectArray_btBvhSubtreeInfo_less private {
}
public threaded struct extern "::btAlignedObjectArray<btChunk*>" btAlignedObjectArray_btChunk_p {
  public function extern "findLinearSearch" int findLinearSearch(rptr{btChunk} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btChunk_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(rptr{btChunk} const& key_0);
  public function extern "expand" rptr{btChunk} mutable& expand_(rptr{btChunk} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btChunk} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btChunk} const& key_0) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btChunk} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btChunk} mutable& at(int n_0);
  public function extern "at" rptr{btChunk} const& cat(int n_0) const;
  public function extern "expandNonInitializing" rptr{btChunk} mutable& expandNonInitializing();
}
public threaded struct extern "::btAlignedObjectArray<btChunk*>::less" "nodefault" btAlignedObjectArray_btChunk_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionAlgorithm*>" btAlignedObjectArray_btCollisionAlgorithm_p {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btCollisionAlgorithm} mutable& expand_(rptr{btCollisionAlgorithm} const& fillValue_0);
  public function extern "remove" void remove(rptr{btCollisionAlgorithm} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionAlgorithm_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionAlgorithm} const& key_0) const;
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{btCollisionAlgorithm} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" rptr{btCollisionAlgorithm} mutable& expandNonInitializing();
  public function extern "at" rptr{btCollisionAlgorithm} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionAlgorithm} const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionAlgorithm} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionAlgorithm} const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btCollisionAlgorithm*>::less" "nodefault" btAlignedObjectArray_btCollisionAlgorithm_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject const*>" btAlignedObjectArray_btCollisionObject_const_p {
  public function extern "resize" void resize(int newsize_0, crptr{btCollisionObject} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(crptr{btCollisionObject} const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(crptr{btCollisionObject} const& _Val_0);
  public function extern "expandNonInitializing" crptr{btCollisionObject} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" crptr{btCollisionObject} const& cat(int n_0) const;
  public function extern "at" crptr{btCollisionObject} mutable& at(int n_0);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionObject_const_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(crptr{btCollisionObject} const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" crptr{btCollisionObject} mutable& expand_(crptr{btCollisionObject} const& fillValue_0);
  public function extern "remove" void remove(crptr{btCollisionObject} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject const*>::less" "nodefault" btAlignedObjectArray_btCollisionObject_const_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject*>" btAlignedObjectArray_btCollisionObject_p {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btCollisionObject} mutable& expand_(rptr{btCollisionObject} const& fillValue_0);
  public function extern "remove" void remove(rptr{btCollisionObject} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionObject_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionObject} const& key_0) const;
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{btCollisionObject} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" rptr{btCollisionObject} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btCollisionObject} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionObject} const& cat(int n_0) const;
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionObject} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionObject} const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject*>::less" "nodefault" btAlignedObjectArray_btCollisionObject_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionShape*>" btAlignedObjectArray_btCollisionShape_p {
  public function extern "remove" void remove(rptr{btCollisionShape} const& key_0);
  public function extern "expand" rptr{btCollisionShape} mutable& expand_(rptr{btCollisionShape} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionShape} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionShape_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btCollisionShape} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" rptr{btCollisionShape} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionShape} const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{btCollisionShape} mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionShape} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionShape} const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btCollisionShape*>::less" "nodefault" btAlignedObjectArray_btCollisionShape_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btCompoundShapeChild>" btAlignedObjectArray_btCompoundShapeChild {
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btCompoundShapeChild const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btCompoundShapeChild mutable& expand_(btCompoundShapeChild const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btCompoundShapeChild const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCompoundShapeChild const& otherArray_0);
  public function extern "pop_back" void pop_back();
  public function extern "at" btCompoundShapeChild const& cat(int n_0) const;
  public function extern "at" btCompoundShapeChild mutable& at(int n_0);
  public function extern "expandNonInitializing" btCompoundShapeChild mutable& expandNonInitializing();
  public function extern "push_back" void push_back(btCompoundShapeChild const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(btCompoundShapeChild const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btCompoundShapeChild const& fillData_1);
}
public threaded struct extern "::btAlignedObjectArray<btCompoundShapeChild>::less" "nodefault" btAlignedObjectArray_btCompoundShapeChild_less private {
}
public threaded struct extern "::btAlignedObjectArray<btConvexHullComputer::Edge>" btAlignedObjectArray_btConvexHullComputer_Edge {
  public function extern "expandNonInitializing" btConvexHullComputer_Edge mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" btConvexHullComputer_Edge const& cat(int n_0) const;
  public function extern "at" btConvexHullComputer_Edge mutable& at(int n_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(btConvexHullComputer_Edge const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "findBinarySearch" int findBinarySearch(btConvexHullComputer_Edge const& key_0) const;
  public function extern "resize" void resize(int newsize_0, btConvexHullComputer_Edge const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" btConvexHullComputer_Edge mutable& expand_(btConvexHullComputer_Edge const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(btConvexHullComputer_Edge const& key_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btConvexHullComputer_Edge const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btConvexHullComputer_Edge const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btConvexHullComputer::Edge>::less" "nodefault" btAlignedObjectArray_btConvexHullComputer_Edge_less private {
}
public threaded struct extern "::btAlignedObjectArray<btDbvtNode const*>" btAlignedObjectArray_btDbvtNode_const_p {
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(crptr{btDbvtNode} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvtNode_const_p const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(crptr{btDbvtNode} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" crptr{btDbvtNode} mutable& expand_(crptr{btDbvtNode} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(crptr{btDbvtNode} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, crptr{btDbvtNode} const& fillData_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" crptr{btDbvtNode} const& cat(int n_0) const;
  public function extern "at" crptr{btDbvtNode} mutable& at(int n_0);
  public function extern "expandNonInitializing" crptr{btDbvtNode} mutable& expandNonInitializing();
  public function extern "push_back" void push_back(crptr{btDbvtNode} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public threaded struct extern "::btAlignedObjectArray<btDbvtNode const*>::less" "nodefault" btAlignedObjectArray_btDbvtNode_const_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btDbvtNode*>" "nodefault" btAlignedObjectArray_btDbvtNode_p private {
}
public threaded struct extern "::btAlignedObjectArray<btDbvtProxy*>" "nodefault" btAlignedObjectArray_btDbvtProxy_p private {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNN>" btAlignedObjectArray_btDbvt_sStkNN {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btDbvt_sStkNN mutable& expand_(btDbvt_sStkNN const& fillValue_0);
  public function extern "remove" void remove(btDbvt_sStkNN const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNN const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNN const& key_0) const;
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(btDbvt_sStkNN const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" btDbvt_sStkNN mutable& expandNonInitializing();
  public function extern "at" btDbvt_sStkNN const& cat(int n_0) const;
  public function extern "at" btDbvt_sStkNN mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "resize" void resize(int newsize_0, btDbvt_sStkNN const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNN const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNN>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNN_less private {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNP>" btAlignedObjectArray_btDbvt_sStkNP {
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNP const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNP const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btDbvt_sStkNP mutable& expand_(btDbvt_sStkNP const& fillValue_0);
  public function extern "remove" void remove(btDbvt_sStkNP const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "resize" void resize(int newsize_0, btDbvt_sStkNP const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNP const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(btDbvt_sStkNP const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" btDbvt_sStkNP mutable& expandNonInitializing();
  public function extern "at" btDbvt_sStkNP const& cat(int n_0) const;
  public function extern "at" btDbvt_sStkNP mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNPS>" btAlignedObjectArray_btDbvt_sStkNPS {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btDbvt_sStkNPS mutable& expand_(btDbvt_sStkNPS const& fillValue_0);
  public function extern "remove" void remove(btDbvt_sStkNPS const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNPS const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNPS const& key_0) const;
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btDbvt_sStkNPS const& _Val_0);
  public function extern "expandNonInitializing" btDbvt_sStkNPS mutable& expandNonInitializing();
  public function extern "at" btDbvt_sStkNPS const& cat(int n_0) const;
  public function extern "at" btDbvt_sStkNPS mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "resize" void resize(int newsize_0, btDbvt_sStkNPS const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNPS const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNPS>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNPS_less private {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNP>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNP_less private {
}
public threaded struct extern "::btAlignedObjectArray<btElement>" btAlignedObjectArray_btElement {
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btElement const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btElement const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btElement const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btElement mutable& expand_(btElement const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btElement const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btElement const& fillData_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" btElement mutable& at(int n_0);
  public function extern "at" btElement const& cat(int n_0) const;
  public function extern "expandNonInitializing" btElement mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btElement const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public threaded struct extern "::btAlignedObjectArray<btElement>::less" "nodefault" btAlignedObjectArray_btElement_less private {
}
public threaded struct extern "::btAlignedObjectArray<btFace>" btAlignedObjectArray_btFace {
  public function extern "findBinarySearch" int findBinarySearch(btFace const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btFace const& fillData_1);
  public function extern "at" btFace const& cat(int n_0) const;
  public function extern "at" btFace mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btFace mutable& expandNonInitializing();
  public function extern "push_back" void push_back(btFace const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btFace const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btFace const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btFace const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btFace mutable& expand_(btFace const& fillValue_0);
}
public threaded struct extern "::btAlignedObjectArray<btFace>::less" "nodefault" btAlignedObjectArray_btFace_less private {
}
public threaded struct extern "::btAlignedObjectArray<btGImpactMeshShapePart::TrimeshPrimitiveManager>" btAlignedObjectArray_btGImpactMeshShapePart_TrimeshPrimitiveManager {
  public function extern "pop_back" void pop_back();
  public function extern "at" btGImpactMeshShapePart_TrimeshPrimitiveManager const& cat(int n_0) const;
  public function extern "at" btGImpactMeshShapePart_TrimeshPrimitiveManager mutable& at(int n_0);
  public function extern "expandNonInitializing" btGImpactMeshShapePart_TrimeshPrimitiveManager mutable& expandNonInitializing();
  public function extern "push_back" void push_back(btGImpactMeshShapePart_TrimeshPrimitiveManager const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(btGImpactMeshShapePart_TrimeshPrimitiveManager const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btGImpactMeshShapePart_TrimeshPrimitiveManager const& fillData_1);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btGImpactMeshShapePart_TrimeshPrimitiveManager const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btGImpactMeshShapePart_TrimeshPrimitiveManager mutable& expand_(btGImpactMeshShapePart_TrimeshPrimitiveManager const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btGImpactMeshShapePart_TrimeshPrimitiveManager const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btGImpactMeshShapePart_TrimeshPrimitiveManager const& otherArray_0);
}
public threaded struct extern "::btAlignedObjectArray<btGImpactMeshShapePart::TrimeshPrimitiveManager>::less" "nodefault" btAlignedObjectArray_btGImpactMeshShapePart_TrimeshPrimitiveManager_less private {
}
public threaded struct extern "::btAlignedObjectArray<btGImpactMeshShapePart*>" btAlignedObjectArray_btGImpactMeshShapePart_p {
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(rptr{btGImpactMeshShapePart} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btGImpactMeshShapePart} mutable& expand_(rptr{btGImpactMeshShapePart} const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btGImpactMeshShapePart} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btGImpactMeshShapePart_p const& otherArray_0);
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btGImpactMeshShapePart} mutable& at(int n_0);
  public function extern "at" rptr{btGImpactMeshShapePart} const& cat(int n_0) const;
  public function extern "expandNonInitializing" rptr{btGImpactMeshShapePart} mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btGImpactMeshShapePart} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btGImpactMeshShapePart} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btGImpactMeshShapePart} const& fillData_1);
}
public threaded struct extern "::btAlignedObjectArray<btGImpactMeshShapePart*>::less" "nodefault" btAlignedObjectArray_btGImpactMeshShapePart_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btHashInt>" btAlignedObjectArray_btHashInt {
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btHashInt const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btHashInt mutable& expand_(btHashInt const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btHashInt const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashInt const& otherArray_0);
  public function extern "pop_back" void pop_back();
  public function extern "at" btHashInt mutable& at(int n_0);
  public function extern "at" btHashInt const& cat(int n_0) const;
  public function extern "expandNonInitializing" btHashInt mutable& expandNonInitializing();
  public function extern "push_back" void push_back(btHashInt const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(btHashInt const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btHashInt const& fillData_1);
}
public threaded struct extern "::btAlignedObjectArray<btHashInt>::less" "nodefault" btAlignedObjectArray_btHashInt_less private {
}
public threaded struct extern "::btAlignedObjectArray<btHashKey<btTriIndex> >" btAlignedObjectArray_btHashKey_btTriIndex_ {
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" btHashKey_btTriIndex mutable& expand_(btHashKey_btTriIndex const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(btHashKey_btTriIndex const& key_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashKey_btTriIndex_ const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btHashKey_btTriIndex const& key_0) const;
  public function extern "expandNonInitializing" btHashKey_btTriIndex mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" btHashKey_btTriIndex const& cat(int n_0) const;
  public function extern "at" btHashKey_btTriIndex mutable& at(int n_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(btHashKey_btTriIndex const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "findBinarySearch" int findBinarySearch(btHashKey_btTriIndex const& key_0) const;
  public function extern "resize" void resize(int newsize_0, btHashKey_btTriIndex const& fillData_1);
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<btHashKey<btTriIndex> >::less" "nodefault" btAlignedObjectArray_btHashKey_btTriIndex_less private {
}
public threaded struct extern "::btAlignedObjectArray<btHashPtr>" btAlignedObjectArray_btHashPtr {
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(btHashPtr const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" btHashPtr mutable& expandNonInitializing();
  public function extern "at" btHashPtr mutable& at(int n_0);
  public function extern "at" btHashPtr const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "resize" void resize(int newsize_0, btHashPtr const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btHashPtr const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btHashPtr mutable& expand_(btHashPtr const& fillValue_0);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashPtr const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btHashPtr const& key_0) const;
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<btHashPtr>::less" "nodefault" btAlignedObjectArray_btHashPtr_less private {
}
public threaded struct extern "::btAlignedObjectArray<btHashString>" btAlignedObjectArray_btHashString {
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashString const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btHashString const& key_0) const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" btHashString mutable& expand_(btHashString const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "findBinarySearch" int findBinarySearch(btHashString const& key_0) const;
  public function extern "resize" void resize(int newsize_0, btHashString const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" btHashString mutable& expandNonInitializing();
  public function extern "at" btHashString const& cat(int n_0) const;
  public function extern "at" btHashString mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btHashString const& _Val_0);
}
public threaded struct extern "::btAlignedObjectArray<btHashString>::less" "nodefault" btAlignedObjectArray_btHashString_less private {
}
public threaded struct extern "::btAlignedObjectArray<btIndexedMesh>" btAlignedObjectArray_btIndexedMesh {
  public function extern "remove" void remove(btIndexedMesh const& key_0);
  public function extern "expand" btIndexedMesh mutable& expand_(btIndexedMesh const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(btIndexedMesh const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btIndexedMesh const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "push_back" void push_back(btIndexedMesh const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" btIndexedMesh const& cat(int n_0) const;
  public function extern "at" btIndexedMesh mutable& at(int n_0);
  public function extern "expandNonInitializing" btIndexedMesh mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btIndexedMesh const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btIndexedMesh const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btIndexedMesh>::less" "nodefault" btAlignedObjectArray_btIndexedMesh_less private {
}
public threaded struct extern "::btAlignedObjectArray<btMaterialProperties>" btAlignedObjectArray_btMaterialProperties {
  public function extern "findLinearSearch" int findLinearSearch(btMaterialProperties const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btMaterialProperties const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(btMaterialProperties const& key_0);
  public function extern "expand" btMaterialProperties mutable& expand_(btMaterialProperties const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btMaterialProperties const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btMaterialProperties const& key_0) const;
  public function extern "push_back" void push_back(btMaterialProperties const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" btMaterialProperties mutable& at(int n_0);
  public function extern "at" btMaterialProperties const& cat(int n_0) const;
  public function extern "expandNonInitializing" btMaterialProperties mutable& expandNonInitializing();
}
public threaded struct extern "::btAlignedObjectArray<btMaterialProperties>::less" "nodefault" btAlignedObjectArray_btMaterialProperties_less private {
}
public threaded struct extern "::btAlignedObjectArray<btMaterial*>" btAlignedObjectArray_btMaterial_p {
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" rptr{btMaterial} mutable& expand_(rptr{btMaterial} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(rptr{btMaterial} const& key_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btMaterial_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMaterial} const& key_0) const;
  public function extern "expandNonInitializing" rptr{btMaterial} mutable& expandNonInitializing();
  public function extern "at" rptr{btMaterial} mutable& at(int n_0);
  public function extern "at" rptr{btMaterial} const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{btMaterial} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMaterial} const& key_0) const;
  public function extern "resize" void resize(int newsize_0, rptr{btMaterial} const& fillData_1);
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<btMaterial*>::less" "nodefault" btAlignedObjectArray_btMaterial_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>" btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p {
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMultiSapBroadphase_btBridgeProxy} const& key_0) const;
  public function extern "resize" void resize(int newsize_0, rptr{btMultiSapBroadphase_btBridgeProxy} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btMultiSapBroadphase_btBridgeProxy} const& cat(int n_0) const;
  public function extern "at" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& at(int n_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{btMultiSapBroadphase_btBridgeProxy} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMultiSapBroadphase_btBridgeProxy} const& key_0) const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& expand_(rptr{btMultiSapBroadphase_btBridgeProxy} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(rptr{btMultiSapBroadphase_btBridgeProxy} const& key_0);
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::less" "nodefault" btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>" btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p {
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& expand_(rptr{btMultiSapBroadphase_btMultiSapProxy} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btMultiSapBroadphase_btMultiSapProxy} const& fillData_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& at(int n_0);
  public function extern "at" rptr{btMultiSapBroadphase_btMultiSapProxy} const& cat(int n_0) const;
  public function extern "expandNonInitializing" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btMultiSapBroadphase_btMultiSapProxy} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::less" "nodefault" btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btOptimizedBvhNode>" btAlignedObjectArray_btOptimizedBvhNode {
  public function extern "resize" void resize(int newsize_0, btOptimizedBvhNode const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btOptimizedBvhNode const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btOptimizedBvhNode const& _Val_0);
  public function extern "expandNonInitializing" btOptimizedBvhNode mutable& expandNonInitializing();
  public function extern "at" btOptimizedBvhNode mutable& at(int n_0);
  public function extern "at" btOptimizedBvhNode const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btOptimizedBvhNode const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btOptimizedBvhNode const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btOptimizedBvhNode mutable& expand_(btOptimizedBvhNode const& fillValue_0);
  public function extern "remove" void remove(btOptimizedBvhNode const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btOptimizedBvhNode>::less" "nodefault" btAlignedObjectArray_btOptimizedBvhNode_less private {
}
public threaded struct extern "::btAlignedObjectArray<btOptimizedBvh*>" btAlignedObjectArray_btOptimizedBvh_p {
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btOptimizedBvh} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btOptimizedBvh} const& key_0) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btOptimizedBvh} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" rptr{btOptimizedBvh} mutable& at(int n_0);
  public function extern "at" rptr{btOptimizedBvh} const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{btOptimizedBvh} mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btOptimizedBvh} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btOptimizedBvh_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(rptr{btOptimizedBvh} const& key_0);
  public function extern "expand" rptr{btOptimizedBvh} mutable& expand_(rptr{btOptimizedBvh} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
}
public threaded struct extern "::btAlignedObjectArray<btOptimizedBvh*>::less" "nodefault" btAlignedObjectArray_btOptimizedBvh_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btPersistentManifold*>" btAlignedObjectArray_btPersistentManifold_p {
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btPersistentManifold} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btPersistentManifold} const& key_0) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btPersistentManifold} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" rptr{btPersistentManifold} const& cat(int n_0) const;
  public function extern "at" rptr{btPersistentManifold} mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{btPersistentManifold} mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(rptr{btPersistentManifold} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btPersistentManifold_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(rptr{btPersistentManifold} const& key_0);
  public function extern "expand" rptr{btPersistentManifold} mutable& expand_(rptr{btPersistentManifold} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
}
public threaded struct extern "::btAlignedObjectArray<btPersistentManifold*>::less" "nodefault" btAlignedObjectArray_btPersistentManifold_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btPointerUid>" btAlignedObjectArray_btPointerUid {
  public function extern "resize" void resize(int newsize_0, btPointerUid const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btPointerUid const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btPointerUid const& _Val_0);
  public function extern "expandNonInitializing" btPointerUid mutable& expandNonInitializing();
  public function extern "at" btPointerUid const& cat(int n_0) const;
  public function extern "at" btPointerUid mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btPointerUid const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btPointerUid const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btPointerUid mutable& expand_(btPointerUid const& fillValue_0);
  public function extern "remove" void remove(btPointerUid const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btPointerUid>::less" "nodefault" btAlignedObjectArray_btPointerUid_less private {
}
public threaded struct extern "::btAlignedObjectArray<btQuantizedBvhNode>" btAlignedObjectArray_btQuantizedBvhNode {
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btQuantizedBvhNode const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btQuantizedBvhNode const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btQuantizedBvhNode mutable& expand_(btQuantizedBvhNode const& fillValue_0);
  public function extern "remove" void remove(btQuantizedBvhNode const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "resize" void resize(int newsize_0, btQuantizedBvhNode const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btQuantizedBvhNode const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(btQuantizedBvhNode const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" btQuantizedBvhNode mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" btQuantizedBvhNode mutable& at(int n_0);
  public function extern "at" btQuantizedBvhNode const& cat(int n_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btQuantizedBvhNode>::less" "nodefault" btAlignedObjectArray_btQuantizedBvhNode_less private {
}
public threaded struct extern "::btAlignedObjectArray<btRigidBody*>" btAlignedObjectArray_btRigidBody_p {
  public function extern "findLinearSearch" int findLinearSearch(rptr{btRigidBody} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btRigidBody_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(rptr{btRigidBody} const& key_0);
  public function extern "expand" rptr{btRigidBody} mutable& expand_(rptr{btRigidBody} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btRigidBody} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btRigidBody} const& key_0) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btRigidBody} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btRigidBody} mutable& at(int n_0);
  public function extern "at" rptr{btRigidBody} const& cat(int n_0) const;
  public function extern "expandNonInitializing" rptr{btRigidBody} mutable& expandNonInitializing();
}
public threaded struct extern "::btAlignedObjectArray<btRigidBody*>::less" "nodefault" btAlignedObjectArray_btRigidBody_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSimplePair>" btAlignedObjectArray_btSimplePair {
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" btSimplePair mutable& expand_(btSimplePair const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(btSimplePair const& key_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSimplePair const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btSimplePair const& key_0) const;
  public function extern "expandNonInitializing" btSimplePair mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" btSimplePair const& cat(int n_0) const;
  public function extern "at" btSimplePair mutable& at(int n_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(btSimplePair const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "findBinarySearch" int findBinarySearch(btSimplePair const& key_0) const;
  public function extern "resize" void resize(int newsize_0, btSimplePair const& fillData_1);
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<btSimplePair>::less" "nodefault" btAlignedObjectArray_btSimplePair_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Anchor>" btAlignedObjectArray_btSoftBody_Anchor {
  public function extern "findBinarySearch" int findBinarySearch(btSoftBody_Anchor const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSoftBody_Anchor const& fillData_1);
  public function extern "at" btSoftBody_Anchor const& cat(int n_0) const;
  public function extern "at" btSoftBody_Anchor mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btSoftBody_Anchor mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btSoftBody_Anchor const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btSoftBody_Anchor const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Anchor const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btSoftBody_Anchor const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btSoftBody_Anchor mutable& expand_(btSoftBody_Anchor const& fillValue_0);
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Anchor>::less" "nodefault" btAlignedObjectArray_btSoftBody_Anchor_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Cluster*>" btAlignedObjectArray_btSoftBody_Cluster_p {
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btSoftBody_Cluster} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Cluster_p const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(rptr{btSoftBody_Cluster} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btSoftBody_Cluster} mutable& expand_(rptr{btSoftBody_Cluster} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btSoftBody_Cluster} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btSoftBody_Cluster} const& fillData_1);
  public function extern "at" rptr{btSoftBody_Cluster} const& cat(int n_0) const;
  public function extern "at" rptr{btSoftBody_Cluster} mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{btSoftBody_Cluster} mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btSoftBody_Cluster} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Cluster*>::less" "nodefault" btAlignedObjectArray_btSoftBody_Cluster_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Face>" btAlignedObjectArray_btSoftBody_Face {
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btSoftBody_Face const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Face const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btSoftBody_Face const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btSoftBody_Face mutable& expand_(btSoftBody_Face const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btSoftBody_Face const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSoftBody_Face const& fillData_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" btSoftBody_Face mutable& at(int n_0);
  public function extern "at" btSoftBody_Face const& cat(int n_0) const;
  public function extern "expandNonInitializing" btSoftBody_Face mutable& expandNonInitializing();
  public function extern "push_back" void push_back(btSoftBody_Face const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Face>::less" "nodefault" btAlignedObjectArray_btSoftBody_Face_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Joint*>" btAlignedObjectArray_btSoftBody_Joint_p {
  public function extern "remove" void remove(rptr{btSoftBody_Joint} const& key_0);
  public function extern "expand" rptr{btSoftBody_Joint} mutable& expand_(rptr{btSoftBody_Joint} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btSoftBody_Joint} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Joint_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btSoftBody_Joint} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btSoftBody_Joint} mutable& at(int n_0);
  public function extern "at" rptr{btSoftBody_Joint} const& cat(int n_0) const;
  public function extern "expandNonInitializing" rptr{btSoftBody_Joint} mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btSoftBody_Joint} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btSoftBody_Joint} const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Joint*>::less" "nodefault" btAlignedObjectArray_btSoftBody_Joint_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Link>" btAlignedObjectArray_btSoftBody_Link {
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Link const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btSoftBody_Link const& key_0) const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" btSoftBody_Link mutable& expand_(btSoftBody_Link const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(btSoftBody_Link const& key_0);
  public function extern "findBinarySearch" int findBinarySearch(btSoftBody_Link const& key_0) const;
  public function extern "resize" void resize(int newsize_0, btSoftBody_Link const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" btSoftBody_Link mutable& expandNonInitializing();
  public function extern "at" btSoftBody_Link const& cat(int n_0) const;
  public function extern "at" btSoftBody_Link mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btSoftBody_Link const& _Val_0);
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Link>::less" "nodefault" btAlignedObjectArray_btSoftBody_Link_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Material*>" btAlignedObjectArray_btSoftBody_Material_p {
  public function extern "push_back" void push_back(rptr{btSoftBody_Material} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btSoftBody_Material} const& cat(int n_0) const;
  public function extern "at" rptr{btSoftBody_Material} mutable& at(int n_0);
  public function extern "expandNonInitializing" rptr{btSoftBody_Material} mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btSoftBody_Material} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btSoftBody_Material} const& key_0) const;
  public function extern "remove" void remove(rptr{btSoftBody_Material} const& key_0);
  public function extern "expand" rptr{btSoftBody_Material} mutable& expand_(rptr{btSoftBody_Material} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btSoftBody_Material} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Material_p const& otherArray_0);
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Material*>::less" "nodefault" btAlignedObjectArray_btSoftBody_Material_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Node>" btAlignedObjectArray_btSoftBody_Node {
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btSoftBody_Node const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Node const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btSoftBody_Node const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btSoftBody_Node mutable& expand_(btSoftBody_Node const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btSoftBody_Node const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSoftBody_Node const& fillData_1);
  public function extern "at" btSoftBody_Node mutable& at(int n_0);
  public function extern "at" btSoftBody_Node const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btSoftBody_Node mutable& expandNonInitializing();
  public function extern "push_back" void push_back(btSoftBody_Node const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Node>::less" "nodefault" btAlignedObjectArray_btSoftBody_Node_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Node*>" btAlignedObjectArray_btSoftBody_Node_p {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btSoftBody_Node} mutable& expand_(rptr{btSoftBody_Node} const& fillValue_0);
  public function extern "remove" void remove(rptr{btSoftBody_Node} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Node_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btSoftBody_Node} const& key_0) const;
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{btSoftBody_Node} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" rptr{btSoftBody_Node} mutable& expandNonInitializing();
  public function extern "at" rptr{btSoftBody_Node} mutable& at(int n_0);
  public function extern "at" rptr{btSoftBody_Node} const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "resize" void resize(int newsize_0, rptr{btSoftBody_Node} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{btSoftBody_Node} const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Node*>::less" "nodefault" btAlignedObjectArray_btSoftBody_Node_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Note>" btAlignedObjectArray_btSoftBody_Note {
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btSoftBody_Note const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btSoftBody_Note mutable& expand_(btSoftBody_Note const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btSoftBody_Note const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Note const& otherArray_0);
  public function extern "pop_back" void pop_back();
  public function extern "at" btSoftBody_Note mutable& at(int n_0);
  public function extern "at" btSoftBody_Note const& cat(int n_0) const;
  public function extern "expandNonInitializing" btSoftBody_Note mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btSoftBody_Note const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(btSoftBody_Note const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSoftBody_Note const& fillData_1);
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Note>::less" "nodefault" btAlignedObjectArray_btSoftBody_Note_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::RContact>" btAlignedObjectArray_btSoftBody_RContact {
  public function extern "remove" void remove(btSoftBody_RContact const& key_0);
  public function extern "expand" btSoftBody_RContact mutable& expand_(btSoftBody_RContact const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(btSoftBody_RContact const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_RContact const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btSoftBody_RContact const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" btSoftBody_RContact mutable& at(int n_0);
  public function extern "at" btSoftBody_RContact const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btSoftBody_RContact mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSoftBody_RContact const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btSoftBody_RContact const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::RContact>::less" "nodefault" btAlignedObjectArray_btSoftBody_RContact_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::SContact>" btAlignedObjectArray_btSoftBody_SContact {
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btSoftBody_SContact const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" btSoftBody_SContact const& cat(int n_0) const;
  public function extern "at" btSoftBody_SContact mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btSoftBody_SContact mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSoftBody_SContact const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btSoftBody_SContact const& key_0) const;
  public function extern "remove" void remove(btSoftBody_SContact const& key_0);
  public function extern "expand" btSoftBody_SContact mutable& expand_(btSoftBody_SContact const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(btSoftBody_SContact const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_SContact const& otherArray_0);
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::SContact>::less" "nodefault" btAlignedObjectArray_btSoftBody_SContact_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Tetra>" btAlignedObjectArray_btSoftBody_Tetra {
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSoftBody_Tetra const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btSoftBody_Tetra const& key_0) const;
  public function extern "push_back" void push_back(btSoftBody_Tetra const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" btSoftBody_Tetra const& cat(int n_0) const;
  public function extern "at" btSoftBody_Tetra mutable& at(int n_0);
  public function extern "expandNonInitializing" btSoftBody_Tetra mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(btSoftBody_Tetra const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_Tetra const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(btSoftBody_Tetra const& key_0);
  public function extern "expand" btSoftBody_Tetra mutable& expand_(btSoftBody_Tetra const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::Tetra>::less" "nodefault" btAlignedObjectArray_btSoftBody_Tetra_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::ePSolver::_>" btAlignedObjectArray_btSoftBody_ePSolver_ {
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_ePSolver_ const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "capacity" int capacity() const;
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::ePSolver::_>::less" "nodefault" btAlignedObjectArray_btSoftBody_ePSolver_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::eVSolver::_>" btAlignedObjectArray_btSoftBody_eVSolver_ {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_eVSolver_ const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "capacity" int capacity() const;
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody::eVSolver::_>::less" "nodefault" btAlignedObjectArray_btSoftBody_eVSolver_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody*>" btAlignedObjectArray_btSoftBody_p {
  public function extern "resize" void resize(int newsize_0, rptr{btSoftBody} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{btSoftBody} const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btSoftBody} const& _Val_0);
  public function extern "expandNonInitializing" rptr{btSoftBody} mutable& expandNonInitializing();
  public function extern "at" rptr{btSoftBody} const& cat(int n_0) const;
  public function extern "at" rptr{btSoftBody} mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSoftBody_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btSoftBody} const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btSoftBody} mutable& expand_(rptr{btSoftBody} const& fillValue_0);
  public function extern "remove" void remove(rptr{btSoftBody} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btSoftBody*>::less" "nodefault" btAlignedObjectArray_btSoftBody_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSolverBody>" btAlignedObjectArray_btSolverBody {
  public function extern "at" btSolverBody const& cat(int n_0) const;
  public function extern "at" btSolverBody mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btSolverBody mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btSolverBody const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(btSolverBody const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSolverBody const& fillData_1);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btSolverBody const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btSolverBody mutable& expand_(btSolverBody const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btSolverBody const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSolverBody const& otherArray_0);
}
public threaded struct extern "::btAlignedObjectArray<btSolverBody>::less" "nodefault" btAlignedObjectArray_btSolverBody_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSolverConstraint>" btAlignedObjectArray_btSolverConstraint {
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btSolverConstraint const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btSolverConstraint const& key_0) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btSolverConstraint const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" btSolverConstraint mutable& at(int n_0);
  public function extern "at" btSolverConstraint const& cat(int n_0) const;
  public function extern "expandNonInitializing" btSolverConstraint mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(btSolverConstraint const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSolverConstraint const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(btSolverConstraint const& key_0);
  public function extern "expand" btSolverConstraint mutable& expand_(btSolverConstraint const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
}
public threaded struct extern "::btAlignedObjectArray<btSolverConstraint>::less" "nodefault" btAlignedObjectArray_btSolverConstraint_less private {
}
public threaded struct extern "::btAlignedObjectArray<btSparseSdf<3>::Cell*>" btAlignedObjectArray_btSparseSdf_3_Cell_p {
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(rptr{btSparseSdf_3_Cell} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btSparseSdf_3_Cell} mutable& expand_(rptr{btSparseSdf_3_Cell} const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btSparseSdf_3_Cell} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSparseSdf_3_Cell_p const& otherArray_0);
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btSparseSdf_3_Cell} const& cat(int n_0) const;
  public function extern "at" rptr{btSparseSdf_3_Cell} mutable& at(int n_0);
  public function extern "expandNonInitializing" rptr{btSparseSdf_3_Cell} mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btSparseSdf_3_Cell} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btSparseSdf_3_Cell} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btSparseSdf_3_Cell} const& fillData_1);
}
public threaded struct extern "::btAlignedObjectArray<btSparseSdf<3>::Cell*>::less" "nodefault" btAlignedObjectArray_btSparseSdf_3_Cell_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btStridingMeshInterfaceData*>" btAlignedObjectArray_btStridingMeshInterfaceData_p {
  public function extern "resize" void resize(int newsize_0, rptr{btStridingMeshInterfaceData} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{btStridingMeshInterfaceData} const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{btStridingMeshInterfaceData} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" rptr{btStridingMeshInterfaceData} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btStridingMeshInterfaceData} const& cat(int n_0) const;
  public function extern "at" rptr{btStridingMeshInterfaceData} mutable& at(int n_0);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btStridingMeshInterfaceData_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btStridingMeshInterfaceData} const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btStridingMeshInterfaceData} mutable& expand_(rptr{btStridingMeshInterfaceData} const& fillValue_0);
  public function extern "remove" void remove(rptr{btStridingMeshInterfaceData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btStridingMeshInterfaceData*>::less" "nodefault" btAlignedObjectArray_btStridingMeshInterfaceData_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btTransform>" btAlignedObjectArray_btTransform {
  public function extern "resize" void resize(int newsize_0, btTransform const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btTransform const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btTransform const& _Val_0);
  public function extern "expandNonInitializing" btTransform mutable& expandNonInitializing();
  public function extern "at" btTransform const& cat(int n_0) const;
  public function extern "at" btTransform mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTransform const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btTransform const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btTransform mutable& expand_(btTransform const& fillValue_0);
  public function extern "remove" void remove(btTransform const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btTransform>::less" "nodefault" btAlignedObjectArray_btTransform_less private {
}
public threaded struct extern "::btAlignedObjectArray<btTriIndex>" btAlignedObjectArray_btTriIndex {
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btTriIndex const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" btTriIndex const& cat(int n_0) const;
  public function extern "at" btTriIndex mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btTriIndex mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btTriIndex const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btTriIndex const& key_0) const;
  public function extern "remove" void remove(btTriIndex const& key_0);
  public function extern "expand" btTriIndex mutable& expand_(btTriIndex const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(btTriIndex const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTriIndex const& otherArray_0);
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<btTriIndex>::less" "nodefault" btAlignedObjectArray_btTriIndex_less private {
}
public threaded struct extern "::btAlignedObjectArray<btTriangle>" btAlignedObjectArray_btTriangle {
  public function extern "findBinarySearch" int findBinarySearch(btTriangle const& key_0) const;
  public function extern "resize" void resize(int newsize_0, btTriangle const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" btTriangle mutable& expandNonInitializing();
  public function extern "at" btTriangle const& cat(int n_0) const;
  public function extern "at" btTriangle mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btTriangle const& _Val_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTriangle const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btTriangle const& key_0) const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" btTriangle mutable& expand_(btTriangle const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(btTriangle const& key_0);
}
public threaded struct extern "::btAlignedObjectArray<btTriangleIndexVertexArray*>" btAlignedObjectArray_btTriangleIndexVertexArray_p {
  public function extern "resize" void resize(int newsize_0, rptr{btTriangleIndexVertexArray} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTriangleIndexVertexArray} const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{btTriangleIndexVertexArray} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" rptr{btTriangleIndexVertexArray} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btTriangleIndexVertexArray} const& cat(int n_0) const;
  public function extern "at" rptr{btTriangleIndexVertexArray} mutable& at(int n_0);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTriangleIndexVertexArray_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTriangleIndexVertexArray} const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btTriangleIndexVertexArray} mutable& expand_(rptr{btTriangleIndexVertexArray} const& fillValue_0);
  public function extern "remove" void remove(rptr{btTriangleIndexVertexArray} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<btTriangleIndexVertexArray*>::less" "nodefault" btAlignedObjectArray_btTriangleIndexVertexArray_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btTriangleInfo>" btAlignedObjectArray_btTriangleInfo {
  public function extern "findLinearSearch" int findLinearSearch(btTriangleInfo const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTriangleInfo const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(btTriangleInfo const& key_0);
  public function extern "expand" btTriangleInfo mutable& expand_(btTriangleInfo const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btTriangleInfo const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(btTriangleInfo const& key_0) const;
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btTriangleInfo const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "at" btTriangleInfo const& cat(int n_0) const;
  public function extern "at" btTriangleInfo mutable& at(int n_0);
  public function extern "expandNonInitializing" btTriangleInfo mutable& expandNonInitializing();
}
public threaded struct extern "::btAlignedObjectArray<btTriangleInfoMap*>" btAlignedObjectArray_btTriangleInfoMap_p {
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(rptr{btTriangleInfoMap} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btTriangleInfoMap} mutable& expand_(rptr{btTriangleInfoMap} const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTriangleInfoMap} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTriangleInfoMap_p const& otherArray_0);
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btTriangleInfoMap} const& cat(int n_0) const;
  public function extern "at" rptr{btTriangleInfoMap} mutable& at(int n_0);
  public function extern "expandNonInitializing" rptr{btTriangleInfoMap} mutable& expandNonInitializing();
  public function extern "push_back" void push_back(rptr{btTriangleInfoMap} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTriangleInfoMap} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btTriangleInfoMap} const& fillData_1);
}
public threaded struct extern "::btAlignedObjectArray<btTriangleInfoMap*>::less" "nodefault" btAlignedObjectArray_btTriangleInfoMap_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btTriangleInfo>::less" "nodefault" btAlignedObjectArray_btTriangleInfo_less private {
}
public threaded struct extern "::btAlignedObjectArray<btTriangle>::less" "nodefault" btAlignedObjectArray_btTriangle_less private {
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>" btAlignedObjectArray_btTypedConstraint_btConstraintInfo1 {
  public function extern "at" btTypedConstraint_btConstraintInfo1 const& cat(int n_0) const;
  public function extern "at" btTypedConstraint_btConstraintInfo1 mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" btTypedConstraint_btConstraintInfo1 mutable& expandNonInitializing();
  public function extern "push_back" void push_back(btTypedConstraint_btConstraintInfo1 const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(btTypedConstraint_btConstraintInfo1 const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, btTypedConstraint_btConstraintInfo1 const& fillData_1);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(btTypedConstraint_btConstraintInfo1 const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btTypedConstraint_btConstraintInfo1 mutable& expand_(btTypedConstraint_btConstraintInfo1 const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(btTypedConstraint_btConstraintInfo1 const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTypedConstraint_btConstraintInfo1 const& otherArray_0);
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::less" "nodefault" btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_less private {
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint*>" btAlignedObjectArray_btTypedConstraint_p {
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTypedConstraint} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTypedConstraint_p const& otherArray_0);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(rptr{btTypedConstraint} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btTypedConstraint} mutable& expand_(rptr{btTypedConstraint} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTypedConstraint} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btTypedConstraint} const& fillData_1);
  public function extern "at" rptr{btTypedConstraint} const& cat(int n_0) const;
  public function extern "at" rptr{btTypedConstraint} mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{btTypedConstraint} mutable& expandNonInitializing();
  public function extern "push_back" void push_back(rptr{btTypedConstraint} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint*>::less" "nodefault" btAlignedObjectArray_btTypedConstraint_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btVector3>" btAlignedObjectArray_btVector3 {
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btVector3 const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btVector3 const& key_0) const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" btVector3 mutable& expand_(btVector3 const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(btVector3 const& key_0);
  public function extern "findBinarySearch" int findBinarySearch(btVector3 const& key_0) const;
  public function extern "resize" void resize(int newsize_0, btVector3 const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" btVector3 mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" btVector3 mutable& at(int n_0);
  public function extern "at" btVector3 const& cat(int n_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(btVector3 const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
}
public threaded struct extern "::btAlignedObjectArray<btVector3DoubleData*>" btAlignedObjectArray_btVector3DoubleData_p {
  public function extern "remove" void remove(rptr{btVector3DoubleData} const& key_0);
  public function extern "expand" rptr{btVector3DoubleData} mutable& expand_(rptr{btVector3DoubleData} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{btVector3DoubleData} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btVector3DoubleData_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "push_back" void push_back(rptr{btVector3DoubleData} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" rptr{btVector3DoubleData} const& cat(int n_0) const;
  public function extern "at" rptr{btVector3DoubleData} mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{btVector3DoubleData} mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btVector3DoubleData} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btVector3DoubleData} const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<btVector3DoubleData*>::less" "nodefault" btAlignedObjectArray_btVector3DoubleData_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btVector3FloatData*>" btAlignedObjectArray_btVector3FloatData_p {
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{btVector3FloatData} mutable& at(int n_0);
  public function extern "at" rptr{btVector3FloatData} const& cat(int n_0) const;
  public function extern "expandNonInitializing" rptr{btVector3FloatData} mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{btVector3FloatData} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btVector3FloatData} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{btVector3FloatData} const& fillData_1);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(rptr{btVector3FloatData} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{btVector3FloatData} mutable& expand_(rptr{btVector3FloatData} const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btVector3FloatData} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btVector3FloatData_p const& otherArray_0);
}
public threaded struct extern "::btAlignedObjectArray<btVector3FloatData*>::less" "nodefault" btAlignedObjectArray_btVector3FloatData_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<btVector3>::less" "nodefault" btAlignedObjectArray_btVector3_less private {
}
public threaded struct extern "::btAlignedObjectArray<btWheelInfo>" btAlignedObjectArray_btWheelInfo {
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(btWheelInfo const& _Val_0);
  public function extern "expandNonInitializing" btWheelInfo mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" btWheelInfo mutable& at(int n_0);
  public function extern "at" btWheelInfo const& cat(int n_0) const;
  public function extern "resize" void resize(int newsize_0, btWheelInfo const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(btWheelInfo const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" btWheelInfo mutable& expand_(btWheelInfo const& fillValue_0);
  public function extern "remove" void remove(btWheelInfo const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btWheelInfo const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(btWheelInfo const& key_0) const;
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<btWheelInfo>::less" "nodefault" btAlignedObjectArray_btWheelInfo_less private {
}
public threaded struct extern "::btAlignedObjectArray<char const*>" btAlignedObjectArray_char_const_p {
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_char_const_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(crptr{char} const& key_0) const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" crptr{char} mutable& expand_(crptr{char} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(crptr{char} const& key_0);
  public function extern "findBinarySearch" int findBinarySearch(crptr{char} const& key_0) const;
  public function extern "resize" void resize(int newsize_0, crptr{char} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" crptr{char} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" crptr{char} const& cat(int n_0) const;
  public function extern "at" crptr{char} mutable& at(int n_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(crptr{char} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
}
public threaded struct extern "::btAlignedObjectArray<char const*>::less" "nodefault" btAlignedObjectArray_char_const_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<char*>" btAlignedObjectArray_char_p {
  public function extern "remove" void remove(rptr{char} const& key_0);
  public function extern "expand" rptr{char} mutable& expand_(rptr{char} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{char} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_char_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "push_back" void push_back(rptr{char} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" rptr{char} mutable& at(int n_0);
  public function extern "at" rptr{char} const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{char} mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{char} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{char} const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<char*>::less" "nodefault" btAlignedObjectArray_char_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<double>" btAlignedObjectArray_double {
  public function extern "findBinarySearch" int findBinarySearch(double const& key_0) const;
  public function extern "resize" void resize(int newsize_0, double const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "expandNonInitializing" double mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" double const& cat(int n_0) const;
  public function extern "at" double mutable& at(int n_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(double const& _Val_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_double const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(double const& key_0) const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" double mutable& expand_(double const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(double const& key_0);
}
public threaded struct extern "::btAlignedObjectArray<double>::less" "nodefault" btAlignedObjectArray_double_less private {
}
public threaded struct extern "::btAlignedObjectArray<float>" btAlignedObjectArray_float {
  public function extern "resize" void resize(int newsize_0, float const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(float const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(float const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" float mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" float mutable& at(int n_0);
  public function extern "at" float const& cat(int n_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_float const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(float const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" float mutable& expand_(float const& fillValue_0);
  public function extern "remove" void remove(float const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<float>::less" "nodefault" btAlignedObjectArray_float_less private {
}
public threaded struct extern "::btAlignedObjectArray<int>" btAlignedObjectArray_int {
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" int mutable& expand_(int const& fillValue_0);
  public function extern "remove" void remove(int const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_int const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(int const& key_0) const;
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(int const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" int mutable& expandNonInitializing();
  public function extern "at" int mutable& at(int n_0);
  public function extern "at" int const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "resize" void resize(int newsize_0, int const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(int const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<int>::less" "nodefault" btAlignedObjectArray_int_less private {
}
public threaded struct extern "::btAlignedObjectArray<int*>" btAlignedObjectArray_int_p {
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{int} const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{int} const& key_0) const;
  public function extern "push_back" void push_back(rptr{int} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" rptr{int} const& cat(int n_0) const;
  public function extern "at" rptr{int} mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{int} mutable& expandNonInitializing();
  public function extern "findLinearSearch" int findLinearSearch(rptr{int} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_int_p const& otherArray_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(rptr{int} const& key_0);
  public function extern "expand" rptr{int} mutable& expand_(rptr{int} const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
}
public threaded struct extern "::btAlignedObjectArray<int*>::less" "nodefault" btAlignedObjectArray_int_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<short>" btAlignedObjectArray_short {
  public function extern "push_back" void push_back(short const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "at" short mutable& at(int n_0);
  public function extern "at" short const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" short mutable& expandNonInitializing();
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, short const& fillData_1);
  public function extern "findBinarySearch" int findBinarySearch(short const& key_0) const;
  public function extern "remove" void remove(short const& key_0);
  public function extern "expand" short mutable& expand_(short const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "findLinearSearch" int findLinearSearch(short const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_short const& otherArray_0);
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<short>::less" "nodefault" btAlignedObjectArray_short_less private {
}
public threaded struct extern "::btAlignedObjectArray<short*>" btAlignedObjectArray_short_p {
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(rptr{short} const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "expandNonInitializing" rptr{short} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{short} mutable& at(int n_0);
  public function extern "at" rptr{short} const& cat(int n_0) const;
  public function extern "resize" void resize(int newsize_0, rptr{short} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{short} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{short} mutable& expand_(rptr{short} const& fillValue_0);
  public function extern "remove" void remove(rptr{short} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_short_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{short} const& key_0) const;
  public function extern "size" int size() const;
}
public threaded struct extern "::btAlignedObjectArray<short*>::less" "nodefault" btAlignedObjectArray_short_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<unsigned char*>" btAlignedObjectArray_unsigned_char_p {
  public function extern "resize" void resize(int newsize_0, rptr{uchar} const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "findBinarySearch" int findBinarySearch(rptr{uchar} const& key_0) const;
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{uchar} const& _Val_0);
  public function extern "expandNonInitializing" rptr{uchar} mutable& expandNonInitializing();
  public function extern "pop_back" void pop_back();
  public function extern "at" rptr{uchar} mutable& at(int n_0);
  public function extern "at" rptr{uchar} const& cat(int n_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_unsigned_char_p const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(rptr{uchar} const& key_0) const;
  public function extern "size" int size() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{uchar} mutable& expand_(rptr{uchar} const& fillValue_0);
  public function extern "remove" void remove(rptr{uchar} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
}
public threaded struct extern "::btAlignedObjectArray<unsigned char*>::less" "nodefault" btAlignedObjectArray_unsigned_char_p_less private {
}
public threaded struct extern "::btAlignedObjectArray<unsigned int>" btAlignedObjectArray_unsigned_int {
  public function extern "expandNonInitializing" uint mutable& expandNonInitializing();
  public function extern "at" uint const& cat(int n_0) const;
  public function extern "at" uint mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "push_back" void push_back(uint const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "findBinarySearch" int findBinarySearch(uint const& key_0) const;
  public function extern "resize" void resize(int newsize_0, uint const& fillData_1);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "clear" void clear();
  public function extern "expand" uint mutable& expand_(uint const& fillValue_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "remove" void remove(uint const& key_0);
  public function extern "size" int size() const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_unsigned_int const& otherArray_0);
  public function extern "findLinearSearch" int findLinearSearch(uint const& key_0) const;
}
public threaded struct extern "::btAlignedObjectArray<unsigned int>::less" "nodefault" btAlignedObjectArray_unsigned_int_less private {
}
public threaded struct extern "::btAlignedObjectArray<unsigned short>" btAlignedObjectArray_unsigned_short {
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(ushort const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" ushort mutable& expand_(ushort const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(ushort const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_unsigned_short const& otherArray_0);
  public function extern "at" ushort const& cat(int n_0) const;
  public function extern "at" ushort mutable& at(int n_0);
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" ushort mutable& expandNonInitializing();
  public function extern "push_back" void push_back(ushort const& _Val_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(ushort const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, ushort const& fillData_1);
}
public threaded struct extern "::btAlignedObjectArray<unsigned short>::less" "nodefault" btAlignedObjectArray_unsigned_short_less private {
}
public threaded struct extern "::btAlignedObjectArray<void*>" btAlignedObjectArray_void_p {
  public function extern "at" rptr{void} mutable& at(int n_0);
  public function extern "at" rptr{void} const& cat(int n_0) const;
  public function extern "pop_back" void pop_back();
  public function extern "expandNonInitializing" rptr{void} mutable& expandNonInitializing();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "push_back" void push_back(rptr{void} const& _Val_0);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{void} const& key_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "resize" void resize(int newsize_0, rptr{void} const& fillData_1);
  public function extern "clear" void clear();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "remove" void remove(rptr{void} const& key_0);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "expand" rptr{void} mutable& expand_(rptr{void} const& fillValue_0);
  public function extern "size" int size() const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{void} const& key_0) const;
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_void_p const& otherArray_0);
}
public threaded struct extern "::btAlignedObjectArray<void*>::less" "nodefault" btAlignedObjectArray_void_p_less private {
}
public metafunction btAllocFunc meta::list{rptr{void}, size_t};
public threaded struct extern "::btAngleCompareFunc" "nodefault" btAngleCompareFunc(btVector3 const& anchor_0)  {
  public btVector3 m_anchor;
}
public threaded struct extern "::btAngularLimit" btAngularLimit {
  public function extern "getRelaxationFactor" btScalar getRelaxationFactor() const;
  public function extern "getHalfRange" btScalar getHalfRange() const;
  public function extern "fit" void fit(btScalar mutable& angle_0) const;
  public function extern "getSoftness" btScalar getSoftness() const;
  public function extern "test" void test(btScalar const angle_0);
  public function extern "set" void set(btScalar low_0, btScalar high_1, btScalar _softness_2, btScalar _biasFactor_3, btScalar _relaxationFactor_4);
  public function extern "getHigh" btScalar getHigh() const;
  public function extern "getSign" btScalar getSign() const;
  public function extern "getError" btScalar getError() const;
  public function extern "getBiasFactor" btScalar getBiasFactor() const;
  public function extern "getCorrection" btScalar getCorrection() const;
  public function extern "getLow" btScalar getLow() const;
  public function extern "isLimit" bool isLimit() const;
}
public threaded struct extern "::btAxisSweep3" "nodefault" btAxisSweep3(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, ushort maxHandles_2, rptr{btOverlappingPairCache} pairCache_3, bool disableRaycastAccelerator_4)  {
  public metafunction __base__ {btBroadphaseInterface, btAxisSweep3Internal_unsigned_short};
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_short_Handle} getHandle(ushort index_0) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "updateHandle" void updateHandle(ushort handle_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback_0);
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "removeHandle" void removeHandle(ushort handle_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getNumHandles" ushort getNumHandles() const;
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "addHandle" ushort addHandle(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} pOwner_2, short collisionFilterGroup_3, short collisionFilterMask_4, rptr{btDispatcher} dispatcher_5, rptr{void} multiSapProxy_6);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "printStats" void printStats();
  public function extern "quantize" void quantize(rptr{ushort} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback_0);
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>" "nodefault" btAxisSweep3Internal_unsigned_int(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, uint handleMask_2, uint handleSentinel_3, uint userMaxHandles_4, rptr{btOverlappingPairCache} pairCache_5, bool disableRaycastAccelerator_6)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "removeHandle" void removeHandle(uint handle_0, rptr{btDispatcher} dispatcher_1);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "updateHandle" void updateHandle(uint handle_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback_0);
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_int_Handle} getHandle(uint index_0) const;
  public function extern "printStats" void printStats();
  public function extern "quantize" void quantize(rptr{uint} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback_0);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} _0);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "addHandle" uint addHandle(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} pOwner_2, short collisionFilterGroup_3, short collisionFilterMask_4, rptr{btDispatcher} dispatcher_5, rptr{void} multiSapProxy_6);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "getNumHandles" uint getNumHandles() const;
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>::Edge" "nodefault" btAxisSweep3Internal_unsigned_int_Edge private {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>::Handle" "nodefault" btAxisSweep3Internal_unsigned_int_Handle private {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>" "nodefault" btAxisSweep3Internal_unsigned_short(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, ushort handleMask_2, ushort handleSentinel_3, ushort userMaxHandles_4, rptr{btOverlappingPairCache} pairCache_5, bool disableRaycastAccelerator_6)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_short_Handle} getHandle(ushort index_0) const;
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback_0);
  public function extern "updateHandle" void updateHandle(ushort handle_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "removeHandle" void removeHandle(ushort handle_0, rptr{btDispatcher} dispatcher_1);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "getNumHandles" ushort getNumHandles() const;
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "addHandle" ushort addHandle(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} pOwner_2, short collisionFilterGroup_3, short collisionFilterMask_4, rptr{btDispatcher} dispatcher_5, rptr{void} multiSapProxy_6);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} _0);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback_0);
  public function extern "printStats" void printStats();
  public function extern "quantize" void quantize(rptr{ushort} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>::Edge" "nodefault" btAxisSweep3Internal_unsigned_short_Edge private {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>::Handle" "nodefault" btAxisSweep3Internal_unsigned_short_Handle private {
}
public threaded struct extern "::btBU_Simplex1to4" "nonmovable" btBU_Simplex1to4 {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape, btPolyhedralConvexAabbCachingShape};
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getIndex" int getIndex(int i_0) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "addVertex" void addVertex(btVector3 const& pt_0);
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "reset" void reset();
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
}
public threaded struct extern "::btBlock" btBlock {
  public rptr{uchar} address;
  public rptr{btBlock} previous;
}
public threaded struct extern "::btBox2dBox2dCollisionAlgorithm" "nodefault" btBox2dBox2dCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btCollisionAlgorithm, btActivatingCollisionAlgorithm};
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btBox2dBox2dCollisionAlgorithm::CreateFunc" "nonmovable" btBox2dBox2dCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btBox2dShape" "nodefault" btBox2dShape(btVector3 const& boxHalfExtents_0)  {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getNormals" crptr{btVector3} getNormals() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getCentroid" btVector3 const& getCentroid() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getPlaneEquation" void getPlaneEquation(btVector4 mutable& plane_0, int i_1) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getVertexCount" int getVertexCount() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getVertices" crptr{btVector3} getVertices() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
}
public threaded struct extern "::btBoxBoxCollisionAlgorithm" "nodefault" btBoxBoxCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
}
public threaded struct extern "::btBoxBoxCollisionAlgorithm::CreateFunc" "nonmovable" btBoxBoxCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btBoxBoxDetector" "nodefault" btBoxBoxDetector(crptr{btBoxShape} box1_0, crptr{btBoxShape} box2_1)  {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface};
  public function extern "getClosestPoints" void getClosestPoints(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input_0, btDiscreteCollisionDetectorInterface_Result mutable& output_1, rptr{btIDebugDraw} debugDraw_2, bool swapResults_3);
  public crptr{btBoxShape} m_box2;
  public crptr{btBoxShape} m_box1;
}
public threaded struct extern "::btBoxShape" "nodefault" btBoxShape(btVector3 const& boxHalfExtents_0)  {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getPlaneEquation" void getPlaneEquation(btVector4 mutable& plane_0, int i_1) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
}
public threaded struct extern "::btBroadphaseAabbCallback" "nonmovable" btBroadphaseAabbCallback {
  public function extern "process" bool process(crptr{btBroadphaseProxy} proxy_0);
}
public metafunction btBroadphaseCallback rptr{meta::list{void, rptr{void}, rptr{void}, rptr{void}}};
public threaded struct extern "::btBroadphaseInterface" "nonmovable" btBroadphaseInterface {
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "printStats" void printStats();
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
}
public threaded struct extern "::btBroadphasePair" btBroadphasePair {
  public rptr{btCollisionAlgorithm} m_algorithm;
  public rptr{btBroadphaseProxy} m_pProxy0;
  public rptr{btBroadphaseProxy} m_pProxy1;
}
public metafunction btBroadphasePairArray btAlignedObjectArray_btBroadphasePair;
public threaded struct extern "::btBroadphasePairSortPredicate" btBroadphasePairSortPredicate {
}
/* skip btBroadphasePair_27 : unnamed */
public threaded struct extern "::btBroadphaseProxy" btBroadphaseProxy {
  public function extern "getUid" int getUid() const;
  public short m_collisionFilterGroup;
  public btVector3 m_aabbMin;
  public rptr{void} m_clientObject;
  public btVector3 m_aabbMax;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
  public short m_collisionFilterMask;
}
public threaded struct extern "::btBroadphaseRayCallback" btBroadphaseRayCallback {
  public metafunction __base__ {btBroadphaseAabbCallback};
  public function extern "process" bool process(crptr{btBroadphaseProxy} proxy_0);
  public rawarray{uint, 3} m_signs;
  public btVector3 m_rayDirectionInverse;
  public btScalar m_lambda_max;
}
public threaded struct extern "::btBulletFile" "nodefault" btBulletFile private {
}
public threaded struct extern "::btBulletWorldImporter" "nodefault" btBulletWorldImporter(rptr{btDynamicsWorld} world_0)  {
  public metafunction __base__ {btWorldImporter};
  public function extern "getConstraintByName" rptr{btTypedConstraint} getConstraintByName(crptr{char} name_0);
  public function extern "createMultiSphereShape" rptr{btMultiSphereShape} createMultiSphereShape(crptr{btVector3} positions_0, crptr{btScalar} radi_1, int numSpheres_2);
  public function extern "createConvexHullShape" rptr{btConvexHullShape} createConvexHullShape();
  public function extern "createCylinderShapeX" rptr{btCollisionShape} createCylinderShapeX(btScalar radius_0, btScalar height_1);
  public function extern "createGimpactShape" rptr{btGImpactMeshShape} createGimpactShape(rptr{btStridingMeshInterface} trimesh_0);
  public function extern "createConeTwistConstraint" rptr{btConeTwistConstraint} createConeTwistConstraint2(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1);
  public function extern "createConeTwistConstraint" rptr{btConeTwistConstraint} createConeTwistConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3);
  public function extern "createCapsuleShapeY" rptr{btCollisionShape} createCapsuleShapeY(btScalar radius_0, btScalar height_1);
  public function extern "createRigidBody" rptr{btRigidBody} createRigidBody(bool isDynamic_0, btScalar mass_1, btTransform const& startTransform_2, rptr{btCollisionShape} shape_3, crptr{char} bodyName_4);
  public function extern "createCapsuleShapeX" rptr{btCollisionShape} createCapsuleShapeX(btScalar radius_0, btScalar height_1);
  public function extern "setVerboseMode" void setVerboseMode(int verboseMode_0);
  public function extern "createPlaneShape" rptr{btCollisionShape} createPlaneShape(btVector3 const& planeNormal_0, btScalar planeConstant_1);
  public function extern "createBvhTriangleMeshShape" rptr{btBvhTriangleMeshShape} createBvhTriangleMeshShape(rptr{btStridingMeshInterface} trimesh_0, rptr{btOptimizedBvh} bvh_1);
  public function extern "createStridingMeshInterfaceData" rptr{btStridingMeshInterfaceData} createStridingMeshInterfaceData(rptr{btStridingMeshInterfaceData} interfaceData_0);
  public function extern "createCollisionObject" rptr{btCollisionObject} createCollisionObject(btTransform const& startTransform_0, rptr{btCollisionShape} shape_1, crptr{char} bodyName_2);
  public function extern "createOptimizedBvh" rptr{btOptimizedBvh} createOptimizedBvh();
  public function extern "createHingeConstraint" rptr{btHingeConstraint} createHingeConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3, bool useReferenceFrameA_4);
  public function extern "createHingeConstraint" rptr{btHingeConstraint} createHingeConstraint3(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1, bool useReferenceFrameA_2);
  public function extern "getConstraintByIndex" rptr{btTypedConstraint} getConstraintByIndex(int index_0) const;
  public function extern "createGeneric6DofSpringConstraint" rptr{btGeneric6DofSpringConstraint} createGeneric6DofSpringConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
  public function extern "getRigidBodyByIndex" rptr{btCollisionObject} getRigidBodyByIndex(int index_0) const;
  public function extern "getCollisionShapeByIndex" rptr{btCollisionShape} getCollisionShapeByIndex(int index_0);
  public function extern "loadFileFromMemory" bool loadFileFromMemory(rptr{char} memoryBuffer_0, int len_1);
  public function extern "loadFile" bool loadFile(crptr{char} fileName_0, crptr{char} preSwapFilenameOut_1);
  public function extern "createSphereShape" rptr{btCollisionShape} createSphereShape(btScalar radius_0);
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getVerboseMode" int getVerboseMode() const;
  public function extern "getNameForPointer" crptr{char} getNameForPointer(crptr{void} ptr_0) const;
  public function extern "createTriangleInfoMap" rptr{btTriangleInfoMap} createTriangleInfoMap();
  public function extern "getNumTriangleInfoMaps" int getNumTriangleInfoMaps() const;
  public function extern "setDynamicsWorldInfo" void setDynamicsWorldInfo(btVector3 const& gravity_0, btContactSolverInfo const& solverInfo_1);
  public function extern "createCapsuleShapeZ" rptr{btCollisionShape} createCapsuleShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "createBoxShape" rptr{btCollisionShape} createBoxShape(btVector3 const& halfExtents_0);
  public function extern "createConeShapeY" rptr{btCollisionShape} createConeShapeY(btScalar radius_0, btScalar height_1);
  public function extern "createConvexTriangleMeshShape" rptr{btCollisionShape} createConvexTriangleMeshShape(rptr{btStridingMeshInterface} trimesh_0);
  public function extern "createConeShapeZ" rptr{btCollisionShape} createConeShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "createSliderConstraint" rptr{btSliderConstraint} createSliderConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameA_2);
  public function extern "createSliderConstraint" rptr{btSliderConstraint} createSliderConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
  public function extern "createGearConstraint" rptr{btGearConstraint} createGearConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& axisInA_2, btVector3 const& axisInB_3, btScalar ratio_4);
  public function extern "createGeneric6DofConstraint" rptr{btGeneric6DofConstraint} createGeneric6DofConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameB_2);
  public function extern "createGeneric6DofConstraint" rptr{btGeneric6DofConstraint} createGeneric6DofConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
  public function extern "createScaledTrangleMeshShape" rptr{btScaledBvhTriangleMeshShape} createScaledTrangleMeshShape(rptr{btBvhTriangleMeshShape} meshShape_0, btVector3 const& localScalingbtBvhTriangleMeshShape_1);
  public function extern "createCompoundShape" rptr{btCompoundShape} createCompoundShape();
  public function extern "createMeshInterface" rptr{btTriangleIndexVertexArray} createMeshInterface(btStridingMeshInterfaceData mutable& meshData_0);
  public function extern "getNumBvhs" int getNumBvhs() const;
  public function extern "getNumRigidBodies" int getNumRigidBodies() const;
  public function extern "createConeShapeX" rptr{btCollisionShape} createConeShapeX(btScalar radius_0, btScalar height_1);
  public function extern "getCollisionShapeByName" rptr{btCollisionShape} getCollisionShapeByName(crptr{char} name_0);
  public function extern "deleteAllData" void deleteAllData();
  public function extern "createCylinderShapeZ" rptr{btCollisionShape} createCylinderShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "getTriangleInfoMapByIndex" rptr{btTriangleInfoMap} getTriangleInfoMapByIndex(int index_0) const;
  public function extern "createCylinderShapeY" rptr{btCollisionShape} createCylinderShapeY(btScalar radius_0, btScalar height_1);
  public function extern "createTriangleMeshContainer" rptr{btTriangleIndexVertexArray} createTriangleMeshContainer();
  public function extern "getBvhByIndex" rptr{btOptimizedBvh} getBvhByIndex(int index_0) const;
  public function extern "createPoint2PointConstraint" rptr{btPoint2PointConstraint} createPoint2PointConstraint2(btRigidBody mutable& rbA_0, btVector3 const& pivotInA_1);
  public function extern "createPoint2PointConstraint" rptr{btPoint2PointConstraint} createPoint2PointConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3);
  public function extern "getNumCollisionShapes" int getNumCollisionShapes() const;
  public function extern "getRigidBodyByName" rptr{btRigidBody} getRigidBodyByName(crptr{char} name_0);
}
public threaded struct extern "::btBvhSubtreeInfo" btBvhSubtreeInfo {
  public function extern "setAabbFromQuantizeNode" void setAabbFromQuantizeNode(btQuantizedBvhNode const& quantizedNode_0);
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public int m_subtreeSize;
  public int m_rootNodeIndex;
  public rawarray{int, 3} m_padding;
  public rawarray{ushort, 3} m_quantizedAabbMax;
}
public threaded struct extern "::btBvhSubtreeInfoData" btBvhSubtreeInfoData {
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public int m_rootNodeIndex;
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public int m_subtreeSize;
}
public threaded struct extern "::btBvhTree" btBvhTree {
  public function extern "setNodeBound" void setNodeBound(int nodeindex_0, btAABB const& bound_1);
  public function extern "getEscapeNodeIndex" int getEscapeNodeIndex(int nodeindex_0) const;
  public function extern "getNodeCount" int getNodeCount() const;
  public function extern "getRightNode" int getRightNode(int nodeindex_0) const;
  public function extern "isLeafNode" bool isLeafNode(int nodeindex_0) const;
  public function extern "getNodeBound" void getNodeBound(int nodeindex_0, btAABB mutable& bound_1) const;
  public function extern "getLeftNode" int getLeftNode(int nodeindex_0) const;
  public function extern "getNodeData" int getNodeData(int nodeindex_0) const;
  public function extern "clearNodes" void clearNodes();
}
public threaded struct extern "::btBvhTriangleMeshShape" "nodefault" btBvhTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, bool buildBvh_2)  {
  public metafunction __base__ {btConcaveShape, btTriangleMeshShape, btCollisionShape};
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "performRaycast" void performRaycast(rptr{btTriangleCallback} callback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2);
  public function extern "setTriangleInfoMap" void setTriangleInfoMap(rptr{btTriangleInfoMap} triangleInfoMap_0);
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "partialRefitTree" void partialRefitTree(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1);
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getOptimizedBvh" rptr{btOptimizedBvh} getOptimizedBvh();
  public function extern "getShapeType" int getShapeType() const;
  public function extern "setOptimizedBvh" void setOptimizedBvh(rptr{btOptimizedBvh} bvh_0, btVector3 const& localScaling_1);
  public function extern "refitTree" void refitTree(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getOwnsBvh" bool getOwnsBvh() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getTriangleInfoMap" rptr{btTriangleInfoMap} getTriangleInfoMap();
  public function extern "getTriangleInfoMap" crptr{btTriangleInfoMap} cgetTriangleInfoMap() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "usesQuantizedAabbCompression" bool usesQuantizedAabbCompression() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "serializeSingleTriangleInfoMap" void serializeSingleTriangleInfoMap(rptr{btSerializer} serializer_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "serializeSingleBvh" void serializeSingleBvh(rptr{btSerializer} serializer_0) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "buildOptimizedBvh" void buildOptimizedBvh();
  public function extern "performConvexcast" void performConvexcast(rptr{btTriangleCallback} callback_0, btVector3 const& boxSource_1, btVector3 const& boxTarget_2, btVector3 const& boxMin_3, btVector3 const& boxMax_4);
}
public threaded struct extern "::btCPUVertexBufferDescriptor" "nodefault" btCPUVertexBufferDescriptor(rptr{float} basePointer_0, int vertexOffset_1, int vertexStride_2)  {
  public metafunction __base__ {btVertexBufferDescriptor};
  public function extern "getBasePointer" rptr{float} getBasePointer() const;
  public function extern "getNormalOffset" int getNormalOffset() const;
  public function extern "getVertexOffset" int getVertexOffset() const;
  public function extern "hasVertexPositions" bool hasVertexPositions() const;
  public function extern "getNormalStride" int getNormalStride() const;
  public function extern "getVertexStride" int getVertexStride() const;
  public function extern "hasNormals" bool hasNormals() const;
}
public threaded struct extern "::btCapsuleShape" "nodefault" btCapsuleShape(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
}
public threaded struct extern "::btCapsuleShapeData" btCapsuleShapeData {
  public rawarray{char, 4} m_padding;
  public int m_upAxis;
  public btConvexInternalShapeData m_convexInternalShapeData;
}
public threaded struct extern "::btCapsuleShapeX" "nodefault" btCapsuleShapeX(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCapsuleShape, btCollisionShape};
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
}
public threaded struct extern "::btCapsuleShapeZ" "nodefault" btCapsuleShapeZ(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCapsuleShape, btCollisionShape};
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
}
public threaded struct extern "::btCharIndexTripletData" btCharIndexTripletData {
  public char m_pad;
  public rawarray{uchar, 3} m_values;
}
public threaded struct extern "::btCharacterControllerInterface" "nonmovable" btCharacterControllerInterface {
  public metafunction __base__ {btActionInterface};
  public function extern "canJump" bool canJump() const;
  public function extern "setWalkDirection" void setWalkDirection(btVector3 const& walkDirection_0);
  public function extern "setUpInterpolate" void setUpInterpolate(bool value_0);
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "warp" void warp(btVector3 const& origin_0);
  public function extern "preStep" void preStep(rptr{btCollisionWorld} collisionWorld_0);
  public function extern "setVelocityForTimeInterval" void setVelocityForTimeInterval(btVector3 const& velocity_0, btScalar timeInterval_1);
  public function extern "jump" void jump();
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld_0, btScalar deltaTimeStep_1);
  public function extern "onGround" bool onGround() const;
  public function extern "playerStep" void playerStep(rptr{btCollisionWorld} collisionWorld_0, btScalar dt_1);
  public function extern "reset" void reset(rptr{btCollisionWorld} collisionWorld_0);
}
public threaded struct extern "::btChunk" btChunk {
  public rptr{void} m_oldPtr;
  public int m_length;
  public int m_dna_nr;
  public int m_number;
  public int m_chunkCode;
}
public threaded struct extern "::btClock" btClock {
  public function extern "reset" void reset();
  public function extern "getTimeMilliseconds" ulong getTimeMilliseconds();
  public function extern "getTimeMicroseconds" ulong getTimeMicroseconds();
}
public threaded struct extern "::btClockData" "nodefault" btClockData private {
}
public threaded struct extern "::btCollisionAlgorithm" "nonmovable" btCollisionAlgorithm {
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btCollisionAlgorithmConstructionInfo" btCollisionAlgorithmConstructionInfo {
  public rptr{btDispatcher} m_dispatcher1;
  public rptr{btPersistentManifold} m_manifold;
}
public threaded struct extern "::btCollisionAlgorithmCreateFunc" "nonmovable" btCollisionAlgorithmCreateFunc {
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btCollisionConfiguration" "nonmovable" btCollisionConfiguration {
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0_0, int proxyType1_1);
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
}
public threaded struct extern "::btCollisionDispatcher" "nodefault" btCollisionDispatcher(rptr{btCollisionConfiguration} collisionConfiguration_0)  {
  public metafunction __base__ {btDispatcher};
  public function extern "getInternalManifoldPointer" rptr{rptr{btPersistentManifold}} getInternalManifoldPointer();
  public function extern "getDispatcherFlags" int getDispatcherFlags() const;
  public function extern "setCollisionConfiguration" void setCollisionConfiguration(rptr{btCollisionConfiguration} config_0);
  public function extern "getNearCallback" btNearCallback getNearCallback() const;
  public function extern "dispatchAllCollisionPairs" void dispatchAllCollisionPairs(rptr{btOverlappingPairCache} pairCache_0, btDispatcherInfo const& dispatchInfo_1, rptr{btDispatcher} dispatcher_2);
  public function extern "getNumManifolds" int getNumManifolds() const;
  public function extern "setDispatcherFlags" void setDispatcherFlags(int flags_0);
  public function extern "needsCollision" bool needsCollision(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
  public function extern "releaseManifold" void releaseManifold(rptr{btPersistentManifold} manifold_0);
  public function extern "getNewManifold" rptr{btPersistentManifold} getNewManifold(crptr{btCollisionObject} b0_0, crptr{btCollisionObject} b1_1);
  public function extern "setNearCallback" void setNearCallback(btNearCallback nearCallback_0);
  public function extern "getManifoldByIndexInternal" rptr{btPersistentManifold} getManifoldByIndexInternal(int index_0);
  public function extern "getManifoldByIndexInternal" crptr{btPersistentManifold} cgetManifoldByIndexInternal(int index_0) const;
  public function extern "findAlgorithm" rptr{btCollisionAlgorithm} findAlgorithm(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, rptr{btPersistentManifold} sharedManifold_2);
  public function extern "allocateCollisionAlgorithm" rptr{void} allocateCollisionAlgorithm(int size_0);
  public function extern "registerCollisionCreateFunc" void registerCollisionCreateFunc(int proxyType0_0, int proxyType1_1, rptr{btCollisionAlgorithmCreateFunc} createFunc_2);
  public function extern "freeCollisionAlgorithm" void freeCollisionAlgorithm(rptr{void} ptr_0);
  public function extern "clearManifold" void clearManifold(rptr{btPersistentManifold} manifold_0);
  public function extern "getCollisionConfiguration" crptr{btCollisionConfiguration} cgetCollisionConfiguration() const;
  public function extern "getCollisionConfiguration" rptr{btCollisionConfiguration} getCollisionConfiguration();
  public function extern "getInternalManifoldPool" rptr{btPoolAllocator} getInternalManifoldPool();
  public function extern "getInternalManifoldPool" crptr{btPoolAllocator} cgetInternalManifoldPool() const;
  public function extern "needsResponse" bool needsResponse(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
}
public threaded struct extern "::btCollisionObject" "nonmovable" btCollisionObject {
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "getInternalType" int getInternalType() const;
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "isActive" bool isActive() const;
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "activate" void activate(bool forceActivation_0) const;
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "getUserIndex" int getUserIndex() const;
}
public metafunction btCollisionObjectArray btAlignedObjectArray_btCollisionObject_p;
public threaded struct extern "::btCollisionObjectDoubleData" btCollisionObjectDoubleData {
  public rptr{void} m_broadphaseHandle;
  public int m_collisionFlags;
  public int m_activationState1;
  public double m_deactivationTime;
  public int m_internalType;
  public rawarray{char, 4} m_padding;
  public btVector3DoubleData m_interpolationLinearVelocity;
  public double m_ccdMotionThreshold;
  public rptr{char} m_name;
  public int m_hasAnisotropicFriction;
  public double m_restitution;
  public double m_rollingFriction;
  public int m_islandTag1;
  public btVector3DoubleData m_anisotropicFriction;
  public int m_companionId;
  public rptr{btCollisionShapeData} m_rootCollisionShape;
  public int m_checkCollideWith;
  public double m_friction;
  public btVector3DoubleData m_interpolationAngularVelocity;
  public rptr{void} m_collisionShape;
  public double m_hitFraction;
  public double m_contactProcessingThreshold;
  public double m_ccdSweptSphereRadius;
  public btTransformDoubleData m_worldTransform;
  public btTransformDoubleData m_interpolationWorldTransform;
}
public threaded struct extern "::btCollisionObjectFloatData" btCollisionObjectFloatData {
  public rawarray{char, 4} m_padding;
  public btVector3FloatData m_interpolationLinearVelocity;
  public rptr{char} m_name;
  public float m_ccdMotionThreshold;
  public int m_hasAnisotropicFriction;
  public rptr{void} m_broadphaseHandle;
  public int m_collisionFlags;
  public int m_activationState1;
  public float m_deactivationTime;
  public int m_internalType;
  public float m_friction;
  public btVector3FloatData m_interpolationAngularVelocity;
  public rptr{void} m_collisionShape;
  public float m_hitFraction;
  public float m_contactProcessingThreshold;
  public float m_ccdSweptSphereRadius;
  public btTransformFloatData m_worldTransform;
  public btTransformFloatData m_interpolationWorldTransform;
  public float m_restitution;
  public float m_rollingFriction;
  public int m_islandTag1;
  public btVector3FloatData m_anisotropicFriction;
  public int m_companionId;
  public rptr{btCollisionShapeData} m_rootCollisionShape;
  public int m_checkCollideWith;
}
public threaded struct extern "::btCollisionObjectWrapper" "nodefault" btCollisionObjectWrapper(crptr{btCollisionObjectWrapper} parent_0, crptr{btCollisionShape} shape_1, crptr{btCollisionObject} collisionObject_2, btTransform const& worldTransform_3, int partId_4, int index_5)  {
  public function extern "getCollisionShape" crptr{btCollisionShape} getCollisionShape() const;
  public function extern "getWorldTransform" btTransform const& getWorldTransform() const;
  public function extern "getCollisionObject" crptr{btCollisionObject} getCollisionObject() const;
  public int m_partId;
  public crptr{btCollisionObject} m_collisionObject;
  public crptr{btCollisionShape} m_shape;
  public int m_index;
  public crptr{btCollisionObjectWrapper} m_parent;
}
/* skip btCollisionObject_26 : unnamed */
public threaded struct extern "::btCollisionResult" "nodefault" btCollisionResult private {
}
public threaded struct extern "::btCollisionShape" "nonmovable" btCollisionShape {
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getName" crptr{char} getName() const;
}
public threaded struct extern "::btCollisionShapeData" btCollisionShapeData {
  public rawarray{char, 4} m_padding;
  public rptr{char} m_name;
  public int m_shapeType;
}
public threaded struct extern "::btCollisionWorld" "nodefault" btCollisionWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} broadphasePairCache_1, rptr{btCollisionConfiguration} collisionConfiguration_2)  {
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "updateAabbs" void updateAabbs();
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
}
public threaded struct extern "::btCollisionWorld::AllHitsRayResultCallback" "nodefault" btCollisionWorld_AllHitsRayResultCallback(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1)  {
  public metafunction __base__ {btCollisionWorld_RayResultCallback};
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public function extern "hasHit" bool hasHit() const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult_0, bool normalInWorldSpace_1);
  public short m_collisionFilterGroup;
  public btVector3 m_rayFromWorld;
  public btScalar m_closestHitFraction;
  public uint m_flags;
  public btVector3 m_rayToWorld;
  public crptr{btCollisionObject} m_collisionObject;
  public btAlignedObjectArray_btCollisionObject_const_p m_collisionObjects;
  public btAlignedObjectArray_float m_hitFractions;
  public short m_collisionFilterMask;
  public btAlignedObjectArray_btVector3 m_hitNormalWorld;
  public btAlignedObjectArray_btVector3 m_hitPointWorld;
}
public threaded struct extern "::btCollisionWorld::ClosestConvexResultCallback" "nodefault" btCollisionWorld_ClosestConvexResultCallback(btVector3 const& convexFromWorld_0, btVector3 const& convexToWorld_1)  {
  public metafunction __base__ {btCollisionWorld_ConvexResultCallback};
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public function extern "hasHit" bool hasHit() const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalConvexResult mutable& convexResult_0, bool normalInWorldSpace_1);
  public short m_collisionFilterGroup;
  public crptr{btCollisionObject} m_hitCollisionObject;
  public btScalar m_closestHitFraction;
  public btVector3 m_convexToWorld;
  public btVector3 m_convexFromWorld;
  public btVector3 m_hitNormalWorld;
  public btVector3 m_hitPointWorld;
  public short m_collisionFilterMask;
}
public threaded struct extern "::btCollisionWorld::ClosestRayResultCallback" "nodefault" btCollisionWorld_ClosestRayResultCallback(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1)  {
  public metafunction __base__ {btCollisionWorld_RayResultCallback};
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult_0, bool normalInWorldSpace_1);
  public function extern "hasHit" bool hasHit() const;
  public btVector3 m_hitPointWorld;
  public btVector3 m_hitNormalWorld;
  public short m_collisionFilterMask;
  public crptr{btCollisionObject} m_collisionObject;
  public btVector3 m_rayToWorld;
  public uint m_flags;
  public btScalar m_closestHitFraction;
  public btVector3 m_rayFromWorld;
  public short m_collisionFilterGroup;
}
public threaded struct extern "::btCollisionWorld::ContactResultCallback" "nonmovable" btCollisionWorld_ContactResultCallback {
  public function extern "addSingleResult" btScalar addSingleResult(btManifoldPoint mutable& cp_0, crptr{btCollisionObjectWrapper} colObj0Wrap_1, int partId0_2, int index0_3, crptr{btCollisionObjectWrapper} colObj1Wrap_4, int partId1_5, int index1_6);
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public short m_collisionFilterMask;
  public short m_collisionFilterGroup;
}
public threaded struct extern "::btCollisionWorld::ConvexResultCallback" "nonmovable" btCollisionWorld_ConvexResultCallback {
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalConvexResult mutable& convexResult_0, bool normalInWorldSpace_1);
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public btScalar m_closestHitFraction;
  public short m_collisionFilterMask;
  public short m_collisionFilterGroup;
}
public threaded struct extern "::btCollisionWorld::LocalConvexResult" "nodefault" btCollisionWorld_LocalConvexResult(crptr{btCollisionObject} hitCollisionObject_0, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo_1, btVector3 const& hitNormalLocal_2, btVector3 const& hitPointLocal_3, btScalar hitFraction_4)  {
  public rptr{btCollisionWorld_LocalShapeInfo} m_localShapeInfo;
  public btVector3 m_hitPointLocal;
  public btScalar m_hitFraction;
  public btVector3 m_hitNormalLocal;
  public crptr{btCollisionObject} m_hitCollisionObject;
}
public threaded struct extern "::btCollisionWorld::LocalRayResult" "nodefault" btCollisionWorld_LocalRayResult(crptr{btCollisionObject} collisionObject_0, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo_1, btVector3 const& hitNormalLocal_2, btScalar hitFraction_3)  {
  public rptr{btCollisionWorld_LocalShapeInfo} m_localShapeInfo;
  public crptr{btCollisionObject} m_collisionObject;
  public btScalar m_hitFraction;
  public btVector3 m_hitNormalLocal;
}
public threaded struct extern "::btCollisionWorld::LocalShapeInfo" btCollisionWorld_LocalShapeInfo {
  public int m_triangleIndex;
  public int m_shapePart;
}
public threaded struct extern "::btCollisionWorld::RayResultCallback" "nonmovable" btCollisionWorld_RayResultCallback {
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult_0, bool normalInWorldSpace_1);
  public function extern "hasHit" bool hasHit() const;
  public short m_collisionFilterGroup;
  public uint m_flags;
  public btScalar m_closestHitFraction;
  public short m_collisionFilterMask;
  public crptr{btCollisionObject} m_collisionObject;
}
public threaded struct extern "::btCompoundCollisionAlgorithm" "nodefault" btCompoundCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btCollisionAlgorithm, btActivatingCollisionAlgorithm};
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getChildAlgorithm" rptr{btCollisionAlgorithm} getChildAlgorithm(int n_0) const;
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
}
public threaded struct extern "::btCompoundCollisionAlgorithm::CreateFunc" "nonmovable" btCompoundCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btCompoundCollisionAlgorithm::SwappedCreateFunc" "nonmovable" btCompoundCollisionAlgorithm_SwappedCreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btCompoundCompoundCollisionAlgorithm" "nodefault" btCompoundCompoundCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btCompoundCompoundCollisionAlgorithm::CreateFunc" "nonmovable" btCompoundCompoundCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btCompoundCompoundCollisionAlgorithm::SwappedCreateFunc" "nonmovable" btCompoundCompoundCollisionAlgorithm_SwappedCreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btCompoundShape" "nodefault" btCompoundShape(bool enableDynamicAabbTree_0)  {
  public metafunction __base__ {btCollisionShape};
  public function extern "addChildShape" void addChildShape(btTransform const& localTransform_0, rptr{btCollisionShape} shape_1);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "getDynamicAabbTree" crptr{btDbvt} cgetDynamicAabbTree() const;
  public function extern "getDynamicAabbTree" rptr{btDbvt} getDynamicAabbTree();
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index_0);
  public function extern "getChildShape" crptr{btCollisionShape} cgetChildShape(int index_0) const;
  public function extern "calculatePrincipalAxisTransform" void calculatePrincipalAxisTransform(rptr{btScalar} masses_0, btTransform mutable& principal_1, btVector3 mutable& inertia_2) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "createAabbTreeFromChildren" void createAabbTreeFromChildren();
  public function extern "getChildList" rptr{btCompoundShapeChild} getChildList();
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "removeChildShape" void removeChildShape(rptr{btCollisionShape} shape_0);
  public function extern "recalculateLocalAabb" void recalculateLocalAabb();
  public function extern "removeChildShapeByIndex" void removeChildShapeByIndex(int childShapeindex_0);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getUpdateRevision" int getUpdateRevision() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getChildTransform" btTransform const& cgetChildTransform(int index_0) const;
  public function extern "getChildTransform" btTransform mutable& getChildTransform(int index_0);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "updateChildTransform" void updateChildTransform(int childIndex_0, btTransform const& newChildTransform_1, bool shouldRecalculateLocalAabb_2);
  public function extern "getNumChildShapes" int getNumChildShapes() const;
}
public threaded struct extern "::btCompoundShapeChild" btCompoundShapeChild {
  public rptr{btDbvtNode} m_node;
  public rptr{btCollisionShape} m_childShape;
  public int m_childShapeType;
  public btScalar m_childMargin;
  public btTransform m_transform;
}
public threaded struct extern "::btCompoundShapeChildData" btCompoundShapeChildData {
  public rptr{btCollisionShapeData} m_childShape;
  public int m_childShapeType;
  public float m_childMargin;
  public btTransformFloatData m_transform;
}
public threaded struct extern "::btCompoundShapeData" btCompoundShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public rptr{btCompoundShapeChildData} m_childShapePtr;
  public int m_numChildShapes;
  public float m_collisionMargin;
}
public threaded struct extern "::btConcaveShape" "nonmovable" btConcaveShape {
  public metafunction __base__ {btCollisionShape};
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
}
public threaded struct extern "::btConeShape" "nodefault" btConeShape(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btCollisionShape, btConvexInternalShape, btConvexShape};
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex_0);
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
}
public threaded struct extern "::btConeShapeData" btConeShapeData {
  public rawarray{char, 4} m_padding;
  public int m_upIndex;
  public btConvexInternalShapeData m_convexInternalShapeData;
}
public threaded struct extern "::btConeShapeX" "nodefault" btConeShapeX(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape, btConeShape};
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex_0);
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
}
public threaded struct extern "::btConeShapeZ" "nodefault" btConeShapeZ(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btConeShape, btCollisionShape};
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex_0);
  public function extern "isConvex" bool isConvex() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHeight" btScalar getHeight() const;
}
public threaded struct extern "::btConeTwistConstraint" "nodefault" btConeTwistConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getTwistAngle" btScalar getTwistAngle();
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "getUid" int getUid() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getBFrame" btTransform const& getBFrame();
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getSwingSpan2" btScalar getSwingSpan2();
  public function extern "getSolveSwingLimit" int getSolveSwingLimit();
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform const& getFrameOffsetA() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "isPastSwingLimit" bool isPastSwingLimit();
  public function extern "getFixThresh" btScalar getFixThresh();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setDamping" void setDamping(btScalar damping_0);
  public function extern "calcAngleInfo" void calcAngleInfo();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "setMotorTargetInConstraintSpace" void setMotorTargetInConstraintSpace(btQuaternion const& q_0);
  public function extern "setMaxMotorImpulseNormalized" void setMaxMotorImpulseNormalized(btScalar maxMotorImpulse_0);
  public function extern "getTwistSpan" btScalar getTwistSpan();
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "setMotorTarget" void setMotorTarget(btQuaternion const& q_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "getAFrame" btTransform const& getAFrame();
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "getTwistLimitSign" btScalar getTwistLimitSign();
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "calcAngleInfo2" void calcAngleInfo2(btTransform const& transA_0, btTransform const& transB_1, btMatrix3x3 const& invInertiaWorldA_2, btMatrix3x3 const& invInertiaWorldB_3);
  public function extern "getSolveTwistLimit" int getSolveTwistLimit();
  public function extern "getSwingSpan1" btScalar getSwingSpan1();
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse_0);
  public function extern "setLimit" void setLimit2(int limitIndex_0, btScalar limitValue_1);
  public function extern "setLimit" void setLimit6(btScalar _swingSpan1_0, btScalar _swingSpan2_1, btScalar _twistSpan_2, btScalar _softness_3, btScalar _biasFactor_4, btScalar _relaxationFactor_5);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setFixThresh" void setFixThresh(btScalar fixThresh_0);
  public function extern "enableMotor" void enableMotor(bool b_0);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "getFrameOffsetB" btTransform const& getFrameOffsetB() const;
  public function extern "GetPointForAngle" btVector3 GetPointForAngle(btScalar fAngleInRadians_0, btScalar fLength_1) const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btMatrix3x3 const& invInertiaWorldA_3, btMatrix3x3 const& invInertiaWorldB_4);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& bodyA_0, btSolverBody mutable& bodyB_1, btScalar timeStep_2);
  public int m_objectType;
}
public threaded struct extern "::btConeTwistConstraintData" btConeTwistConstraintData {
  public float m_biasFactor;
  public float m_relaxationFactor;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public btTypedConstraintData m_typeConstraintData;
  public float m_swingSpan1;
  public float m_damping;
  public float m_swingSpan2;
  public float m_limitSoftness;
  public rawarray{char, 4} m_pad;
  public float m_twistSpan;
}
public threaded struct extern "::btConeTwistConstraintDoubleData" btConeTwistConstraintDoubleData {
  public double m_biasFactor;
  public btTransformDoubleData m_rbAFrame;
  public double m_relaxationFactor;
  public btTransformDoubleData m_rbBFrame;
  public btTypedConstraintDoubleData m_typeConstraintData;
  public double m_swingSpan1;
  public double m_damping;
  public double m_limitSoftness;
  public double m_swingSpan2;
  public double m_twistSpan;
}
public tsvaluetype struct extern "::btConeTwistFlags" "extenum" btConeTwistFlags { }
public extern "BT_CONETWIST_FLAGS_LIN_CFM" btConeTwistFlags BT_CONETWIST_FLAGS_LIN_CFM;
public extern "BT_CONETWIST_FLAGS_LIN_ERP" btConeTwistFlags BT_CONETWIST_FLAGS_LIN_ERP;
public extern "BT_CONETWIST_FLAGS_ANG_CFM" btConeTwistFlags BT_CONETWIST_FLAGS_ANG_CFM;
public metafunction btConstraintArray btAlignedObjectArray_btSolverConstraint;
public tsvaluetype struct extern "::btConstraintParams" "extenum" btConstraintParams { }
public extern "BT_CONSTRAINT_ERP" btConstraintParams BT_CONSTRAINT_ERP;
public extern "BT_CONSTRAINT_STOP_ERP" btConstraintParams BT_CONSTRAINT_STOP_ERP;
public extern "BT_CONSTRAINT_CFM" btConstraintParams BT_CONSTRAINT_CFM;
public extern "BT_CONSTRAINT_STOP_CFM" btConstraintParams BT_CONSTRAINT_STOP_CFM;
public threaded struct extern "::btConstraintRow" btConstraintRow {
  public btScalar m_rhs;
  public btScalar m_lowerLimit;
  public btScalar m_accumImpulse;
  public btScalar m_upperLimit;
  public rawarray{btScalar, 3} m_normal;
  public btScalar m_jacDiagInv;
}
public threaded struct extern "::btConstraintSetting" btConstraintSetting {
  public btScalar m_tau;
  public btScalar m_impulseClamp;
  public btScalar m_damping;
}
public threaded struct extern "::btConstraintSolver" "nonmovable" btConstraintSolver {
  public function extern "reset" void reset();
  public function extern "prepareSolve" void prepareSolve(int _0, int _1);
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies_0, int numBodies_1, rptr{rptr{btPersistentManifold}} manifold_2, int numManifolds_3, rptr{rptr{btTypedConstraint}} constraints_4, int numConstraints_5, btContactSolverInfo const& info_6, rptr{btIDebugDraw} debugDrawer_7, rptr{btDispatcher} dispatcher_8);
  public function extern "allSolved" void allSolved(btContactSolverInfo const& _0, rptr{btIDebugDraw} _1);
  public function extern "getSolverType" btConstraintSolverType getSolverType() const;
}
public tsvaluetype struct extern "::btConstraintSolverType" "extenum" btConstraintSolverType { }
public extern "BT_SEQUENTIAL_IMPULSE_SOLVER" btConstraintSolverType BT_SEQUENTIAL_IMPULSE_SOLVER;
public extern "BT_MLCP_SOLVER" btConstraintSolverType BT_MLCP_SOLVER;
public threaded struct extern "::btContactConstraint" "nodefault" btContactConstraint(rptr{btPersistentManifold} contactManifold_0, btRigidBody mutable& rbA_1, btRigidBody mutable& rbB_2)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint};
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getContactManifold" crptr{btPersistentManifold} cgetContactManifold() const;
  public function extern "getContactManifold" rptr{btPersistentManifold} getContactManifold();
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setContactManifold" void setContactManifold(rptr{btPersistentManifold} contactManifold_0);
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "getUid" int getUid() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public int m_objectType;
}
public tsvaluetype struct extern "::btContactManifoldTypes" "extenum" btContactManifoldTypes { }
public extern "MIN_CONTACT_MANIFOLD_TYPE" btContactManifoldTypes MIN_CONTACT_MANIFOLD_TYPE;
public extern "BT_PERSISTENT_MANIFOLD_TYPE" btContactManifoldTypes BT_PERSISTENT_MANIFOLD_TYPE;
public threaded struct extern "::btContactSolverInfo" btContactSolverInfo {
  public metafunction __base__ {btContactSolverInfoData};
  public btScalar m_friction;
  public btScalar m_splitImpulsePenetrationThreshold;
  public int m_restingContactRestitutionThreshold;
  public btScalar m_timeStep;
  public int m_splitImpulse;
  public int m_numIterations;
  public btScalar m_erp;
  public btScalar m_maxErrorReduction;
  public btScalar m_damping;
  public btScalar m_restitution;
  public btScalar m_singleAxisRollingFrictionThreshold;
  public btScalar m_splitImpulseTurnErp;
  public btScalar m_erp2;
  public btScalar m_sor;
  public int m_minimumSolverBatchSize;
  public btScalar m_globalCfm;
  public btScalar m_warmstartingFactor;
  public int m_solverMode;
  public btScalar m_maxGyroscopicForce;
  public btScalar m_linearSlop;
  public btScalar m_tau;
}
public threaded struct extern "::btContactSolverInfoData" btContactSolverInfoData {
  public btScalar m_splitImpulseTurnErp;
  public btScalar m_erp2;
  public btScalar m_sor;
  public btScalar m_globalCfm;
  public int m_minimumSolverBatchSize;
  public btScalar m_maxErrorReduction;
  public btScalar m_damping;
  public btScalar m_restitution;
  public btScalar m_singleAxisRollingFrictionThreshold;
  public int m_splitImpulse;
  public btScalar m_timeStep;
  public int m_numIterations;
  public btScalar m_erp;
  public btScalar m_friction;
  public btScalar m_splitImpulsePenetrationThreshold;
  public int m_restingContactRestitutionThreshold;
  public btScalar m_linearSlop;
  public btScalar m_tau;
  public btScalar m_maxGyroscopicForce;
  public int m_solverMode;
  public btScalar m_warmstartingFactor;
}
public threaded struct extern "::btContactSolverInfoDoubleData" btContactSolverInfoDoubleData {
  public int m_solverMode;
  public double m_warmstartingFactor;
  public rawarray{char, 4} m_padding;
  public double m_linearSlop;
  public double m_tau;
  public double m_maxGyroscopicForce;
  public int m_splitImpulse;
  public double m_timeStep;
  public double m_erp;
  public int m_numIterations;
  public double m_friction;
  public double m_splitImpulsePenetrationThreshold;
  public int m_restingContactRestitutionThreshold;
  public double m_erp2;
  public double m_splitImpulseTurnErp;
  public double m_sor;
  public int m_minimumSolverBatchSize;
  public double m_globalCfm;
  public double m_maxErrorReduction;
  public double m_damping;
  public double m_restitution;
  public double m_singleAxisRollingFrictionThreshold;
}
public threaded struct extern "::btContactSolverInfoFloatData" btContactSolverInfoFloatData {
  public int m_minimumSolverBatchSize;
  public float m_globalCfm;
  public float m_splitImpulseTurnErp;
  public float m_erp2;
  public float m_sor;
  public float m_restitution;
  public float m_singleAxisRollingFrictionThreshold;
  public float m_maxErrorReduction;
  public float m_damping;
  public int m_numIterations;
  public float m_erp;
  public float m_timeStep;
  public int m_splitImpulse;
  public float m_splitImpulsePenetrationThreshold;
  public int m_restingContactRestitutionThreshold;
  public float m_friction;
  public float m_tau;
  public float m_linearSlop;
  public float m_maxGyroscopicForce;
  public int m_solverMode;
  public rawarray{char, 4} m_padding;
  public float m_warmstartingFactor;
}
public threaded struct extern "::btContinuousConvexCollision" "nodefault" btContinuousConvexCollision(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_3)  {
  public metafunction __base__ {btConvexCast};
  public function extern "calcTimeOfImpact" bool calcTimeOfImpact(btTransform const& fromA_0, btTransform const& toA_1, btTransform const& fromB_2, btTransform const& toB_3, btConvexCast_CastResult mutable& result_4);
}
public threaded struct extern "::btConvex2dConvex2dAlgorithm" "nodefault" btConvex2dConvex2dAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, rptr{btVoronoiSimplexSolver} simplexSolver_4, rptr{btConvexPenetrationDepthSolver} pdSolver_5, int numPerturbationIterations_6, int minimumPointsPerturbationThreshold_7)  {
  public metafunction __base__ {btCollisionAlgorithm, btActivatingCollisionAlgorithm};
  public function extern "getManifold" crptr{btPersistentManifold} getManifold();
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "setLowLevelOfDetail" void setLowLevelOfDetail(bool useLowLevel_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btConvex2dConvex2dAlgorithm::CreateFunc" "nodefault" btConvex2dConvex2dAlgorithm_CreateFunc(rptr{btVoronoiSimplexSolver} simplexSolver_0, rptr{btConvexPenetrationDepthSolver} pdSolver_1)  {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public int m_numPerturbationIterations;
  public rptr{btConvexPenetrationDepthSolver} m_pdSolver;
  public int m_minimumPointsPerturbationThreshold;
  public bool m_swapped;
  public rptr{btVoronoiSimplexSolver} m_simplexSolver;
}
public threaded struct extern "::btConvex2dShape" "nodefault" btConvex2dShape(rptr{btConvexShape} convexChildShape_0)  {
  public metafunction __base__ {btCollisionShape, btConvexShape};
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getChildShape" rptr{btConvexShape} getChildShape();
  public function extern "getChildShape" crptr{btConvexShape} cgetChildShape() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
}
public threaded struct extern "::btConvexCast" "nonmovable" btConvexCast {
  public function extern "calcTimeOfImpact" bool calcTimeOfImpact(btTransform const& fromA_0, btTransform const& toA_1, btTransform const& fromB_2, btTransform const& toB_3, btConvexCast_CastResult mutable& result_4);
}
public threaded struct extern "::btConvexCast::CastResult" "nonmovable" btConvexCast_CastResult {
  public function extern "DebugDraw" void DebugDraw(btScalar fraction_0);
  public function extern "reportFailure" void reportFailure(int errNo_0, int numIterations_1);
  public function extern "drawCoordSystem" void drawCoordSystem(btTransform const& trans_0);
  public btScalar m_allowedPenetration;
  public btTransform m_hitTransformA;
  public btScalar m_fraction;
  public rptr{btIDebugDraw} m_debugDrawer;
  public btTransform m_hitTransformB;
  public btVector3 m_normal;
  public btVector3 m_hitPoint;
}
public threaded struct extern "::btConvexConcaveCollisionAlgorithm" "nodefault" btConvexConcaveCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btCollisionAlgorithm, btActivatingCollisionAlgorithm};
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "clearCache" void clearCache();
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
}
public threaded struct extern "::btConvexConcaveCollisionAlgorithm::CreateFunc" "nonmovable" btConvexConcaveCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btConvexConcaveCollisionAlgorithm::SwappedCreateFunc" "nonmovable" btConvexConcaveCollisionAlgorithm_SwappedCreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btConvexConvexAlgorithm" "nodefault" btConvexConvexAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, rptr{btVoronoiSimplexSolver} simplexSolver_4, rptr{btConvexPenetrationDepthSolver} pdSolver_5, int numPerturbationIterations_6, int minimumPointsPerturbationThreshold_7)  {
  public metafunction __base__ {btCollisionAlgorithm, btActivatingCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "setLowLevelOfDetail" void setLowLevelOfDetail(bool useLowLevel_0);
  public function extern "getManifold" crptr{btPersistentManifold} getManifold();
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btConvexConvexAlgorithm::CreateFunc" "nodefault" btConvexConvexAlgorithm_CreateFunc(rptr{btVoronoiSimplexSolver} simplexSolver_0, rptr{btConvexPenetrationDepthSolver} pdSolver_1)  {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public int m_numPerturbationIterations;
  public rptr{btVoronoiSimplexSolver} m_simplexSolver;
  public int m_minimumPointsPerturbationThreshold;
  public bool m_swapped;
  public rptr{btConvexPenetrationDepthSolver} m_pdSolver;
}
public threaded struct extern "::btConvexHullComputer" btConvexHullComputer {
  public function extern "compute" btScalar compute_float_cp_int_int_btScalar_btScalar(crptr{float} coords_0, int stride_1, int count_2, btScalar shrink_3, btScalar shrinkClamp_4);
  public function extern "compute" btScalar compute_double_cp_int_int_btScalar_btScalar(crptr{double} coords_0, int stride_1, int count_2, btScalar shrink_3, btScalar shrinkClamp_4);
  public btAlignedObjectArray_btVector3 vertices;
  public btAlignedObjectArray_int faces;
  public btAlignedObjectArray_btConvexHullComputer_Edge edges;
}
public threaded struct extern "::btConvexHullComputer::Edge" btConvexHullComputer_Edge {
  public function extern "getTargetVertex" int getTargetVertex() const;
  public function extern "getReverseEdge" crptr{btConvexHullComputer_Edge} getReverseEdge() const;
  public function extern "getSourceVertex" int getSourceVertex() const;
  public function extern "getNextEdgeOfVertex" crptr{btConvexHullComputer_Edge} getNextEdgeOfVertex() const;
  public function extern "getNextEdgeOfFace" crptr{btConvexHullComputer_Edge} getNextEdgeOfFace() const;
}
public threaded struct extern "::btConvexHullShape" "nodefault" btConvexHullShape(crptr{btScalar} points_0, int numPoints_1, int stride_2)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btPolyhedralConvexShape, btPolyhedralConvexAabbCachingShape, btCollisionShape};
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getScaledPoint" btVector3 getScaledPoint(int i_0) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project4(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "project" void project6(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& minProj_2, btScalar mutable& maxProj_3, btVector3 mutable& witnesPtMin_4, btVector3 mutable& witnesPtMax_5) const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getNumPoints" int getNumPoints() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "addPoint" void addPoint(btVector3 const& point_0, bool recalculateLocalAabb_1);
  public function extern "getPoints" crptr{btVector3} getPoints() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getUnscaledPoints" rptr{btVector3} getUnscaledPoints();
  public function extern "getUnscaledPoints" crptr{btVector3} cgetUnscaledPoints() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
}
public threaded struct extern "::btConvexHullShapeData" btConvexHullShapeData {
  public int m_numUnscaledPoints;
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rptr{btVector3FloatData} m_unscaledPointsFloatPtr;
  public rptr{btVector3DoubleData} m_unscaledPointsDoublePtr;
  public rawarray{char, 4} m_padding3;
}
public threaded struct extern "::btConvexInternalAabbCachingShape" "nodefault" btConvexInternalAabbCachingShape private {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
}
public threaded struct extern "::btConvexInternalShape" "nodefault" btConvexInternalShape private {
  public metafunction __base__ {btCollisionShape, btConvexShape};
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
}
public threaded struct extern "::btConvexInternalShapeData" btConvexInternalShapeData {
  public btVector3FloatData m_localScaling;
  public btCollisionShapeData m_collisionShapeData;
  public btVector3FloatData m_implicitShapeDimensions;
  public int m_padding;
  public float m_collisionMargin;
}
public threaded struct extern "::btConvexPenetrationDepthSolver" "nonmovable" btConvexPenetrationDepthSolver {
  public function extern "calcPenDepth" bool calcPenDepth(btVoronoiSimplexSolver mutable& simplexSolver_0, crptr{btConvexShape} convexA_1, crptr{btConvexShape} convexB_2, btTransform const& transA_3, btTransform const& transB_4, btVector3 mutable& v_5, btVector3 mutable& pa_6, btVector3 mutable& pb_7, rptr{btIDebugDraw} debugDraw_8);
}
public threaded struct extern "::btConvexPlaneCollisionAlgorithm" "nodefault" btConvexPlaneCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool isSwapped_4, int numPerturbationIterations_5, int minimumPointsPerturbationThreshold_6)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "collideSingleContact" void collideSingleContact(btQuaternion const& perturbeRot_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, btDispatcherInfo const& dispatchInfo_3, rptr{btManifoldResult} resultOut_4);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
}
public threaded struct extern "::btConvexPlaneCollisionAlgorithm::CreateFunc" "nonmovable" btConvexPlaneCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public int m_numPerturbationIterations;
  public bool m_swapped;
  public int m_minimumPointsPerturbationThreshold;
}
public threaded struct extern "::btConvexPointCloudShape" "nonmovable" btConvexPointCloudShape {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape, btPolyhedralConvexAabbCachingShape};
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getUnscaledPoints" rptr{btVector3} getUnscaledPoints();
  public function extern "getUnscaledPoints" crptr{btVector3} cgetUnscaledPoints() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "setPoints" void setPoints(rptr{btVector3} points_0, int numPoints_1, bool computeAabb_2, btVector3 const& localScaling_3);
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "getNumPoints" int getNumPoints() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getScaledPoint" btVector3 getScaledPoint(int index_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
}
public threaded struct extern "::btConvexPolyhedron" btConvexPolyhedron {
  public function extern "testContainment" bool testContainment() const;
  public function extern "initialize" void initialize();
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& minProj_2, btScalar mutable& maxProj_3, btVector3 mutable& witnesPtMin_4, btVector3 mutable& witnesPtMax_5) const;
  public btVector3 mC;
  public btVector3 mE;
  public btAlignedObjectArray_btFace m_faces;
  public btAlignedObjectArray_btVector3 m_uniqueEdges;
  public btAlignedObjectArray_btVector3 m_vertices;
  public btVector3 m_extents;
  public btVector3 m_localCenter;
  public btScalar m_radius;
}
public threaded struct extern "::btConvexSeparatingDistanceUtil" "nodefault" btConvexSeparatingDistanceUtil(btScalar boundingRadiusA_0, btScalar boundingRadiusB_1)  {
  public function extern "getConservativeSeparatingDistance" btScalar getConservativeSeparatingDistance();
  public function extern "initSeparatingDistance" void initSeparatingDistance(btVector3 const& separatingVector_0, btScalar separatingDistance_1, btTransform const& transA_2, btTransform const& transB_3);
  public function extern "updateSeparatingDistance" void updateSeparatingDistance(btTransform const& transA_0, btTransform const& transB_1);
}
public threaded struct extern "::btConvexShape" "nonmovable" btConvexShape {
  public metafunction __base__ {btCollisionShape};
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
}
public threaded struct extern "::btConvexTriangleCallback" "nodefault" btConvexTriangleCallback(rptr{btDispatcher} dispatcher_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btTriangleCallback};
  public function extern "clearWrapperData" void clearWrapperData();
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
  public function extern "getAabbMin" btVector3 const& getAabbMin() const;
  public function extern "setTimeStepAndCounters" void setTimeStepAndCounters(btScalar collisionMarginTriangle_0, btDispatcherInfo const& dispatchInfo_1, crptr{btCollisionObjectWrapper} convexBodyWrap_2, crptr{btCollisionObjectWrapper} triBodyWrap_3, rptr{btManifoldResult} resultOut_4);
  public function extern "clearCache" void clearCache();
  public function extern "getAabbMax" btVector3 const& getAabbMax() const;
  public rptr{btPersistentManifold} m_manifoldPtr;
  public int m_triangleCount;
}
public threaded struct extern "::btConvexTriangleMeshShape" "nodefault" btConvexTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface_0, bool calcAabb_1)  {
  public metafunction __base__ {btCollisionShape, btPolyhedralConvexAabbCachingShape, btPolyhedralConvexShape, btConvexShape, btConvexInternalShape};
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "calculatePrincipalAxisTransform" void calculatePrincipalAxisTransform(btTransform mutable& principal_0, btVector3 mutable& inertia_1, btScalar mutable& volume_2) const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
}
public threaded struct extern "::btCylinderShape" "nodefault" btCylinderShape(btVector3 const& halfExtents_0)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCollisionShape};
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
}
public threaded struct extern "::btCylinderShapeData" btCylinderShapeData {
  public rawarray{char, 4} m_padding;
  public btConvexInternalShapeData m_convexInternalShapeData;
  public int m_upAxis;
}
public threaded struct extern "::btCylinderShapeX" "nodefault" btCylinderShapeX(btVector3 const& halfExtents_0)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape, btCylinderShape};
  public function extern "isCompound" bool isCompound() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public threaded struct extern "::btCylinderShapeZ" "nodefault" btCylinderShapeZ(btVector3 const& halfExtents_0)  {
  public metafunction __base__ {btCylinderShape, btCollisionShape, btConvexInternalShape, btConvexShape};
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
}
public threaded struct extern "::btDbvt" "nonmovable" btDbvt {
  public function extern "rayTestInternal" void rayTestInternal(crptr{btDbvtNode} root_0, btVector3 const& rayFrom_1, btVector3 const& rayTo_2, btVector3 const& rayDirectionInverse_3, rptr{uint} signs_4, btScalar lambda_max_5, btVector3 const& aabbMin_6, btVector3 const& aabbMax_7, btDbvt_ICollide mutable& policy_8) const;
  public function extern "clear" void clear();
  public function extern "write" void write(rptr{btDbvt_IWriter} iwriter_0) const;
  public function extern "optimizeIncremental" void optimizeIncremental(int passes_0);
  public function extern "empty" bool empty() const;
  public function extern "collideTTpersistentStack" void collideTTpersistentStack(crptr{btDbvtNode} root0_0, crptr{btDbvtNode} root1_1, btDbvt_ICollide mutable& policy_2);
  public function extern "clone" void clone(btDbvt mutable& dest_0, rptr{btDbvt_IClone} iclone_1) const;
  public function extern "collideTT" void collideTT(crptr{btDbvtNode} root0_0, crptr{btDbvtNode} root1_1, btDbvt_ICollide mutable& policy_2);
  public function extern "optimizeTopDown" void optimizeTopDown(int bu_treshold_0);
  public function extern "remove" void remove(rptr{btDbvtNode} leaf_0);
  public function extern "update" bool update4(rptr{btDbvtNode} leaf_0, btDbvtVolume mutable& volume_1, btVector3 const& velocity_2, btScalar margin_3);
  public function extern "update" bool update_btDbvtNode_p_btDbvtVolume_btScalar(rptr{btDbvtNode} leaf_0, btDbvtVolume mutable& volume_1, btScalar margin_2);
  public function extern "update" bool update_btDbvtNode_p_btDbvtVolume_btVector3(rptr{btDbvtNode} leaf_0, btDbvtVolume mutable& volume_1, btVector3 const& velocity_2);
  public function extern "update" void update_btDbvtNode_p_int(rptr{btDbvtNode} leaf_0, int lookahead_1);
  public function extern "update" void update_btDbvtNode_p_btDbvtVolume(rptr{btDbvtNode} leaf_0, btDbvtVolume mutable& volume_1);
  public function extern "insert" rptr{btDbvtNode} insert(btDbvtVolume const& box_0, rptr{void} data_1);
  public function extern "collideTV" void collideTV(crptr{btDbvtNode} root_0, btDbvtVolume const& vol_1, btDbvt_ICollide mutable& policy_2) const;
  public function extern "optimizeBottomUp" void optimizeBottomUp();
  public btAlignedObjectArray_btDbvtNode_const_p m_rayTestStack;
  public btAlignedObjectArray_btDbvt_sStkNN m_stkStack;
  public int m_leaves;
  public rptr{btDbvtNode} m_root;
  public uint m_opath;
  public int m_lkhd;
  public rptr{btDbvtNode} m_free;
}
public threaded struct extern "::btDbvtAabbMm" btDbvtAabbMm {
  public function extern "Maxs" btVector3 const& Maxs() const;
  public function extern "SignedExpand" void SignedExpand(btVector3 const& e_0);
  public function extern "Classify" int Classify(btVector3 const& n_0, btScalar o_1, int s_2) const;
  public function extern "Mins" btVector3 const& Mins() const;
  public function extern "Contain" bool Contain(btDbvtAabbMm const& a_0) const;
  public function extern "Expand" void Expand(btVector3 const& e_0);
  public function extern "tMins" btVector3 mutable& tMins();
  public function extern "ProjectMinimum" btScalar ProjectMinimum(btVector3 const& v_0, uint signs_1) const;
  public function extern "tMaxs" btVector3 mutable& tMaxs();
  public function extern "Extents" btVector3 Extents() const;
  public function extern "Lengths" btVector3 Lengths() const;
  public function extern "Center" btVector3 Center() const;
}
public threaded struct extern "::btDbvtBroadphase" "nodefault" btDbvtBroadphase(rptr{btOverlappingPairCache} paircache_0)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "optimize" void optimize();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "performDeferredRemoval" void performDeferredRemoval(rptr{btDispatcher} dispatcher_0);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "setAabbForceUpdate" void setAabbForceUpdate(rptr{btBroadphaseProxy} absproxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} _3);
  public function extern "printStats" void printStats();
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "collide" void collide(rptr{btDispatcher} dispatcher_0);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "getVelocityPrediction" btScalar getVelocityPrediction() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "setVelocityPrediction" void setVelocityPrediction(btScalar prediction_0);
  public bool m_deferedcollide;
  public int m_stageCurrent;
  public btScalar m_updates_ratio;
  public int m_fixedleft;
  public uint m_updates_call;
  public int m_gid;
  public int m_fupdates;
  public rawarray{btDbvt, 2} m_sets;
  public int m_cid;
  public int m_pid;
  public int m_dupdates;
  public uint m_updates_done;
  public int m_cupdates;
  public rptr{btOverlappingPairCache} m_paircache;
  public btScalar m_prediction;
  public bool m_releasepaircache;
  public bool m_needcleanup;
  public int m_newpairs;
  public rawarray{rptr{btDbvtProxy}, 3} m_stageRoots;
}
public threaded struct extern "::btDbvtNode" btDbvtNode {
  public function extern "isleaf" bool isleaf() const;
  public function extern "isinternal" bool isinternal() const;
  public rptr{btDbvtNode} parent;
  public btDbvtVolume volume;
}
/* skip btDbvtNode_30 : unnamed */
public threaded struct extern "::btDbvtProxy" "nodefault" btDbvtProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} userPtr_2, short collisionFilterGroup_3, short collisionFilterMask_4)  {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "getUid" int getUid() const;
  public short m_collisionFilterMask;
  public rptr{btDbvtNode} leaf;
  public int stage;
  public rawarray{rptr{btDbvtProxy}, 2} links;
  public rptr{void} m_clientObject;
  public btVector3 m_aabbMax;
  public int m_uniqueId;
  public rptr{void} m_multiSapParentProxy;
  public short m_collisionFilterGroup;
  public btVector3 m_aabbMin;
}
public metafunction btDbvtProxyArray btAlignedObjectArray_btDbvtProxy_p;
public metafunction btDbvtVolume btDbvtAabbMm;
public threaded struct extern "::btDbvt::IClone" "nonmovable" btDbvt_IClone {
  public function extern "CloneLeaf" void CloneLeaf(rptr{btDbvtNode} _0);
}
public threaded struct extern "::btDbvt::ICollide" "nonmovable" btDbvt_ICollide {
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n_0, btScalar _1);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} _0, crptr{btDbvtNode} _1);
  public function extern "Process" void Process1(crptr{btDbvtNode} _0);
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
}
public threaded struct extern "::btDbvt::IWriter" "nonmovable" btDbvt_IWriter {
  public function extern "Prepare" void Prepare(crptr{btDbvtNode} root_0, int numnodes_1);
  public function extern "WriteNode" void WriteNode(crptr{btDbvtNode} _0, int index_1, int parent_2, int child0_3, int child1_4);
  public function extern "WriteLeaf" void WriteLeaf(crptr{btDbvtNode} _0, int index_1, int parent_2);
}
public threaded struct extern "::btDbvt::sStkCLN" "nodefault" btDbvt_sStkCLN(crptr{btDbvtNode} n_0, rptr{btDbvtNode} p_1)  {
  public crptr{btDbvtNode} node;
  public rptr{btDbvtNode} parent;
}
public threaded struct extern "::btDbvt::sStkNN" btDbvt_sStkNN {
  public crptr{btDbvtNode} b;
  public crptr{btDbvtNode} a;
}
public threaded struct extern "::btDbvt::sStkNP" "nodefault" btDbvt_sStkNP(crptr{btDbvtNode} n_0, uint m_1)  {
  public int mask;
  public crptr{btDbvtNode} node;
}
public threaded struct extern "::btDbvt::sStkNPS" btDbvt_sStkNPS {
  public btScalar value;
  public crptr{btDbvtNode} node;
  public int mask;
}
public threaded struct extern "::btDefaultCollisionConfiguration" "nodefault" btDefaultCollisionConfiguration(btDefaultCollisionConstructionInfo const& constructionInfo_0)  {
  public metafunction __base__ {btCollisionConfiguration};
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0_0, int proxyType1_1);
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
  public function extern "setPlaneConvexMultipointIterations" void setPlaneConvexMultipointIterations(int numPerturbationIterations_0, int minimumPointsPerturbationThreshold_1);
  public function extern "setConvexConvexMultipointIterations" void setConvexConvexMultipointIterations(int numPerturbationIterations_0, int minimumPointsPerturbationThreshold_1);
  public function extern "getSimplexSolver" rptr{btVoronoiSimplexSolver} getSimplexSolver();
}
public threaded struct extern "::btDefaultCollisionConstructionInfo" btDefaultCollisionConstructionInfo {
  public rptr{btPoolAllocator} m_persistentManifoldPool;
  public int m_defaultMaxPersistentManifoldPoolSize;
  public int m_useEpaPenetrationAlgorithm;
  public int m_customCollisionAlgorithmMaxElementSize;
  public int m_defaultMaxCollisionAlgorithmPoolSize;
  public rptr{btPoolAllocator} m_collisionAlgorithmPool;
}
public threaded struct extern "::btDefaultMotionState" "nodefault" btDefaultMotionState(btTransform const& startTrans_0, btTransform const& centerOfMassOffset_1)  {
  public metafunction __base__ {btMotionState};
  public function extern "getWorldTransform" void getWorldTransform(btTransform mutable& centerOfMassWorldTrans_0) const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& centerOfMassWorldTrans_0);
  public btTransform m_graphicsWorldTrans;
  public btTransform m_centerOfMassOffset;
  public btTransform m_startWorldTrans;
  public rptr{void} m_userPointer;
}
public threaded struct extern "::btDefaultSerializer" "nodefault" btDefaultSerializer(int totalSize_0)  {
  public metafunction __base__ {btSerializer};
  public function extern "finishSerialization" void finishSerialization();
  public function extern "serializeName" void serializeName(crptr{char} name_0);
  public function extern "findNameForPointer" crptr{char} findNameForPointer(crptr{void} ptr_0) const;
  public function extern "allocate" rptr{btChunk} allocate(size_t size_0, int numElements_1);
  public function extern "getSerializationFlags" int getSerializationFlags() const;
  public function extern "getUniquePointer" rptr{void} getUniquePointer(rptr{void} oldPtr_0);
  public function extern "writeHeader" void writeHeader(rptr{uchar} buffer_0) const;
  public function extern "setSerializationFlags" void setSerializationFlags(int flags_0);
  public function extern "findPointer" rptr{void} findPointer(rptr{void} oldPtr_0);
  public function extern "finalizeChunk" void finalizeChunk(rptr{btChunk} chunk_0, crptr{char} structType_1, int chunkCode_2, rptr{void} oldPtr_3);
  public function extern "getBufferPointer" crptr{uchar} getBufferPointer() const;
  public function extern "internalAlloc" rptr{uchar} internalAlloc(size_t size_0);
  public function extern "getCurrentBufferSize" int getCurrentBufferSize() const;
  public function extern "registerNameForPointer" void registerNameForPointer(crptr{void} ptr_0, crptr{char} name_1);
  public function extern "startSerialization" void startSerialization();
}
public threaded struct extern "::btDefaultSoftBodySolver" "nonmovable" btDefaultSoftBodySolver {
  public metafunction __base__ {btSoftBodySolver};
  public function extern "updateSoftBodies" void updateSoftBodies();
  public function extern "optimize" void optimize(btAlignedObjectArray_btSoftBody_p mutable& softBodies_0, bool forceUpdate_1);
  public function extern "setNumberOfPositionIterations" void setNumberOfPositionIterations(int iterations_0);
  public function extern "copyBackToSoftBodies" void copyBackToSoftBodies(bool bMove_0);
  public function extern "getNumberOfPositionIterations" int getNumberOfPositionIterations();
  public function extern "copySoftBodyToVertexBuffer" void copySoftBodyToVertexBuffer(crptr{btSoftBody} const softBody_0, rptr{btVertexBufferDescriptor} vertexBuffer_1);
  public function extern "getTimeScale" float getTimeScale();
  public function extern "checkInitialized" bool checkInitialized();
  public function extern "getNumberOfVelocityIterations" int getNumberOfVelocityIterations();
  public function extern "processCollision" void processCollision_btSoftBody_p_btCollisionObjectWrapper_cp(rptr{btSoftBody} _0, crptr{btCollisionObjectWrapper} _1);
  public function extern "processCollision" void processCollision_btSoftBody_p_btSoftBody_p(rptr{btSoftBody} _0, rptr{btSoftBody} _1);
  public function extern "solveConstraints" void solveConstraints(float solverdt_0);
  public function extern "predictMotion" void predictMotion(float solverdt_0);
  public function extern "setNumberOfVelocityIterations" void setNumberOfVelocityIterations(int iterations_0);
}
public threaded struct extern "::btDefaultVehicleRaycaster" "nodefault" btDefaultVehicleRaycaster(rptr{btDynamicsWorld} world_0)  {
  public metafunction __base__ {btVehicleRaycaster};
  public function extern "castRay" rptr{void} castRay(btVector3 const& from_0, btVector3 const& to_1, btVehicleRaycaster_btVehicleRaycasterResult mutable& result_2);
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface" "nonmovable" btDiscreteCollisionDetectorInterface {
  public function extern "getClosestPoints" void getClosestPoints(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input_0, btDiscreteCollisionDetectorInterface_Result mutable& output_1, rptr{btIDebugDraw} debugDraw_2, bool swapResults_3);
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface::ClosestPointInput" btDiscreteCollisionDetectorInterface_ClosestPointInput {
  public btScalar m_maximumDistanceSquared;
  public btTransform m_transformA;
  public btTransform m_transformB;
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface::Result" "nonmovable" btDiscreteCollisionDetectorInterface_Result {
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0_0, int index0_1);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1_0, int index1_1);
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld_0, btVector3 const& pointInWorld_1, btScalar depth_2);
}
public threaded struct extern "::btDiscreteDynamicsWorld" "nodefault" btDiscreteDynamicsWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3)  {
  public metafunction __base__ {btDynamicsWorld, btCollisionWorld};
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "clearForces" void clearForces();
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character_0);
  public function extern "getApplySpeculativeContactRestitution" bool getApplySpeculativeContactRestitution() const;
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index_0) const;
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index_0);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver_0);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "setLatencyMotionStateInterpolation" void setLatencyMotionStateInterpolation(bool latencyInterpolation_0);
  public function extern "getSimulationIslandManager" crptr{btSimulationIslandManager} cgetSimulationIslandManager() const;
  public function extern "getSimulationIslandManager" rptr{btSimulationIslandManager} getSimulationIslandManager();
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body_0);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character_0);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep_0, int maxSubSteps_1, btScalar fixedTimeStep_2);
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb_0, rptr{void} worldUserInfo_1, bool isPreTick_2);
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "synchronizeSingleMotionState" void synchronizeSingleMotionState(rptr{btRigidBody} body_0);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint_0, bool disableCollisionsBetweenLinkedBodies_1);
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "addAction" void addAction(rptr{btActionInterface} _0);
  public function extern "getLatencyMotionStateInterpolation" bool getLatencyMotionStateInterpolation() const;
  public function extern "setApplySpeculativeContactRestitution" void setApplySpeculativeContactRestitution(bool enable_0);
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "getCollisionWorld" rptr{btCollisionWorld} getCollisionWorld();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "updateAabbs" void updateAabbs();
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "setNumTasks" void setNumTasks(int numTasks_0);
  public function extern "debugDrawConstraint" void debugDrawConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "updateVehicles" void updateVehicles(btScalar timeStep_0);
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "setSynchronizeAllMotionStates" void setSynchronizeAllMotionStates(bool synchronizeAll_0);
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body_0, short group_1, short mask_2);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body_0);
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo_0);
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "setGravity" void setGravity(btVector3 const& gravity_0);
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "getSynchronizeAllMotionStates" bool getSynchronizeAllMotionStates() const;
  public function extern "applyGravity" void applyGravity();
  public function extern "removeAction" void removeAction(rptr{btActionInterface} _0);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle_0);
}
public threaded struct extern "::btDispatcher" "nonmovable" btDispatcher {
  public function extern "needsCollision" bool needsCollision(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
  public function extern "dispatchAllCollisionPairs" void dispatchAllCollisionPairs(rptr{btOverlappingPairCache} pairCache_0, btDispatcherInfo const& dispatchInfo_1, rptr{btDispatcher} dispatcher_2);
  public function extern "findAlgorithm" rptr{btCollisionAlgorithm} findAlgorithm(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, rptr{btPersistentManifold} sharedManifold_2);
  public function extern "getNewManifold" rptr{btPersistentManifold} getNewManifold(crptr{btCollisionObject} b0_0, crptr{btCollisionObject} b1_1);
  public function extern "releaseManifold" void releaseManifold(rptr{btPersistentManifold} manifold_0);
  public function extern "getInternalManifoldPool" crptr{btPoolAllocator} cgetInternalManifoldPool() const;
  public function extern "getInternalManifoldPool" rptr{btPoolAllocator} getInternalManifoldPool();
  public function extern "allocateCollisionAlgorithm" rptr{void} allocateCollisionAlgorithm(int size_0);
  public function extern "clearManifold" void clearManifold(rptr{btPersistentManifold} manifold_0);
  public function extern "freeCollisionAlgorithm" void freeCollisionAlgorithm(rptr{void} ptr_0);
  public function extern "getInternalManifoldPointer" rptr{rptr{btPersistentManifold}} getInternalManifoldPointer();
  public function extern "getNumManifolds" int getNumManifolds() const;
  public function extern "getManifoldByIndexInternal" rptr{btPersistentManifold} getManifoldByIndexInternal(int index_0);
  public function extern "needsResponse" bool needsResponse(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
}
public threaded struct extern "::btDispatcherInfo" btDispatcherInfo {
  public bool m_useContinuous;
  public btScalar m_convexConservativeDistanceThreshold;
  public bool m_useEpa;
  public int m_dispatchFunc;
  public bool m_enableSPU;
  public btScalar m_timeOfImpact;
  public btScalar m_timeStep;
  public bool m_enableSatConvex;
  public int m_stepCount;
  public bool m_useConvexConservativeDistanceUtil;
  public btScalar m_allowedCcdPenetration;
  public rptr{btIDebugDraw} m_debugDraw;
}
public threaded struct extern "::btDynamicsWorld" "nodefault" btDynamicsWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} broadphase_1, rptr{btCollisionConfiguration} collisionConfiguration_2)  {
  public metafunction __base__ {btCollisionWorld};
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "updateAabbs" void updateAabbs();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action_0);
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "setGravity" void setGravity(btVector3 const& gravity_0);
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo_0);
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body_0, short group_1, short mask_2);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body_0);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver_0);
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index_0) const;
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index_0);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character_0);
  public function extern "clearForces" void clearForces();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "addAction" void addAction(rptr{btActionInterface} action_0);
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint_0, bool disableCollisionsBetweenLinkedBodies_1);
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep_0, int maxSubSteps_1, btScalar fixedTimeStep_2);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb_0, rptr{void} worldUserInfo_1, bool isPreTick_2);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character_0);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body_0);
}
public threaded struct extern "::btDynamicsWorldDoubleData" btDynamicsWorldDoubleData {
  public btContactSolverInfoDoubleData m_solverInfo;
  public btVector3DoubleData m_gravity;
}
public threaded struct extern "::btDynamicsWorldFloatData" btDynamicsWorldFloatData {
  public btVector3FloatData m_gravity;
  public btContactSolverInfoFloatData m_solverInfo;
}
public tsvaluetype struct extern "::btDynamicsWorldType" "extenum" btDynamicsWorldType { }
public extern "BT_SIMPLE_DYNAMICS_WORLD" btDynamicsWorldType BT_SIMPLE_DYNAMICS_WORLD;
public extern "BT_DISCRETE_DYNAMICS_WORLD" btDynamicsWorldType BT_DISCRETE_DYNAMICS_WORLD;
public extern "BT_CONTINUOUS_DYNAMICS_WORLD" btDynamicsWorldType BT_CONTINUOUS_DYNAMICS_WORLD;
public extern "BT_SOFT_RIGID_DYNAMICS_WORLD" btDynamicsWorldType BT_SOFT_RIGID_DYNAMICS_WORLD;
public extern "BT_GPU_DYNAMICS_WORLD" btDynamicsWorldType BT_GPU_DYNAMICS_WORLD;
public threaded struct extern "::btEigen" btEigen {
}
public threaded struct extern "::btElement" btElement {
  public int m_sz;
  public int m_id;
}
public threaded struct extern "::btEmptyAlgorithm" "nodefault" btEmptyAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btEmptyAlgorithm::CreateFunc" "nonmovable" btEmptyAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btEmptyShape" "nonmovable" btEmptyShape {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} _0, btVector3 const& _1, btVector3 const& _2) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
}
public threaded struct extern "::btFace" btFace {
  public rawarray{btScalar, 4} m_plane;
  public btAlignedObjectArray_int m_indices;
}
public threaded struct extern "::btFixedConstraint" "nodefault" btFixedConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "getUid" int getUid() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "buildJacobian" void buildJacobian();
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public int m_objectType;
}
public metafunction btFreeFunc meta::list{void, rptr{void}};
public threaded struct extern "::btGEN_Link" btGEN_Link {
  public function extern "isTail" bool isTail() const;
  public function extern "getNext" rptr{btGEN_Link} getNext() const;
  public function extern "insertBefore" void insertBefore(rptr{btGEN_Link} link_0);
  public function extern "isHead" bool isHead() const;
  public function extern "remove" void remove();
  public function extern "getPrev" rptr{btGEN_Link} getPrev() const;
  public function extern "insertAfter" void insertAfter(rptr{btGEN_Link} link_0);
}
public threaded struct extern "::btGEN_List" btGEN_List {
  public function extern "addTail" void addTail(rptr{btGEN_Link} link_0);
  public function extern "getHead" rptr{btGEN_Link} getHead() const;
  public function extern "getTail" rptr{btGEN_Link} getTail() const;
  public function extern "addHead" void addHead(rptr{btGEN_Link} link_0);
}
public metafunction btGImpactBoxSet btGImpactQuantizedBvh;
public threaded struct extern "::btGImpactBvh" btGImpactBvh {
  public function extern "setNodeBound" void setNodeBound(int nodeindex_0, btAABB const& bound_1);
  public function extern "getNodeTriangle" void getNodeTriangle(int nodeindex_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "getNodeBound" void getNodeBound(int nodeindex_0, btAABB mutable& bound_1) const;
  public function extern "rayQuery" bool rayQuery(btVector3 const& ray_dir_0, btVector3 const& ray_origin_1, btAlignedObjectArray_int mutable& collided_results_2) const;
  public function extern "getNodeCount" int getNodeCount() const;
  public function extern "getLeftNode" int getLeftNode(int nodeindex_0) const;
  public function extern "getNodeData" int getNodeData(int nodeindex_0) const;
  public function extern "hasHierarchy" bool hasHierarchy() const;
  public function extern "getEscapeNodeIndex" int getEscapeNodeIndex(int nodeindex_0) const;
  public function extern "buildSet" void buildSet();
  public function extern "isLeafNode" bool isLeafNode(int nodeindex_0) const;
  public function extern "getGlobalBox" btAABB getGlobalBox() const;
  public function extern "getRightNode" int getRightNode(int nodeindex_0) const;
  public function extern "isTrimesh" bool isTrimesh() const;
  public function extern "update" void update();
  public function extern "boxQuery" bool boxQuery(btAABB const& box_0, btAlignedObjectArray_int mutable& collided_results_1) const;
  public function extern "boxQueryTrans" bool boxQueryTrans(btAABB const& box_0, btTransform const& transform_1, btAlignedObjectArray_int mutable& collided_results_2) const;
  public function extern "getPrimitiveManager" rptr{btPrimitiveManagerBase} getPrimitiveManager() const;
  public function extern "setPrimitiveManager" void setPrimitiveManager(rptr{btPrimitiveManagerBase} primitive_manager_0);
}
public threaded struct extern "::btGImpactCompoundShape" "nodefault" btGImpactCompoundShape(bool children_has_transform_0)  {
  public metafunction __base__ {btGImpactShapeInterface, btConcaveShape, btCollisionShape};
  public function extern "needsRetrieveTetrahedrons" bool needsRetrieveTetrahedrons() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "postUpdate" void postUpdate();
  public function extern "getCompoundPrimitiveManager" rptr{btGImpactCompoundShape_CompoundPrimitiveManager} getCompoundPrimitiveManager();
  public function extern "getBulletTriangle" void getBulletTriangle(int prim_index_0, btTriangleShapeEx mutable& triangle_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "hasBoxSet" bool hasBoxSet() const;
  public function extern "processAllTrianglesRay" void processAllTrianglesRay(rptr{btTriangleCallback} _0, btVector3 const& _1, btVector3 const& _2) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "childrenHasTransform" bool childrenHasTransform() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getLocalBox" btAABB const& getLocalBox();
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "needsRetrieveTriangles" bool needsRetrieveTriangles() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "unlockChildShapes" void unlockChildShapes() const;
  public function extern "getPrimitiveTriangle" void getPrimitiveTriangle(int index_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "lockChildShapes" void lockChildShapes() const;
  public function extern "getNumChildShapes" int getNumChildShapes() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getBulletTetrahedron" void getBulletTetrahedron(int prim_index_0, btTetrahedronShapeEx mutable& tetrahedron_1) const;
  public function extern "getChildTransform" btTransform getChildTransform(int index_0) const;
  public function extern "getPrimitiveManager" crptr{btPrimitiveManagerBase} getPrimitiveManager() const;
  public function extern "getChildShape" crptr{btCollisionShape} cgetChildShape(int index_0) const;
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "setChildTransform" void setChildTransform(int index_0, btTransform const& transform_1);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "addChildShape" void addChildShape2(btTransform const& localTransform_0, rptr{btCollisionShape} shape_1);
  public function extern "addChildShape" void addChildShape1(rptr{btCollisionShape} shape_0);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getChildAabb" void getChildAabb(int child_index_0, btTransform const& t_1, btVector3 mutable& aabbMin_2, btVector3 mutable& aabbMax_3) const;
  public function extern "getBoxSet" crptr{btGImpactBoxSet} getBoxSet() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "updateBound" void updateBound();
}
public threaded struct extern "::btGImpactCompoundShape::CompoundPrimitiveManager" "nonmovable" btGImpactCompoundShape_CompoundPrimitiveManager {
  public metafunction __base__ {btPrimitiveManagerBase};
  public function extern "get_primitive_triangle" void get_primitive_triangle(int prim_index_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "is_trimesh" bool is_trimesh() const;
  public function extern "get_primitive_box" void get_primitive_box(int prim_index_0, btAABB mutable& primbox_1) const;
  public function extern "get_primitive_count" int get_primitive_count() const;
  public rptr{btGImpactCompoundShape} m_compoundShape;
}
public threaded struct extern "::btGImpactConvexDecompositionShape" "nodefault" btGImpactConvexDecompositionShape(rptr{btStridingMeshInterface} meshInterface_0, btVector3 const& mesh_scale_1, btScalar margin_2, bool children_has_transform_3)  {
  public metafunction __base__ {btGImpactCompoundShape, btGImpactShapeInterface, btConcaveShape, btCollisionShape};
  public function extern "processAllTrianglesRay" void processAllTrianglesRay(rptr{btTriangleCallback} _0, btVector3 const& _1, btVector3 const& _2) const;
  public function extern "hasBoxSet" bool hasBoxSet() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "childrenHasTransform" bool childrenHasTransform() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getTrimeshInterface" rptr{btGImpactMeshShapePart_TrimeshPrimitiveManager} getTrimeshInterface(int part_0);
  public function extern "needsRetrieveTetrahedrons" bool needsRetrieveTetrahedrons() const;
  public function extern "postUpdate" void postUpdate();
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getCompoundPrimitiveManager" rptr{btGImpactCompoundShape_CompoundPrimitiveManager} getCompoundPrimitiveManager();
  public function extern "getBulletTriangle" void getBulletTriangle(int prim_index_0, btTriangleShapeEx mutable& triangle_1) const;
  public function extern "needsRetrieveTriangles" bool needsRetrieveTriangles() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "unlockChildShapes" void unlockChildShapes() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getLocalBox" btAABB const& getLocalBox();
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getChildTransform" btTransform getChildTransform(int index_0) const;
  public function extern "getBulletTetrahedron" void getBulletTetrahedron(int prim_index_0, btTetrahedronShapeEx mutable& tetrahedron_1) const;
  public function extern "getPrimitiveTriangle" void getPrimitiveTriangle(int index_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "lockChildShapes" void lockChildShapes() const;
  public function extern "getNumChildShapes" int getNumChildShapes() const;
  public function extern "addChildShape" void addChildShape1(rptr{btCollisionShape} shape_0);
  public function extern "addChildShape" void addChildShape2(btTransform const& localTransform_0, rptr{btCollisionShape} shape_1);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getChildAabb" void getChildAabb(int child_index_0, btTransform const& t_1, btVector3 mutable& aabbMin_2, btVector3 mutable& aabbMax_3) const;
  public function extern "getBoxSet" crptr{btGImpactBoxSet} getBoxSet() const;
  public function extern "updateBound" void updateBound();
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index_0);
  public function extern "getChildShape" crptr{btCollisionShape} cgetChildShape(int index_0) const;
  public function extern "getPrimitiveManager" crptr{btPrimitiveManagerBase} getPrimitiveManager() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setChildTransform" void setChildTransform(int index_0, btTransform const& transform_1);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
}
public threaded struct extern "::btGImpactMeshShape" "nodefault" btGImpactMeshShape(rptr{btStridingMeshInterface} meshInterface_0)  {
  public metafunction __base__ {btGImpactShapeInterface, btConcaveShape, btCollisionShape};
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index_0);
  public function extern "getChildShape" crptr{btCollisionShape} cgetChildShape(int index_0) const;
  public function extern "getPrimitiveManager" crptr{btPrimitiveManagerBase} getPrimitiveManager() const;
  public function extern "setChildTransform" void setChildTransform(int index_0, btTransform const& transform_1);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getBoxSet" crptr{btGImpactBoxSet} getBoxSet() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "updateBound" void updateBound();
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getChildAabb" void getChildAabb(int child_index_0, btTransform const& t_1, btVector3 mutable& aabbMin_2, btVector3 mutable& aabbMax_3) const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "lockChildShapes" void lockChildShapes() const;
  public function extern "getNumChildShapes" int getNumChildShapes() const;
  public function extern "getPrimitiveTriangle" void getPrimitiveTriangle(int index_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMeshPart" crptr{btGImpactMeshShapePart} cgetMeshPart(int index_0) const;
  public function extern "getMeshPart" rptr{btGImpactMeshShapePart} getMeshPart(int index_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getBulletTetrahedron" void getBulletTetrahedron(int prim_index_0, btTetrahedronShapeEx mutable& tetrahedron_1) const;
  public function extern "getChildTransform" btTransform getChildTransform(int index_0) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getMeshPartCount" int getMeshPartCount() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getLocalBox" btAABB const& getLocalBox();
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "unlockChildShapes" void unlockChildShapes() const;
  public function extern "needsRetrieveTriangles" bool needsRetrieveTriangles() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getBulletTriangle" void getBulletTriangle(int prim_index_0, btTriangleShapeEx mutable& triangle_1) const;
  public function extern "needsRetrieveTetrahedrons" bool needsRetrieveTetrahedrons() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "postUpdate" void postUpdate();
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "childrenHasTransform" bool childrenHasTransform() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "processAllTrianglesRay" void processAllTrianglesRay(rptr{btTriangleCallback} callback_0, btVector3 const& rayFrom_1, btVector3 const& rayTo_2) const;
  public function extern "hasBoxSet" bool hasBoxSet() const;
  public function extern "isConvex" bool isConvex() const;
}
public threaded struct extern "::btGImpactMeshShapeData" btGImpactMeshShapeData {
  public btVector3FloatData m_localScaling;
  public btCollisionShapeData m_collisionShapeData;
  public float m_collisionMargin;
  public btStridingMeshInterfaceData m_meshInterface;
  public int m_gimpactSubType;
}
public threaded struct extern "::btGImpactMeshShapePart" "nonmovable" btGImpactMeshShapePart {
  public metafunction __base__ {btCollisionShape, btConcaveShape, btGImpactShapeInterface};
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getLocalBox" btAABB const& getLocalBox();
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "unlockChildShapes" void unlockChildShapes() const;
  public function extern "needsRetrieveTriangles" bool needsRetrieveTriangles() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getBulletTriangle" void getBulletTriangle(int prim_index_0, btTriangleShapeEx mutable& triangle_1) const;
  public function extern "getTrimeshPrimitiveManager" rptr{btGImpactMeshShapePart_TrimeshPrimitiveManager} getTrimeshPrimitiveManager();
  public function extern "needsRetrieveTetrahedrons" bool needsRetrieveTetrahedrons() const;
  public function extern "postUpdate" void postUpdate();
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "childrenHasTransform" bool childrenHasTransform() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "hasBoxSet" bool hasBoxSet() const;
  public function extern "processAllTrianglesRay" void processAllTrianglesRay(rptr{btTriangleCallback} callback_0, btVector3 const& rayFrom_1, btVector3 const& rayTo_2) const;
  public function extern "getPart" int getPart() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index_0);
  public function extern "getChildShape" crptr{btCollisionShape} cgetChildShape(int index_0) const;
  public function extern "getPrimitiveManager" crptr{btPrimitiveManagerBase} getPrimitiveManager() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setChildTransform" void setChildTransform(int index_0, btTransform const& transform_1);
  public function extern "getVertexCount" int getVertexCount() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int vertex_index_0, btVector3 mutable& vertex_1) const;
  public function extern "getBoxSet" crptr{btGImpactBoxSet} getBoxSet() const;
  public function extern "updateBound" void updateBound();
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getChildAabb" void getChildAabb(int child_index_0, btTransform const& t_1, btVector3 mutable& aabbMin_2, btVector3 mutable& aabbMax_3) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "lockChildShapes" void lockChildShapes() const;
  public function extern "getNumChildShapes" int getNumChildShapes() const;
  public function extern "getPrimitiveTriangle" void getPrimitiveTriangle(int index_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getChildTransform" btTransform getChildTransform(int index_0) const;
  public function extern "getBulletTetrahedron" void getBulletTetrahedron(int prim_index_0, btTetrahedronShapeEx mutable& tetrahedron_1) const;
}
public threaded struct extern "::btGImpactMeshShapePart::TrimeshPrimitiveManager" "nonmovable" btGImpactMeshShapePart_TrimeshPrimitiveManager {
  public metafunction __base__ {btPrimitiveManagerBase};
  public function extern "get_primitive_count" int get_primitive_count() const;
  public function extern "get_primitive_box" void get_primitive_box(int prim_index_0, btAABB mutable& primbox_1) const;
  public function extern "get_bullet_triangle" void get_bullet_triangle(int prim_index_0, btTriangleShapeEx mutable& triangle_1) const;
  public function extern "get_vertex_count" int get_vertex_count() const;
  public function extern "get_primitive_triangle" void get_primitive_triangle(int prim_index_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "unlock" void unlock();
  public function extern "lock" void lock();
  public function extern "get_indices" void get_indices(int face_index_0, uint mutable& i0_1, uint mutable& i1_2, uint mutable& i2_3) const;
  public function extern "get_vertex" void get_vertex(uint vertex_index_0, btVector3 mutable& vertex_1) const;
  public function extern "is_trimesh" bool is_trimesh() const;
  public rptr{btStridingMeshInterface} m_meshInterface;
  public int m_part;
  public int numverts;
  public btVector3 m_scale;
  public btScalar m_margin;
  public int indexstride;
  public PHY_ScalarType type;
  public int stride;
  public PHY_ScalarType indicestype;
  public int m_lock_count;
  public int numfaces;
  public crptr{uchar} vertexbase;
  public crptr{uchar} indexbase;
}
public threaded struct extern "::btGImpactQuantizedBvh" btGImpactQuantizedBvh {
  public function extern "getPrimitiveManager" rptr{btPrimitiveManagerBase} getPrimitiveManager() const;
  public function extern "boxQuery" bool boxQuery(btAABB const& box_0, btAlignedObjectArray_int mutable& collided_results_1) const;
  public function extern "boxQueryTrans" bool boxQueryTrans(btAABB const& box_0, btTransform const& transform_1, btAlignedObjectArray_int mutable& collided_results_2) const;
  public function extern "setPrimitiveManager" void setPrimitiveManager(rptr{btPrimitiveManagerBase} primitive_manager_0);
  public function extern "getGlobalBox" btAABB getGlobalBox() const;
  public function extern "isLeafNode" bool isLeafNode(int nodeindex_0) const;
  public function extern "isTrimesh" bool isTrimesh() const;
  public function extern "update" void update();
  public function extern "getRightNode" int getRightNode(int nodeindex_0) const;
  public function extern "buildSet" void buildSet();
  public function extern "getEscapeNodeIndex" int getEscapeNodeIndex(int nodeindex_0) const;
  public function extern "hasHierarchy" bool hasHierarchy() const;
  public function extern "getNodeData" int getNodeData(int nodeindex_0) const;
  public function extern "getLeftNode" int getLeftNode(int nodeindex_0) const;
  public function extern "getNodeBound" void getNodeBound(int nodeindex_0, btAABB mutable& bound_1) const;
  public function extern "getNodeTriangle" void getNodeTriangle(int nodeindex_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "rayQuery" bool rayQuery(btVector3 const& ray_dir_0, btVector3 const& ray_origin_1, btAlignedObjectArray_int mutable& collided_results_2) const;
  public function extern "getNodeCount" int getNodeCount() const;
  public function extern "setNodeBound" void setNodeBound(int nodeindex_0, btAABB const& bound_1);
}
public threaded struct extern "::btGImpactShapeInterface" "nonmovable" btGImpactShapeInterface {
  public metafunction __base__ {btCollisionShape, btConcaveShape};
  public function extern "getBulletTriangle" void getBulletTriangle(int prim_index_0, btTriangleShapeEx mutable& triangle_1) const;
  public function extern "needsRetrieveTetrahedrons" bool needsRetrieveTetrahedrons() const;
  public function extern "postUpdate" void postUpdate();
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "childrenHasTransform" bool childrenHasTransform() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "processAllTrianglesRay" void processAllTrianglesRay(rptr{btTriangleCallback} _0, btVector3 const& _1, btVector3 const& _2) const;
  public function extern "hasBoxSet" bool hasBoxSet() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getLocalBox" btAABB const& getLocalBox();
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "unlockChildShapes" void unlockChildShapes() const;
  public function extern "needsRetrieveTriangles" bool needsRetrieveTriangles() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "lockChildShapes" void lockChildShapes() const;
  public function extern "getNumChildShapes" int getNumChildShapes() const;
  public function extern "getPrimitiveTriangle" void getPrimitiveTriangle(int index_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getChildTransform" btTransform getChildTransform(int index_0) const;
  public function extern "getBulletTetrahedron" void getBulletTetrahedron(int prim_index_0, btTetrahedronShapeEx mutable& tetrahedron_1) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index_0);
  public function extern "getChildShape" crptr{btCollisionShape} cgetChildShape(int index_0) const;
  public function extern "getPrimitiveManager" crptr{btPrimitiveManagerBase} getPrimitiveManager() const;
  public function extern "setChildTransform" void setChildTransform(int index_0, btTransform const& transform_1);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getBoxSet" crptr{btGImpactBoxSet} getBoxSet() const;
  public function extern "updateBound" void updateBound();
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getChildAabb" void getChildAabb(int child_index_0, btTransform const& t_1, btVector3 mutable& aabbMin_2, btVector3 mutable& aabbMax_3) const;
}
public threaded struct extern "::btGearConstraint" "nodefault" btGearConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& axisInA_2, btVector3 const& axisInB_3, btScalar ratio_4)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint};
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getAxisA" btVector3 const& getAxisA() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "setAxisB" void setAxisB(btVector3 mutable& axisB_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setRatio" void setRatio(btScalar ratio_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRatio" btScalar getRatio() const;
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "setAxisA" void setAxisA(btVector3 mutable& axisA_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getAxisB" btVector3 const& getAxisB() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "getUid" int getUid() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public int m_objectType;
}
public threaded struct extern "::btGearConstraintDoubleData" btGearConstraintDoubleData {
  public btVector3DoubleData m_axisInA;
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btVector3DoubleData m_axisInB;
  public double m_ratio;
}
public threaded struct extern "::btGearConstraintFloatData" btGearConstraintFloatData {
  public rawarray{char, 4} m_padding;
  public float m_ratio;
  public btVector3FloatData m_axisInB;
  public btVector3FloatData m_axisInA;
  public btTypedConstraintFloatData m_typeConstraintData;
}
public threaded struct extern "::btGeneric6DofConstraint" "nodefault" btGeneric6DofConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index_0);
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6, rptr{btTypedConstraint_btConstraintInfo2} info_7, int row_8, btVector3 mutable& ax1_9, int rotational_10, int rotAllowed_11);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "getAxis" btVector3 getAxis(int axis_index_0) const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "getAngle" btScalar getAngle(int axis_index_0) const;
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "getUid" int getUid() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "setAxis" void setAxis(btVector3 const& axis1_0, btVector3 const& axis2_1);
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper_0);
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index_0);
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower_0);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower_0);
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper_0);
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index_0) const;
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setLimit" void setLimit(int axis_0, btScalar lo_1, btScalar hi_2);
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper_0);
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6);
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower_0);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public int m_objectType;
  public bool m_useSolveConstraintObsolete;
}
public threaded struct extern "::btGeneric6DofConstraintData" btGeneric6DofConstraintData {
  public int m_useOffsetForConstraintFrame;
  public btVector3FloatData m_linearUpperLimit;
  public int m_useLinearReferenceFrameA;
  public btVector3FloatData m_angularUpperLimit;
  public btTransformFloatData m_rbAFrame;
  public btVector3FloatData m_angularLowerLimit;
  public btTypedConstraintData m_typeConstraintData;
  public btVector3FloatData m_linearLowerLimit;
  public btTransformFloatData m_rbBFrame;
}
public threaded struct extern "::btGeneric6DofConstraintDoubleData2" btGeneric6DofConstraintDoubleData2 {
  public int m_useOffsetForConstraintFrame;
  public btVector3DoubleData m_linearUpperLimit;
  public int m_useLinearReferenceFrameA;
  public btVector3DoubleData m_angularUpperLimit;
  public btTransformDoubleData m_rbAFrame;
  public btVector3DoubleData m_angularLowerLimit;
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btVector3DoubleData m_linearLowerLimit;
  public btTransformDoubleData m_rbBFrame;
}
public threaded struct extern "::btGeneric6DofSpringConstraint" "nodefault" btGeneric6DofSpringConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4)  {
  public metafunction __base__ {btTypedObject, btGeneric6DofConstraint, btTypedConstraint};
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower_0);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower_0);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint2(int index_0, btScalar val_1);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint1(int index_0);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint0();
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6);
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setLimit" void setLimit(int axis_0, btScalar lo_1, btScalar hi_2);
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index_0) const;
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper_0);
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "setAxis" void setAxis(btVector3 const& axis1_0, btVector3 const& axis2_1);
  public function extern "getAngle" btScalar getAngle(int axis_index_0) const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "getUid" int getUid() const;
  public function extern "getAxis" btVector3 getAxis(int axis_index_0) const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6, rptr{btTypedConstraint_btConstraintInfo2} info_7, int row_8, btVector3 mutable& ax1_9, int rotational_10, int rotAllowed_11);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "setStiffness" void setStiffness(int index_0, btScalar stiffness_1);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "enableSpring" void enableSpring(int index_0, bool onOff_1);
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower_0);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index_0);
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "setDamping" void setDamping(int index_0, btScalar damping_1);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper_0);
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public int m_objectType;
  public bool m_useSolveConstraintObsolete;
}
public threaded struct extern "::btGeneric6DofSpringConstraintData" btGeneric6DofSpringConstraintData {
  public rawarray{int, 6} m_springEnabled;
  public rawarray{float, 6} m_equilibriumPoint;
  public btGeneric6DofConstraintData m_6dofData;
  public rawarray{float, 6} m_springDamping;
  public rawarray{float, 6} m_springStiffness;
}
public threaded struct extern "::btGeneric6DofSpringConstraintDoubleData2" btGeneric6DofSpringConstraintDoubleData2 {
  public rawarray{double, 6} m_springDamping;
  public rawarray{double, 6} m_springStiffness;
  public btGeneric6DofConstraintDoubleData2 m_6dofData;
  public rawarray{int, 6} m_springEnabled;
  public rawarray{double, 6} m_equilibriumPoint;
}
public threaded struct extern "::btGeometryUtil" btGeometryUtil {
}
public threaded struct extern "::btGhostObject" "nonmovable" btGhostObject {
  public metafunction __base__ {btCollisionObject};
  public function extern "getActivationState" int getActivationState() const;
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "isActive" bool isActive() const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "getOverlappingPairs" btAlignedObjectArray_btCollisionObject_p const cgetOverlappingPairs() const;
  public function extern "getOverlappingPairs" btAlignedObjectArray_btCollisionObject_p mutable& getOverlappingPairs();
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& convexFromWorld_1, btTransform const& convexToWorld_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "getOverlappingObject" rptr{btCollisionObject} getOverlappingObject(int index_0);
  public function extern "getOverlappingObject" crptr{btCollisionObject} cgetOverlappingObject(int index_0) const;
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "getInternalType" int getInternalType() const;
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "addOverlappingObjectInternal" void addOverlappingObjectInternal(rptr{btBroadphaseProxy} otherProxy_0, rptr{btBroadphaseProxy} thisProxy_1);
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "removeOverlappingObjectInternal" void removeOverlappingObjectInternal(rptr{btBroadphaseProxy} otherProxy_0, rptr{btDispatcher} dispatcher_1, rptr{btBroadphaseProxy} thisProxy_2);
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "getNumOverlappingObjects" int getNumOverlappingObjects() const;
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "activate" void activate(bool forceActivation_0) const;
}
public threaded struct extern "::btGhostPairCallback" "nonmovable" btGhostPairCallback {
  public metafunction __base__ {btOverlappingPairCallback};
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} _0, rptr{btDispatcher} _1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
}
public threaded struct extern "::btGjkConvexCast" "nodefault" btGjkConvexCast(crptr{btConvexShape} convexA_0, crptr{btConvexShape} convexB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2)  {
  public metafunction __base__ {btConvexCast};
  public function extern "calcTimeOfImpact" bool calcTimeOfImpact(btTransform const& fromA_0, btTransform const& toA_1, btTransform const& fromB_2, btTransform const& toB_3, btConvexCast_CastResult mutable& result_4);
}
public threaded struct extern "::btGjkEpaPenetrationDepthSolver" "nonmovable" btGjkEpaPenetrationDepthSolver {
  public metafunction __base__ {btConvexPenetrationDepthSolver};
  public function extern "calcPenDepth" bool calcPenDepth(btVoronoiSimplexSolver mutable& simplexSolver_0, crptr{btConvexShape} pConvexA_1, crptr{btConvexShape} pConvexB_2, btTransform const& transformA_3, btTransform const& transformB_4, btVector3 mutable& v_5, btVector3 mutable& wWitnessOnA_6, btVector3 mutable& wWitnessOnB_7, rptr{btIDebugDraw} debugDraw_8);
}
public threaded struct extern "::btGjkEpaSolver2" btGjkEpaSolver2 {
}
public threaded struct extern "::btGjkEpaSolver2::sResults" btGjkEpaSolver2_sResults {
  public btScalar distance;
  public btVector3 normal;
  public rawarray{btVector3, 2} witnesses;
}
public threaded struct extern "::btGjkPairDetector" "nodefault" btGjkPairDetector(crptr{btConvexShape} objectA_0, crptr{btConvexShape} objectB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_3)  {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface};
  public function extern "getCachedSeparatingDistance" btScalar getCachedSeparatingDistance() const;
  public function extern "setMinkowskiA" void setMinkowskiA(crptr{btConvexShape} minkA_0);
  public function extern "getCachedSeparatingAxis" btVector3 const& getCachedSeparatingAxis() const;
  public function extern "getClosestPoints" void getClosestPoints(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input_0, btDiscreteCollisionDetectorInterface_Result mutable& output_1, rptr{btIDebugDraw} debugDraw_2, bool swapResults_3);
  public function extern "setPenetrationDepthSolver" void setPenetrationDepthSolver(rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_0);
  public function extern "setMinkowskiB" void setMinkowskiB(crptr{btConvexShape} minkB_0);
  public function extern "getClosestPointsNonVirtual" void getClosestPointsNonVirtual(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input_0, btDiscreteCollisionDetectorInterface_Result mutable& output_1, rptr{btIDebugDraw} debugDraw_2);
  public function extern "setIgnoreMargin" void setIgnoreMargin(bool ignoreMargin_0);
  public function extern "setCachedSeperatingAxis" void setCachedSeperatingAxis(btVector3 const& seperatingAxis_0);
  public int m_fixContactNormalDirection;
  public int m_degenerateSimplex;
  public int m_curIter;
  public int m_catchDegeneracies;
  public int m_lastUsedMethod;
}
public threaded struct extern "::btHashInt" "nodefault" btHashInt(int uid_0)  {
  public function extern "getHash" uint getHash() const;
  public function extern "getUid1" int getUid1() const;
  public function extern "equals" bool equals(btHashInt const& other_0) const;
  public function extern "setUid1" void setUid1(int uid_0);
}
public threaded struct extern "::btHashKey<btTriIndex>" "nodefault" btHashKey_btTriIndex private {
}
public threaded struct extern "::btHashMap<btHashInt, btTriangleInfo>" btHashMap_btHashInt_btTriangleInfo {
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashInt const& key_0) const;
  public function extern "find" rptr{btTriangleInfo} find(btHashInt const& key_0);
  public function extern "find" crptr{btTriangleInfo} cfind(btHashInt const& key_0) const;
  public function extern "getAtIndex" crptr{btTriangleInfo} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{btTriangleInfo} getAtIndex(int index_0);
  public function extern "size" int size() const;
  public function extern "insert" void insert(btHashInt const& key_0, btTriangleInfo const& value_1);
  public function extern "remove" void remove(btHashInt const& key_0);
}
public threaded struct extern "::btHashMap<btHashInt, int>" btHashMap_btHashInt_int {
  public function extern "size" int size() const;
  public function extern "insert" void insert(btHashInt const& key_0, int const& value_1);
  public function extern "remove" void remove(btHashInt const& key_0);
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashInt const& key_0) const;
  public function extern "find" crptr{int} cfind(btHashInt const& key_0) const;
  public function extern "find" rptr{int} find(btHashInt const& key_0);
  public function extern "getAtIndex" crptr{int} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{int} getAtIndex(int index_0);
}
public threaded struct extern "::btHashMap<btHashKey<btTriIndex>, btTriIndex>" btHashMap_btHashKey_btTriIndex_btTriIndex {
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashKey_btTriIndex const& key_0) const;
  public function extern "find" rptr{btTriIndex} find(btHashKey_btTriIndex const& key_0);
  public function extern "find" crptr{btTriIndex} cfind(btHashKey_btTriIndex const& key_0) const;
  public function extern "getAtIndex" rptr{btTriIndex} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{btTriIndex} cgetAtIndex(int index_0) const;
  public function extern "size" int size() const;
  public function extern "remove" void remove(btHashKey_btTriIndex const& key_0);
  public function extern "insert" void insert(btHashKey_btTriIndex const& key_0, btTriIndex const& value_1);
}
public threaded struct extern "::btHashMap<btHashPtr, bParse::bChunkInd>" btHashMap_btHashPtr_bParse_bChunkInd {
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public threaded struct extern "::btHashMap<btHashPtr, bParse::bStructHandle*>" btHashMap_btHashPtr_bParse_bStructHandle_p {
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "clear" void clear();
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public threaded struct extern "::btHashMap<btHashPtr, btCollisionObject*>" btHashMap_btHashPtr_btCollisionObject_p {
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{btCollisionObject} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{rptr{btCollisionObject}} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{rptr{btCollisionObject}} getAtIndex(int index_0);
  public function extern "find" crptr{rptr{btCollisionObject}} cfind(btHashPtr const& key_0) const;
  public function extern "find" rptr{rptr{btCollisionObject}} find(btHashPtr const& key_0);
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
}
public threaded struct extern "::btHashMap<btHashPtr, btCollisionShape*>" btHashMap_btHashPtr_btCollisionShape_p {
  public function extern "getAtIndex" rptr{rptr{btCollisionShape}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{btCollisionShape}} cgetAtIndex(int index_0) const;
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "clear" void clear();
  public function extern "find" crptr{rptr{btCollisionShape}} cfind(btHashPtr const& key_0) const;
  public function extern "find" rptr{rptr{btCollisionShape}} find(btHashPtr const& key_0);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{btCollisionShape} const& value_1);
  public function extern "size" int size() const;
}
public threaded struct extern "::btHashMap<btHashPtr, btOptimizedBvh*>" btHashMap_btHashPtr_btOptimizedBvh_p {
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{btOptimizedBvh} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{rptr{btOptimizedBvh}} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{rptr{btOptimizedBvh}} getAtIndex(int index_0);
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "clear" void clear();
  public function extern "find" crptr{rptr{btOptimizedBvh}} cfind(btHashPtr const& key_0) const;
  public function extern "find" rptr{rptr{btOptimizedBvh}} find(btHashPtr const& key_0);
}
public threaded struct extern "::btHashMap<btHashPtr, btPointerUid>" btHashMap_btHashPtr_btPointerUid {
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "find" rptr{btPointerUid} find(btHashPtr const& key_0);
  public function extern "find" crptr{btPointerUid} cfind(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{btPointerUid} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{btPointerUid} cgetAtIndex(int index_0) const;
  public function extern "size" int size() const;
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "insert" void insert(btHashPtr const& key_0, btPointerUid const& value_1);
}
public threaded struct extern "::btHashMap<btHashPtr, btTriangleInfoMap*>" btHashMap_btHashPtr_btTriangleInfoMap_p {
  public function extern "size" int size() const;
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{btTriangleInfoMap} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "find" rptr{rptr{btTriangleInfoMap}} find(btHashPtr const& key_0);
  public function extern "find" crptr{rptr{btTriangleInfoMap}} cfind(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{rptr{btTriangleInfoMap}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{btTriangleInfoMap}} cgetAtIndex(int index_0) const;
}
public threaded struct extern "::btHashMap<btHashPtr, char const*>" btHashMap_btHashPtr_char_const_p {
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "clear" void clear();
  public function extern "find" rptr{crptr{char}} find(btHashPtr const& key_0);
  public function extern "find" crptr{crptr{char}} cfind(btHashPtr const& key_0) const;
  public function extern "getAtIndex" crptr{crptr{char}} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{crptr{char}} getAtIndex(int index_0);
  public function extern "size" int size() const;
  public function extern "insert" void insert(btHashPtr const& key_0, crptr{char} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
}
public threaded struct extern "::btHashMap<btHashPtr, void*>" btHashMap_btHashPtr_void_p {
  public function extern "size" int size() const;
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{void} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "clear" void clear();
  public function extern "find" rptr{rptr{void}} find(btHashPtr const& key_0);
  public function extern "find" crptr{rptr{void}} cfind(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{rptr{void}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{void}} cgetAtIndex(int index_0) const;
}
public threaded struct extern "::btHashMap<btHashString, btCollisionShape*>" btHashMap_btHashString_btCollisionShape_p {
  public function extern "size" int size() const;
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "insert" void insert(btHashString const& key_0, rptr{btCollisionShape} const& value_1);
  public function extern "findIndex" int findIndex(btHashString const& key_0) const;
  public function extern "clear" void clear();
  public function extern "find" crptr{rptr{btCollisionShape}} cfind(btHashString const& key_0) const;
  public function extern "find" rptr{rptr{btCollisionShape}} find(btHashString const& key_0);
  public function extern "getAtIndex" rptr{rptr{btCollisionShape}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{btCollisionShape}} cgetAtIndex(int index_0) const;
}
public threaded struct extern "::btHashMap<btHashString, btRigidBody*>" btHashMap_btHashString_btRigidBody_p {
  public function extern "size" int size() const;
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "insert" void insert(btHashString const& key_0, rptr{btRigidBody} const& value_1);
  public function extern "find" rptr{rptr{btRigidBody}} find(btHashString const& key_0);
  public function extern "find" crptr{rptr{btRigidBody}} cfind(btHashString const& key_0) const;
  public function extern "findIndex" int findIndex(btHashString const& key_0) const;
  public function extern "clear" void clear();
  public function extern "getAtIndex" crptr{rptr{btRigidBody}} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{rptr{btRigidBody}} getAtIndex(int index_0);
}
public threaded struct extern "::btHashMap<btHashString, btTypedConstraint*>" btHashMap_btHashString_btTypedConstraint_p {
  public function extern "find" crptr{rptr{btTypedConstraint}} cfind(btHashString const& key_0) const;
  public function extern "find" rptr{rptr{btTypedConstraint}} find(btHashString const& key_0);
  public function extern "findIndex" int findIndex(btHashString const& key_0) const;
  public function extern "clear" void clear();
  public function extern "getAtIndex" crptr{rptr{btTypedConstraint}} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{rptr{btTypedConstraint}} getAtIndex(int index_0);
  public function extern "size" int size() const;
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "insert" void insert(btHashString const& key_0, rptr{btTypedConstraint} const& value_1);
}
public threaded struct extern "::btHashMap<btHashString, int>" btHashMap_btHashString_int {
  public function extern "size" int size() const;
  public function extern "insert" void insert(btHashString const& key_0, int const& value_1);
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "find" crptr{int} cfind(btHashString const& key_0) const;
  public function extern "find" rptr{int} find(btHashString const& key_0);
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashString const& key_0) const;
  public function extern "getAtIndex" crptr{int} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{int} getAtIndex(int index_0);
}
public threaded struct extern "::btHashPtr" "nodefault" btHashPtr(crptr{void} ptr_0)  {
  public function extern "equals" bool equals(btHashPtr const& other_0) const;
  public function extern "getPointer" crptr{void} getPointer() const;
  public function extern "getHash" uint getHash() const;
}
/* skip btHashPtr_28 : unnamed */
public threaded struct extern "::btHashString" "nodefault" btHashString(crptr{char} name_0)  {
  public function extern "getHash" uint getHash() const;
  public function extern "portableStringCompare" int portableStringCompare(crptr{char} src_0, crptr{char} dst_1) const;
  public function extern "equals" bool equals(btHashString const& other_0) const;
  public crptr{char} m_string;
  public uint m_hash;
}
public threaded struct extern "::btHashedOverlappingPairCache" "nonmovable" btHashedOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCache, btOverlappingPairCallback};
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "GetCount" int GetCount() const;
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback_0);
  public function extern "getOverlappingPairArray" btBroadphasePairArray const& cgetOverlappingPairArray() const;
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback_0);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getOverlapFilterCallback" rptr{btOverlapFilterCallback} getOverlapFilterCallback();
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher_1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair_0, rptr{btDispatcher} dispatcher_1);
  public function extern "needsBroadphaseCollision" bool needsBroadphaseCollision(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1) const;
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
}
public threaded struct extern "::btHashedSimplePairCache" "nonmovable" btHashedSimplePairCache {
  public function extern "GetCount" int GetCount() const;
  public function extern "removeAllPairs" void removeAllPairs();
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(int indexA_0, int indexB_1);
  public function extern "getOverlappingPairArrayPtr" crptr{btSimplePair} cgetOverlappingPairArrayPtr() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btSimplePair} getOverlappingPairArrayPtr();
  public function extern "addOverlappingPair" rptr{btSimplePair} addOverlappingPair(int indexA_0, int indexB_1);
  public function extern "getOverlappingPairArray" btSimplePairArray const& cgetOverlappingPairArray() const;
  public function extern "getOverlappingPairArray" btSimplePairArray mutable& getOverlappingPairArray();
  public function extern "findPair" rptr{btSimplePair} findPair(int indexA_0, int indexB_1);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
}
public threaded struct extern "::btHeightfieldTerrainShape" "nodefault" btHeightfieldTerrainShape(int heightStickWidth_0, int heightStickLength_1, crptr{void} heightfieldData_2, btScalar heightScale_3, btScalar minHeight_4, btScalar maxHeight_5, int upAxis_6, PHY_ScalarType heightDataType_7, bool flipQuadEdges_8)  {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUseZigzagSubdivision" void setUseZigzagSubdivision(bool useZigzagSubdivision_0);
  public function extern "setUseDiamondSubdivision" void setUseDiamondSubdivision(bool useDiamondSubdivision_0);
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
}
/* skip btHeightfieldTerrainShape_34 : unnamed */
public threaded struct extern "::btHinge2Constraint" "nodefault" btHinge2Constraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 mutable& anchor_2, btVector3 mutable& axis1_3, btVector3 mutable& axis2_4)  {
  public metafunction __base__ {btTypedConstraint, btGeneric6DofConstraint, btGeneric6DofSpringConstraint, btTypedObject};
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "enableSpring" void enableSpring(int index_0, bool onOff_1);
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "setStiffness" void setStiffness(int index_0, btScalar stiffness_1);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "setDamping" void setDamping(int index_0, btScalar damping_1);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper_0);
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "setLowerLimit" void setLowerLimit(btScalar ang1min_0);
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getAngle2" btScalar getAngle2();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower_0);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index_0);
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "getAxis" btVector3 getAxis(int axis_index_0) const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "setAxis" void setAxis(btVector3 const& axis1_0, btVector3 const& axis2_1);
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "getAngle" btScalar getAngle(int axis_index_0) const;
  public function extern "getUid" int getUid() const;
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6, rptr{btTypedConstraint_btConstraintInfo2} info_7, int row_8, btVector3 mutable& ax1_9, int rotational_10, int rotAllowed_11);
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower_0);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "setEquilibriumPoint" void setEquilibriumPoint0();
  public function extern "setEquilibriumPoint" void setEquilibriumPoint1(int index_0);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint2(int index_0, btScalar val_1);
  public function extern "setUpperLimit" void setUpperLimit(btScalar ang1max_0);
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6);
  public function extern "getAnchor2" btVector3 const& getAnchor2();
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper_0);
  public function extern "getAngle1" btScalar getAngle1();
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getAxis1" btVector3 const& getAxis1();
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower_0);
  public function extern "setLimit" void setLimit(int axis_0, btScalar lo_1, btScalar hi_2);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "getAxis2" btVector3 const& getAxis2();
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index_0) const;
  public function extern "getAnchor" btVector3 const& getAnchor();
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower_0);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public bool m_useSolveConstraintObsolete;
  public int m_objectType;
}
public threaded struct extern "::btHingeConstraint" "nodefault" btHingeConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3, btVector3 const& axisInA_4, btVector3 const& axisInB_5, bool useReferenceFrameA_6)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getMaxMotorImpulse" btScalar getMaxMotorImpulse();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getLimitSign" btScalar getLimitSign();
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getMotorTargetVelosity" btScalar getMotorTargetVelosity();
  public function extern "getUid" int getUid() const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setAxis" void setAxis(btVector3 mutable& axisInA_0);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getBFrame" btTransform const& cgetBFrame() const;
  public function extern "getBFrame" btTransform mutable& getBFrame();
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly_0);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getInfo2InternalUsingFrameOffset" void getInfo2InternalUsingFrameOffset(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getInfo2Internal" void getInfo2Internal(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "setMotorTarget" void setMotorTarget_btScalar_btScalar(btScalar targetAngle_0, btScalar dt_1);
  public function extern "setMotorTarget" void setMotorTarget_btQuaternion_btScalar(btQuaternion const& qAinB_0, btScalar dt_1);
  public function extern "getUpperLimit" btScalar getUpperLimit() const;
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "getAngularOnly" bool getAngularOnly();
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "getSolveLimit" int getSolveLimit();
  public function extern "getAFrame" btTransform mutable& getAFrame();
  public function extern "getAFrame" btTransform const& cgetAFrame() const;
  public function extern "getHingeAngle" btScalar getHingeAngle2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "getHingeAngle" btScalar getHingeAngle0();
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "enableAngularMotor" void enableAngularMotor(bool enableMotor_0, btScalar targetVelocity_1, btScalar maxMotorImpulse_2);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse_0);
  public function extern "testLimit" void testLimit(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "getEnableAngularMotor" bool getEnableAngularMotor();
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setLimit" void setLimit(btScalar low_0, btScalar high_1, btScalar _softness_2, btScalar _biasFactor_3, btScalar _relaxationFactor_4);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "getLowerLimit" btScalar getLowerLimit() const;
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "enableMotor" void enableMotor(bool enableMotor_0);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public int m_objectType;
}
public threaded struct extern "::btHingeConstraintDoubleData" btHingeConstraintDoubleData {
  public float m_limitSoftness;
  public int m_useReferenceFrameA;
  public int m_enableAngularMotor;
  public int m_angularOnly;
  public float m_maxMotorImpulse;
  public btTransformDoubleData m_rbAFrame;
  public float m_relaxationFactor;
  public float m_biasFactor;
  public float m_lowerLimit;
  public float m_motorTargetVelocity;
  public btTypedConstraintData m_typeConstraintData;
  public float m_upperLimit;
  public btTransformDoubleData m_rbBFrame;
}
public threaded struct extern "::btHingeConstraintDoubleData2" btHingeConstraintDoubleData2 {
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btTransformDoubleData m_rbBFrame;
  public double m_upperLimit;
  public double m_relaxationFactor;
  public btTransformDoubleData m_rbAFrame;
  public double m_motorTargetVelocity;
  public double m_biasFactor;
  public double m_lowerLimit;
  public int m_enableAngularMotor;
  public int m_useReferenceFrameA;
  public int m_angularOnly;
  public double m_maxMotorImpulse;
  public rawarray{char, 4} m_padding1;
  public double m_limitSoftness;
}
public threaded struct extern "::btHingeConstraintFloatData" btHingeConstraintFloatData {
  public float m_maxMotorImpulse;
  public int m_angularOnly;
  public int m_useReferenceFrameA;
  public int m_enableAngularMotor;
  public float m_limitSoftness;
  public float m_upperLimit;
  public btTransformFloatData m_rbBFrame;
  public btTypedConstraintData m_typeConstraintData;
  public float m_lowerLimit;
  public float m_biasFactor;
  public float m_motorTargetVelocity;
  public btTransformFloatData m_rbAFrame;
  public float m_relaxationFactor;
}
public tsvaluetype struct extern "::btHingeFlags" "extenum" btHingeFlags { }
public extern "BT_HINGE_FLAGS_CFM_STOP" btHingeFlags BT_HINGE_FLAGS_CFM_STOP;
public extern "BT_HINGE_FLAGS_ERP_STOP" btHingeFlags BT_HINGE_FLAGS_ERP_STOP;
public extern "BT_HINGE_FLAGS_CFM_NORM" btHingeFlags BT_HINGE_FLAGS_CFM_NORM;
public threaded struct extern "::btIDebugDraw" "nonmovable" btIDebugDraw {
  public function extern "drawTriangle" void drawTriangle8(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2, btVector3 const& _3, btVector3 const& _4, btVector3 const& _5, btVector3 const& color_6, btScalar alpha_7);
  public function extern "drawTriangle" void drawTriangle5(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2, btVector3 const& color_3, btScalar _4);
  public function extern "drawContactPoint" void drawContactPoint(btVector3 const& PointOnB_0, btVector3 const& normalOnB_1, btScalar distance_2, int lifeTime_3, btVector3 const& color_4);
  public function extern "drawCone" void drawCone(btScalar radius_0, btScalar height_1, int upAxis_2, btTransform const& transform_3, btVector3 const& color_4);
  public function extern "drawLine" void drawLine4(btVector3 const& from_0, btVector3 const& to_1, btVector3 const& fromColor_2, btVector3 const& toColor_3);
  public function extern "drawLine" void drawLine3(btVector3 const& from_0, btVector3 const& to_1, btVector3 const& color_2);
  public function extern "drawCapsule" void drawCapsule(btScalar radius_0, btScalar halfHeight_1, int upAxis_2, btTransform const& transform_3, btVector3 const& color_4);
  public function extern "drawSphere" void drawSphere_btScalar_btTransform_btVector3(btScalar radius_0, btTransform const& transform_1, btVector3 const& color_2);
  public function extern "drawSphere" void drawSphere_btVector3_btScalar_btVector3(btVector3 const& p_0, btScalar radius_1, btVector3 const& color_2);
  public function extern "drawTransform" void drawTransform(btTransform const& transform_0, btScalar orthoLen_1);
  public function extern "getDebugMode" int getDebugMode() const;
  public function extern "drawSpherePatch" void drawSpherePatch(btVector3 const& center_0, btVector3 const& up_1, btVector3 const& axis_2, btScalar radius_3, btScalar minTh_4, btScalar maxTh_5, btScalar minPs_6, btScalar maxPs_7, btVector3 const& color_8, btScalar stepDegrees_9, bool drawCenter_10);
  public function extern "drawArc" void drawArc(btVector3 const& center_0, btVector3 const& normal_1, btVector3 const& axis_2, btScalar radiusA_3, btScalar radiusB_4, btScalar minAngle_5, btScalar maxAngle_6, btVector3 const& color_7, bool drawSect_8, btScalar stepDegrees_9);
  public function extern "drawBox" void drawBox4(btVector3 const& bbMin_0, btVector3 const& bbMax_1, btTransform const& trans_2, btVector3 const& color_3);
  public function extern "drawBox" void drawBox3(btVector3 const& bbMin_0, btVector3 const& bbMax_1, btVector3 const& color_2);
  public function extern "setDebugMode" void setDebugMode(int debugMode_0);
  public function extern "reportErrorWarning" void reportErrorWarning(crptr{char} warningString_0);
  public function extern "drawCylinder" void drawCylinder(btScalar radius_0, btScalar halfHeight_1, int upAxis_2, btTransform const& transform_3, btVector3 const& color_4);
  public function extern "draw3dText" void draw3dText(btVector3 const& location_0, crptr{char} textString_1);
  public function extern "drawAabb" void drawAabb(btVector3 const& from_0, btVector3 const& to_1, btVector3 const& color_2);
  public function extern "drawPlane" void drawPlane(btVector3 const& planeNormal_0, btScalar planeConst_1, btTransform const& transform_2, btVector3 const& color_3);
}
public threaded struct extern "::btIndexedMesh" btIndexedMesh {
  public crptr{uchar} m_vertexBase;
  public int m_numVertices;
  public int m_triangleIndexStride;
  public PHY_ScalarType m_indexType;
  public PHY_ScalarType m_vertexType;
  public int m_numTriangles;
  public int m_vertexStride;
  public crptr{uchar} m_triangleIndexBase;
}
public threaded struct extern "::btIntIndexData" btIntIndexData {
  public int m_value;
}
public threaded struct extern "::btIntSortPredicate" btIntSortPredicate {
}
public tsvaluetype struct extern "::btInternalEdgeAdjustFlags" "extenum" btInternalEdgeAdjustFlags { }
public extern "BT_TRIANGLE_CONVEX_BACKFACE_MODE" btInternalEdgeAdjustFlags BT_TRIANGLE_CONVEX_BACKFACE_MODE;
public extern "BT_TRIANGLE_CONCAVE_DOUBLE_SIDED" btInternalEdgeAdjustFlags BT_TRIANGLE_CONCAVE_DOUBLE_SIDED;
public extern "BT_TRIANGLE_CONVEX_DOUBLE_SIDED" btInternalEdgeAdjustFlags BT_TRIANGLE_CONVEX_DOUBLE_SIDED;
public metafunction btInternalTickCallback rptr{meta::list{void, rptr{btDynamicsWorld}, btScalar}};
public threaded struct extern "::btInternalTriangleIndexCallback" "nonmovable" btInternalTriangleIndexCallback {
  public function extern "internalProcessTriangleIndex" void internalProcessTriangleIndex(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
}
public metafunction btInternalTriangleInfoMap btHashMap_btHashInt_btTriangleInfo;
public threaded struct extern "::btJacobianEntry" btJacobianEntry {
  public function extern "getDiagonal" btScalar getDiagonal() const;
  public function extern "getNonDiagonal" btScalar getNonDiagonal3(btJacobianEntry const& jacB_0, btScalar const massInvA_1, btScalar const massInvB_2) const;
  public function extern "getNonDiagonal" btScalar getNonDiagonal2(btJacobianEntry const& jacB_0, btScalar const massInvA_1) const;
  public function extern "getRelativeVelocity" btScalar getRelativeVelocity(btVector3 const& linvelA_0, btVector3 const& angvelA_1, btVector3 const& linvelB_2, btVector3 const& angvelB_3);
  public btVector3 m_1MinvJt;
  public btVector3 m_0MinvJt;
  public btVector3 m_bJ;
  public btVector3 m_linearJointAxis;
  public btScalar m_Adiag;
  public btVector3 m_aJ;
}
public threaded struct extern "::btJointFeedback" btJointFeedback {
  public btVector3 m_appliedForceBodyB;
  public btVector3 m_appliedForceBodyA;
  public btVector3 m_appliedTorqueBodyB;
  public btVector3 m_appliedTorqueBodyA;
}
public threaded struct extern "::btKinematicCharacterController" "nodefault" btKinematicCharacterController(rptr{btPairCachingGhostObject} ghostObject_0, rptr{btConvexShape} convexShape_1, btScalar stepHeight_2, int upAxis_3)  {
  public metafunction __base__ {btCharacterControllerInterface, btActionInterface};
  public function extern "setUseGhostSweepTest" void setUseGhostSweepTest(bool useGhostObjectSweepTest_0);
  public function extern "getGhostObject" rptr{btPairCachingGhostObject} getGhostObject();
  public function extern "onGround" bool onGround() const;
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld_0, btScalar deltaTime_1);
  public function extern "setMaxSlope" void setMaxSlope(btScalar slopeRadians_0);
  public function extern "warp" void warp(btVector3 const& origin_0);
  public function extern "setGravity" void setGravity(btScalar gravity_0);
  public function extern "preStep" void preStep(rptr{btCollisionWorld} collisionWorld_0);
  public function extern "getGravity" btScalar getGravity() const;
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "setUpInterpolate" void setUpInterpolate(bool value_0);
  public function extern "setWalkDirection" void setWalkDirection(btVector3 const& walkDirection_0);
  public function extern "reset" void reset(rptr{btCollisionWorld} collisionWorld_0);
  public function extern "playerStep" void playerStep(rptr{btCollisionWorld} collisionWorld_0, btScalar dt_1);
  public function extern "setFallSpeed" void setFallSpeed(btScalar fallSpeed_0);
  public function extern "getMaxSlope" btScalar getMaxSlope() const;
  public function extern "jump" void jump();
  public function extern "setVelocityForTimeInterval" void setVelocityForTimeInterval(btVector3 const& velocity_0, btScalar timeInterval_1);
  public function extern "setJumpSpeed" void setJumpSpeed(btScalar jumpSpeed_0);
  public function extern "setUpAxis" void setUpAxis(int axis_0);
  public function extern "canJump" bool canJump() const;
  public function extern "setMaxJumpHeight" void setMaxJumpHeight(btScalar maxJumpHeight_0);
}
public metafunction btManifoldArray btAlignedObjectArray_btPersistentManifold_p;
public threaded struct extern "::btManifoldPoint" btManifoldPoint {
  public function extern "getPositionWorldOnA" btVector3 const& getPositionWorldOnA() const;
  public function extern "getDistance" btScalar getDistance() const;
  public function extern "setDistance" void setDistance(btScalar dist_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getPositionWorldOnB" btVector3 const& getPositionWorldOnB() const;
  public function extern "getLifeTime" int getLifeTime() const;
  public int m_lifeTime;
  public rptr{void} m_userPersistentData;
  public btScalar m_contactCFM1;
  public btScalar m_appliedImpulseLateral2;
  public btScalar m_appliedImpulse;
  public int m_index0;
  public btScalar m_contactMotion1;
  public btScalar m_combinedRollingFriction;
  public btVector3 m_lateralFrictionDir2;
  public int m_index1;
  public btVector3 m_localPointA;
  public btVector3 m_lateralFrictionDir1;
  public int m_partId1;
  public bool m_lateralFrictionInitialized;
  public btScalar m_combinedRestitution;
  public btScalar m_distance1;
  public btVector3 m_positionWorldOnB;
  public btScalar m_combinedFriction;
  public int m_partId0;
  public btVector3 m_positionWorldOnA;
  public btScalar m_appliedImpulseLateral1;
  public btVector3 m_normalWorldOnB;
  public btScalar m_contactCFM2;
  public btVector3 m_localPointB;
  public btScalar m_contactMotion2;
}
public threaded struct extern "::btManifoldResult" "nonmovable" btManifoldResult {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld_0, btVector3 const& pointInWorld_1, btScalar depth_2);
  public function extern "getBody1Internal" crptr{btCollisionObject} getBody1Internal() const;
  public function extern "getPersistentManifold" crptr{btPersistentManifold} cgetPersistentManifold() const;
  public function extern "getPersistentManifold" rptr{btPersistentManifold} getPersistentManifold();
  public function extern "setPersistentManifold" void setPersistentManifold(rptr{btPersistentManifold} manifoldPtr_0);
  public function extern "getBody0Wrap" crptr{btCollisionObjectWrapper} getBody0Wrap() const;
  public function extern "getBody1Wrap" crptr{btCollisionObjectWrapper} getBody1Wrap() const;
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1_0, int index1_1);
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0_0, int index0_1);
  public function extern "getBody0Internal" crptr{btCollisionObject} getBody0Internal() const;
  public function extern "setBody1Wrap" void setBody1Wrap(crptr{btCollisionObjectWrapper} obj1Wrap_0);
  public function extern "refreshContactPoints" void refreshContactPoints();
  public function extern "setBody0Wrap" void setBody0Wrap(crptr{btCollisionObjectWrapper} obj0Wrap_0);
}
public threaded struct extern "::btMaterial" btMaterial {
  public rawarray{int, 2} pad;
  public btScalar m_restitution;
  public btScalar m_friction;
}
public threaded struct extern "::btMaterialProperties" btMaterialProperties {
  public int m_numTriangles;
  public int m_triangleMaterialStride;
  public PHY_ScalarType m_triangleType;
  public int m_materialStride;
  public crptr{uchar} m_triangleMaterialsBase;
  public PHY_ScalarType m_materialType;
  public crptr{uchar} m_materialBase;
  public int m_numMaterials;
}
public threaded struct extern "::btMatrix3x3" btMatrix3x3 {
  public function extern "tdoty" btScalar tdoty(btVector3 const& v_0) const;
  public function extern "determinant" btScalar determinant() const;
  public function extern "setIdentity" void setIdentity();
  public function extern "serialize" void serialize(btMatrix3x3FloatData mutable& dataOut_0) const;
  public function extern "getEulerZYX" void getEulerZYX(btScalar mutable& yaw_0, btScalar mutable& pitch_1, btScalar mutable& roll_2, uint solution_number_3) const;
  public function extern "getEulerYPR" void getEulerYPR(btScalar mutable& yaw_0, btScalar mutable& pitch_1, btScalar mutable& roll_2) const;
  public function extern "serializeFloat" void serializeFloat(btMatrix3x3FloatData mutable& dataOut_0) const;
  public function extern "deSerialize" void deSerialize(btMatrix3x3FloatData const& dataIn_0);
  public function extern "transposeTimes" btMatrix3x3 transposeTimes(btMatrix3x3 const& m_0) const;
  public function extern "setRotation" void setRotation(btQuaternion const& q_0);
  public function extern "deSerializeDouble" void deSerializeDouble(btMatrix3x3DoubleData const& dataIn_0);
  public function extern "tdotz" btScalar tdotz(btVector3 const& v_0) const;
  public function extern "absolute" btMatrix3x3 absolute() const;
  public function extern "setEulerZYX" void setEulerZYX(btScalar eulerX_0, btScalar eulerY_1, btScalar eulerZ_2);
  public function extern "cofac" btScalar cofac(int r1_0, int c1_1, int r2_2, int c2_3) const;
  public function extern "deSerializeFloat" void deSerializeFloat(btMatrix3x3FloatData const& dataIn_0);
  public function extern "setValue" void setValue(btScalar const& xx_0, btScalar const& xy_1, btScalar const& xz_2, btScalar const& yx_3, btScalar const& yy_4, btScalar const& yz_5, btScalar const& zx_6, btScalar const& zy_7, btScalar const& zz_8);
  public function extern "getColumn" btVector3 getColumn(int i_0) const;
  public function extern "tdotx" btScalar tdotx(btVector3 const& v_0) const;
  public function extern "scaled" btMatrix3x3 scaled(btVector3 const& s_0) const;
  public function extern "adjoint" btMatrix3x3 adjoint() const;
  public function extern "getOpenGLSubMatrix" void getOpenGLSubMatrix(rptr{btScalar} m_0) const;
  public function extern "diagonalize" void diagonalize(btMatrix3x3 mutable& rot_0, btScalar threshold_1, int maxSteps_2);
  public function extern "getRotation" void getRotation(btQuaternion mutable& q_0) const;
  public function extern "timesTranspose" btMatrix3x3 timesTranspose(btMatrix3x3 const& m_0) const;
  public function extern "inverse" btMatrix3x3 inverse() const;
  public function extern "getRow" btVector3 const& getRow(int i_0) const;
  public function extern "setFromOpenGLSubMatrix" void setFromOpenGLSubMatrix(crptr{btScalar} m_0);
  public function extern "transpose" btMatrix3x3 transpose() const;
  public function extern "setEulerYPR" void setEulerYPR(btScalar const& yaw_0, btScalar const& pitch_1, btScalar const& roll_2);
}
public threaded struct extern "::btMatrix3x3DoubleData" btMatrix3x3DoubleData {
  public rawarray{btVector3DoubleData, 3} m_el;
}
public threaded struct extern "::btMatrix3x3FloatData" btMatrix3x3FloatData {
  public rawarray{btVector3FloatData, 3} m_el;
}
public threaded struct extern "::btMatrixX<double>" btMatrixX_double {
  public function extern "cols" int cols() const;
  public function extern "resize" void resize(int rows_0, int cols_1);
  public function extern "sortRowIndexArrays" void sortRowIndexArrays();
  public function extern "printMatrix" void printMatrix(crptr{char} msg_0);
  public function extern "setZero" void setZero();
  public function extern "multiply2_p8r" void multiply2_p8r(crptr{btScalar} B_0, crptr{btScalar} C_1, int numRows_2, int numRowsOther_3, int row_4, int col_5);
  public function extern "clearSparseInfo" void clearSparseInfo();
  public function extern "getBufferPointerWritable" rptr{double} getBufferPointerWritable();
  public function extern "sortColIndexArrays" void sortColIndexArrays();
  public function extern "rows" int rows() const;
  public function extern "getBufferPointer" crptr{double} getBufferPointer() const;
  public function extern "setElem" void setElem(int row_0, int col_1, double val_2);
  public function extern "copyLowerToUpperTriangle" void copyLowerToUpperTriangle();
  public function extern "multiplyAdd2_p8r" void multiplyAdd2_p8r(crptr{btScalar} B_0, crptr{btScalar} C_1, int numRows_2, int numRowsOther_3, int row_4, int col_5);
  public function extern "printNumZeros" void printNumZeros(crptr{char} msg_0);
  public function extern "transpose" btMatrixX_double transpose() const;
  public function extern "addElem" void addElem(int row_0, int col_1, double val_2);
  public btAlignedObjectArray_double m_storage;
  public int m_resizeOperations;
  public int m_operations;
  public int m_setElemOperations;
  public int m_cols;
  public btAlignedObjectArray_btAlignedObjectArray_int_ m_colNonZeroElements;
  public int m_rows;
  public btAlignedObjectArray_btAlignedObjectArray_int_ m_rowNonZeroElements1;
}
public threaded struct extern "::btMatrixX<float>" btMatrixX_float {
  public function extern "rows" int rows() const;
  public function extern "sortColIndexArrays" void sortColIndexArrays();
  public function extern "getBufferPointerWritable" rptr{float} getBufferPointerWritable();
  public function extern "clearSparseInfo" void clearSparseInfo();
  public function extern "multiply2_p8r" void multiply2_p8r(crptr{btScalar} B_0, crptr{btScalar} C_1, int numRows_2, int numRowsOther_3, int row_4, int col_5);
  public function extern "sortRowIndexArrays" void sortRowIndexArrays();
  public function extern "printMatrix" void printMatrix(crptr{char} msg_0);
  public function extern "setZero" void setZero();
  public function extern "cols" int cols() const;
  public function extern "resize" void resize(int rows_0, int cols_1);
  public function extern "addElem" void addElem(int row_0, int col_1, float val_2);
  public function extern "transpose" btMatrixX_float transpose() const;
  public function extern "printNumZeros" void printNumZeros(crptr{char} msg_0);
  public function extern "multiplyAdd2_p8r" void multiplyAdd2_p8r(crptr{btScalar} B_0, crptr{btScalar} C_1, int numRows_2, int numRowsOther_3, int row_4, int col_5);
  public function extern "copyLowerToUpperTriangle" void copyLowerToUpperTriangle();
  public function extern "setElem" void setElem(int row_0, int col_1, float val_2);
  public function extern "getBufferPointer" crptr{float} getBufferPointer() const;
  public int m_operations;
  public int m_setElemOperations;
  public btAlignedObjectArray_float m_storage;
  public int m_resizeOperations;
  public int m_cols;
  public btAlignedObjectArray_btAlignedObjectArray_int_ m_rowNonZeroElements1;
  public int m_rows;
  public btAlignedObjectArray_btAlignedObjectArray_int_ m_colNonZeroElements;
}
public metafunction btMatrixXd btMatrixX_double;
public metafunction btMatrixXf btMatrixX_float;
public threaded struct extern "::btMeshPartData" btMeshPartData {
  public rptr{btIntIndexData} m_indices32;
  public rptr{btShortIntIndexData} m_indices16;
  public rptr{btVector3FloatData} m_vertices3f;
  public rptr{btVector3DoubleData} m_vertices3d;
  public rptr{btCharIndexTripletData} m_3indices8;
  public int m_numVertices;
  public rptr{btShortIntIndexTripletData} m_3indices16;
  public int m_numTriangles;
}
public threaded struct extern "::btMinkowskiPenetrationDepthSolver" "nonmovable" btMinkowskiPenetrationDepthSolver {
  public metafunction __base__ {btConvexPenetrationDepthSolver};
  public function extern "calcPenDepth" bool calcPenDepth(btVoronoiSimplexSolver mutable& simplexSolver_0, crptr{btConvexShape} convexA_1, crptr{btConvexShape} convexB_2, btTransform const& transA_3, btTransform const& transB_4, btVector3 mutable& v_5, btVector3 mutable& pa_6, btVector3 mutable& pb_7, rptr{btIDebugDraw} debugDraw_8);
}
public threaded struct extern "::btMinkowskiSumShape" "nodefault" btMinkowskiSumShape(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1)  {
  public metafunction __base__ {btCollisionShape, btConvexInternalShape, btConvexShape};
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getShapeB" crptr{btConvexShape} getShapeB() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "setTransformA" void setTransformA(btTransform const& transA_0);
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setTransformB" void setTransformB(btTransform const& transB_0);
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "GetTransformB" btTransform const& GetTransformB() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getShapeA" crptr{btConvexShape} getShapeA() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "isCompound" bool isCompound() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getTransformA" btTransform const& getTransformA() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
}
public threaded struct extern "::btMotionState" "nonmovable" btMotionState {
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
  public function extern "getWorldTransform" void getWorldTransform(btTransform mutable& worldTrans_0) const;
}
public threaded struct extern "::btMultiSapBroadphase" "nodefault" btMultiSapBroadphase(int maxProxies_0, rptr{btOverlappingPairCache} pairCache_1)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "printStats" void printStats();
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "buildTree" void buildTree(btVector3 const& bvhAabbMin_0, btVector3 const& bvhAabbMax_1);
  public function extern "quicksort" void quicksort(btBroadphasePairArray mutable& a_0, int lo_1, int hi_2);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "getBroadphaseArray" btSapBroadphaseArray mutable& getBroadphaseArray();
  public function extern "getBroadphaseArray" btSapBroadphaseArray const& cgetBroadphaseArray() const;
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "addToChildBroadphase" void addToChildBroadphase(rptr{btMultiSapBroadphase_btMultiSapProxy} parentMultiSapProxy_0, rptr{btBroadphaseProxy} childProxy_1, rptr{btBroadphaseInterface} childBroadphase_2);
}
public threaded struct extern "::btMultiSapBroadphase::btBridgeProxy" "nodefault" btMultiSapBroadphase_btBridgeProxy private {
}
public threaded struct extern "::btMultiSapBroadphase::btMultiSapProxy" "nodefault" btMultiSapBroadphase_btMultiSapProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5)  {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "getUid" int getUid() const;
  public rptr{void} m_clientObject;
  public short m_collisionFilterMask;
  public int m_shapeType;
  public btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p m_bridgeProxies;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
  public short m_collisionFilterGroup;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
}
public threaded struct extern "::btMultiSphereShape" "nodefault" btMultiSphereShape(crptr{btVector3} positions_0, crptr{btScalar} radi_1, int numSpheres_2)  {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btConvexInternalAabbCachingShape, btCollisionShape};
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getSpherePosition" btVector3 const& getSpherePosition(int index_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getSphereRadius" btScalar getSphereRadius(int index_0) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getSphereCount" int getSphereCount() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
}
public threaded struct extern "::btMultiSphereShapeData" btMultiSphereShapeData {
  public rptr{btPositionAndRadius} m_localPositionArrayPtr;
  public int m_localPositionArraySize;
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btMultimaterialTriangleMeshShape" "nodefault" btMultimaterialTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, bool buildBvh_2)  {
  public metafunction __base__ {btCollisionShape, btBvhTriangleMeshShape, btTriangleMeshShape, btConcaveShape};
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "setOptimizedBvh" void setOptimizedBvh(rptr{btOptimizedBvh} bvh_0, btVector3 const& localScaling_1);
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getOptimizedBvh" rptr{btOptimizedBvh} getOptimizedBvh();
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "performRaycast" void performRaycast(rptr{btTriangleCallback} callback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2);
  public function extern "setTriangleInfoMap" void setTriangleInfoMap(rptr{btTriangleInfoMap} triangleInfoMap_0);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "performConvexcast" void performConvexcast(rptr{btTriangleCallback} callback_0, btVector3 const& boxSource_1, btVector3 const& boxTarget_2, btVector3 const& boxMin_3, btVector3 const& boxMax_4);
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "usesQuantizedAabbCompression" bool usesQuantizedAabbCompression() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "getOwnsBvh" bool getOwnsBvh() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getTriangleInfoMap" crptr{btTriangleInfoMap} cgetTriangleInfoMap() const;
  public function extern "getTriangleInfoMap" rptr{btTriangleInfoMap} getTriangleInfoMap();
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getMaterialProperties" crptr{btMaterial} getMaterialProperties(int partID_0, int triIndex_1);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "refitTree" void refitTree(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1);
  public function extern "partialRefitTree" void partialRefitTree(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1);
  public function extern "buildOptimizedBvh" void buildOptimizedBvh();
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serializeSingleBvh" void serializeSingleBvh(rptr{btSerializer} serializer_0) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "serializeSingleTriangleInfoMap" void serializeSingleTriangleInfoMap(rptr{btSerializer} serializer_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
}
public metafunction btNearCallback rptr{meta::list{void, rawref{btBroadphasePair}, rawref{btCollisionDispatcher}, crawref{btDispatcherInfo}}};
public threaded struct extern "::btNodeOverlapCallback" "nonmovable" btNodeOverlapCallback {
  public function extern "processNode" void processNode(int subPart_0, int triangleIndex_1);
}
public threaded struct extern "::btNullPairCache" "nonmovable" btNullPairCache {
  public metafunction __base__ {btOverlappingPairCallback, btOverlappingPairCache};
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1);
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} _0, rptr{btDispatcher} _1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} _0);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1, rptr{btDispatcher} _2);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} _0, rptr{btDispatcher} _1);
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} _0);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} _1);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& _0, rptr{btDispatcher} _1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1);
}
public threaded struct extern "::btOptimizedBvh" "nonmovable" btOptimizedBvh {
  public metafunction __base__ {btQuantizedBvh};
  public function extern "isQuantized" bool isQuantized();
  public function extern "serializeInPlace" bool serializeInPlace(rptr{void} o_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2) const;
  public function extern "calculateSerializeBufferSizeNew" int calculateSerializeBufferSizeNew() const;
  public function extern "quantize" void quantize(rptr{ushort} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "setQuantizationValues" void setQuantizationValues(btVector3 const& bvhAabbMin_0, btVector3 const& bvhAabbMax_1, btScalar quantizationMargin_2);
  public function extern "getQuantizedNodeArray" QuantizedNodeArray mutable& getQuantizedNodeArray();
  public function extern "refitPartial" void refitPartial(rptr{btStridingMeshInterface} triangles_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2);
  public function extern "buildInternal" void buildInternal();
  public function extern "build" void build(rptr{btStridingMeshInterface} triangles_0, bool useQuantizedAabbCompression_1, btVector3 const& bvhAabbMin_2, btVector3 const& bvhAabbMax_3);
  public function extern "setTraversalMode" void setTraversalMode(btTraversalMode traversalMode_0);
  public function extern "getLeafNodeArray" QuantizedNodeArray mutable& getLeafNodeArray();
  public function extern "getSubtreeInfoArray" BvhSubtreeInfoArray mutable& getSubtreeInfoArray();
  public function extern "reportBoxCastOverlappingNodex" void reportBoxCastOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4) const;
  public function extern "deSerializeDouble" void deSerializeDouble(btQuantizedBvhDoubleData mutable& quantizedBvhDoubleData_0);
  public function extern "unQuantize" btVector3 unQuantize(crptr{ushort} vecIn_0) const;
  public function extern "reportAabbOverlappingNodex" void reportAabbOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "calculateSerializeBufferSize" uint calculateSerializeBufferSize() const;
  public function extern "deSerializeFloat" void deSerializeFloat(btQuantizedBvhFloatData mutable& quantizedBvhFloatData_0);
  public function extern "quantizeWithClamp" void quantizeWithClamp(rptr{ushort} out_0, btVector3 const& point2_1, int isMax_2) const;
  public function extern "reportRayOverlappingNodex" void reportRayOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2) const;
  public function extern "refit" void refit(rptr{btStridingMeshInterface} triangles_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2);
  public function extern "serialize" crptr{char} serialize2(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serialize" bool serialize3(rptr{void} o_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2) const;
  public function extern "updateBvhNodes" void updateBvhNodes(rptr{btStridingMeshInterface} meshInterface_0, int firstNode_1, int endNode_2, int index_3);
}
public threaded struct extern "::btOptimizedBvhNode" btOptimizedBvhNode {
  public btVector3 m_aabbMaxOrg;
  public int m_subPart;
  public int m_triangleIndex;
  public rawarray{char, 20} m_padding;
  public int m_escapeIndex;
  public btVector3 m_aabbMinOrg;
}
public threaded struct extern "::btOptimizedBvhNodeDoubleData" btOptimizedBvhNodeDoubleData {
  public int m_escapeIndex;
  public btVector3DoubleData m_aabbMinOrg;
  public rawarray{char, 4} m_pad;
  public btVector3DoubleData m_aabbMaxOrg;
  public int m_triangleIndex;
  public int m_subPart;
}
public threaded struct extern "::btOptimizedBvhNodeFloatData" btOptimizedBvhNodeFloatData {
  public int m_escapeIndex;
  public btVector3FloatData m_aabbMinOrg;
  public rawarray{char, 4} m_pad;
  public btVector3FloatData m_aabbMaxOrg;
  public int m_subPart;
  public int m_triangleIndex;
}
public threaded struct extern "::btOverlapCallback" "nonmovable" btOverlapCallback {
  public function extern "processOverlap" bool processOverlap(btBroadphasePair mutable& pair_0);
}
public threaded struct extern "::btOverlapFilterCallback" "nonmovable" btOverlapFilterCallback {
  public function extern "needBroadphaseCollision" bool needBroadphaseCollision(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1) const;
}
public threaded struct extern "::btOverlappingPairCache" "nonmovable" btOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCallback};
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback_0);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0_0, rptr{btDispatcher} dispatcher_1);
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback_0);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher_1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair_0, rptr{btDispatcher} dispatcher_1);
}
public threaded struct extern "::btOverlappingPairCallback" "nonmovable" btOverlappingPairCallback {
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0_0, rptr{btDispatcher} dispatcher_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
}
public threaded struct extern "::btPairCachingGhostObject" "nonmovable" btPairCachingGhostObject {
  public metafunction __base__ {btCollisionObject, btGhostObject};
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& convexFromWorld_1, btTransform const& convexToWorld_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getOverlappingPairs" btAlignedObjectArray_btCollisionObject_p const cgetOverlappingPairs() const;
  public function extern "getOverlappingPairs" btAlignedObjectArray_btCollisionObject_p mutable& getOverlappingPairs();
  public function extern "isActive" bool isActive() const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "getOverlappingPairCache" rptr{btHashedOverlappingPairCache} getOverlappingPairCache();
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "getNumOverlappingObjects" int getNumOverlappingObjects() const;
  public function extern "activate" void activate(bool forceActivation_0) const;
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "removeOverlappingObjectInternal" void removeOverlappingObjectInternal(rptr{btBroadphaseProxy} otherProxy_0, rptr{btDispatcher} dispatcher_1, rptr{btBroadphaseProxy} thisProxy_2);
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "addOverlappingObjectInternal" void addOverlappingObjectInternal(rptr{btBroadphaseProxy} otherProxy_0, rptr{btBroadphaseProxy} thisProxy_1);
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "getInternalType" int getInternalType() const;
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "getOverlappingObject" rptr{btCollisionObject} getOverlappingObject(int index_0);
  public function extern "getOverlappingObject" crptr{btCollisionObject} cgetOverlappingObject(int index_0) const;
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "getFriction" btScalar getFriction() const;
}
public threaded struct extern "::btPairSet" btPairSet {
  public metafunction __base__ {btAlignedObjectArray_GIM_PAIR};
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_GIM_PAIR const& otherArray_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "capacity" int capacity() const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "clear" void clear();
  public function extern "push_pair_inv" void push_pair_inv(int index1_0, int index2_1);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "push_pair" void push_pair(int index1_0, int index2_1);
  public function extern "swap" void swap(int index0_0, int index1_1);
  public function extern "pop_back" void pop_back();
  public function extern "size" int size() const;
}
public threaded struct extern "::btPersistentManifold" btPersistentManifold {
  public metafunction __base__ {btTypedObject};
  public function extern "addManifoldPoint" int addManifoldPoint(btManifoldPoint const& newPoint_0, bool isPredictive_1);
  public function extern "replaceContactPoint" void replaceContactPoint(btManifoldPoint const& newPoint_0, int insertIndex_1);
  public function extern "setContactBreakingThreshold" void setContactBreakingThreshold(btScalar contactBreakingThreshold_0);
  public function extern "clearManifold" void clearManifold();
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "refreshContactPoints" void refreshContactPoints(btTransform const& trA_0, btTransform const& trB_1);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "removeContactPoint" void removeContactPoint(int index_0);
  public function extern "validContactDistance" bool validContactDistance(btManifoldPoint const& pt_0) const;
  public function extern "getCacheEntry" int getCacheEntry(btManifoldPoint const& newPoint_0) const;
  public function extern "clearUserCache" void clearUserCache(btManifoldPoint mutable& pt_0);
  public function extern "setNumContacts" void setNumContacts(int cachedPoints_0);
  public function extern "getContactPoint" btManifoldPoint const& cgetContactPoint(int index_0) const;
  public function extern "getContactPoint" btManifoldPoint mutable& getContactPoint(int index_0);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold() const;
  public function extern "getBody0" crptr{btCollisionObject} getBody0() const;
  public function extern "getBody1" crptr{btCollisionObject} getBody1() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getNumContacts" int getNumContacts() const;
  public function extern "setBodies" void setBodies(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
  public int m_objectType;
  public int m_companionIdB;
  public int m_index1a;
  public int m_companionIdA;
}
public threaded struct extern "::btPoint2PointConstraint" "nodefault" btPoint2PointConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint};
  public function extern "setPivotB" void setPivotB(btVector3 const& pivotB_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& body0_trans_1, btTransform const& body1_trans_2);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getPivotInA" btVector3 const& getPivotInA() const;
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getPivotInB" btVector3 const& getPivotInB() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "getUid" int getUid() const;
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "setPivotA" void setPivotA(btVector3 const& pivotA_0);
  public int m_objectType;
  public bool m_useSolveConstraintObsolete;
  public btConstraintSetting m_setting;
}
public threaded struct extern "::btPoint2PointConstraintDoubleData" btPoint2PointConstraintDoubleData {
  public btVector3DoubleData m_pivotInB;
  public btTypedConstraintData m_typeConstraintData;
  public btVector3DoubleData m_pivotInA;
}
public threaded struct extern "::btPoint2PointConstraintDoubleData2" btPoint2PointConstraintDoubleData2 {
  public btVector3DoubleData m_pivotInA;
  public btVector3DoubleData m_pivotInB;
  public btTypedConstraintDoubleData m_typeConstraintData;
}
public threaded struct extern "::btPoint2PointConstraintFloatData" btPoint2PointConstraintFloatData {
  public btVector3FloatData m_pivotInA;
  public btTypedConstraintData m_typeConstraintData;
  public btVector3FloatData m_pivotInB;
}
public tsvaluetype struct extern "::btPoint2PointFlags" "extenum" btPoint2PointFlags { }
public extern "BT_P2P_FLAGS_ERP" btPoint2PointFlags BT_P2P_FLAGS_ERP;
public extern "BT_P2P_FLAGS_CFM" btPoint2PointFlags BT_P2P_FLAGS_CFM;
public threaded struct extern "::btPointCollector" "nonmovable" btPointCollector {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld_0, btVector3 const& pointInWorld_1, btScalar depth_2);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1_0, int index1_1);
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0_0, int index0_1);
  public btVector3 m_normalOnBInWorld;
  public btScalar m_distance;
  public btVector3 m_pointInWorld;
  public bool m_hasResult;
}
public threaded struct extern "::btPointerUid" btPointerUid {
}
/* skip btPointerUid_29 : unnamed */
public threaded struct extern "::btPolarDecomposition" "nodefault" btPolarDecomposition(btScalar tolerance_0, uint maxIterations_1)  {
  public function extern "maxIterations" uint maxIterations() const;
  public function extern "decompose" uint decompose(btMatrix3x3 const& a_0, btMatrix3x3 mutable& u_1, btMatrix3x3 mutable& h_2) const;
}
public threaded struct extern "::btPolyhedralContactClipping" btPolyhedralContactClipping {
}
public threaded struct extern "::btPolyhedralConvexAabbCachingShape" "nonmovable" btPolyhedralConvexAabbCachingShape {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btPolyhedralConvexShape, btCollisionShape};
  public function extern "isCompound" bool isCompound() const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
}
public threaded struct extern "::btPolyhedralConvexShape" "nonmovable" btPolyhedralConvexShape {
  public metafunction __base__ {btConvexShape, btConvexInternalShape, btCollisionShape};
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
}
public threaded struct extern "::btPoolAllocator" "nodefault" btPoolAllocator(int elemSize_0, int maxElements_1)  {
  public function extern "getUsedCount" int getUsedCount() const;
  public function extern "validPtr" bool validPtr(rptr{void} ptr_0);
  public function extern "getFreeCount" int getFreeCount() const;
  public function extern "getMaxCount" int getMaxCount() const;
  public function extern "allocate" rptr{void} allocate(int size_0);
  public function extern "getElementSize" int getElementSize() const;
  public function extern "getPoolAddress" rptr{uchar} getPoolAddress();
  public function extern "getPoolAddress" crptr{uchar} cgetPoolAddress() const;
  public function extern "freeMemory" void freeMemory(rptr{void} ptr_0);
}
public threaded struct extern "::btPositionAndRadius" btPositionAndRadius {
  public btVector3FloatData m_pos;
  public float m_radius;
}
public threaded struct extern "::btPrimitiveManagerBase" "nonmovable" btPrimitiveManagerBase {
  public function extern "get_primitive_triangle" void get_primitive_triangle(int prim_index_0, btPrimitiveTriangle mutable& triangle_1) const;
  public function extern "is_trimesh" bool is_trimesh() const;
  public function extern "get_primitive_box" void get_primitive_box(int prim_index_0, btAABB mutable& primbox_1) const;
  public function extern "get_primitive_count" int get_primitive_count() const;
}
public threaded struct extern "::btPrimitiveTriangle" btPrimitiveTriangle {
  public function extern "get_edge_plane" void get_edge_plane(int edge_index_0, btVector4 mutable& plane_1) const;
  public function extern "applyTransform" void applyTransform(btTransform const& t_0);
  public function extern "buildTriPlane" void buildTriPlane();
  public function extern "clip_triangle" int clip_triangle(btPrimitiveTriangle mutable& other_0, rptr{btVector3} clipped_points_1);
  public function extern "overlap_test_conservative" bool overlap_test_conservative(btPrimitiveTriangle const& other_0);
  public btScalar m_dummy;
  public btScalar m_margin;
  public btVector4 m_plane;
  public rawarray{btVector3, 3} m_vertices;
}
public threaded struct extern "::btQuadWord" btQuadWord {
  public function extern "setW" void setW(btScalar _w_0);
  public function extern "setMin" void setMin(btQuadWord const& other_0);
  public function extern "y" btScalar const& y() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "setX" void setX(btScalar _x_0);
  public function extern "x" btScalar const& x() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "setZ" void setZ(btScalar _z_0);
  public function extern "setY" void setY(btScalar _y_0);
  public function extern "setMax" void setMax(btQuadWord const& other_0);
  public function extern "setValue" void setValue3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
  public function extern "setValue" void setValue4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
  public function extern "getX" btScalar const& getX() const;
  public function extern "w" btScalar const& w() const;
  public function extern "z" btScalar const& z() const;
}
public threaded struct extern "::btQuantizedBvh" "nonmovable" btQuantizedBvh {
  public function extern "getLeafNodeArray" QuantizedNodeArray mutable& getLeafNodeArray();
  public function extern "setTraversalMode" void setTraversalMode(btTraversalMode traversalMode_0);
  public function extern "getQuantizedNodeArray" QuantizedNodeArray mutable& getQuantizedNodeArray();
  public function extern "buildInternal" void buildInternal();
  public function extern "isQuantized" bool isQuantized();
  public function extern "setQuantizationValues" void setQuantizationValues(btVector3 const& bvhAabbMin_0, btVector3 const& bvhAabbMax_1, btScalar quantizationMargin_2);
  public function extern "calculateSerializeBufferSizeNew" int calculateSerializeBufferSizeNew() const;
  public function extern "quantize" void quantize(rptr{ushort} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "serialize" crptr{char} serialize2(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serialize" bool serialize3(rptr{void} o_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2) const;
  public function extern "quantizeWithClamp" void quantizeWithClamp(rptr{ushort} out_0, btVector3 const& point2_1, int isMax_2) const;
  public function extern "reportRayOverlappingNodex" void reportRayOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2) const;
  public function extern "deSerializeDouble" void deSerializeDouble(btQuantizedBvhDoubleData mutable& quantizedBvhDoubleData_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btQuantizedBvhFloatData mutable& quantizedBvhFloatData_0);
  public function extern "calculateSerializeBufferSize" uint calculateSerializeBufferSize() const;
  public function extern "reportAabbOverlappingNodex" void reportAabbOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "unQuantize" btVector3 unQuantize(crptr{ushort} vecIn_0) const;
  public function extern "reportBoxCastOverlappingNodex" void reportBoxCastOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4) const;
  public function extern "getSubtreeInfoArray" BvhSubtreeInfoArray mutable& getSubtreeInfoArray();
}
public threaded struct extern "::btQuantizedBvhDoubleData" btQuantizedBvhDoubleData {
  public int m_curNodeIndex;
  public rptr{btQuantizedBvhNodeData} m_quantizedContiguousNodesPtr;
  public int m_numSubtreeHeaders;
  public int m_useQuantization;
  public rptr{btOptimizedBvhNodeDoubleData} m_contiguousNodesPtr;
  public rptr{btBvhSubtreeInfoData} m_subTreeInfoPtr;
  public int m_numContiguousLeafNodes;
  public btVector3DoubleData m_bvhAabbMin;
  public int m_numQuantizedContiguousNodes;
  public btVector3DoubleData m_bvhAabbMax;
  public btVector3DoubleData m_bvhQuantization;
  public int m_traversalMode;
}
public threaded struct extern "::btQuantizedBvhFloatData" btQuantizedBvhFloatData {
  public btVector3FloatData m_bvhQuantization;
  public int m_traversalMode;
  public btVector3FloatData m_bvhAabbMax;
  public int m_numQuantizedContiguousNodes;
  public btVector3FloatData m_bvhAabbMin;
  public int m_numContiguousLeafNodes;
  public rptr{btOptimizedBvhNodeFloatData} m_contiguousNodesPtr;
  public rptr{btBvhSubtreeInfoData} m_subTreeInfoPtr;
  public int m_useQuantization;
  public rptr{btQuantizedBvhNodeData} m_quantizedContiguousNodesPtr;
  public int m_numSubtreeHeaders;
  public int m_curNodeIndex;
}
public threaded struct extern "::btQuantizedBvhNode" btQuantizedBvhNode {
  public function extern "getTriangleIndex" int getTriangleIndex() const;
  public function extern "isLeafNode" bool isLeafNode() const;
  public function extern "getPartId" int getPartId() const;
  public function extern "getEscapeIndex" int getEscapeIndex() const;
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public int m_escapeIndexOrTriangleIndex;
  public rawarray{ushort, 3} m_quantizedAabbMax;
}
public threaded struct extern "::btQuantizedBvhNodeData" btQuantizedBvhNodeData {
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public int m_escapeIndexOrTriangleIndex;
  public rawarray{ushort, 3} m_quantizedAabbMax;
}
public threaded struct extern "::btQuantizedBvhTree" btQuantizedBvhTree {
  public function extern "getNodeData" int getNodeData(int nodeindex_0) const;
  public function extern "getLeftNode" int getLeftNode(int nodeindex_0) const;
  public function extern "quantizePoint" void quantizePoint(rptr{ushort} quantizedpoint_0, btVector3 const& point_1) const;
  public function extern "clearNodes" void clearNodes();
  public function extern "setNodeBound" void setNodeBound(int nodeindex_0, btAABB const& bound_1);
  public function extern "getNodeBound" void getNodeBound(int nodeindex_0, btAABB mutable& bound_1) const;
  public function extern "getNodeCount" int getNodeCount() const;
  public function extern "getEscapeNodeIndex" int getEscapeNodeIndex(int nodeindex_0) const;
  public function extern "isLeafNode" bool isLeafNode(int nodeindex_0) const;
  public function extern "testQuantizedBoxOverlapp" bool testQuantizedBoxOverlapp(int node_index_0, rptr{ushort} quantizedMin_1, rptr{ushort} quantizedMax_2) const;
  public function extern "getRightNode" int getRightNode(int nodeindex_0) const;
}
public threaded struct extern "::btQuaternion" btQuaternion {
  public metafunction __base__ {btQuadWord};
  public function extern "setEulerZYX" void setEulerZYX(btScalar const& yaw_0, btScalar const& pitch_1, btScalar const& roll_2);
  public function extern "setMax" void setMax(btQuadWord const& other_0);
  public function extern "setValue" void setValue3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
  public function extern "setValue" void setValue4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
  public function extern "setEuler" void setEuler(btScalar const& yaw_0, btScalar const& pitch_1, btScalar const& roll_2);
  public function extern "slerp" btQuaternion slerp(btQuaternion const& q_0, btScalar const& t_1) const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "setRotation" void setRotation(btVector3 const& axis_0, btScalar const& _angle_1);
  public function extern "normalized" btQuaternion normalized() const;
  public function extern "getAngle" btScalar getAngle() const;
  public function extern "length" btScalar length() const;
  public function extern "z" btScalar const& z() const;
  public function extern "getAxis" btVector3 getAxis() const;
  public function extern "w" btScalar const& w() const;
  public function extern "x" btScalar const& x() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "setZ" void setZ(btScalar _z_0);
  public function extern "setY" void setY(btScalar _y_0);
  public function extern "angleShortestPath" btScalar angleShortestPath(btQuaternion const& q_0) const;
  public function extern "setMin" void setMin(btQuadWord const& other_0);
  public function extern "y" btScalar const& y() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "normalize" btQuaternion mutable& normalize();
  public function extern "length2" btScalar length2() const;
  public function extern "farthest" btQuaternion farthest(btQuaternion const& qd_0) const;
  public function extern "nearest" btQuaternion nearest(btQuaternion const& qd_0) const;
  public function extern "inverse" btQuaternion inverse() const;
  public function extern "setX" void setX(btScalar _x_0);
  public function extern "angle" btScalar angle(btQuaternion const& q_0) const;
  public function extern "setW" void setW(btScalar _w_0);
  public function extern "getAngleShortestPath" btScalar getAngleShortestPath() const;
  public function extern "getW" btScalar const& getW() const;
  public function extern "dot" btScalar dot(btQuaternion const& q_0) const;
}
public threaded struct extern "::btRaycastVehicle" "nodefault" btRaycastVehicle(btRaycastVehicle_btVehicleTuning const& tuning_0, rptr{btRigidBody} chassis_1, rptr{btVehicleRaycaster} raycaster_2)  {
  public metafunction __base__ {btActionInterface};
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getRigidBody" rptr{btRigidBody} getRigidBody();
  public function extern "getRigidBody" crptr{btRigidBody} cgetRigidBody() const;
  public function extern "getChassisWorldTransform" btTransform const& getChassisWorldTransform() const;
  public function extern "rayCast" btScalar rayCast(btWheelInfo mutable& wheel_0);
  public function extern "addWheel" btWheelInfo mutable& addWheel(btVector3 const& connectionPointCS0_0, btVector3 const& wheelDirectionCS0_1, btVector3 const& wheelAxleCS_2, btScalar suspensionRestLength_3, btScalar wheelRadius_4, btRaycastVehicle_btVehicleTuning const& tuning_5, bool isFrontWheel_6);
  public function extern "getWheelInfo" btWheelInfo const& cgetWheelInfo(int index_0) const;
  public function extern "getWheelInfo" btWheelInfo mutable& getWheelInfo(int index_0);
  public function extern "updateFriction" void updateFriction(btScalar timeStep_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "getForwardAxis" int getForwardAxis() const;
  public function extern "setBrake" void setBrake(btScalar brake_0, int wheelIndex_1);
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getForwardVector" btVector3 getForwardVector() const;
  public function extern "updateWheelTransform" void updateWheelTransform(int wheelIndex_0, bool interpolatedTransform_1);
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "updateWheelTransformsWS" void updateWheelTransformsWS(btWheelInfo mutable& wheel_0, bool interpolatedTransform_1);
  public function extern "getSteeringValue" btScalar getSteeringValue(int wheel_0) const;
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setSteeringValue" void setSteeringValue(btScalar steering_0, int wheel_1);
  public function extern "getCurrentSpeedKmHour" btScalar getCurrentSpeedKmHour() const;
  public function extern "getWheelTransformWS" btTransform const& getWheelTransformWS(int wheelIndex_0) const;
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "applyEngineForce" void applyEngineForce(btScalar force_0, int wheel_1);
  public function extern "setPitchControl" void setPitchControl(btScalar pitch_0);
  public function extern "getNumWheels" int getNumWheels() const;
  public function extern "resetSuspension" void resetSuspension();
  public function extern "updateVehicle" void updateVehicle(btScalar step_0);
  public function extern "updateSuspension" void updateSuspension(btScalar deltaTime_0);
  public function extern "getRightAxis" int getRightAxis() const;
  public function extern "setCoordinateSystem" void setCoordinateSystem(int rightIndex_0, int upIndex_1, int forwardIndex_2);
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld_0, btScalar step_1);
  public btAlignedObjectArray_btWheelInfo m_wheelInfo;
}
public threaded struct extern "::btRaycastVehicle::btVehicleTuning" btRaycastVehicle_btVehicleTuning {
  public btScalar m_suspensionDamping;
  public btScalar m_frictionSlip;
  public btScalar m_suspensionStiffness;
  public btScalar m_suspensionCompression;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_maxSuspensionForce;
}
public threaded struct extern "::btRigidBody" "nodefault" btRigidBody(btRigidBody_btRigidBodyConstructionInfo const& constructionInfo_0)  {
  public metafunction __base__ {btCollisionObject};
  public function extern "getActivationState" int getActivationState() const;
  public function extern "applyCentralImpulse" void applyCentralImpulse(btVector3 const& impulse_0);
  public function extern "addConstraintRef" void addConstraintRef(rptr{btTypedConstraint} c_0);
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "setFlags" void setFlags(int flags_0);
  public function extern "getOrientation" btQuaternion getOrientation() const;
  public function extern "getLinearDamping" btScalar getLinearDamping() const;
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "isActive" bool isActive() const;
  public function extern "applyDamping" void applyDamping(btScalar timeStep_0);
  public function extern "saveKinematicState" void saveKinematicState(btScalar step_0);
  public function extern "setAngularVelocity" void setAngularVelocity(btVector3 const& ang_vel_0);
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "wantsSleeping" bool wantsSleeping();
  public function extern "proceedToTransform" void proceedToTransform(btTransform const& newTrans_0);
  public function extern "getAngularDamping" btScalar getAngularDamping() const;
  public function extern "setInvInertiaDiagLocal" void setInvInertiaDiagLocal(btVector3 const& diagInvInertia_0);
  public function extern "computeGyroscopicForce" btVector3 computeGyroscopicForce(btScalar maxGyroscopicForce_0) const;
  public function extern "getInvInertiaDiagLocal" btVector3 const& getInvInertiaDiagLocal() const;
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "getInvMass" btScalar getInvMass() const;
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "getLinearFactor" btVector3 const& getLinearFactor() const;
  public function extern "getLinearVelocity" btVector3 const& getLinearVelocity() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "setDamping" void setDamping(btScalar lin_damping_0, btScalar ang_damping_1);
  public function extern "getBroadphaseProxy" rptr{btBroadphaseProxy} getBroadphaseProxy();
  public function extern "getBroadphaseProxy" crptr{btBroadphaseProxy} cgetBroadphaseProxy() const;
  public function extern "clearForces" void clearForces();
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "setCenterOfMassTransform" void setCenterOfMassTransform(btTransform const& xform_0);
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "getFlags" int getFlags() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "applyForce" void applyForce(btVector3 const& force_0, btVector3 const& rel_pos_1);
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public function extern "setMassProps" void setMassProps(btScalar mass_0, btVector3 const& inertia_1);
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getAabb" void getAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getCenterOfMassPosition" btVector3 const& getCenterOfMassPosition() const;
  public function extern "predictIntegratedTransform" void predictIntegratedTransform(btScalar step_0, btTransform mutable& predictedTransform_1);
  public function extern "updateDeactivation" void updateDeactivation(btScalar timeStep_0);
  public function extern "getLinearSleepingThreshold" btScalar getLinearSleepingThreshold() const;
  public function extern "setAngularFactor" void setAngularFactor_btVector3(btVector3 const& angFac_0);
  public function extern "setAngularFactor" void setAngularFactor_btScalar(btScalar angFac_0);
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "getAngularSleepingThreshold" btScalar getAngularSleepingThreshold() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "applyTorqueImpulse" void applyTorqueImpulse(btVector3 const& torque_0);
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "computeImpulseDenominator" btScalar computeImpulseDenominator(btVector3 const& pos_0, btVector3 const& normal_1) const;
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "getCenterOfMassTransform" btTransform const& getCenterOfMassTransform() const;
  public function extern "setLinearVelocity" void setLinearVelocity(btVector3 const& lin_vel_0);
  public function extern "getNumConstraintRefs" int getNumConstraintRefs() const;
  public function extern "checkCollideWithOverride" bool checkCollideWithOverride(crptr{btCollisionObject} co_0) const;
  public function extern "getVelocityInLocalPoint" btVector3 getVelocityInLocalPoint(btVector3 const& rel_pos_0) const;
  public function extern "setLinearFactor" void setLinearFactor(btVector3 const& linearFactor_0);
  public function extern "getTotalTorque" btVector3 const& getTotalTorque() const;
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "getGravity" btVector3 const& getGravity() const;
  public function extern "getInvInertiaTensorWorld" btMatrix3x3 const& getInvInertiaTensorWorld() const;
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "isInWorld" bool isInWorld() const;
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "applyGravity" void applyGravity();
  public function extern "getInternalType" int getInternalType() const;
  public function extern "setMotionState" void setMotionState(rptr{btMotionState} motionState_0);
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "integrateVelocities" void integrateVelocities(btScalar step_0);
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "getConstraintRef" rptr{btTypedConstraint} getConstraintRef(int index_0);
  public function extern "setGravity" void setGravity(btVector3 const& acceleration_0);
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "computeAngularImpulseDenominator" btScalar computeAngularImpulseDenominator(btVector3 const& axis_0) const;
  public function extern "getAngularFactor" btVector3 const& getAngularFactor() const;
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "setSleepingThresholds" void setSleepingThresholds(btScalar linear_0, btScalar angular_1);
  public function extern "translate" void translate(btVector3 const& v_0);
  public function extern "getMotionState" crptr{btMotionState} cgetMotionState() const;
  public function extern "getMotionState" rptr{btMotionState} getMotionState();
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setNewBroadphaseProxy" void setNewBroadphaseProxy(rptr{btBroadphaseProxy} broadphaseProxy_0);
  public function extern "applyTorque" void applyTorque(btVector3 const& torque_0);
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getTotalForce" btVector3 const& getTotalForce() const;
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "getAngularVelocity" btVector3 const& getAngularVelocity() const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "removeConstraintRef" void removeConstraintRef(rptr{btTypedConstraint} c_0);
  public function extern "updateInertiaTensor" void updateInertiaTensor();
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "applyImpulse" void applyImpulse(btVector3 const& impulse_0, btVector3 const& rel_pos_1);
  public function extern "applyCentralForce" void applyCentralForce(btVector3 const& force_0);
  public function extern "activate" void activate(bool forceActivation_0) const;
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public int m_contactSolverType;
  public int m_frictionSolverType;
}
public threaded struct extern "::btRigidBodyColladaInfo" "nodefault" btRigidBodyColladaInfo private {
}
public threaded struct extern "::btRigidBodyDoubleData" btRigidBodyDoubleData {
  public double m_inverseMass;
  public btVector3DoubleData m_totalForce;
  public btMatrix3x3DoubleData m_invInertiaTensorWorld;
  public btVector3DoubleData m_angularVelocity;
  public int m_additionalDamping;
  public double m_additionalAngularDampingFactor;
  public btVector3DoubleData m_linearFactor;
  public double m_angularDamping;
  public btVector3DoubleData m_linearVelocity;
  public btVector3DoubleData m_invInertiaLocal;
  public double m_additionalAngularDampingThresholdSqr;
  public double m_angularSleepingThreshold;
  public btVector3DoubleData m_gravity_acceleration;
  public double m_linearSleepingThreshold;
  public double m_additionalLinearDampingThresholdSqr;
  public btVector3DoubleData m_totalTorque;
  public btCollisionObjectDoubleData m_collisionObjectData;
  public btVector3DoubleData m_angularFactor;
  public double m_linearDamping;
  public double m_additionalDampingFactor;
  public rawarray{char, 4} m_padding;
  public btVector3DoubleData m_gravity;
}
public tsvaluetype struct extern "::btRigidBodyFlags" "extenum" btRigidBodyFlags { }
public extern "BT_DISABLE_WORLD_GRAVITY" btRigidBodyFlags BT_DISABLE_WORLD_GRAVITY;
public extern "BT_ENABLE_GYROPSCOPIC_FORCE" btRigidBodyFlags BT_ENABLE_GYROPSCOPIC_FORCE;
public threaded struct extern "::btRigidBodyFloatData" btRigidBodyFloatData {
  public float m_linearSleepingThreshold;
  public float m_additionalLinearDampingThresholdSqr;
  public btVector3FloatData m_totalTorque;
  public btVector3FloatData m_angularFactor;
  public btCollisionObjectFloatData m_collisionObjectData;
  public float m_additionalDampingFactor;
  public float m_linearDamping;
  public btVector3FloatData m_gravity;
  public btVector3FloatData m_totalForce;
  public float m_inverseMass;
  public btVector3FloatData m_angularVelocity;
  public btMatrix3x3FloatData m_invInertiaTensorWorld;
  public float m_additionalAngularDampingFactor;
  public int m_additionalDamping;
  public float m_angularDamping;
  public btVector3FloatData m_linearFactor;
  public btVector3FloatData m_linearVelocity;
  public float m_additionalAngularDampingThresholdSqr;
  public btVector3FloatData m_invInertiaLocal;
  public float m_angularSleepingThreshold;
  public btVector3FloatData m_gravity_acceleration;
}
public threaded struct extern "::btRigidBody::btRigidBodyConstructionInfo" "nodefault" btRigidBody_btRigidBodyConstructionInfo(btScalar mass_0, rptr{btMotionState} motionState_1, rptr{btCollisionShape} collisionShape_2, btVector3 const& localInertia_3)  {
  public bool m_additionalDamping;
  public btScalar m_additionalAngularDampingFactor;
  public btTransform m_startWorldTransform;
  public btScalar m_angularDamping;
  public btScalar m_rollingFriction;
  public btScalar m_restitution;
  public btScalar m_mass;
  public btVector3 m_localInertia;
  public rptr{btCollisionShape} m_collisionShape;
  public btScalar m_additionalAngularDampingThresholdSqr;
  public btScalar m_friction;
  public btScalar m_angularSleepingThreshold;
  public rptr{btMotionState} m_motionState;
  public btScalar m_linearSleepingThreshold;
  public btScalar m_additionalLinearDampingThresholdSqr;
  public btScalar m_linearDamping;
  public btScalar m_additionalDampingFactor;
}
public threaded struct extern "::btRotationalLimitMotor" btRotationalLimitMotor {
  public function extern "solveAngularLimits" btScalar solveAngularLimits(btScalar timeStep_0, btVector3 mutable& axis_1, btScalar jacDiagABInv_2, rptr{btRigidBody} body0_3, rptr{btRigidBody} body1_4);
  public function extern "testLimitValue" int testLimitValue(btScalar test_value_0);
  public function extern "isLimited" bool isLimited();
  public function extern "needApplyTorques" bool needApplyTorques();
  public btScalar m_maxLimitForce;
  public btScalar m_maxMotorForce;
  public btScalar m_limitSoftness;
  public btScalar m_currentPosition;
  public btScalar m_hiLimit;
  public btScalar m_accumulatedImpulse;
  public btScalar m_loLimit;
  public btScalar m_stopCFM;
  public int m_currentLimit;
  public btScalar m_targetVelocity;
  public btScalar m_damping;
  public btScalar m_normalCFM;
  public bool m_enableMotor;
  public btScalar m_currentLimitError;
  public btScalar m_bounce;
  public btScalar m_stopERP;
}
public metafunction btSapBroadphaseArray btAlignedObjectArray_btBroadphaseInterface_p;
public metafunction btScalar float;
public threaded struct extern "::btScaledBvhTriangleMeshShape" "nodefault" btScaledBvhTriangleMeshShape(rptr{btBvhTriangleMeshShape} childShape_0, btVector3 const& localScaling_1)  {
  public metafunction __base__ {btCollisionShape, btConcaveShape};
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getChildShape" rptr{btBvhTriangleMeshShape} getChildShape();
  public function extern "getChildShape" crptr{btBvhTriangleMeshShape} cgetChildShape() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
}
public threaded struct extern "::btScaledTriangleMeshShapeData" btScaledTriangleMeshShapeData {
  public btTriangleMeshShapeData m_trimeshShapeData;
  public btVector3FloatData m_localScaling;
}
public threaded struct extern "::btSequentialImpulseConstraintSolver" "nonmovable" btSequentialImpulseConstraintSolver {
  public metafunction __base__ {btConstraintSolver};
  public function extern "getSolverType" btConstraintSolverType getSolverType() const;
  public function extern "btRandInt2" int btRandInt2(int n_0);
  public function extern "btRand2" ulong btRand2();
  public function extern "allSolved" void allSolved(btContactSolverInfo const& _0, rptr{btIDebugDraw} _1);
  public function extern "prepareSolve" void prepareSolve(int _0, int _1);
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies_0, int numBodies_1, rptr{rptr{btPersistentManifold}} manifold_2, int numManifolds_3, rptr{rptr{btTypedConstraint}} constraints_4, int numConstraints_5, btContactSolverInfo const& info_6, rptr{btIDebugDraw} debugDrawer_7, rptr{btDispatcher} dispatcher_8);
  public function extern "setRandSeed" void setRandSeed(ulong seed_0);
  public function extern "reset" void reset();
  public function extern "getRandSeed" ulong getRandSeed() const;
}
public tsvaluetype struct extern "::btSerializationFlags" "extenum" btSerializationFlags { }
public extern "BT_SERIALIZE_NO_BVH" btSerializationFlags BT_SERIALIZE_NO_BVH;
public extern "BT_SERIALIZE_NO_TRIANGLEINFOMAP" btSerializationFlags BT_SERIALIZE_NO_TRIANGLEINFOMAP;
public extern "BT_SERIALIZE_NO_DUPLICATE_ASSERT" btSerializationFlags BT_SERIALIZE_NO_DUPLICATE_ASSERT;
public threaded struct extern "::btSerializer" "nonmovable" btSerializer {
  public function extern "getBufferPointer" crptr{uchar} getBufferPointer() const;
  public function extern "finalizeChunk" void finalizeChunk(rptr{btChunk} chunk_0, crptr{char} structType_1, int chunkCode_2, rptr{void} oldPtr_3);
  public function extern "getCurrentBufferSize" int getCurrentBufferSize() const;
  public function extern "registerNameForPointer" void registerNameForPointer(crptr{void} ptr_0, crptr{char} name_1);
  public function extern "startSerialization" void startSerialization();
  public function extern "finishSerialization" void finishSerialization();
  public function extern "serializeName" void serializeName(crptr{char} ptr_0);
  public function extern "allocate" rptr{btChunk} allocate(size_t size_0, int numElements_1);
  public function extern "getSerializationFlags" int getSerializationFlags() const;
  public function extern "findNameForPointer" crptr{char} findNameForPointer(crptr{void} ptr_0) const;
  public function extern "getUniquePointer" rptr{void} getUniquePointer(rptr{void} oldPtr_0);
  public function extern "findPointer" rptr{void} findPointer(rptr{void} oldPtr_0);
  public function extern "setSerializationFlags" void setSerializationFlags(int flags_0);
}
public threaded struct extern "::btShapeHull" "nodefault" btShapeHull(crptr{btConvexShape} shape_0)  {
  public function extern "numVertices" int numVertices() const;
  public function extern "getVertexPointer" crptr{btVector3} getVertexPointer() const;
  public function extern "getIndexPointer" crptr{uint} getIndexPointer() const;
  public function extern "buildHull" bool buildHull(btScalar margin_0);
  public function extern "numIndices" int numIndices() const;
  public function extern "numTriangles" int numTriangles() const;
}
public metafunction btShapePairCallback rptr{meta::list{bool, crptr{btCollisionShape}, crptr{btCollisionShape}}};
public threaded struct extern "::btShortIntIndexData" btShortIntIndexData {
  public rawarray{char, 2} m_pad;
  public short m_value;
}
public threaded struct extern "::btShortIntIndexTripletData" btShortIntIndexTripletData {
  public rawarray{short, 3} m_values;
  public rawarray{char, 2} m_pad;
}
public threaded struct extern "::btSimpleBroadphase" "nodefault" btSimpleBroadphase(int maxProxies_0, rptr{btOverlappingPairCache} overlappingPairCache_1)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "printStats" void printStats();
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
}
public threaded struct extern "::btSimpleBroadphaseProxy" btSimpleBroadphaseProxy {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "getUid" int getUid() const;
  public function extern "GetNextFree" int GetNextFree() const;
  public function extern "SetNextFree" void SetNextFree(int next_0);
  public short m_collisionFilterMask;
  public rptr{void} m_clientObject;
  public btVector3 m_aabbMax;
  public int m_nextFree;
  public short m_collisionFilterGroup;
  public btVector3 m_aabbMin;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
}
public threaded struct extern "::btSimpleDynamicsWorld" "nodefault" btSimpleDynamicsWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3)  {
  public metafunction __base__ {btDynamicsWorld, btCollisionWorld};
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character_0);
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index_0);
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index_0) const;
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver_0);
  public function extern "clearForces" void clearForces();
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint_0, bool disableCollisionsBetweenLinkedBodies_1);
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "addAction" void addAction(rptr{btActionInterface} action_0);
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep_0, int maxSubSteps_1, btScalar fixedTimeStep_2);
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb_0, rptr{void} worldUserInfo_1, bool isPreTick_2);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body_0);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character_0);
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "updateAabbs" void updateAabbs();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action_0);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "setGravity" void setGravity(btVector3 const& gravity_0);
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body_0);
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body_0, short group_1, short mask_2);
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo_0);
}
public threaded struct extern "::btSimplePair" "nodefault" btSimplePair(int indexA_0, int indexB_1)  {
  public int m_indexA;
  public int m_indexB;
}
public metafunction btSimplePairArray btAlignedObjectArray_btSimplePair;
/* skip btSimplePair_33 : unnamed */
public threaded struct extern "::btSimulationIslandManager" "nonmovable" btSimulationIslandManager {
  public function extern "getUnionFind" btUnionFind mutable& getUnionFind();
  public function extern "storeIslandActivationState" void storeIslandActivationState(rptr{btCollisionWorld} world_0);
  public function extern "findUnions" void findUnions(rptr{btDispatcher} dispatcher_0, rptr{btCollisionWorld} colWorld_1);
  public function extern "initUnionFind" void initUnionFind(int n_0);
  public function extern "buildIslands" void buildIslands(rptr{btDispatcher} dispatcher_0, rptr{btCollisionWorld} colWorld_1);
  public function extern "getSplitIslands" bool getSplitIslands();
  public function extern "buildAndProcessIslands" void buildAndProcessIslands(rptr{btDispatcher} dispatcher_0, rptr{btCollisionWorld} collisionWorld_1, rptr{btSimulationIslandManager_IslandCallback} callback_2);
  public function extern "setSplitIslands" void setSplitIslands(bool doSplitIslands_0);
  public function extern "updateActivationState" void updateActivationState(rptr{btCollisionWorld} colWorld_0, rptr{btDispatcher} dispatcher_1);
}
public threaded struct extern "::btSimulationIslandManager::IslandCallback" "nonmovable" btSimulationIslandManager_IslandCallback {
  public function extern "processIsland" void processIsland(rptr{rptr{btCollisionObject}} bodies_0, int numBodies_1, rptr{rptr{btPersistentManifold}} manifolds_2, int numManifolds_3, int islandId_4);
}
public threaded struct extern "::btSliderConstraint" "nodefault" btSliderConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4)  {
  public metafunction __base__ {btTypedObject, btTypedConstraint};
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getDampingOrthoLin" btScalar getDampingOrthoLin();
  public function extern "setRestitutionOrthoLin" void setRestitutionOrthoLin(btScalar restitutionOrthoLin_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "getDampingDirAng" btScalar getDampingDirAng();
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "setRestitutionDirAng" void setRestitutionDirAng(btScalar restitutionDirAng_0);
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "setRestitutionDirLin" void setRestitutionDirLin(btScalar restitutionDirLin_0);
  public function extern "getMaxLinMotorForce" btScalar getMaxLinMotorForce();
  public function extern "setMaxLinMotorForce" void setMaxLinMotorForce(btScalar maxLinMotorForce_0);
  public function extern "getDampingOrthoAng" btScalar getDampingOrthoAng();
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "getLowerLinLimit" btScalar getLowerLinLimit();
  public function extern "getDampingLimAng" btScalar getDampingLimAng();
  public function extern "getLinDepth" btScalar getLinDepth();
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "setPoweredLinMotor" void setPoweredLinMotor(bool onOff_0);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getRestitutionDirAng" btScalar getRestitutionDirAng();
  public function extern "getRestitutionOrthoAng" btScalar getRestitutionOrthoAng();
  public function extern "getUpperAngLimit" btScalar getUpperAngLimit();
  public function extern "setPoweredAngMotor" void setPoweredAngMotor(bool onOff_0);
  public function extern "getSoftnessDirAng" btScalar getSoftnessDirAng();
  public function extern "getSoftnessLimLin" btScalar getSoftnessLimLin();
  public function extern "getTargetLinMotorVelocity" btScalar getTargetLinMotorVelocity();
  public function extern "setLowerLinLimit" void setLowerLinLimit(btScalar lowerLimit_0);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "getSoftnessLimAng" btScalar getSoftnessLimAng();
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setSoftnessDirAng" void setSoftnessDirAng(btScalar softnessDirAng_0);
  public function extern "getRestitutionDirLin" btScalar getRestitutionDirLin();
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "setDampingDirAng" void setDampingDirAng(btScalar dampingDirAng_0);
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "setDampingLimLin" void setDampingLimLin(btScalar dampingLimLin_0);
  public function extern "setSoftnessOrthoLin" void setSoftnessOrthoLin(btScalar softnessOrthoLin_0);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setRestitutionLimAng" void setRestitutionLimAng(btScalar restitutionLimAng_0);
  public function extern "getMaxAngMotorForce" btScalar getMaxAngMotorForce();
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "testLinLimits" void testLinLimits();
  public function extern "getUid" int getUid() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getSoftnessDirLin" btScalar getSoftnessDirLin();
  public function extern "getLowerAngLimit" btScalar getLowerAngLimit();
  public function extern "setLowerAngLimit" void setLowerAngLimit(btScalar lowerLimit_0);
  public function extern "getSolveLinLimit" bool getSolveLinLimit();
  public function extern "setMaxAngMotorForce" void setMaxAngMotorForce(btScalar maxAngMotorForce_0);
  public function extern "setRestitutionLimLin" void setRestitutionLimLin(btScalar restitutionLimLin_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "setUpperLinLimit" void setUpperLinLimit(btScalar upperLimit_0);
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRestitutionLimAng" btScalar getRestitutionLimAng();
  public function extern "setSoftnessLimLin" void setSoftnessLimLin(btScalar softnessLimLin_0);
  public function extern "getUseLinearReferenceFrameA" bool getUseLinearReferenceFrameA();
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "setDampingOrthoAng" void setDampingOrthoAng(btScalar dampingOrthoAng_0);
  public function extern "setSoftnessLimAng" void setSoftnessLimAng(btScalar softnessLimAng_0);
  public function extern "setDampingDirLin" void setDampingDirLin(btScalar dampingDirLin_0);
  public function extern "getAncorInA" btVector3 getAncorInA();
  public function extern "getAngDepth" btScalar getAngDepth();
  public function extern "getAncorInB" btVector3 getAncorInB();
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btScalar rbAinvMass_5, btScalar rbBinvMass_6);
  public function extern "getLinearPos" btScalar getLinearPos() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "getDampingDirLin" btScalar getDampingDirLin();
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getPoweredAngMotor" bool getPoweredAngMotor();
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "getSolveAngLimit" bool getSolveAngLimit();
  public function extern "calculateTransforms" void calculateTransforms(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "testAngLimits" void testAngLimits();
  public function extern "getAngularPos" btScalar getAngularPos() const;
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setSoftnessOrthoAng" void setSoftnessOrthoAng(btScalar softnessOrthoAng_0);
  public function extern "getTargetAngMotorVelocity" btScalar getTargetAngMotorVelocity();
  public function extern "setSoftnessDirLin" void setSoftnessDirLin(btScalar softnessDirLin_0);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "getRestitutionLimLin" btScalar getRestitutionLimLin();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "setRestitutionOrthoAng" void setRestitutionOrthoAng(btScalar restitutionOrthoAng_0);
  public function extern "setDampingLimAng" void setDampingLimAng(btScalar dampingLimAng_0);
  public function extern "getDampingLimLin" btScalar getDampingLimLin();
  public function extern "getSoftnessOrthoLin" btScalar getSoftnessOrthoLin();
  public function extern "getRestitutionOrthoLin" btScalar getRestitutionOrthoLin();
  public function extern "setDampingOrthoLin" void setDampingOrthoLin(btScalar dampingOrthoLin_0);
  public function extern "setUpperAngLimit" void setUpperAngLimit(btScalar upperLimit_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setTargetAngMotorVelocity" void setTargetAngMotorVelocity(btScalar targetAngMotorVelocity_0);
  public function extern "setTargetLinMotorVelocity" void setTargetLinMotorVelocity(btScalar targetLinMotorVelocity_0);
  public function extern "getPoweredLinMotor" bool getPoweredLinMotor();
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "getUpperLinLimit" btScalar getUpperLinLimit();
  public function extern "getSoftnessOrthoAng" btScalar getSoftnessOrthoAng();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public int m_objectType;
}
public threaded struct extern "::btSliderConstraintData" btSliderConstraintData {
  public float m_linearUpperLimit;
  public float m_angularUpperLimit;
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
  public float m_linearLowerLimit;
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbBFrame;
  public btTransformFloatData m_rbAFrame;
  public float m_angularLowerLimit;
}
public threaded struct extern "::btSliderConstraintDoubleData" btSliderConstraintDoubleData {
  public btTransformDoubleData m_rbAFrame;
  public double m_angularLowerLimit;
  public double m_linearLowerLimit;
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btTransformDoubleData m_rbBFrame;
  public int m_useOffsetForConstraintFrame;
  public double m_linearUpperLimit;
  public double m_angularUpperLimit;
  public int m_useLinearReferenceFrameA;
}
public tsvaluetype struct extern "::btSliderFlags" "extenum" btSliderFlags { }
public extern "BT_SLIDER_FLAGS_CFM_DIRLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_DIRLIN;
public extern "BT_SLIDER_FLAGS_ERP_DIRLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_DIRLIN;
public extern "BT_SLIDER_FLAGS_CFM_DIRANG" btSliderFlags BT_SLIDER_FLAGS_CFM_DIRANG;
public extern "BT_SLIDER_FLAGS_ERP_DIRANG" btSliderFlags BT_SLIDER_FLAGS_ERP_DIRANG;
public extern "BT_SLIDER_FLAGS_CFM_ORTLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_ORTLIN;
public extern "BT_SLIDER_FLAGS_ERP_ORTLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_ORTLIN;
public extern "BT_SLIDER_FLAGS_CFM_ORTANG" btSliderFlags BT_SLIDER_FLAGS_CFM_ORTANG;
public extern "BT_SLIDER_FLAGS_ERP_ORTANG" btSliderFlags BT_SLIDER_FLAGS_ERP_ORTANG;
public extern "BT_SLIDER_FLAGS_CFM_LIMLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_LIMLIN;
public extern "BT_SLIDER_FLAGS_ERP_LIMLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_LIMLIN;
public extern "BT_SLIDER_FLAGS_CFM_LIMANG" btSliderFlags BT_SLIDER_FLAGS_CFM_LIMANG;
public extern "BT_SLIDER_FLAGS_ERP_LIMANG" btSliderFlags BT_SLIDER_FLAGS_ERP_LIMANG;
public threaded struct extern "::btSoftBody" "nodefault" btSoftBody(rptr{btSoftBodyWorldInfo} worldInfo_0, int node_count_1, crptr{btVector3} x_2, crptr{btScalar} m_3)  {
  public metafunction __base__ {btCollisionObject};
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "addAeroForceToNode" void addAeroForceToNode(btVector3 const& windVelocity_0, int nodeIndex_1);
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "cleanupClusters" void cleanupClusters();
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "setVolumeDensity" void setVolumeDensity(btScalar density_0);
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "appendLinearJoint" void appendLinearJoint3(btSoftBody_LJoint_Specs const& specs_0, rptr{btSoftBody_Cluster} body0_1, btSoftBody_Body body1_2);
  public function extern "appendLinearJoint" void appendLinearJoint_btSoftBody_LJoint_Specs_btSoftBody_Body(btSoftBody_LJoint_Specs const& specs_0, btSoftBody_Body body_1);
  public function extern "appendLinearJoint" void appendLinearJoint_btSoftBody_LJoint_Specs_btSoftBody_p(btSoftBody_LJoint_Specs const& specs_0, rptr{btSoftBody} body_1);
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "applyClusters" void applyClusters(bool drift_0);
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "solveConstraints" void solveConstraints();
  public function extern "appendNode" void appendNode(btVector3 const& x_0, btScalar m_1);
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "appendLink" void appendLink_btSoftBody_Node_p_btSoftBody_Node_p_btSoftBody_Material_p_bool(rptr{btSoftBody_Node} node0_0, rptr{btSoftBody_Node} node1_1, rptr{btSoftBody_Material} mat_2, bool bcheckexist_3);
  public function extern "appendLink" void appendLink_int_int_btSoftBody_Material_p_bool(int node0_0, int node1_1, rptr{btSoftBody_Material} mat_2, bool bcheckexist_3);
  public function extern "appendLink" void appendLink2(int model_0, rptr{btSoftBody_Material} mat_1);
  public function extern "activate" void activate(bool forceActivation_0) const;
  public function extern "predictMotion" void predictMotion(btScalar dt_0);
  public function extern "solveClusters" void solveClusters(btScalar sor_0);
  public function extern "getSoftBodySolver" rptr{btSoftBodySolver} getSoftBodySolver();
  public function extern "getSoftBodySolver" rptr{btSoftBodySolver} cgetSoftBodySolver() const;
  public function extern "cutLink" bool cutLink_btSoftBody_Node_cp_btSoftBody_Node_cp_btScalar(crptr{btSoftBody_Node} node0_0, crptr{btSoftBody_Node} node1_1, btScalar position_2);
  public function extern "cutLink" bool cutLink_int_int_btScalar(int node0_0, int node1_1, btScalar position_2);
  public function extern "getWindVelocity" btVector3 const& getWindVelocity();
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "getTotalMass" btScalar getTotalMass() const;
  public function extern "setMass" void setMass(int node_0, btScalar mass_1);
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "checkLink" bool checkLink_int_int(int node0_0, int node1_1) const;
  public function extern "checkLink" bool checkLink_btSoftBody_Node_cp_btSoftBody_Node_cp(crptr{btSoftBody_Node} node0_0, crptr{btSoftBody_Node} node1_1) const;
  public function extern "resetLinkRestLengths" void resetLinkRestLengths();
  public function extern "updateBounds" void updateBounds();
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "addForce" void addForce2(btVector3 const& force_0, int node_1);
  public function extern "addForce" void addForce1(btVector3 const& force_0);
  public function extern "setSoftBodySolver" void setSoftBodySolver(rptr{btSoftBodySolver} softBodySolver_0);
  public function extern "initializeFaceTree" void initializeFaceTree();
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "transform" void transform(btTransform const& trs_0);
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "initDefaults" void initDefaults();
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "clusterCom" btVector3 clusterCom(int cluster_0) const;
  public function extern "getVolume" btScalar getVolume() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "updateConstants" void updateConstants();
  public function extern "generateBendingConstraints" int generateBendingConstraints(int distance_0, rptr{btSoftBody_Material} mat_1);
  public function extern "updateLinkConstants" void updateLinkConstants();
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "checkFace" bool checkFace(int node0_0, int node1_1, int node2_2) const;
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "isActive" bool isActive() const;
  public function extern "indicesToPointers" void indicesToPointers(crptr{int} map_0);
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "appendTetra" void appendTetra2(int model_0, rptr{btSoftBody_Material} mat_1);
  public function extern "appendTetra" void appendTetra5(int node0_0, int node1_1, int node2_2, int node3_3, rptr{btSoftBody_Material} mat_4);
  public function extern "setRestLengthScale" void setRestLengthScale(btScalar restLength_0);
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "setPose" void setPose(bool bvolume_0, bool bframe_1);
  public function extern "staticSolve" void staticSolve(int iterations_0);
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "defaultCollisionHandler" void defaultCollisionHandler_btSoftBody_p(rptr{btSoftBody} psb_0);
  public function extern "defaultCollisionHandler" void defaultCollisionHandler_btCollisionObjectWrapper_cp(crptr{btCollisionObjectWrapper} pcoWrap_0);
  public function extern "rotate" void rotate(btQuaternion const& rot_0);
  public function extern "generateClusters" int generateClusters(int k_0, int maxiterations_1);
  public function extern "getAabb" void getAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "setTotalDensity" void setTotalDensity(btScalar density_0);
  public function extern "scale" void scale(btVector3 const& scl_0);
  public function extern "appendAngularJoint" void appendAngularJoint_btSoftBody_AJoint_Specs_btSoftBody_Body(btSoftBody_AJoint_Specs const& specs_0, btSoftBody_Body body_1);
  public function extern "appendAngularJoint" void appendAngularJoint_btSoftBody_AJoint_Specs_btSoftBody_p(btSoftBody_AJoint_Specs const& specs_0, rptr{btSoftBody} body_1);
  public function extern "appendAngularJoint" void appendAngularJoint3(btSoftBody_AJoint_Specs const& specs_0, rptr{btSoftBody_Cluster} body0_1, btSoftBody_Body body1_2);
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "randomizeConstraints" void randomizeConstraints();
  public function extern "setVelocity" void setVelocity(btVector3 const& velocity_0);
  public function extern "appendNote" void appendNote_char_cp_btVector3_btSoftBody_Link_p(crptr{char} text_0, btVector3 const& o_1, rptr{btSoftBody_Link} feature_2);
  public function extern "appendNote" void appendNote_char_cp_btVector3_btSoftBody_Node_p(crptr{char} text_0, btVector3 const& o_1, rptr{btSoftBody_Node} feature_2);
  public function extern "appendNote" void appendNote_char_cp_btVector3_btSoftBody_Face_p(crptr{char} text_0, btVector3 const& o_1, rptr{btSoftBody_Face} feature_2);
  public function extern "appendNote" void appendNote7(crptr{char} text_0, btVector3 const& o_1, btVector4 const& c_2, rptr{btSoftBody_Node} n0_3, rptr{btSoftBody_Node} n1_4, rptr{btSoftBody_Node} n2_5, rptr{btSoftBody_Node} n3_6);
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "getInternalType" int getInternalType() const;
  public function extern "prepareClusters" void prepareClusters(int iterations_0);
  public function extern "setWindVelocity" void setWindVelocity(btVector3 const& velocity_0);
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "rayTest" bool rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btSoftBody_sRayCast mutable& results_2);
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "appendMaterial" rptr{btSoftBody_Material} appendMaterial();
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "clusterCount" int clusterCount() const;
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "updateClusters" void updateClusters();
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setVolumeMass" void setVolumeMass(btScalar mass_0);
  public function extern "updatePose" void updatePose();
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "dampClusters" void dampClusters();
  public function extern "releaseCluster" void releaseCluster(int index_0);
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "translate" void translate(btVector3 const& trs_0);
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "releaseClusters" void releaseClusters();
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "checkContact" bool checkContact(crptr{btCollisionObjectWrapper} colObjWrap_0, btVector3 const& x_1, btScalar margin_2, btSoftBody_sCti mutable& cti_3) const;
  public function extern "getMass" btScalar getMass(int node_0) const;
  public function extern "addVelocity" void addVelocity1(btVector3 const& velocity_0);
  public function extern "addVelocity" void addVelocity2(btVector3 const& velocity_0, int node_1);
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
  public function extern "refine" void refine(rptr{btSoftBody_ImplicitFn} ifn_0, btScalar accurary_1, bool cut_2);
  public function extern "appendFace" void appendFace4(int node0_0, int node1_1, int node2_2, rptr{btSoftBody_Material} mat_3);
  public function extern "appendFace" void appendFace2(int model_0, rptr{btSoftBody_Material} mat_1);
  public function extern "appendAnchor" void appendAnchor4(int node_0, rptr{btRigidBody} body_1, bool disableCollisionBetweenLinkedBodies_2, btScalar influence_3);
  public function extern "appendAnchor" void appendAnchor5(int node_0, rptr{btRigidBody} body_1, btVector3 const& localPivot_2, bool disableCollisionBetweenLinkedBodies_3, btScalar influence_4);
  public function extern "initializeClusters" void initializeClusters();
  public function extern "pointersToIndices" void pointersToIndices();
  public function extern "setTotalMass" void setTotalMass(btScalar mass_0, bool fromfaces_1);
  public function extern "applyForces" void applyForces();
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "updateArea" void updateArea(bool averageArea_0);
  public function extern "getRestLengthScale" btScalar getRestLengthScale();
  public function extern "integrateMotion" void integrateMotion();
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "getWorldInfo" rptr{btSoftBodyWorldInfo} getWorldInfo();
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "updateNormals" void updateNormals();
  public function extern "evaluateCom" btVector3 evaluateCom() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "addAeroForceToFace" void addAeroForceToFace(btVector3 const& windVelocity_0, int faceIndex_1);
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public btDbvt m_ndbvt;
  public btAlignedObjectArray_btSoftBody_Link m_links;
  public btAlignedObjectArray_btSoftBody_Tetra m_tetras;
  public btAlignedObjectArray_btSoftBody_Note m_notes;
  public btAlignedObjectArray_btSoftBody_Joint_p m_joints;
  public btDbvt m_cdbvt;
  public bool m_bUpdateRtCst;
  public btTransform m_initialWorldTransform;
  public rawarray{btVector3, 2} m_bounds;
  public btAlignedObjectArray_btSoftBody_Face m_faces;
  public btSoftBody_Config m_cfg;
  public btAlignedObjectArray_int m_userIndexMapping;
  public btVector3 m_windVelocity;
  public btAlignedObjectArray_btSoftBody_SContact m_scontacts;
  public rptr{btSoftBodySolver} m_softBodySolver;
  public btAlignedObjectArray_btSoftBody_Material_p m_materials;
  public btScalar m_timeacc;
  public btAlignedObjectArray_btSoftBody_Node m_nodes;
  public btAlignedObjectArray_btSoftBody_RContact m_rcontacts;
  public rptr{btSoftBodyWorldInfo} m_worldInfo;
  public btAlignedObjectArray_bool m_clusterConnectivity;
  public btAlignedObjectArray_btSoftBody_Cluster_p m_clusters;
  public btDbvt m_fdbvt;
  public btSoftBody_Pose m_pose;
  public btScalar m_restLengthScale;
  public btAlignedObjectArray_btCollisionObject_const_p m_collisionDisabledObjects;
  public rptr{void} m_tag;
  public btAlignedObjectArray_btSoftBody_Anchor m_anchors;
  public btSoftBody_SolverState m_sst;
}
public metafunction btSoftBodyArray btAlignedObjectArray_btSoftBody_p;
public threaded struct extern "::btSoftBodyCollisionShape" "nodefault" btSoftBodyCollisionShape(rptr{btSoftBody} backptr_0)  {
  public metafunction __base__ {btCollisionShape, btConcaveShape};
  public function extern "getShapeType" int getShapeType() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar _0, btVector3 mutable& _1) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& _0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} _0, btVector3 const& _1, btVector3 const& _2) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public rptr{btSoftBody} m_body;
}
public threaded struct extern "::btSoftBodyConcaveCollisionAlgorithm" "nodefault" btSoftBodyConcaveCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "clearCache" void clearCache();
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btSoftBodyConcaveCollisionAlgorithm::CreateFunc" "nonmovable" btSoftBodyConcaveCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btSoftBodyConcaveCollisionAlgorithm::SwappedCreateFunc" "nonmovable" btSoftBodyConcaveCollisionAlgorithm_SwappedCreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btSoftBodyFloatData" btSoftBodyFloatData {
  public int m_numClusters;
  public int m_numMaterials;
  public int m_numFaces;
  public rptr{btSoftBodyJointData} m_joints;
  public btCollisionObjectFloatData m_collisionObjectData;
  public int m_numJoints;
  public int m_numTetrahedra;
  public int m_numNodes;
  public int m_numLinks;
  public int m_numAnchors;
}
public threaded struct extern "::btSoftBodyHelpers" btSoftBodyHelpers {
}
public threaded struct extern "::btSoftBodyJointData" btSoftBodyJointData {
  public int m_bodyBtype;
  public float m_split;
  public float m_cfm;
  public int m_bodyAtype;
  public float m_erp;
  public rawarray{btVector3FloatData, 2} m_refs;
  public rawarray{btVector3FloatData, 2} m_relPosition;
  public int m_pad;
  public rptr{void} m_bodyA;
  public rptr{void} m_bodyB;
  public int m_jointType;
  public int m_delete;
}
public threaded struct extern "::btSoftBodyLinkData" "nodefault" btSoftBodyLinkData private {
}
public threaded struct extern "::btSoftBodyRigidBodyCollisionConfiguration" "nodefault" btSoftBodyRigidBodyCollisionConfiguration(btDefaultCollisionConstructionInfo const& constructionInfo_0)  {
  public metafunction __base__ {btDefaultCollisionConfiguration, btCollisionConfiguration};
  public function extern "setPlaneConvexMultipointIterations" void setPlaneConvexMultipointIterations(int numPerturbationIterations_0, int minimumPointsPerturbationThreshold_1);
  public function extern "setConvexConvexMultipointIterations" void setConvexConvexMultipointIterations(int numPerturbationIterations_0, int minimumPointsPerturbationThreshold_1);
  public function extern "getSimplexSolver" rptr{btVoronoiSimplexSolver} getSimplexSolver();
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0_0, int proxyType1_1);
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
}
public threaded struct extern "::btSoftBodySolver" "nonmovable" btSoftBodySolver {
  public function extern "updateSoftBodies" void updateSoftBodies();
  public function extern "copyBackToSoftBodies" void copyBackToSoftBodies(bool bMove_0);
  public function extern "checkInitialized" bool checkInitialized();
  public function extern "processCollision" void processCollision_btSoftBody_p_btSoftBody_p(rptr{btSoftBody} _0, rptr{btSoftBody} _1);
  public function extern "processCollision" void processCollision_btSoftBody_p_btCollisionObjectWrapper_cp(rptr{btSoftBody} _0, crptr{btCollisionObjectWrapper} _1);
  public function extern "optimize" void optimize(btAlignedObjectArray_btSoftBody_p mutable& softBodies_0, bool forceUpdate_1);
  public function extern "setNumberOfPositionIterations" void setNumberOfPositionIterations(int iterations_0);
  public function extern "getNumberOfPositionIterations" int getNumberOfPositionIterations();
  public function extern "getTimeScale" float getTimeScale();
  public function extern "getNumberOfVelocityIterations" int getNumberOfVelocityIterations();
  public function extern "solveConstraints" void solveConstraints(float solverdt_0);
  public function extern "predictMotion" void predictMotion(float solverdt_0);
  public function extern "setNumberOfVelocityIterations" void setNumberOfVelocityIterations(int iterations_0);
}
public threaded struct extern "::btSoftBodySolverOutput" "nonmovable" btSoftBodySolverOutput {
  public function extern "copySoftBodyToVertexBuffer" void copySoftBodyToVertexBuffer(crptr{btSoftBody} const softBody_0, rptr{btVertexBufferDescriptor} vertexBuffer_1);
}
public threaded struct extern "::btSoftBodyTriangleCallback" "nodefault" btSoftBodyTriangleCallback(rptr{btDispatcher} dispatcher_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btTriangleCallback};
  public function extern "clearCache" void clearCache();
  public function extern "getAabbMin" btVector3 const& getAabbMin() const;
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
  public function extern "getAabbMax" btVector3 const& getAabbMax() const;
  public function extern "setTimeStepAndCounters" void setTimeStepAndCounters(btScalar collisionMarginTriangle_0, crptr{btCollisionObjectWrapper} triObjWrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public int m_triangleCount;
}
public threaded struct extern "::btSoftBodyTriangleData" "nodefault" btSoftBodyTriangleData private {
}
public threaded struct extern "::btSoftBodyVertexData" "nodefault" btSoftBodyVertexData private {
}
public threaded struct extern "::btSoftBodyWorldInfo" btSoftBodyWorldInfo {
  public btVector3 m_gravity;
  public btScalar water_offset;
  public rptr{btDispatcher} m_dispatcher;
  public btSparseSdf_3 m_sparsesdf;
  public btScalar water_density;
  public btScalar air_density;
  public btScalar m_maxDisplacement;
  public rptr{btBroadphaseInterface} m_broadphase;
  public btVector3 water_normal;
}
public threaded struct extern "::btSoftBody::AJoint" "nonmovable" btSoftBody_AJoint {
  public metafunction __base__ {btSoftBody_Joint};
  public function extern "Terminate" void Terminate(btScalar dt_0);
  public function extern "Solve" void Solve(btScalar dt_0, btScalar sor_1);
  public function extern "Prepare" void Prepare(btScalar dt_0, int iterations_1);
  public bool m_delete;
  public btVector3 m_sdrift;
  public rptr{btSoftBody_AJoint_IControl} m_icontrol;
  public btVector3 m_drift;
  public btMatrix3x3 m_massmatrix;
  public btScalar m_erp;
  public btScalar m_split;
  public btScalar m_cfm;
  public rawarray{btVector3, 2} m_axis;
  public rawarray{btVector3, 2} m_refs;
  public rawarray{btSoftBody_Body, 2} m_bodies;
}
public threaded struct extern "::btSoftBody::AJoint::IControl" "nonmovable" btSoftBody_AJoint_IControl {
  public function extern "Speed" btScalar Speed(rptr{btSoftBody_AJoint} _0, btScalar current_1);
  public function extern "Prepare" void Prepare(rptr{btSoftBody_AJoint} _0);
}
public threaded struct extern "::btSoftBody::AJoint::Specs" btSoftBody_AJoint_Specs {
  public metafunction __base__ {btSoftBody_Joint_Specs};
  public btScalar split;
  public btScalar cfm;
  public rptr{btSoftBody_AJoint_IControl} icontrol;
  public btVector3 axis;
  public btScalar erp;
}
public threaded struct extern "::btSoftBody::Anchor" btSoftBody_Anchor {
  public btScalar m_c2;
  public rptr{btRigidBody} m_body;
  public btVector3 m_local;
  public btVector3 m_c1;
  public rptr{btSoftBody_Node} m_node;
  public btScalar m_influence;
  public btMatrix3x3 m_c0;
}
public threaded struct extern "::btSoftBody::Body" btSoftBody_Body {
  public function extern "invWorldInertia" btMatrix3x3 const& invWorldInertia() const;
  public function extern "linearVelocity" btVector3 linearVelocity() const;
  public function extern "velocity" btVector3 velocity(btVector3 const& rpos_0) const;
  public function extern "angularVelocity" btVector3 angularVelocity0() const;
  public function extern "angularVelocity" btVector3 angularVelocity1(btVector3 const& rpos_0) const;
  public function extern "applyImpulse" void applyImpulse(btSoftBody_Impulse const& impulse_0, btVector3 const& rpos_1) const;
  public function extern "applyVAImpulse" void applyVAImpulse(btVector3 const& impulse_0) const;
  public function extern "xform" btTransform const& xform() const;
  public function extern "applyDAImpulse" void applyDAImpulse(btVector3 const& impulse_0) const;
  public function extern "applyDImpulse" void applyDImpulse(btVector3 const& impulse_0, btVector3 const& rpos_1) const;
  public function extern "applyVImpulse" void applyVImpulse(btVector3 const& impulse_0, btVector3 const& rpos_1) const;
  public function extern "applyAImpulse" void applyAImpulse(btSoftBody_Impulse const& impulse_0) const;
  public function extern "invMass" btScalar invMass() const;
  public function extern "activate" void activate() const;
  public function extern "applyDCImpulse" void applyDCImpulse(btVector3 const& impulse_0) const;
  public crptr{btCollisionObject} m_collisionObject;
  public rptr{btRigidBody} m_rigid;
  public rptr{btSoftBody_Cluster} m_soft;
}
public threaded struct extern "::btSoftBody::CJoint" "nonmovable" btSoftBody_CJoint {
  public metafunction __base__ {btSoftBody_Joint};
  public function extern "Prepare" void Prepare(btScalar dt_0, int iterations_1);
  public function extern "Solve" void Solve(btScalar dt_0, btScalar sor_1);
  public function extern "Terminate" void Terminate(btScalar dt_0);
  public btMatrix3x3 m_massmatrix;
  public btVector3 m_sdrift;
  public bool m_delete;
  public btVector3 m_drift;
  public btVector3 m_normal;
  public rawarray{btSoftBody_Body, 2} m_bodies;
  public rawarray{btVector3, 2} m_refs;
  public btScalar m_split;
  public btScalar m_friction;
  public int m_maxlife;
  public btScalar m_cfm;
  public rawarray{btVector3, 2} m_rpos;
  public btScalar m_erp;
  public int m_life;
}
public threaded struct extern "::btSoftBody::Cluster" btSoftBody_Cluster {
  public btScalar m_selfCollisionImpulseFactor;
  public btMatrix3x3 m_invwi;
  public int m_ndimpulses;
  public btScalar m_maxSelfCollisionImpulse;
  public btAlignedObjectArray_float m_masses;
  public btVector3 m_lv;
  public int m_nvimpulses;
  public btScalar m_matching;
  public bool m_collide;
  public btMatrix3x3 m_locii;
  public btVector3 m_com;
  public btScalar m_idmass;
  public btScalar m_imass;
  public btScalar m_ldamping;
  public btAlignedObjectArray_btVector3 m_framerefs;
  public int m_clusterIndex;
  public bool m_containsAnchor;
  public rawarray{btVector3, 2} m_vimpulses;
  public btVector3 m_av;
  public btScalar m_adamping;
  public btScalar m_ndamping;
  public rptr{btDbvtNode} m_leaf;
  public btAlignedObjectArray_btSoftBody_Node_p m_nodes;
  public rawarray{btVector3, 2} m_dimpulses;
  public btTransform m_framexform;
}
public threaded struct extern "::btSoftBody::Config" btSoftBody_Config {
  public btScalar kSK_SPLT_CL;
  public btScalar kMT;
  public btScalar kSRHR_CL;
  public btScalar kSSHR_CL;
  public btScalar maxvolume;
  public int diterations;
  public btScalar kPR;
  public int citerations;
  public btAlignedObjectArray_btSoftBody_ePSolver_ m_dsequence;
  public btAlignedObjectArray_btSoftBody_ePSolver_ m_psequence;
  public btScalar kSS_SPLT_CL;
  public btScalar kCHR;
  public btScalar kSR_SPLT_CL;
  public btScalar kDF;
  public int piterations;
  public btScalar kSKHR_CL;
  public btScalar kDP;
  public btScalar kDG;
  public btAlignedObjectArray_btSoftBody_eVSolver_ m_vsequence;
  public btScalar kKHR;
  public int viterations;
  public btScalar timescale;
  public int collisions;
  public btScalar kVCF;
  public btScalar kAHR;
  public btScalar kVC;
  public btScalar kSHR;
  public btScalar kLF;
}
public threaded struct extern "::btSoftBody::Element" btSoftBody_Element {
  public rptr{void} m_tag;
}
public threaded struct extern "::btSoftBody::Face" btSoftBody_Face {
  public metafunction __base__ {btSoftBody_Feature, btSoftBody_Element};
  public rawarray{rptr{btSoftBody_Node}, 3} m_n;
  public rptr{void} m_tag;
  public btScalar m_ra;
  public rptr{btDbvtNode} m_leaf;
  public btVector3 m_normal;
  public rptr{btSoftBody_Material} m_material;
}
public threaded struct extern "::btSoftBody::Feature" btSoftBody_Feature {
  public metafunction __base__ {btSoftBody_Element};
  public rptr{void} m_tag;
  public rptr{btSoftBody_Material} m_material;
}
public threaded struct extern "::btSoftBody::ImplicitFn" "nonmovable" btSoftBody_ImplicitFn {
  public function extern "Eval" btScalar Eval(btVector3 const& x_0);
}
public threaded struct extern "::btSoftBody::Impulse" btSoftBody_Impulse {
  public int m_asVelocity;
  public btVector3 m_velocity;
  public int m_asDrift;
  public btVector3 m_drift;
}
public threaded struct extern "::btSoftBody::Joint" "nonmovable" btSoftBody_Joint {
  public function extern "Prepare" void Prepare(btScalar dt_0, int iterations_1);
  public function extern "Terminate" void Terminate(btScalar dt_0);
  public function extern "Solve" void Solve(btScalar dt_0, btScalar sor_1);
  public btMatrix3x3 m_massmatrix;
  public btVector3 m_drift;
  public bool m_delete;
  public btVector3 m_sdrift;
  public rawarray{btSoftBody_Body, 2} m_bodies;
  public rawarray{btVector3, 2} m_refs;
  public btScalar m_cfm;
  public btScalar m_split;
  public btScalar m_erp;
}
public threaded struct extern "::btSoftBody::Joint::Specs" btSoftBody_Joint_Specs {
  public btScalar erp;
  public btScalar cfm;
  public btScalar split;
}
public threaded struct extern "::btSoftBody::Joint::eType" btSoftBody_Joint_eType {
}
public threaded struct extern "::btSoftBody::LJoint" "nonmovable" btSoftBody_LJoint {
  public metafunction __base__ {btSoftBody_Joint};
  public function extern "Prepare" void Prepare(btScalar dt_0, int iterations_1);
  public function extern "Solve" void Solve(btScalar dt_0, btScalar sor_1);
  public function extern "Terminate" void Terminate(btScalar dt_0);
  public btMatrix3x3 m_massmatrix;
  public btVector3 m_sdrift;
  public bool m_delete;
  public btVector3 m_drift;
  public rawarray{btSoftBody_Body, 2} m_bodies;
  public rawarray{btVector3, 2} m_refs;
  public btScalar m_split;
  public btScalar m_cfm;
  public rawarray{btVector3, 2} m_rpos;
  public btScalar m_erp;
}
public threaded struct extern "::btSoftBody::LJoint::Specs" btSoftBody_LJoint_Specs {
  public metafunction __base__ {btSoftBody_Joint_Specs};
  public btScalar erp;
  public btVector3 position;
  public btScalar cfm;
  public btScalar split;
}
public threaded struct extern "::btSoftBody::Link" btSoftBody_Link {
  public metafunction __base__ {btSoftBody_Feature, btSoftBody_Element};
  public btScalar m_c0;
  public btScalar m_rl;
  public int m_bbending;
  public rptr{void} m_tag;
  public rawarray{rptr{btSoftBody_Node}, 2} m_n;
  public btScalar m_c2;
  public rptr{btSoftBody_Material} m_material;
  public btVector3 m_c3;
  public btScalar m_c1;
}
public threaded struct extern "::btSoftBody::Material" btSoftBody_Material {
  public metafunction __base__ {btSoftBody_Element};
  public btScalar m_kAST;
  public rptr{void} m_tag;
  public int m_flags;
  public btScalar m_kLST;
  public btScalar m_kVST;
}
public threaded struct extern "::btSoftBody::Node" btSoftBody_Node {
  public metafunction __base__ {btSoftBody_Element, btSoftBody_Feature};
  public btVector3 m_x;
  public btScalar m_area;
  public rptr{btSoftBody_Material} m_material;
  public btVector3 m_n;
  public btVector3 m_q;
  public btScalar m_im;
  public rptr{void} m_tag;
  public btVector3 m_f;
  public int m_battach;
  public btVector3 m_v;
  public rptr{btDbvtNode} m_leaf;
}
public threaded struct extern "::btSoftBody::Note" btSoftBody_Note {
  public metafunction __base__ {btSoftBody_Element};
  public rptr{void} m_tag;
  public btVector3 m_offset;
  public int m_rank;
  public rawarray{rptr{btSoftBody_Node}, 4} m_nodes;
  public crptr{char} m_text;
  public rawarray{btScalar, 4} m_coords;
}
public threaded struct extern "::btSoftBody::Pose" btSoftBody_Pose {
  public btAlignedObjectArray_float m_wgh;
  public btScalar m_volume;
  public btVector3 m_com;
  public bool m_bframe;
  public btMatrix3x3 m_rot;
  public bool m_bvolume;
  public btMatrix3x3 m_aqq;
  public btMatrix3x3 m_scl;
  public btAlignedObjectArray_btVector3 m_pos;
}
public threaded struct extern "::btSoftBody::RContact" btSoftBody_RContact {
  public btVector3 m_c1;
  public btScalar m_c2;
  public btSoftBody_sCti m_cti;
  public btScalar m_c3;
  public btScalar m_c4;
  public rptr{btSoftBody_Node} m_node;
  public btMatrix3x3 m_c0;
}
public threaded struct extern "::btSoftBody::RayFromToCaster" "nodefault" btSoftBody_RayFromToCaster(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btScalar mxt_2)  {
  public metafunction __base__ {btDbvt_ICollide};
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public function extern "Process" void Process1(crptr{btDbvtNode} leaf_0);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} _0, crptr{btDbvtNode} _1);
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n_0, btScalar _1);
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
  public btVector3 m_rayNormalizedDirection;
  public btScalar m_mint;
  public rptr{btSoftBody_Face} m_face;
  public btVector3 m_rayFrom;
  public int m_tests;
  public btVector3 m_rayTo;
}
public threaded struct extern "::btSoftBody::SContact" btSoftBody_SContact {
  public btScalar m_margin;
  public btVector3 m_normal;
  public btVector3 m_weights;
  public rptr{btSoftBody_Face} m_face;
  public rawarray{btScalar, 2} m_cfm;
  public btScalar m_friction;
  public rptr{btSoftBody_Node} m_node;
}
public threaded struct extern "::btSoftBody::SolverState" btSoftBody_SolverState {
  public btScalar radmrg;
  public btScalar velmrg;
  public btScalar isdt;
  public btScalar updmrg;
  public btScalar sdt;
}
public threaded struct extern "::btSoftBody::Tetra" btSoftBody_Tetra {
  public metafunction __base__ {btSoftBody_Element, btSoftBody_Feature};
  public rawarray{rptr{btSoftBody_Node}, 4} m_n;
  public rptr{void} m_tag;
  public rawarray{btVector3, 4} m_c0;
  public rptr{btDbvtNode} m_leaf;
  public btScalar m_c1;
  public btScalar m_rv;
  public btScalar m_c2;
  public rptr{btSoftBody_Material} m_material;
}
public threaded struct extern "::btSoftBody::eAeroModel" btSoftBody_eAeroModel {
}
public threaded struct extern "::btSoftBody::eFeature" btSoftBody_eFeature {
}
public threaded struct extern "::btSoftBody::ePSolver" btSoftBody_ePSolver {
}
public threaded struct extern "::btSoftBody::eSolverPresets" btSoftBody_eSolverPresets {
}
public threaded struct extern "::btSoftBody::eVSolver" btSoftBody_eVSolver {
}
public threaded struct extern "::btSoftBody::fCollision" btSoftBody_fCollision {
}
public threaded struct extern "::btSoftBody::fMaterial" btSoftBody_fMaterial {
}
public threaded struct extern "::btSoftBody::sCti" btSoftBody_sCti {
  public btScalar m_offset;
  public btVector3 m_normal;
  public crptr{btCollisionObject} m_colObj;
}
public threaded struct extern "::btSoftBody::sMedium" btSoftBody_sMedium {
  public btScalar m_density;
  public btScalar m_pressure;
  public btVector3 m_velocity;
}
public threaded struct extern "::btSoftBody::sRayCast" btSoftBody_sRayCast {
  public btScalar fraction;
  public rptr{btSoftBody} body;
  public int index;
}
public threaded struct extern "::btSoftClusterCollisionShape" "nodefault" btSoftClusterCollisionShape(crptr{btSoftBody_Cluster} cluster_0)  {
  public metafunction __base__ {btCollisionShape, btConvexInternalShape, btConvexShape};
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public crptr{btSoftBody_Cluster} m_cluster;
}
public threaded struct extern "::btSoftColliders" btSoftColliders {
}
public threaded struct extern "::btSoftColliders::ClusterBase" btSoftColliders_ClusterBase {
  public metafunction __base__ {btDbvt_ICollide};
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public function extern "SolveContact" bool SolveContact(btGjkEpaSolver2_sResults const& res_0, btSoftBody_Body ba_1, btSoftBody_Body const bb_2, btSoftBody_CJoint mutable& joint_3);
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n_0, btScalar _1);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} _0, crptr{btDbvtNode} _1);
  public function extern "Process" void Process1(crptr{btDbvtNode} _0);
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
  public btScalar erp;
  public btScalar friction;
  public btScalar threshold;
  public btScalar m_margin;
  public btScalar idt;
}
public threaded struct extern "::btSoftColliders::CollideCL_RS" "nonmovable" btSoftColliders_CollideCL_RS {
  public metafunction __base__ {btSoftColliders_ClusterBase, btDbvt_ICollide};
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
  public function extern "SolveContact" bool SolveContact(btGjkEpaSolver2_sResults const& res_0, btSoftBody_Body ba_1, btSoftBody_Body const bb_2, btSoftBody_CJoint mutable& joint_3);
  public function extern "Process" void Process1(crptr{btDbvtNode} leaf_0);
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n_0, btScalar _1);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} _0, crptr{btDbvtNode} _1);
  public function extern "ProcessColObj" void ProcessColObj(rptr{btSoftBody} ps_0, crptr{btCollisionObjectWrapper} colObWrap_1);
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public btScalar friction;
  public btScalar erp;
  public rptr{btSoftBody} psb;
  public btScalar idt;
  public crptr{btCollisionObjectWrapper} m_colObjWrap;
  public btScalar m_margin;
  public btScalar threshold;
}
public threaded struct extern "::btSoftColliders::CollideCL_SS" "nonmovable" btSoftColliders_CollideCL_SS {
  public metafunction __base__ {btDbvt_ICollide, btSoftColliders_ClusterBase};
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
  public function extern "ProcessSoftSoft" void ProcessSoftSoft(rptr{btSoftBody} psa_0, rptr{btSoftBody} psb_1);
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public function extern "SolveContact" bool SolveContact(btGjkEpaSolver2_sResults const& res_0, btSoftBody_Body ba_1, btSoftBody_Body const bb_2, btSoftBody_CJoint mutable& joint_3);
  public function extern "Process" void Process1(crptr{btDbvtNode} _0);
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n_0, btScalar _1);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} la_0, crptr{btDbvtNode} lb_1);
  public rawarray{rptr{btSoftBody}, 2} bodies;
  public btScalar idt;
  public btScalar m_margin;
  public btScalar threshold;
  public btScalar friction;
  public btScalar erp;
}
public threaded struct extern "::btSoftColliders::CollideSDF_RS" "nonmovable" btSoftColliders_CollideSDF_RS {
  public metafunction __base__ {btDbvt_ICollide};
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n_0, btScalar _1);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} _0, crptr{btDbvtNode} _1);
  public function extern "Process" void Process1(crptr{btDbvtNode} leaf_0);
  public function extern "DoNode" void DoNode(btSoftBody_Node mutable& n_0) const;
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
  public rptr{btSoftBody} psb;
  public rptr{btRigidBody} m_rigidBody;
  public btScalar stamargin;
  public crptr{btCollisionObjectWrapper} m_colObj1Wrap;
  public btScalar dynmargin;
}
public threaded struct extern "::btSoftColliders::CollideVF_SS" "nonmovable" btSoftColliders_CollideVF_SS {
  public metafunction __base__ {btDbvt_ICollide};
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n_0, btScalar _1);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} lnode_0, crptr{btDbvtNode} lface_1);
  public function extern "Process" void Process1(crptr{btDbvtNode} _0);
  public rawarray{rptr{btSoftBody}, 2} psb;
  public btScalar mrg;
}
public tsvaluetype struct extern "::btSoftJointBodyType" "extenum" btSoftJointBodyType { }
public extern "BT_JOINT_SOFT_BODY_CLUSTER" btSoftJointBodyType BT_JOINT_SOFT_BODY_CLUSTER;
public extern "BT_JOINT_RIGID_BODY" btSoftJointBodyType BT_JOINT_RIGID_BODY;
public extern "BT_JOINT_COLLISION_OBJECT" btSoftJointBodyType BT_JOINT_COLLISION_OBJECT;
public threaded struct extern "::btSoftRigidCollisionAlgorithm" "nodefault" btSoftRigidCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} col0_2, crptr{btCollisionObjectWrapper} col1Wrap_3, bool isSwapped_4)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btSoftRigidCollisionAlgorithm::CreateFunc" "nonmovable" btSoftRigidCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btSoftRigidDynamicsWorld" "nodefault" btSoftRigidDynamicsWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3, rptr{btSoftBodySolver} softBodySolver_4)  {
  public metafunction __base__ {btDynamicsWorld, btCollisionWorld, btDiscreteDynamicsWorld};
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "applyGravity" void applyGravity();
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "getSoftBodyArray" btSoftBodyArray const& cgetSoftBodyArray() const;
  public function extern "getSoftBodyArray" btSoftBodyArray mutable& getSoftBodyArray();
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "setNumTasks" void setNumTasks(int numTasks_0);
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint_0, bool disableCollisionsBetweenLinkedBodies_1);
  public function extern "addAction" void addAction(rptr{btActionInterface} action_0);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb_0, rptr{void} worldUserInfo_1, bool isPreTick_2);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep_0, int maxSubSteps_1, btScalar fixedTimeStep_2);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character_0);
  public function extern "getSimulationIslandManager" crptr{btSimulationIslandManager} cgetSimulationIslandManager() const;
  public function extern "getSimulationIslandManager" rptr{btSimulationIslandManager} getSimulationIslandManager();
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver_0);
  public function extern "removeSoftBody" void removeSoftBody(rptr{btSoftBody} body_0);
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index_0);
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index_0) const;
  public function extern "clearForces" void clearForces();
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action_0);
  public function extern "getSynchronizeAllMotionStates" bool getSynchronizeAllMotionStates() const;
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "setGravity" void setGravity(btVector3 const& gravity_0);
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo_0);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body_0);
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body_0, short group_1, short mask_2);
  public function extern "setSynchronizeAllMotionStates" void setSynchronizeAllMotionStates(bool synchronizeAll_0);
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "updateVehicles" void updateVehicles(btScalar timeStep_0);
  public function extern "debugDrawConstraint" void debugDrawConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "updateAabbs" void updateAabbs();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
  public function extern "getCollisionWorld" rptr{btCollisionWorld} getCollisionWorld();
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& cgetCollisionObjectArray() const;
  public function extern "setDrawFlags" void setDrawFlags(int f_0);
  public function extern "setApplySpeculativeContactRestitution" void setApplySpeculativeContactRestitution(bool enable_0);
  public function extern "getLatencyMotionStateInterpolation" bool getLatencyMotionStateInterpolation() const;
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "synchronizeSingleMotionState" void synchronizeSingleMotionState(rptr{btRigidBody} body_0);
  public function extern "addSoftBody" void addSoftBody(rptr{btSoftBody} body_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body_0);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "setLatencyMotionStateInterpolation" void setLatencyMotionStateInterpolation(bool latencyInterpolation_0);
  public function extern "getWorldInfo" btSoftBodyWorldInfo mutable& getWorldInfo();
  public function extern "getWorldInfo" btSoftBodyWorldInfo const& cgetWorldInfo() const;
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "getApplySpeculativeContactRestitution" bool getApplySpeculativeContactRestitution() const;
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character_0);
  public function extern "getDrawFlags" int getDrawFlags() const;
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
}
public threaded struct extern "::btSoftSoftCollisionAlgorithm" "nodefault" btSoftSoftCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
}
public threaded struct extern "::btSoftSoftCollisionAlgorithm::CreateFunc" "nonmovable" btSoftSoftCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btSolve2LinearConstraint" "nodefault" btSolve2LinearConstraint(btScalar tau_0, btScalar damping_1)  {
  public function extern "resolveUnilateralPairConstraint" void resolveUnilateralPairConstraint(rptr{btRigidBody} body0_0, rptr{btRigidBody} body1_1, btMatrix3x3 const& world2A_2, btMatrix3x3 const& world2B_3, btVector3 const& invInertiaADiag_4, btScalar const invMassA_5, btVector3 const& linvelA_6, btVector3 const& angvelA_7, btVector3 const& rel_posA1_8, btVector3 const& invInertiaBDiag_9, btScalar const invMassB_10, btVector3 const& linvelB_11, btVector3 const& angvelB_12, btVector3 const& rel_posA2_13, btScalar depthA_14, btVector3 const& normalA_15, btVector3 const& rel_posB1_16, btVector3 const& rel_posB2_17, btScalar depthB_18, btVector3 const& normalB_19, btScalar mutable& imp0_20, btScalar mutable& imp1_21);
  public function extern "resolveBilateralPairConstraint" void resolveBilateralPairConstraint(rptr{btRigidBody} body0_0, rptr{btRigidBody} body1_1, btMatrix3x3 const& world2A_2, btMatrix3x3 const& world2B_3, btVector3 const& invInertiaADiag_4, btScalar const invMassA_5, btVector3 const& linvelA_6, btVector3 const& angvelA_7, btVector3 const& rel_posA1_8, btVector3 const& invInertiaBDiag_9, btScalar const invMassB_10, btVector3 const& linvelB_11, btVector3 const& angvelB_12, btVector3 const& rel_posA2_13, btScalar depthA_14, btVector3 const& normalA_15, btVector3 const& rel_posB1_16, btVector3 const& rel_posB2_17, btScalar depthB_18, btVector3 const& normalB_19, btScalar mutable& imp0_20, btScalar mutable& imp1_21);
}
public threaded struct extern "::btSolverBody" btSolverBody {
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTransform_0);
  public function extern "getPushVelocity" btVector3 const& getPushVelocity() const;
  public function extern "writebackVelocity" void writebackVelocity();
  public function extern "internalGetVelocityInLocalPointObsolete" void internalGetVelocityInLocalPointObsolete(btVector3 const& rel_pos_0, btVector3 mutable& velocity_1) const;
  public function extern "internalGetAngularFactor" btVector3 const& internalGetAngularFactor() const;
  public function extern "applyImpulse" void applyImpulse(btVector3 const& linearComponent_0, btVector3 const& angularComponent_1, btScalar const impulseMagnitude_2);
  public function extern "getDeltaLinearVelocity" btVector3 const& getDeltaLinearVelocity() const;
  public function extern "getAngularVelocity" void getAngularVelocity(btVector3 mutable& angVel_0) const;
  public function extern "internalGetDeltaAngularVelocity" btVector3 mutable& internalGetDeltaAngularVelocity();
  public function extern "internalSetInvMass" void internalSetInvMass(btVector3 const& invMass_0);
  public function extern "internalApplyPushImpulse" void internalApplyPushImpulse(btVector3 const& linearComponent_0, btVector3 const& angularComponent_1, btScalar impulseMagnitude_2);
  public function extern "getWorldTransform" btTransform const& getWorldTransform() const;
  public function extern "getTurnVelocity" btVector3 const& getTurnVelocity() const;
  public function extern "internalGetTurnVelocity" btVector3 mutable& internalGetTurnVelocity();
  public function extern "internalGetAngularVelocity" void internalGetAngularVelocity(btVector3 mutable& angVel_0) const;
  public function extern "internalApplyImpulse" void internalApplyImpulse(btVector3 const& linearComponent_0, btVector3 const& angularComponent_1, btScalar const impulseMagnitude_2);
  public function extern "internalGetPushVelocity" btVector3 mutable& internalGetPushVelocity();
  public function extern "internalGetInvMass" btVector3 const& internalGetInvMass() const;
  public function extern "writebackVelocityAndTransform" void writebackVelocityAndTransform(btScalar timeStep_0, btScalar splitImpulseTurnErp_1);
  public function extern "internalGetDeltaLinearVelocity" btVector3 mutable& internalGetDeltaLinearVelocity();
  public function extern "getVelocityInLocalPointNoDelta" void getVelocityInLocalPointNoDelta(btVector3 const& rel_pos_0, btVector3 mutable& velocity_1) const;
  public function extern "getVelocityInLocalPointObsolete" void getVelocityInLocalPointObsolete(btVector3 const& rel_pos_0, btVector3 mutable& velocity_1) const;
  public function extern "getDeltaAngularVelocity" btVector3 const& getDeltaAngularVelocity() const;
  public btVector3 m_deltaLinearVelocity;
  public btVector3 m_invMass;
  public btVector3 m_angularFactor;
  public btVector3 m_angularVelocity;
  public btVector3 m_turnVelocity;
  public btVector3 m_externalTorqueImpulse;
  public btVector3 m_linearFactor;
  public btVector3 m_linearVelocity;
  public btVector3 m_externalForceImpulse;
  public btVector3 m_deltaAngularVelocity;
  public rptr{btRigidBody} m_originalBody;
  public btVector3 m_pushVelocity;
  public btTransform m_worldTransform;
}
public threaded struct extern "::btSolverConstraint" btSolverConstraint {
  public btScalar m_upperLimit;
  public int m_solverBodyIdB;
  public btVector3 m_angularComponentA;
  public int m_frictionIndex;
  public btVector3 m_angularComponentB;
  public btVector3 m_relpos2CrossNormal;
  public btScalar m_lowerLimit;
  public btVector3 m_contactNormal2;
  public btScalar m_cfm;
  public btScalar m_rhs;
  public btScalar m_appliedPushImpulse;
  public btScalar m_friction;
  public int m_solverBodyIdA;
  public btVector3 m_contactNormal1;
  public int m_overrideNumSolverIterations;
  public btScalar m_jacDiagABInv;
  public btVector3 m_relpos1CrossNormal;
  public btScalar m_appliedImpulse;
  public btScalar m_rhsPenetration;
}
public tsvaluetype struct extern "::btSolverConstraintType" "extenum" btSolverConstraintType { }
public extern "BT_SOLVER_CONTACT_1D" btSolverConstraintType BT_SOLVER_CONTACT_1D;
public extern "BT_SOLVER_FRICTION_1D" btSolverConstraintType BT_SOLVER_FRICTION_1D;
/* skip btSolverConstraint_91 : unnamed */
public tsvaluetype struct extern "::btSolverMode" "extenum" btSolverMode { }
public extern "SOLVER_RANDMIZE_ORDER" btSolverMode SOLVER_RANDMIZE_ORDER;
public extern "SOLVER_FRICTION_SEPARATE" btSolverMode SOLVER_FRICTION_SEPARATE;
public extern "SOLVER_USE_WARMSTARTING" btSolverMode SOLVER_USE_WARMSTARTING;
public extern "SOLVER_USE_2_FRICTION_DIRECTIONS" btSolverMode SOLVER_USE_2_FRICTION_DIRECTIONS;
public extern "SOLVER_ENABLE_FRICTION_DIRECTION_CACHING" btSolverMode SOLVER_ENABLE_FRICTION_DIRECTION_CACHING;
public extern "SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION" btSolverMode SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION;
public extern "SOLVER_CACHE_FRIENDLY" btSolverMode SOLVER_CACHE_FRIENDLY;
public extern "SOLVER_SIMD" btSolverMode SOLVER_SIMD;
public extern "SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS" btSolverMode SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS;
public extern "SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS" btSolverMode SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS;
public threaded struct extern "::btSortedOverlappingPairCache" "nonmovable" btSortedOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCallback, btOverlappingPairCache};
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback_0);
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "needsBroadphaseCollision" bool needsBroadphaseCollision(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1) const;
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair_0, rptr{btDispatcher} dispatcher_1);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher_1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback_0);
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "getOverlappingPairArray" btBroadphasePairArray const& cgetOverlappingPairArray() const;
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "getOverlapFilterCallback" rptr{btOverlapFilterCallback} getOverlapFilterCallback();
}
public threaded struct extern "::btSparseSdf<3>" btSparseSdf_3 {
  public function extern "Evaluate" btScalar Evaluate(btVector3 const& x_0, crptr{btCollisionShape} shape_1, btVector3 mutable& normal_2, btScalar margin_3);
  public function extern "BuildCell" void BuildCell(btSparseSdf_3_Cell mutable& c_0);
  public function extern "GarbageCollect" void GarbageCollect(int lifetime_0);
  public function extern "Initialize" void Initialize(int hashsize_0, int clampCells_1);
  public function extern "Reset" void Reset();
  public function extern "RemoveReferences" int RemoveReferences(rptr{btCollisionShape} pcs_0);
  public int puid;
  public int nprobes;
  public int m_clampCells;
  public int ncells;
  public int nqueries;
  public btScalar voxelsz;
  public btAlignedObjectArray_btSparseSdf_3_Cell_p cells;
}
public threaded struct extern "::btSparseSdf<3>::Cell" "nodefault" btSparseSdf_3_Cell private {
}
public threaded struct extern "::btSparseSdf<3>::IntFrac" "nodefault" btSparseSdf_3_IntFrac private {
}
public threaded struct extern "::btSphereBoxCollisionAlgorithm" "nodefault" btSphereBoxCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool isSwapped_4)  {
  public metafunction __base__ {btCollisionAlgorithm, btActivatingCollisionAlgorithm};
  public function extern "getSphereDistance" bool getSphereDistance(crptr{btCollisionObjectWrapper} boxObjWrap_0, btVector3 mutable& v3PointOnBox_1, btVector3 mutable& normal_2, btScalar mutable& penetrationDepth_3, btVector3 const& v3SphereCenter_4, btScalar fRadius_5, btScalar maxContactDistance_6);
  public function extern "getSpherePenetration" btScalar getSpherePenetration(btVector3 const& boxHalfExtent_0, btVector3 const& sphereRelPos_1, btVector3 mutable& closestPoint_2, btVector3 mutable& normal_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btSphereBoxCollisionAlgorithm::CreateFunc" "nonmovable" btSphereBoxCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btSphereShape" "nodefault" btSphereShape(btScalar radius_0)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "setUnscaledRadius" void setUnscaledRadius(btScalar radius_0);
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
}
public threaded struct extern "::btSphereSphereCollisionAlgorithm" "nodefault" btSphereSphereCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} col0Wrap_2, crptr{btCollisionObjectWrapper} col1Wrap_3)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btSphereSphereCollisionAlgorithm::CreateFunc" "nonmovable" btSphereSphereCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} col0Wrap_1, crptr{btCollisionObjectWrapper} col1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btSphereTriangleCollisionAlgorithm" "nodefault" btSphereTriangleCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool swapped_4)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray_0);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public threaded struct extern "::btSphereTriangleCollisionAlgorithm::CreateFunc" "nonmovable" btSphereTriangleCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public threaded struct extern "::btStackAlloc" "nodefault" btStackAlloc(uint size_0)  {
  public function extern "create" void create(uint size_0);
  public function extern "beginBlock" rptr{btBlock} beginBlock();
  public function extern "endBlock" void endBlock(rptr{btBlock} block_0);
  public function extern "allocate" rptr{uchar} allocate(uint size_0);
  public function extern "getAvailableMemory" int getAvailableMemory() const;
  public function extern "destroy" void destroy();
}
public threaded struct extern "::btStaticPlaneShape" "nodefault" btStaticPlaneShape(btVector3 const& planeNormal_0, btScalar planeConstant_1)  {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "getPlaneConstant" btScalar const& getPlaneConstant() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getPlaneNormal" btVector3 const& getPlaneNormal() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
}
public threaded struct extern "::btStaticPlaneShapeData" btStaticPlaneShapeData {
  public btVector3FloatData m_localScaling;
  public btCollisionShapeData m_collisionShapeData;
  public float m_planeConstant;
  public rawarray{char, 4} m_pad;
  public btVector3FloatData m_planeNormal;
}
public threaded struct extern "::btStorageResult" "nonmovable" btStorageResult {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1_0, int index1_1);
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0_0, int index0_1);
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld_0, btVector3 const& pointInWorld_1, btScalar depth_2);
  public btVector3 m_closestPointInB;
  public btVector3 m_normalOnSurfaceB;
  public btScalar m_distance;
}
public threaded struct extern "::btStridingMeshInterface" "nonmovable" btStridingMeshInterface {
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin_0, rptr{btVector3} aabbMax_1) const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart_0) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{rptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart_0);
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{crptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8) const;
  public function extern "preallocateVertices" void preallocateVertices(int numverts_0);
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1);
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling_0);
  public function extern "preallocateIndices" void preallocateIndices(int numindices_0);
}
public threaded struct extern "::btStridingMeshInterfaceData" btStridingMeshInterfaceData {
  public int m_numMeshParts;
  public rawarray{char, 4} m_padding;
  public btVector3FloatData m_scaling;
  public rptr{btMeshPartData} m_meshPartsPtr;
}
public threaded struct extern "::btSubSimplexClosestResult" btSubSimplexClosestResult {
  public function extern "setBarycentricCoordinates" void setBarycentricCoordinates(btScalar a_0, btScalar b_1, btScalar c_2, btScalar d_3);
  public function extern "isValid" bool isValid();
  public function extern "reset" void reset();
  public btVector3 m_closestPointOnSimplex;
  public rawarray{btScalar, 4} m_barycentricCoords;
  public btUsageBitfield m_usedVertices;
  public bool m_degenerate;
}
public threaded struct extern "::btSubsimplexConvexCast" "nodefault" btSubsimplexConvexCast(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2)  {
  public metafunction __base__ {btConvexCast};
  public function extern "calcTimeOfImpact" bool calcTimeOfImpact(btTransform const& fromA_0, btTransform const& toA_1, btTransform const& fromB_2, btTransform const& toB_3, btConvexCast_CastResult mutable& result_4);
}
public threaded struct extern "::btTetrahedronShapeEx" btTetrahedronShapeEx {
  public metafunction __base__ {btCollisionShape, btPolyhedralConvexAabbCachingShape, btPolyhedralConvexShape, btConvexShape, btBU_Simplex1to4, btConvexInternalShape};
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getIndex" int getIndex(int i_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "setVertices" void setVertices(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2, btVector3 const& v3_3);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "addVertex" void addVertex(btVector3 const& pt_0);
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "reset" void reset();
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
}
public threaded struct extern "::btTransform" btTransform {
  public function extern "serializeFloat" void serializeFloat(btTransformFloatData mutable& dataOut_0) const;
  public function extern "serialize" void serialize(btTransformFloatData mutable& dataOut_0) const;
  public function extern "setIdentity" void setIdentity();
  public function extern "getBasis" btMatrix3x3 mutable& getBasis();
  public function extern "getBasis" btMatrix3x3 const& cgetBasis() const;
  public function extern "mult" void mult(btTransform const& t1_0, btTransform const& t2_1);
  public function extern "deSerializeFloat" void deSerializeFloat(btTransformFloatData const& dataIn_0);
  public function extern "setFromOpenGLMatrix" void setFromOpenGLMatrix(crptr{btScalar} m_0);
  public function extern "setOrigin" void setOrigin(btVector3 const& origin_0);
  public function extern "invXform" btVector3 invXform(btVector3 const& inVec_0) const;
  public function extern "inverse" btTransform inverse() const;
  public function extern "deSerialize" void deSerialize(btTransformFloatData const& dataIn_0);
  public function extern "inverseTimes" btTransform inverseTimes(btTransform const& t_0) const;
  public function extern "deSerializeDouble" void deSerializeDouble(btTransformDoubleData const& dataIn_0);
  public function extern "setRotation" void setRotation(btQuaternion const& q_0);
  public function extern "setBasis" void setBasis(btMatrix3x3 const& basis_0);
  public function extern "getOpenGLMatrix" void getOpenGLMatrix(rptr{btScalar} m_0) const;
  public function extern "getOrigin" btVector3 mutable& getOrigin();
  public function extern "getOrigin" btVector3 const& cgetOrigin() const;
  public function extern "getRotation" btQuaternion getRotation() const;
}
public threaded struct extern "::btTransformDoubleData" btTransformDoubleData {
  public btMatrix3x3DoubleData m_basis;
  public btVector3DoubleData m_origin;
}
public threaded struct extern "::btTransformFloatData" btTransformFloatData {
  public btVector3FloatData m_origin;
  public btMatrix3x3FloatData m_basis;
}
public threaded struct extern "::btTransformUtil" btTransformUtil {
}
public threaded struct extern "::btTranslationalLimitMotor" btTranslationalLimitMotor {
  public function extern "testLimitValue" int testLimitValue(int limitIndex_0, btScalar test_value_1);
  public function extern "solveLinearAxis" btScalar solveLinearAxis(btScalar timeStep_0, btScalar jacDiagABInv_1, btRigidBody mutable& body1_2, btVector3 const& pointInA_3, btRigidBody mutable& body2_4, btVector3 const& pointInB_5, int limit_index_6, btVector3 const& axis_normal_on_a_7, btVector3 const& anchorPos_8);
  public function extern "needApplyForce" bool needApplyForce(int limitIndex_0);
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public btVector3 m_currentLimitError;
  public btVector3 m_stopERP;
  public btVector3 m_normalCFM;
  public rawarray{bool, 3} m_enableMotor;
  public btVector3 m_lowerLimit;
  public btScalar m_restitution;
  public btScalar m_damping;
  public rawarray{int, 3} m_currentLimit;
  public btVector3 m_targetVelocity;
  public btVector3 m_upperLimit;
  public btVector3 m_stopCFM;
  public btScalar m_limitSoftness;
  public btVector3 m_accumulatedImpulse;
  public btVector3 m_maxMotorForce;
  public btVector3 m_currentLinearDiff;
}
public tsvaluetype struct extern "::btTraversalMode" "extenum" btTraversalMode { }
public extern "TRAVERSAL_STACKLESS" btTraversalMode TRAVERSAL_STACKLESS;
public extern "TRAVERSAL_STACKLESS_CACHE_FRIENDLY" btTraversalMode TRAVERSAL_STACKLESS_CACHE_FRIENDLY;
public extern "TRAVERSAL_RECURSIVE" btTraversalMode TRAVERSAL_RECURSIVE;
public threaded struct extern "::btTriIndex" "nodefault" btTriIndex(int partId_0, int triangleIndex_1, rptr{btCollisionShape} shape_2)  {
  public function extern "getUid" int getUid() const;
  public function extern "getTriangleIndex" int getTriangleIndex() const;
  public function extern "getPartId" int getPartId() const;
  public int m_PartIdTriangleIndex;
  public rptr{btCollisionShape} m_childShape;
}
public threaded struct extern "::btTriangle" btTriangle {
  public btVector3 m_vertex1;
  public btVector3 m_vertex0;
  public int m_triangleIndex;
  public int m_partId;
  public btVector3 m_vertex2;
}
public threaded struct extern "::btTriangleBuffer" "nonmovable" btTriangleBuffer {
  public metafunction __base__ {btTriangleCallback};
  public function extern "getNumTriangles" int getNumTriangles() const;
  public function extern "getTriangle" btTriangle const& getTriangle(int index_0) const;
  public function extern "clearBuffer" void clearBuffer();
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
}
public threaded struct extern "::btTriangleCallback" "nonmovable" btTriangleCallback {
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
}
public threaded struct extern "::btTriangleConvexcastCallback" "nodefault" btTriangleConvexcastCallback(crptr{btConvexShape} convexShape_0, btTransform const& convexShapeFrom_1, btTransform const& convexShapeTo_2, btTransform const& triangleToWorld_3, btScalar const triangleCollisionMargin_4)  {
  public metafunction __base__ {btTriangleCallback};
  public function extern "reportHit" btScalar reportHit(btVector3 const& hitNormalLocal_0, btVector3 const& hitPointLocal_1, btScalar hitFraction_2, int partId_3, int triangleIndex_4);
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
  public btScalar m_allowedPenetration;
  public crptr{btConvexShape} m_convexShape;
  public btTransform m_convexShapeFrom;
  public btScalar m_triangleCollisionMargin;
  public btScalar m_hitFraction;
  public btTransform m_triangleToWorld;
  public btTransform m_convexShapeTo;
}
public threaded struct extern "::btTriangleIndexVertexArray" "nonmovable" btTriangleIndexVertexArray {
  public metafunction __base__ {btStridingMeshInterface};
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin_0, rptr{btVector3} aabbMax_1) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& vertexStride_3, rptr{rptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8);
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart_0) const;
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh_0, PHY_ScalarType indexType_1);
  public function extern "getIndexedMeshArray" IndexedMeshArray const& cgetIndexedMeshArray() const;
  public function extern "getIndexedMeshArray" IndexedMeshArray mutable& getIndexedMeshArray();
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1);
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart_0);
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& vertexStride_3, rptr{crptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8) const;
  public function extern "preallocateVertices" void preallocateVertices(int numverts_0);
  public function extern "preallocateIndices" void preallocateIndices(int numindices_0);
  public function extern "setScaling" void setScaling(btVector3 const& scaling_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
}
public threaded struct extern "::btTriangleIndexVertexMaterialArray" "nonmovable" btTriangleIndexVertexMaterialArray {
  public metafunction __base__ {btTriangleIndexVertexArray, btStridingMeshInterface};
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh_0, PHY_ScalarType indexType_1);
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart_0) const;
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& vertexStride_3, rptr{rptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "addMaterialProperties" void addMaterialProperties(btMaterialProperties const& mat_0, PHY_ScalarType triangleType_1);
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin_0, rptr{btVector3} aabbMax_1) const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "getLockedReadOnlyMaterialBase" void getLockedReadOnlyMaterialBase(rptr{crptr{uchar}} materialBase_0, int mutable& numMaterials_1, PHY_ScalarType mutable& materialType_2, int mutable& materialStride_3, rptr{crptr{uchar}} triangleMaterialBase_4, int mutable& numTriangles_5, int mutable& triangleMaterialStride_6, PHY_ScalarType mutable& triangleType_7, int subpart_8);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling_0);
  public function extern "preallocateIndices" void preallocateIndices(int numindices_0);
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart_0);
  public function extern "preallocateVertices" void preallocateVertices(int numverts_0);
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& vertexStride_3, rptr{crptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8) const;
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1);
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "getLockedMaterialBase" void getLockedMaterialBase(rptr{rptr{uchar}} materialBase_0, int mutable& numMaterials_1, PHY_ScalarType mutable& materialType_2, int mutable& materialStride_3, rptr{rptr{uchar}} triangleMaterialBase_4, int mutable& numTriangles_5, int mutable& triangleMaterialStride_6, PHY_ScalarType mutable& triangleType_7, int subpart_8);
  public function extern "getIndexedMeshArray" IndexedMeshArray const& cgetIndexedMeshArray() const;
  public function extern "getIndexedMeshArray" IndexedMeshArray mutable& getIndexedMeshArray();
}
public threaded struct extern "::btTriangleInfo" btTriangleInfo {
  public btScalar m_edgeV1V2Angle;
  public btScalar m_edgeV0V1Angle;
  public btScalar m_edgeV2V0Angle;
  public int m_flags;
}
public threaded struct extern "::btTriangleInfoData" btTriangleInfoData {
  public float m_edgeV1V2Angle;
  public float m_edgeV2V0Angle;
  public float m_edgeV0V1Angle;
  public int m_flags;
}
public threaded struct extern "::btTriangleInfoMap" "nonmovable" btTriangleInfoMap {
  public metafunction __base__ {btHashMap_btHashInt_btTriangleInfo};
  public function extern "deSerialize" void deSerialize(btTriangleInfoMapData mutable& tmapData_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "find" rptr{btTriangleInfo} find(btHashInt const& key_0);
  public function extern "find" crptr{btTriangleInfo} cfind(btHashInt const& key_0) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAtIndex" crptr{btTriangleInfo} cgetAtIndex(int index_0) const;
  public function extern "getAtIndex" rptr{btTriangleInfo} getAtIndex(int index_0);
  public function extern "findIndex" int findIndex(btHashInt const& key_0) const;
  public function extern "clear" void clear();
  public function extern "insert" void insert(btHashInt const& key_0, btTriangleInfo const& value_1);
  public function extern "remove" void remove(btHashInt const& key_0);
  public function extern "size" int size() const;
  public btScalar m_maxEdgeAngleThreshold;
  public btScalar m_planarEpsilon;
  public btScalar m_convexEpsilon;
  public btScalar m_zeroAreaThreshold;
  public btScalar m_equalVertexThreshold;
  public btScalar m_edgeDistanceThreshold;
}
public threaded struct extern "::btTriangleInfoMapData" btTriangleInfoMapData {
  public float m_equalVertexThreshold;
  public float m_edgeDistanceThreshold;
  public int m_hashTableSize;
  public rptr{btTriangleInfoData} m_valueArrayPtr;
  public rptr{int} m_keyArrayPtr;
  public float m_zeroAreaThreshold;
  public rawarray{char, 4} m_padding;
  public int m_numValues;
  public rptr{int} m_hashTablePtr;
  public rptr{int} m_nextPtr;
  public int m_nextSize;
  public float m_planarEpsilon;
  public float m_convexEpsilon;
  public int m_numKeys;
}
public threaded struct extern "::btTriangleMesh" "nodefault" btTriangleMesh(bool use32bitIndices_0, bool use4componentVertices_1)  {
  public metafunction __base__ {btTriangleIndexVertexArray, btStridingMeshInterface};
  public function extern "getUse32bitIndices" bool getUse32bitIndices() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& vertexStride_3, rptr{rptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8);
  public function extern "getUse4componentVertices" bool getUse4componentVertices() const;
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh_0, PHY_ScalarType indexType_1);
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart_0) const;
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1) const;
  public function extern "findOrAddVertex" int findOrAddVertex(btVector3 const& vertex_0, bool removeDuplicateVertices_1);
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin_0, rptr{btVector3} aabbMax_1) const;
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "preallocateIndices" void preallocateIndices(int numindices_0);
  public function extern "setScaling" void setScaling(btVector3 const& scaling_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "addIndex" void addIndex(int index_0);
  public function extern "getNumTriangles" int getNumTriangles() const;
  public function extern "getIndexedMeshArray" IndexedMeshArray mutable& getIndexedMeshArray();
  public function extern "getIndexedMeshArray" IndexedMeshArray const& cgetIndexedMeshArray() const;
  public function extern "addTriangle" void addTriangle(btVector3 const& vertex0_0, btVector3 const& vertex1_1, btVector3 const& vertex2_2, bool removeDuplicateVertices_3);
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1);
  public function extern "preallocateVertices" void preallocateVertices(int numverts_0);
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& vertexStride_3, rptr{crptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart_0);
  public btScalar m_weldingThreshold;
}
public threaded struct extern "::btTriangleMeshShape" "nodefault" btTriangleMeshShape private {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin_0);
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
}
public threaded struct extern "::btTriangleMeshShapeData" btTriangleMeshShapeData {
  public rawarray{char, 4} m_pad3;
  public rptr{btTriangleInfoMapData} m_triangleInfoMap;
  public rptr{btQuantizedBvhFloatData} m_quantizedFloatBvh;
  public btStridingMeshInterfaceData m_meshInterface;
  public float m_collisionMargin;
  public btCollisionShapeData m_collisionShapeData;
  public rptr{btQuantizedBvhDoubleData} m_quantizedDoubleBvh;
}
public threaded struct extern "::btTriangleRaycastCallback" "nodefault" btTriangleRaycastCallback(btVector3 const& from_0, btVector3 const& to_1, uint flags_2)  {
  public metafunction __base__ {btTriangleCallback};
  public function extern "reportHit" btScalar reportHit(btVector3 const& hitNormalLocal_0, btScalar hitFraction_1, int partId_2, int triangleIndex_3);
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
  public btVector3 m_from;
  public btVector3 m_to;
  public uint m_flags;
  public btScalar m_hitFraction;
}
public threaded struct extern "::btTriangleShape" "nonmovable" btTriangleShape {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getPlaneEquation" void getPlaneEquation(int i_0, btVector3 mutable& planeNormal_1, btVector3 mutable& planeSupport_2) const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getVertexPtr" btVector3 mutable& getVertexPtr(int index_0);
  public function extern "getVertexPtr" btVector3 const& cgetVertexPtr(int index_0) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& dir_0) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getVertex" void getVertex(int index_0, btVector3 mutable& vert_1) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "calcNormal" void calcNormal(btVector3 mutable& normal_0) const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public rawarray{btVector3, 3} m_vertices1;
}
public threaded struct extern "::btTriangleShapeEx" "nonmovable" btTriangleShapeEx {
  public metafunction __base__ {btCollisionShape, btConvexInternalShape, btConvexShape, btTriangleShape, btPolyhedralConvexShape};
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "applyTransform" void applyTransform(btTransform const& t_0);
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "getVertexPtr" btVector3 mutable& getVertexPtr(int index_0);
  public function extern "getVertexPtr" btVector3 const& cgetVertexPtr(int index_0) const;
  public function extern "overlap_test_conservative" bool overlap_test_conservative(btTriangleShapeEx const& other_0);
  public function extern "getName" crptr{char} getName() const;
  public function extern "getPlaneEquation" void getPlaneEquation(int i_0, btVector3 mutable& planeNormal_1, btVector3 mutable& planeSupport_2) const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "buildTriPlane" void buildTriPlane(btVector4 mutable& plane_0) const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "calcNormal" void calcNormal(btVector3 mutable& normal_0) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getVertex" void getVertex(int index_0, btVector3 mutable& vert_1) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public rawarray{btVector3, 3} m_vertices1;
}
public threaded struct extern "::btTypedConstraint" "nodefault" btTypedConstraint(btTypedConstraintType type_0, btRigidBody mutable& rbA_1)  {
  public metafunction __base__ {btTypedObject};
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getUid" int getUid() const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public int m_objectType;
}
public threaded struct extern "::btTypedConstraintData" btTypedConstraintData {
  public float m_dbgDrawSize;
  public rptr{btRigidBodyFloatData} m_rbB;
  public int m_userConstraintType;
  public int m_overrideNumSolverIterations;
  public float m_breakingImpulseThreshold;
  public int m_needsFeedback;
  public int m_disableCollisionsBetweenLinkedBodies;
  public int m_objectType;
  public rptr{btRigidBodyFloatData} m_rbA;
  public rptr{char} m_name;
  public int m_isEnabled;
  public float m_appliedImpulse;
  public int m_userConstraintId;
}
public threaded struct extern "::btTypedConstraintDoubleData" btTypedConstraintDoubleData {
  public double m_dbgDrawSize;
  public rptr{btRigidBodyDoubleData} m_rbB;
  public int m_userConstraintType;
  public int m_overrideNumSolverIterations;
  public double m_breakingImpulseThreshold;
  public int m_disableCollisionsBetweenLinkedBodies;
  public int m_objectType;
  public int m_needsFeedback;
  public rptr{btRigidBodyDoubleData} m_rbA;
  public rptr{char} m_name;
  public int m_isEnabled;
  public rawarray{char, 4} padding;
  public double m_appliedImpulse;
  public int m_userConstraintId;
}
public threaded struct extern "::btTypedConstraintFloatData" btTypedConstraintFloatData {
  public rptr{char} m_name;
  public int m_isEnabled;
  public float m_appliedImpulse;
  public int m_userConstraintId;
  public int m_overrideNumSolverIterations;
  public float m_breakingImpulseThreshold;
  public int m_disableCollisionsBetweenLinkedBodies;
  public int m_objectType;
  public int m_needsFeedback;
  public rptr{btRigidBodyFloatData} m_rbA;
  public rptr{btRigidBodyFloatData} m_rbB;
  public int m_userConstraintType;
  public float m_dbgDrawSize;
}
public tsvaluetype struct extern "::btTypedConstraintType" "extenum" btTypedConstraintType { }
public extern "POINT2POINT_CONSTRAINT_TYPE" btTypedConstraintType POINT2POINT_CONSTRAINT_TYPE;
public extern "HINGE_CONSTRAINT_TYPE" btTypedConstraintType HINGE_CONSTRAINT_TYPE;
public extern "CONETWIST_CONSTRAINT_TYPE" btTypedConstraintType CONETWIST_CONSTRAINT_TYPE;
public extern "D6_CONSTRAINT_TYPE" btTypedConstraintType D6_CONSTRAINT_TYPE;
public extern "SLIDER_CONSTRAINT_TYPE" btTypedConstraintType SLIDER_CONSTRAINT_TYPE;
public extern "CONTACT_CONSTRAINT_TYPE" btTypedConstraintType CONTACT_CONSTRAINT_TYPE;
public extern "D6_SPRING_CONSTRAINT_TYPE" btTypedConstraintType D6_SPRING_CONSTRAINT_TYPE;
public extern "GEAR_CONSTRAINT_TYPE" btTypedConstraintType GEAR_CONSTRAINT_TYPE;
public extern "FIXED_CONSTRAINT_TYPE" btTypedConstraintType FIXED_CONSTRAINT_TYPE;
public extern "MAX_CONSTRAINT_TYPE" btTypedConstraintType MAX_CONSTRAINT_TYPE;
/* skip btTypedConstraint_92 : unnamed */
public threaded struct extern "::btTypedConstraint::btConstraintInfo1" btTypedConstraint_btConstraintInfo1 {
  public int m_numConstraintRows;
  public int nub;
}
public threaded struct extern "::btTypedConstraint::btConstraintInfo2" btTypedConstraint_btConstraintInfo2 {
  public btScalar m_damping;
  public rptr{btScalar} m_J2linearAxis;
  public rptr{btScalar} m_upperLimit;
  public rptr{btScalar} m_J1linearAxis;
  public btScalar erp;
  public rptr{btScalar} m_constraintError;
  public int m_numIterations;
  public rptr{btScalar} m_lowerLimit;
  public int rowskip;
  public btScalar fps;
  public rptr{btScalar} m_J1angularAxis;
  public rptr{btScalar} cfm;
  public rptr{int} findex;
  public rptr{btScalar} m_J2angularAxis;
}
public threaded struct extern "::btTypedObject" "nodefault" btTypedObject(int objectType_0)  {
  public function extern "getObjectType" int getObjectType() const;
  public int m_objectType;
}
public threaded struct extern "::btUniformScalingShape" "nodefault" btUniformScalingShape(rptr{btConvexShape} convexChildShape_0, btScalar uniformScalingFactor_1)  {
  public metafunction __base__ {btConvexShape, btCollisionShape};
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUniformScalingFactor" btScalar getUniformScalingFactor() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getChildShape" rptr{btConvexShape} getChildShape();
  public function extern "getChildShape" crptr{btConvexShape} cgetChildShape() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "getMargin" btScalar getMargin() const;
}
public threaded struct extern "::btUnionFind" btUnionFind {
  public function extern "find" int find1(int x_0);
  public function extern "find" int find2(int p_0, int q_1);
  public function extern "allocate" void allocate(int N_0);
  public function extern "getElement" btElement mutable& getElement(int index_0);
  public function extern "getElement" btElement const& cgetElement(int index_0) const;
  public function extern "unite" void unite(int p_0, int q_1);
  public function extern "isRoot" bool isRoot(int x_0) const;
  public function extern "reset" void reset(int N_0);
  public function extern "sortIslands" void sortIslands();
  public function extern "Free" void Free();
  public function extern "getNumElements" int getNumElements() const;
}
public threaded struct extern "::btUniversalConstraint" "nodefault" btUniversalConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& anchor_2, btVector3 const& axis1_3, btVector3 const& axis2_4)  {
  public metafunction __base__ {btTypedConstraint, btGeneric6DofConstraint, btTypedObject};
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca_0, int solverBodyA_1, int solverBodyB_2, btScalar timeStep_3);
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper_0);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index_0);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getAngle" btScalar getAngle(int axis_index_0) const;
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setAxis" void setAxis(btVector3 const& axis1_0, btVector3 const& axis2_1);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper_0);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6);
  public function extern "getAnchor2" btVector3 const& getAnchor2();
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "setUpperLimit" void setUpperLimit(btScalar ang1max_0, btScalar ang2max_1);
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getAxis1" btVector3 const& getAxis1();
  public function extern "getAngle1" btScalar getAngle1();
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "getAnchor" btVector3 const& getAnchor();
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower_0);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "setLowerLimit" void setLowerLimit(btScalar ang1min_0, btScalar ang2min_1);
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower_0);
  public function extern "getAngle2" btScalar getAngle2();
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getAxis" btVector3 getAxis(int axis_index_0) const;
  public function extern "getUid" int getUid() const;
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6, rptr{btTypedConstraint_btConstraintInfo2} info_7, int row_8, btVector3 mutable& ax1_9, int rotational_10, int rotAllowed_11);
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower_0);
  public function extern "getAxis2" btVector3 const& getAxis2();
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index_0) const;
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower_0);
  public function extern "setLimit" void setLimit(int axis_0, btScalar lo_1, btScalar hi_2);
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper_0);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public int m_objectType;
  public bool m_useSolveConstraintObsolete;
}
public threaded struct extern "::btUsageBitfield" btUsageBitfield {
  public function extern "reset" void reset();
  public ushort usedVertexB;
  public ushort usedVertexD;
  public ushort unused1;
  public ushort usedVertexA;
  public ushort usedVertexC;
  public ushort unused3;
  public ushort unused4;
  public ushort unused2;
}
public threaded struct extern "::btVector3" btVector3 {
  public function extern "setW" void setW(btScalar _w_0);
  public function extern "getSkewSymmetricMatrix" void getSkewSymmetricMatrix(rptr{btVector3} v0_0, rptr{btVector3} v1_1, rptr{btVector3} v2_2) const;
  public function extern "dot" btScalar dot(btVector3 const& v_0) const;
  public function extern "closestAxis" int closestAxis() const;
  public function extern "setMin" void setMin(btVector3 const& other_0);
  public function extern "getY" btScalar const& getY() const;
  public function extern "normalize" btVector3 mutable& normalize();
  public function extern "triple" btScalar triple(btVector3 const& v1_0, btVector3 const& v2_1) const;
  public function extern "length2" btScalar length2() const;
  public function extern "setX" void setX(btScalar _x_0);
  public function extern "maxDot" long maxDot(crptr{btVector3} array_0, long array_count_1, btScalar mutable& dotOut_2) const;
  public function extern "fuzzyZero" bool fuzzyZero() const;
  public function extern "x" btScalar const& x() const;
  public function extern "minDot" long minDot(crptr{btVector3} array_0, long array_count_1, btScalar mutable& dotOut_2) const;
  public function extern "serializeFloat" void serializeFloat(btVector3FloatData mutable& dataOut_0) const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "serialize" void serialize(btVector3FloatData mutable& dataOut_0) const;
  public function extern "furthestAxis" int furthestAxis() const;
  public function extern "setY" void setY(btScalar _y_0);
  public function extern "distance2" btScalar distance2(btVector3 const& v_0) const;
  public function extern "lerp" btVector3 lerp(btVector3 const& v_0, btScalar const& t_1) const;
  public function extern "setMax" void setMax(btVector3 const& other_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btVector3FloatData const& dataIn_0);
  public function extern "setValue" void setValue(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
  public function extern "normalized" btVector3 normalized() const;
  public function extern "isZero" bool isZero() const;
  public function extern "w" btScalar const& w() const;
  public function extern "rotate" btVector3 rotate(btVector3 const& wAxis_0, btScalar const _angle_1) const;
  public function extern "minAxis" int minAxis() const;
  public function extern "serializeDouble" void serializeDouble(btVector3DoubleData mutable& dataOut_0) const;
  public function extern "norm" btScalar norm() const;
  public function extern "y" btScalar const& y() const;
  public function extern "distance" btScalar distance(btVector3 const& v_0) const;
  public function extern "setInterpolate3" void setInterpolate3(btVector3 const& v0_0, btVector3 const& v1_1, btScalar rt_2);
  public function extern "angle" btScalar angle(btVector3 const& v_0) const;
  public function extern "safeNormalize" btVector3 mutable& safeNormalize();
  public function extern "maxAxis" int maxAxis() const;
  public function extern "deSerialize" void deSerialize(btVector3FloatData const& dataIn_0);
  public function extern "setZ" void setZ(btScalar _z_0);
  public function extern "cross" btVector3 cross(btVector3 const& v_0) const;
  public function extern "setZero" void setZero();
  public function extern "absolute" btVector3 absolute() const;
  public function extern "dot3" btVector3 dot3(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2) const;
  public function extern "deSerializeDouble" void deSerializeDouble(btVector3DoubleData const& dataIn_0);
  public function extern "getX" btScalar const& getX() const;
  public function extern "length" btScalar length() const;
  public function extern "z" btScalar const& z() const;
  public rawarray{btScalar, 4} m_floats;
}
public threaded struct extern "::btVector3DoubleData" btVector3DoubleData {
  public rawarray{double, 4} m_floats;
}
public threaded struct extern "::btVector3FloatData" btVector3FloatData {
  public rawarray{float, 4} m_floats;
}
public threaded struct extern "::btVector4" btVector4 {
  public metafunction __base__ {btVector3};
  public function extern "serializeDouble" void serializeDouble(btVector3DoubleData mutable& dataOut_0) const;
  public function extern "getW" btScalar getW() const;
  public function extern "minAxis" int minAxis() const;
  public function extern "norm" btScalar norm() const;
  public function extern "distance" btScalar distance(btVector3 const& v_0) const;
  public function extern "y" btScalar const& y() const;
  public function extern "absolute4" btVector4 absolute4() const;
  public function extern "angle" btScalar angle(btVector3 const& v_0) const;
  public function extern "maxAxis4" int maxAxis4() const;
  public function extern "setInterpolate3" void setInterpolate3(btVector3 const& v0_0, btVector3 const& v1_1, btScalar rt_2);
  public function extern "setZ" void setZ(btScalar _z_0);
  public function extern "cross" btVector3 cross(btVector3 const& v_0) const;
  public function extern "maxAxis" int maxAxis() const;
  public function extern "safeNormalize" btVector3 mutable& safeNormalize();
  public function extern "deSerialize" void deSerialize(btVector3FloatData const& dataIn_0);
  public function extern "setZero" void setZero();
  public function extern "deSerializeDouble" void deSerializeDouble(btVector3DoubleData const& dataIn_0);
  public function extern "minAxis4" int minAxis4() const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "absolute" btVector3 absolute() const;
  public function extern "dot3" btVector3 dot3(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2) const;
  public function extern "z" btScalar const& z() const;
  public function extern "length" btScalar length() const;
  public function extern "closestAxis4" int closestAxis4() const;
  public function extern "getSkewSymmetricMatrix" void getSkewSymmetricMatrix(rptr{btVector3} v0_0, rptr{btVector3} v1_1, rptr{btVector3} v2_2) const;
  public function extern "setW" void setW(btScalar _w_0);
  public function extern "dot" btScalar dot(btVector3 const& v_0) const;
  public function extern "triple" btScalar triple(btVector3 const& v1_0, btVector3 const& v2_1) const;
  public function extern "length2" btScalar length2() const;
  public function extern "closestAxis" int closestAxis() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "setMin" void setMin(btVector3 const& other_0);
  public function extern "normalize" btVector3 mutable& normalize();
  public function extern "fuzzyZero" bool fuzzyZero() const;
  public function extern "setX" void setX(btScalar _x_0);
  public function extern "maxDot" long maxDot(crptr{btVector3} array_0, long array_count_1, btScalar mutable& dotOut_2) const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "serialize" void serialize(btVector3FloatData mutable& dataOut_0) const;
  public function extern "furthestAxis" int furthestAxis() const;
  public function extern "x" btScalar const& x() const;
  public function extern "minDot" long minDot(crptr{btVector3} array_0, long array_count_1, btScalar mutable& dotOut_2) const;
  public function extern "serializeFloat" void serializeFloat(btVector3FloatData mutable& dataOut_0) const;
  public function extern "setY" void setY(btScalar _y_0);
  public function extern "distance2" btScalar distance2(btVector3 const& v_0) const;
  public function extern "lerp" btVector3 lerp(btVector3 const& v_0, btScalar const& t_1) const;
  public function extern "setMax" void setMax(btVector3 const& other_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btVector3FloatData const& dataIn_0);
  public function extern "setValue" void setValue4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
  public function extern "setValue" void setValue3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
  public function extern "w" btScalar const& w() const;
  public function extern "rotate" btVector3 rotate(btVector3 const& wAxis_0, btScalar const _angle_1) const;
  public function extern "normalized" btVector3 normalized() const;
  public function extern "isZero" bool isZero() const;
  public rawarray{btScalar, 4} m_floats;
}
public threaded struct extern "::btVectorX<double>" "nodefault" btVectorX_double private {
}
public threaded struct extern "::btVectorX<float>" "nodefault" btVectorX_float private {
}
public metafunction btVectorXd btVectorX_double;
public metafunction btVectorXf btVectorX_float;
public threaded struct extern "::btVehicleRaycaster" "nonmovable" btVehicleRaycaster {
  public function extern "castRay" rptr{void} castRay(btVector3 const& from_0, btVector3 const& to_1, btVehicleRaycaster_btVehicleRaycasterResult mutable& result_2);
}
public threaded struct extern "::btVehicleRaycaster::btVehicleRaycasterResult" btVehicleRaycaster_btVehicleRaycasterResult {
  public btVector3 m_hitPointInWorld;
  public btVector3 m_hitNormalInWorld;
  public btScalar m_distFraction;
}
public threaded struct extern "::btVehicleTuning" "nodefault" btVehicleTuning private {
}
public metafunction btVertexArray btAlignedObjectArray_btVector3;
public threaded struct extern "::btVertexBufferDescriptor" "nonmovable" btVertexBufferDescriptor {
  public function extern "getNormalOffset" int getNormalOffset() const;
  public function extern "hasVertexPositions" bool hasVertexPositions() const;
  public function extern "getVertexStride" int getVertexStride() const;
  public function extern "getNormalStride" int getNormalStride() const;
  public function extern "getVertexOffset" int getVertexOffset() const;
  public function extern "hasNormals" bool hasNormals() const;
}
public threaded struct extern "::btVoronoiSimplexSolver" btVoronoiSimplexSolver {
  public function extern "inSimplex" bool inSimplex(btVector3 const& w_0);
  public function extern "setEqualVertexThreshold" void setEqualVertexThreshold(btScalar threshold_0);
  public function extern "closestPtPointTriangle" bool closestPtPointTriangle(btVector3 const& p_0, btVector3 const& a_1, btVector3 const& b_2, btVector3 const& c_3, btSubSimplexClosestResult mutable& result_4);
  public function extern "getSimplex" int getSimplex(rptr{btVector3} pBuf_0, rptr{btVector3} qBuf_1, rptr{btVector3} yBuf_2) const;
  public function extern "compute_points" void compute_points(btVector3 mutable& p1_0, btVector3 mutable& p2_1);
  public function extern "emptySimplex" bool emptySimplex() const;
  public function extern "backup_closest" void backup_closest(btVector3 mutable& v_0);
  public function extern "closestPtPointTetrahedron" bool closestPtPointTetrahedron(btVector3 const& p_0, btVector3 const& a_1, btVector3 const& b_2, btVector3 const& c_3, btVector3 const& d_4, btSubSimplexClosestResult mutable& finalResult_5);
  public function extern "removeVertex" void removeVertex(int index_0);
  public function extern "fullSimplex" bool fullSimplex() const;
  public function extern "getEqualVertexThreshold" btScalar getEqualVertexThreshold() const;
  public function extern "maxVertex" btScalar maxVertex();
  public function extern "numVertices" int numVertices() const;
  public function extern "pointOutsideOfPlane" int pointOutsideOfPlane(btVector3 const& p_0, btVector3 const& a_1, btVector3 const& b_2, btVector3 const& c_3, btVector3 const& d_4);
  public function extern "updateClosestVectorAndPoints" bool updateClosestVectorAndPoints();
  public function extern "closest" bool closest(btVector3 mutable& v_0);
  public function extern "reduceVertices" void reduceVertices(btUsageBitfield const& usedVerts_0);
  public function extern "reset" void reset();
  public function extern "addVertex" void addVertex(btVector3 const& w_0, btVector3 const& p_1, btVector3 const& q_2);
  public rawarray{btVector3, 5} m_simplexPointsQ;
  public btSubSimplexClosestResult m_cachedBC;
  public rawarray{btVector3, 5} m_simplexVectorW;
  public btVector3 m_cachedV;
  public int m_numVertices;
  public bool m_needsUpdate;
  public rawarray{btVector3, 5} m_simplexPointsP;
  public btVector3 m_lastW;
  public bool m_cachedValidClosest;
  public btVector3 m_cachedP1;
  public btVector3 m_cachedP2;
  public btScalar m_equalVertexThreshold;
}
public threaded struct extern "::btWheelInfo" "nodefault" btWheelInfo(btWheelInfoConstructionInfo mutable& ci_0)  {
  public function extern "updateWheel" void updateWheel(btRigidBody const& chassis_0, btWheelInfo_RaycastInfo mutable& raycastInfo_1);
  public function extern "getSuspensionRestLength" btScalar getSuspensionRestLength() const;
  public btScalar m_suspensionRestLength1;
  public btScalar m_rotation;
  public btScalar m_skidInfo;
  public btVector3 m_chassisConnectionPointCS;
  public btScalar m_suspensionRelativeVelocity;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_maxSuspensionForce;
  public bool m_bIsFrontWheel;
  public btScalar m_wheelsRadius;
  public btScalar m_steering;
  public btTransform m_worldTransform;
  public btScalar m_wheelsDampingRelaxation;
  public rptr{void} m_clientInfo;
  public btScalar m_wheelsDampingCompression;
  public btScalar m_wheelsSuspensionForce;
  public btScalar m_brake;
  public btScalar m_rollInfluence;
  public btScalar m_engineForce;
  public btVector3 m_wheelDirectionCS;
  public btScalar m_suspensionStiffness;
  public btScalar m_deltaRotation;
  public btScalar m_clippedInvContactDotSuspension;
  public btVector3 m_wheelAxleCS;
  public btScalar m_frictionSlip;
  public btWheelInfo_RaycastInfo m_raycastInfo;
}
public threaded struct extern "::btWheelInfoConstructionInfo" btWheelInfoConstructionInfo {
  public btScalar m_wheelRadius;
  public btScalar m_maxSuspensionTravelCm;
  public bool m_bIsFrontWheel;
  public btScalar m_maxSuspensionForce;
  public btScalar m_suspensionRestLength;
  public btScalar m_wheelsDampingRelaxation;
  public btScalar m_wheelsDampingCompression;
  public btVector3 m_wheelAxleCS;
  public btScalar m_frictionSlip;
  public btVector3 m_chassisConnectionCS;
  public btVector3 m_wheelDirectionCS;
  public btScalar m_suspensionStiffness;
}
public threaded struct extern "::btWheelInfo::RaycastInfo" btWheelInfo_RaycastInfo {
  public btVector3 m_hardPointWS;
  public btVector3 m_contactPointWS;
  public btVector3 m_wheelDirectionWS;
  public btVector3 m_wheelAxleWS;
  public btScalar m_suspensionLength;
  public btVector3 m_contactNormalWS;
  public bool m_isInContact;
  public rptr{void} m_groundObject;
}
public threaded struct extern "::btWorldImporter" "nodefault" btWorldImporter(rptr{btDynamicsWorld} world_0)  {
  public function extern "createStridingMeshInterfaceData" rptr{btStridingMeshInterfaceData} createStridingMeshInterfaceData(rptr{btStridingMeshInterfaceData} interfaceData_0);
  public function extern "createCylinderShapeX" rptr{btCollisionShape} createCylinderShapeX(btScalar radius_0, btScalar height_1);
  public function extern "createMultiSphereShape" rptr{btMultiSphereShape} createMultiSphereShape(crptr{btVector3} positions_0, crptr{btScalar} radi_1, int numSpheres_2);
  public function extern "getCollisionShapeByIndex" rptr{btCollisionShape} getCollisionShapeByIndex(int index_0);
  public function extern "createCapsuleShapeZ" rptr{btCollisionShape} createCapsuleShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "createTriangleMeshContainer" rptr{btTriangleIndexVertexArray} createTriangleMeshContainer();
  public function extern "getTriangleInfoMapByIndex" rptr{btTriangleInfoMap} getTriangleInfoMapByIndex(int index_0) const;
  public function extern "getNumBvhs" int getNumBvhs() const;
  public function extern "createCompoundShape" rptr{btCompoundShape} createCompoundShape();
  public function extern "createOptimizedBvh" rptr{btOptimizedBvh} createOptimizedBvh();
  public function extern "createCollisionObject" rptr{btCollisionObject} createCollisionObject(btTransform const& startTransform_0, rptr{btCollisionShape} shape_1, crptr{char} bodyName_2);
  public function extern "createBvhTriangleMeshShape" rptr{btBvhTriangleMeshShape} createBvhTriangleMeshShape(rptr{btStridingMeshInterface} trimesh_0, rptr{btOptimizedBvh} bvh_1);
  public function extern "createPlaneShape" rptr{btCollisionShape} createPlaneShape(btVector3 const& planeNormal_0, btScalar planeConstant_1);
  public function extern "createCapsuleShapeY" rptr{btCollisionShape} createCapsuleShapeY(btScalar radius_0, btScalar height_1);
  public function extern "createGimpactShape" rptr{btGImpactMeshShape} createGimpactShape(rptr{btStridingMeshInterface} trimesh_0);
  public function extern "getConstraintByName" rptr{btTypedConstraint} getConstraintByName(crptr{char} name_0);
  public function extern "getVerboseMode" int getVerboseMode() const;
  public function extern "getRigidBodyByIndex" rptr{btCollisionObject} getRigidBodyByIndex(int index_0) const;
  public function extern "getConstraintByIndex" rptr{btTypedConstraint} getConstraintByIndex(int index_0) const;
  public function extern "createHingeConstraint" rptr{btHingeConstraint} createHingeConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3, bool useReferenceFrameA_4);
  public function extern "createHingeConstraint" rptr{btHingeConstraint} createHingeConstraint3(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1, bool useReferenceFrameA_2);
  public function extern "createGearConstraint" rptr{btGearConstraint} createGearConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& axisInA_2, btVector3 const& axisInB_3, btScalar ratio_4);
  public function extern "createConvexTriangleMeshShape" rptr{btCollisionShape} createConvexTriangleMeshShape(rptr{btStridingMeshInterface} trimesh_0);
  public function extern "createConeShapeY" rptr{btCollisionShape} createConeShapeY(btScalar radius_0, btScalar height_1);
  public function extern "setDynamicsWorldInfo" void setDynamicsWorldInfo(btVector3 const& gravity_0, btContactSolverInfo const& solverInfo_1);
  public function extern "getCollisionShapeByName" rptr{btCollisionShape} getCollisionShapeByName(crptr{char} name_0);
  public function extern "createConeShapeX" rptr{btCollisionShape} createConeShapeX(btScalar radius_0, btScalar height_1);
  public function extern "setVerboseMode" void setVerboseMode(int verboseMode_0);
  public function extern "createRigidBody" rptr{btRigidBody} createRigidBody(bool isDynamic_0, btScalar mass_1, btTransform const& startTransform_2, rptr{btCollisionShape} shape_3, crptr{char} bodyName_4);
  public function extern "createConeTwistConstraint" rptr{btConeTwistConstraint} createConeTwistConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3);
  public function extern "createConeTwistConstraint" rptr{btConeTwistConstraint} createConeTwistConstraint2(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1);
  public function extern "createBoxShape" rptr{btCollisionShape} createBoxShape(btVector3 const& halfExtents_0);
  public function extern "createTriangleInfoMap" rptr{btTriangleInfoMap} createTriangleInfoMap();
  public function extern "getNumTriangleInfoMaps" int getNumTriangleInfoMaps() const;
  public function extern "getRigidBodyByName" rptr{btRigidBody} getRigidBodyByName(crptr{char} name_0);
  public function extern "createPoint2PointConstraint" rptr{btPoint2PointConstraint} createPoint2PointConstraint2(btRigidBody mutable& rbA_0, btVector3 const& pivotInA_1);
  public function extern "createPoint2PointConstraint" rptr{btPoint2PointConstraint} createPoint2PointConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3);
  public function extern "createCylinderShapeY" rptr{btCollisionShape} createCylinderShapeY(btScalar radius_0, btScalar height_1);
  public function extern "createCylinderShapeZ" rptr{btCollisionShape} createCylinderShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "createCapsuleShapeX" rptr{btCollisionShape} createCapsuleShapeX(btScalar radius_0, btScalar height_1);
  public function extern "createConvexHullShape" rptr{btConvexHullShape} createConvexHullShape();
  public function extern "createSphereShape" rptr{btCollisionShape} createSphereShape(btScalar radius_0);
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "createGeneric6DofSpringConstraint" rptr{btGeneric6DofSpringConstraint} createGeneric6DofSpringConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
  public function extern "createGeneric6DofConstraint" rptr{btGeneric6DofConstraint} createGeneric6DofConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameB_2);
  public function extern "createGeneric6DofConstraint" rptr{btGeneric6DofConstraint} createGeneric6DofConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
  public function extern "createScaledTrangleMeshShape" rptr{btScaledBvhTriangleMeshShape} createScaledTrangleMeshShape(rptr{btBvhTriangleMeshShape} meshShape_0, btVector3 const& localScalingbtBvhTriangleMeshShape_1);
  public function extern "createSliderConstraint" rptr{btSliderConstraint} createSliderConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
  public function extern "createSliderConstraint" rptr{btSliderConstraint} createSliderConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameA_2);
  public function extern "createConeShapeZ" rptr{btCollisionShape} createConeShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "getNameForPointer" crptr{char} getNameForPointer(crptr{void} ptr_0) const;
  public function extern "getNumCollisionShapes" int getNumCollisionShapes() const;
  public function extern "getBvhByIndex" rptr{btOptimizedBvh} getBvhByIndex(int index_0) const;
  public function extern "deleteAllData" void deleteAllData();
  public function extern "getNumRigidBodies" int getNumRigidBodies() const;
  public function extern "createMeshInterface" rptr{btTriangleIndexVertexArray} createMeshInterface(btStridingMeshInterfaceData mutable& meshData_0);
}
public metafunction size_type int;
/* notdefined [_2751] $VAR1 = {
          'bases' => '',
          'mangled' => '12GIM_BVH_DATA',
          'sort' => 'Struct',
          'artificial' => '1',
          'context' => '_1',
          'members' => '_15700 _15701 _15702 _15703 _15704 _15705 ',
          'name' => 'GIM_BVH_DATA',
          'file' => 'f75',
          'demangled' => 'GIM_BVH_DATA',
          'location' => 'f75:80',
          'id' => '_2751',
          'line' => '80',
          'size' => '288',
          'align' => '32'
        };
*/
/* notdefined [_2166] $VAR1 = {
          'id' => '_2166',
          'location' => 'f10:54',
          'line' => '54',
          'demangled' => 'SoftBodyFaceData',
          'align' => '64',
          'size' => '320',
          'file' => 'f10',
          'artificial' => '1',
          'name' => 'SoftBodyFaceData',
          'context' => '_1',
          'members' => '_14310 _14311 _14312 _14313 _14314 _14315 _14316 _14317 ',
          'sort' => 'Struct',
          'mangled' => '16SoftBodyFaceData',
          'bases' => ''
        };
*/
/* notdefined [_21579] $VAR1 = {
          'align' => '32',
          'size' => '32',
          'location' => 'f61:111',
          'id' => '_21579',
          'line' => '111',
          'file' => 'f61',
          'EnumValue' => [
                         {
                           'init' => '0',
                           'name' => 'Positions'
                         },
                         {
                           'name' => 'Velocities',
                           'init' => '1'
                         },
                         {
                           'name' => 'Default',
                           'init' => '0'
                         },
                         {
                           'init' => '1',
                           'name' => 'END'
                         }
                       ],
          'context' => '_12270',
          'name' => '_',
          'artificial' => '1',
          'access' => 'public',
          'sort' => 'Enumeration'
        };
*/
/* notdefined [_1467] $VAR1 = {
          'bases' => '',
          'mangled' => '17GIM_BVH_TREE_NODE',
          'sort' => 'Class',
          'artificial' => '1',
          'context' => '_1',
          'members' => '_11781 _11782 _11783 _11784 _11785 _11786 _11787 _11788 _11789 _11790 _11791 ',
          'name' => 'GIM_BVH_TREE_NODE',
          'file' => 'f75',
          'demangled' => 'GIM_BVH_TREE_NODE',
          'location' => 'f75:87',
          'id' => '_1467',
          'line' => '87',
          'size' => '288',
          'align' => '32'
        };
*/
/* notdefined [_309] $VAR1 = {
          'artificial' => '1',
          'name' => 'GIM_BVH_DATA_ARRAY',
          'members' => '_4150 _4151 _4152 _4153 ',
          'context' => '_1',
          'sort' => 'Class',
          'Base' => {
                    'access' => 'public',
                    'type' => '_1233',
                    'offset' => '0',
                    'virtual' => '0'
                  },
          'mangled' => '18GIM_BVH_DATA_ARRAY',
          'bases' => '_1233 ',
          'line' => '131',
          'id' => '_309',
          'location' => 'f75:131',
          'demangled' => 'GIM_BVH_DATA_ARRAY',
          'size' => '256',
          'align' => '64',
          'file' => 'f75'
        };
*/
/* notdefined [_13902] $VAR1 = {
          'name' => 'BufferTypes',
          'context' => '_2091',
          'artificial' => '1',
          'sort' => 'Enumeration',
          'access' => 'public',
          'align' => '32',
          'size' => '32',
          'line' => '23',
          'id' => '_13902',
          'location' => 'f58:23',
          'EnumValue' => [
                         {
                           'init' => '0',
                           'name' => 'CPU_BUFFER'
                         },
                         {
                           'init' => '1',
                           'name' => 'DX11_BUFFER'
                         },
                         {
                           'name' => 'OPENGL_BUFFER',
                           'init' => '2'
                         }
                       ],
          'file' => 'f58'
        };
*/
/* notdefined [_137] $VAR1 = {
          'bases' => '',
          'mangled' => '16SoftBodyPoseData',
          'sort' => 'Struct',
          'artificial' => '1',
          'name' => 'SoftBodyPoseData',
          'context' => '_1',
          'members' => '_3900 _3901 _3902 _3903 _3904 _3905 _3906 _3907 _3908 _3909 _3910 _3911 _3912 _3913 _3914 _3915 ',
          'file' => 'f10',
          'demangled' => 'SoftBodyPoseData',
          'line' => '115',
          'id' => '_137',
          'location' => 'f10:115',
          'align' => '64',
          'size' => '1600'
        };
*/
/* notdefined [_2191] $VAR1 = {
          'name' => 'GrahamVector3',
          'context' => '_1',
          'members' => '_14344 _14345 _14346 _14347 _14348 _14349 ',
          'artificial' => '1',
          'Base' => {
                    'virtual' => '0',
                    'offset' => '0',
                    'type' => '_2095',
                    'access' => 'public'
                  },
          'bases' => '_2095 ',
          'mangled' => '13GrahamVector3',
          'sort' => 'Struct',
          'align' => '32',
          'size' => '192',
          'demangled' => 'GrahamVector3',
          'location' => 'f148:25',
          'id' => '_2191',
          'line' => '25',
          'file' => 'f148'
        };
*/
/* notdefined [_859] $VAR1 = {
          'artificial' => '1',
          'context' => '_1',
          'name' => 'eGIMPACT_SHAPE_TYPE',
          'sort' => 'Enumeration',
          'location' => 'f48:46',
          'id' => '_859',
          'line' => '46',
          'size' => '32',
          'align' => '32',
          'EnumValue' => [
                         {
                           'name' => 'CONST_GIMPACT_COMPOUND_SHAPE',
                           'init' => '0'
                         },
                         {
                           'name' => 'CONST_GIMPACT_TRIMESH_SHAPE_PART',
                           'init' => '1'
                         },
                         {
                           'name' => 'CONST_GIMPACT_TRIMESH_SHAPE',
                           'init' => '2'
                         }
                       ],
          'file' => 'f48'
        };
*/
/* notdefined [_4985] $VAR1 = {
          'artificial' => '1',
          'context' => '_12269',
          'name' => '_',
          'access' => 'public',
          'sort' => 'Enumeration',
          'location' => 'f61:102',
          'id' => '_4985',
          'line' => '102',
          'size' => '32',
          'align' => '32',
          'file' => 'f61',
          'EnumValue' => [
                         {
                           'name' => 'Linear',
                           'init' => '0'
                         },
                         {
                           'init' => '1',
                           'name' => 'Anchors'
                         },
                         {
                           'init' => '2',
                           'name' => 'RContacts'
                         },
                         {
                           'name' => 'SContacts',
                           'init' => '3'
                         },
                         {
                           'init' => '4',
                           'name' => 'END'
                         }
                       ]
        };
*/
/* notdefined [_2648] $VAR1 = {
          'artificial' => '1',
          'context' => '_1',
          'name' => 'CHull',
          'members' => '_15537 _15538 _15539 _15540 _15541 _15542 _15543 _15544 _15545 _15546 ',
          'bases' => '',
          'mangled' => '5CHull',
          'sort' => 'Class',
          'demangled' => 'CHull',
          'id' => '_2648',
          'line' => '47',
          'location' => 'f175:47',
          'align' => '64',
          'size' => '320',
          'file' => 'f175'
        };
*/
/* notdefined [_7000] $VAR1 = {
          'context' => '_817',
          'name' => 'bStructHandle',
          'sort' => 'Typedef',
          'type' => '_6999',
          'line' => '33',
          'location' => 'f279:33',
          'id' => '_7000',
          'file' => 'f279'
        };
*/
/* notdefined [_21566] $VAR1 = {
          'EnumValue' => [
                         {
                           'init' => '0',
                           'name' => 'V_Point'
                         },
                         {
                           'name' => 'V_TwoSided',
                           'init' => '1'
                         },
                         {
                           'init' => '2',
                           'name' => 'V_TwoSidedLiftDrag'
                         },
                         {
                           'name' => 'V_OneSided',
                           'init' => '3'
                         },
                         {
                           'name' => 'F_TwoSided',
                           'init' => '4'
                         },
                         {
                           'name' => 'F_TwoSidedLiftDrag',
                           'init' => '5'
                         },
                         {
                           'init' => '6',
                           'name' => 'F_OneSided'
                         },
                         {
                           'init' => '7',
                           'name' => 'END'
                         }
                       ],
          'file' => 'f61',
          'line' => '84',
          'id' => '_21566',
          'location' => 'f61:84',
          'align' => '32',
          'size' => '32',
          'sort' => 'Enumeration',
          'access' => 'public',
          'artificial' => '1',
          'context' => '_12267',
          'name' => '_'
        };
*/
/* notdefined [_902] $VAR1 = {
          'artificial' => '1',
          'name' => 'SoftBodyClusterData',
          'members' => '_7246 _7247 _7248 _7249 _7250 _7251 _7252 _7253 _7254 _7255 _7256 _7257 _7258 _7259 _7260 _7261 _7262 _7263 _7264 _7265 _7266 _7267 _7268 _7269 _7270 _7271 _7272 _7273 _7274 _7275 _7276 ',
          'context' => '_1',
          'bases' => '',
          'mangled' => '19SoftBodyClusterData',
          'sort' => 'Struct',
          'demangled' => 'SoftBodyClusterData',
          'id' => '_902',
          'location' => 'f10:133',
          'line' => '133',
          'align' => '64',
          'size' => '2880',
          'file' => 'f10'
        };
*/
/* notdefined [_5005] $VAR1 = {
          'file' => 'f61',
          'EnumValue' => [
                         {
                           'name' => 'Linear',
                           'init' => '0'
                         },
                         {
                           'init' => '1',
                           'name' => 'END'
                         }
                       ],
          'line' => '96',
          'id' => '_5005',
          'location' => 'f61:96',
          'align' => '32',
          'size' => '32',
          'access' => 'public',
          'sort' => 'Enumeration',
          'artificial' => '1',
          'context' => '_12268',
          'name' => '_'
        };
*/
/* notdefined [_1721] $VAR1 = {
          'sort' => 'Enumeration',
          'artificial' => '1',
          'context' => '_1',
          'name' => 'eBT_PLANE_INTERSECTION_TYPE',
          'file' => 'f44',
          'EnumValue' => [
                         {
                           'name' => 'BT_CONST_BACK_PLANE',
                           'init' => '0'
                         },
                         {
                           'init' => '1',
                           'name' => 'BT_CONST_COLLIDE_PLANE'
                         },
                         {
                           'init' => '2',
                           'name' => 'BT_CONST_FRONT_PLANE'
                         }
                       ],
          'location' => 'f44:51',
          'id' => '_1721',
          'line' => '51',
          'align' => '32',
          'size' => '32'
        };
*/
/* notdefined [_1063] $VAR1 = {
          'name' => 'SoftBodyTetraData',
          'context' => '_1',
          'members' => '_7688 _7689 _7690 _7691 _7692 _7693 _7694 _7695 _7696 _7697 _7698 ',
          'artificial' => '1',
          'mangled' => '17SoftBodyTetraData',
          'bases' => '',
          'sort' => 'Struct',
          'align' => '64',
          'size' => '832',
          'demangled' => 'SoftBodyTetraData',
          'line' => '62',
          'id' => '_1063',
          'location' => 'f10:62',
          'file' => 'f10'
        };
*/
/* notdefined [_3919] $VAR1 = {
          'file' => 'f49',
          'EnumValue' => [
                         {
                           'init' => '0',
                           'name' => 'DEFAULT_SOLVER'
                         },
                         {
                           'init' => '1',
                           'name' => 'CPU_SOLVER'
                         },
                         {
                           'init' => '2',
                           'name' => 'CL_SOLVER'
                         },
                         {
                           'init' => '3',
                           'name' => 'CL_SIMD_SOLVER'
                         },
                         {
                           'init' => '4',
                           'name' => 'DX_SOLVER'
                         },
                         {
                           'init' => '5',
                           'name' => 'DX_SIMD_SOLVER'
                         }
                       ],
          'size' => '32',
          'align' => '32',
          'location' => 'f49:33',
          'id' => '_3919',
          'line' => '33',
          'access' => 'public',
          'sort' => 'Enumeration',
          'context' => '_142',
          'name' => 'SolverTypes',
          'artificial' => '1'
        };
*/
/* notdefined [_2775] $VAR1 = {
          'align' => '32',
          'size' => '2240',
          'id' => '_2775',
          'location' => 'f159:39',
          'line' => '39',
          'demangled' => 'GIM_TRIANGLE_CONTACT',
          'file' => 'f159',
          'name' => 'GIM_TRIANGLE_CONTACT',
          'context' => '_1',
          'members' => '_15784 _15785 _15786 _15787 _15788 _15789 _15790 _15791 _15792 _15793 ',
          'artificial' => '1',
          'sort' => 'Struct',
          'bases' => '',
          'mangled' => '20GIM_TRIANGLE_CONTACT'
        };
*/
/* notdefined [_19813] $VAR1 = {
          'access' => 'public',
          'sort' => 'Enumeration',
          'context' => '_3582',
          'name' => 'eStatus',
          'artificial' => '1',
          'file' => 'f23',
          'EnumValue' => [
                         {
                           'init' => '0',
                           'name' => 'Separated'
                         },
                         {
                           'name' => 'Penetrating',
                           'init' => '1'
                         },
                         {
                           'name' => 'GJK_Failed',
                           'init' => '2'
                         },
                         {
                           'name' => 'EPA_Failed',
                           'init' => '3'
                         }
                       ],
          'align' => '32',
          'size' => '32',
          'location' => 'f23:35',
          'id' => '_19813',
          'line' => '35'
        };
*/
/* notdefined [_19] $VAR1 = {
          'artificial' => '1',
          'members' => '_3430 _3431 _3432 _3433 _3434 _3435 _3436 _3437 _3438 _3439 _3440 _3441 _3442 _3443 ',
          'context' => '_1',
          'name' => 'SoftBodyNodeData',
          'sort' => 'Struct',
          'mangled' => '16SoftBodyNodeData',
          'bases' => '',
          'location' => 'f10:32',
          'id' => '_19',
          'line' => '32',
          'demangled' => 'SoftBodyNodeData',
          'align' => '64',
          'size' => '832',
          'file' => 'f10'
        };
*/
/* notdefined [_1873] $VAR1 = {
          'mangled' => '26BT_BOX_BOX_TRANSFORM_CACHE',
          'bases' => '',
          'sort' => 'Class',
          'name' => 'BT_BOX_BOX_TRANSFORM_CACHE',
          'context' => '_1',
          'members' => '_13137 _13138 _13139 _13140 _13141 _13142 _13143 _13144 _13145 _13146 _13147 ',
          'artificial' => '1',
          'file' => 'f44',
          'size' => '896',
          'align' => '32',
          'demangled' => 'BT_BOX_BOX_TRANSFORM_CACHE',
          'id' => '_1873',
          'line' => '162',
          'location' => 'f44:162'
        };
*/
/* notdefined [_6995] $VAR1 = {
          'demangled' => 'bParse::btBulletFile',
          'id' => '_6995',
          'line' => '32',
          'location' => 'f233:32',
          'align' => '64',
          'size' => '6720',
          'file' => 'f233',
          'artificial' => '1',
          'name' => 'btBulletFile',
          'members' => '_20602 _20603 _20604 _20605 _20606 _20607 _20608 _20609 _20610 _20611 _20612 _20613 _20614 _20615 _20616 _20617 _20618 _20619 _20620 _20621 _20622 _20623 ',
          'context' => '_817',
          'Base' => {
                    'virtual' => '0',
                    'offset' => '0',
                    'access' => 'public',
                    'type' => '_7002'
                  },
          'bases' => '_7002 ',
          'mangled' => 'N6bParse12btBulletFileE',
          'sort' => 'Class'
        };
*/
/* notdefined [_21584] $VAR1 = {
          'EnumValue' => [
                         {
                           'init' => '0',
                           'name' => 'None'
                         },
                         {
                           'init' => '1',
                           'name' => 'Node'
                         },
                         {
                           'name' => 'Link',
                           'init' => '2'
                         },
                         {
                           'name' => 'Face',
                           'init' => '3'
                         },
                         {
                           'init' => '4',
                           'name' => 'Tetra'
                         },
                         {
                           'init' => '5',
                           'name' => 'END'
                         }
                       ],
          'file' => 'f61',
          'align' => '32',
          'size' => '32',
          'line' => '119',
          'id' => '_21584',
          'location' => 'f61:119',
          'sort' => 'Enumeration',
          'access' => 'public',
          'context' => '_12271',
          'name' => '_',
          'artificial' => '1'
        };
*/
/* notdefined [_520] $VAR1 = {
          'align' => '64',
          'size' => '768',
          'demangled' => 'SoftRigidAnchorData',
          'line' => '73',
          'id' => '_520',
          'location' => 'f10:73',
          'file' => 'f10',
          'members' => '_6311 _6312 _6313 _6314 _6315 _6316 _6317 _6318 _6319 _6320 ',
          'name' => 'SoftRigidAnchorData',
          'context' => '_1',
          'artificial' => '1',
          'bases' => '',
          'mangled' => '19SoftRigidAnchorData',
          'sort' => 'Struct'
        };
*/
/* notdefined [_65] $VAR1 = {
          'align' => '32',
          'size' => '128',
          'id' => '_65',
          'location' => 'f26:37',
          'line' => '37',
          'demangled' => 'BT_QUANTIZED_BVH_NODE',
          'file' => 'f26',
          'context' => '_1',
          'name' => 'BT_QUANTIZED_BVH_NODE',
          'members' => '_3604 _3605 _3606 _3607 _3608 _3609 _3610 _3611 _3612 _3613 _3614 _3615 _3616 ',
          'artificial' => '1',
          'sort' => 'Struct',
          'mangled' => '21BT_QUANTIZED_BVH_NODE',
          'bases' => ''
        };
*/
/* notdefined [_998] $VAR1 = {
          'mangled' => '8GIM_PAIR',
          'bases' => '',
          'sort' => 'Struct',
          'members' => '_7531 _7532 _7533 _7534 _7535 _7536 _7537 ',
          'context' => '_1',
          'name' => 'GIM_PAIR',
          'artificial' => '1',
          'file' => 'f75',
          'size' => '64',
          'align' => '32',
          'demangled' => 'GIM_PAIR',
          'line' => '39',
          'id' => '_998',
          'location' => 'f75:39'
        };
*/
/* notdefined [_4454] $VAR1 = {
          'size' => '192',
          'align' => '64',
          'demangled' => 'bParse::bNameInfo',
          'id' => '_4454',
          'location' => 'f277:25',
          'line' => '25',
          'file' => 'f277',
          'context' => '_817',
          'members' => '_19997 _19998 _19999 _20000 _20001 _20002 _20003 _20004 ',
          'name' => 'bNameInfo',
          'artificial' => '1',
          'mangled' => 'N6bParse9bNameInfoE',
          'bases' => '',
          'sort' => 'Struct'
        };
*/
/* notdefined [_973] $VAR1 = {
          'file' => 'f10',
          'demangled' => 'SoftBodyMaterialData',
          'line' => '24',
          'id' => '_973',
          'location' => 'f10:24',
          'size' => '128',
          'align' => '32',
          'mangled' => '20SoftBodyMaterialData',
          'bases' => '',
          'sort' => 'Struct',
          'artificial' => '1',
          'name' => 'SoftBodyMaterialData',
          'members' => '_7421 _7422 _7423 _7424 _7425 _7426 _7427 _7428 ',
          'context' => '_1'
        };
*/
/* notdefined [_4474] $VAR1 = {
          'artificial' => '1',
          'members' => '_20008 _20009 _20010 _20011 _20012 _20013 _20014 _20015 _20016 ',
          'context' => '_817',
          'name' => 'bChunkInd',
          'mangled' => 'N6bParse9bChunkIndE',
          'bases' => '',
          'sort' => 'Class',
          'demangled' => 'bParse::bChunkInd',
          'id' => '_4474',
          'line' => '63',
          'location' => 'f278:63',
          'size' => '192',
          'align' => '64',
          'file' => 'f278'
        };
*/
/* notdefined [_2815] $VAR1 = {
          'sort' => 'Struct',
          'mangled' => '16SoftBodyLinkData',
          'bases' => '',
          'artificial' => '1',
          'context' => '_1',
          'name' => 'SoftBodyLinkData',
          'members' => '_15880 _15881 _15882 _15883 _15884 _15885 _15886 _15887 ',
          'file' => 'f10',
          'location' => 'f10:46',
          'id' => '_2815',
          'line' => '46',
          'demangled' => 'SoftBodyLinkData',
          'align' => '64',
          'size' => '192'
        };
*/
/* notdefined [_24292] $VAR1 = {
          'name' => '_',
          'context' => '_21729',
          'artificial' => '1',
          'access' => 'public',
          'sort' => 'Enumeration',
          'size' => '32',
          'align' => '32',
          'location' => 'f61:485',
          'id' => '_24292',
          'line' => '485',
          'file' => 'f61',
          'EnumValue' => [
                         {
                           'init' => '0',
                           'name' => 'Linear'
                         },
                         {
                           'init' => '1',
                           'name' => 'Angular'
                         },
                         {
                           'init' => '2',
                           'name' => 'Contact'
                         }
                       ]
        };
*/
/* notdefined [_1392] $VAR1 = {
          'name' => 'SoftBodyConfigData',
          'members' => '_11473 _11474 _11475 _11476 _11477 _11478 _11479 _11480 _11481 _11482 _11483 _11484 _11485 _11486 _11487 _11488 _11489 _11490 _11491 _11492 _11493 _11494 _11495 _11496 _11497 _11498 _11499 _11500 _11501 _11502 ',
          'context' => '_1',
          'artificial' => '1',
          'sort' => 'Struct',
          'mangled' => '18SoftBodyConfigData',
          'bases' => '',
          'align' => '32',
          'size' => '832',
          'id' => '_1392',
          'line' => '85',
          'location' => 'f10:85',
          'demangled' => 'SoftBodyConfigData',
          'file' => 'f10'
        };
*/
public threaded function extern "::btSoftBody::clusterVAImpulse" "nocdecl" void btSoftBody_clusterVAImpulse(rptr{btSoftBody_Cluster} cluster_0, btVector3 const& impulse_1);
public threaded function extern "::btPersistentManifold" "nocdecl" btPersistentManifold btPersistentManifold5(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1, int _2, btScalar contactBreakingThreshold_3, btScalar contactProcessingThreshold_4);
public threaded function extern "::btBoxBoxCollisionAlgorithm" "nocdecl" btBoxBoxCollisionAlgorithm btBoxBoxCollisionAlgorithm4(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3);
public threaded function extern "::btBoxBoxCollisionAlgorithm" "nocdecl" btBoxBoxCollisionAlgorithm btBoxBoxCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public threaded function extern "::btCollisionWorld::LocalConvexResult" "nocdecl" btCollisionWorld_LocalConvexResult btCollisionWorld_LocalConvexResult5(crptr{btCollisionObject} hitCollisionObject_0, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo_1, btVector3 const& hitNormalLocal_2, btVector3 const& hitPointLocal_3, btScalar hitFraction_4);
public threaded function extern "::btQuantizedBvh::deSerializeInPlace" "nocdecl" rptr{btQuantizedBvh} btQuantizedBvh_deSerializeInPlace(rptr{void} i_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2);
public threaded function extern "::btSoftBody::clusterVImpulse" "nocdecl" void btSoftBody_clusterVImpulse(rptr{btSoftBody_Cluster} cluster_0, btVector3 const& rpos_1, btVector3 const& impulse_2);
public threaded function extern "::btTransformUtil::calculateVelocity" "nocdecl" void btTransformUtil_calculateVelocity(btTransform const& transform0_0, btTransform const& transform1_1, btScalar timeStep_2, btVector3 mutable& linVel_3, btVector3 mutable& angVel_4);
public threaded function extern "::btBroadphaseProxy::isConvex" "nocdecl" bool btBroadphaseProxy_isConvex(int proxyType_0);
public threaded function extern "::btSoftBody::PSolve_Anchors" "nocdecl" void btSoftBody_PSolve_Anchors(rptr{btSoftBody} psb_0, btScalar kst_1, btScalar ti_2);
public threaded function extern "::btSwapEndianFloat" uint btSwapEndianFloat(float d_0);
public threaded function extern "::btTransformUtil::calculateDiffAxisAngleQuaternion" "nocdecl" void btTransformUtil_calculateDiffAxisAngleQuaternion(btQuaternion const& orn0_0, btQuaternion const& orn1a_1, btVector3 mutable& axis_2, btScalar mutable& angle_3);
public threaded function extern "::btConeShapeX" "nocdecl" btConeShapeX btConeShapeX2(btScalar radius_0, btScalar height_1);
public threaded function extern "::btGjkEpaSolver2::Distance" "nocdecl" bool btGjkEpaSolver2_Distance(crptr{btConvexShape} shape0_0, btTransform const& wtrs0_1, crptr{btConvexShape} shape1_2, btTransform const& wtrs1_3, btVector3 const& guess_4, btGjkEpaSolver2_sResults mutable& results_5);
public threaded function extern "::bt_edge_plane" void bt_edge_plane(btVector3 const& e1_0, btVector3 const& e2_1, btVector3 const& normal_2, btVector4 mutable& plane_3);
public threaded function extern "::btGjkEpaSolver2::SignedDistance" "nocdecl" bool btGjkEpaSolver2_SignedDistance6(crptr{btConvexShape} shape0_0, btTransform const& wtrs0_1, crptr{btConvexShape} shape1_2, btTransform const& wtrs1_3, btVector3 const& guess_4, btGjkEpaSolver2_sResults mutable& results_5);
public threaded function extern "::btGjkEpaSolver2::SignedDistance" "nocdecl" btScalar btGjkEpaSolver2_SignedDistance5(btVector3 const& position_0, btScalar margin_1, crptr{btConvexShape} shape_2, btTransform const& wtrs_3, btGjkEpaSolver2_sResults mutable& results_4);
public threaded function extern "::btDot" btScalar btDot(btVector3 const& v1_0, btVector3 const& v2_1);
public threaded function extern "::btGearConstraint" "nocdecl" btGearConstraint btGearConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& axisInA_2, btVector3 const& axisInB_3, btScalar ratio_4);
public threaded function extern "::btCapsuleShapeX" "nocdecl" btCapsuleShapeX btCapsuleShapeX2(btScalar radius_0, btScalar height_1);
public threaded function extern "::btShapeHull" "nocdecl" btShapeHull btShapeHull1(crptr{btConvexShape} shape_0);
public threaded function extern "::btSoftBody::clusterCom" "nocdecl" btVector3 btSoftBody_clusterCom(crptr{btSoftBody_Cluster} cluster_0);
public threaded function extern "::btBroadphaseProxy" "nocdecl" btBroadphaseProxy btBroadphaseProxy6(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} userPtr_2, short collisionFilterGroup_3, short collisionFilterMask_4, rptr{void} multiSapParentProxy_5);
public threaded function extern "::btLog" btScalar btLog(btScalar x_0);
public threaded function extern "::bt_plane_clip_triangle" int bt_plane_clip_triangle(btVector4 const& plane_0, btVector3 const& point0_1, btVector3 const& point1_2, btVector3 const& point2_3, rptr{btVector3} clipped_4);
public threaded function extern "::btSoftRigidCollisionAlgorithm" "nocdecl" btSoftRigidCollisionAlgorithm btSoftRigidCollisionAlgorithm5(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} col0_2, crptr{btCollisionObjectWrapper} col1Wrap_3, bool isSwapped_4);
public threaded function extern "::btAabbSupport" btVector3 btAabbSupport(btVector3 const& halfExtents_0, btVector3 const& supportDir_1);
public threaded function extern "::btSphereSphereCollisionAlgorithm" "nocdecl" btSphereSphereCollisionAlgorithm btSphereSphereCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public threaded function extern "::btSphereSphereCollisionAlgorithm" "nocdecl" btSphereSphereCollisionAlgorithm btSphereSphereCollisionAlgorithm4(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} col0Wrap_2, crptr{btCollisionObjectWrapper} col1Wrap_3);
public threaded function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3, bool useReferenceFrameA_4);
public threaded function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint3(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1, bool useReferenceFrameA_2);
public threaded function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint4(btRigidBody mutable& rbA_0, btVector3 const& pivotInA_1, btVector3 const& axisInA_2, bool useReferenceFrameA_3);
public threaded function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint7(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3, btVector3 const& axisInA_4, btVector3 const& axisInB_5, bool useReferenceFrameA_6);
public threaded function extern "::btSoftBodyHelpers::DrawFaceTree" "nocdecl" void btSoftBodyHelpers_DrawFaceTree(rptr{btSoftBody} psb_0, rptr{btIDebugDraw} idraw_1, int mindepth_2, int maxdepth_3);
public threaded function extern "::btDefaultMotionState" "nocdecl" btDefaultMotionState btDefaultMotionState2(btTransform const& startTrans_0, btTransform const& centerOfMassOffset_1);
public threaded function extern "::btPoint2PointConstraint" "nocdecl" btPoint2PointConstraint btPoint2PointConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3);
public threaded function extern "::btPoint2PointConstraint" "nocdecl" btPoint2PointConstraint btPoint2PointConstraint2(btRigidBody mutable& rbA_0, btVector3 const& pivotInA_1);
public threaded function extern "::btDefaultSerializer" "nocdecl" btDefaultSerializer btDefaultSerializer1(int totalSize_0);
public threaded function extern "::btGjkEpaSolver2::Penetration" "nocdecl" bool btGjkEpaSolver2_Penetration(crptr{btConvexShape} shape0_0, btTransform const& wtrs0_1, crptr{btConvexShape} shape1_2, btTransform const& wtrs1_3, btVector3 const& guess_4, btGjkEpaSolver2_sResults mutable& results_5, bool usemargins_6);
public threaded function extern "::btGImpactCompoundShape::CompoundPrimitiveManager" "nocdecl" btGImpactCompoundShape_CompoundPrimitiveManager btGImpactCompoundShape_CompoundPrimitiveManager1(rptr{btGImpactCompoundShape} compoundShape_0);
public threaded function extern "::btAlignedFreeInternal" void btAlignedFreeInternal(rptr{void} ptr_0);
public threaded function extern "::btDbvtAabbMm::FromCR" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromCR(btVector3 const& c_0, btScalar r_1);
public threaded function extern "::btGeometryUtil::areVerticesBehindPlane" "nocdecl" bool btGeometryUtil_areVerticesBehindPlane(btVector3 const& planeNormal_0, btAlignedObjectArray_btVector3 const& vertices_1, btScalar margin_2);
public threaded function extern "::btDbvt::nearest" "nocdecl" int btDbvt_nearest(crptr{int} i_0, crptr{btDbvt_sStkNPS} a_1, btScalar v_2, int l_3, int h_4);
public threaded function extern "::btMultiSapBroadphase::btMultiSapProxy" "nocdecl" btMultiSapBroadphase_btMultiSapProxy btMultiSapBroadphase_btMultiSapProxy6(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5);
public threaded function extern "::btSolve2LinearConstraint" "nocdecl" btSolve2LinearConstraint btSolve2LinearConstraint2(btScalar tau_0, btScalar damping_1);
public threaded function extern "::btFmod" btScalar btFmod(btScalar x_0, btScalar y_1);
public threaded function extern "::btSoftBodyHelpers::CreateFromTetGenData" "nocdecl" rptr{btSoftBody} btSoftBodyHelpers_CreateFromTetGenData(btSoftBodyWorldInfo mutable& worldInfo_0, crptr{char} ele_1, crptr{char} face_2, crptr{char} node_3, bool bfacelinks_4, bool btetralinks_5, bool bfacesfromtetras_6);
public threaded function extern "::btBox2dShape" "nocdecl" btBox2dShape btBox2dShape1(btVector3 const& boxHalfExtents_0);
public threaded function extern "::btDbvtProxy" "nocdecl" btDbvtProxy btDbvtProxy5(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} userPtr_2, short collisionFilterGroup_3, short collisionFilterMask_4);
public threaded function extern "::btSliderConstraint" "nocdecl" btSliderConstraint btSliderConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
public threaded function extern "::btSliderConstraint" "nocdecl" btSliderConstraint btSliderConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameA_2);
public threaded function extern "::btDbvtAabbMm::FromMM" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromMM(btVector3 const& mi_0, btVector3 const& mx_1);
public threaded function extern "::btDbvt::collideTU" "nocdecl" void btDbvt_collideTU(crptr{btDbvtNode} root_0, btDbvt_ICollide mutable& policy_1);
public threaded function extern "::btSimpleBroadphase" "nocdecl" btSimpleBroadphase btSimpleBroadphase2(int maxProxies_0, rptr{btOverlappingPairCache} overlappingPairCache_1);
public threaded function extern "::btDbvt::allocate" "nocdecl" int btDbvt_allocate(btAlignedObjectArray_int mutable& ifree_0, btAlignedObjectArray_btDbvt_sStkNPS mutable& stock_1, btDbvt_sStkNPS const& value_2);
public threaded function extern "::btMaterial" "nocdecl" btMaterial btMaterial2(btScalar fric_0, btScalar rest_1);
public threaded function extern "::btGenerateInternalEdgeInfo" void btGenerateInternalEdgeInfo(rptr{btBvhTriangleMeshShape} trimeshShape_0, rptr{btTriangleInfoMap} triangleInfoMap_1);
public threaded function extern "::btCompoundCompoundCollisionAlgorithm" "nocdecl" btCompoundCompoundCollisionAlgorithm btCompoundCompoundCollisionAlgorithm4(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public threaded function extern "::btConeShapeZ" "nocdecl" btConeShapeZ btConeShapeZ2(btScalar radius_0, btScalar height_1);
public threaded function extern "::btContactConstraint" "nocdecl" btContactConstraint btContactConstraint3(rptr{btPersistentManifold} contactManifold_0, btRigidBody mutable& rbA_1, btRigidBody mutable& rbB_2);
public threaded function extern "::btMultimaterialTriangleMeshShape" "nocdecl" btMultimaterialTriangleMeshShape btMultimaterialTriangleMeshShape5(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, btVector3 const& bvhAabbMin_2, btVector3 const& bvhAabbMax_3, bool buildBvh_4);
public threaded function extern "::btMultimaterialTriangleMeshShape" "nocdecl" btMultimaterialTriangleMeshShape btMultimaterialTriangleMeshShape3(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, bool buildBvh_2);
public threaded function extern "::btBroadphaseProxy::isPolyhedral" "nocdecl" bool btBroadphaseProxy_isPolyhedral(int proxyType_0);
public threaded function extern "::btDefaultVehicleRaycaster" "nocdecl" btDefaultVehicleRaycaster btDefaultVehicleRaycaster1(rptr{btDynamicsWorld} world_0);
public threaded function extern "::btManifoldResult" "nocdecl" btManifoldResult btManifoldResult2(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1);
public threaded function extern "::btDbvtAabbMm::FromCE" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromCE(btVector3 const& c_0, btVector3 const& e_1);
public threaded function extern "::btSwapVector3Endian" void btSwapVector3Endian(btVector3 const& sourceVec_0, btVector3 mutable& destVec_1);
public threaded function extern "::btConvexTriangleMeshShape" "nocdecl" btConvexTriangleMeshShape btConvexTriangleMeshShape2(rptr{btStridingMeshInterface} meshInterface_0, bool calcAabb_1);
public threaded function extern "::btUnswapEndianDouble" double btUnswapEndianDouble(crptr{uchar} src_0);
public threaded function extern "::btSoftBodyHelpers::DrawInfos" "nocdecl" void btSoftBodyHelpers_DrawInfos(rptr{btSoftBody} psb_0, rptr{btIDebugDraw} idraw_1, bool masses_2, bool areas_3, bool stress_4);
public threaded function extern "::btDiscreteDynamicsWorld" "nocdecl" btDiscreteDynamicsWorld btDiscreteDynamicsWorld4(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3);
public threaded function extern "::btAdjustInternalEdgeContacts" void btAdjustInternalEdgeContacts(btManifoldPoint mutable& cp_0, crptr{btCollisionObjectWrapper} trimeshColObj0Wrap_1, crptr{btCollisionObjectWrapper} otherColObj1Wrap_2, int partId0_3, int index0_4, int normalAdjustFlags_5);
public threaded function extern "::btConvexConvexAlgorithm" "nocdecl" btConvexConvexAlgorithm btConvexConvexAlgorithm8(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, rptr{btVoronoiSimplexSolver} simplexSolver_4, rptr{btConvexPenetrationDepthSolver} pdSolver_5, int numPerturbationIterations_6, int minimumPointsPerturbationThreshold_7);
public threaded function extern "::btVector3" "nocdecl" btVector3 btVector3_3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
public threaded function extern "::btCompoundShape" "nocdecl" btCompoundShape btCompoundShape1(bool enableDynamicAabbTree_0);
public threaded function extern "::btTriangleIndexVertexArray" "nocdecl" btTriangleIndexVertexArray btTriangleIndexVertexArray6(int numTriangles_0, rptr{int} triangleIndexBase_1, int triangleIndexStride_2, int numVertices_3, rptr{btScalar} vertexBase_4, int vertexStride_5);
public threaded function extern "::btConvex2dConvex2dAlgorithm::CreateFunc" "nocdecl" btConvex2dConvex2dAlgorithm_CreateFunc btConvex2dConvex2dAlgorithm_CreateFunc2(rptr{btVoronoiSimplexSolver} simplexSolver_0, rptr{btConvexPenetrationDepthSolver} pdSolver_1);
public threaded function extern "::btSoftBodyHelpers::CreateEllipsoid" "nocdecl" rptr{btSoftBody} btSoftBodyHelpers_CreateEllipsoid(btSoftBodyWorldInfo mutable& worldInfo_0, btVector3 const& center_1, btVector3 const& radius_2, int res_3);
public threaded function extern "::btKinematicCharacterController" "nocdecl" btKinematicCharacterController btKinematicCharacterController4(rptr{btPairCachingGhostObject} ghostObject_0, rptr{btConvexShape} convexShape_1, btScalar stepHeight_2, int upAxis_3);
public threaded function extern "::btDistance2" btScalar btDistance2(btVector3 const& v1_0, btVector3 const& v2_1);
public threaded function extern "::btExp" btScalar btExp(btScalar x_0);
public threaded function extern "::btSoftClusterCollisionShape" "nocdecl" btSoftClusterCollisionShape btSoftClusterCollisionShape1(crptr{btSoftBody_Cluster} cluster_0);
public threaded function extern "::btDbvt::countLeaves" "nocdecl" int btDbvt_countLeaves(crptr{btDbvtNode} node_0);
public threaded function extern "::btConvexHullShape" "nocdecl" btConvexHullShape btConvexHullShape3(crptr{btScalar} points_0, int numPoints_1, int stride_2);
public threaded function extern "::btRaycastVehicle" "nocdecl" btRaycastVehicle btRaycastVehicle3(btRaycastVehicle_btVehicleTuning const& tuning_0, rptr{btRigidBody} chassis_1, rptr{btVehicleRaycaster} raycaster_2);
public threaded function extern "::btTransformUtil::calculateVelocityQuaternion" "nocdecl" void btTransformUtil_calculateVelocityQuaternion(btVector3 const& pos0_0, btVector3 const& pos1_1, btQuaternion const& orn0_2, btQuaternion const& orn1_3, btScalar timeStep_4, btVector3 mutable& linVel_5, btVector3 mutable& angVel_6);
public threaded function extern "::btDefaultCollisionConfiguration" "nocdecl" btDefaultCollisionConfiguration btDefaultCollisionConfiguration1(btDefaultCollisionConstructionInfo const& constructionInfo_0);
public threaded function extern "::bt_plane_clip_polygon" int bt_plane_clip_polygon(btVector4 const& plane_0, crptr{btVector3} polygon_points_1, int polygon_point_count_2, rptr{btVector3} clipped_3);
public threaded function extern "::btDynamicsWorld" "nocdecl" btDynamicsWorld btDynamicsWorld3(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} broadphase_1, rptr{btCollisionConfiguration} collisionConfiguration_2);
public threaded function extern "::btCos" btScalar btCos(btScalar x_0);
public threaded function extern "::btFuzzyZero" bool btFuzzyZero(btScalar x_0);
public threaded function extern "::btSoftBody::solveClusters" "nocdecl" void btSoftBody_solveClusters(btAlignedObjectArray_btSoftBody_p const& bodies_0);
public threaded function extern "::btHashInt" "nocdecl" btHashInt btHashInt1(int uid_0);
public threaded function extern "::btHashPtr" "nocdecl" btHashPtr btHashPtr1(crptr{void} ptr_0);
public threaded function extern "::btDbvt::collideKDOP" "nocdecl" void btDbvt_collideKDOP(crptr{btDbvtNode} root_0, crptr{btVector3} normals_1, crptr{btScalar} offsets_2, int count_3, btDbvt_ICollide mutable& policy_4);
public threaded function extern "::btTriangleShape" "nocdecl" btTriangleShape btTriangleShape3(btVector3 const& p0_0, btVector3 const& p1_1, btVector3 const& p2_2);
public threaded function extern "::btPolyhedralContactClipping::clipHullAgainstHull" "nocdecl" void btPolyhedralContactClipping_clipHullAgainstHull(btVector3 const& separatingNormal_0, btConvexPolyhedron const& hullA_1, btConvexPolyhedron const& hullB_2, btTransform const& transA_3, btTransform const& transB_4, btScalar const minDist_5, btScalar maxDist_6, btDiscreteCollisionDetectorInterface_Result mutable& resultOut_7);
public threaded function extern "::btGeometryUtil::isPointInsidePlanes" "nocdecl" bool btGeometryUtil_isPointInsidePlanes(btAlignedObjectArray_btVector3 const& planeEquations_0, btVector3 const& point_1, btScalar margin_2);
public threaded function extern "::btGjkConvexCast" "nocdecl" btGjkConvexCast btGjkConvexCast3(crptr{btConvexShape} convexA_0, crptr{btConvexShape} convexB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2);
public threaded function extern "::btFsel" btScalar btFsel(btScalar a_0, btScalar b_1, btScalar c_2);
public threaded function extern "::btCollisionWorld" "nocdecl" btCollisionWorld btCollisionWorld3(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} broadphasePairCache_1, rptr{btCollisionConfiguration} collisionConfiguration_2);
public threaded function extern "::btStackAlloc" "nocdecl" btStackAlloc btStackAlloc1(uint size_0);
public threaded function extern "::btCapsuleShape" "nocdecl" btCapsuleShape btCapsuleShape2(btScalar radius_0, btScalar height_1);
public threaded function extern "::btDbvtBroadphase" "nocdecl" btDbvtBroadphase btDbvtBroadphase1(rptr{btOverlappingPairCache} paircache_0);
public threaded function extern "::bt_distance_point_plane" btScalar bt_distance_point_plane(btVector4 const& plane_0, btVector3 const& point_1);
public threaded function extern "::btDistance" btScalar btDistance(btVector3 const& v1_0, btVector3 const& v2_1);
public threaded function extern "::btHeightfieldTerrainShape" "nocdecl" btHeightfieldTerrainShape btHeightfieldTerrainShape7(int heightStickWidth_0, int heightStickLength_1, crptr{void} heightfieldData_2, btScalar maxHeight_3, int upAxis_4, bool useFloatData_5, bool flipQuadEdges_6);
public threaded function extern "::btHeightfieldTerrainShape" "nocdecl" btHeightfieldTerrainShape btHeightfieldTerrainShape9(int heightStickWidth_0, int heightStickLength_1, crptr{void} heightfieldData_2, btScalar heightScale_3, btScalar minHeight_4, btScalar maxHeight_5, int upAxis_6, PHY_ScalarType heightDataType_7, bool flipQuadEdges_8);
public threaded function extern "::btSoftBody::clusterAImpulse" "nocdecl" void btSoftBody_clusterAImpulse(rptr{btSoftBody_Cluster} cluster_0, btSoftBody_Impulse const& impulse_1);
public threaded function extern "::btContinuousConvexCollision" "nocdecl" btContinuousConvexCollision btContinuousConvexCollision4(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_3);
public threaded function extern "::btContinuousConvexCollision" "nocdecl" btContinuousConvexCollision btContinuousConvexCollision2(crptr{btConvexShape} shapeA_0, crptr{btStaticPlaneShape} plane_1);
public threaded function extern "::btDbvt::enumLeaves" "nocdecl" void btDbvt_enumLeaves(crptr{btDbvtNode} root_0, btDbvt_ICollide mutable& policy_1);
public threaded function extern "::btGreaterEqual" bool btGreaterEqual(btScalar a_0, btScalar eps_1);
public threaded function extern "::btCollisionAlgorithmConstructionInfo" "nocdecl" btCollisionAlgorithmConstructionInfo btCollisionAlgorithmConstructionInfo2(rptr{btDispatcher} dispatcher_0, int temp_1);
public threaded function extern "::btSoftBody::PSolve_Links" "nocdecl" void btSoftBody_PSolve_Links(rptr{btSoftBody} psb_0, btScalar kst_1, btScalar ti_2);
public threaded function extern "::btSimpleBroadphase::aabbOverlap" "nocdecl" bool btSimpleBroadphase_aabbOverlap(rptr{btSimpleBroadphaseProxy} proxy0_0, rptr{btSimpleBroadphaseProxy} proxy1_1);
public threaded function extern "::btBroadphaseProxy::isNonMoving" "nocdecl" bool btBroadphaseProxy_isNonMoving(int proxyType_0);
public threaded function extern "::btSphereTriangleCollisionAlgorithm" "nocdecl" btSphereTriangleCollisionAlgorithm btSphereTriangleCollisionAlgorithm5(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool swapped_4);
public threaded function extern "::btSphereTriangleCollisionAlgorithm" "nocdecl" btSphereTriangleCollisionAlgorithm btSphereTriangleCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public threaded function extern "::bt_quantize_clamp" void bt_quantize_clamp(rptr{ushort} out_0, btVector3 const& point_1, btVector3 const& min_bound_2, btVector3 const& max_bound_3, btVector3 const& bvhQuantization_4);
public threaded function extern "::btConvexPointCloudShape" "nocdecl" btConvexPointCloudShape btConvexPointCloudShape4(rptr{btVector3} points_0, int numPoints_1, btVector3 const& localScaling_2, bool computeAabb_3);
public threaded function extern "::btGImpactCompoundShape" "nocdecl" btGImpactCompoundShape btGImpactCompoundShape1(bool children_has_transform_0);
public threaded function extern "::btAtan2Fast" btScalar btAtan2Fast(btScalar y_0, btScalar x_1);
public threaded function extern "::btIsNegative" int btIsNegative(btScalar x_0);
public threaded function extern "::btGeometryUtil::getPlaneEquationsFromVertices" "nocdecl" void btGeometryUtil_getPlaneEquationsFromVertices(btAlignedObjectArray_btVector3 mutable& vertices_0, btAlignedObjectArray_btVector3 mutable& planeEquationsOut_1);
public threaded function extern "::btAlignedAllocSetCustom" void btAlignedAllocSetCustom(rptr{btAllocFunc} allocFunc_0, rptr{btFreeFunc} freeFunc_1);
public threaded function extern "::btCompoundCollisionAlgorithm" "nocdecl" btCompoundCollisionAlgorithm btCompoundCollisionAlgorithm4(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public threaded function extern "::btCPUVertexBufferDescriptor" "nocdecl" btCPUVertexBufferDescriptor btCPUVertexBufferDescriptor3(rptr{float} basePointer_0, int vertexOffset_1, int vertexStride_2);
public threaded function extern "::btCPUVertexBufferDescriptor" "nocdecl" btCPUVertexBufferDescriptor btCPUVertexBufferDescriptor5(rptr{float} basePointer_0, int vertexOffset_1, int vertexStride_2, int normalOffset_3, int normalStride_4);
public threaded function extern "::btSoftBodyHelpers::Draw" "nocdecl" void btSoftBodyHelpers_Draw(rptr{btSoftBody} psb_0, rptr{btIDebugDraw} idraw_1, int drawflags_2);
public threaded function extern "::btSoftBody" "nocdecl" btSoftBody btSoftBody1(rptr{btSoftBodyWorldInfo} worldInfo_0);
public threaded function extern "::btSoftBody" "nocdecl" btSoftBody btSoftBody4(rptr{btSoftBodyWorldInfo} worldInfo_0, int node_count_1, crptr{btVector3} x_2, crptr{btScalar} m_3);
public threaded function extern "::btConeShape" "nocdecl" btConeShape btConeShape2(btScalar radius_0, btScalar height_1);
public threaded function extern "::bt_calc_quantization_parameters" void bt_calc_quantization_parameters(btVector3 mutable& outMinBound_0, btVector3 mutable& outMaxBound_1, btVector3 mutable& bvhQuantization_2, btVector3 const& srcMinBound_3, btVector3 const& srcMaxBound_4, btScalar quantizationMargin_5);
public threaded function extern "::btSwapEndian" uint btSwapEndian_int(int val_0);
public threaded function extern "::btSwapEndian" ushort btSwapEndian_ushort(ushort val_0);
public threaded function extern "::btSwapEndian" ushort btSwapEndian_short(short val_0);
public threaded function extern "::btSwapEndian" uint btSwapEndian_uint(uint val_0);
public threaded function extern "::btConvexTriangleCallback" "nocdecl" btConvexTriangleCallback btConvexTriangleCallback4(rptr{btDispatcher} dispatcher_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public threaded function extern "::btTriangleIndexVertexMaterialArray" "nocdecl" btTriangleIndexVertexMaterialArray btTriangleIndexVertexMaterialArray11(int numTriangles_0, rptr{int} triangleIndexBase_1, int triangleIndexStride_2, int numVertices_3, rptr{btScalar} vertexBase_4, int vertexStride_5, int numMaterials_6, rptr{uchar} materialBase_7, int materialStride_8, rptr{int} triangleMaterialsBase_9, int materialIndexStride_10);
public threaded function extern "::btDbvt::sStkNPS" "nocdecl" btDbvt_sStkNPS btDbvt_sStkNPS3(crptr{btDbvtNode} n_0, uint m_1, btScalar v_2);
public threaded function extern "::btSoftBody::PSolve_RContacts" "nocdecl" void btSoftBody_PSolve_RContacts(rptr{btSoftBody} psb_0, btScalar kst_1, btScalar ti_2);
public threaded function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion2(btVector3 const& _axis_0, btScalar const& _angle_1);
public threaded function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
public threaded function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion3(btScalar const& yaw_0, btScalar const& pitch_1, btScalar const& roll_2);
public threaded function extern "::btGImpactBvh" "nocdecl" btGImpactBvh btGImpactBvh1(rptr{btPrimitiveManagerBase} primitive_manager_0);
public threaded function extern "::btAABB" "nocdecl" btAABB btAABB3(btVector3 const& V1_0, btVector3 const& V2_1, btVector3 const& V3_2);
public threaded function extern "::btAABB" "nocdecl" btAABB btAABB4(btVector3 const& V1_0, btVector3 const& V2_1, btVector3 const& V3_2, btScalar margin_3);
public threaded function extern "::btAABB" "nocdecl" btAABB btAABB2(btAABB const& other_0, btScalar margin_1);
public threaded function extern "::btBroadphaseProxy::isConcave" "nocdecl" bool btBroadphaseProxy_isConcave(int proxyType_0);
public threaded function extern "::btSoftBody::solveCommonConstraints" "nocdecl" void btSoftBody_solveCommonConstraints(rptr{rptr{btSoftBody}} bodies_0, int count_1, int iterations_2);
public threaded function extern "::btActivatingCollisionAlgorithm" "nocdecl" btActivatingCollisionAlgorithm btActivatingCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public threaded function extern "::btActivatingCollisionAlgorithm" "nocdecl" btActivatingCollisionAlgorithm btActivatingCollisionAlgorithm3(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
public threaded function extern "::btUnswapEndianFloat" float btUnswapEndianFloat(uint a_0);
public threaded function extern "::btAxisSweep3Internal<unsigned short>" "nocdecl" btAxisSweep3Internal_unsigned_short btAxisSweep3Internal_unsigned_short7(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, ushort handleMask_2, ushort handleSentinel_3, ushort userMaxHandles_4, rptr{btOverlappingPairCache} pairCache_5, bool disableRaycastAccelerator_6);
public threaded function extern "::btTransformAabb" void btTransformAabb6(btVector3 const& localAabbMin_0, btVector3 const& localAabbMax_1, btScalar margin_2, btTransform const& trans_3, btVector3 mutable& aabbMinOut_4, btVector3 mutable& aabbMaxOut_5);
public threaded function extern "::btTransformAabb" void btTransformAabb5(btVector3 const& halfExtents_0, btScalar margin_1, btTransform const& t_2, btVector3 mutable& aabbMinOut_3, btVector3 mutable& aabbMaxOut_4);
public threaded function extern "::btSoftSoftCollisionAlgorithm" "nocdecl" btSoftSoftCollisionAlgorithm btSoftSoftCollisionAlgorithm4(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3);
public threaded function extern "::btSoftSoftCollisionAlgorithm" "nocdecl" btSoftSoftCollisionAlgorithm btSoftSoftCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public threaded function extern "::btConvexConvexAlgorithm::CreateFunc" "nocdecl" btConvexConvexAlgorithm_CreateFunc btConvexConvexAlgorithm_CreateFunc2(rptr{btVoronoiSimplexSolver} simplexSolver_0, rptr{btConvexPenetrationDepthSolver} pdSolver_1);
public threaded function extern "::btRigidBody" "nocdecl" btRigidBody btRigidBody4(btScalar mass_0, rptr{btMotionState} motionState_1, rptr{btCollisionShape} collisionShape_2, btVector3 const& localInertia_3);
public threaded function extern "::btRigidBody" "nocdecl" btRigidBody btRigidBody1(btRigidBody_btRigidBodyConstructionInfo const& constructionInfo_0);
public threaded function extern "::btMinkowskiSumShape" "nocdecl" btMinkowskiSumShape btMinkowskiSumShape2(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1);
public threaded function extern "::btSparseSdf<3>::Decompose" "nocdecl" btSparseSdf_3_IntFrac btSparseSdf_3_Decompose(btScalar x_0);
public threaded function extern "::btBroadphaseProxy::isConvex2d" "nocdecl" bool btBroadphaseProxy_isConvex2d(int proxyType_0);
public threaded function extern "::btAngle" btScalar btAngle_btQuaternion_btQuaternion(btQuaternion const& q1_0, btQuaternion const& q2_1);
public threaded function extern "::btAngle" btScalar btAngle_btVector3_btVector3(btVector3 const& v1_0, btVector3 const& v2_1);
public threaded function extern "::btBroadphaseProxy::isCompound" "nocdecl" bool btBroadphaseProxy_isCompound(int proxyType_0);
public threaded function extern "::btSoftBody::Body" "nocdecl" btSoftBody_Body btSoftBody_Body_btSoftBody_Cluster_p(rptr{btSoftBody_Cluster} p_0);
public threaded function extern "::btSoftBody::Body" "nocdecl" btSoftBody_Body btSoftBody_Body_btCollisionObject_cp(crptr{btCollisionObject} colObj_0);
public threaded function extern "::btSoftBody::RayFromToCaster::rayFromToTriangle" "nocdecl" btScalar btSoftBody_RayFromToCaster_rayFromToTriangle(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btVector3 const& rayNormalizedDirection_2, btVector3 const& a_3, btVector3 const& b_4, btVector3 const& c_5, btScalar maxt_6);
public threaded function extern "::btVector4" "nocdecl" btVector4 btVector4_4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
public threaded function extern "::btSoftBody::upcast" "nocdecl" crptr{btSoftBody} btSoftBody_upcast_btCollisionObject_cp(crptr{btCollisionObject} colObj_0);
public threaded function extern "::btSoftBody::upcast" "nocdecl" rptr{btSoftBody} btSoftBody_upcast_btCollisionObject_p(rptr{btCollisionObject} colObj_0);
public threaded function extern "::btTan" btScalar btTan(btScalar x_0);
public threaded function extern "::btGImpactQuantizedBvh" "nocdecl" btGImpactQuantizedBvh btGImpactQuantizedBvh1(rptr{btPrimitiveManagerBase} primitive_manager_0);
public threaded function extern "::btScaledBvhTriangleMeshShape" "nocdecl" btScaledBvhTriangleMeshShape btScaledBvhTriangleMeshShape2(rptr{btBvhTriangleMeshShape} childShape_0, btVector3 const& localScaling_1);
public threaded function extern "::btTriangleMesh" "nocdecl" btTriangleMesh btTriangleMesh2(bool use32bitIndices_0, bool use4componentVertices_1);
public threaded function extern "::btStaticPlaneShape" "nocdecl" btStaticPlaneShape btStaticPlaneShape2(btVector3 const& planeNormal_0, btScalar planeConstant_1);
public threaded function extern "::btSphereBoxCollisionAlgorithm" "nocdecl" btSphereBoxCollisionAlgorithm btSphereBoxCollisionAlgorithm5(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool isSwapped_4);
public threaded function extern "::btAcos" btScalar btAcos(btScalar x_0);
public threaded function extern "::bt_vec_blend" void bt_vec_blend(btVector3 mutable& vr_0, btVector3 const& va_1, btVector3 const& vb_2, btScalar blend_factor_3);
public threaded function extern "::btDbvt::extractLeaves" "nocdecl" void btDbvt_extractLeaves(crptr{btDbvtNode} node_0, btAlignedObjectArray_btDbvtNode_const_p mutable& leaves_1);
public threaded function extern "::btQuantizedBvh::getAlignmentSerializationPadding" "nocdecl" uint btQuantizedBvh_getAlignmentSerializationPadding();
public threaded function extern "::bt_plane_clip_polygon_collect" void bt_plane_clip_polygon_collect(btVector3 const& point0_0, btVector3 const& point1_1, btScalar dist0_2, btScalar dist1_3, rptr{btVector3} clipped_4, int mutable& clipped_count_5);
public threaded function extern "::btHinge2Constraint" "nocdecl" btHinge2Constraint btHinge2Constraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 mutable& anchor_2, btVector3 mutable& axis1_3, btVector3 mutable& axis2_4);
public threaded function extern "::btSoftBody::AJoint::IControl::Default" "nocdecl" rptr{btSoftBody_AJoint_IControl} btSoftBody_AJoint_IControl_Default();
public threaded function extern "::btSimpleDynamicsWorld" "nocdecl" btSimpleDynamicsWorld btSimpleDynamicsWorld4(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3);
public threaded function extern "::btDbvt::sStkNN" "nocdecl" btDbvt_sStkNN btDbvt_sStkNN2(crptr{btDbvtNode} na_0, crptr{btDbvtNode} nb_1);
public threaded function extern "::btMatrixX<float>" "nocdecl" btMatrixX_float btMatrixX_float2(int rows_0, int cols_1);
public threaded function extern "::btGImpactMeshShape" "nocdecl" btGImpactMeshShape btGImpactMeshShape1(rptr{btStridingMeshInterface} meshInterface_0);
public threaded function extern "::btSoftBody::clusterVelocity" "nocdecl" btVector3 btSoftBody_clusterVelocity(crptr{btSoftBody_Cluster} cluster_0, btVector3 const& rpos_1);
public threaded function extern "::btQuaternion::getIdentity" "nocdecl" btQuaternion const& btQuaternion_getIdentity();
public threaded function extern "::btCompareTransformsEqual" bool btCompareTransformsEqual(btTransform const& t1_0, btTransform const& t2_1);
public threaded function extern "::btCapsuleShapeZ" "nocdecl" btCapsuleShapeZ btCapsuleShapeZ2(btScalar radius_0, btScalar height_1);
public threaded function extern "::btAlignedAllocInternal" rptr{void} btAlignedAllocInternal(size_t size_0, int alignment_1);
public threaded function extern "::btSubsimplexConvexCast" "nocdecl" btSubsimplexConvexCast btSubsimplexConvexCast3(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2);
public threaded function extern "::btCollisionWorld::ClosestConvexResultCallback" "nocdecl" btCollisionWorld_ClosestConvexResultCallback btCollisionWorld_ClosestConvexResultCallback2(btVector3 const& convexFromWorld_0, btVector3 const& convexToWorld_1);
public threaded function extern "::btSparseSdf<3>::Lerp" "nocdecl" btScalar btSparseSdf_3_Lerp(btScalar a_0, btScalar b_1, btScalar t_2);
public threaded function extern "::btSoftBodyTriangleCallback" "nocdecl" btSoftBodyTriangleCallback btSoftBodyTriangleCallback4(rptr{btDispatcher} dispatcher_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public threaded function extern "::btSoftBody::clusterDImpulse" "nocdecl" void btSoftBody_clusterDImpulse(rptr{btSoftBody_Cluster} cluster_0, btVector3 const& rpos_1, btVector3 const& impulse_2);
public threaded function extern "::btCollisionObjectWrapper" "nocdecl" btCollisionObjectWrapper btCollisionObjectWrapper6(crptr{btCollisionObjectWrapper} parent_0, crptr{btCollisionShape} shape_1, crptr{btCollisionObject} collisionObject_2, btTransform const& worldTransform_3, int partId_4, int index_5);
public threaded function extern "::btSqrt" btScalar btSqrt(btScalar y_0);
public threaded function extern "::btTypedConstraint" "nocdecl" btTypedConstraint btTypedConstraint3(btTypedConstraintType type_0, btRigidBody mutable& rbA_1, btRigidBody mutable& rbB_2);
public threaded function extern "::btTypedConstraint" "nocdecl" btTypedConstraint btTypedConstraint2(btTypedConstraintType type_0, btRigidBody mutable& rbA_1);
public threaded function extern "::btDbvt::maxdepth" "nocdecl" int btDbvt_maxdepth(crptr{btDbvtNode} node_0);
public threaded function extern "::btTriangleRaycastCallback" "nocdecl" btTriangleRaycastCallback btTriangleRaycastCallback3(btVector3 const& from_0, btVector3 const& to_1, uint flags_2);
public threaded function extern "::btRayAabb" bool btRayAabb(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btVector3 const& aabbMin_2, btVector3 const& aabbMax_3, btScalar mutable& param_4, btVector3 mutable& normal_5);
public threaded function extern "::btConvex2dConvex2dAlgorithm" "nocdecl" btConvex2dConvex2dAlgorithm btConvex2dConvex2dAlgorithm8(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, rptr{btVoronoiSimplexSolver} simplexSolver_4, rptr{btConvexPenetrationDepthSolver} pdSolver_5, int numPerturbationIterations_6, int minimumPointsPerturbationThreshold_7);
public threaded function extern "::btPolyhedralContactClipping::clipFaceAgainstHull" "nocdecl" void btPolyhedralContactClipping_clipFaceAgainstHull(btVector3 const& separatingNormal_0, btConvexPolyhedron const& hullA_1, btTransform const& transA_2, btVertexArray mutable& worldVertsB1_3, btScalar const minDist_4, btScalar maxDist_5, btDiscreteCollisionDetectorInterface_Result mutable& resultOut_6);
public threaded function extern "::btStrLen" int btStrLen(crptr{char} str_0);
public threaded function extern "::btMultiSphereShape" "nocdecl" btMultiSphereShape btMultiSphereShape3(crptr{btVector3} positions_0, crptr{btScalar} radi_1, int numSpheres_2);
public threaded function extern "::btTriple" btScalar btTriple(btVector3 const& v1_0, btVector3 const& v2_1, btVector3 const& v3_2);
public threaded function extern "::btEmptyAlgorithm" "nocdecl" btEmptyAlgorithm btEmptyAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public threaded function extern "::btDbvt::rayTest" "nocdecl" void btDbvt_rayTest(crptr{btDbvtNode} root_0, btVector3 const& rayFrom_1, btVector3 const& rayTo_2, btDbvt_ICollide mutable& policy_3);
public threaded function extern "::btQuadWord" "nocdecl" btQuadWord btQuadWord3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
public threaded function extern "::btQuadWord" "nocdecl" btQuadWord btQuadWord4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
public threaded function extern "::btBroadphaseProxy::isSoftBody" "nocdecl" bool btBroadphaseProxy_isSoftBody(int proxyType_0);
public threaded function extern "::btUniversalConstraint" "nocdecl" btUniversalConstraint btUniversalConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& anchor_2, btVector3 const& axis1_3, btVector3 const& axis2_4);
public threaded function extern "::bt_segment_collision" void bt_segment_collision(btVector3 const& vA1_0, btVector3 const& vA2_1, btVector3 const& vB1_2, btVector3 const& vB2_3, btVector3 mutable& vPointA_4, btVector3 mutable& vPointB_5);
public threaded function extern "::btSoftBodyHelpers::CreateFromConvexHull" "nocdecl" rptr{btSoftBody} btSoftBodyHelpers_CreateFromConvexHull(btSoftBodyWorldInfo mutable& worldInfo_0, crptr{btVector3} vertices_1, int nvertices_2, bool randomizeConstraints_3);
public threaded function extern "::btTransformUtil::calculateDiffAxisAngle" "nocdecl" void btTransformUtil_calculateDiffAxisAngle(btTransform const& transform0_0, btTransform const& transform1_1, btVector3 mutable& axis_2, btScalar mutable& angle_3);
public threaded function extern "::btSoftBody::clusterDAImpulse" "nocdecl" void btSoftBody_clusterDAImpulse(rptr{btSoftBody_Cluster} cluster_0, btVector3 const& impulse_1);
public threaded function extern "::btAngleCompareFunc" "nocdecl" btAngleCompareFunc btAngleCompareFunc1(btVector3 const& anchor_0);
public threaded function extern "::btAdjustAngleToLimits" btScalar btAdjustAngleToLimits(btScalar angleInRadians_0, btScalar angleLowerLimitInRadians_1, btScalar angleUpperLimitInRadians_2);
public threaded function extern "::btManifoldResult::calculateCombinedRestitution" "nocdecl" btScalar btManifoldResult_calculateCombinedRestitution(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
public threaded function extern "::Lerp" btVector3 Lerp(btVector3 const& a_0, btVector3 const& b_1, btScalar t_2);
public threaded function extern "::btSelect" int btSelect_uint_int_int(uint condition_0, int valueIfConditionNonZero_1, int valueIfConditionZero_2);
public threaded function extern "::btSelect" float btSelect_uint_float_float(uint condition_0, float valueIfConditionNonZero_1, float valueIfConditionZero_2);
public threaded function extern "::btSelect" uint btSelect_uint_uint_uint(uint condition_0, uint valueIfConditionNonZero_1, uint valueIfConditionZero_2);
public threaded function extern "::btAxisSweep3Internal<unsigned int>" "nocdecl" btAxisSweep3Internal_unsigned_int btAxisSweep3Internal_unsigned_int7(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, uint handleMask_2, uint handleSentinel_3, uint userMaxHandles_4, rptr{btOverlappingPairCache} pairCache_5, bool disableRaycastAccelerator_6);
public threaded function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_1(btVector3 const& pt0_0);
public threaded function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_2(btVector3 const& pt0_0, btVector3 const& pt1_1);
public threaded function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_4(btVector3 const& pt0_0, btVector3 const& pt1_1, btVector3 const& pt2_2, btVector3 const& pt3_3);
public threaded function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_3(btVector3 const& pt0_0, btVector3 const& pt1_1, btVector3 const& pt2_2);
public threaded function extern "::btRigidBody::upcast" "nocdecl" crptr{btRigidBody} btRigidBody_upcast_btCollisionObject_cp(crptr{btCollisionObject} colObj_0);
public threaded function extern "::btRigidBody::upcast" "nocdecl" rptr{btRigidBody} btRigidBody_upcast_btCollisionObject_p(rptr{btCollisionObject} colObj_0);
public threaded function extern "::btOptimizedBvh::deSerializeInPlace" "nocdecl" rptr{btOptimizedBvh} btOptimizedBvh_deSerializeInPlace(rptr{void} i_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2);
public threaded function extern "::bt_unquantize" btVector3 bt_unquantize(crptr{ushort} vecIn_0, btVector3 const& offset_1, btVector3 const& bvhQuantization_2);
public threaded function extern "::btSparseSdf<3>::DistanceToShape" "nocdecl" btScalar btSparseSdf_3_DistanceToShape(btVector3 const& x_0, crptr{btCollisionShape} shape_1);
public threaded function extern "::btRigidBody::btRigidBodyConstructionInfo" "nocdecl" btRigidBody_btRigidBodyConstructionInfo btRigidBody_btRigidBodyConstructionInfo4(btScalar mass_0, rptr{btMotionState} motionState_1, rptr{btCollisionShape} collisionShape_2, btVector3 const& localInertia_3);
public threaded function extern "::btGeometryUtil::isInside" "nocdecl" bool btGeometryUtil_isInside(btAlignedObjectArray_btVector3 const& vertices_0, btVector3 const& planeNormal_1, btScalar margin_2);
public threaded function extern "::btTypedObject" "nocdecl" btTypedObject btTypedObject1(int objectType_0);
public threaded function extern "::btCollisionWorld::objectQuerySingleInternal" "nocdecl" void btCollisionWorld_objectQuerySingleInternal(crptr{btConvexShape} castShape_0, btTransform const& convexFromTrans_1, btTransform const& convexToTrans_2, crptr{btCollisionObjectWrapper} colObjWrap_3, btCollisionWorld_ConvexResultCallback mutable& resultCallback_4, btScalar allowedPenetration_5);
public threaded function extern "::btSoftRigidDynamicsWorld::rayTestSingle" "nocdecl" void btSoftRigidDynamicsWorld_rayTestSingle(btTransform const& rayFromTrans_0, btTransform const& rayToTrans_1, rptr{btCollisionObject} collisionObject_2, crptr{btCollisionShape} collisionShape_3, btTransform const& colObjWorldTransform_4, btCollisionWorld_RayResultCallback mutable& resultCallback_5);
public threaded function extern "::btGImpactMeshShapePart::TrimeshPrimitiveManager" "nocdecl" btGImpactMeshShapePart_TrimeshPrimitiveManager btGImpactMeshShapePart_TrimeshPrimitiveManager2(rptr{btStridingMeshInterface} meshInterface_0, int part_1);
public threaded function extern "::btDbvt::benchmark" "nocdecl" void btDbvt_benchmark();
public threaded function extern "::btSoftBody::PSolve_SContacts" "nocdecl" void btSoftBody_PSolve_SContacts(rptr{btSoftBody} psb_0, btScalar _1, btScalar ti_2);
public threaded function extern "::btCollisionWorld::rayTestSingle" "nocdecl" void btCollisionWorld_rayTestSingle(btTransform const& rayFromTrans_0, btTransform const& rayToTrans_1, rptr{btCollisionObject} collisionObject_2, crptr{btCollisionShape} collisionShape_3, btTransform const& colObjWorldTransform_4, btCollisionWorld_RayResultCallback mutable& resultCallback_5);
public threaded function extern "::btSparseSdf<3>::Hash" "nocdecl" uint btSparseSdf_3_Hash(int x_0, int y_1, int z_2, crptr{btCollisionShape} shape_3);
public threaded function extern "::btCollisionWorld::AllHitsRayResultCallback" "nocdecl" btCollisionWorld_AllHitsRayResultCallback btCollisionWorld_AllHitsRayResultCallback2(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1);
public threaded function extern "::btConvexPlaneCollisionAlgorithm" "nocdecl" btConvexPlaneCollisionAlgorithm btConvexPlaneCollisionAlgorithm7(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool isSwapped_4, int numPerturbationIterations_5, int minimumPointsPerturbationThreshold_6);
public threaded function extern "::bt_line_plane_collision" int bt_line_plane_collision(btVector4 const& plane_0, btVector3 const& vDir_1, btVector3 const& vPoint_2, btVector3 mutable& pout_3, btScalar mutable& tparam_4, btScalar tmin_5, btScalar tmax_6);
public threaded function extern "::btTriangleShapeEx" "nocdecl" btTriangleShapeEx btTriangleShapeEx3(btVector3 const& p0_0, btVector3 const& p1_1, btVector3 const& p2_2);
public threaded function extern "::btBvhTriangleMeshShape" "nocdecl" btBvhTriangleMeshShape btBvhTriangleMeshShape5(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, btVector3 const& bvhAabbMin_2, btVector3 const& bvhAabbMax_3, bool buildBvh_4);
public threaded function extern "::btBvhTriangleMeshShape" "nocdecl" btBvhTriangleMeshShape btBvhTriangleMeshShape3(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, bool buildBvh_2);
public threaded function extern "::btAlignedAllocSetCustomAligned" void btAlignedAllocSetCustomAligned(rptr{btAlignedAllocFunc} allocFunc_0, rptr{btAlignedFreeFunc} freeFunc_1);
public threaded function extern "::btGeneric6DofSpringConstraint" "nocdecl" btGeneric6DofSpringConstraint btGeneric6DofSpringConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameB_2);
public threaded function extern "::btGeneric6DofSpringConstraint" "nocdecl" btGeneric6DofSpringConstraint btGeneric6DofSpringConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
public threaded function extern "::btSoftBody::RayFromToCaster" "nocdecl" btSoftBody_RayFromToCaster btSoftBody_RayFromToCaster3(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btScalar mxt_2);
public threaded function extern "::btBroadphasePair" "nocdecl" btBroadphasePair btBroadphasePair2(btBroadphaseProxy mutable& proxy0_0, btBroadphaseProxy mutable& proxy1_1);
public threaded function extern "::btGEN_Link" "nocdecl" btGEN_Link btGEN_Link2(rptr{btGEN_Link} next_0, rptr{btGEN_Link} prev_1);
public threaded function extern "::btPolyhedralContactClipping::findSeparatingAxis" "nocdecl" bool btPolyhedralContactClipping_findSeparatingAxis(btConvexPolyhedron const& hullA_0, btConvexPolyhedron const& hullB_1, btTransform const& transA_2, btTransform const& transB_3, btVector3 mutable& sep_4, btDiscreteCollisionDetectorInterface_Result mutable& resultOut_5);
public threaded function extern "::btSoftBodyHelpers::CreateFromTriMesh" "nocdecl" rptr{btSoftBody} btSoftBodyHelpers_CreateFromTriMesh(btSoftBodyWorldInfo mutable& worldInfo_0, crptr{btScalar} vertices_1, crptr{int} triangles_2, int ntriangles_3, bool randomizeConstraints_4);
public threaded function extern "::btCylinderShapeZ" "nocdecl" btCylinderShapeZ btCylinderShapeZ1(btVector3 const& halfExtents_0);
public threaded function extern "::btEigen::system" "nocdecl" int btEigen_system(btMatrix3x3 mutable& a_0, rptr{btMatrix3x3} vectors_1, rptr{btVector3} values_2);
public threaded function extern "::btGeometryUtil::getVerticesFromPlaneEquations" "nocdecl" void btGeometryUtil_getVerticesFromPlaneEquations(btAlignedObjectArray_btVector3 const& planeEquations_0, btAlignedObjectArray_btVector3 mutable& verticesOut_1);
public threaded function extern "::btSoftBodyHelpers::CreatePatch" "nocdecl" rptr{btSoftBody} btSoftBodyHelpers_CreatePatch(btSoftBodyWorldInfo mutable& worldInfo_0, btVector3 const& corner00_1, btVector3 const& corner10_2, btVector3 const& corner01_3, btVector3 const& corner11_4, int resx_5, int resy_6, int fixeds_7, bool gendiags_8);
public threaded function extern "::btSoftRigidDynamicsWorld" "nocdecl" btSoftRigidDynamicsWorld btSoftRigidDynamicsWorld5(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3, rptr{btSoftBodySolver} softBodySolver_4);
public threaded function extern "::btSoftBodyHelpers::DrawFrame" "nocdecl" void btSoftBodyHelpers_DrawFrame(rptr{btSoftBody} psb_0, rptr{btIDebugDraw} idraw_1);
public threaded function extern "::btRayAabb2" bool btRayAabb2(btVector3 const& rayFrom_0, btVector3 const& rayInvDirection_1, crptr{uint} raySign_2, crptr{btVector3} bounds_3, btScalar mutable& tmin_4, btScalar lambda_min_5, btScalar lambda_max_6);
public threaded function extern "::btGhostObject::upcast" "nocdecl" rptr{btGhostObject} btGhostObject_upcast_btCollisionObject_p(rptr{btCollisionObject} colObj_0);
public threaded function extern "::btGhostObject::upcast" "nocdecl" crptr{btGhostObject} btGhostObject_upcast_btCollisionObject_cp(crptr{btCollisionObject} colObj_0);
public threaded function extern "::btGImpactConvexDecompositionShape" "nocdecl" btGImpactConvexDecompositionShape btGImpactConvexDecompositionShape4(rptr{btStridingMeshInterface} meshInterface_0, btVector3 const& mesh_scale_1, btScalar margin_2, bool children_has_transform_3);
public threaded function extern "::btAtan" btScalar btAtan(btScalar x_0);
public threaded function extern "::btAxisSweep3" "nocdecl" btAxisSweep3 btAxisSweep3_5(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, ushort maxHandles_2, rptr{btOverlappingPairCache} pairCache_3, bool disableRaycastAccelerator_4);
public threaded function extern "::btBulletWorldImporter" "nocdecl" btBulletWorldImporter btBulletWorldImporter1(rptr{btDynamicsWorld} world_0);
public threaded function extern "::btGImpactQuantizedBvh::find_collision" "nocdecl" void btGImpactQuantizedBvh_find_collision(crptr{btGImpactQuantizedBvh} boxset1_0, btTransform const& trans1_1, crptr{btGImpactQuantizedBvh} boxset2_2, btTransform const& trans2_3, btPairSet mutable& collision_pairs_4);
public threaded function extern "::btBoxBoxDetector" "nocdecl" btBoxBoxDetector btBoxBoxDetector2(crptr{btBoxShape} box1_0, crptr{btBoxShape} box2_1);
public threaded function extern "::btUniformScalingShape" "nocdecl" btUniformScalingShape btUniformScalingShape2(rptr{btConvexShape} convexChildShape_0, btScalar uniformScalingFactor_1);
public threaded function extern "::btSoftBodyHelpers::CreateRope" "nocdecl" rptr{btSoftBody} btSoftBodyHelpers_CreateRope(btSoftBodyWorldInfo mutable& worldInfo_0, btVector3 const& from_1, btVector3 const& to_2, int res_3, int fixeds_4);
public threaded function extern "::bt32BitAxisSweep3" "nocdecl" bt32BitAxisSweep3 bt32BitAxisSweep3_5(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, uint maxHandles_2, rptr{btOverlappingPairCache} pairCache_3, bool disableRaycastAccelerator_4);
public threaded function extern "::btPoolAllocator" "nocdecl" btPoolAllocator btPoolAllocator2(int elemSize_0, int maxElements_1);
public threaded function extern "::btHashString" "nocdecl" btHashString btHashString1(crptr{char} name_0);
public threaded function extern "::btGjkEpaSolver2::StackSizeRequirement" "nocdecl" int btGjkEpaSolver2_StackSizeRequirement();
public threaded function extern "::btSoftBody::VSolve_Links" "nocdecl" void btSoftBody_VSolve_Links(rptr{btSoftBody} psb_0, btScalar kst_1);
public threaded function extern "::btCylinderShape" "nocdecl" btCylinderShape btCylinderShape1(btVector3 const& halfExtents_0);
public threaded function extern "::btFabs" btScalar btFabs(btScalar x_0);
public threaded function extern "::btMultiSapBroadphase" "nocdecl" btMultiSapBroadphase btMultiSapBroadphase2(int maxProxies_0, rptr{btOverlappingPairCache} pairCache_1);
public threaded function extern "::btSimplePair" "nocdecl" btSimplePair btSimplePair2(int indexA_0, int indexB_1);
public threaded function extern "::btMatrix3x3::getIdentity" "nocdecl" btMatrix3x3 const& btMatrix3x3_getIdentity();
public threaded function extern "::btBox2dBox2dCollisionAlgorithm" "nocdecl" btBox2dBox2dCollisionAlgorithm btBox2dBox2dCollisionAlgorithm4(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3);
public threaded function extern "::btBox2dBox2dCollisionAlgorithm" "nocdecl" btBox2dBox2dCollisionAlgorithm btBox2dBox2dCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public threaded function extern "::btCollisionDispatcher" "nocdecl" btCollisionDispatcher btCollisionDispatcher1(rptr{btCollisionConfiguration} collisionConfiguration_0);
public threaded function extern "::btCollisionWorld::ClosestRayResultCallback" "nocdecl" btCollisionWorld_ClosestRayResultCallback btCollisionWorld_ClosestRayResultCallback2(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1);
public threaded function extern "::btGeneric6DofConstraint" "nocdecl" btGeneric6DofConstraint btGeneric6DofConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
public threaded function extern "::btGeneric6DofConstraint" "nocdecl" btGeneric6DofConstraint btGeneric6DofConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameB_2);
public threaded function extern "::btSoftBodyConcaveCollisionAlgorithm" "nocdecl" btSoftBodyConcaveCollisionAlgorithm btSoftBodyConcaveCollisionAlgorithm4(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public threaded function extern "::btWheelInfo" "nocdecl" btWheelInfo btWheelInfo1(btWheelInfoConstructionInfo mutable& ci_0);
public threaded function extern "::btGImpactMeshShapePart" "nocdecl" btGImpactMeshShapePart btGImpactMeshShapePart2(rptr{btStridingMeshInterface} meshInterface_0, int part_1);
public threaded function extern "::btSoftBodyHelpers::DrawNodeTree" "nocdecl" void btSoftBodyHelpers_DrawNodeTree(rptr{btSoftBody} psb_0, rptr{btIDebugDraw} idraw_1, int mindepth_2, int maxdepth_3);
public threaded function extern "::btMachineIsLittleEndian" bool btMachineIsLittleEndian();
public threaded function extern "::btDbvt::collideOCL" "nocdecl" void btDbvt_collideOCL(crptr{btDbvtNode} root_0, crptr{btVector3} normals_1, crptr{btScalar} offsets_2, btVector3 const& sortaxis_3, int count_4, btDbvt_ICollide mutable& policy_5, bool fsort_6);
public threaded function extern "::btDbvtAabbMm::FromPoints" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromPoints_btVector3_cp_p_int(rptr{crptr{btVector3}} ppts_0, int n_1);
public threaded function extern "::btDbvtAabbMm::FromPoints" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromPoints_btVector3_cp_int(crptr{btVector3} pts_0, int n_1);
public threaded function extern "::btTriIndex" "nocdecl" btTriIndex btTriIndex3(int partId_0, int triangleIndex_1, rptr{btCollisionShape} shape_2);
public threaded function extern "::btTriangleConvexcastCallback" "nocdecl" btTriangleConvexcastCallback btTriangleConvexcastCallback5(crptr{btConvexShape} convexShape_0, btTransform const& convexShapeFrom_1, btTransform const& convexShapeTo_2, btTransform const& triangleToWorld_3, btScalar const triangleCollisionMargin_4);
public threaded function extern "::btBroadphaseProxy::isInfinite" "nocdecl" bool btBroadphaseProxy_isInfinite(int proxyType_0);
public threaded function extern "::btFixedConstraint" "nocdecl" btFixedConstraint btFixedConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3);
public threaded function extern "::btGetVersion" int btGetVersion();
public threaded function extern "::btSoftBodyHelpers::DrawClusterTree" "nocdecl" void btSoftBodyHelpers_DrawClusterTree(rptr{btSoftBody} psb_0, rptr{btIDebugDraw} idraw_1, int mindepth_2, int maxdepth_3);
public threaded function extern "::btWorldImporter" "nocdecl" btWorldImporter btWorldImporter1(rptr{btDynamicsWorld} world_0);
public threaded function extern "::btSwapScalarEndian" void btSwapScalarEndian(btScalar const& sourceVal_0, btScalar mutable& destVal_1);
public threaded function extern "::btAtan2" btScalar btAtan2(btScalar x_0, btScalar y_1);
public threaded function extern "::btAsin" btScalar btAsin(btScalar x_0);
public threaded function extern "::btConeTwistConstraint" "nocdecl" btConeTwistConstraint btConeTwistConstraint2(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1);
public threaded function extern "::btConeTwistConstraint" "nocdecl" btConeTwistConstraint btConeTwistConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3);
public threaded function extern "::btManifoldPoint" "nocdecl" btManifoldPoint btManifoldPoint4(btVector3 const& pointA_0, btVector3 const& pointB_1, btVector3 const& normal_2, btScalar distance_3);
public threaded function extern "::btBoxShape" "nocdecl" btBoxShape btBoxShape1(btVector3 const& boxHalfExtents_0);
public threaded function extern "::btDbvt::sStkNP" "nocdecl" btDbvt_sStkNP btDbvt_sStkNP2(crptr{btDbvtNode} n_0, uint m_1);
public threaded function extern "::btPow" btScalar btPow(btScalar x_0, btScalar y_1);
public threaded function extern "::btSoftBodyRigidBodyCollisionConfiguration" "nocdecl" btSoftBodyRigidBodyCollisionConfiguration btSoftBodyRigidBodyCollisionConfiguration1(btDefaultCollisionConstructionInfo const& constructionInfo_0);
public threaded function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry5(btVector3 const& jointAxis_0, btMatrix3x3 const& world2A_1, btMatrix3x3 const& world2B_2, btVector3 const& inertiaInvA_3, btVector3 const& inertiaInvB_4);
public threaded function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry9(btMatrix3x3 const& world2A_0, btMatrix3x3 const& world2B_1, btVector3 const& rel_pos1_2, btVector3 const& rel_pos2_3, btVector3 const& jointAxis_4, btVector3 const& inertiaInvA_5, btScalar const massInvA_6, btVector3 const& inertiaInvB_7, btScalar const massInvB_8);
public threaded function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry6(btMatrix3x3 const& world2A_0, btVector3 const& rel_pos1_1, btVector3 const& rel_pos2_2, btVector3 const& jointAxis_3, btVector3 const& inertiaInvA_4, btScalar const massInvA_5);
public threaded function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry4(btVector3 const& axisInA_0, btVector3 const& axisInB_1, btVector3 const& inertiaInvA_2, btVector3 const& inertiaInvB_3);
public threaded function extern "::btMatrixX<double>" "nocdecl" btMatrixX_double btMatrixX_double2(int rows_0, int cols_1);
public threaded function extern "::btSimpleBroadphaseProxy" "nocdecl" btSimpleBroadphaseProxy btSimpleBroadphaseProxy7(btVector3 const& minpt_0, btVector3 const& maxpt_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{void} multiSapProxy_6);
public threaded function extern "::btSoftBodyCollisionShape" "nocdecl" btSoftBodyCollisionShape btSoftBodyCollisionShape1(rptr{btSoftBody} backptr_0);
public threaded function extern "::btDbvtBroadphase::benchmark" "nocdecl" void btDbvtBroadphase_benchmark(rptr{btBroadphaseInterface} _0);
public threaded function extern "::btCross" btVector3 btCross(btVector3 const& v1_0, btVector3 const& v2_1);
public threaded function extern "::btTypedConstraint::getFixedBody" "nocdecl" btRigidBody mutable& btTypedConstraint_getFixedBody();
public threaded function extern "::btCollisionWorld::objectQuerySingle" "nocdecl" void btCollisionWorld_objectQuerySingle(crptr{btConvexShape} castShape_0, btTransform const& rayFromTrans_1, btTransform const& rayToTrans_2, rptr{btCollisionObject} collisionObject_3, crptr{btCollisionShape} collisionShape_4, btTransform const& colObjWorldTransform_5, btCollisionWorld_ConvexResultCallback mutable& resultCallback_6, btScalar allowedPenetration_7);
public threaded function extern "::btNormalizeAngle" btScalar btNormalizeAngle(btScalar angleInRadians_0);
public threaded function extern "::btCylinderShapeX" "nocdecl" btCylinderShapeX btCylinderShapeX1(btVector3 const& halfExtents_0);
public threaded function extern "::btDegrees" btScalar btDegrees(btScalar x_0);
public threaded function extern "::btGImpactBvh::find_collision" "nocdecl" void btGImpactBvh_find_collision(rptr{btGImpactBvh} boxset1_0, btTransform const& trans1_1, rptr{btGImpactBvh} boxset2_2, btTransform const& trans2_3, btPairSet mutable& collision_pairs_4);
public threaded function extern "::btEqual" bool btEqual(btScalar a_0, btScalar eps_1);
public threaded function extern "::btSoftBodyHelpers::CreatePatchUV" "nocdecl" rptr{btSoftBody} btSoftBodyHelpers_CreatePatchUV(btSoftBodyWorldInfo mutable& worldInfo_0, btVector3 const& corner00_1, btVector3 const& corner10_2, btVector3 const& corner01_3, btVector3 const& corner11_4, int resx_5, int resy_6, int fixeds_7, bool gendiags_8, rptr{float} tex_coords_9);
public threaded function extern "::bt_mat3_dot_col" btScalar bt_mat3_dot_col(btMatrix3x3 const& mat_0, btVector3 const& vec3_1, int colindex_2);
public threaded function extern "::btConvexSeparatingDistanceUtil" "nocdecl" btConvexSeparatingDistanceUtil btConvexSeparatingDistanceUtil2(btScalar boundingRadiusA_0, btScalar boundingRadiusB_1);
public threaded function extern "::btSin" btScalar btSin(btScalar x_0);
public threaded function extern "::btTransform" "nocdecl" btTransform btTransform_btQuaternion_btVector3(btQuaternion const& q_0, btVector3 const& c_1);
public threaded function extern "::btTransform" "nocdecl" btTransform btTransform_btMatrix3x3_btVector3(btMatrix3x3 const& b_0, btVector3 const& c_1);
public threaded function extern "::bt_closest_point_on_segment" void bt_closest_point_on_segment(btVector3 mutable& cp_0, btVector3 const& v_1, btVector3 const& e1_2, btVector3 const& e2_3);
public threaded function extern "::btMatrix3x3" "nocdecl" btMatrix3x3 btMatrix3x3_1(btQuaternion const& q_0);
public threaded function extern "::btMatrix3x3" "nocdecl" btMatrix3x3 btMatrix3x3_9(btScalar const& xx_0, btScalar const& xy_1, btScalar const& xz_2, btScalar const& yx_3, btScalar const& yy_4, btScalar const& yz_5, btScalar const& zx_6, btScalar const& zy_7, btScalar const& zz_8);
public threaded function extern "::btGjkPairDetector" "nocdecl" btGjkPairDetector btGjkPairDetector8(crptr{btConvexShape} objectA_0, crptr{btConvexShape} objectB_1, int shapeTypeA_2, int shapeTypeB_3, btScalar marginA_4, btScalar marginB_5, rptr{btVoronoiSimplexSolver} simplexSolver_6, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_7);
public threaded function extern "::btGjkPairDetector" "nocdecl" btGjkPairDetector btGjkPairDetector4(crptr{btConvexShape} objectA_0, crptr{btConvexShape} objectB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_3);
public threaded function extern "::btManifoldResult::calculateCombinedFriction" "nocdecl" btScalar btManifoldResult_calculateCombinedFriction(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
public threaded function extern "::btTransformUtil::integrateTransform" "nocdecl" void btTransformUtil_integrateTransform(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btTransform mutable& predictedTransform_4);
public threaded function extern "::btCollisionWorld::rayTestSingleInternal" "nocdecl" void btCollisionWorld_rayTestSingleInternal(btTransform const& rayFromTrans_0, btTransform const& rayToTrans_1, crptr{btCollisionObjectWrapper} collisionObjectWrap_2, btCollisionWorld_RayResultCallback mutable& resultCallback_3);
public threaded function extern "::btCollisionDispatcher::defaultNearCallback" "nocdecl" void btCollisionDispatcher_defaultNearCallback(btBroadphasePair mutable& collisionPair_0, btCollisionDispatcher mutable& dispatcher_1, btDispatcherInfo const& dispatchInfo_2);
public threaded function extern "::btSoftBody::clusterDCImpulse" "nocdecl" void btSoftBody_clusterDCImpulse(rptr{btSoftBody_Cluster} cluster_0, btVector3 const& impulse_1);
public threaded function extern "::btOutcode" int btOutcode(btVector3 const& p_0, btVector3 const& halfExtent_1);
public threaded function extern "::btDbvt::enumNodes" "nocdecl" void btDbvt_enumNodes(crptr{btDbvtNode} root_0, btDbvt_ICollide mutable& policy_1);
public threaded function extern "::btPolyhedralContactClipping::clipFace" "nocdecl" void btPolyhedralContactClipping_clipFace(btVertexArray const& pVtxIn_0, btVertexArray mutable& ppVtxOut_1, btVector3 const& planeNormalWS_2, btScalar planeEqWS_3);
public threaded function extern "::btUnSwapVector3Endian" void btUnSwapVector3Endian(btVector3 mutable& vector_0);
public threaded function extern "::btCollisionWorld::LocalRayResult" "nocdecl" btCollisionWorld_LocalRayResult btCollisionWorld_LocalRayResult4(crptr{btCollisionObject} collisionObject_0, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo_1, btVector3 const& hitNormalLocal_2, btScalar hitFraction_3);
public threaded function extern "::btSphereShape" "nocdecl" btSphereShape btSphereShape1(btScalar radius_0);
public threaded function extern "::btPolarDecomposition" "nocdecl" btPolarDecomposition btPolarDecomposition2(btScalar tolerance_0, uint maxIterations_1);
public threaded function extern "::btSwapEndianDouble" void btSwapEndianDouble(double d_0, rptr{uchar} dst_1);
public threaded function extern "::btSoftBodyHelpers::CalculateUV" "nocdecl" float btSoftBodyHelpers_CalculateUV(int resx_0, int resy_1, int ix_2, int iy_3, int id_4);
public threaded function extern "::btSoftBody::clusterImpulse" "nocdecl" void btSoftBody_clusterImpulse(rptr{btSoftBody_Cluster} cluster_0, btVector3 const& rpos_1, btSoftBody_Impulse const& impulse_2);
public threaded function extern "::btConvexConcaveCollisionAlgorithm" "nocdecl" btConvexConcaveCollisionAlgorithm btConvexConcaveCollisionAlgorithm4(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public threaded function extern "::btCollisionAlgorithm" "nocdecl" btCollisionAlgorithm btCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public threaded function extern "::btTransform::getIdentity" "nocdecl" btTransform const& btTransform_getIdentity();
public threaded function extern "::btLargeDot" btScalar btLargeDot(crptr{btScalar} a_0, crptr{btScalar} b_1, int n_2);
public threaded function extern "::btRadians" btScalar btRadians(btScalar x_0);
public threaded function extern "::btConvex2dShape" "nocdecl" btConvex2dShape btConvex2dShape1(rptr{btConvexShape} convexChildShape_0);
public threaded function extern "::btDbvt::sStkCLN" "nocdecl" btDbvt_sStkCLN btDbvt_sStkCLN2(crptr{btDbvtNode} n_0, rptr{btDbvtNode} p_1);
private metafunction bt32BitAxisSweep3_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{bt32BitAxisSweep3, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{bt32BitAxisSweep3, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
bt32BitAxisSweep3_getOverlappingPairCache__rt{tis}
bt32BitAxisSweep3_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btAlignedObjectArray_bool_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_bool, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_bool, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_bool_at__rt{tis}
btAlignedObjectArray_bool_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btActionInterface_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btActionInterface_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btActionInterface_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btActionInterface_p_at__rt{tis}
btAlignedObjectArray_btActionInterface_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btAlignedObjectArray_int__at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btAlignedObjectArray_int_, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btAlignedObjectArray_int_, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btAlignedObjectArray_int__at__rt{tis}
btAlignedObjectArray_btAlignedObjectArray_int__at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBroadphaseInterface_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphaseInterface_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphaseInterface_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btBroadphaseInterface_p_at__rt{tis}
btAlignedObjectArray_btBroadphaseInterface_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBroadphasePair_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphasePair, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphasePair, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btBroadphasePair_at__rt{tis}
btAlignedObjectArray_btBroadphasePair_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBvhSubtreeInfo_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBvhSubtreeInfo, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBvhSubtreeInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btBvhSubtreeInfo_at__rt{tis}
btAlignedObjectArray_btBvhSubtreeInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btChunk_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btChunk_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btChunk_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btChunk_p_at__rt{tis}
btAlignedObjectArray_btChunk_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionAlgorithm_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionAlgorithm_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionAlgorithm_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btCollisionAlgorithm_p_at__rt{tis}
btAlignedObjectArray_btCollisionAlgorithm_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionObject_const_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_const_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_const_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btCollisionObject_const_p_at__rt{tis}
btAlignedObjectArray_btCollisionObject_const_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionObject_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btCollisionObject_p_at__rt{tis}
btAlignedObjectArray_btCollisionObject_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionShape_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionShape_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionShape_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btCollisionShape_p_at__rt{tis}
btAlignedObjectArray_btCollisionShape_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCompoundShapeChild_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCompoundShapeChild, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCompoundShapeChild, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btCompoundShapeChild_at__rt{tis}
btAlignedObjectArray_btCompoundShapeChild_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btConvexHullComputer_Edge_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btConvexHullComputer_Edge, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btConvexHullComputer_Edge, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btConvexHullComputer_Edge_at__rt{tis}
btAlignedObjectArray_btConvexHullComputer_Edge_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvtNode_const_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvtNode_const_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvtNode_const_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btDbvtNode_const_p_at__rt{tis}
btAlignedObjectArray_btDbvtNode_const_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNN_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNN, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNN, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btDbvt_sStkNN_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNN_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNP_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNP, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNP, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btDbvt_sStkNP_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNP_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNPS_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNPS, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNPS, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btDbvt_sStkNPS_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNPS_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btElement_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btElement, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btElement, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btElement_at__rt{tis}
btAlignedObjectArray_btElement_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btFace_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btFace, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btFace, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btFace_at__rt{tis}
btAlignedObjectArray_btFace_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btGImpactMeshShapePart_TrimeshPrimitiveManager_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btGImpactMeshShapePart_TrimeshPrimitiveManager, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btGImpactMeshShapePart_TrimeshPrimitiveManager, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btGImpactMeshShapePart_TrimeshPrimitiveManager_at__rt{tis}
btAlignedObjectArray_btGImpactMeshShapePart_TrimeshPrimitiveManager_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btGImpactMeshShapePart_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btGImpactMeshShapePart_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btGImpactMeshShapePart_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btGImpactMeshShapePart_p_at__rt{tis}
btAlignedObjectArray_btGImpactMeshShapePart_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashInt_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashInt, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashInt, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btHashInt_at__rt{tis}
btAlignedObjectArray_btHashInt_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashKey_btTriIndex__at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashKey_btTriIndex_, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashKey_btTriIndex_, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btHashKey_btTriIndex__at__rt{tis}
btAlignedObjectArray_btHashKey_btTriIndex__at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashPtr_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashPtr, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashPtr, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btHashPtr_at__rt{tis}
btAlignedObjectArray_btHashPtr_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashString_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashString, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashString, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btHashString_at__rt{tis}
btAlignedObjectArray_btHashString_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btIndexedMesh_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btIndexedMesh, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btIndexedMesh, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btIndexedMesh_at__rt{tis}
btAlignedObjectArray_btIndexedMesh_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMaterialProperties_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMaterialProperties, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMaterialProperties, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btMaterialProperties_at__rt{tis}
btAlignedObjectArray_btMaterialProperties_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMaterial_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMaterial_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMaterial_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btMaterial_p_at__rt{tis}
btAlignedObjectArray_btMaterial_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at__rt{tis}
btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at__rt{tis}
btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btOptimizedBvhNode_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvhNode, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvhNode, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btOptimizedBvhNode_at__rt{tis}
btAlignedObjectArray_btOptimizedBvhNode_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btOptimizedBvh_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvh_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvh_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btOptimizedBvh_p_at__rt{tis}
btAlignedObjectArray_btOptimizedBvh_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btPersistentManifold_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPersistentManifold_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPersistentManifold_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btPersistentManifold_p_at__rt{tis}
btAlignedObjectArray_btPersistentManifold_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btPointerUid_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPointerUid, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPointerUid, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btPointerUid_at__rt{tis}
btAlignedObjectArray_btPointerUid_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btQuantizedBvhNode_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhNode, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhNode, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btQuantizedBvhNode_at__rt{tis}
btAlignedObjectArray_btQuantizedBvhNode_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btRigidBody_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBody_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBody_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btRigidBody_p_at__rt{tis}
btAlignedObjectArray_btRigidBody_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSimplePair_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSimplePair, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSimplePair, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSimplePair_at__rt{tis}
btAlignedObjectArray_btSimplePair_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Anchor_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Anchor, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Anchor, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Anchor_at__rt{tis}
btAlignedObjectArray_btSoftBody_Anchor_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Cluster_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Cluster_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Cluster_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Cluster_p_at__rt{tis}
btAlignedObjectArray_btSoftBody_Cluster_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Face_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Face, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Face, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Face_at__rt{tis}
btAlignedObjectArray_btSoftBody_Face_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Joint_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Joint_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Joint_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Joint_p_at__rt{tis}
btAlignedObjectArray_btSoftBody_Joint_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Link_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Link, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Link, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Link_at__rt{tis}
btAlignedObjectArray_btSoftBody_Link_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Material_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Material_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Material_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Material_p_at__rt{tis}
btAlignedObjectArray_btSoftBody_Material_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Node_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Node, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Node, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Node_at__rt{tis}
btAlignedObjectArray_btSoftBody_Node_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Node_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Node_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Node_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Node_p_at__rt{tis}
btAlignedObjectArray_btSoftBody_Node_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Note_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Note, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Note, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Note_at__rt{tis}
btAlignedObjectArray_btSoftBody_Note_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_RContact_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_RContact, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_RContact, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_RContact_at__rt{tis}
btAlignedObjectArray_btSoftBody_RContact_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_SContact_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_SContact, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_SContact, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_SContact_at__rt{tis}
btAlignedObjectArray_btSoftBody_SContact_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_Tetra_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Tetra, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_Tetra, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_Tetra_at__rt{tis}
btAlignedObjectArray_btSoftBody_Tetra_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSoftBody_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSoftBody_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSoftBody_p_at__rt{tis}
btAlignedObjectArray_btSoftBody_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSolverBody_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverBody, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverBody, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSolverBody_at__rt{tis}
btAlignedObjectArray_btSolverBody_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSolverConstraint_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverConstraint, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverConstraint, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSolverConstraint_at__rt{tis}
btAlignedObjectArray_btSolverConstraint_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSparseSdf_3_Cell_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSparseSdf_3_Cell_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSparseSdf_3_Cell_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btSparseSdf_3_Cell_p_at__rt{tis}
btAlignedObjectArray_btSparseSdf_3_Cell_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btStridingMeshInterfaceData_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btStridingMeshInterfaceData_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btStridingMeshInterfaceData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btStridingMeshInterfaceData_p_at__rt{tis}
btAlignedObjectArray_btStridingMeshInterfaceData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTransform_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTransform, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTransform, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTransform_at__rt{tis}
btAlignedObjectArray_btTransform_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriIndex_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriIndex, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriIndex, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTriIndex_at__rt{tis}
btAlignedObjectArray_btTriIndex_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriangle_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangle, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangle, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTriangle_at__rt{tis}
btAlignedObjectArray_btTriangle_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriangleIndexVertexArray_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleIndexVertexArray_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleIndexVertexArray_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTriangleIndexVertexArray_p_at__rt{tis}
btAlignedObjectArray_btTriangleIndexVertexArray_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriangleInfo_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleInfo, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTriangleInfo_at__rt{tis}
btAlignedObjectArray_btTriangleInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriangleInfoMap_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleInfoMap_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleInfoMap_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTriangleInfoMap_p_at__rt{tis}
btAlignedObjectArray_btTriangleInfoMap_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_btConstraintInfo1, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_btConstraintInfo1, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at__rt{tis}
btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraint_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btTypedConstraint_p_at__rt{tis}
btAlignedObjectArray_btTypedConstraint_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btVector3_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btVector3_at__rt{tis}
btAlignedObjectArray_btVector3_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btVector3DoubleData_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3DoubleData_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3DoubleData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btVector3DoubleData_p_at__rt{tis}
btAlignedObjectArray_btVector3DoubleData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btVector3FloatData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3FloatData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3FloatData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btVector3FloatData_p_at__rt{tis}
btAlignedObjectArray_btVector3FloatData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btWheelInfo_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btWheelInfo, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btWheelInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_btWheelInfo_at__rt{tis}
btAlignedObjectArray_btWheelInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_char_const_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_const_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_const_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_char_const_p_at__rt{tis}
btAlignedObjectArray_char_const_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_char_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_char_p_at__rt{tis}
btAlignedObjectArray_char_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_double_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_double, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_double, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_double_at__rt{tis}
btAlignedObjectArray_double_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_float_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_float, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_float, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_float_at__rt{tis}
btAlignedObjectArray_float_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_int_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_int_at__rt{tis}
btAlignedObjectArray_int_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_int_p_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int_p, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_int_p_at__rt{tis}
btAlignedObjectArray_int_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_short_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_short_at__rt{tis}
btAlignedObjectArray_short_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_short_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_short_p_at__rt{tis}
btAlignedObjectArray_short_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_unsigned_char_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_char_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_char_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_unsigned_char_p_at__rt{tis}
btAlignedObjectArray_unsigned_char_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_unsigned_int_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_int, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_int, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_unsigned_int_at__rt{tis}
btAlignedObjectArray_unsigned_int_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_unsigned_short_at__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_short, "at"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_short, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_unsigned_short_at__rt{tis}
btAlignedObjectArray_unsigned_short_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_void_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_void_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_void_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAlignedObjectArray_void_p_at__rt{tis}
btAlignedObjectArray_void_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAxisSweep3_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btAxisSweep3, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btAxisSweep3, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3_getOverlappingPairCache__rt{tis}
btAxisSweep3_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btAxisSweep3Internal_unsigned_int_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_int, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_int, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3Internal_unsigned_int_getOverlappingPairCache__rt{tis}
btAxisSweep3Internal_unsigned_int_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btAxisSweep3Internal_unsigned_short_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_short, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_short, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3Internal_unsigned_short_getOverlappingPairCache__rt{tis}
btAxisSweep3Internal_unsigned_short_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btBU_Simplex1to4_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBU_Simplex1to4, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBU_Simplex1to4, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBU_Simplex1to4_setSafeMargin__rt{tis}
btBU_Simplex1to4_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btBox2dShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBox2dShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBox2dShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBox2dShape_setSafeMargin__rt{tis}
btBox2dShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btBoxShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBoxShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBoxShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBoxShape_setSafeMargin__rt{tis}
btBoxShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btBroadphaseInterface_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btBroadphaseInterface, "getOverlappingPairCache"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btBroadphaseInterface, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBroadphaseInterface_getOverlappingPairCache__rt{tis}
btBroadphaseInterface_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btBulletWorldImporter_createConeTwistConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btTransform,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createConeTwistConstraint2"}},
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createConeTwistConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBulletWorldImporter_createConeTwistConstraint__rt{tis}
btBulletWorldImporter_createConeTwistConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btTransform,0}}}) {
    return a0.createConeTwistConstraint2(a1,a2);
  } else if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}}) {
    return a0.createConeTwistConstraint4(a1,a2,a3,a4);
  }
}
private metafunction btBulletWorldImporter_createHingeConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createHingeConstraint5"}},
    match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createHingeConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBulletWorldImporter_createHingeConstraint__rt{tis}
btBulletWorldImporter_createHingeConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return a0.createHingeConstraint5(a1,a2,a3,a4,a5);
  } else if (match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return a0.createHingeConstraint3(a1,a2,a3);
  }
}
private metafunction btBulletWorldImporter_createSliderConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createSliderConstraint3"}},
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createSliderConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBulletWorldImporter_createSliderConstraint__rt{tis}
btBulletWorldImporter_createSliderConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return a0.createSliderConstraint3(a1,a2,a3);
  } else if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return a0.createSliderConstraint5(a1,a2,a3,a4,a5);
  }
}
private metafunction btBulletWorldImporter_createGeneric6DofConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createGeneric6DofConstraint3"}},
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createGeneric6DofConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBulletWorldImporter_createGeneric6DofConstraint__rt{tis}
btBulletWorldImporter_createGeneric6DofConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return a0.createGeneric6DofConstraint3(a1,a2,a3);
  } else if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return a0.createGeneric6DofConstraint5(a1,a2,a3,a4,a5);
  }
}
private metafunction btBulletWorldImporter_createPoint2PointConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btVector3,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createPoint2PointConstraint2"}},
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btBulletWorldImporter, "createPoint2PointConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBulletWorldImporter_createPoint2PointConstraint__rt{tis}
btBulletWorldImporter_createPoint2PointConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btVector3,0}}}) {
    return a0.createPoint2PointConstraint2(a1,a2);
  } else if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}}) {
    return a0.createPoint2PointConstraint4(a1,a2,a3,a4);
  }
}
private metafunction btBvhTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBvhTriangleMeshShape_getMeshInterface__rt{tis}
btBvhTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btBvhTriangleMeshShape_getTriangleInfoMap__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getTriangleInfoMap"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getTriangleInfoMap"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBvhTriangleMeshShape_getTriangleInfoMap__rt{tis}
btBvhTriangleMeshShape_getTriangleInfoMap(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getTriangleInfoMap();
  } else if (match_args{tis, {0}}) {
    return a0.getTriangleInfoMap();
  }
}
private metafunction btCapsuleShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShape_setSafeMargin__rt{tis}
btCapsuleShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCapsuleShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeX, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeX, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShapeX_setSafeMargin__rt{tis}
btCapsuleShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCapsuleShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeZ, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeZ, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShapeZ_setSafeMargin__rt{tis}
btCapsuleShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCollisionDispatcher_getManifoldByIndexInternal__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getManifoldByIndexInternal"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getManifoldByIndexInternal"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionDispatcher_getManifoldByIndexInternal__rt{tis}
btCollisionDispatcher_getManifoldByIndexInternal(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getManifoldByIndexInternal(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getManifoldByIndexInternal(a1);
  }
}
private metafunction btCollisionDispatcher_getCollisionConfiguration__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getCollisionConfiguration"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getCollisionConfiguration"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionDispatcher_getCollisionConfiguration__rt{tis}
btCollisionDispatcher_getCollisionConfiguration(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionConfiguration();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionConfiguration();
  }
}
private metafunction btCollisionDispatcher_getInternalManifoldPool__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getInternalManifoldPool"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getInternalManifoldPool"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionDispatcher_getInternalManifoldPool__rt{tis}
btCollisionDispatcher_getInternalManifoldPool(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInternalManifoldPool();
  } else if (match_args{tis, {0}}) {
    return a0.getInternalManifoldPool();
  }
}
private metafunction btCollisionObject_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getWorldTransform"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObject_getWorldTransform__rt{tis}
btCollisionObject_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btCollisionObject_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getCollisionShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObject_getCollisionShape__rt{tis}
btCollisionObject_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btCollisionObject_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getInterpolationWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObject_getInterpolationWorldTransform__rt{tis}
btCollisionObject_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btCollisionObject_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getBroadphaseHandle"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObject_getBroadphaseHandle__rt{tis}
btCollisionObject_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btCollisionWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getBroadphase"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_getBroadphase__rt{tis}
btCollisionWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  }
}
private metafunction btCollisionWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatcher"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_getDispatcher__rt{tis}
btCollisionWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  }
}
private metafunction btCollisionWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_getDispatchInfo__rt{tis}
btCollisionWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btCollisionWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getCollisionObjectArray"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_getCollisionObjectArray__rt{tis}
btCollisionWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btCompoundShape_getDynamicAabbTree__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCompoundShape, "getDynamicAabbTree"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCompoundShape, "getDynamicAabbTree"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundShape_getDynamicAabbTree__rt{tis}
btCompoundShape_getDynamicAabbTree(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDynamicAabbTree();
  } else if (match_args{tis, {1}}) {
    return a0.getDynamicAabbTree();
  }
}
private metafunction btCompoundShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildShape"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundShape_getChildShape__rt{tis}
btCompoundShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildShape(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildShape(a1);
  }
}
private metafunction btCompoundShape_getChildTransform__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildTransform"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundShape_getChildTransform__rt{tis}
btCompoundShape_getChildTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildTransform(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildTransform(a1);
  }
}
private metafunction btConeShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShape_setSafeMargin__rt{tis}
btConeShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConeShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeX, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeX, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShapeX_setSafeMargin__rt{tis}
btConeShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btConeShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeZ, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeZ, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShapeZ_setSafeMargin__rt{tis}
btConeShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConeTwistConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint_getRigidBodyA__rt{tis}
btConeTwistConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btConeTwistConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint_getJointFeedback__rt{tis}
btConeTwistConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btConeTwistConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint_getRigidBodyB__rt{tis}
btConeTwistConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btConeTwistConstraint_setLimit__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeTwistConstraint, "setLimit2"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeTwistConstraint, "setLimit6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint_setLimit__rt{tis}
btConeTwistConstraint_setLimit(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0},{btScalar,0}}}) {
    return a0.setLimit2(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setLimit6(a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btContactConstraint_getContactManifold__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btContactConstraint, "getContactManifold"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btContactConstraint, "getContactManifold"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btContactConstraint_getContactManifold__rt{tis}
btContactConstraint_getContactManifold(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getContactManifold();
  } else if (match_args{tis, {1}}) {
    return a0.getContactManifold();
  }
}
private metafunction btContactConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btContactConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btContactConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btContactConstraint_getRigidBodyB__rt{tis}
btContactConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btContactConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btContactConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btContactConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btContactConstraint_getJointFeedback__rt{tis}
btContactConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btContactConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btContactConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btContactConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btContactConstraint_getRigidBodyA__rt{tis}
btContactConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btConvex2dShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvex2dShape, "getChildShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvex2dShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvex2dShape_getChildShape__rt{tis}
btConvex2dShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getChildShape();
  } else if (match_args{tis, {0}}) {
    return a0.getChildShape();
  }
}
private metafunction btConvexHullComputer_compute__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{float},0},{int,0},{int,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullComputer, "compute_float_cp_int_int_btScalar_btScalar"}},
    match_args{tis, {1,{crptr{double},0},{int,0},{int,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullComputer, "compute_double_cp_int_int_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullComputer_compute__rt{tis}
btConvexHullComputer_compute(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{float},0},{int,0},{int,0},{btScalar,0},{btScalar,0}}}) {
    return a0.compute_float_cp_int_int_btScalar_btScalar(a1,a2,a3,a4,a5);
  } else if (match_args{tis, {1,{crptr{double},0},{int,0},{int,0},{btScalar,0},{btScalar,0}}}) {
    return a0.compute_double_cp_int_int_btScalar_btScalar(a1,a2,a3,a4,a5);
  }
}
private metafunction btConvexHullShape_project__rt{tis}
  m::cond{
    match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1}}},
    m::ret_type{m::symbol{btConvexHullShape, "project4"}},
    match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{btConvexHullShape, "project6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullShape_project__rt{tis}
btConvexHullShape_project(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1}}}) {
    return a0.project4(a1,a2,a3,a4);
  } else if (match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1},{btVector3,1},{btVector3,1}}}) {
    return a0.project6(a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btConvexHullShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullShape_setSafeMargin__rt{tis}
btConvexHullShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btConvexHullShape_getUnscaledPoints__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvexHullShape, "getUnscaledPoints"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvexHullShape, "getUnscaledPoints"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullShape_getUnscaledPoints__rt{tis}
btConvexHullShape_getUnscaledPoints(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getUnscaledPoints();
  } else if (match_args{tis, {0}}) {
    return a0.getUnscaledPoints();
  }
}
private metafunction btConvexInternalAabbCachingShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalAabbCachingShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalAabbCachingShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexInternalAabbCachingShape_setSafeMargin__rt{tis}
btConvexInternalAabbCachingShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConvexInternalShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexInternalShape_setSafeMargin__rt{tis}
btConvexInternalShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btConvexPointCloudShape_getUnscaledPoints__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvexPointCloudShape, "getUnscaledPoints"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvexPointCloudShape, "getUnscaledPoints"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexPointCloudShape_getUnscaledPoints__rt{tis}
btConvexPointCloudShape_getUnscaledPoints(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getUnscaledPoints();
  } else if (match_args{tis, {0}}) {
    return a0.getUnscaledPoints();
  }
}
private metafunction btConvexPointCloudShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexPointCloudShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexPointCloudShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexPointCloudShape_setSafeMargin__rt{tis}
btConvexPointCloudShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btConvexTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexTriangleMeshShape_getMeshInterface__rt{tis}
btConvexTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btConvexTriangleMeshShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexTriangleMeshShape_setSafeMargin__rt{tis}
btConvexTriangleMeshShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btCylinderShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShape_setSafeMargin__rt{tis}
btCylinderShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCylinderShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeX, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeX, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShapeX_setSafeMargin__rt{tis}
btCylinderShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btCylinderShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeZ, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeZ, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShapeZ_setSafeMargin__rt{tis}
btCylinderShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btDbvt_update__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt, "update4"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume_btScalar"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume_btVector3"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{int,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_int"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_update__rt{tis}
btDbvt_update(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0},{btScalar,0}}}) {
    return a0.update4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btScalar,0}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume_btScalar(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume_btVector3(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{int,0}}}) {
    return a0.update_btDbvtNode_p_int(a1,a2);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume(a1,a2);
  }
}
private metafunction btDbvtBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDbvtBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDbvtBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvtBroadphase_getOverlappingPairCache__rt{tis}
btDbvtBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btDbvt_ICollide_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process_btDbvtNode_cp_btScalar"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_ICollide_Process__rt{tis}
btDbvt_ICollide_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  }
}
private metafunction btDefaultSoftBodySolver_processCollision__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btSoftBody},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{btDefaultSoftBodySolver, "processCollision_btSoftBody_p_btCollisionObjectWrapper_cp"}},
    match_args{tis, {1,{rptr{btSoftBody},0},{rptr{btSoftBody},0}}},
    m::ret_type{m::symbol{btDefaultSoftBodySolver, "processCollision_btSoftBody_p_btSoftBody_p"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultSoftBodySolver_processCollision__rt{tis}
btDefaultSoftBodySolver_processCollision(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btSoftBody},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return a0.processCollision_btSoftBody_p_btCollisionObjectWrapper_cp(a1,a2);
  } else if (match_args{tis, {1,{rptr{btSoftBody},0},{rptr{btSoftBody},0}}}) {
    return a0.processCollision_btSoftBody_p_btSoftBody_p(a1,a2);
  }
}
private metafunction btDiscreteDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getConstraint"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getConstraint__rt{tis}
btDiscreteDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btDiscreteDynamicsWorld_getSimulationIslandManager__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getSimulationIslandManager"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getSimulationIslandManager"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getSimulationIslandManager__rt{tis}
btDiscreteDynamicsWorld_getSimulationIslandManager(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getSimulationIslandManager();
  } else if (match_args{tis, {1}}) {
    return a0.getSimulationIslandManager();
  }
}
private metafunction btDiscreteDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getDispatchInfo__rt{tis}
btDiscreteDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btDiscreteDynamicsWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getCollisionObjectArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getCollisionObjectArray__rt{tis}
btDiscreteDynamicsWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btDiscreteDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getBroadphase"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getBroadphase__rt{tis}
btDiscreteDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  }
}
private metafunction btDiscreteDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatcher"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_getDispatcher__rt{tis}
btDiscreteDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  }
}
private metafunction btDiscreteDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "addRigidBody3"}},
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "addRigidBody1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld_addRigidBody__rt{tis}
btDiscreteDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  }
}
private metafunction btDispatcher_getInternalManifoldPool__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDispatcher, "getInternalManifoldPool"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDispatcher, "getInternalManifoldPool"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDispatcher_getInternalManifoldPool__rt{tis}
btDispatcher_getInternalManifoldPool(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getInternalManifoldPool();
  } else if (match_args{tis, {1}}) {
    return a0.getInternalManifoldPool();
  }
}
private metafunction btDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatcher"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getDispatcher__rt{tis}
btDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  }
}
private metafunction btDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getBroadphase"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getBroadphase__rt{tis}
btDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  }
}
private metafunction btDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "addRigidBody3"}},
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "addRigidBody1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_addRigidBody__rt{tis}
btDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  }
}
private metafunction btDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "getConstraint"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getConstraint__rt{tis}
btDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btDynamicsWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getCollisionObjectArray"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getCollisionObjectArray__rt{tis}
btDynamicsWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld_getDispatchInfo__rt{tis}
btDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btFixedConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btFixedConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btFixedConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btFixedConstraint_getRigidBodyB__rt{tis}
btFixedConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btFixedConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btFixedConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btFixedConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btFixedConstraint_getRigidBodyA__rt{tis}
btFixedConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btFixedConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btFixedConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btFixedConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btFixedConstraint_getJointFeedback__rt{tis}
btFixedConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGImpactCompoundShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btGImpactCompoundShape, "getChildShape"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGImpactCompoundShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactCompoundShape_getChildShape__rt{tis}
btGImpactCompoundShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildShape(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildShape(a1);
  }
}
private metafunction btGImpactCompoundShape_addChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{btTransform,0},{rptr{btCollisionShape},0}}},
    m::ret_type{m::symbol{btGImpactCompoundShape, "addChildShape2"}},
    match_args{tis, {1,{rptr{btCollisionShape},0}}},
    m::ret_type{m::symbol{btGImpactCompoundShape, "addChildShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactCompoundShape_addChildShape__rt{tis}
btGImpactCompoundShape_addChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btTransform,0},{rptr{btCollisionShape},0}}}) {
    return a0.addChildShape2(a1,a2);
  } else if (match_args{tis, {1,{rptr{btCollisionShape},0}}}) {
    return a0.addChildShape1(a1);
  }
}
private metafunction btGImpactConvexDecompositionShape_addChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btCollisionShape},0}}},
    m::ret_type{m::symbol{btGImpactConvexDecompositionShape, "addChildShape1"}},
    match_args{tis, {1,{btTransform,0},{rptr{btCollisionShape},0}}},
    m::ret_type{m::symbol{btGImpactConvexDecompositionShape, "addChildShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactConvexDecompositionShape_addChildShape__rt{tis}
btGImpactConvexDecompositionShape_addChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btCollisionShape},0}}}) {
    return a0.addChildShape1(a1);
  } else if (match_args{tis, {1,{btTransform,0},{rptr{btCollisionShape},0}}}) {
    return a0.addChildShape2(a1,a2);
  }
}
private metafunction btGImpactConvexDecompositionShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGImpactConvexDecompositionShape, "getChildShape"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btGImpactConvexDecompositionShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactConvexDecompositionShape_getChildShape__rt{tis}
btGImpactConvexDecompositionShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildShape(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildShape(a1);
  }
}
private metafunction btGImpactMeshShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGImpactMeshShape, "getChildShape"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btGImpactMeshShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactMeshShape_getChildShape__rt{tis}
btGImpactMeshShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildShape(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildShape(a1);
  }
}
private metafunction btGImpactMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGImpactMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGImpactMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactMeshShape_getMeshInterface__rt{tis}
btGImpactMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btGImpactMeshShape_getMeshPart__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btGImpactMeshShape, "getMeshPart"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGImpactMeshShape, "getMeshPart"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactMeshShape_getMeshPart__rt{tis}
btGImpactMeshShape_getMeshPart(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getMeshPart(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getMeshPart(a1);
  }
}
private metafunction btGImpactMeshShapePart_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGImpactMeshShapePart, "getChildShape"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btGImpactMeshShapePart, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactMeshShapePart_getChildShape__rt{tis}
btGImpactMeshShapePart_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildShape(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildShape(a1);
  }
}
private metafunction btGImpactShapeInterface_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGImpactShapeInterface, "getChildShape"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btGImpactShapeInterface, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactShapeInterface_getChildShape__rt{tis}
btGImpactShapeInterface_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildShape(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildShape(a1);
  }
}
private metafunction btGearConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGearConstraint_getRigidBodyB__rt{tis}
btGearConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGearConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGearConstraint_getJointFeedback__rt{tis}
btGearConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGearConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGearConstraint_getRigidBodyA__rt{tis}
btGearConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGeneric6DofConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getRigidBodyA__rt{tis}
btGeneric6DofConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGeneric6DofConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getJointFeedback__rt{tis}
btGeneric6DofConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGeneric6DofConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getFrameOffsetA__rt{tis}
btGeneric6DofConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btGeneric6DofConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getRigidBodyB__rt{tis}
btGeneric6DofConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGeneric6DofConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "calculateTransforms0"}},
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "calculateTransforms2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_calculateTransforms__rt{tis}
btGeneric6DofConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  } else if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  }
}
private metafunction btGeneric6DofConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint_getFrameOffsetB__rt{tis}
btGeneric6DofConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btGeneric6DofSpringConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getRigidBodyB__rt{tis}
btGeneric6DofSpringConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGeneric6DofSpringConstraint_setEquilibriumPoint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint2"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint1"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint0"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_setEquilibriumPoint__rt{tis}
btGeneric6DofSpringConstraint_setEquilibriumPoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0},{btScalar,0}}}) {
    return a0.setEquilibriumPoint2(a1,a2);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.setEquilibriumPoint1(a1);
  } else if (match_args{tis, {1}}) {
    return a0.setEquilibriumPoint0();
  }
}
private metafunction btGeneric6DofSpringConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getFrameOffsetB__rt{tis}
btGeneric6DofSpringConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btGeneric6DofSpringConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "calculateTransforms2"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "calculateTransforms0"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_calculateTransforms__rt{tis}
btGeneric6DofSpringConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  } else if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  }
}
private metafunction btGeneric6DofSpringConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getRigidBodyA__rt{tis}
btGeneric6DofSpringConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGeneric6DofSpringConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getFrameOffsetA__rt{tis}
btGeneric6DofSpringConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btGeneric6DofSpringConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint_getJointFeedback__rt{tis}
btGeneric6DofSpringConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGhostObject_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGhostObject_getWorldTransform__rt{tis}
btGhostObject_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btGhostObject_getOverlappingPairs__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getOverlappingPairs"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getOverlappingPairs"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGhostObject_getOverlappingPairs__rt{tis}
btGhostObject_getOverlappingPairs(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairs();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairs();
  }
}
private metafunction btGhostObject_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getCollisionShape"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGhostObject_getCollisionShape__rt{tis}
btGhostObject_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btGhostObject_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getBroadphaseHandle"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGhostObject_getBroadphaseHandle__rt{tis}
btGhostObject_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btGhostObject_getOverlappingObject__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGhostObject, "getOverlappingObject"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btGhostObject, "getOverlappingObject"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGhostObject_getOverlappingObject__rt{tis}
btGhostObject_getOverlappingObject(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getOverlappingObject(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getOverlappingObject(a1);
  }
}
private metafunction btGhostObject_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getInterpolationWorldTransform"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGhostObject_getInterpolationWorldTransform__rt{tis}
btGhostObject_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btHashMap_btHashInt_btTriangleInfo_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "find"}},
    match_args{tis, {0,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashInt_btTriangleInfo_find__rt{tis}
btHashMap_btHashInt_btTriangleInfo_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashInt,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashInt,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashInt_btTriangleInfo_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashInt_btTriangleInfo_getAtIndex__rt{tis}
btHashMap_btHashInt_btTriangleInfo_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashInt_int_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "find"}},
    match_args{tis, {1,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashInt_int_find__rt{tis}
btHashMap_btHashInt_int_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashInt,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashInt,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashInt_int_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashInt_int_getAtIndex__rt{tis}
btHashMap_btHashInt_int_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashKey_btTriIndex_btTriIndex_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashKey_btTriIndex,0}}},
    m::ret_type{m::symbol{btHashMap_btHashKey_btTriIndex_btTriIndex, "find"}},
    match_args{tis, {0,{btHashKey_btTriIndex,0}}},
    m::ret_type{m::symbol{btHashMap_btHashKey_btTriIndex_btTriIndex, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashKey_btTriIndex_btTriIndex_find__rt{tis}
btHashMap_btHashKey_btTriIndex_btTriIndex_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashKey_btTriIndex,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashKey_btTriIndex,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashKey_btTriIndex_btTriIndex_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashKey_btTriIndex_btTriIndex, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashKey_btTriIndex_btTriIndex, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashKey_btTriIndex_btTriIndex_getAtIndex__rt{tis}
btHashMap_btHashKey_btTriIndex_btTriIndex_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btCollisionObject_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionObject_p, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionObject_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btCollisionObject_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_btCollisionObject_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btCollisionObject_p_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionObject_p, "find"}},
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionObject_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btCollisionObject_p_find__rt{tis}
btHashMap_btHashPtr_btCollisionObject_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btCollisionShape_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionShape_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionShape_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btCollisionShape_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_btCollisionShape_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btCollisionShape_p_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionShape_p, "find"}},
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionShape_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btCollisionShape_p_find__rt{tis}
btHashMap_btHashPtr_btCollisionShape_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btOptimizedBvh_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btOptimizedBvh_p, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btOptimizedBvh_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btOptimizedBvh_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_btOptimizedBvh_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btOptimizedBvh_p_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btOptimizedBvh_p, "find"}},
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btOptimizedBvh_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btOptimizedBvh_p_find__rt{tis}
btHashMap_btHashPtr_btOptimizedBvh_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btPointerUid_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btPointerUid_find__rt{tis}
btHashMap_btHashPtr_btPointerUid_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btPointerUid_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btPointerUid_getAtIndex__rt{tis}
btHashMap_btHashPtr_btPointerUid_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btTriangleInfoMap_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btTriangleInfoMap_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btTriangleInfoMap_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btTriangleInfoMap_p_find__rt{tis}
btHashMap_btHashPtr_btTriangleInfoMap_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btTriangleInfoMap_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btTriangleInfoMap_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btTriangleInfoMap_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_btTriangleInfoMap_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_btTriangleInfoMap_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_char_const_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_char_const_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_char_const_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_char_const_p_find__rt{tis}
btHashMap_btHashPtr_char_const_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_char_const_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_char_const_p, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_char_const_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_char_const_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_char_const_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_void_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_void_p_find__rt{tis}
btHashMap_btHashPtr_void_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_void_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashPtr_void_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_void_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashString_btCollisionShape_p_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionShape_p, "find"}},
    match_args{tis, {1,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionShape_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_btCollisionShape_p_find__rt{tis}
btHashMap_btHashString_btCollisionShape_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashString,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashString,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashString_btCollisionShape_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionShape_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionShape_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_btCollisionShape_p_getAtIndex__rt{tis}
btHashMap_btHashString_btCollisionShape_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashString_btRigidBody_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btRigidBody_p, "find"}},
    match_args{tis, {0,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btRigidBody_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_btRigidBody_p_find__rt{tis}
btHashMap_btHashString_btRigidBody_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashString,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashString,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashString_btRigidBody_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btRigidBody_p, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btRigidBody_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_btRigidBody_p_getAtIndex__rt{tis}
btHashMap_btHashString_btRigidBody_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashString_btTypedConstraint_p_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btTypedConstraint_p, "find"}},
    match_args{tis, {1,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btTypedConstraint_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_btTypedConstraint_p_find__rt{tis}
btHashMap_btHashString_btTypedConstraint_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashString,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashString,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashString_btTypedConstraint_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btTypedConstraint_p, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btTypedConstraint_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_btTypedConstraint_p_getAtIndex__rt{tis}
btHashMap_btHashString_btTypedConstraint_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashString_int_find__rt{tis}
  m::cond{
    match_args{tis, {0,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "find"}},
    match_args{tis, {1,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_int_find__rt{tis}
btHashMap_btHashString_int_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btHashString,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {1,{btHashString,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashString_int_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashMap_btHashString_int_getAtIndex__rt{tis}
btHashMap_btHashString_int_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashedOverlappingPairCache_getOverlappingPairArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashedOverlappingPairCache_getOverlappingPairArray__rt{tis}
btHashedOverlappingPairCache_getOverlappingPairArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArray();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArray();
  }
}
private metafunction btHashedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btHashedOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btHashedSimplePairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHashedSimplePairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHashedSimplePairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashedSimplePairCache_getOverlappingPairArrayPtr__rt{tis}
btHashedSimplePairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btHashedSimplePairCache_getOverlappingPairArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHashedSimplePairCache, "getOverlappingPairArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHashedSimplePairCache, "getOverlappingPairArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashedSimplePairCache_getOverlappingPairArray__rt{tis}
btHashedSimplePairCache_getOverlappingPairArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArray();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArray();
  }
}
private metafunction btHinge2Constraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getJointFeedback__rt{tis}
btHinge2Constraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btHinge2Constraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getFrameOffsetA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getFrameOffsetA__rt{tis}
btHinge2Constraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btHinge2Constraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getRigidBodyA__rt{tis}
btHinge2Constraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btHinge2Constraint_setEquilibriumPoint__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "setEquilibriumPoint0"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHinge2Constraint, "setEquilibriumPoint1"}},
    match_args{tis, {1,{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHinge2Constraint, "setEquilibriumPoint2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_setEquilibriumPoint__rt{tis}
btHinge2Constraint_setEquilibriumPoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.setEquilibriumPoint0();
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.setEquilibriumPoint1(a1);
  } else if (match_args{tis, {1,{int,0},{btScalar,0}}}) {
    return a0.setEquilibriumPoint2(a1,a2);
  }
}
private metafunction btHinge2Constraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getFrameOffsetB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getFrameOffsetB__rt{tis}
btHinge2Constraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btHinge2Constraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "calculateTransforms0"}},
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btHinge2Constraint, "calculateTransforms2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_calculateTransforms__rt{tis}
btHinge2Constraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  } else if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  }
}
private metafunction btHinge2Constraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHinge2Constraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHinge2Constraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint_getRigidBodyB__rt{tis}
btHinge2Constraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btHingeConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getRigidBodyA__rt{tis}
btHingeConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btHingeConstraint_getBFrame__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getBFrame"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getBFrame"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getBFrame__rt{tis}
btHingeConstraint_getBFrame(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBFrame();
  } else if (match_args{tis, {1}}) {
    return a0.getBFrame();
  }
}
private metafunction btHingeConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getJointFeedback__rt{tis}
btHingeConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btHingeConstraint_setMotorTarget__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "setMotorTarget_btScalar_btScalar"}},
    match_args{tis, {1,{btQuaternion,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "setMotorTarget_btQuaternion_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_setMotorTarget__rt{tis}
btHingeConstraint_setMotorTarget(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setMotorTarget_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btQuaternion,0},{btScalar,0}}}) {
    return a0.setMotorTarget_btQuaternion_btScalar(a1,a2);
  }
}
private metafunction btHingeConstraint_getAFrame__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getAFrame"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getAFrame"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getAFrame__rt{tis}
btHingeConstraint_getAFrame(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getAFrame();
  } else if (match_args{tis, {0}}) {
    return a0.getAFrame();
  }
}
private metafunction btHingeConstraint_getHingeAngle__rt{tis}
  m::cond{
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "getHingeAngle2"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getHingeAngle0"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getHingeAngle__rt{tis}
btHingeConstraint_getHingeAngle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.getHingeAngle2(a1,a2);
  } else if (match_args{tis, {1}}) {
    return a0.getHingeAngle0();
  }
}
private metafunction btHingeConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint_getRigidBodyB__rt{tis}
btHingeConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btIDebugDraw_drawTriangle__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawTriangle8"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawTriangle5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btIDebugDraw_drawTriangle__rt{tis}
btIDebugDraw_drawTriangle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return a0.drawTriangle8(a1,a2,a3,a4,a5,a6,a7,a8);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return a0.drawTriangle5(a1,a2,a3,a4,a5);
  }
}
private metafunction btIDebugDraw_drawLine__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawLine4"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawLine3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btIDebugDraw_drawLine__rt{tis}
btIDebugDraw_drawLine(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawLine4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawLine3(a1,a2,a3);
  }
}
private metafunction btIDebugDraw_drawSphere__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btTransform,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawSphere_btScalar_btTransform_btVector3"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawSphere_btVector3_btScalar_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btIDebugDraw_drawSphere__rt{tis}
btIDebugDraw_drawSphere(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btTransform,0},{btVector3,0}}}) {
    return a0.drawSphere_btScalar_btTransform_btVector3(a1,a2,a3);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0},{btVector3,0}}}) {
    return a0.drawSphere_btVector3_btScalar_btVector3(a1,a2,a3);
  }
}
private metafunction btIDebugDraw_drawBox__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btTransform,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawBox4"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawBox3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btIDebugDraw_drawBox__rt{tis}
btIDebugDraw_drawBox(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btTransform,0},{btVector3,0}}}) {
    return a0.drawBox4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawBox3(a1,a2,a3);
  }
}
private metafunction btJacobianEntry_getNonDiagonal__rt{tis}
  m::cond{
    match_args{tis, {0,{btJacobianEntry,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btJacobianEntry, "getNonDiagonal3"}},
    match_args{tis, {0,{btJacobianEntry,0},{btScalar,0}}},
    m::ret_type{m::symbol{btJacobianEntry, "getNonDiagonal2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btJacobianEntry_getNonDiagonal__rt{tis}
btJacobianEntry_getNonDiagonal(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btJacobianEntry,0},{btScalar,0},{btScalar,0}}}) {
    return a0.getNonDiagonal3(a1,a2,a3);
  } else if (match_args{tis, {0,{btJacobianEntry,0},{btScalar,0}}}) {
    return a0.getNonDiagonal2(a1,a2);
  }
}
private metafunction btManifoldResult_getPersistentManifold__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btManifoldResult, "getPersistentManifold"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btManifoldResult, "getPersistentManifold"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btManifoldResult_getPersistentManifold__rt{tis}
btManifoldResult_getPersistentManifold(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getPersistentManifold();
  } else if (match_args{tis, {1}}) {
    return a0.getPersistentManifold();
  }
}
private metafunction btMinkowskiSumShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMinkowskiSumShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMinkowskiSumShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMinkowskiSumShape_setSafeMargin__rt{tis}
btMinkowskiSumShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btMultiSapBroadphase_getBroadphaseArray__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getBroadphaseArray"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getBroadphaseArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSapBroadphase_getBroadphaseArray__rt{tis}
btMultiSapBroadphase_getBroadphaseArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseArray();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseArray();
  }
}
private metafunction btMultiSapBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSapBroadphase_getOverlappingPairCache__rt{tis}
btMultiSapBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btMultiSphereShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMultiSphereShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMultiSphereShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSphereShape_setSafeMargin__rt{tis}
btMultiSphereShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btMultimaterialTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btMultimaterialTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btMultimaterialTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultimaterialTriangleMeshShape_getMeshInterface__rt{tis}
btMultimaterialTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btMultimaterialTriangleMeshShape_getTriangleInfoMap__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btMultimaterialTriangleMeshShape, "getTriangleInfoMap"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btMultimaterialTriangleMeshShape, "getTriangleInfoMap"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultimaterialTriangleMeshShape_getTriangleInfoMap__rt{tis}
btMultimaterialTriangleMeshShape_getTriangleInfoMap(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getTriangleInfoMap();
  } else if (match_args{tis, {1}}) {
    return a0.getTriangleInfoMap();
  }
}
private metafunction btNullPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btNullPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btNullPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btNullPairCache_getOverlappingPairArrayPtr__rt{tis}
btNullPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btOptimizedBvh_serialize__rt{tis}
  m::cond{
    match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}},
    m::ret_type{m::symbol{btOptimizedBvh, "serialize2"}},
    match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}},
    m::ret_type{m::symbol{btOptimizedBvh, "serialize3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btOptimizedBvh_serialize__rt{tis}
btOptimizedBvh_serialize(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}}) {
    return a0.serialize2(a1,a2);
  } else if (match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}}) {
    return a0.serialize3(a1,a2,a3);
  }
}
private metafunction btOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btPairCachingGhostObject_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getBroadphaseHandle"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPairCachingGhostObject_getBroadphaseHandle__rt{tis}
btPairCachingGhostObject_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btPairCachingGhostObject_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getCollisionShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPairCachingGhostObject_getCollisionShape__rt{tis}
btPairCachingGhostObject_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btPairCachingGhostObject_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getWorldTransform"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPairCachingGhostObject_getWorldTransform__rt{tis}
btPairCachingGhostObject_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btPairCachingGhostObject_getOverlappingPairs__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getOverlappingPairs"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getOverlappingPairs"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPairCachingGhostObject_getOverlappingPairs__rt{tis}
btPairCachingGhostObject_getOverlappingPairs(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairs();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairs();
  }
}
private metafunction btPairCachingGhostObject_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getInterpolationWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPairCachingGhostObject_getInterpolationWorldTransform__rt{tis}
btPairCachingGhostObject_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btPairCachingGhostObject_getOverlappingObject__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getOverlappingObject"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getOverlappingObject"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPairCachingGhostObject_getOverlappingObject__rt{tis}
btPairCachingGhostObject_getOverlappingObject(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getOverlappingObject(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getOverlappingObject(a1);
  }
}
private metafunction btPersistentManifold_getContactPoint__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btPersistentManifold, "getContactPoint"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btPersistentManifold, "getContactPoint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPersistentManifold_getContactPoint__rt{tis}
btPersistentManifold_getContactPoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getContactPoint(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getContactPoint(a1);
  }
}
private metafunction btPoint2PointConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoint2PointConstraint_getRigidBodyB__rt{tis}
btPoint2PointConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btPoint2PointConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoint2PointConstraint_getJointFeedback__rt{tis}
btPoint2PointConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btPoint2PointConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoint2PointConstraint_getRigidBodyA__rt{tis}
btPoint2PointConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btPolyhedralConvexAabbCachingShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexAabbCachingShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexAabbCachingShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPolyhedralConvexAabbCachingShape_setSafeMargin__rt{tis}
btPolyhedralConvexAabbCachingShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btPolyhedralConvexShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPolyhedralConvexShape_setSafeMargin__rt{tis}
btPolyhedralConvexShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btPoolAllocator_getPoolAddress__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoolAllocator, "getPoolAddress"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoolAllocator, "getPoolAddress"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoolAllocator_getPoolAddress__rt{tis}
btPoolAllocator_getPoolAddress(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getPoolAddress();
  } else if (match_args{tis, {0}}) {
    return a0.getPoolAddress();
  }
}
private metafunction btQuadWord_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuadWord, "setValue3"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuadWord, "setValue4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuadWord_setValue__rt{tis}
btQuadWord_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  }
}
private metafunction btQuantizedBvh_serialize__rt{tis}
  m::cond{
    match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}},
    m::ret_type{m::symbol{btQuantizedBvh, "serialize2"}},
    match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}},
    m::ret_type{m::symbol{btQuantizedBvh, "serialize3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuantizedBvh_serialize__rt{tis}
btQuantizedBvh_serialize(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}}) {
    return a0.serialize2(a1,a2);
  } else if (match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}}) {
    return a0.serialize3(a1,a2,a3);
  }
}
private metafunction btQuaternion_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuaternion, "setValue3"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuaternion, "setValue4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuaternion_setValue__rt{tis}
btQuaternion_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  }
}
private metafunction btRaycastVehicle_getRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRaycastVehicle, "getRigidBody"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRaycastVehicle, "getRigidBody"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRaycastVehicle_getRigidBody__rt{tis}
btRaycastVehicle_getRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBody();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBody();
  }
}
private metafunction btRaycastVehicle_getWheelInfo__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btRaycastVehicle, "getWheelInfo"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btRaycastVehicle, "getWheelInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRaycastVehicle_getWheelInfo__rt{tis}
btRaycastVehicle_getWheelInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getWheelInfo(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getWheelInfo(a1);
  }
}
private metafunction btRigidBody_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getWorldTransform__rt{tis}
btRigidBody_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btRigidBody_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getCollisionShape"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getCollisionShape__rt{tis}
btRigidBody_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btRigidBody_getBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseProxy"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseProxy"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getBroadphaseProxy__rt{tis}
btRigidBody_getBroadphaseProxy(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseProxy();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseProxy();
  }
}
private metafunction btRigidBody_setAngularFactor__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0}}},
    m::ret_type{m::symbol{btRigidBody, "setAngularFactor_btVector3"}},
    match_args{tis, {1,{btScalar,0}}},
    m::ret_type{m::symbol{btRigidBody, "setAngularFactor_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_setAngularFactor__rt{tis}
btRigidBody_setAngularFactor(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0}}}) {
    return a0.setAngularFactor_btVector3(a1);
  } else if (match_args{tis, {1,{btScalar,0}}}) {
    return a0.setAngularFactor_btScalar(a1);
  }
}
private metafunction btRigidBody_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseHandle"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getBroadphaseHandle__rt{tis}
btRigidBody_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btRigidBody_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getInterpolationWorldTransform"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getInterpolationWorldTransform__rt{tis}
btRigidBody_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btRigidBody_getMotionState__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getMotionState"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getMotionState"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_getMotionState__rt{tis}
btRigidBody_getMotionState(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getMotionState();
  } else if (match_args{tis, {1}}) {
    return a0.getMotionState();
  }
}
private metafunction btScaledBvhTriangleMeshShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btScaledBvhTriangleMeshShape, "getChildShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btScaledBvhTriangleMeshShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btScaledBvhTriangleMeshShape_getChildShape__rt{tis}
btScaledBvhTriangleMeshShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getChildShape();
  } else if (match_args{tis, {0}}) {
    return a0.getChildShape();
  }
}
private metafunction btSimpleBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleBroadphase_getOverlappingPairCache__rt{tis}
btSimpleBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btSimpleDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getConstraint"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getConstraint__rt{tis}
btSimpleDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btSimpleDynamicsWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getCollisionObjectArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getCollisionObjectArray__rt{tis}
btSimpleDynamicsWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btSimpleDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getDispatchInfo__rt{tis}
btSimpleDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btSimpleDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatcher"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getDispatcher__rt{tis}
btSimpleDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  }
}
private metafunction btSimpleDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getBroadphase"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_getBroadphase__rt{tis}
btSimpleDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  }
}
private metafunction btSimpleDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "addRigidBody1"}},
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "addRigidBody3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld_addRigidBody__rt{tis}
btSimpleDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  }
}
private metafunction btSliderConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getJointFeedback__rt{tis}
btSliderConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btSliderConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getFrameOffsetA__rt{tis}
btSliderConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btSliderConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getRigidBodyA__rt{tis}
btSliderConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btSliderConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getFrameOffsetB__rt{tis}
btSliderConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btSliderConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint_getRigidBodyB__rt{tis}
btSliderConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btSoftBody_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftBody, "getInterpolationWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftBody, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_getInterpolationWorldTransform__rt{tis}
btSoftBody_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btSoftBody_appendLinearJoint__rt{tis}
  m::cond{
    match_args{tis, {1,{btSoftBody_LJoint_Specs,0},{rptr{btSoftBody_Cluster},0},{btSoftBody_Body,0}}},
    m::ret_type{m::symbol{btSoftBody, "appendLinearJoint3"}},
    match_args{tis, {1,{btSoftBody_LJoint_Specs,0},{btSoftBody_Body,0}}},
    m::ret_type{m::symbol{btSoftBody, "appendLinearJoint_btSoftBody_LJoint_Specs_btSoftBody_Body"}},
    match_args{tis, {1,{btSoftBody_LJoint_Specs,0},{rptr{btSoftBody},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendLinearJoint_btSoftBody_LJoint_Specs_btSoftBody_p"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_appendLinearJoint__rt{tis}
btSoftBody_appendLinearJoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btSoftBody_LJoint_Specs,0},{rptr{btSoftBody_Cluster},0},{btSoftBody_Body,0}}}) {
    return a0.appendLinearJoint3(a1,a2,a3);
  } else if (match_args{tis, {1,{btSoftBody_LJoint_Specs,0},{btSoftBody_Body,0}}}) {
    return a0.appendLinearJoint_btSoftBody_LJoint_Specs_btSoftBody_Body(a1,a2);
  } else if (match_args{tis, {1,{btSoftBody_LJoint_Specs,0},{rptr{btSoftBody},0}}}) {
    return a0.appendLinearJoint_btSoftBody_LJoint_Specs_btSoftBody_p(a1,a2);
  }
}
private metafunction btSoftBody_appendLink__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Material},0},{bool,0}}},
    m::ret_type{m::symbol{btSoftBody, "appendLink_btSoftBody_Node_p_btSoftBody_Node_p_btSoftBody_Material_p_bool"}},
    match_args{tis, {1,{int,0},{int,0},{rptr{btSoftBody_Material},0},{bool,0}}},
    m::ret_type{m::symbol{btSoftBody, "appendLink_int_int_btSoftBody_Material_p_bool"}},
    match_args{tis, {1,{int,0},{rptr{btSoftBody_Material},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendLink2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_appendLink__rt{tis}
btSoftBody_appendLink(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Material},0},{bool,0}}}) {
    return a0.appendLink_btSoftBody_Node_p_btSoftBody_Node_p_btSoftBody_Material_p_bool(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{int,0},{int,0},{rptr{btSoftBody_Material},0},{bool,0}}}) {
    return a0.appendLink_int_int_btSoftBody_Material_p_bool(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{int,0},{rptr{btSoftBody_Material},0}}}) {
    return a0.appendLink2(a1,a2);
  }
}
private metafunction btSoftBody_getSoftBodySolver__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftBody, "getSoftBodySolver"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftBody, "getSoftBodySolver"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_getSoftBodySolver__rt{tis}
btSoftBody_getSoftBodySolver(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getSoftBodySolver();
  } else if (match_args{tis, {0}}) {
    return a0.getSoftBodySolver();
  }
}
private metafunction btSoftBody_cutLink__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btSoftBody_Node},0},{crptr{btSoftBody_Node},0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftBody, "cutLink_btSoftBody_Node_cp_btSoftBody_Node_cp_btScalar"}},
    match_args{tis, {1,{int,0},{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftBody, "cutLink_int_int_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_cutLink__rt{tis}
btSoftBody_cutLink(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btSoftBody_Node},0},{crptr{btSoftBody_Node},0},{btScalar,0}}}) {
    return a0.cutLink_btSoftBody_Node_cp_btSoftBody_Node_cp_btScalar(a1,a2,a3);
  } else if (match_args{tis, {1,{int,0},{int,0},{btScalar,0}}}) {
    return a0.cutLink_int_int_btScalar(a1,a2,a3);
  }
}
private metafunction btSoftBody_checkLink__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0},{int,0}}},
    m::ret_type{m::symbol{btSoftBody, "checkLink_int_int"}},
    match_args{tis, {0,{crptr{btSoftBody_Node},0},{crptr{btSoftBody_Node},0}}},
    m::ret_type{m::symbol{btSoftBody, "checkLink_btSoftBody_Node_cp_btSoftBody_Node_cp"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_checkLink__rt{tis}
btSoftBody_checkLink(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0},{int,0}}}) {
    return a0.checkLink_int_int(a1,a2);
  } else if (match_args{tis, {0,{crptr{btSoftBody_Node},0},{crptr{btSoftBody_Node},0}}}) {
    return a0.checkLink_btSoftBody_Node_cp_btSoftBody_Node_cp(a1,a2);
  }
}
private metafunction btSoftBody_addForce__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{int,0}}},
    m::ret_type{m::symbol{btSoftBody, "addForce2"}},
    match_args{tis, {1,{btVector3,0}}},
    m::ret_type{m::symbol{btSoftBody, "addForce1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_addForce__rt{tis}
btSoftBody_addForce(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{int,0}}}) {
    return a0.addForce2(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0}}}) {
    return a0.addForce1(a1);
  }
}
private metafunction btSoftBody_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftBody, "getWorldTransform"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftBody, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_getWorldTransform__rt{tis}
btSoftBody_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btSoftBody_appendTetra__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0},{rptr{btSoftBody_Material},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendTetra2"}},
    match_args{tis, {1,{int,0},{int,0},{int,0},{int,0},{rptr{btSoftBody_Material},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendTetra5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_appendTetra__rt{tis}
btSoftBody_appendTetra(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0},{rptr{btSoftBody_Material},0}}}) {
    return a0.appendTetra2(a1,a2);
  } else if (match_args{tis, {1,{int,0},{int,0},{int,0},{int,0},{rptr{btSoftBody_Material},0}}}) {
    return a0.appendTetra5(a1,a2,a3,a4,a5);
  }
}
private metafunction btSoftBody_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftBody, "getBroadphaseHandle"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftBody, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_getBroadphaseHandle__rt{tis}
btSoftBody_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btSoftBody_defaultCollisionHandler__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btSoftBody},0}}},
    m::ret_type{m::symbol{btSoftBody, "defaultCollisionHandler_btSoftBody_p"}},
    match_args{tis, {1,{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{btSoftBody, "defaultCollisionHandler_btCollisionObjectWrapper_cp"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_defaultCollisionHandler__rt{tis}
btSoftBody_defaultCollisionHandler(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btSoftBody},0}}}) {
    return a0.defaultCollisionHandler_btSoftBody_p(a1);
  } else if (match_args{tis, {1,{crptr{btCollisionObjectWrapper},0}}}) {
    return a0.defaultCollisionHandler_btCollisionObjectWrapper_cp(a1);
  }
}
private metafunction btSoftBody_appendAngularJoint__rt{tis}
  m::cond{
    match_args{tis, {1,{btSoftBody_AJoint_Specs,0},{btSoftBody_Body,0}}},
    m::ret_type{m::symbol{btSoftBody, "appendAngularJoint_btSoftBody_AJoint_Specs_btSoftBody_Body"}},
    match_args{tis, {1,{btSoftBody_AJoint_Specs,0},{rptr{btSoftBody},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendAngularJoint_btSoftBody_AJoint_Specs_btSoftBody_p"}},
    match_args{tis, {1,{btSoftBody_AJoint_Specs,0},{rptr{btSoftBody_Cluster},0},{btSoftBody_Body,0}}},
    m::ret_type{m::symbol{btSoftBody, "appendAngularJoint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_appendAngularJoint__rt{tis}
btSoftBody_appendAngularJoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btSoftBody_AJoint_Specs,0},{btSoftBody_Body,0}}}) {
    return a0.appendAngularJoint_btSoftBody_AJoint_Specs_btSoftBody_Body(a1,a2);
  } else if (match_args{tis, {1,{btSoftBody_AJoint_Specs,0},{rptr{btSoftBody},0}}}) {
    return a0.appendAngularJoint_btSoftBody_AJoint_Specs_btSoftBody_p(a1,a2);
  } else if (match_args{tis, {1,{btSoftBody_AJoint_Specs,0},{rptr{btSoftBody_Cluster},0},{btSoftBody_Body,0}}}) {
    return a0.appendAngularJoint3(a1,a2,a3);
  }
}
private metafunction btSoftBody_appendNote__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{char},0},{btVector3,0},{rptr{btSoftBody_Link},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendNote_char_cp_btVector3_btSoftBody_Link_p"}},
    match_args{tis, {1,{crptr{char},0},{btVector3,0},{rptr{btSoftBody_Node},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendNote_char_cp_btVector3_btSoftBody_Node_p"}},
    match_args{tis, {1,{crptr{char},0},{btVector3,0},{rptr{btSoftBody_Face},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendNote_char_cp_btVector3_btSoftBody_Face_p"}},
    match_args{tis, {1,{crptr{char},0},{btVector3,0},{btVector4,0},{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Node},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendNote7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_appendNote__rt{tis}
btSoftBody_appendNote(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{char},0},{btVector3,0},{rptr{btSoftBody_Link},0}}}) {
    return a0.appendNote_char_cp_btVector3_btSoftBody_Link_p(a1,a2,a3);
  } else if (match_args{tis, {1,{crptr{char},0},{btVector3,0},{rptr{btSoftBody_Node},0}}}) {
    return a0.appendNote_char_cp_btVector3_btSoftBody_Node_p(a1,a2,a3);
  } else if (match_args{tis, {1,{crptr{char},0},{btVector3,0},{rptr{btSoftBody_Face},0}}}) {
    return a0.appendNote_char_cp_btVector3_btSoftBody_Face_p(a1,a2,a3);
  } else if (match_args{tis, {1,{crptr{char},0},{btVector3,0},{btVector4,0},{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Node},0},{rptr{btSoftBody_Node},0}}}) {
    return a0.appendNote7(a1,a2,a3,a4,a5,a6,a7);
  }
}
private metafunction btSoftBody_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftBody, "getCollisionShape"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftBody, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_getCollisionShape__rt{tis}
btSoftBody_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btSoftBody_addVelocity__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0}}},
    m::ret_type{m::symbol{btSoftBody, "addVelocity1"}},
    match_args{tis, {1,{btVector3,0},{int,0}}},
    m::ret_type{m::symbol{btSoftBody, "addVelocity2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_addVelocity__rt{tis}
btSoftBody_addVelocity(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0}}}) {
    return a0.addVelocity1(a1);
  } else if (match_args{tis, {1,{btVector3,0},{int,0}}}) {
    return a0.addVelocity2(a1,a2);
  }
}
private metafunction btSoftBody_appendFace__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0},{int,0},{int,0},{rptr{btSoftBody_Material},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendFace4"}},
    match_args{tis, {1,{int,0},{rptr{btSoftBody_Material},0}}},
    m::ret_type{m::symbol{btSoftBody, "appendFace2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_appendFace__rt{tis}
btSoftBody_appendFace(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0},{int,0},{int,0},{rptr{btSoftBody_Material},0}}}) {
    return a0.appendFace4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{int,0},{rptr{btSoftBody_Material},0}}}) {
    return a0.appendFace2(a1,a2);
  }
}
private metafunction btSoftBody_appendAnchor__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0},{rptr{btRigidBody},0},{bool,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftBody, "appendAnchor4"}},
    match_args{tis, {1,{int,0},{rptr{btRigidBody},0},{btVector3,0},{bool,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftBody, "appendAnchor5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_appendAnchor__rt{tis}
btSoftBody_appendAnchor(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0},{rptr{btRigidBody},0},{bool,0},{btScalar,0}}}) {
    return a0.appendAnchor4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{int,0},{rptr{btRigidBody},0},{btVector3,0},{bool,0},{btScalar,0}}}) {
    return a0.appendAnchor5(a1,a2,a3,a4,a5);
  }
}
private metafunction btSoftBodySolver_processCollision__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btSoftBody},0},{rptr{btSoftBody},0}}},
    m::ret_type{m::symbol{btSoftBodySolver, "processCollision_btSoftBody_p_btSoftBody_p"}},
    match_args{tis, {1,{rptr{btSoftBody},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{btSoftBodySolver, "processCollision_btSoftBody_p_btCollisionObjectWrapper_cp"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBodySolver_processCollision__rt{tis}
btSoftBodySolver_processCollision(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btSoftBody},0},{rptr{btSoftBody},0}}}) {
    return a0.processCollision_btSoftBody_p_btSoftBody_p(a1,a2);
  } else if (match_args{tis, {1,{rptr{btSoftBody},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return a0.processCollision_btSoftBody_p_btCollisionObjectWrapper_cp(a1,a2);
  }
}
private metafunction btSoftBody_Body_angularVelocity__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftBody_Body, "angularVelocity0"}},
    match_args{tis, {0,{btVector3,0}}},
    m::ret_type{m::symbol{btSoftBody_Body, "angularVelocity1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_Body_angularVelocity__rt{tis}
btSoftBody_Body_angularVelocity(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.angularVelocity0();
  } else if (match_args{tis, {0,{btVector3,0}}}) {
    return a0.angularVelocity1(a1);
  }
}
private metafunction btSoftBody_RayFromToCaster_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftBody_RayFromToCaster, "Process1"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftBody_RayFromToCaster, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftBody_RayFromToCaster, "Process_btDbvtNode_cp_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_RayFromToCaster_Process__rt{tis}
btSoftBody_RayFromToCaster_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  }
}
private metafunction btSoftClusterCollisionShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftClusterCollisionShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftClusterCollisionShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftClusterCollisionShape_setSafeMargin__rt{tis}
btSoftClusterCollisionShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btSoftColliders_ClusterBase_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftColliders_ClusterBase, "Process_btDbvtNode_cp_btScalar"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_ClusterBase, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_ClusterBase, "Process1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftColliders_ClusterBase_Process__rt{tis}
btSoftColliders_ClusterBase_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  }
}
private metafunction btSoftColliders_CollideCL_RS_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideCL_RS, "Process1"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideCL_RS, "Process_btDbvtNode_cp_btScalar"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideCL_RS, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftColliders_CollideCL_RS_Process__rt{tis}
btSoftColliders_CollideCL_RS_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  }
}
private metafunction btSoftColliders_CollideCL_SS_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideCL_SS, "Process1"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideCL_SS, "Process_btDbvtNode_cp_btScalar"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideCL_SS, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftColliders_CollideCL_SS_Process__rt{tis}
btSoftColliders_CollideCL_SS_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  }
}
private metafunction btSoftColliders_CollideSDF_RS_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideSDF_RS, "Process_btDbvtNode_cp_btScalar"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideSDF_RS, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideSDF_RS, "Process1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftColliders_CollideSDF_RS_Process__rt{tis}
btSoftColliders_CollideSDF_RS_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  }
}
private metafunction btSoftColliders_CollideVF_SS_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideVF_SS, "Process_btDbvtNode_cp_btScalar"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideVF_SS, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btSoftColliders_CollideVF_SS, "Process1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftColliders_CollideVF_SS_Process__rt{tis}
btSoftColliders_CollideVF_SS_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  }
}
private metafunction btSoftRigidDynamicsWorld_getSoftBodyArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getSoftBodyArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getSoftBodyArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_getSoftBodyArray__rt{tis}
btSoftRigidDynamicsWorld_getSoftBodyArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getSoftBodyArray();
  } else if (match_args{tis, {1}}) {
    return a0.getSoftBodyArray();
  }
}
private metafunction btSoftRigidDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getDispatcher"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_getDispatcher__rt{tis}
btSoftRigidDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  }
}
private metafunction btSoftRigidDynamicsWorld_getSimulationIslandManager__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getSimulationIslandManager"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getSimulationIslandManager"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_getSimulationIslandManager__rt{tis}
btSoftRigidDynamicsWorld_getSimulationIslandManager(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getSimulationIslandManager();
  } else if (match_args{tis, {1}}) {
    return a0.getSimulationIslandManager();
  }
}
private metafunction btSoftRigidDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getConstraint"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_getConstraint__rt{tis}
btSoftRigidDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btSoftRigidDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "addRigidBody1"}},
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "addRigidBody3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_addRigidBody__rt{tis}
btSoftRigidDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  }
}
private metafunction btSoftRigidDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getBroadphase"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_getBroadphase__rt{tis}
btSoftRigidDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  }
}
private metafunction btSoftRigidDynamicsWorld_getCollisionObjectArray__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getCollisionObjectArray"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getCollisionObjectArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_getCollisionObjectArray__rt{tis}
btSoftRigidDynamicsWorld_getCollisionObjectArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionObjectArray();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionObjectArray();
  }
}
private metafunction btSoftRigidDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_getDispatchInfo__rt{tis}
btSoftRigidDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btSoftRigidDynamicsWorld_getWorldInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getWorldInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSoftRigidDynamicsWorld, "getWorldInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld_getWorldInfo__rt{tis}
btSoftRigidDynamicsWorld_getWorldInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldInfo();
  }
}
private metafunction btSortedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSortedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btSortedOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btSortedOverlappingPairCache_getOverlappingPairArray__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArray"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSortedOverlappingPairCache_getOverlappingPairArray__rt{tis}
btSortedOverlappingPairCache_getOverlappingPairArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArray();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArray();
  }
}
private metafunction btSphereShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSphereShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSphereShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSphereShape_setSafeMargin__rt{tis}
btSphereShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btTetrahedronShapeEx_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btTetrahedronShapeEx, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btTetrahedronShapeEx, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTetrahedronShapeEx_setSafeMargin__rt{tis}
btTetrahedronShapeEx_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btTransform_getBasis__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTransform, "getBasis"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTransform, "getBasis"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTransform_getBasis__rt{tis}
btTransform_getBasis(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBasis();
  } else if (match_args{tis, {0}}) {
    return a0.getBasis();
  }
}
private metafunction btTransform_getOrigin__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTransform, "getOrigin"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTransform, "getOrigin"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTransform_getOrigin__rt{tis}
btTransform_getOrigin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOrigin();
  } else if (match_args{tis, {0}}) {
    return a0.getOrigin();
  }
}
private metafunction btTriangleIndexVertexArray_getIndexedMeshArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTriangleIndexVertexArray, "getIndexedMeshArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTriangleIndexVertexArray, "getIndexedMeshArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleIndexVertexArray_getIndexedMeshArray__rt{tis}
btTriangleIndexVertexArray_getIndexedMeshArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getIndexedMeshArray();
  } else if (match_args{tis, {1}}) {
    return a0.getIndexedMeshArray();
  }
}
private metafunction btTriangleIndexVertexMaterialArray_getIndexedMeshArray__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTriangleIndexVertexMaterialArray, "getIndexedMeshArray"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTriangleIndexVertexMaterialArray, "getIndexedMeshArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleIndexVertexMaterialArray_getIndexedMeshArray__rt{tis}
btTriangleIndexVertexMaterialArray_getIndexedMeshArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getIndexedMeshArray();
  } else if (match_args{tis, {1}}) {
    return a0.getIndexedMeshArray();
  }
}
private metafunction btTriangleInfoMap_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashInt,0}}},
    m::ret_type{m::symbol{btTriangleInfoMap, "find"}},
    match_args{tis, {0,{btHashInt,0}}},
    m::ret_type{m::symbol{btTriangleInfoMap, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleInfoMap_find__rt{tis}
btTriangleInfoMap_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashInt,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashInt,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btTriangleInfoMap_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btTriangleInfoMap, "getAtIndex"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btTriangleInfoMap, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleInfoMap_getAtIndex__rt{tis}
btTriangleInfoMap_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btTriangleMesh_getIndexedMeshArray__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTriangleMesh, "getIndexedMeshArray"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTriangleMesh, "getIndexedMeshArray"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleMesh_getIndexedMeshArray__rt{tis}
btTriangleMesh_getIndexedMeshArray(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getIndexedMeshArray();
  } else if (match_args{tis, {0}}) {
    return a0.getIndexedMeshArray();
  }
}
private metafunction btTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleMeshShape_getMeshInterface__rt{tis}
btTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btTriangleShape_getVertexPtr__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btTriangleShape, "getVertexPtr"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btTriangleShape, "getVertexPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleShape_getVertexPtr__rt{tis}
btTriangleShape_getVertexPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getVertexPtr(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getVertexPtr(a1);
  }
}
private metafunction btTriangleShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btTriangleShape, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btTriangleShape, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleShape_setSafeMargin__rt{tis}
btTriangleShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btTriangleShapeEx_getVertexPtr__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btTriangleShapeEx, "getVertexPtr"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btTriangleShapeEx, "getVertexPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleShapeEx_getVertexPtr__rt{tis}
btTriangleShapeEx_getVertexPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getVertexPtr(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getVertexPtr(a1);
  }
}
private metafunction btTriangleShapeEx_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btTriangleShapeEx, "setSafeMargin_btVector3_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btTriangleShapeEx, "setSafeMargin_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleShapeEx_setSafeMargin__rt{tis}
btTriangleShapeEx_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  }
}
private metafunction btTypedConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedConstraint_getRigidBodyB__rt{tis}
btTypedConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btTypedConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getJointFeedback"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedConstraint_getJointFeedback__rt{tis}
btTypedConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btTypedConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedConstraint_getRigidBodyA__rt{tis}
btTypedConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btUniformScalingShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniformScalingShape, "getChildShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniformScalingShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniformScalingShape_getChildShape__rt{tis}
btUniformScalingShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getChildShape();
  } else if (match_args{tis, {0}}) {
    return a0.getChildShape();
  }
}
private metafunction btUnionFind_find__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btUnionFind, "find1"}},
    match_args{tis, {1,{int,0},{int,0}}},
    m::ret_type{m::symbol{btUnionFind, "find2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUnionFind_find__rt{tis}
btUnionFind_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.find1(a1);
  } else if (match_args{tis, {1,{int,0},{int,0}}}) {
    return a0.find2(a1,a2);
  }
}
private metafunction btUnionFind_getElement__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btUnionFind, "getElement"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btUnionFind, "getElement"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUnionFind_getElement__rt{tis}
btUnionFind_getElement(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getElement(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getElement(a1);
  }
}
private metafunction btUniversalConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getFrameOffsetA__rt{tis}
btUniversalConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btUniversalConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getJointFeedback__rt{tis}
btUniversalConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btUniversalConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyA"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getRigidBodyA__rt{tis}
btUniversalConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btUniversalConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getFrameOffsetB__rt{tis}
btUniversalConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btUniversalConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btUniversalConstraint, "calculateTransforms2"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "calculateTransforms0"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_calculateTransforms__rt{tis}
btUniversalConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  } else if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  }
}
private metafunction btUniversalConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyB"}},
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint_getRigidBodyB__rt{tis}
btUniversalConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btVector4_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btVector4, "setValue4"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btVector4, "setValue3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btVector4_setValue__rt{tis}
btVector4_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  }
}
private metafunction btWorldImporter_createHingeConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createHingeConstraint5"}},
    match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createHingeConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btWorldImporter_createHingeConstraint__rt{tis}
btWorldImporter_createHingeConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return a0.createHingeConstraint5(a1,a2,a3,a4,a5);
  } else if (match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return a0.createHingeConstraint3(a1,a2,a3);
  }
}
private metafunction btWorldImporter_createConeTwistConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createConeTwistConstraint4"}},
    match_args{tis, {1,{btRigidBody,1},{btTransform,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createConeTwistConstraint2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btWorldImporter_createConeTwistConstraint__rt{tis}
btWorldImporter_createConeTwistConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}}) {
    return a0.createConeTwistConstraint4(a1,a2,a3,a4);
  } else if (match_args{tis, {1,{btRigidBody,1},{btTransform,0}}}) {
    return a0.createConeTwistConstraint2(a1,a2);
  }
}
private metafunction btWorldImporter_createPoint2PointConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btVector3,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createPoint2PointConstraint2"}},
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createPoint2PointConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btWorldImporter_createPoint2PointConstraint__rt{tis}
btWorldImporter_createPoint2PointConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btVector3,0}}}) {
    return a0.createPoint2PointConstraint2(a1,a2);
  } else if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}}) {
    return a0.createPoint2PointConstraint4(a1,a2,a3,a4);
  }
}
private metafunction btWorldImporter_createGeneric6DofConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createGeneric6DofConstraint3"}},
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createGeneric6DofConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btWorldImporter_createGeneric6DofConstraint__rt{tis}
btWorldImporter_createGeneric6DofConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return a0.createGeneric6DofConstraint3(a1,a2,a3);
  } else if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return a0.createGeneric6DofConstraint5(a1,a2,a3,a4,a5);
  }
}
private metafunction btWorldImporter_createSliderConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createSliderConstraint5"}},
    match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{btWorldImporter, "createSliderConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btWorldImporter_createSliderConstraint__rt{tis}
btWorldImporter_createSliderConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return a0.createSliderConstraint5(a1,a2,a3,a4,a5);
  } else if (match_args{tis, {1,{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return a0.createSliderConstraint3(a1,a2,a3);
  }
}
private metafunction btPersistentManifold__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{crptr{btCollisionObject},0},{int,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btPersistentManifold5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPersistentManifold__rt{tis}
btPersistentManifold_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{crptr{btCollisionObject},0},{int,0},{btScalar,0},{btScalar,0}}}) {
    return btPersistentManifold5(a0,a1,a2,a3,a4);
  }
}
private metafunction btBoxBoxCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBoxBoxCollisionAlgorithm4"}},
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBoxBoxCollisionAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBoxBoxCollisionAlgorithm__rt{tis}
btBoxBoxCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btBoxBoxCollisionAlgorithm4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btBoxBoxCollisionAlgorithm1(a0);
  }
}
private metafunction btCollisionWorld_LocalConvexResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_LocalConvexResult5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_LocalConvexResult__rt{tis}
btCollisionWorld_LocalConvexResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btCollisionWorld_LocalConvexResult5(a0,a1,a2,a3,a4);
  }
}
private metafunction btConeShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeShapeX2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShapeX__rt{tis}
btConeShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShapeX2(a0,a1);
  }
}
private metafunction btGjkEpaSolver2_SignedDistance__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{btTransform,0},{crptr{btConvexShape},0},{btTransform,0},{btVector3,0},{btGjkEpaSolver2_sResults,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btGjkEpaSolver2_SignedDistance6"}},
    match_args{tis, {{btVector3,0},{btScalar,0},{crptr{btConvexShape},0},{btTransform,0},{btGjkEpaSolver2_sResults,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btGjkEpaSolver2_SignedDistance5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGjkEpaSolver2_SignedDistance__rt{tis}
btGjkEpaSolver2_SignedDistance(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{btTransform,0},{crptr{btConvexShape},0},{btTransform,0},{btVector3,0},{btGjkEpaSolver2_sResults,1}}}) {
    return btGjkEpaSolver2_SignedDistance6(a0,a1,a2,a3,a4,a5);
  } else if (match_args{tis, {{btVector3,0},{btScalar,0},{crptr{btConvexShape},0},{btTransform,0},{btGjkEpaSolver2_sResults,1}}}) {
    return btGjkEpaSolver2_SignedDistance5(a0,a1,a2,a3,a4);
  }
}
private metafunction btGearConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGearConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGearConstraint__rt{tis}
btGearConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btGearConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btCapsuleShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCapsuleShapeX2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShapeX__rt{tis}
btCapsuleShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShapeX2(a0,a1);
  }
}
private metafunction btShapeHull__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btShapeHull1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btShapeHull__rt{tis}
btShapeHull_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0}}}) {
    return btShapeHull1(a0);
  }
}
private metafunction btBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBroadphaseProxy6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBroadphaseProxy__rt{tis}
btBroadphaseProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}}) {
    return btBroadphaseProxy6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btSoftRigidCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftRigidCollisionAlgorithm5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidCollisionAlgorithm__rt{tis}
btSoftRigidCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btSoftRigidCollisionAlgorithm5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSphereSphereCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereSphereCollisionAlgorithm1"}},
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereSphereCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSphereSphereCollisionAlgorithm__rt{tis}
btSphereSphereCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btSphereSphereCollisionAlgorithm1(a0);
  } else if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btSphereSphereCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btHingeConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHingeConstraint5"}},
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHingeConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHingeConstraint4"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHingeConstraint7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHingeConstraint__rt{tis}
btHingeConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btHingeConstraint5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btHingeConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btHingeConstraint4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btHingeConstraint7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btDefaultMotionState__rt{tis}
  m::cond{
    match_args{tis, {{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDefaultMotionState2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultMotionState__rt{tis}
btDefaultMotionState_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btTransform,0},{btTransform,0}}}) {
    return btDefaultMotionState2(a0,a1);
  }
}
private metafunction btPoint2PointConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btPoint2PointConstraint4"}},
    match_args{tis, {{btRigidBody,1},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btPoint2PointConstraint2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoint2PointConstraint__rt{tis}
btPoint2PointConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}}) {
    return btPoint2PointConstraint4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btRigidBody,1},{btVector3,0}}}) {
    return btPoint2PointConstraint2(a0,a1);
  }
}
private metafunction btDefaultSerializer__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDefaultSerializer1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultSerializer__rt{tis}
btDefaultSerializer_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btDefaultSerializer1(a0);
  }
}
private metafunction btGImpactCompoundShape_CompoundPrimitiveManager__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btGImpactCompoundShape},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGImpactCompoundShape_CompoundPrimitiveManager1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactCompoundShape_CompoundPrimitiveManager__rt{tis}
btGImpactCompoundShape_CompoundPrimitiveManager_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btGImpactCompoundShape},0}}}) {
    return btGImpactCompoundShape_CompoundPrimitiveManager1(a0);
  }
}
private metafunction btMultiSapBroadphase_btMultiSapProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMultiSapBroadphase_btMultiSapProxy6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSapBroadphase_btMultiSapProxy__rt{tis}
btMultiSapBroadphase_btMultiSapProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0}}}) {
    return btMultiSapBroadphase_btMultiSapProxy6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btSolve2LinearConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSolve2LinearConstraint2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSolve2LinearConstraint__rt{tis}
btSolve2LinearConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btSolve2LinearConstraint2(a0,a1);
  }
}
private metafunction btBox2dShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBox2dShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBox2dShape__rt{tis}
btBox2dShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btBox2dShape1(a0);
  }
}
private metafunction btDbvtProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvtProxy5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvtProxy__rt{tis}
btDbvtProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0}}}) {
    return btDbvtProxy5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSliderConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSliderConstraint5"}},
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSliderConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSliderConstraint__rt{tis}
btSliderConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btSliderConstraint5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btSliderConstraint3(a0,a1,a2);
  }
}
private metafunction btSimpleBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSimpleBroadphase2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleBroadphase__rt{tis}
btSimpleBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}}) {
    return btSimpleBroadphase2(a0,a1);
  }
}
private metafunction btMaterial__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMaterial2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMaterial__rt{tis}
btMaterial_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btMaterial2(a0,a1);
  }
}
private metafunction btCompoundCompoundCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCompoundCompoundCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundCompoundCollisionAlgorithm__rt{tis}
btCompoundCompoundCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btCompoundCompoundCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btConeShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeShapeZ2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShapeZ__rt{tis}
btConeShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShapeZ2(a0,a1);
  }
}
private metafunction btContactConstraint__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btRigidBody,1},{btRigidBody,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btContactConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btContactConstraint__rt{tis}
btContactConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btRigidBody,1},{btRigidBody,1}}}) {
    return btContactConstraint3(a0,a1,a2);
  }
}
private metafunction btMultimaterialTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMultimaterialTriangleMeshShape5"}},
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMultimaterialTriangleMeshShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultimaterialTriangleMeshShape__rt{tis}
btMultimaterialTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btMultimaterialTriangleMeshShape5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}}) {
    return btMultimaterialTriangleMeshShape3(a0,a1,a2);
  }
}
private metafunction btDefaultVehicleRaycaster__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDynamicsWorld},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDefaultVehicleRaycaster1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultVehicleRaycaster__rt{tis}
btDefaultVehicleRaycaster_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDynamicsWorld},0}}}) {
    return btDefaultVehicleRaycaster1(a0);
  }
}
private metafunction btManifoldResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btManifoldResult2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btManifoldResult__rt{tis}
btManifoldResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btManifoldResult2(a0,a1);
  }
}
private metafunction btConvexTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexTriangleMeshShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexTriangleMeshShape__rt{tis}
btConvexTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0}}}) {
    return btConvexTriangleMeshShape2(a0,a1);
  }
}
private metafunction btDiscreteDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDiscreteDynamicsWorld4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDiscreteDynamicsWorld__rt{tis}
btDiscreteDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}}) {
    return btDiscreteDynamicsWorld4(a0,a1,a2,a3);
  }
}
private metafunction btConvexConvexAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexConvexAlgorithm8"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexConvexAlgorithm__rt{tis}
btConvexConvexAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0},{int,0},{int,0}}}) {
    return btConvexConvexAlgorithm8(a0,a1,a2,a3,a4,a5,a6,a7);
  }
}
private metafunction btVector3__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btVector3_3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btVector3__rt{tis}
btVector3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btVector3_3(a0,a1,a2);
  }
}
private metafunction btCompoundShape__rt{tis}
  m::cond{
    match_args{tis, {{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCompoundShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundShape__rt{tis}
btCompoundShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{bool,0}}}) {
    return btCompoundShape1(a0);
  }
}
private metafunction btTriangleIndexVertexArray__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleIndexVertexArray6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleIndexVertexArray__rt{tis}
btTriangleIndexVertexArray_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0}}}) {
    return btTriangleIndexVertexArray6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btConvex2dConvex2dAlgorithm_CreateFunc__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvex2dConvex2dAlgorithm_CreateFunc2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvex2dConvex2dAlgorithm_CreateFunc__rt{tis}
btConvex2dConvex2dAlgorithm_CreateFunc_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btConvex2dConvex2dAlgorithm_CreateFunc2(a0,a1);
  }
}
private metafunction btKinematicCharacterController__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPairCachingGhostObject},0},{rptr{btConvexShape},0},{btScalar,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btKinematicCharacterController4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btKinematicCharacterController__rt{tis}
btKinematicCharacterController_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPairCachingGhostObject},0},{rptr{btConvexShape},0},{btScalar,0},{int,0}}}) {
    return btKinematicCharacterController4(a0,a1,a2,a3);
  }
}
private metafunction btSoftClusterCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btSoftBody_Cluster},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftClusterCollisionShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftClusterCollisionShape__rt{tis}
btSoftClusterCollisionShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btSoftBody_Cluster},0}}}) {
    return btSoftClusterCollisionShape1(a0);
  }
}
private metafunction btConvexHullShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btScalar},0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexHullShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexHullShape__rt{tis}
btConvexHullShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btScalar},0},{int,0},{int,0}}}) {
    return btConvexHullShape3(a0,a1,a2);
  }
}
private metafunction btRaycastVehicle__rt{tis}
  m::cond{
    match_args{tis, {{btRaycastVehicle_btVehicleTuning,0},{rptr{btRigidBody},0},{rptr{btVehicleRaycaster},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRaycastVehicle3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRaycastVehicle__rt{tis}
btRaycastVehicle_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRaycastVehicle_btVehicleTuning,0},{rptr{btRigidBody},0},{rptr{btVehicleRaycaster},0}}}) {
    return btRaycastVehicle3(a0,a1,a2);
  }
}
private metafunction btDefaultCollisionConfiguration__rt{tis}
  m::cond{
    match_args{tis, {{btDefaultCollisionConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDefaultCollisionConfiguration1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDefaultCollisionConfiguration__rt{tis}
btDefaultCollisionConfiguration_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btDefaultCollisionConstructionInfo,0}}}) {
    return btDefaultCollisionConfiguration1(a0);
  }
}
private metafunction btDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDynamicsWorld3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDynamicsWorld__rt{tis}
btDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}}) {
    return btDynamicsWorld3(a0,a1,a2);
  }
}
private metafunction btHashInt__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHashInt1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashInt__rt{tis}
btHashInt_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btHashInt1(a0);
  }
}
private metafunction btHashPtr__rt{tis}
  m::cond{
    match_args{tis, {{crptr{void},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHashPtr1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashPtr__rt{tis}
btHashPtr_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{void},0}}}) {
    return btHashPtr1(a0);
  }
}
private metafunction btTriangleShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleShape__rt{tis}
btTriangleShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btTriangleShape3(a0,a1,a2);
  }
}
private metafunction btGjkConvexCast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGjkConvexCast3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGjkConvexCast__rt{tis}
btGjkConvexCast_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0}}}) {
    return btGjkConvexCast3(a0,a1,a2);
  }
}
private metafunction btCollisionWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld__rt{tis}
btCollisionWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}}) {
    return btCollisionWorld3(a0,a1,a2);
  }
}
private metafunction btStackAlloc__rt{tis}
  m::cond{
    match_args{tis, {{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btStackAlloc1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btStackAlloc__rt{tis}
btStackAlloc_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{uint,0}}}) {
    return btStackAlloc1(a0);
  }
}
private metafunction btCapsuleShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCapsuleShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShape__rt{tis}
btCapsuleShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShape2(a0,a1);
  }
}
private metafunction btDbvtBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvtBroadphase1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvtBroadphase__rt{tis}
btDbvtBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btOverlappingPairCache},0}}}) {
    return btDbvtBroadphase1(a0);
  }
}
private metafunction btHeightfieldTerrainShape__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0},{crptr{void},0},{btScalar,0},{int,0},{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHeightfieldTerrainShape7"}},
    match_args{tis, {{int,0},{int,0},{crptr{void},0},{btScalar,0},{btScalar,0},{btScalar,0},{int,0},{PHY_ScalarType,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHeightfieldTerrainShape9"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHeightfieldTerrainShape__rt{tis}
btHeightfieldTerrainShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0},{crptr{void},0},{btScalar,0},{int,0},{bool,0},{bool,0}}}) {
    return btHeightfieldTerrainShape7(a0,a1,a2,a3,a4,a5,a6);
  } else if (match_args{tis, {{int,0},{int,0},{crptr{void},0},{btScalar,0},{btScalar,0},{btScalar,0},{int,0},{PHY_ScalarType,0},{bool,0}}}) {
    return btHeightfieldTerrainShape9(a0,a1,a2,a3,a4,a5,a6,a7,a8);
  }
}
private metafunction btContinuousConvexCollision__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btContinuousConvexCollision4"}},
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btStaticPlaneShape},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btContinuousConvexCollision2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btContinuousConvexCollision__rt{tis}
btContinuousConvexCollision_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btContinuousConvexCollision4(a0,a1,a2,a3);
  } else if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btStaticPlaneShape},0}}}) {
    return btContinuousConvexCollision2(a0,a1);
  }
}
private metafunction btCollisionAlgorithmConstructionInfo__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionAlgorithmConstructionInfo2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionAlgorithmConstructionInfo__rt{tis}
btCollisionAlgorithmConstructionInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{int,0}}}) {
    return btCollisionAlgorithmConstructionInfo2(a0,a1);
  }
}
private metafunction btSphereTriangleCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereTriangleCollisionAlgorithm5"}},
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereTriangleCollisionAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSphereTriangleCollisionAlgorithm__rt{tis}
btSphereTriangleCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btSphereTriangleCollisionAlgorithm5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btSphereTriangleCollisionAlgorithm1(a0);
  }
}
private metafunction btConvexPointCloudShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btVector3},0},{int,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexPointCloudShape4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexPointCloudShape__rt{tis}
btConvexPointCloudShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btVector3},0},{int,0},{btVector3,0},{bool,0}}}) {
    return btConvexPointCloudShape4(a0,a1,a2,a3);
  }
}
private metafunction btGImpactCompoundShape__rt{tis}
  m::cond{
    match_args{tis, {{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGImpactCompoundShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactCompoundShape__rt{tis}
btGImpactCompoundShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{bool,0}}}) {
    return btGImpactCompoundShape1(a0);
  }
}
private metafunction btCompoundCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCompoundCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCompoundCollisionAlgorithm__rt{tis}
btCompoundCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btCompoundCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btCPUVertexBufferDescriptor__rt{tis}
  m::cond{
    match_args{tis, {{rptr{float},0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCPUVertexBufferDescriptor3"}},
    match_args{tis, {{rptr{float},0},{int,0},{int,0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCPUVertexBufferDescriptor5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCPUVertexBufferDescriptor__rt{tis}
btCPUVertexBufferDescriptor_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{float},0},{int,0},{int,0}}}) {
    return btCPUVertexBufferDescriptor3(a0,a1,a2);
  } else if (match_args{tis, {{rptr{float},0},{int,0},{int,0},{int,0},{int,0}}}) {
    return btCPUVertexBufferDescriptor5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSoftBody__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btSoftBodyWorldInfo},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBody1"}},
    match_args{tis, {{rptr{btSoftBodyWorldInfo},0},{int,0},{crptr{btVector3},0},{crptr{btScalar},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBody4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody__rt{tis}
btSoftBody_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btSoftBodyWorldInfo},0}}}) {
    return btSoftBody1(a0);
  } else if (match_args{tis, {{rptr{btSoftBodyWorldInfo},0},{int,0},{crptr{btVector3},0},{crptr{btScalar},0}}}) {
    return btSoftBody4(a0,a1,a2,a3);
  }
}
private metafunction btConeShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeShape__rt{tis}
btConeShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShape2(a0,a1);
  }
}
private metafunction btSwapEndian__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSwapEndian_int"}},
    match_args{tis, {{ushort,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSwapEndian_ushort"}},
    match_args{tis, {{short,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSwapEndian_short"}},
    match_args{tis, {{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSwapEndian_uint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSwapEndian__rt{tis}
btSwapEndian(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btSwapEndian_int(a0);
  } else if (match_args{tis, {{ushort,0}}}) {
    return btSwapEndian_ushort(a0);
  } else if (match_args{tis, {{short,0}}}) {
    return btSwapEndian_short(a0);
  } else if (match_args{tis, {{uint,0}}}) {
    return btSwapEndian_uint(a0);
  }
}
private metafunction btConvexTriangleCallback__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexTriangleCallback4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexTriangleCallback__rt{tis}
btConvexTriangleCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btConvexTriangleCallback4(a0,a1,a2,a3);
  }
}
private metafunction btTriangleIndexVertexMaterialArray__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0},{int,0},{rptr{uchar},0},{int,0},{rptr{int},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleIndexVertexMaterialArray11"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleIndexVertexMaterialArray__rt{tis}
btTriangleIndexVertexMaterialArray_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0},{int,0},{rptr{uchar},0},{int,0},{rptr{int},0},{int,0}}}) {
    return btTriangleIndexVertexMaterialArray11(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  }
}
private metafunction btDbvt_sStkNPS__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{uint,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvt_sStkNPS3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_sStkNPS__rt{tis}
btDbvt_sStkNPS_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{uint,0},{btScalar,0}}}) {
    return btDbvt_sStkNPS3(a0,a1,a2);
  }
}
private metafunction btQuaternion__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuaternion2"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuaternion4"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuaternion3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuaternion__rt{tis}
btQuaternion_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btScalar,0}}}) {
    return btQuaternion2(a0,a1);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuaternion4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuaternion3(a0,a1,a2);
  }
}
private metafunction btGImpactBvh__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPrimitiveManagerBase},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGImpactBvh1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactBvh__rt{tis}
btGImpactBvh_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPrimitiveManagerBase},0}}}) {
    return btGImpactBvh1(a0);
  }
}
private metafunction btAABB__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAABB3"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAABB4"}},
    match_args{tis, {{btAABB,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAABB2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAABB__rt{tis}
btAABB_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btAABB3(a0,a1,a2);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btAABB4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btAABB,0},{btScalar,0}}}) {
    return btAABB2(a0,a1);
  }
}
private metafunction btActivatingCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btActivatingCollisionAlgorithm1"}},
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btActivatingCollisionAlgorithm3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btActivatingCollisionAlgorithm__rt{tis}
btActivatingCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btActivatingCollisionAlgorithm1(a0);
  } else if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btActivatingCollisionAlgorithm3(a0,a1,a2);
  }
}
private metafunction btAxisSweep3Internal_unsigned_short__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{ushort,0},{ushort,0},{ushort,0},{rptr{btOverlappingPairCache},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAxisSweep3Internal_unsigned_short7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3Internal_unsigned_short__rt{tis}
btAxisSweep3Internal_unsigned_short_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{ushort,0},{ushort,0},{ushort,0},{rptr{btOverlappingPairCache},0},{bool,0}}}) {
    return btAxisSweep3Internal_unsigned_short7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btTransformAabb__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btTransformAabb6"}},
    match_args{tis, {{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btTransformAabb5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTransformAabb__rt{tis}
btTransformAabb(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}}) {
    return btTransformAabb6(a0,a1,a2,a3,a4,a5);
  } else if (match_args{tis, {{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}}) {
    return btTransformAabb5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSoftSoftCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftSoftCollisionAlgorithm4"}},
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftSoftCollisionAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftSoftCollisionAlgorithm__rt{tis}
btSoftSoftCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btSoftSoftCollisionAlgorithm4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btSoftSoftCollisionAlgorithm1(a0);
  }
}
private metafunction btConvexConvexAlgorithm_CreateFunc__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexConvexAlgorithm_CreateFunc2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexConvexAlgorithm_CreateFunc__rt{tis}
btConvexConvexAlgorithm_CreateFunc_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btConvexConvexAlgorithm_CreateFunc2(a0,a1);
  }
}
private metafunction btRigidBody__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody4"}},
    match_args{tis, {{btRigidBody_btRigidBodyConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody__rt{tis}
btRigidBody_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}}) {
    return btRigidBody4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btRigidBody_btRigidBodyConstructionInfo,0}}}) {
    return btRigidBody1(a0);
  }
}
private metafunction btMinkowskiSumShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMinkowskiSumShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMinkowskiSumShape__rt{tis}
btMinkowskiSumShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0}}}) {
    return btMinkowskiSumShape2(a0,a1);
  }
}
private metafunction btAngle__rt{tis}
  m::cond{
    match_args{tis, {{btQuaternion,0},{btQuaternion,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAngle_btQuaternion_btQuaternion"}},
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAngle_btVector3_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAngle__rt{tis}
btAngle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btQuaternion,0},{btQuaternion,0}}}) {
    return btAngle_btQuaternion_btQuaternion(a0,a1);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btAngle_btVector3_btVector3(a0,a1);
  }
}
private metafunction btSoftBody_Body__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btSoftBody_Cluster},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBody_Body_btSoftBody_Cluster_p"}},
    match_args{tis, {{crptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBody_Body_btCollisionObject_cp"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_Body__rt{tis}
btSoftBody_Body_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btSoftBody_Cluster},0}}}) {
    return btSoftBody_Body_btSoftBody_Cluster_p(a0);
  } else if (match_args{tis, {{crptr{btCollisionObject},0}}}) {
    return btSoftBody_Body_btCollisionObject_cp(a0);
  }
}
private metafunction btVector4__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btVector4_4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btVector4__rt{tis}
btVector4_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btVector4_4(a0,a1,a2,a3);
  }
}
private metafunction btSoftBody_upcast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBody_upcast_btCollisionObject_cp"}},
    match_args{tis, {{rptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBody_upcast_btCollisionObject_p"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_upcast__rt{tis}
btSoftBody_upcast(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0}}}) {
    return btSoftBody_upcast_btCollisionObject_cp(a0);
  } else if (match_args{tis, {{rptr{btCollisionObject},0}}}) {
    return btSoftBody_upcast_btCollisionObject_p(a0);
  }
}
private metafunction btGImpactQuantizedBvh__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPrimitiveManagerBase},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGImpactQuantizedBvh1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactQuantizedBvh__rt{tis}
btGImpactQuantizedBvh_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPrimitiveManagerBase},0}}}) {
    return btGImpactQuantizedBvh1(a0);
  }
}
private metafunction btScaledBvhTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btBvhTriangleMeshShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btScaledBvhTriangleMeshShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btScaledBvhTriangleMeshShape__rt{tis}
btScaledBvhTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btBvhTriangleMeshShape},0},{btVector3,0}}}) {
    return btScaledBvhTriangleMeshShape2(a0,a1);
  }
}
private metafunction btTriangleMesh__rt{tis}
  m::cond{
    match_args{tis, {{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleMesh2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleMesh__rt{tis}
btTriangleMesh_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{bool,0},{bool,0}}}) {
    return btTriangleMesh2(a0,a1);
  }
}
private metafunction btStaticPlaneShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btStaticPlaneShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btStaticPlaneShape__rt{tis}
btStaticPlaneShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btScalar,0}}}) {
    return btStaticPlaneShape2(a0,a1);
  }
}
private metafunction btSphereBoxCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereBoxCollisionAlgorithm5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSphereBoxCollisionAlgorithm__rt{tis}
btSphereBoxCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btSphereBoxCollisionAlgorithm5(a0,a1,a2,a3,a4);
  }
}
private metafunction btHinge2Constraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,1},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btHinge2Constraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHinge2Constraint__rt{tis}
btHinge2Constraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,1},{btVector3,1},{btVector3,1}}}) {
    return btHinge2Constraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSimpleDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSimpleDynamicsWorld4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleDynamicsWorld__rt{tis}
btSimpleDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}}) {
    return btSimpleDynamicsWorld4(a0,a1,a2,a3);
  }
}
private metafunction btDbvt_sStkNN__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvt_sStkNN2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_sStkNN__rt{tis}
btDbvt_sStkNN_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return btDbvt_sStkNN2(a0,a1);
  }
}
private metafunction btMatrixX_float__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMatrixX_float2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMatrixX_float__rt{tis}
btMatrixX_float_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0}}}) {
    return btMatrixX_float2(a0,a1);
  }
}
private metafunction btGImpactMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGImpactMeshShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactMeshShape__rt{tis}
btGImpactMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0}}}) {
    return btGImpactMeshShape1(a0);
  }
}
private metafunction btCapsuleShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCapsuleShapeZ2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCapsuleShapeZ__rt{tis}
btCapsuleShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShapeZ2(a0,a1);
  }
}
private metafunction btSubsimplexConvexCast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSubsimplexConvexCast3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSubsimplexConvexCast__rt{tis}
btSubsimplexConvexCast_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0}}}) {
    return btSubsimplexConvexCast3(a0,a1,a2);
  }
}
private metafunction btCollisionWorld_ClosestConvexResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_ClosestConvexResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_ClosestConvexResultCallback__rt{tis}
btCollisionWorld_ClosestConvexResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_ClosestConvexResultCallback2(a0,a1);
  }
}
private metafunction btSoftBodyTriangleCallback__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBodyTriangleCallback4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBodyTriangleCallback__rt{tis}
btSoftBodyTriangleCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btSoftBodyTriangleCallback4(a0,a1,a2,a3);
  }
}
private metafunction btCollisionObjectWrapper__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionShape},0},{crptr{btCollisionObject},0},{btTransform,0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionObjectWrapper6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionObjectWrapper__rt{tis}
btCollisionObjectWrapper_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionShape},0},{crptr{btCollisionObject},0},{btTransform,0},{int,0},{int,0}}}) {
    return btCollisionObjectWrapper6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btTypedConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1},{btRigidBody,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btTypedConstraint3"}},
    match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btTypedConstraint2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedConstraint__rt{tis}
btTypedConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1},{btRigidBody,1}}}) {
    return btTypedConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1}}}) {
    return btTypedConstraint2(a0,a1);
  }
}
private metafunction btTriangleRaycastCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleRaycastCallback3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleRaycastCallback__rt{tis}
btTriangleRaycastCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{uint,0}}}) {
    return btTriangleRaycastCallback3(a0,a1,a2);
  }
}
private metafunction btConvex2dConvex2dAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvex2dConvex2dAlgorithm8"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvex2dConvex2dAlgorithm__rt{tis}
btConvex2dConvex2dAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0},{int,0},{int,0}}}) {
    return btConvex2dConvex2dAlgorithm8(a0,a1,a2,a3,a4,a5,a6,a7);
  }
}
private metafunction btMultiSphereShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btVector3},0},{crptr{btScalar},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMultiSphereShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSphereShape__rt{tis}
btMultiSphereShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btVector3},0},{crptr{btScalar},0},{int,0}}}) {
    return btMultiSphereShape3(a0,a1,a2);
  }
}
private metafunction btEmptyAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btEmptyAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btEmptyAlgorithm__rt{tis}
btEmptyAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btEmptyAlgorithm1(a0);
  }
}
private metafunction btQuadWord__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuadWord3"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btQuadWord4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btQuadWord__rt{tis}
btQuadWord_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuadWord3(a0,a1,a2);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuadWord4(a0,a1,a2,a3);
  }
}
private metafunction btUniversalConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btUniversalConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniversalConstraint__rt{tis}
btUniversalConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btUniversalConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btAngleCompareFunc__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAngleCompareFunc1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAngleCompareFunc__rt{tis}
btAngleCompareFunc_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btAngleCompareFunc1(a0);
  }
}
private metafunction btSelect__rt{tis}
  m::cond{
    match_args{tis, {{uint,0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSelect_uint_int_int"}},
    match_args{tis, {{uint,0},{float,0},{float,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSelect_uint_float_float"}},
    match_args{tis, {{uint,0},{uint,0},{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSelect_uint_uint_uint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSelect__rt{tis}
btSelect(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{uint,0},{int,0},{int,0}}}) {
    return btSelect_uint_int_int(a0,a1,a2);
  } else if (match_args{tis, {{uint,0},{float,0},{float,0}}}) {
    return btSelect_uint_float_float(a0,a1,a2);
  } else if (match_args{tis, {{uint,0},{uint,0},{uint,0}}}) {
    return btSelect_uint_uint_uint(a0,a1,a2);
  }
}
private metafunction btAxisSweep3Internal_unsigned_int__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{uint,0},{uint,0},{uint,0},{rptr{btOverlappingPairCache},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAxisSweep3Internal_unsigned_int7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3Internal_unsigned_int__rt{tis}
btAxisSweep3Internal_unsigned_int_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{uint,0},{uint,0},{uint,0},{rptr{btOverlappingPairCache},0},{bool,0}}}) {
    return btAxisSweep3Internal_unsigned_int7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btBU_Simplex1to4__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBU_Simplex1to4_1"}},
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBU_Simplex1to4_2"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBU_Simplex1to4_4"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBU_Simplex1to4_3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBU_Simplex1to4__rt{tis}
btBU_Simplex1to4_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btBU_Simplex1to4_1(a0);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_2(a0,a1);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_3(a0,a1,a2);
  }
}
private metafunction btRigidBody_upcast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody_upcast_btCollisionObject_cp"}},
    match_args{tis, {{rptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody_upcast_btCollisionObject_p"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_upcast__rt{tis}
btRigidBody_upcast(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0}}}) {
    return btRigidBody_upcast_btCollisionObject_cp(a0);
  } else if (match_args{tis, {{rptr{btCollisionObject},0}}}) {
    return btRigidBody_upcast_btCollisionObject_p(a0);
  }
}
private metafunction btRigidBody_btRigidBodyConstructionInfo__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btRigidBody_btRigidBodyConstructionInfo4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btRigidBody_btRigidBodyConstructionInfo__rt{tis}
btRigidBody_btRigidBodyConstructionInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}}) {
    return btRigidBody_btRigidBodyConstructionInfo4(a0,a1,a2,a3);
  }
}
private metafunction btTypedObject__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTypedObject1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTypedObject__rt{tis}
btTypedObject_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btTypedObject1(a0);
  }
}
private metafunction btGImpactMeshShapePart_TrimeshPrimitiveManager__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGImpactMeshShapePart_TrimeshPrimitiveManager2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactMeshShapePart_TrimeshPrimitiveManager__rt{tis}
btGImpactMeshShapePart_TrimeshPrimitiveManager_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{int,0}}}) {
    return btGImpactMeshShapePart_TrimeshPrimitiveManager2(a0,a1);
  }
}
private metafunction btCollisionWorld_AllHitsRayResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_AllHitsRayResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_AllHitsRayResultCallback__rt{tis}
btCollisionWorld_AllHitsRayResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_AllHitsRayResultCallback2(a0,a1);
  }
}
private metafunction btConvexPlaneCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexPlaneCollisionAlgorithm7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexPlaneCollisionAlgorithm__rt{tis}
btConvexPlaneCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0},{int,0},{int,0}}}) {
    return btConvexPlaneCollisionAlgorithm7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btTriangleShapeEx__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleShapeEx3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleShapeEx__rt{tis}
btTriangleShapeEx_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btTriangleShapeEx3(a0,a1,a2);
  }
}
private metafunction btBvhTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBvhTriangleMeshShape5"}},
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBvhTriangleMeshShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBvhTriangleMeshShape__rt{tis}
btBvhTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btBvhTriangleMeshShape5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}}) {
    return btBvhTriangleMeshShape3(a0,a1,a2);
  }
}
private metafunction btGeneric6DofSpringConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGeneric6DofSpringConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGeneric6DofSpringConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofSpringConstraint__rt{tis}
btGeneric6DofSpringConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofSpringConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofSpringConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSoftBody_RayFromToCaster__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBody_RayFromToCaster3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBody_RayFromToCaster__rt{tis}
btSoftBody_RayFromToCaster_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btSoftBody_RayFromToCaster3(a0,a1,a2);
  }
}
private metafunction btBroadphasePair__rt{tis}
  m::cond{
    match_args{tis, {{btBroadphaseProxy,1},{btBroadphaseProxy,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btBroadphasePair2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBroadphasePair__rt{tis}
btBroadphasePair_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btBroadphaseProxy,1},{btBroadphaseProxy,1}}}) {
    return btBroadphasePair2(a0,a1);
  }
}
private metafunction btGEN_Link__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btGEN_Link},0},{rptr{btGEN_Link},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGEN_Link2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGEN_Link__rt{tis}
btGEN_Link_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btGEN_Link},0},{rptr{btGEN_Link},0}}}) {
    return btGEN_Link2(a0,a1);
  }
}
private metafunction btCylinderShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCylinderShapeZ1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShapeZ__rt{tis}
btCylinderShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShapeZ1(a0);
  }
}
private metafunction btSoftRigidDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0},{rptr{btSoftBodySolver},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftRigidDynamicsWorld5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftRigidDynamicsWorld__rt{tis}
btSoftRigidDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0},{rptr{btSoftBodySolver},0}}}) {
    return btSoftRigidDynamicsWorld5(a0,a1,a2,a3,a4);
  }
}
private metafunction btGhostObject_upcast__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGhostObject_upcast_btCollisionObject_p"}},
    match_args{tis, {{crptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGhostObject_upcast_btCollisionObject_cp"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGhostObject_upcast__rt{tis}
btGhostObject_upcast(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btCollisionObject},0}}}) {
    return btGhostObject_upcast_btCollisionObject_p(a0);
  } else if (match_args{tis, {{crptr{btCollisionObject},0}}}) {
    return btGhostObject_upcast_btCollisionObject_cp(a0);
  }
}
private metafunction btGImpactConvexDecompositionShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{btVector3,0},{btScalar,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGImpactConvexDecompositionShape4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactConvexDecompositionShape__rt{tis}
btGImpactConvexDecompositionShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{btVector3,0},{btScalar,0},{bool,0}}}) {
    return btGImpactConvexDecompositionShape4(a0,a1,a2,a3);
  }
}
private metafunction btAxisSweep3__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{ushort,0},{rptr{btOverlappingPairCache},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btAxisSweep3_5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btAxisSweep3__rt{tis}
btAxisSweep3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{ushort,0},{rptr{btOverlappingPairCache},0},{bool,0}}}) {
    return btAxisSweep3_5(a0,a1,a2,a3,a4);
  }
}
private metafunction btBulletWorldImporter__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDynamicsWorld},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBulletWorldImporter1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBulletWorldImporter__rt{tis}
btBulletWorldImporter_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDynamicsWorld},0}}}) {
    return btBulletWorldImporter1(a0);
  }
}
private metafunction btBoxBoxDetector__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btBoxShape},0},{crptr{btBoxShape},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBoxBoxDetector2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBoxBoxDetector__rt{tis}
btBoxBoxDetector_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btBoxShape},0},{crptr{btBoxShape},0}}}) {
    return btBoxBoxDetector2(a0,a1);
  }
}
private metafunction btUniformScalingShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btConvexShape},0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btUniformScalingShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btUniformScalingShape__rt{tis}
btUniformScalingShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btConvexShape},0},{btScalar,0}}}) {
    return btUniformScalingShape2(a0,a1);
  }
}
private metafunction bt32BitAxisSweep3__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{uint,0},{rptr{btOverlappingPairCache},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "bt32BitAxisSweep3_5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
bt32BitAxisSweep3__rt{tis}
bt32BitAxisSweep3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{uint,0},{rptr{btOverlappingPairCache},0},{bool,0}}}) {
    return bt32BitAxisSweep3_5(a0,a1,a2,a3,a4);
  }
}
private metafunction btPoolAllocator__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btPoolAllocator2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPoolAllocator__rt{tis}
btPoolAllocator_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0}}}) {
    return btPoolAllocator2(a0,a1);
  }
}
private metafunction btHashString__rt{tis}
  m::cond{
    match_args{tis, {{crptr{char},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btHashString1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btHashString__rt{tis}
btHashString_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{char},0}}}) {
    return btHashString1(a0);
  }
}
private metafunction btCylinderShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCylinderShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShape__rt{tis}
btCylinderShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShape1(a0);
  }
}
private metafunction btMultiSapBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMultiSapBroadphase2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMultiSapBroadphase__rt{tis}
btMultiSapBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}}) {
    return btMultiSapBroadphase2(a0,a1);
  }
}
private metafunction btSimplePair__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSimplePair2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimplePair__rt{tis}
btSimplePair_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0}}}) {
    return btSimplePair2(a0,a1);
  }
}
private metafunction btBox2dBox2dCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBox2dBox2dCollisionAlgorithm4"}},
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBox2dBox2dCollisionAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBox2dBox2dCollisionAlgorithm__rt{tis}
btBox2dBox2dCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btBox2dBox2dCollisionAlgorithm4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btBox2dBox2dCollisionAlgorithm1(a0);
  }
}
private metafunction btCollisionDispatcher__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionDispatcher1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionDispatcher__rt{tis}
btCollisionDispatcher_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btCollisionConfiguration},0}}}) {
    return btCollisionDispatcher1(a0);
  }
}
private metafunction btCollisionWorld_ClosestRayResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_ClosestRayResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_ClosestRayResultCallback__rt{tis}
btCollisionWorld_ClosestRayResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_ClosestRayResultCallback2(a0,a1);
  }
}
private metafunction btGeneric6DofConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGeneric6DofConstraint5"}},
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGeneric6DofConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGeneric6DofConstraint__rt{tis}
btGeneric6DofConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofConstraint5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofConstraint3(a0,a1,a2);
  }
}
private metafunction btSoftBodyConcaveCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBodyConcaveCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBodyConcaveCollisionAlgorithm__rt{tis}
btSoftBodyConcaveCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btSoftBodyConcaveCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btWheelInfo__rt{tis}
  m::cond{
    match_args{tis, {{btWheelInfoConstructionInfo,1}}},
    m::ret_type{m::symbol{"Bullet::api", "btWheelInfo1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btWheelInfo__rt{tis}
btWheelInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btWheelInfoConstructionInfo,1}}}) {
    return btWheelInfo1(a0);
  }
}
private metafunction btGImpactMeshShapePart__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGImpactMeshShapePart2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGImpactMeshShapePart__rt{tis}
btGImpactMeshShapePart_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{int,0}}}) {
    return btGImpactMeshShapePart2(a0,a1);
  }
}
private metafunction btDbvtAabbMm_FromPoints__rt{tis}
  m::cond{
    match_args{tis, {{rptr{crptr{btVector3}},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvtAabbMm_FromPoints_btVector3_cp_p_int"}},
    match_args{tis, {{crptr{btVector3},0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvtAabbMm_FromPoints_btVector3_cp_int"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvtAabbMm_FromPoints__rt{tis}
btDbvtAabbMm_FromPoints(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{crptr{btVector3}},0},{int,0}}}) {
    return btDbvtAabbMm_FromPoints_btVector3_cp_p_int(a0,a1);
  } else if (match_args{tis, {{crptr{btVector3},0},{int,0}}}) {
    return btDbvtAabbMm_FromPoints_btVector3_cp_int(a0,a1);
  }
}
private metafunction btTriIndex__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0},{rptr{btCollisionShape},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriIndex3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriIndex__rt{tis}
btTriIndex_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0},{rptr{btCollisionShape},0}}}) {
    return btTriIndex3(a0,a1,a2);
  }
}
private metafunction btTriangleConvexcastCallback__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{btTransform,0},{btTransform,0},{btTransform,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTriangleConvexcastCallback5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTriangleConvexcastCallback__rt{tis}
btTriangleConvexcastCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{btTransform,0},{btTransform,0},{btTransform,0},{btScalar,0}}}) {
    return btTriangleConvexcastCallback5(a0,a1,a2,a3,a4);
  }
}
private metafunction btFixedConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btFixedConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btFixedConstraint__rt{tis}
btFixedConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}}) {
    return btFixedConstraint4(a0,a1,a2,a3);
  }
}
private metafunction btWorldImporter__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDynamicsWorld},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btWorldImporter1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btWorldImporter__rt{tis}
btWorldImporter_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDynamicsWorld},0}}}) {
    return btWorldImporter1(a0);
  }
}
private metafunction btConeTwistConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeTwistConstraint2"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConeTwistConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConeTwistConstraint__rt{tis}
btConeTwistConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0}}}) {
    return btConeTwistConstraint2(a0,a1);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}}) {
    return btConeTwistConstraint4(a0,a1,a2,a3);
  }
}
private metafunction btManifoldPoint__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btManifoldPoint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btManifoldPoint__rt{tis}
btManifoldPoint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btManifoldPoint4(a0,a1,a2,a3);
  }
}
private metafunction btBoxShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btBoxShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btBoxShape__rt{tis}
btBoxShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btBoxShape1(a0);
  }
}
private metafunction btDbvt_sStkNP__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvt_sStkNP2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_sStkNP__rt{tis}
btDbvt_sStkNP_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{uint,0}}}) {
    return btDbvt_sStkNP2(a0,a1);
  }
}
private metafunction btSoftBodyRigidBodyCollisionConfiguration__rt{tis}
  m::cond{
    match_args{tis, {{btDefaultCollisionConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBodyRigidBodyCollisionConfiguration1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBodyRigidBodyCollisionConfiguration__rt{tis}
btSoftBodyRigidBodyCollisionConfiguration_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btDefaultCollisionConstructionInfo,0}}}) {
    return btSoftBodyRigidBodyCollisionConfiguration1(a0);
  }
}
private metafunction btJacobianEntry__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btJacobianEntry5"}},
    match_args{tis, {{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btJacobianEntry9"}},
    match_args{tis, {{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btJacobianEntry6"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btJacobianEntry4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btJacobianEntry__rt{tis}
btJacobianEntry_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0}}}) {
    return btJacobianEntry5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0},{btVector3,0},{btScalar,0}}}) {
    return btJacobianEntry9(a0,a1,a2,a3,a4,a5,a6,a7,a8);
  } else if (match_args{tis, {{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btJacobianEntry6(a0,a1,a2,a3,a4,a5);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btJacobianEntry4(a0,a1,a2,a3);
  }
}
private metafunction btMatrixX_double__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMatrixX_double2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMatrixX_double__rt{tis}
btMatrixX_double_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0}}}) {
    return btMatrixX_double2(a0,a1);
  }
}
private metafunction btSimpleBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSimpleBroadphaseProxy7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSimpleBroadphaseProxy__rt{tis}
btSimpleBroadphaseProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}}) {
    return btSimpleBroadphaseProxy7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btSoftBodyCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btSoftBody},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSoftBodyCollisionShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSoftBodyCollisionShape__rt{tis}
btSoftBodyCollisionShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btSoftBody},0}}}) {
    return btSoftBodyCollisionShape1(a0);
  }
}
private metafunction btCylinderShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCylinderShapeX1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCylinderShapeX__rt{tis}
btCylinderShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShapeX1(a0);
  }
}
private metafunction btConvexSeparatingDistanceUtil__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexSeparatingDistanceUtil2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexSeparatingDistanceUtil__rt{tis}
btConvexSeparatingDistanceUtil_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConvexSeparatingDistanceUtil2(a0,a1);
  }
}
private metafunction btTransform__rt{tis}
  m::cond{
    match_args{tis, {{btQuaternion,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTransform_btQuaternion_btVector3"}},
    match_args{tis, {{btMatrix3x3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btTransform_btMatrix3x3_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btTransform__rt{tis}
btTransform_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btQuaternion,0},{btVector3,0}}}) {
    return btTransform_btQuaternion_btVector3(a0,a1);
  } else if (match_args{tis, {{btMatrix3x3,0},{btVector3,0}}}) {
    return btTransform_btMatrix3x3_btVector3(a0,a1);
  }
}
private metafunction btMatrix3x3__rt{tis}
  m::cond{
    match_args{tis, {{btQuaternion,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMatrix3x3_1"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btMatrix3x3_9"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btMatrix3x3__rt{tis}
btMatrix3x3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btQuaternion,0}}}) {
    return btMatrix3x3_1(a0);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btMatrix3x3_9(a0,a1,a2,a3,a4,a5,a6,a7,a8);
  }
}
private metafunction btGjkPairDetector__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{int,0},{int,0},{btScalar,0},{btScalar,0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGjkPairDetector8"}},
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btGjkPairDetector4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btGjkPairDetector__rt{tis}
btGjkPairDetector_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{int,0},{int,0},{btScalar,0},{btScalar,0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btGjkPairDetector8(a0,a1,a2,a3,a4,a5,a6,a7);
  } else if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btGjkPairDetector4(a0,a1,a2,a3);
  }
}
private metafunction btCollisionWorld_LocalRayResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionWorld_LocalRayResult4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionWorld_LocalRayResult__rt{tis}
btCollisionWorld_LocalRayResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btScalar,0}}}) {
    return btCollisionWorld_LocalRayResult4(a0,a1,a2,a3);
  }
}
private metafunction btSphereShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btSphereShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btSphereShape__rt{tis}
btSphereShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0}}}) {
    return btSphereShape1(a0);
  }
}
private metafunction btPolarDecomposition__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{uint,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btPolarDecomposition2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btPolarDecomposition__rt{tis}
btPolarDecomposition_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{uint,0}}}) {
    return btPolarDecomposition2(a0,a1);
  }
}
private metafunction btConvexConcaveCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvexConcaveCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvexConcaveCollisionAlgorithm__rt{tis}
btConvexConcaveCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btConvexConcaveCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"Bullet::api", "btCollisionAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btCollisionAlgorithm__rt{tis}
btCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btCollisionAlgorithm1(a0);
  }
}
private metafunction btConvex2dShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btConvexShape},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btConvex2dShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btConvex2dShape__rt{tis}
btConvex2dShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btConvexShape},0}}}) {
    return btConvex2dShape1(a0);
  }
}
private metafunction btDbvt_sStkCLN__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{rptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{"Bullet::api", "btDbvt_sStkCLN2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public threaded function {tis}
btDbvt_sStkCLN__rt{tis}
btDbvt_sStkCLN_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{rptr{btDbvtNode},0}}}) {
    return btDbvt_sStkCLN2(a0,a1);
  }
}
