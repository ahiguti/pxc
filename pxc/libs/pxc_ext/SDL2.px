public threaded namespace SDL2 "use-unsafe";
public import common -;
public import exception -;
public import meta m;

extern "cflags" "`sdl2-config --cflags`";
extern "ldflags" "`sdl2-config --libs`";

/* SDL_Init */

public struct extern "SDL2::Init" "nodefault"
SDL_Init(SDL_InitFlags flags) { }

public tsvaluetype struct extern "Uint32" "extbitmask" SDL_InitFlags { }
expand(sym : m::map{m::list{
  "AUDIO", "VIDEO", "CDROM", "TIMER", "EVERYTHING"
}, metafunction{x} m::concat{"SDL_INIT_", x}}) {
  public extern "%" SDL_InitFlags sym;
}

/* SDL_Window */

public function option{ptr{SDL_Window}}
SDL_CreateWindow(cstrref const& title, int x, int y, int w, int h,
  SDL_WindowFlags f)
{
  ptr{SDL_Window} p = make_ptr{SDL_Window}();
  option{ptr{SDL_Window}} r;
  if (CreateWindow(*p, title, x, y, w, h, f) == 0) {
    r.some = p;
  }
  return r;
}

public struct extern "SDL2::Window" "noncopyable"
SDL_Window private() { }

public extern "%" int SDL_WINDOWPOS_UNDEFINED;

public tsvaluetype struct extern "Uint32" "extbitmask" SDL_WindowFlags { }
expand(sym : m::map{m::list{
  "FULLSCREEN", "OPENGL", "SHOWN", "HIDDEN", "BORDERLESS", "RESIZABLE",
  "MINIMIZED", "MAXIMIZED", "INPUT_GRABBED", "INPUT_FOCUS", "MOUSE_FOCUS",
  "FULLSCREEN_DESKTOP", "ALLOW_HIGHDPI"
}, metafunction{x} m::concat{"SDL_WINDOW_", x}}) {
  public extern "%" SDL_WindowFlags sym;
}

public function extern "SDL2::GetWindowSize" void
SDL_GetWindowSize(ptr{SDL_Window} const& wnd, int mutable& w, int mutable& h);

private function extern "SDL2::CreateWindow" int
CreateWindow(SDL_Window mutable& wnd, cstrref const& title, int x, int y,
  int w, int h, SDL_WindowFlags f);

/* SDL_Renderer */

public function option{ptr{SDL_Renderer}}
SDL_CreateRenderer(ptr{SDL_Window} const& wnd, int index, SDL_RendererFlags f)
{
  ptr{SDL_Renderer} p = make_ptr{SDL_Renderer}();
  option{ptr{SDL_Renderer}} r;
  if (CreateRenderer(*p, *wnd, index, f) == 0) {
    r.some = p;
  }
  return r;
}

public struct extern "SDL2::Renderer" "noncopyable"
SDL_Renderer private () { }

public tsvaluetype struct extern "Uint32" "extbitmask" SDL_RendererFlags { }
expand(sym : m::map{m::list{
  "SOFTWARE", "ACCELERATED", "PRESENTVSYNC", "TARGETTEXTURE"
}, metafunction{x} m::concat{"SDL_RENDERER_", x}}) {
  public extern "%" SDL_RendererFlags sym;
}

public struct extern "SDL_Rect" SDL_Rect {
  public int x;
  public int y;
  public int w;
  public int h;
}

public function extern "SDL2::RenderClear" int
SDL_RenderClear(ptr{SDL_Renderer} const& rnd);
public function extern "SDL2::RenderPresent" void
SDL_RenderPresent(ptr{SDL_Renderer} const& rnd);
public function extern "SDL2::RenderCopy" int
SDL_RenderCopy(ptr{SDL_Renderer} const& rnd,
  ptr{SDL_Texture} const& tx, SDL_Rect const& src, SDL_Rect const& dst);

private function extern "SDL2::CreateRenderer" int
CreateRenderer(SDL_Renderer mutable& rnd, SDL_Window const& wnd,
  int index, SDL_RendererFlags f);

/* SDL_Surface */

public struct extern "SDL2::Surface" "noncopyable"
SDL_Surface private () { }

public function option{ptr{SDL_Surface}}
SDL_LoadBMP(cstrref const& filename)
{
  ptr{SDL_Surface} p = make_ptr{SDL_Surface}();
  option{ptr{SDL_Surface}} r;
  if (LoadBMP(*p, filename) == 0) {
    r.some = p;
  }
  return r;
}

private function extern "SDL2::LoadBMP" int
LoadBMP(SDL_Surface mutable& sur, cstrref const& filename);

public function option{ptr{SDL_Surface}}
SDL_CreateRGBSurface(int width, int height, int depth, uint rmask, uint gmask,
  uint bmask, uint amask)
{
  ptr{SDL_Surface} p = make_ptr{SDL_Surface}();
  option{ptr{SDL_Surface}} r;
  if (CreateRGBSurface(*p, width, height, depth, rmask, gmask, bmask, amask)
    == 0) {
    r.some = p;
  }
  return r;
}

private function extern "SDL2::CreateRGBSurface" int
CreateRGBSurface(SDL_Surface mutable& sur, int width, int height, int depth,
  uint rmask, uint gmask, uint bmask, uint amask);

public function extern "SDL2::Surface_W" uint
SDL_Surface_W(ptr{SDL_Surface} const& sur);
public function extern "SDL2::Surface_H" uint
SDL_Surface_H(ptr{SDL_Surface} const& sur);
public function extern "SDL2::Surface_Pitch" uint
SDL_Surface_Pitch(ptr{SDL_Surface} const& sur);
public function extern "SDL2::Surface_BytesPerPixel" uint
SDL_Surface_BytesPerPixel(ptr{SDL_Surface} const& sur);
public function extern "SDL2::Surface_Pixels" strref
SDL_Surface_Pixels(ptr{SDL_Surface} const& sur);

public function extern "SDL2::BlitSurface" int
SDL_BlitSurface(ptr{SDL_Surface} const& src, SDL_Rect const& srcrect,
  ptr{SDL_Surface} const& dst, SDL_Rect mutable& dstrect);

public tsvaluetype struct extern "SDL_Color"
SDL_Color {
  public uchar r;
  public uchar g;
  public uchar b;
  public uchar a;
}

/* SDL_Texture */

public function option{ptr{SDL_Texture}}
SDL_CreateTextureFromSurface(ptr{SDL_Renderer} const& rnd,
  ptr{SDL_Surface} const& sur)
{
  ptr{SDL_Texture} p = make_ptr{SDL_Texture}();
  option{ptr{SDL_Texture}} r;
  if (CreateTextureFromSurface(*p, rnd, sur) == 0) {
    r.some = p;
  }
  return r;
}

public struct extern "SDL2::Texture" "noncopyable"
SDL_Texture private () { }

public function extern "SDL2::CreateTextureFromSurface" int
CreateTextureFromSurface(SDL_Texture mutable& tx, ptr{SDL_Renderer} const& rnd,
  ptr{SDL_Surface} const& sur);

/* SDL_Event */

public tsvaluetype struct extern "uchar" "extenum" SDL_ButtonState { }
public extern "::SDL_PRESSED" SDL_ButtonState SDL_PRESSED;
public extern "::SDL_RELEASED" SDL_ButtonState SDL_RELEASED;

public tsvaluetype struct extern "SDL_TouchID" "extint" SDL_TouchID { }
public tsvaluetype struct extern "SDL_FingerID" "extint" SDL_FingerID { }

public tsvaluetype struct extern "SDL_Event" SDL_Event {
  /* SDL_Event is actually a union */
  public SDL_EventType const type;
  public SDL_CommonEvent const common;
  public SDL_WindowEvent const window;
  public SDL_KeyboardEvent const key;
  public SDL_TextEditingEvent const edit;
  public SDL_TextInputEvent const text;
  public SDL_MouseMotionEvent const motion;
  public SDL_MouseButtonEvent const button;
  public SDL_MouseWheelEvent const wheel;
  public SDL_JoyAxisEvent const jaxis;
  public SDL_JoyBallEvent const jball;
  public SDL_JoyHatEvent const jhat;
  public SDL_JoyButtonEvent const jbutton;
  public SDL_JoyDeviceEvent const jdevice;
  public SDL_ControllerAxisEvent const caxis;
  public SDL_ControllerButtonEvent const cbutton;
  public SDL_ControllerDeviceEvent const cdevice;
  public SDL_QuitEvent const quit;
  public SDL_UserEvent const user;
  public SDL_SysWMEvent const syswm;
  public SDL_TouchFingerEvent const tfinger;
  public SDL_MultiGestureEvent const mgesture;
  public SDL_DollarGestureEvent const dgesture;
  public SDL_DropEvent const drop;
}
public tsvaluetype struct extern "SDL_CommonEvent" SDL_CommonEvent {
  public SDL_EventType const type;
  public uint const timestamp;
}
public tsvaluetype struct extern "SDL_WindowEvent" SDL_WindowEvent {
  public SDL_EventType const type;
  public uint const timestamp;
  public uint const windowID;
  public SDL_WindowEventID const event;
  public int const data1;
  public int const data2;
}
public tsvaluetype struct extern "SDL_KeyboardEvent"
SDL_KeyboardEvent {
  public SDL_EventType const type;
  public uint const timestamp;
  public uint const windowID;
  public uchar const state;
  public uchar const repeat;
  public SDL_Keysym keysym;
}
public tsvaluetype struct extern "SDL_TextEditingEvent"
SDL_TextEditingEvent { }
public tsvaluetype struct extern "SDL_TextInputEvent"
SDL_TextInputEvent { }
public tsvaluetype struct extern "SDL_MouseButtonEvent"
SDL_MouseButtonEvent {
  public SDL_EventType const type;
  public uint const timestamp;
  public uint const windowID;
  public uint const which;
  public uchar const button;
  public SDL_ButtonState const state;
  public uchar const clicks;
  public int const x;
  public int const y;
}
public tsvaluetype struct extern "SDL_MouseMotionEvent"
SDL_MouseMotionEvent { }
public tsvaluetype struct extern "SDL_MouseWheelEvent"
SDL_MouseWheelEvent { }
public tsvaluetype struct extern "SDL_JoyAxisEvent"
SDL_JoyAxisEvent { }
public tsvaluetype struct extern "SDL_JoyBallEvent"
SDL_JoyBallEvent { }
public tsvaluetype struct extern "SDL_JoyHatEvent"
SDL_JoyHatEvent { }
public tsvaluetype struct extern "SDL_JoyButtonEvent"
SDL_JoyButtonEvent { }
public tsvaluetype struct extern "SDL_JoyDeviceEvent"
SDL_JoyDeviceEvent { }
public tsvaluetype struct extern "SDL_ControllerAxisEvent"
SDL_ControllerAxisEvent { }
public tsvaluetype struct extern "SDL_ControllerButtonEvent"
SDL_ControllerButtonEvent { }
public tsvaluetype struct extern "SDL_ControllerDeviceEvent"
SDL_ControllerDeviceEvent { }
public tsvaluetype struct extern "SDL_QuitEvent"
SDL_QuitEvent { }
public tsvaluetype struct extern "SDL_UserEvent"
SDL_UserEvent { }
public tsvaluetype struct extern "SDL_SysWMEvent"
SDL_SysWMEvent { }
public tsvaluetype struct extern "SDL_TouchFingerEvent"
SDL_TouchFingerEvent {
  public SDL_EventType const type;
  public uint const timestamp;
  public SDL_TouchID touchId;
  public SDL_FingerID fingerId;
  public float x;
  public float y;
  public float dx;
  public float dy;
  public float pressure;
}
public tsvaluetype struct extern "SDL_MultiGestureEvent"
SDL_MultiGestureEvent {
  public SDL_EventType const type;
  public uint const timestamp;
  public float dTheta;
  public float dDist;
  public float x;
  public float y;
  public ushort numFingers;
}
public tsvaluetype struct extern "SDL_DollarGestureEvent"
SDL_DollarGestureEvent { }
public tsvaluetype struct extern "SDL_DropEvent" SDL_DropEvent { }

public function extern "SDL2::PollEvent" bool
SDL_PollEvent(SDL_Event mutable& ev);

public tsvaluetype struct extern "Uint32" /* SDL_EventType */ "extenum"
SDL_EventType { }
expand(sym : m::map{m::list{
  "QUIT", "APP_TERMINATING", "APP_LOWMEMORY", "APP_WILLENTERBACKGROUND",
  "APP_DIDENTERBACKGROUND", "APP_WILLENTERFOREGROUND",
  "APP_DIDENTERFOREGROUND", "WINDOWEVENT", "SYSWMEVENT", "KEYDOWN", "KEYUP",
  "TEXTEDITING", "TEXTINPUT", "MOUSEMOTION", "MOUSEBUTTONDOWN",
  "MOUSEBUTTONUP", "MOUSEWHEEL", "JOYAXISMOTION", "JOYBALLMOTION",
  "JOYHATMOTION", "JOYBUTTONDOWN", "JOYBUTTONUP", "JOYDEVICEADDED",
  "JOYDEVICEREMOTED", "CONTROLLERAXISMOTION", "CONTROLLERBUTTONDOWN",
  "CONTROLLERBUTTONUP", "CONTROLLERDEVICEADDED", "CONTROLLERDEVICEREMOVED",
  "CONTROLLERDEVICEREMAPPED", "FINGERDOWN", "FINGERUP", "FINGERMOTION",
  "DOLLARGESTURE", "DOLLARRECORD", "MULTIGESTURE", "CLIPBOARDUPDATE",
  "DROPFILE", "USEREVENT", "LASTEVENT"
}, metafunction{x} m::concat{"SDL_", x}}) {
  public extern "%" SDL_EventType sym;
}

public tsvaluetype struct extern "Uint8" "extenum" SDL_WindowEventID { }
expand (sym : m::map{m::list{
  "SHOWN", "HIDDEN", "EXPOSED", "MOVED", "RESIZED", "SIZE_CHANGED",
  "MINIMIZED", "MAXIMIZED", "RESTORED", "ENTER", "LEAVE", "FOCUS_GAINED",
  "FOCUS_LOST", "CLOSE"
}, metafunction{x} m::concat{"SDL_WINDOWEVENT_", x}}) {
  public extern "%" SDL_WindowEventID sym;
}

public tsvaluetype struct extern "SDL_GLattr" "extenum" SDL_GLattr { }
expand (sym : m::map{m::list{
  "DOUBLEBUFFER", "CONTEXT_MAJOR_VERSION", "CONTEXT_MINOR_VERSION",
  "CONTEXT_PROFILE_MASK", "ACCELERATED_VISUAL"
}, metafunction{x} m::concat{"SDL_GL_", x}}) {
  public extern "%" SDL_GLattr sym;
}
expand (sym : m::map{m::list{
  "CONTEXT_PROFILE_CORE", "CONTEXT_PROFILE_COMPATIBILITY"
}, metafunction{x} m::concat{"SDL_GL_", x}}) {
  public extern "%" int sym;
}

public function option{ptr{SDL_GLContext}}
SDL_GL_CreateContext(ptr{SDL_Window} const& wnd)
{
  ptr{SDL_GLContext} p = make_ptr{SDL_GLContext}();
  option{ptr{SDL_GLContext}} r;
  if (GL_CreateContext(*p, *wnd) == 0) {
    r.some = p;
  }
  return r;
}

public struct extern "SDL2::GLContext" "noncopyable"
SDL_GLContext private () { }

public function extern "SDL_GL_SetAttribute" void
SDL_GL_SetAttribute(SDL_GLattr attr, int value);
public function extern "SDL2::GL_SwapWindow" void
SDL_GL_SwapWindow(ptr{SDL_Window} const& wnd);
public function extern "SDL_GL_SetSwapInterval" int
SDL_GL_SetSwapInterval(int v);
public function extern "SDL2::GL_GetDrawableSize" void
SDL_GL_GetDrawableSize(ptr{SDL_Window} const& wnd, int mutable& w,
  int mutable& h);

private function extern "SDL2::GL_CreateContext" int
GL_CreateContext(SDL_GLContext mutable& glctx, SDL_Window const& wnd);

/* SDL_KeyboardState */

public tsvaluetype struct extern "SDL_Keysym" 
SDL_Keysym {
  public SDL_Scancode scancode;
}

public tsvaluetype struct extern "SDL2::KeyboardState" "noncopyable"
SDL_KeyboardState() { }

public function extern "SDL2::KeyboardState_Key" uint
SDL_KeyboardState_Key(SDL_KeyboardState const& ks, SDL_Scancode code);

/* SDL_Scancode */

public tsvaluetype struct extern "SDL_Scancode" "extenum" SDL_Scancode { }
expand (sym : m::map{m::join{
  m::list{
    "UNKNOWN", "RIGHT", "LEFT", "DOWN", "UP", "ESCAPE", "SPACE", "LSHIFT",
    "LCTRL", "RETURN", "TAB"},
  m::map{
    m::seq{26}, metafunction{i} m::character{m::add{i, m::code_at{"A", 0}}}},
  m::map{
    m::seq{10}, metafunction{i} m::character{m::add{i, m::code_at{"0", 0}}}}
}, metafunction{x} m::concat{"SDL_SCANCODE_", x}}) {
  public extern "%" SDL_Scancode sym;
}

/* SDL_log */

public struct extern "int" "extenum" SDL_LogCategory { }
expand (sym : m::map{m::list{
  "APPLICATION", "ERROR", "ASSERT", "SYSTEM", "AUDIO", "VIDEO", "RENDER",
  "INPUT", "TEST"
}, metafunction{x} m::concat{"SDL_LOG_CATEGORY_", x}}) {
  public extern "%" SDL_LogCategory sym;
}

public function extern "SDL2::Log" void SDL_Log(cstrref const& mess);
public function extern "SDL2::LogInfo" void SDL_LogInfo(SDL_LogCategory cat,
  cstrref const& mess);
public function extern "SDL2::LogWarn" void SDL_LogWarn(SDL_LogCategory cat,
  cstrref const& mess);
public function extern "SDL2::LogError" void SDL_LogError(SDL_LogCategory cat,
  cstrref const& mess);

/* timer */

public function extern "SDL_GetTicks" uint SDL_GetTicks();
public function extern "SDL_Delay" void SDL_Delay(uint ms);

/* display mode */

public struct extern "SDL_DisplayMode" SDL_DisplayMode {
  public uint format;
  public int w;
  public int h;
  public int refresh_rate;
}

public function extern "SDL_GetNumDisplayModes"
int SDL_GetNumDisplayModes(int display_index);
public function extern "SDL2::GetDisplayMode"
int SDL_GetDisplayMode(int display_index, int mode_index,
  SDL_DisplayMode mutable& mode);

extern "types" inline

#include <SDL.h>

namespace SDL2 {

using namespace pxcrt;

struct Init {
  Init(Uint32 flags);
  Init();
  Init(Init const& x);
  ~Init();
private:
  Init& operator =(Init const& x);
  static int init_count;
};

struct Window : private noncopyable {
  Window();
  ~Window();
  const Init ini;
  SDL_Window *ptr;
};

struct Renderer : private noncopyable {
  Renderer();
  ~Renderer();
  const Init ini;
  SDL_Renderer *ptr;
};

struct Surface : private noncopyable {
  Surface();
  ~Surface();
  const Init ini;
  /* ptr must not be invalidated so that Surface_Pixels() returns a valid
   * slice */
  SDL_Surface *ptr;
};

struct Texture : private noncopyable {
  Texture();
  ~Texture();
  const Init ini;
  SDL_Texture *ptr;
};

struct GLContext : private noncopyable {
  GLContext();
  ~GLContext();
  const Init ini;
  SDL_GLContext ptr;
};

struct KeyboardState : private noncopyable {
  KeyboardState();
  const Uint8 *keyboardstate;
  int num;
  const Init ini;
private:
};

}; // namespace SDL2

;

extern "implementation" inline

namespace SDL2 {

using namespace pxcrt;

int Init::init_count = 0;

Init::Init(Uint32 flags)
{
  if (++init_count == 1) {
    SDL_Init(flags);
    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_VERBOSE); // FIXME
  }
}

Init::Init()
{
  if (++init_count == 1) {
    SDL_Init(0);
  }
}

Init::~Init()
{
  if (--init_count == 0) {
    SDL_Quit();
  }
}

Init::Init(Init const& x)
{
  ++init_count;
}

Window::Window()
  : ptr(0)
{
}

Window::~Window()
{
  if (ptr != 0) {
    SDL_DestroyWindow(ptr);
  }
}

bt_int CreateWindow(Window& wnd, cstrref const& title, bt_int x, bt_int y,
  bt_int w, bt_int h, Uint32 f)
{
  PXCRT_ALLOCA_NTSTRING(title_nt, title);
  wnd.ptr = SDL_CreateWindow(title_nt.get(), x, y, w, h, f);
  return (wnd.ptr != 0) ? 0 : -1;
}

typedef rcptr< rcval<Window> > Window_ptr;

void GetWindowSize(Window_ptr const& wnd, int& w, int& h)
{
  SDL_GetWindowSize(wnd->value.ptr, &w, &h);
}

Renderer::Renderer()
  : ptr(0)
{
}

Renderer::~Renderer()
{
  if (ptr != 0) {
    SDL_DestroyRenderer(ptr);
  }
}

bt_int CreateRenderer(Renderer& rnd, Window const& wnd, int index, Uint32 f)
{
  rnd.ptr = SDL_CreateRenderer(wnd.ptr, index, f);
  return (rnd.ptr != 0) ? 0 : -1;
}

Surface::Surface()
  : ptr(0)
{
}

Surface::~Surface()
{
  if (ptr != 0) {
    SDL_FreeSurface(ptr);
  }
}

bt_int LoadBMP(Surface& sur, cstrref const& filename)
{
  PXCRT_ALLOCA_NTSTRING(filename_nt, filename);
  sur.ptr = SDL_LoadBMP(filename_nt.get());
  return (sur.ptr != 0) ? 0 : -1;
}

bt_int CreateRGBSurface(Surface& sur, bt_int width, bt_int height,
  bt_int depth, bt_uint rmask, bt_uint gmask, bt_uint bmask, bt_uint amask)
{
  sur.ptr = SDL_CreateRGBSurface(SDL_SWSURFACE, width, height, depth, rmask,
    gmask, bmask, amask);
  return (sur.ptr != 0) ? 0 : -1;
}

typedef rcptr< rcval<Surface> > Surface_ptr;

bt_uint Surface_W(Surface_ptr const& sur)
{
  return sur->value.ptr->w;
}

bt_uint Surface_H(Surface_ptr const& sur)
{
  return sur->value.ptr->h;
}

bt_uint Surface_Pitch(Surface_ptr const& sur)
{
  return sur->value.ptr->pitch;
}

bt_uint Surface_BytesPerPixel(Surface_ptr const& sur)
{
  return sur->value.ptr->format->BytesPerPixel;
}

strref Surface_Pixels(Surface_ptr const& sur)
{
  SDL_Surface *const p = sur->value.ptr;
  size_t const len = p->pitch * p->h;
  return strref(static_cast<unsigned char *>(sur->value.ptr->pixels), len);
}

bt_int BlitSurface(Surface_ptr const& src, SDL_Rect const& srcrect,
  Surface_ptr const& dst, SDL_Rect& dstrect)
{
  return ::SDL_BlitSurface(src->value.ptr, &srcrect, dst->value.ptr, &dstrect);
}

Texture::Texture()
  : ptr(0)
{
}

Texture::~Texture()
{
  if (ptr != 0) {
    SDL_DestroyTexture(ptr);
  }
}

typedef rcptr< rcval<Renderer> > Renderer_ptr;
typedef rcptr< rcval<Surface> > Surface_ptr;

bt_int CreateTextureFromSurface(Texture& tx, Renderer_ptr const& rnd,
  Surface_ptr const& sur)
{
  tx.ptr = SDL_CreateTextureFromSurface(rnd->value.ptr, sur->value.ptr);
  return (tx.ptr != 0) ? 0 : -1;
}

typedef rcptr< rcval<Texture> > Texture_ptr;

bt_int RenderClear(Renderer_ptr const& rnd)
{
  return SDL_RenderClear(rnd->value.ptr);
}

void RenderPresent(Renderer_ptr const& rnd)
{
  SDL_RenderPresent(rnd->value.ptr);
}

bt_int RenderCopy(Renderer_ptr const& rnd, Texture_ptr const& tx,
  SDL_Rect const& src, SDL_Rect const& dst)
{
  return SDL_RenderCopy(rnd->value.ptr, tx->value.ptr, &src, &dst);
}

GLContext::GLContext()
  : ptr(0)
{
}

GLContext::~GLContext()
{
  if (ptr != 0) {
    ::SDL_GL_DeleteContext(ptr);
  }
}

bt_int GL_CreateContext(GLContext& glctx, Window const& wnd)
{
  glctx.ptr = SDL_GL_CreateContext(wnd.ptr);
  return (glctx.ptr != 0) ? 0 : -1;
}

KeyboardState::KeyboardState()
{
  keyboardstate = ::SDL_GetKeyboardState(&num);
}

bt_bool PollEvent(SDL_Event& ev)
{
  return ::SDL_PollEvent(&ev);
}

void GL_SwapWindow(Window_ptr const& wnd)
{
  ::SDL_GL_SwapWindow(wnd->value.ptr);
}

void GL_GetDrawableSize(Window_ptr const& wnd, bt_int& w, bt_int& h)
{
  ::SDL_GL_GetDrawableSize(wnd->value.ptr, &w, &h);
}

SDL_EventType Event_Type(SDL_Event const& e)
{
  return SDL_EventType(e.type);
}

SDL_WindowEventID Event_WindowEventID(SDL_Event const& e)
{
  return static_cast<SDL_WindowEventID>(e.window.event);
}

bt_int Event_WindowEventData1(SDL_Event const& e)
{
  return e.window.data1;
}

bt_int Event_WindowEventData2(SDL_Event const& e)
{
  return e.window.data2;
}

bt_uchar Event_KeyboardEventState(SDL_Event const& e)
{
  return e.key.state;
}

bt_uchar Event_KeyboardEventRepeat(SDL_Event const& e)
{
  return e.key.repeat;
}

bt_uint KeyboardState_Key(KeyboardState const& ks, SDL_Scancode key)
{
  if (key < ks.num) {
    return ks.keyboardstate[key];
  } else {
    return 0;
  }
}

void Log(cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_Log("%s", mess_nt.get());
}

void LogInfo(int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogInfo(cat, "%s", mess_nt.get());
}

void LogWarn(int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogWarn(cat, "%s", mess_nt.get());
}

void LogError(int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogError(cat, "%s", mess_nt.get());
}

bt_int GetDisplayMode(bt_int display, bt_int mode_index,
  SDL_DisplayMode& mode_r)
{
  return SDL_GetDisplayMode(display, mode_index, &mode_r);
}

}; // namespace SDL2

;

