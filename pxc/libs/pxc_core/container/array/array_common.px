public threaded namespace container::array::array_common "use-unsafe";
public import numeric::integral;
public import allocator;

extern "types" inline

#include <algorithm>

namespace pxcrt {

void throw_bad_alloc();
void throw_would_invalidate();
void throw_invalid_index();

/* alternative to uninitialized_* functions. optimized for pod types. */

template <typename T> struct is_trivially_copyable {
  enum { value = boost::is_pod<T>::value };
};

template <typename T> inline void
deallocate_uninitialized(T *ptr, size_t len)
{
  global_deallocate_n(ptr, len * sizeof(T));
}

template <typename T> inline T *
allocate_uninitialized(size_t len)
{
  void *p = global_allocate_n(len * sizeof(T));
  return static_cast<T *>(p);
}

template <typename T> inline void
deinitialize_n(T *ptr, size_t len)
{
  if (!is_trivially_copyable<T>::value) {
    for (T *p = ptr + len; p != ptr; --p) {
      (p - 1)->T::~T();
    }
  }
}

template <typename T> inline void
deinitialize_1(T *ptr)
{
  if (!is_trivially_copyable<T>::value) {
    ptr->T::~T();
  }
}

template <typename T> inline void
initialize_fill_n(T *ptr, size_t len, const T& x)
{
  if (is_trivially_copyable<T>::value) {
    for (size_t i = 0; i < len; ++i) {
      ptr[i] = x;
    }
  } else {
    size_t i = 0;
    PXC_TRY {
      for (; i < len; ++i) {
	new (ptr + i) T(x);
      }
    } PXC_CATCH(...) {
      deinitialize_n(ptr, i);
      PXC_RETHROW;
    }
  }
}

template <typename T> inline void
initialize_copy_n(T *ptr, size_t len, const T *src)
{
  if (is_trivially_copyable<T>::value) {
    memcpy(ptr, src, len * sizeof(T));
  } else {
    size_t i = 0;
    PXC_TRY {
      for (; i < len; ++i) {
	new (ptr + i) T(src[i]);
      }
    } PXC_CATCH(...) {
      deinitialize_n(ptr, i);
      PXC_RETHROW;
    }
  }
}

template <typename T> inline void
initialize_1(T *ptr, const T& x)
{
  if (is_trivially_copyable<T>::value) {
    *ptr = x;
  } else {
    new (ptr) T(x);
  }
}

template <typename T> inline T *
reserve_n(T *ptr, size_t vlen, size_t alloc_olen, size_t alloc_nlen)
{
  if (is_trivially_copyable<T>::value) {
    void *p = global_reallocate_n(ptr, alloc_olen * sizeof(T),
      alloc_nlen * sizeof(T));
    return static_cast<T *>(p);
  } else {
    T *p = allocate_uninitialized<T>(alloc_nlen);
    PXC_TRY {
      initialize_copy_n(p, vlen, ptr);
    } PXC_CATCH(...) {
      deallocate_uninitialized<T>(p, alloc_nlen);
      PXC_RETHROW;
    }
    deinitialize_n(ptr, vlen);
    deallocate_uninitialized<T>(ptr, vlen);
    return p;
  }
}

template <typename T> inline void
copy_n(T *ptr, size_t len, const T *src)
{
  if (is_trivially_copyable<T>::value) {
    memmove(ptr, src, len * sizeof(T));
  } else {
    for (size_t i = 0; i < len; ++i) {
      ptr[i] = src[i];
    }
  }
}

template <typename T> inline void
copy_backward_n(T *ptr, size_t len, const T *src)
{
  if (is_trivially_copyable<T>::value) {
    memmove(ptr, src, len * sizeof(T));
  } else {
    for (size_t i = len; i > 0; --i) {
      ptr[i - 1] = src[i - 1];
    }
  }
}

template <typename T> inline void
insert_n(T *x, size_t& xlen, const T *y, size_t ylen, size_t xpos)
  /* xlen is modified so that it is always the size of initialized range */
{
  /* x[0 .. xlen] must be initialized, and x[xlen .. xlen + ylen]
   * uninitialized */
  const size_t olen = xlen;
  const size_t nlen = olen + ylen;
  if (olen - xpos >= ylen) {
    /* moving size >= ylen */
    /* append from x */
    initialize_copy_n(x + xlen, ylen, x + olen - ylen);
    xlen = nlen;
    /* move */
    copy_backward_n(x + xpos + ylen, olen - ylen - xpos, x + xpos);
    /* copy from y */
    copy_n(x + xpos, ylen, y);
  } else {
    /* moving size < ylen */
    /* append from y */
    initialize_copy_n(x + xlen, ylen - (olen - xpos), y + (olen - xpos));
    xlen = xpos + ylen;
    /* append from x */
    initialize_copy_n(x + xlen, olen - xpos, x + xpos);
    xlen = nlen;
    /* copy from y */
    copy_n(x + xpos, olen - xpos, y);
  }
}

/* utility functions for array types */

template <typename T> static inline bt_size_t
array_find(const T *arr, bt_size_t len, bt_size_t offset, T const& value)
{
  if (offset >= len) {
    return len;
  }
  if (sizeof(T) == 1) {
    const T *const p = static_cast<const T *>(
      ::memchr(arr + offset, value, len - offset));
    return p != 0 ? (p - arr) : len;
  } else {
    bt_size_t i = offset;
    for (; i < len && arr[i] != value; ++i) { }
    return i;
  }
}

template <typename T> static inline bt_size_t
find_mapped_memchr(const T& c, bt_size_t offset, typename T::mapped_type v)
{
  return array_find(c.rawarr(), c.size(), offset, v);
}

template <typename T> static inline typename T::mapped_type
get_elem_value(const T& c, bt_size_t offset)
{
  return c[offset];
}

template <typename T> static inline typename T::mapped_type
get_elem_value_nochek(const T& c, bt_size_t offset)
{
  return c.rawarr()[offset];
}

template <typename Tx, typename Ty> inline int
compare_memcmp(const Tx& x, const Ty& y)
{
  BOOST_STATIC_ASSERT((
    sizeof(typename Tx::mapped_type) == sizeof(typename Ty::mapped_type)));
  const size_t xlen = x.size();
  const size_t ylen = y.size();
  const size_t clen = std::min(xlen, ylen);
  const int c = memcmp(x.rawarr(), y.rawarr(),
    clen * sizeof(typename Tx::mapped_type));
  if (c < 0) {
    return -1;
  } else if (c > 0) {
    return 1;
  }
  if (xlen < ylen) {
    return -1;
  } else if (xlen > ylen) {
    return 1;
  }
  return 0;
}

template <typename Tx, typename Ty> inline bool
eq_memcmp(const Tx& x, const Ty& y)
{
  BOOST_STATIC_ASSERT((
    sizeof(typename Tx::mapped_type) == sizeof(typename Ty::mapped_type)));
  return x.size() == y.size() &&
    memcmp(x.rawarr(), y.rawarr(),
      x.size() * sizeof(typename Tx::mapped_type)) == 0;
}

template <typename Tx, typename Ty> inline bool
lt_memcmp(const Tx& x, const Ty& y)
{
  BOOST_STATIC_ASSERT((
    sizeof(typename Tx::mapped_type) == sizeof(typename Ty::mapped_type)));
  const size_t xlen = x.size();
  const size_t ylen = y.size();
  const size_t clen = std::min(xlen, ylen);
  const int c = memcmp(x.rawarr(), y.rawarr(),
    clen * sizeof(typename Tx::mapped_type));
  if (c < 0) {
    return true;
  } else if (c == 0 && xlen < ylen) {
    return true;
  } else {
    return false;
  }
}

template <typename Tx, typename Ty> inline bool
ne_memcmp(const Tx& x, const Ty& y) { return !eq_memcmp(x, y); }
template <typename Tx, typename Ty> inline bool
gt_memcmp(const Tx& x, const Ty& y) { return lt_memcmp(y, x); }
template <typename Tx, typename Ty> inline bool
le_memcmp(const Tx& x, const Ty& y) { return !lt_memcmp(y, x); }
template <typename Tx, typename Ty> inline bool
ge_memcmp(const Tx& x, const Ty& y) { return !lt_memcmp(x, y); }

template <typename T> inline size_t
hash_podarr(const T& x)
{
  typedef typename T::mapped_type mt;
  mt const* const p = x.rawarr();
  size_t n = x.size();
  size_t r = 0;
  for (size_t i = 0; i < n; ++i) {
    r ^= p[i] + 0x9e3779b9 + (r << 6) + (r >> 2);
  }
  return r;
}

}; // namespace pxcrt

;

