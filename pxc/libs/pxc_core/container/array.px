public threaded namespace container::array "use-unsafe";
public import numeric::integral -;
public import numeric::cast -;
public import container::array::array_common;
public import container::array::refguard;
public import container::array::vector;
public import container::array::svector;
public import container::array::farray;
public import container::array::darray;
public import container::array::deque;
public import container::array::util;
public import meta m;
public import meta::family mf;
public import meta::vararg va;

/* public */

public tsvaluetype struct extern "::pxcrt::bt_slice" "slice" {t}
slice {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type slice{t};
  public metafunction crange_type cslice{t};
  public metafunction non_ephemeral_type vector{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "get" t get(size_t i) const;
  public function extern "set" void set(size_t i, t v) const;
  public function extern "increment_front" void increment_front(size_t i);
  public function extern "decrement_back" void decrement_back(size_t i);
  public function extern "next_token" slice{t} next_token(t delim);
}

public tsvaluetype struct extern "::pxcrt::bt_cslice" "cslice" {t}
cslice {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type cslice{t};
  public metafunction crange_type cslice{t};
  public metafunction non_ephemeral_type vector{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "get" t get(size_t i) const;
  public function extern "increment_front" void increment_front(size_t i);
  public function extern "decrement_back" void decrement_back(size_t i);
  public function extern "next_token" cslice{t} next_token(t const& delim);
}

public mtvaluetype struct extern "::pxcrt::pxcvector" "varray" {t}
vector {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type slice{t};
  public metafunction crange_type cslice{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "resize" void resize(size_t i, t const& v);
  public function extern "clear" void clear();
  public function extern "push_back" void push_back(t const& v);
  public function extern "pop_back" t pop_back();
  public function extern "reserve" void reserve(size_t i);
  public function extern "append" void append(crange_type const& v);
  public function extern "insert" void insert(size_t i, crange_type const& v);
  public function extern "erase" void erase(size_t first, size_t last);
}

public mtvaluetype struct extern "::pxcrt::pxcvector" "cvarray" {t}
cvector {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type cslice{t};
  public metafunction crange_type cslice{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "resize" void resize(size_t i, t const& v);
  public function extern "clear" void clear();
  public function extern "push_back" void push_back(t const& v);
  public function extern "pop_back" t pop_back();
  public function extern "reserve" void reserve(size_t i);
  public function extern "append" void append(crange_type const& v);
  public function extern "insert" void insert(size_t i, crange_type const& v);
  public function extern "erase" void erase(size_t first, size_t last);
}

public valuetype struct extern "::pxcrt::msvector" "varray" {t}
svector {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type slice{t};
  public metafunction crange_type cslice{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "resize" void resize(size_t i, t const& v);
  public function extern "clear" void clear();
  public function extern "push_back" void push_back(t const& v);
  public function extern "pop_back" t pop_back();
  public function extern "reserve" void reserve(size_t i);
  public function extern "append" void append(crange_type const& v);
  public function extern "insert" void insert(size_t i, crange_type const& v);
  public function extern "erase" void erase(size_t first, size_t last);
}

public valuetype struct extern "::pxcrt::csvector" "varray" {t}
csvector {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type cslice{t};
  public metafunction crange_type cslice{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "resize" void resize(size_t i, t const& v);
  public function extern "clear" void clear();
  public function extern "push_back" void push_back(t const& v);
  public function extern "pop_back" t pop_back();
  public function extern "reserve" void reserve(size_t i);
  public function extern "append" void append(crange_type const& v);
  public function extern "insert" void insert(size_t i, crange_type const& v);
  public function extern "erase" void erase(size_t first, size_t last);
}

public tsvaluetype struct extern "::pxcrt::farray" "farray" {t, n}
farray {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type slice{t};
  public metafunction crange_type cslice{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
}

public tsvaluetype struct extern "::pxcrt::farray" "cfarray" {t, n}
cfarray {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type cslice{t};
  public metafunction crange_type cslice{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
}

public tsvaluetype struct extern "::pxcrt::darray" "darray" {t}
darray(size_t len, t const& value) {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type slice{t};
  public metafunction crange_type cslice{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
}

public tsvaluetype struct extern "::pxcrt::darray" "cdarray" {t}
cdarray(size_t len, t const& value) {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type cslice{t};
  public metafunction crange_type cslice{t};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
}

public tsvaluetype struct extern "::pxcrt::deque_slice" "slice" {t}
deque_slice {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type deque_slice{t};
  public metafunction crange_type deque_cslice{t};
  public metafunction non_ephemeral_type deque{t};
  public metafunction is_raw_array 0;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "get" t get(size_t i) const;
  public function extern "set" void set(size_t i, t v) const;
  public function extern "increment_front" void increment_front(size_t i);
  public function extern "decrement_back" void decrement_back(size_t i);
}

public tsvaluetype struct extern "::pxcrt::deque_cslice" "cslice" {t}
deque_cslice {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type deque_cslice{t};
  public metafunction crange_type deque_cslice{t};
  public metafunction non_ephemeral_type deque{t};
  public metafunction is_raw_array 0;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "get" t get(size_t i) const;
  public function extern "increment_front" void increment_front(size_t i);
  public function extern "decrement_back" void decrement_back(size_t i);
}

public mtvaluetype struct extern "::pxcrt::pxcdeque" "varray" {t}
deque {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type deque_slice{t};
  public metafunction crange_type deque_cslice{t};
  public metafunction is_raw_array 0;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "resize" void resize(size_t i, t const& v);
  public function extern "clear" void clear();
  public function extern "push_back" void push_back(t const& v);
  public function extern "pop_back" t pop_back();
  public function extern "push_front" void push_front(t const& v);
  public function extern "pop_front" t pop_front();
  public function extern "reserve" void reserve(size_t i);
  public function extern "append" void append(crange_type const& v);
  public function extern "insert" void insert(size_t i, crange_type const& v);
  public function extern "erase" void erase(size_t first, size_t last);
}

public mtvaluetype struct extern "::pxcrt::pxcdeque" "cvarray" {t}
cdeque {
  public metafunction key_type size_t;
  public metafunction mapped_type t;
  public metafunction range_type deque_cslice{t};
  public metafunction crange_type deque_cslice{t};
  public metafunction is_raw_array 0;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
  public function extern "resize" void resize(size_t i, t const& v);
  public function extern "clear" void clear();
  public function extern "push_back" void push_back(t const& v);
  public function extern "pop_back" t pop_back();
  public function extern "push_front" void push_front(t const& v);
  public function extern "pop_front" t pop_front();
  public function extern "reserve" void reserve(size_t i);
  public function extern "append" void append(crange_type const& v);
  public function extern "insert" void insert(size_t i, crange_type const& v);
  public function extern "erase" void erase(size_t first, size_t last);
}

public tsvaluetype struct extern "::pxcrt::bt_strlit" "cfarray" strlit {
  public metafunction key_type size_t;
  public metafunction mapped_type uchar;
  public metafunction range_type cslice{uchar};
  public metafunction crange_type cslice{uchar};
  public metafunction is_raw_array 1;
  public function extern "empty" bool empty() const;
  public function extern "size" size_t size() const;
}

public threaded function {typ, tlist} farray{typ, m::size{tlist}}
make_farray(expand(va::arg_decls_bycref{tlist}))
{
  extern "disable-noheap-checking" 1;
  farray{typ, m::size{tlist}} arr;
  expand macro_construct_list{typ, tlist, "arr"};
  return arr;
}

public threaded function {typ, tlist} cfarray{typ, m::size{tlist}}
make_cfarray(expand(va::arg_decls_bycref{tlist}))
{
  extern "disable-noheap-checking" 1;
  farray{typ, m::size{tlist}} arr;
  expand macro_construct_list{typ, tlist, "arr"};
  return arr;
}

public threaded function {typ, tlist} darray{typ}
make_darray(expand(va::arg_decls_bycref{tlist}))
{
  extern "disable-noheap-checking" 1;
  mutable arr = darray{typ}(m::size{tlist}, typ());
  expand macro_construct_list{typ, tlist, "arr"};
  return arr;
}

public threaded function {typ, tlist} cdarray{typ}
make_cdarray(expand(va::arg_decls_bycref{tlist}))
{
  extern "disable-noheap-checking" 1;
  mutable arr = darray{typ}(m::size{tlist}, typ());
  expand macro_construct_list{typ, tlist, "arr"};
  return arr;
}

public threaded function {typ, tlist} vector{typ}
make_vector(expand(va::arg_decls_bycref{tlist}))
{
  extern "disable-noheap-checking" 1;
  mutable arr = vector{typ}();
  arr.resize(m::size{tlist}, typ());
  expand macro_construct_list{typ, tlist, "arr"};
  return arr;
}

public threaded function {typ, tlist} cvector{typ}
make_cvector(expand(va::arg_decls_bycref{tlist}))
{
  extern "disable-noheap-checking" 1;
  mutable arr = vector{typ}();
  arr.resize(m::size{tlist}, typ());
  expand macro_construct_list{typ, tlist, "arr"};
  return arr;
}

public threaded function {typ, tlist} deque{typ}
make_deque(expand(va::arg_decls_bycref{tlist}))
{
  extern "disable-noheap-checking" 1;
  mutable arr = deque{typ}();
  arr.resize(m::size{tlist}, typ());
  expand macro_construct_list{typ, tlist, "arr"};
  return arr;
}

public threaded function {typ, tlist} cdeque{typ}
make_cdeque(expand(va::arg_decls_bycref{tlist}))
{
  extern "disable-noheap-checking" 1;
  mutable arr = deque{typ}();
  arr.resize(m::size{tlist}, typ());
  expand macro_construct_list{typ, tlist, "arr"};
  return arr;
}

public threaded function {t} void
reverse(t const& x)
{
  metafunction size_type size_t;
  metafunction mapped_type m::symbol{t, "mapped_type"};
  size_type s = 0;
  size_type f = x.size();
  while (s < f) {
    extern "disable-bounds-checking" 1;
    --f;
    mapped_type const v = x[s];
    x[s] = x[f];
    x[f] = v;
    ++s;
  }
}

public threaded function {n, tc, tv} farray{m::symbol{tc, "crange_type"}, n}
make_farray_split(tc const& c, tv const& v)
{
  metafunction key_type m::symbol{tc, "key_type"};
  metafunction mapped_type m::symbol{tc, "mapped_type"};
  metafunction crange_type m::symbol{tc, "crange_type"};
  extern "disable-noheap-checking" 1;
  farray{crange_type, n} arr;
  key_type mutable p;
  for (size_t i : 0 .. n) {
    key_type const pend = find_mapped{tc, key_type, mapped_type}(c, p, v);
    extern "disable-bounds-checking" 1;
    extern "disable-noheap-checking" 1;
    arr[i] = c[p .. pend];
    if (pend == c.size()) {
      break;
    }
    p = pend + 1;
  }
  return arr;
}

public threaded function {tc, tv} darray{m::symbol{tc, "crange_type"}}
make_darray_split(tc const& c, tv const& v)
{
  metafunction key_type m::symbol{tc, "key_type"};
  metafunction mapped_type m::symbol{tc, "mapped_type"};
  metafunction crange_type m::symbol{tc, "crange_type"};
  size_t cnt = 1;
  for (const i, const m : c) {
    if (m == v) {
      ++cnt;
    }
  }
  extern "disable-noheap-checking" 1;
  mutable arr = darray{crange_type}(cnt, crange_type());
  key_type mutable p;
  for (size_t i : 0 .. cnt) {
    key_type const pend = find_mapped{tc, key_type, mapped_type}(c, p, v);
    extern "disable-bounds-checking" 1;
    extern "disable-noheap-checking" 1;
    arr[i] = c[p .. pend];
    p = pend + 1;
  }
  return arr;
}

public metafunction strref slice{uchar};
public metafunction cstrref cslice{uchar};
public metafunction string vector{uchar};
public metafunction dstring darray{uchar};
public metafunction fstring{n} farray{uchar, n};

public function {ts} void
vector_emplace_back(expand(emplace_back_arg_decls{ts}))
{
  metafunction t m::at0{m::at0{m::at0{ts}}};
  t mutable& x = vector_push_back_uninitialized(a0);
  x extern "placement-new" t(expand(a: emplace_back_arg_names{ts}; a));
    /* no need to handle exceptions here */
  vector_rawarr_set_valid_len(a0, a0.size() + 1);
}

public threaded function extern "::pxcrt::string_cmp" {t} int
string_cmp(t const& x, t const& y);

public threaded function extern "::pxcrt::sstring_cmp" int
sstring_cmp(svector{uchar} const& x, svector{uchar} const& y);

public threaded function extern "::pxcrt::sstring_eq" bool
sstring_eq(svector{uchar} const& x, svector{uchar} const& y);

public threaded function extern "::pxcrt::hash_sstring" size_t
hash_sstring(svector{uchar} const& x);

public threaded function {t, tk, tm} tk
find_mapped(t const& c, tk k, tm const& x)
{
  if (m::and{mf::is_array_or_slice_type{t},
    m::or{m::eq{tm, char}, m::eq{tm, uchar}}}) {
    return find_mapped_memchr{t}(c, k, x);
  } else {
    tk i;
    tk const sz = c.size();
    for (i = k; i < sz; ++i) {
      extern "disable-bounds-checking" 1;
      if (c[i] == x) { break; }
    }
    return i;
  }
}

/* private */

private function extern "::pxcrt::pxcvector_push_back_uninitialized" {t}
t mutable& vector_push_back_uninitialized(vector{t} mutable& v);

private function extern "::pxcrt::pxcvector_rawarr_set_valid_len" {t}
void vector_rawarr_set_valid_len(vector{t} mutable& v, size_t len);

private metafunction emplace_back_arg_decls{ts}
  m::map{
    m::seq{m::size{ts}},
    metafunction{i}
      m::list{m::concat{"a", i}, m::at0{m::at{ts, i}},
	m::cond{m::eq{i, 0}, 1, 0}, 1}}; /* 1st arg is by mutable ref */

private metafunction emplace_back_arg_names{ts}
  m::map{m::seq{1, m::size{ts}}, metafunction{i} m::concat{"a", i}};

private threaded function extern "::pxcrt::find_mapped_memchr" {t}
m::symbol{t, "key_type"}
find_mapped_memchr(t const& c, m::symbol{t, "key_type"} const& k,
  m::symbol{t, "mapped_type"} const& x);

private function {typ, tlist, arr} expand macro_construct_list
{
  expand (a, i: va::arg_names{m::size{tlist}}) {
    if (mf::is_numeric_type{typ}) {
      arr[i] = static_cast{typ}(a);
    } else {
      extern "disable-noheap-checking" 1;
      arr[i] = a;
    }
  }
}

