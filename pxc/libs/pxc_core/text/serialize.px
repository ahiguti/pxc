threaded namespace text::serialize;
public import numeric::integral -;
public import container::array -;
public import meta m;
public import meta::family mf;
public import numeric::cast -;
public import generic -;

public threaded function {tpl, t} void
serialize(t const& x, tplf{"target_type"} mutable& o)
{
  metafunction tplf{x} m::find{tpl, x, 0};
  metafunction tsym{x} m::symbol{t, x};
  if (m::not{m::eq{m::apply{tplf{"specialized_func"}, t}, 0}}) {
    m::apply{tplf{"specialized_func"}, t}(x, o);
  } else if (mf::is_array_or_slice_type{t}) {
    metafunction tmapped tsym{"mapped_type"};
    tplf{"array_begin"}(o);
    for (size_t i, tmapped v : x) {
      if (i != 0) {
	tplf{"array_sep"}(o);
      }
      serialize{tpl, tmapped}(v, o);
    }
    tplf{"array_end"}(o);
  } else if (mf::is_map_or_range_type{t}) {
    metafunction tkey tsym{"key_type"};
    metafunction tmapped tsym{"mapped_type"};
    tplf{"map_begin"}(o);
    bool is_first = true;
    for (tkey k, tmapped v : x) {
      if (is_first) {
	is_first = false;
      } else {
	tplf{"map_sep"}(o);
      }
      serialize{tpl, tkey}(k, o);
      tplf{"map_entry_sep"}(o);
      serialize{tpl, tmapped}(v, o);
    }
    tplf{"map_end"}(o);
  } else if (mf::is_pointer_type{t}) {
    tplf{"pointer_begin"}(o);
    serialize{tpl, m::at{t, 0}}(*x, o);
    tplf{"pointer_end"}(o);
  } else if (mf::is_struct_type{t}) {
    tplf{"struct_begin"}(o);
    expand (fld, idx : field_names_sorted{t}) {
      if (idx != 0) {
	tplf{"struct_sep"}(o);
      }
      tplf{"struct_field_name"}(m::to_string{fld}, o);
      tplf{"struct_entry_sep"}(o);
      serialize{tpl, m::at{field_types_sorted{t}, idx}}(x.fld, o);
    }
    tplf{"struct_end"}(o);
  } else if (mf::is_union_type{t}) {
    tplf{"union_begin"}(o);
    expand (fld, idx : m::field_names{t}) {
      if (case x.fld) {
	tplf{"union_field_name"}(m::to_string{fld}, o);
	tplf{"union_entry_sep"}(o);
	serialize{tpl, m::at{m::field_types{t}, idx}}(x.fld, o);
      }
    }
    tplf{"union_end"}(o);
  } else {
    m::apply{tplf{"unknown"}, t}(x, o);
  }
}

public threaded function {tpl, t} void
deserialize(tplf{"source_type"} mutable& s, t mutable& r)
{
  metafunction tplf{x} m::find{tpl, x, 0};
  metafunction tsym{x} m::symbol{t, x};
  if (m::not{m::eq{m::apply{tplf{"specialized_func"}, t}, 0}}) {
    r = m::apply{tplf{"specialized_func"}, t}(s);
  } else if (mf::is_array_or_slice_type{t}) {
    if (m::eq{m::family{t}, "varray"}) {
      if (tplf{"array_begin_cond"}(s)) {
	bool is_first = true;
	while (true) {
	  if (s.empty() || tplf{"array_end_cond"}(s)) {
	    break;
	  }
	  if (is_first) {
	    is_first = false;
	  } else {
	    tplf{"array_sep_cond"}(s);
	  }
	  const sz = r.size();
	  mutable ent = make_default{m::at0{t}}();
	  r.push_back(ent);
	  deserialize{tpl, m::at0{t}}(s, r[sz]);
	}
      } else {
	tplf{"value_skip"}(s);
      }
    } else if (m::eq{m::family{t}, "farray"}) {
      if (tplf{"array_begin_cond"}(s)) {
	bool is_first = true;
	size_t idx = 0;
	while (true) {
	  if (s.empty() || tplf{"array_end_cond"}(s)) {
	    break;
	  }
	  if (is_first) {
	    is_first = false;
	  } else {
	    tplf{"array_sep_cond"}(s);
	  }
	  if (idx < m::at1{t}) {
	    deserialize{tpl, m::at0{t}}(s, r[idx]);
	    ++idx;
	  } else {
	    m::at0{t} ent = make_default{m::at0{t}}();
	    deserialize{tpl, m::at0{t}}(s, ent);
	  }
	}
      } else {
	tplf{"value_skip"}(s);
      }
    } else {
      m::apply{tplf{"unknown"}, t}(s);
    }
  } else if (mf::is_map_or_range_type{t}) {
    if (s.empty() || tplf{"map_begin_cond"}(s)) {
      bool is_first = true;
      while (true) {
	if (tplf{"map_end_cond"}(s)) {
	  break;
	}
	if (is_first) {
	  is_first = false;
	} else {
	  tplf{"map_sep_cond"}(s);
	}
	mutable k = make_default{m::at0{t}}();
	deserialize{tpl, m::at{t, 0}}(s, k);
	if (!tplf{"map_entry_sep_cond"}(s)) {
	  tplf{"map_end_skip"}(s);
	  break;
	}
	deserialize{tpl, m::at{t, 1}}(s, r[k]);
      }
    } else {
      tplf{"value_skip"}(s);
    }
  } else if (mf::is_pointer_type{t}) {
    if (tplf{"pointer_begin_cond"}(s)) {
      if (mf::is_mutable_pointer_type{t}) {
	deserialize{tpl, m::at0{t}}(s, *r);
      } else {
	mutable v = make_default{m::at0{t}}();
	deserialize{tpl, m::at0{t}}(s, v);
	r = box_pointer{t}(v);
      }
      tplf{"pointer_end_skip"}(s);
    }
  } else if (mf::is_struct_type{t}) {
    if (tplf{"struct_begin_cond"}(s)) {
      expand (fld, idx : field_names_sorted{t}) {
	if (!tplf{"struct_end_peek_cond"}(s)) {
	  bool found = true;
	  while (true) {
	    tplf{"struct_sep_cond"}(s);
	    tplf{"source_type"} s0 = s;
	    tplf{"struct_field_name_peek"}(s0);
	    if (s0 == m::to_string{fld}) {
	      break;
	    } else if (s0 > m::to_string{fld}) {
	      found = false;
	      break;
	    }
	    s.increment_front(s0.size());
	    tplf{"struct_entry_sep_cond"}(s);
	    tplf{"value_skip"}(s);
	    if (s.empty() || tplf{"struct_end_peek_cond"}(s)) {
	      found = false;
	      break;
	    }
	  }
	  if (found) {
	    s.increment_front(m::strlen{m::to_string{fld}});
	    tplf{"struct_entry_sep_cond"}(s);
	    deserialize{tpl, m::at{field_types_sorted{t}, idx}}(s, r.fld);
	  }
	}
      }
      tplf{"struct_end_skip"}(s);
    } else {
      tplf{"value_skip"}(s);
    }
  } else if (mf::is_union_type{t}) {
    if (tplf{"union_begin_cond"}(s)) {
      bool is_first = true;
      while (true) {
	if (s.empty() || tplf{"union_end_cond"}(s)) {
	  break;
	}
	if (is_first) {
	  is_first = false;
	} else {
	  if (!tplf{"union_sep_cond"}(s)) {
	    tplf{"union_end_skip"}(s);
	    break;
	  }
	}
	tplf{"source_type"} s0 = s;
	tplf{"union_field_name"}(s0, s);
	if (!tplf{"union_entry_sep_cond"}(s)) {
	  tplf{"union_end_skip"}(s);
	  break;
	}
	expand (fld, idx : m::field_names{t}) {
	  if (s0 == m::to_string{fld}) {
	    metafunction tv m::at{m::field_types{t}, idx};
	    mutable v = make_default{tv}();
	    deserialize{tpl, tv}(s, v);
	    r.fld = v;
	  }
	}
      }
    } else {
      tplf{"value_skip"}(s);
    }
  } else {
    m::apply{tplf{"unknown"}, t}(s);
  }
}

/* private */

private metafunction field_names_sorted{t}
  m::map{m::sort{m::fields{t}}, m::at0};
private metafunction field_types_sorted{t}
  m::map{m::sort{m::fields{t}}, m::at1};

