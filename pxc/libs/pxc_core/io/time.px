public threaded namespace io::time "use-unsafe";
public import numeric::integral -;
public import numeric::fp -;
public import numeric::cast -;
public import io +;

public tsvaluetype struct extern "std::time_t" "extint" time_t { }   //SLONG
public tsvaluetype struct extern "::suseconds_t" "extint" suseconds_t { }

public tsvaluetype struct extern "::timeval" timeval {
  public time_t tv_sec;
  public suseconds_t tv_usec;
}

public threaded function extern "pxcrt::gettimeofday" timeval
io_gettimeofday(io::io const& iop);
public threaded function extern "pxcrt::time" time_t
io_time(io::io const& iop);
public threaded function extern "pxcrt::io_sleep" uint
io_sleep(io const& iop, uint sec);
public threaded function extern "pxcrt::io_usleep" uint
io_usleep(io const& iop, uint usec);

public threaded function double
io_gettimeofday_double(io::io const& iop)
{
  timeval tv = iop.gettimeofday();
  double const rv = static_cast{double, time_t}(tv.tv_sec)
    + static_cast{double, suseconds_t}(tv.tv_usec) / 1000000.0;
  return rv;
}

private function extern "pxcrt::time_init" void time_init(); /* not mtsafe */

extern "functions" inline
#include <ctime>
#include <sys/time.h>
;

extern "implementation" inline
namespace pxcrt {
using namespace pxcrt;

::timeval gettimeofday(io const& iop)
{
  ::timeval tv = { };
  ::gettimeofday(&tv, 0); /* no need to check error */
  return tv;
}

std::time_t time(io const& iop)
{
  return std::time(0);
}

bt_uint io_sleep(io const& iop, bt_uint sec)
{
  return ::sleep(sec);
}

bt_uint io_usleep(io const& iop, bt_uint usec)
{
  return ::usleep(usec);
}

void time_init()
{
  /* not multi-thread safe */
  tzset();
}

}; // namespace pxcrt
;

