public threaded namespace operator;
public import numeric::integral -;
public import meta::family -;
public import exception -;
public import text::string::serialize -;
public import meta m;

/* public */

public threaded function {tx, ty}
binop_ret_type{tx, ty, "add", is_numeric_type}
add(tx const& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { return x + y; }
  else { return binop{tx, ty, "add"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "sub", is_numeric_type}
sub(tx const& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { return x - y; }
  else { return binop{tx, ty, "sub"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "mul", is_numeric_type}
mul(tx const& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { return x * y; }
  else { return binop{tx, ty, "mul"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "div", is_numeric_type}
div(tx const& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { return x / y; }
  else { return binop{tx, ty, "div"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "mod", is_numeric_type}
mod(tx const& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { return x % y; }
  else { return binop{tx, ty, "mod"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "or", is_boolean_type}
or(tx const& x, ty const& y)
{
  if (m::and{is_boolean_type{tx}, is_boolean_type{ty}}) { return x | y; }
  else { return binop{tx, ty, "or"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "and", is_boolean_type}
and(tx const& x, ty const& y)
{
  if (m::and{is_boolean_type{tx}, is_boolean_type{ty}}) { return x & y; }
  else { return binop{tx, ty, "and"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "xor", is_boolean_type}
xor(tx const& x, ty const& y)
{
  if (m::and{is_boolean_type{tx}, is_boolean_type{ty}}) { return x ^ y; }
  else { return binop{tx, ty, "xor"}(x, y); }
}

public threaded function {tx, ty} bool
eq(tx const& x, ty const& y)
{
  if (m::and{is_equality_type{tx}, is_equality_type{ty}}) { return x == y; }
  else { return binop{tx, ty, "eq"}(x, y); }
}

public threaded function {tx, ty} bool
ne(tx const& x, ty const& y)
{
  if (m::and{is_equality_type{tx}, is_equality_type{ty}}) { return x != y; }
  else { return binop{tx, ty, "ne"}(x, y); }
}

public threaded function {tx, ty} bool
gt(tx const& x, ty const& y)
{
  if (m::and{is_ordered_type{tx}, is_ordered_type{ty}}) { return x > y; }
  else { return binop{tx, ty, "gt"}(x, y); }
}

public threaded function {tx, ty} bool
lt(tx const& x, ty const& y)
{
  if (m::and{is_ordered_type{tx}, is_ordered_type{ty}}) { return x < y; }
  else { return binop{tx, ty, "lt"}(x, y); }
}

public threaded function {tx, ty} bool
ge(tx const& x, ty const& y)
{
  if (m::and{is_ordered_type{tx}, is_ordered_type{ty}}) { return x >= y; }
  else { return binop{tx, ty, "ge"}(x, y); }
}

public threaded function {tx, ty} bool
le(tx const& x, ty const& y)
{
  if (m::and{is_ordered_type{tx}, is_ordered_type{ty}}) { return x <= y; }
  else { return binop{tx, ty, "le"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "shiftl", is_integral_type}
shiftl(tx const& x, ty const& y)
{
  if (m::and{is_integral_type{tx}, is_integral_type{ty}}) { return x << y; }
  else { return binop{tx, ty, "shiftl"}(x, y); }
}

public threaded function {tx, ty}
binop_ret_type{tx, ty, "shiftl", is_integral_type}
shiftr(tx const& x, ty const& y)
{
  if (m::and{is_integral_type{tx}, is_integral_type{ty}}) { return x >> y; }
  else { return binop{tx, ty, "shiftr"}(x, y); }
}

public threaded function {tx, ty} void adda(tx mutable& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { x += y; }
  else { binopa{tx, ty, "add"}(x, y); }
}

public threaded function {tx, ty} void suba(tx mutable& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { x -= y; }
  else { binopa{tx, ty, "sub"}(x, y); }
}

public threaded function {tx, ty} void mula(tx mutable& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { x *= y; }
  else { binopa{tx, ty, "mul"}(x, y); }
}

public threaded function {tx, ty} void diva(tx mutable& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { x /= y; }
  else { binopa{tx, ty, "div"}(x, y); }
}

public threaded function {tx, ty} void moda(tx mutable& x, ty const& y)
{
  if (m::and{is_numeric_type{tx}, is_numeric_type{ty}}) { x %= y; }
  else { binopa{tx, ty, "mod"}(x, y); }
}

public threaded function {tx, ty} void ora(tx mutable& x, ty const& y)
{
  if (m::and{is_boolean_type{tx}, is_boolean_type{ty}}) { x |= y; }
  else { binopa{tx, ty, "or"}(x, y); }
}

public threaded function {tx, ty} void anda(tx mutable& x, ty const& y)
{
  if (m::and{is_boolean_type{tx}, is_boolean_type{ty}}) { x &= y; }
  else { binopa{tx, ty, "and"}(x, y); }
}

public threaded function {tx, ty} void xora(tx mutable& x, ty const& y)
{
  if (m::and{is_boolean_type{tx}, is_boolean_type{ty}}) { x ^= y; }
  else { binopa{tx, ty, "xor"}(x, y); }
}

public threaded function {tx, ty} void shiftla(tx mutable& x, ty const& y)
{
  if (m::and{is_integral_type{tx}, is_integral_type{ty}}) { x <<= y; }
  else { binopa{tx, ty, "shiftl"}(x, y); }
}

public threaded function {tx, ty} void shiftra(tx mutable& x, ty const& y)
{
  if (m::and{is_integral_type{tx}, is_integral_type{ty}}) { x >>= y; }
  else { binopa{tx, ty, "shiftr"}(x, y); }
}

public threaded function {tx} unaryop_ret_type{tx, "plus", is_numeric_type}
plus(tx const& x)
{
  if (is_numeric_type{tx}) { return x; }
  else { unaryop{tx, "plus", is_numeric_type}(x); }
}

public threaded function {tx} unaryop_ret_type{tx, "minus", is_numeric_type}
minus(tx const& x)
{
  if (is_numeric_type{tx}) { return -x; }
  else { unaryop{tx, "minus", is_numeric_type}(x); }
}

public threaded function {tx} unaryop_ret_type{tx, "neg", is_boolean_type}
neg(tx const& x)
{
  if (is_boolean_type{tx}) { return ~x; }
  else { unaryop{tx, "neg", is_boolean_type}(x); }
}

public threaded function {tx} unaryop_ret_type{tx, "not", is_boolean_type}
not(tx const& x)
{
  if (is_boolean_type{tx}) { return !x; }
  else { unaryop{tx, "not", is_boolean_type}(x); }
}

public threaded function {tx, ty} mapped_type{tx}
getelem(tx const& x, ty const& y)
{
  if (is_container_or_range_type{tx}) { return x[y]; }
  else { return x.__getelem(y); }
}

public threaded function {tx, ty, tz} void
setelem(tx mutable& x, ty const& y, tz const& z)
{
  if (is_container_or_range_type{tx}) { x[y] = z; }
  else { x.__setelem(y, z); }
}

public threaded function {tx, ty}
m::ret_type{m::symbol{m::nsof{tx}, m::concat{tx, "___getfld"}}}
getfld(tx const& x, ty const& y)
{
  return m::symbol{m::nsof{tx}, m::concat{tx, "___getfld"}}(x, y);
}

public threaded function {tx, ty, tz} void
setfld(tx mutable& x, ty const& y, tz const& z)
{
  m::symbol{m::nsof{tx}, m::concat{tx, "___setfld"}}(x, y, z);
}

public threaded function {fld, t}
m::field_type{t, fld}
union_field(t const& x)
{
  expand (sym: {fld}) {
    if (!case x.sym) {
      expand (fsym, idx: m::field_names{t}) {
	if (m::ne{m::to_string{sym}, m::to_string{fsym}}) {
	  if (case x.fsym) {
	    throw exception::unexpected_value_template{
	      m::to_string{m::field_type{t, fsym}}}(to_string(x.fsym));
	  }
	}
      }
    }
    return x.sym;
  }
}

public metafunction implicit_conversion{tto, tfrom}
  m::cond{ /* conversion function defined in the tfrom ns? */
    m::eq{
      m::to_string{
	m::symbol{m::nsof{tfrom}, conv_funcname_nons{tto, tfrom}}},
      conv_funcname_nons{tto, tfrom}},
    implicit_conversion_ns{tto, tfrom, 0},
    m::cond{ /* conversion function defined in th tto ns? */
      m::eq{
	m::to_string{
	  m::symbol{m::nsof{tto}, conv_funcname_nons{tto, tfrom}}},
	conv_funcname_nons{tto, tfrom}},
      implicit_conversion_ns{tto, tfrom, 1},
      0}};

/* private */

private metafunction mapped_type{t}
  m::cond{
    is_container_or_range_type{t},
    m::symbol{t, "mapped_type"},
    has_symbol{t, "__getelem"},
    m::ret_type{m::symbol{t, "__getelem"}},
    m::ret_type{m::symbol{m::nsof{t},
      m::concat{m::to_string{t}, "___getelem"}}}};

private metafunction has_symbol{t, name} m::symbol_exists{t, name};
private metafunction has_gsymbol{t, name} m::symbol_exists{m::nsof{t}, name};

private metafunction binop_ret_type{tx, ty, opstr, is_builtin}
  m::cond{
    m::and{m::ne{is_builtin, 0}, is_builtin{tx}, is_builtin{ty}},
    tx,
  m::cond{
    has_symbol{tx, m::concat{"__", opstr}},
    m::ret_type{m::symbol{tx, m::concat{"__", opstr}}},
  m::cond{
    has_symbol{tx, m::concat{"__", opstr, "a"}},
    tx,
  m::cond{
    has_gsymbol{tx, m::concat{tx, "___", opstr}},
    m::ret_type{m::apply{
      m::symbol{m::nsof{tx}, m::concat{tx, "___", opstr}}, tx, ty}},
  m::cond{
    has_gsymbol{tx, m::concat{tx, "___", opstr, "a"}},
    tx,
  tx}}}}};

private threaded function {tx, ty, opstr} binop_ret_type{tx, ty, opstr, 0}
binop(tx const& x, ty const& y)
{
  metafunction opstr_bin m::concat{"__", opstr};
  metafunction op_bin m::symbol{tx, opstr_bin};
  metafunction opstr_assign m::concat{"__", opstr, "a"};
  metafunction op_assign m::symbol{tx, opstr_assign};
  metafunction fstr_bin m::concat{tx, "___", opstr};
  metafunction f_bin m::symbol{m::nsof{tx}, fstr_bin};
  metafunction fstr_assign m::concat{tx, "___", opstr, "a"};
  metafunction f_assign m::symbol{m::nsof{tx}, fstr_assign};
  if (m::ne{op_bin, 0}) {
    /* return foo.__add(x, y); */
    // m::error{m::concat{"opbin", tx, ty, opstr}};
    expand(sym: m::list{opstr_bin}) { return x.sym(y); }
  } else if (m::ne{op_assign, 0}) {
    /* r = x; foo.__adda(r, y); return x; */
    // m::error{m::concat{"opassign", tx, ty, opstr}};
    tx r = x; expand(sym: m::list{opstr_assign}) { r.sym(y); } return r;
  } else if (m::ne{f_bin, 0}) {
    /* return foo___add(x, y); */
    // m::error{m::concat{"fbin", tx, ty, opstr}};
    return f_bin{tx, ty}(x, y);
  } else if (m::ne{f_assign, 0}) {
    /* r = x; foo___adda(r, y); return r; */
    // m::error{m::concat{"fassign", tx, ty, opstr}};
    tx r = x;
    f_assign{tx, ty}(r, y);
    return r;
  } else if (m::and{is_struct_type{tx},
    m::not{m::empty{m::field_names{tx}}}}) {
    /* apply binop for each field, and construct a value of type tx */
    // m::error{m::concat{"struct", tx, ty, opstr}};
    metafunction op m::symbol{"operator", opstr};
    return tx(expand(fld: m::field_names{tx}; op(x.fld, y.fld)));
  } else {
    return m::error{m::concat{"operator ", opstr, " not defined"}};
  }
}

private threaded function {tx, ty, opstr} void
binopa(tx mutable& x, ty const& y)
{
  metafunction opstr_bin m::concat{"__", opstr};
  metafunction op_bin m::symbol{tx, opstr_bin};
  metafunction opstr_assign m::concat{"__", opstr, "a"};
  metafunction op_assign m::symbol{tx, opstr_assign};
  metafunction fstr_bin m::concat{tx, "___", opstr};
  metafunction f_bin m::symbol{m::nsof{tx}, fstr_bin};
  metafunction fstr_assign m::concat{tx, "___", opstr, "a"};
  metafunction f_assign m::symbol{m::nsof{tx}, fstr_assign};
  if (m::ne{op_bin, 0}) {
    /* x = foo.__add(x, y); */
    expand(sym: m::list{op_bin}) { x = x.sym(y); }
  } else if (m::ne{op_assign, 0}) {
    /* foo.__adda(x, y); */
    expand(sym: m::list{opstr_assign}) { x.sym(y); }
  } else if (m::ne{f_bin, 0}) {
    /* x = foo___add(x, y); */
    x = f_bin{tx, ty}(x, y);
  } else if (m::ne{f_assign, 0}) {
    /* foo___adda(x, y); */
    f_assign{tx, ty}(x, y);
  } else if (m::and{is_struct_type{tx}, m::eq{tx, ty},
    m::not{m::empty{m::field_names{tx}}}}) {
    /* apply binop for each field */
    metafunction op m::symbol{"operator", m::concat{opstr, "a"}};
    expand(fld: m::field_names{tx}; op(x.fld, y.fld));
  } else {
    return m::error{m::concat{"operator ", opstr, " not defined"}};
  }
}

private metafunction unaryop_ret_type{tx, opstr, is_builtin}
  m::cond{
    m::and{m::ne{is_builtin, 0}, is_builtin{tx}},
    tx,
  m::cond{
    has_symbol{tx, m::concat{"__", opstr}},
    m::ret_type{m::symbol{tx, m::concat{"__", opstr}}},
  m::cond{
    has_gsymbol{tx, m::concat{tx, "___", opstr}},
    m::ret_type{m::apply{
      m::symbol{m::nsof{tx}, m::concat{tx, "___", opstr}}, tx}},
  tx}}};

private threaded function {tx, opstr, is_builtin}
unaryop_ret_type{tx, opstr, is_builtin}
unaryop(tx const& x)
{
  metafunction opstr_u m::concat{"__", opstr};
  metafunction op_u m::symbol{tx, opstr_u};
  metafunction fstr_u m::concat{tx, "___", opstr};
  metafunction f_u m::symbol{m::nsof{tx}, fstr_u};
  if (m::eq{m::to_string{op_u}, opstr_u}) {
    /* return foo.__plus(x); */
    expand(sym: m::list{opstr_u}) { return x.sym(); }
  } else if (m::eq{m::to_string{f_u}, fstr_u}) {
    /* return foo___plus(x); */
    return f_u{tx}(x);
  } else if (is_struct_type{tx}) {
    /* apply unaryop for each field, and construct a value of type tx */
    metafunction op m::symbol{"operator", opstr};
    return tx(expand(fld: m::field_names{tx}; op(x.fld)));
  } else {
    return m::error{m::concat{"operator ", opstr, " not defined"}};
  }
}

private metafunction conv_funcname_nons{tto, tfrom}
  m::concat{m::to_string{tfrom}, "___to"};

private metafunction implicit_conversion_ns{tto, tfrom, tons}
  m::apply{
    m::symbol{
      m::nsof{m::cond{tons, tto, tfrom}},
      conv_funcname_nons{tto, tfrom}},
    tto,
    tfrom};

