public threaded namespace thread "use-unsafe";
public import numeric::integral -;
public import operator -;
public import pointer -;
public import io::errno -;
public import algebraic -;
public import meta m;
public import exception -;
public import callable -;
public import text::string::serialize -;

public threaded function {f} callable_ptr{m::ret_type{f}, m::nil}
make_thread_ptr(expand(m::args{f}))
{
  return callable_ptr{m::ret_type{f}, m::nil}(
    make_ptr{thread{f}}(expand(a: m::arg_names{f}; a)));
    /* arg types of f must be multithreaded, or an error is raised here. */
}

public threaded struct {f}
thread(expand(m::args{f}))
  <callable{m::ret_type{f}, m::nil}>
{
  private metafunction tfuncobj thread_main_funcobj{f};
  private tfuncobj mutable fobj = tfuncobj(expand(a: m::arg_names{f}; a));
  private bool need_join = false;
  private thread_id thd;
  init();
  private function void init() {
    const err = thread_create{tfuncobj}(thd, fobj);
    if (err != EOK) {
      throw runtime_error_template{"thread_create"}(to_string(err));
    }
    need_join = true;
  }
  public function ~ {
    __call();
  }
  public function m::ret_type{f} __call() {
    if (need_join) {
      need_join = false;
      const err = thread_join{tfuncobj}(thd);
      if (err != EOK) {
	throw runtime_error_template{"thread_join"}(to_string(err));
      }
    }
    if (m::ne{m::ret_type{f}, void}) {
      return fobj.ret.some;
    }
  }
}

private multithreaded struct {f}
thread_main_funcobj(expand(m::args{f}))
{
  private metafunction tfld tuple{m::arg_types{f}, m::nil};
  private metafunction tret
    m::cond{m::eq{m::ret_type{f}, void}, unit, option{m::ret_type{f}}};
  public tfld const fld = tfld(expand(a: m::arg_names{f}; a));
    /* arg types of f must be multithreaded, or an error is raised here. */
  public tret mutable ret;
  public function void __call() {
    if (m::eq{m::ret_type{f}, void}) {
      f(expand(f: m::field_names{tfld}; fld.f));
    } else {
      ret.some = f(expand(f: m::field_names{tfld}; fld.f));
    }
  }
}

private threaded struct extern "pxcrt::thread_id" "nonmovable" thread_id { }

private threaded function extern "pxcrt::thread_create" {tfuncobj} errno_t
thread_create(thread_id mutable& thd, tfuncobj mutable& funcobj);
private threaded function extern "pxcrt::thread_join" {tfuncobj} errno_t
thread_join(thread_id mutable& thd);

extern "types" inline

#include <pthread.h>

namespace pxcrt {

typedef pthread_t thread_id;

};

;

extern "functions" inline

namespace pxcrt {

template <typename Tfuncobj> static inline void *
funcobj_wrap(void *arg)
{
  Tfuncobj *const a = static_cast<Tfuncobj *>(arg);
  a->__call$f();
  return 0;
}

template <typename Tfuncobj> int
thread_create(thread_id& thd, Tfuncobj& funcobj)
{
  return pthread_create(&thd, 0, &funcobj_wrap<Tfuncobj>, &funcobj);
}

template <typename Tfuncobj> int
thread_join(thread_id& thd)
{
  return pthread_join(thd, 0);
}

};

;

