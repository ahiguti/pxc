public threaded namespace thread "use-unsafe";
public import numeric::integral -;
public import pointer -;
public import container::array;
public import exception;
public import meta -;
public import meta m;
public import operator -;
public import callable -;

/* public */

public threaded function {f} tcallable_ptr{func_ret{f}, m::nil}
make_thread_func(expand(m::args{f}))
{
  if (m::eq{func_ret{f}, void}) {
    return tcallable_ptr{func_ret{f}, m::nil}(
      make_tcptr(uneval_thread_void{f}(
	make_tptr(make_tuple(expand(a : m::map{m::args{f}, m::at0}; a))))));
  } else {
    return tcallable_ptr{func_ret{f}, m::nil}(
      make_tcptr(uneval_thread_nonvoid{f}(
	make_tptr(make_tuple(expand(a : m::map{m::args{f}, m::at0}; a))))));
  }
}

/* private */

private metafunction func_arg{f} tuple{m::arg_types{f}, m::nil};
private metafunction func_ret{f} m::ret_type{f};

private multithreaded struct {f}
uneval_thread_params_nonvoid(tptr{func_arg{f}} const& a,
  tptr{func_ret{f}} const& r)
{
  private tptr{func_arg{f}} argp = a;
  private tptr{func_ret{f}} retp = r;
  public function void main() {
    func_arg{f} const& arg = *argp;
    *retp = f(expand(a: m::field_names{func_arg{f}}; arg.a));
  }
}

private multithreaded struct {f}
uneval_thread_params_void(tptr{func_arg{f}} const& a)
{
  private tptr{func_arg{f}} argp = a;
  public function void main() {
    func_arg{f} const& arg = *argp;
    f(expand(a: m::field_names{func_arg{f}}; arg.a));
  }
}

private multithreaded struct {f}
uneval_thread_nonvoid(tptr{func_arg{f}} const& a)
  <tcallable{func_ret{f}, m::nil}>
{
  private tptr{func_ret{f}} retp = make_tptr{func_ret{f}}();
  private thread thr =
    make_thread_internal(uneval_thread_params_nonvoid{f}(a, retp));
  public function func_ret{f} __call() const {
    thr.join();
    return *retp;
  }
}

private multithreaded struct {f}
uneval_thread_void(tptr{func_arg{f}} const& a)
  <tcallable{void, m::nil}>
{
  private thread thr = make_thread_internal(uneval_thread_params_void{f}(a));
  public function void __call() const {
    thr.join();
  }
}

private multithreaded struct extern "pxcrt::thread_ptr" "nodefault"
thread { }

private threaded function {targs}
thread make_thread_internal(targs const& args)
{
  tptr{thrdata} r = make_tptr{thrdata_impl{targs}}(thrdata_impl{targs}(args));
  return make_thread_impl(r);
}

private threaded function extern "pxcrt::thread_join"
  void thread_join(thread const& thr);

private multithreaded interface thrdata {
  function void main();
}
private multithreaded struct {targs} thrdata_impl(targs const& a)
  <thrdata>
{
  targs args = a;
  function void main() {
    args.main();
  }
}
private threaded function extern "pxcrt::make_thread_impl"
  thread make_thread_impl(tptr{thrdata} const& f);

extern "types" inline

namespace pxcrt {

struct thread_rep;

typedef pxcrt::rcptr< pxcrt::trcval<thread_rep> > thread_ptr;
};

;

extern "functions" inline

namespace pxcrt {

typedef pxcrt::rcptr< thread$n::thrdata$i > thrdata_ptr;
typedef thread$n::thrdata$i *thrdata_rawptr;

struct thread_rep {
  thread_rep(thrdata_ptr const& m) : tid(), need_join(false), mptr(m) { }
  ~thread_rep() { join(); }
  void join();
  pthread_t tid;
  bool need_join;
  thrdata_ptr mptr;
private:
  thread_rep(const thread_rep&);
  thread_rep& operator =(const thread_rep&);
};

thread_ptr make_thread_impl(thrdata_ptr const& m);
void thread_join(thread_ptr const& t);

};

;

extern "implementation" inline

#define PXC_THREAD_DBG(x)

namespace pxcrt {

void *pxc_thread_child_main(void *arg)
{
  thrdata_rawptr m = static_cast<thrdata_rawptr>(arg);
    /* no need to lock m */
  PXC_TRY {
    PXC_TRY {
      m->main$f();
    } PXC_CATCH(const std::exception& ex) {
      #if !PXC_NOEXCEPTIONS
      pxcrt::c_exception_log_stderr(ex);
      #endif
    }
  } PXC_CATCH(...) {
    const char *const mess = "PXCTHREAD: Uncaught exception\n";
    ::write(2, mess, strlen(mess));
  }
  pxcrt::clear_local_pool();
  return 0;
}

thread_ptr make_thread_impl(thrdata_ptr const& m)
{
  thread_ptr thr(thread_ptr::make_rawptr(m));
  thread_rep& impl = thr->value;
  if (pthread_create(&impl.tid, 0, pxc_thread_child_main, m.get()) != 0) {
    PXC_THREAD_DBG(fprintf(stderr, "failed to create thread\n"));
  } else {
    PXC_THREAD_DBG(fprintf(stderr, "thread create\n"));
    impl.need_join = true;
  }
  return thr;
}

void thread_join(thread_ptr const& t)
{
  if (t.get() == 0) {
    return;
  }
  thread_ptr::guard_val<thread_ptr> grd(t);
  grd.get()->value.join();
}

void thread_rep::join()
{
  if (!need_join) {
    PXC_THREAD_DBG(fprintf(stderr, "no need to join\n"));
    return;
  }
  if (tid == pthread_self()) {
    PXC_THREAD_DBG(fprintf(stderr, "detach\n"));
    __attribute__((unused)) const int e = pthread_detach(tid);
    assert(e == 0);
  } else {
    PXC_THREAD_DBG(fprintf(stderr, "join\n"));
    __attribute__((unused)) const int e = pthread_join(tid, 0);
    assert(e == 0);
  }
  need_join = false;
}

};

#undef PXC_THREAD_DBG

;

