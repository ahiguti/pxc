public threaded namespace algebraic;
public import numeric::integral -;
public import meta -;
public import meta m;
public import meta::vararg va;

public tsvaluetype struct {types, ord}
tuple(expand(
  m::map{
    m::seq{m::size{types}},
    metafunction{i} m::list{m::concat{"a", i}, m::at{types, i}, 1, 0}}))
{
  public metafunction __static_assert__
    m::fold{ord, metafunction{r, x} m::and{r, m::is_int{x}}, 1};
    /* ord must be a list of int */
  public metafunction __attribute__ {{"__order__", ord}};
  expand (s, idx:
    m::map{m::seq{m::size{types}}, metafunction{i} m::concat{"_", i}})
  {
    expand (a: m::list{m::concat{"a", idx}}) {
      public m::at{types, idx} s = a;
    }
  }
}

public tsvaluetype union {types}
sumtype
{
  expand (s, i: va::field_names{m::size{types}}) {
    public m::at{types, i} s;
  }
}

public tsvaluetype struct {t0, t1}
pair(t0 const& a0, t1 const& a1)
{
  public t0 first = a0;
  public t1 second = a1;
}

public tsvaluetype union {t0, t1}
either
{
  public t0 first;
  public t1 second;
}

public tsvaluetype union {t}
option
{
  public unit none;
  public t some;
}

public threaded function {tlist} tuple{m::map{tlist, m::at0}, m::nil}
make_tuple(expand(va::arg_decls_bycref{tlist}))
{
  metafunction typ tuple{m::map{tlist, m::at0}, m::nil};
  return typ(expand(a: va::arg_names{m::size{tlist}}; a));
}

