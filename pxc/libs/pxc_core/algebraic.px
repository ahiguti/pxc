threaded namespace algebraic;
public import numeric::integral -;
public import meta -;
public import meta m;
public import meta::vararg va;

public tsvaluetype struct {types}
tuple(expand(
  m::map{
    m::seq{m::size{types}},
    metafunction{i} m::list{m::concat{"a", i}, m::at{types, i}, 1, 0}}))
{
  expand (s, idx:
    m::map{m::seq{m::size{types}}, metafunction{i} m::concat{"_", i}})
  {
    expand (a: m::list{m::concat{"a", idx}}) {
      m::at{types, idx} s = a;
    }
  }
}

public tsvaluetype union {types}
sumtype
{
  expand (s, i: va::field_names{m::size{types}}) {
    m::at{types, i} s;
  }
}

public tsvaluetype struct {t0, t1}
pair(t0 const& a0, t1 const& a1)
{
  t0 first = a0;
  t1 second = a1;
}

public tsvaluetype union {t0, t1}
either
{
  t0 first;
  t1 second;
}

public tsvaluetype union {t}
option
{
  unit none;
  t some;
}

public threaded function {tlist} tuple{m::map{tlist, m::at0}}
make_tuple(expand(va::arg_decls_bycref{tlist}))
{
  metafunction typ tuple{m::map{tlist, m::at0}};
  return typ(expand(a: va::arg_names{m::size{tlist}}; a));
}

