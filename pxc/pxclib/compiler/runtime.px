namespace compiler::runtime;

public mtvaluetype extern "pxcrt::invalid_index" ""
  struct invalid_index { }
public mtvaluetype extern "pxcrt::invalid_field" ""
  struct invalid_field { }
public mtvaluetype extern "pxcrt::null_dereference" ""
  struct null_dereference { }
public mtvaluetype extern "pxcrt::would_invalidate" ""
  struct would_invalidate { }

public extern "@0void" "@0void" struct void { }
public extern "@0bool" "@0bool" struct bool { }
public extern "@0char" "@0char" struct char { }
public extern "@0uchar" "@0uchar" struct uchar { }
public extern "@0size_t" "@0size_t" struct size_t { }
public tsvaluetype extern "pxcrt::slice" "slice"
struct {t} slice {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type slice{t};
  public macro crange_type cslice{t};
  public extern "empty" function bool empty() const;
  public extern "size" function size_t size() const;
  public extern "next" function void next();
}
public tsvaluetype extern "pxcrt::cslice" "cslice"
struct {t} cslice {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type cslice{t};
  public macro crange_type cslice{t};
  public extern "empty" function bool empty() const;
  public extern "size" function size_t size() const;
  public extern "next" function void next();
}
public mtvaluetype extern "pxcrt::bt_string" "varray"
struct bt_string {
  public macro key_type size_t;
  public macro mapped_type uchar;
  public macro range_type slice{char};
  public macro crange_type cslice{char};
  public extern "empty" function bool empty() const;
  public extern "size" function size_t size() const;
  public extern "resize" function void resize(size_t i, char const& v);
  public extern "clear" function void clear();
  public extern "push_back" function void push_back(char const& v);
  public extern "pop_back" function uchar pop_back();
  public extern "reserve" function void reserve(size_t i);
  public extern "append" function void append(crange_type const& v);
}

extern "type" inline
#include <stdexcept>
#include <vector>
#include <string.h>
#include <stdint.h>
namespace pxcrt {
struct bt_unit { };
extern const bt_unit unit_value;
typedef bool bt_bool;
typedef ::uint8_t bt_uchar;
// typedef ::int8_t bt_char;
typedef char bt_char;
typedef ::uint16_t bt_ushort;
typedef ::int16_t bt_short;
typedef ::uint32_t bt_uint;
typedef ::int32_t bt_int;
typedef ::uint64_t bt_ulong;
typedef ::int64_t bt_long;
typedef ::size_t bt_size_t;
typedef float bt_float;
typedef double bt_double;
struct bt_tpdummy;
void throw_invalid_index() __attribute__((noreturn));
void throw_null_dereference() __attribute__((noreturn));
void throw_invalid_field() __attribute__((noreturn));
void throw_would_invalidate() __attribute__((noreturn));
void throw_virtual_function_call() __attribute__((noreturn));
int main_nothrow(void (*main_f)(void));
template <typename Tc>
struct refvar_igrd_nn {
  refvar_igrd_nn(Tc& c) : c(c) {
    c.inc_invalidate_guard();
  }
  ~refvar_igrd_nn() {
    c.dec_invalidate_guard();
  }
  Tc& get() {
    return c;
  }
  typename Tc::range_type get_range()
    { return typename Tc::range_type(c); }
  typename Tc::crange_type get_crange()
    { return typename Tc::crange_type(c); }
private:
  Tc& c;
  refvar_igrd_nn(const refvar_igrd_nn&);
  refvar_igrd_nn& operator =(const refvar_igrd_nn&);
};
template <typename Tc>
struct valvar_igrd_nn {
  valvar_igrd_nn(const Tc& x) : c(x) {
    c.inc_invalidate_guard();
  }
  ~valvar_igrd_nn() {
    c.dec_invalidate_guard();
  }
  Tc& get() {
    return c;
  }
  typename Tc::range_type get_range()
    { return typename Tc::range_type(c); }
  typename Tc::crange_type get_crange()
    { return typename Tc::crange_type(c); }
private:
  Tc c;
  valvar_igrd_nn(const valvar_igrd_nn&);
  valvar_igrd_nn& operator =(const valvar_igrd_nn&);
};
template <typename T>
struct slice {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  slice() : v(0), len(0) { }
  slice(T *ptr, bt_size_t o) : v(ptr), len(o) { }
  template <typename Tc> slice(Tc& c) : v(c.rawarr()), len(c.size()) { }
  template <typename Tc> slice(Tc& c, bt_size_t o1, bt_size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  bt_size_t size() const { return len; }
  void next() {
    if (len == 0) { pxcrt::throw_invalid_index(); }
    ++v;
    --len;
  }
  T& operator [](bt_size_t idx) const {
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  T& operator *() const {
    if (len == 0) { pxcrt::throw_invalid_index(); }
    return *v;
  }
  T *rawarr() const { return v; }
private:
  T *v;
  bt_size_t len;
};
template <typename T>
struct cslice {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  cslice() : v(0), len(0) { }
  cslice(const T *ptr, bt_size_t o) : v(ptr), len(o) { }
  template <typename Tc> cslice(const Tc& c) : v(c.rawarr()), len(c.size()) { }
  template <typename Tc> cslice(const Tc& c, bt_size_t o1, bt_size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  bt_size_t size() const { return len; }
  void next() {
    if (len == 0) { pxcrt::throw_invalid_index(); }
    ++v;
    --len;
  }
  const T& operator [](bt_size_t idx) const {
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  const T& operator *() const {
    if (len == 0) { pxcrt::throw_invalid_index(); }
    return *v;
  }
  const T *rawarr() const { return v; }
private:
  const T *v;
  bt_size_t len;
};
template <typename T>
struct stdvector {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  typedef typename std::vector<T>::size_type size_type;
  typedef typename std::vector<T>::iterator iterator;
  typedef typename std::vector<T>::const_iterator const_iterator;
  typedef slice<T> range_type;
  typedef cslice<T> crange_type;
  stdvector() : invalidate_guard_count(0) { }
  // stdvector(size_t len) : v(len), invalidate_guard_count(0) { }
  stdvector(const stdvector& x) : v(x.v), invalidate_guard_count(0) { }
  stdvector(const T *start, const T *end) : v(start, end) { }
    // added
  stdvector(const char *str) : v(str, str + strlen(str)) { }
    // added
  stdvector& operator =(const stdvector& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  bool operator ==(const stdvector& x) const { return v == x.v; }
  bool operator !=(const stdvector& x) const { return v != x.v; }
  bool operator <(const stdvector& x) const { return v < x.v; }
  bool operator >(const stdvector& x) const { return v > x.v; }
  bool operator <=(const stdvector& x) const { return v <= x.v; }
  bool operator >=(const stdvector& x) const { return v >= x.v; }
  bool empty() const { return v.empty(); }
  size_type size() const { return v.size(); }
  T& operator [](size_type idx) {
    if (idx >= v.size()) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= v.size()) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  void resize(size_type sz, T const& x) {
    check_resize();
    v.resize(sz, x);
  }
  void clear() {
    check_resize();
    v.clear();
  }
  void push_back(T const& x) {
    check_resize();
    v.push_back(x);
  }
  T pop_back() {
    check_resize();
    if (v.empty()) { pxcrt::throw_invalid_index(); }
    const T r = v.back();
    v.pop_back();
    return r;
  }
  void append(const crange_type& x) {
    v.insert(v.end(), x.rawarr(), x.rawarr() + x.size());
  }
  void append(const const_iterator& start, const const_iterator& finish) {
    v.insert(v.end(), start, finish);
  }
  void prepend(const const_iterator& start, const const_iterator& finish) {
    v.insert(v.begin(), start, finish);
  }
  void reserve(size_type sz) {
    check_resize();
    v.reserve(sz);
  }
  iterator begin() { return v.begin(); }
  const_iterator begin() const { return v.begin(); }
  iterator end() { return v.end(); }
  const_iterator end() const { return v.end(); }
  T *data() { return &v[0]; } // added
  const T *data() const { return &v[0]; } // added
  T *rawarr() { return &v[0]; }
  const T *rawarr() const { return &v[0]; }
private:
  void check_resize() {
    if (invalidate_guard_count != 0) { pxcrt::throw_would_invalidate(); }
  }
  void inc_invalidate_guard() const {
    ++invalidate_guard_count;
  }
  void dec_invalidate_guard() const {
    --invalidate_guard_count;
  }
private:
  std::vector<T> v;
  mutable size_type invalidate_guard_count;
};
template<typename T>
inline bool operator ==(const stdvector<T>& x, const stdvector<T>& y)
  { return x.v == y.v; }
template<typename T>
inline bool operator <(const stdvector<T>& x, const stdvector<T>& y)
  { return x.v < y.v; }
typedef stdvector<char> bt_string;
struct invalid_index : public std::logic_error { invalid_index(); };
struct invalid_field : public std::logic_error { invalid_field(); };
struct null_dereference : public std::logic_error { null_dereference(); };
struct would_invalidate : public std::logic_error { would_invalidate(); };
struct virtual_function_call : public std::logic_error
  { virtual_function_call(); };
}; // namespace pxcrt

extern "fdef" inline
#include <string>
#include <unistd.h>
namespace pxcrt {
invalid_index::invalid_index() : std::logic_error("invalid_index") { }
invalid_field::invalid_field() : std::logic_error("invalid_field") { }
null_dereference::null_dereference() : std::logic_error("null_dereference") { }
would_invalidate::would_invalidate() : std::logic_error("would_invalidate") { }
virtual_function_call::virtual_function_call()
  : std::logic_error("virtual_function_call") { }
void throw_invalid_index() { throw invalid_index(); }
void throw_invalid_field() { throw invalid_field(); }
void throw_null_dereference() { throw null_dereference(); }
void throw_would_invalidate() { throw would_invalidate(); }
void throw_virtual_function_call() { throw virtual_function_call(); }
int main_nothrow(void (*main_f)(void))
{
  try {
    (*main_f)();
  } catch (const std::exception& e) {
    std::string mess(e.what());
    if (!mess.empty() && mess[mess.size() - 1] != '\n') {
      mess += "\n";
    }
    ::write(2, mess.data(), mess.size());
    return 1;
  } catch (...) {
    const std::string mess = "unknown exception\n";
    ::write(2, mess.data(), mess.size());
    return 1;
  }
  return 0;
}
}; // namespace pxcrt

