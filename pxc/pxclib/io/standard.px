namespace io::standard;
public import numeric::integral -;
public import container::string -;
public import io -;
public import io::file -;
public import io::errno -;
public import string::conversion;
public import string::split -;
public import meta::common m;
public import meta::vararg v;
public import exception::common -;
public import algebraic -;

public threaded function extern "pxcio::get_stdin"
  file get_stdin(io const& iop);
public threaded function extern "pxcio::get_stdout"
  file get_stdout(io const& iop);
public threaded function extern "pxcio::get_stderr"
  file get_stderr(io const& iop);

public threaded function {t} void file_print(file const& f, t const& x)
{
  size_t wlen;
  if (is_string_family_type{t}) {
    file_write_all(f, x, wlen);
  } else {
    file_write_all(f, string::conversion::to_string(x), wlen);
  }
}

public threaded function {t} void file_println(file const& f, t const& x)
{
  size_t wlen;
  if (is_string_family_type{t}) {
    string s = x;
    s.append("\n");
    file_write_all(f, s, wlen);
  } else {
    string s = string::conversion::to_string(x);
    s.append("\n");
    file_write_all(f, s, wlen);
  }
}

/*
private function {delim, tlist} string
join_string(expand(v::arg_decls_bycref{tlist}))
{
  string s;
  expand (a, i: v::arg_names{m::size{tlist}}) {
    {
      metafunction t m::at0{m::at{tlist, i}};
      if (m::and{m::ne{i, 0}, m::ne{delim, ""}}) {
	s.append(delim);
      }
      if (is_string_family_type{t}) {
	s.append(a);
      } else {
	string::conversion::serialize_to_string{t}(a, s);
      }
    }
  }
  return s;
}
*/

public function {tlist} void print(expand(v::arg_decls_bycref{tlist}))
{
  string s = string_join{"\t"}(
    expand(a: v::arg_names{m::size{tlist}}; a));
  size_t len;
  file_write_all(get_stdout(io::system), s, len);
}

public function {tlist} void println(expand(v::arg_decls_bycref{tlist}))
{
  string s = string_join{"\t"}(
    expand(a: v::arg_names{m::size{tlist}}; a));
  s.append("\n");
  size_t len;
  file_write_all(get_stdout(io::system), s, len);
}

private extern "pxcio::stdin"  option{file} stdin;
private extern "pxcio::stdout" option{file} stdout;
private extern "pxcio::stderr" option{file} stderr;

private function extern "pxcio::iostd_init" void iostd_init();

iostd_init();

extern "implementation" inline
namespace pxcio {

typedef ::algebraic$n::option$v$p$io$$file$n$$file$s$r$ optfile;

/* these values are immutable after initialized, and multi-thread safe. */
optfile pxc_stdin;
optfile pxc_stdout;
optfile pxc_stderr;

file get_stdin(io const& iop)  { return pxc_stdin.some$$r(); }
file get_stdout(io const& iop) { return pxc_stdout.some$$r(); }
file get_stderr(io const& iop) { return pxc_stderr.some$$r(); }

void iostd_init()
{
  static int init_flag = 0;
  if (!init_flag) {
    init_flag = 1;
    pxc_stdin .some$$l(create_file(0));
    pxc_stdout.some$$l(create_file(1));
    pxc_stderr.some$$l(create_file(2));
  }
}

};
;

