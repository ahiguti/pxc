namespace io::file;
public import type::builtin "";
public import type::array "";
public import io "";
public import io::errno "";
public import compiler::util "";
public import meta::builtin m;

public multithreaded extern "pxcio::file_impl" "linear"
  struct file(ioptr const& iop, cstrref const& fn, open_flags_t flags,
    mode_t mode, errno_t& err_r) { }
public macro fileptr tptr{file};

public tsvaluetype extern "::off_t" "int" struct off_t { }         // SQUAD?
public tsvaluetype extern "::dev_t" "uint" struct dev_t { }        // UQUAD
public tsvaluetype extern "::ino_t" "uint" struct ino_t { }        // ULONGWORD
public tsvaluetype extern "::mode_t " "bitmask" struct mode_t { }  // U32
public tsvaluetype extern "::nlink_t" "uint" struct nlink_t { }    // UWORD
public tsvaluetype extern "::uid_t" "uint" struct uid_t { }        // U32
public tsvaluetype extern "::gid_t" "uint" struct gid_t { }        // U32
public tsvaluetype extern "::blksize_t" "int" struct blksize_t { } // SLONGWORD
public tsvaluetype extern "::blkcnt_t" "int" struct blkcnt_t { }   // SQUAD?
public tsvaluetype extern "::time_t" "int" struct time_t { }       // SLONG
public tsvaluetype extern "::ssize_t" "int" struct ssize_t { }     // SWORD?

public tsvaluetype extern "int" "bitmask" struct open_flags_t { }
public tsvaluetype extern "int" "enum" struct whence_t { }

public tsvaluetype extern "pxcio::statbuf" struct statbuf {
  dev_t st_dev;
  ino_t st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  off_t st_size;
  blksize_t st_blksize;
  blkcnt_t st_blocks;
  time_t st_atime;
  time_t st_mtime;
  time_t st_ctime;
}

public extern "O_RDONLY"	open_flags_t O_RDONLY;
public extern "O_WRONLY"	open_flags_t O_WRONLY;
public extern "O_RDWR"		open_flags_t O_RDWR;
public extern "O_CREAT"		open_flags_t O_CREAT;
public extern "O_EXCL"		open_flags_t O_EXCL;
public extern "O_TRUNC"		open_flags_t O_TRUNC;
public extern "O_APPEND"	open_flags_t O_APPEND;
public extern "O_NONBLOCK"	open_flags_t O_NONBLOCK;
public extern "O_SYNC"		open_flags_t O_SYNC;
public extern "O_FSYNC"		open_flags_t O_FSYNC;
public extern "O_ASYNC"		open_flags_t O_ASYNC;

public extern "SEEK_SET"	whence_t SEEK_SET;
public extern "SEEK_CUR"	whence_t SEEK_CUR;
public extern "SEEK_END"	whence_t SEEK_END;

public extern "S_IRWXU"		mode_t S_IRWXU;
public extern "S_IRUSR"		mode_t S_IRUSR;
public extern "S_IWUSR"		mode_t S_IWUSR;
public extern "S_IXUSR"		mode_t S_IXUSR;
public extern "S_IRWXG"		mode_t S_IRWXG;
public extern "S_IRGRP"		mode_t S_IRGRP;
public extern "S_IWGRP"		mode_t S_IWGRP;
public extern "S_IXGRP"		mode_t S_IXGRP;
public extern "S_IRWXO"		mode_t S_IRWXO;
public extern "S_IROTH"		mode_t S_IROTH;
public extern "S_IWOTH"		mode_t S_IWOTH;
public extern "S_IXOTH"		mode_t S_IXOTH;

public threaded extern "pxcio::file_read" function
  errno_t file_read(file& f, strref const& buf, size_t& len_r);
public threaded extern "pxcio::file_read_append" function
  errno_t file_read_append(file& f, string& buf, size_t& len_inout);
public threaded extern "pxcio::file_write" function
  errno_t file_write(file& f, cstrref const& buf, size_t& len_inout);
public threaded extern "pxcio::file_lseek" function
  errno_t file_lseek(file& f, off_t& offset_inout, whence_t whence);

public threaded extern "pxcio::io_stat" function
  errno_t io_stat(ioptr const& iop, cstrref const& fn, statbuf& buf);
public threaded extern "pxcio::io_errno" function
  errno_t io_errno(ioptr const& iop);
public threaded extern "pxcio::io_sleep" function
  uint io_sleep(ioptr const& iop, uint sec);
public threaded extern "pxcio::io_usleep" function
  uint io_usleep(ioptr const& iop, uint usec);

public threaded function
size_t file_read_all(file& f, string& buf)
{
  size_t r = 0;
  while (true) {
    size_t rlen = 16384;
    errno_t e = file_read_append(f, buf, rlen);
    if (rlen == 0) { break; }
    r += rlen;
  }
  return r;
}
public threaded function
size_t file_write_all(file& f, cstrref const& buf)
{
  size_t curpos = 0;
  size_t endpos = buf.size();
  while (curpos != endpos) {
    size_t wlen;
    errno_t e = file_write(f, buf[curpos .. endpos], wlen);
    if (wlen == 0) {
      break;
    }
    curpos += wlen;
  }
  return curpos;
}
public threaded function
size_t io_read_file(ioptr const& iop, cstrref const& fn,
  string& buf)
{
  buf.clear();
  errno_t e;
  file f = file(iop, fn, O_RDONLY, 0, e);
  return f.read_all(buf);
}
public threaded function
size_t io_write_file(ioptr const& iop, cstrref const& fn, cstrref const& buf)
{
  errno_t e;
  file f = file(iop, fn, O_WRONLY | O_CREAT | O_TRUNC,
    S_IRWXU | S_IRWXG | S_IRWXO, e);
  return f.write_all(buf);
}

extern "type" inline
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
namespace pxcio {
using namespace pxcrt;
typedef struct ::stat statbuf;
typedef int errno_t;
struct auto_file {
  auto_file(int fd) : fd(fd) { }
  ~auto_file() { if (fd > 2) close(fd); } /* don't close stdin/out/err */
  int get() const { return fd; }
private:
  const int fd;
  auto_file(const auto_file&);
  auto_file& operator =(const auto_file&);
};
struct file_impl : public auto_file {
  file_impl(ioptr const& iop, cstrref const& fn, int flags, ::mode_t md,
    errno_t& err_r);
  file_impl(ioptr const& iop, int fd); /* must not be used from pxc */
public:
  int err;
};
};

extern "fdecl" inline
namespace pxcio {
errno_t file_lseek_impl(int fd, ::off_t& offset_inout, int whence);
errno_t file_read_impl(int fd, strref const& buf, size_t& len_r);
errno_t file_read_append_impl(int fd, bt_string& buf, size_t& len_inout);
errno_t file_write_impl(int fd, cstrref const& buf, size_t& len_r);
};

extern "fdef" inline
namespace pxcio {
#include <stdlib.h>
#include <limits.h>
#include <string>
int file_open_impl(cstrref const& fn, int flags, ::mode_t md)
{
  PXCRT_ALLOCA_NTSTRING(fn_nt, fn);
  int fd = ::open(fn_nt.get(), flags, md);
  return fd;
}
file_impl::file_impl(ioptr const& iop, cstrref const& fn,
  int flags, ::mode_t md, errno_t& err_r)
  : auto_file(file_open_impl(fn, flags, md))
{
  err_r = get() < 0 ? errno : 0;
}
file_impl::file_impl(ioptr const& iop, int fd)
  : auto_file(fd)
{
}
errno_t file_read_impl(int fd, strref const& buf, size_t& len_r)
{
  bt_size_t sz = buf.size();
  if (sz > SSIZE_MAX) {
    sz = SSIZE_MAX;
  }
  void *const ptr = buf.rawarr();
  const ssize_t rlen = ::read(fd, ptr, sz);
  if (rlen < 0) {
    len_r = 0;
    return errno;
  }
  len_r = rlen;
  return 0;
}
errno_t file_read(file_impl& f, strref const& buf, size_t& len_r)
{
  return file_read_impl(f.get(), buf, len_r);
}
errno_t file_read_append_impl(int fd, bt_string& buf, size_t& len_inout)
{
  bt_size_t sz = len_inout;
  if (sz > SSIZE_MAX) {
    sz = SSIZE_MAX;
  }
  const bt_size_t osz = buf.size();
  bt_size_t nsz = osz + sz;
  if (nsz < nsz) {
    throw std::bad_alloc(); /* overflow */
  }
  buf.reserve(nsz);
  void *const ptr = buf.rawarr() + osz;
  const ssize_t rlen = ::read(fd, ptr, sz);
  if (rlen < 0) {
    len_inout = 0;
    return errno;
  }
  buf.rawarr_initialized(osz + rlen);
  len_inout = rlen;
  return 0;
}
errno_t file_read_append(file_impl& f, bt_string& buf, size_t& len_inout)
{
  return file_read_append_impl(f.get(), buf, len_inout);
}
errno_t file_write_impl(int fd, cstrref const& buf, size_t& len_r)
{
  bt_size_t sz = buf.size();
  if (sz > SSIZE_MAX) {
    sz = SSIZE_MAX;
  }
  const unsigned char *const ptr = buf.rawarr();
  const ssize_t wlen = ::write(fd, ptr, sz);
  if (wlen < 0) {
    len_r = 0;
    return errno;
  }
  len_r = wlen;
  return 0;
}
errno_t file_write(file_impl& f, cstrref const& buf, size_t& len_r)
{
  return file_write_impl(f.get(), buf, len_r);
}
errno_t file_lseek_impl(int fd, ::off_t& offset_inout, int whence)
{
  offset_inout = ::lseek(fd, offset_inout, whence);
  return (offset_inout == (off_t)-1) ? errno : 0;
}
errno_t file_lseek(file_impl& f, ::off_t& offset_inout, int whence)
{
  return file_lseek_impl(f.get(), offset_inout, whence);
}
errno_t io_stat(ioptr const& iop, cstrref const& fn, pxcio::statbuf& buf)
{
  PXCRT_ALLOCA_NTSTRING(fn_nt, fn);
  const int e = ::stat(fn_nt.get(), &buf);
  return e != 0 ? errno : 0;
}
errno_t io_errno(ioptr const& iop)
{
  return errno;
}
bt_uint io_sleep(ioptr const& iop, bt_uint sec)
{
  return ::sleep(sec);
}
bt_uint io_usleep(ioptr const& iop, bt_uint usec)
{
  return ::usleep(usec);
}
};

