namespace io::net::addrinfo;
public import numeric::integral -;
public import container::string -;
public import container::array -;
public import io -;

public tsvaluetype struct extern "int" "extenum" family_t { }
public tsvaluetype struct extern "int" "extenum" socktype_t { }
public tsvaluetype struct extern "int" "extenum" protocol_t { }
public tsvaluetype struct extern "int" "extbitmask" ai_flags_t { }

public extern "AF_UNSPEC"	family_t AF_UNSPEC;
public extern "AF_INET"		family_t AF_INET;
public extern "AF_INET6"	family_t AF_INET6;
public extern "AF_UNIX"		family_t AF_UNIX;
public extern "0"		socktype_t SOCK_UNSPEC;
public extern "SOCK_STREAM"	socktype_t SOCK_STREAM;
public extern "SOCK_DGRAM"	socktype_t SOCK_DGRAM;
public extern "0"		protocol_t PROTO_UNSPEC;
public extern "IPPROTO_TCP"	protocol_t IPPROTO_TCP;
public extern "IPPROTO_UDP"	protocol_t IPPROTO_UDP;
public extern "AI_PASSIVE"	ai_flags_t AI_PASSIVE;
public extern "AI_NUMERICHOST"	ai_flags_t AI_NUMERICHOST;
public extern "AI_NUMERICSERV"	ai_flags_t AI_NUMERICSERV;
public extern "0"               gai_error_t EAI_OK;

public tsvaluetype struct extern "int" "extenum" gai_error_t { }
public threaded function extern "pxcio::gai_error_t_append_to_string"
  void gai_error_t_append_to_string(gai_error_t x, string mutable& s);

public multithreaded struct extern "pxcio::addrinfo"
addrinfo(io const& iop, cslice{uchar} const& node,
  cslice{uchar} const& service, family_t ai_family, socktype_t ai_socktype,
  protocol_t ai_protocol, ai_flags_t ai_flags)
{
  public function extern "get_sockaddr" sockaddr_storage get_sockaddr() const;
  public function extern "get_canonname" string get_canonname() const;
  public function extern "empty" bool empty() const;
  public function extern "next" void next();
  public function extern "get_error" gai_error_t get_error() const;
}

public tsvaluetype struct extern "pxcio::sockaddr_storage" sockaddr_storage {
  public function extern "get_family" family_t get_family() const;
  public function extern "get_in_port" ushort get_in_port() const;
  public function extern "get_in_addr" uint get_in_addr() const;
}

extern "types" inline
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
namespace pxcio {

using namespace pxcrt;

struct sockaddr_storage {
  sockaddr_storage() : sto() { }
  int get_family() const;
  bt_uint get_in_addr() const;
  bt_ushort get_in_port() const;
  ::sockaddr *get_sockaddr() { return reinterpret_cast< ::sockaddr *>(&sto); }
  const ::sockaddr *get_sockaddr() const
    { return reinterpret_cast<const ::sockaddr *>(&sto); }
  socklen_t get_socklen() const { return sizeof(sto); }
  ::sockaddr_storage sto;
};

struct addrinfo {
  addrinfo(::pxcio::io const& iop, cstrref const& node, cstrref const& service,
    int ai_family, int ai_socktype, int ai_protocol, int ai_flags);
  ~addrinfo();
  bt_bool empty() const;
  void next();
  int get_error() const;
  sockaddr_storage get_sockaddr() const;
  bt_string get_canonname() const;
  const ::addrinfo *get_cur() const { return cur; }
private:
  addrinfo(const addrinfo&);
  addrinfo& operator =(const addrinfo&);
  ::addrinfo *ai;
  ::addrinfo *cur;
  int error;
};

}; //namespace pxcio
;

extern "implementation" inline
namespace pxcio {
using namespace pxcrt;

void gai_error_t_append_to_string(int err, bt_string& s)
{
  const char *p = gai_strerror(err);
  s.append(reinterpret_cast<const bt_uchar *>(p), strlen(p));
}

addrinfo::addrinfo(::pxcio::io const& iop, cstrref const& node,
  cstrref const& service, int ai_family, int ai_socktype, int ai_protocol,
  int ai_flags)
  : ai(0), cur(0), error(0)
{
  ::addrinfo hints = { };
  hints.ai_family = ai_family;
  hints.ai_socktype = ai_socktype;
  hints.ai_protocol = ai_protocol;
  hints.ai_flags = ai_flags;
  PXCRT_ALLOCA_NTSTRING(node_nt, node);
  int err = 0;
  if (service.empty()) {
    hints.ai_flags |= AI_NUMERICSERV;
    err = ::getaddrinfo(node_nt.get(), "0", &hints, &ai);
  } else {
    PXCRT_ALLOCA_NTSTRING(service_nt, service);
    err = ::getaddrinfo(node_nt.get(), service_nt.get(), &hints, &ai);
  }
  if (err != 0) {
    if (ai != 0) {
      ::freeaddrinfo(ai);
      ai = 0;
    }
  }
  cur = ai;
  error = err;
}

addrinfo::~addrinfo()
{
  if (ai != 0) {
    ::freeaddrinfo(ai);
  }
}

bt_bool addrinfo::empty() const
{
  return cur == 0;
}

void addrinfo::next()
{
  if (cur == 0) {
    return;
  }
  cur = cur->ai_next;
}

int addrinfo::get_error() const
{
  return error;
}

sockaddr_storage addrinfo::get_sockaddr() const
{
  sockaddr_storage r = sockaddr_storage();
  if (cur != 0) {
    memcpy(&r.sto, cur->ai_addr, cur->ai_addrlen);
  }
  return r;
}

bt_string addrinfo::get_canonname() const
{
  const char *s = cur != 0 ? cur->ai_canonname : 0;
  if (s == 0) {
    s = "";
  }
  bt_string r(reinterpret_cast<const bt_uchar *>(s), strlen(s));
  return r;
}

int sockaddr_storage::get_family() const
{
  return sto.ss_family;
}

bt_uint sockaddr_storage::get_in_addr() const
{
  if (sto.ss_family != AF_INET) {
    return 0;
  }
  const sockaddr_in *p = reinterpret_cast<const sockaddr_in *>(&sto);
  return ntohl(p->sin_addr.s_addr);
}

bt_ushort sockaddr_storage::get_in_port() const
{
  if (sto.ss_family != AF_INET) {
    return 0;
  }
  const sockaddr_in *p = reinterpret_cast<const sockaddr_in *>(&sto);
  return ntohs(p->sin_port);
}

}; // namespace pxcio
;

