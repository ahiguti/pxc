namespace io::net::addrinfo;
public import type::builtin "";
public import compiler::util "";
public import io "";
public import error;

public tsvaluetype extern "int" "enum" struct family_t { }
public tsvaluetype extern "int" "enum" struct socktype_t { }
public tsvaluetype extern "int" "enum" struct protocol_t { }
public tsvaluetype extern "int" "bitmask" struct ai_flags_t { }

public extern "AF_UNSPEC"	family_t AF_UNSPEC;
public extern "AF_INET"		family_t AF_INET;
public extern "AF_INET6"	family_t AF_INET6;
public extern "AF_UNIX"		family_t AF_UNIX;
public extern "0"		socktype_t SOCK_UNSPEC;
public extern "SOCK_STREAM"	socktype_t SOCK_STREAM;
public extern "SOCK_DGRAM"	socktype_t SOCK_DGRAM;
public extern "0"		protocol_t PROTO_UNSPEC;
public extern "IPPROTO_TCP"	protocol_t IPPROTO_TCP;
public extern "IPPROTO_UDP"	protocol_t IPPROTO_UDP;
public extern "AI_PASSIVE"	ai_flags_t AI_PASSIVE;
public extern "AI_NUMERICHOST"	ai_flags_t AI_NUMERICHOST;
public extern "AI_NUMERICSERV"	ai_flags_t AI_NUMERICSERV;

public tsvaluetype extern "int" "enum" struct gai_error_t { }
public macro gai_eh error::error_handler{gai_error_t};
public threaded extern "pxcio::gai_error_t_append_to_string"
  function void gai_error_t_append_to_string(gai_error_t x, string& s);

public multithreaded extern "pxcio::addrinfo"
struct addrinfo(ioptr const& iop, cslice{uchar} const& node,
  cslice{uchar} const& service, family_t ai_family, socktype_t ai_socktype,
  protocol_t ai_protocol, ai_flags_t ai_flags, gai_eh& eh) {
  public extern "get_sockaddr" function sockaddr_storage get_sockaddr() const;
  public extern "get_canonname" function string get_canonname() const;
  public extern "empty" function bool empty() const;
  public extern "next" function void next();
}

public tsvaluetype extern "pxcio::sockaddr_storage" struct sockaddr_storage {
  public extern "get_family" function family_t get_family() const;
  public extern "get_in_port" function ushort get_in_port() const;
  public extern "get_in_addr" function uint get_in_addr() const;
}

extern "type" inline
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
namespace error$n
  { struct error_handler$s$tp1$io$$net$$addrinfo$n$$gai_error_t$s; };
namespace pxcio {
using namespace pxcrt;
struct sockaddr_storage {
  sockaddr_storage() : sto() { }
  int get_family() const;
  bt_uint get_in_addr() const;
  bt_ushort get_in_port() const;
  ::sockaddr *get_sockaddr() { return reinterpret_cast< ::sockaddr *>(&sto); }
  const ::sockaddr *get_sockaddr() const
    { return reinterpret_cast<const ::sockaddr *>(&sto); }
  socklen_t get_socklen() const { return sizeof(sto); }
  ::sockaddr_storage sto;
};
typedef ::error$n::error_handler$s$tp1$io$$net$$addrinfo$n$$gai_error_t$s
  gai_eh;
struct addrinfo {
  addrinfo(ioptr const& iop, cstrref const& node, cstrref const& service,
    int ai_family, int ai_socktype, int ai_protocol, int ai_flags, gai_eh& eh);
  ~addrinfo();
  bt_bool empty() const;
  void next();
  sockaddr_storage get_sockaddr() const;
  bt_string get_canonname() const;
  const ::addrinfo *get_cur() const { return cur; }
private:
  addrinfo(const addrinfo&);
  addrinfo& operator =(const addrinfo&);
  ::addrinfo *ai;
  ::addrinfo *cur;
};
}; //namespace pxcio

extern "fdef" inline
namespace pxcio {
using namespace pxcrt;
inline void gai_eh_set(gai_eh& eh, int err) { eh.set$f(err); }
void gai_error_t_append_to_string(int err, bt_string& s)
{
  const char *p = gai_strerror(err);
  s.append(reinterpret_cast<const bt_uchar *>(p), strlen(p));
}
addrinfo::addrinfo(ioptr const& iop, cstrref const& node,
  cstrref const& service, int ai_family, int ai_socktype, int ai_protocol,
  int ai_flags, gai_eh& eh)
  : ai(0), cur(0)
{
  ::addrinfo hints = { };
  hints.ai_family = ai_family;
  hints.ai_socktype = ai_socktype;
  hints.ai_protocol = ai_protocol;
  hints.ai_flags = ai_flags;
  PXCRT_ALLOCA_NTSTRING(node_nt, node);
  int err = 0;
  if (service.empty()) {
    hints.ai_flags |= AI_NUMERICSERV;
    err = ::getaddrinfo(node_nt.get(), "0", &hints, &ai);
  } else {
    PXCRT_ALLOCA_NTSTRING(service_nt, service);
    err = ::getaddrinfo(node_nt.get(), service_nt.get(), &hints, &ai);
  }
  if (err != 0) {
    if (ai != 0) {
      ::freeaddrinfo(ai);
      ai = 0;
    }
    gai_eh_set(eh, err);
  }
  cur = ai;
}
addrinfo::~addrinfo()
{
  if (ai != 0) {
    ::freeaddrinfo(ai);
  }
}
bt_bool addrinfo::empty() const
{
  return cur == 0;
}
void addrinfo::next()
{
  if (cur == 0) {
    return;
  }
  cur = cur->ai_next;
}
sockaddr_storage addrinfo::get_sockaddr() const
{
  sockaddr_storage r = sockaddr_storage();
  if (cur != 0) {
    memcpy(&r.sto, cur->ai_addr, cur->ai_addrlen);
  }
  return r;
}
bt_string addrinfo::get_canonname() const
{
  const char *s = cur != 0 ? cur->ai_canonname : 0;
  if (s == 0) {
    s = "";
  }
  bt_string r(reinterpret_cast<const bt_uchar *>(s), strlen(s));
  return r;
}
int sockaddr_storage::get_family() const
{
  return sto.ss_family;
}
bt_uint sockaddr_storage::get_in_addr() const
{
  if (sto.ss_family != AF_INET) {
    return 0;
  }
  const sockaddr_in *p = reinterpret_cast<const sockaddr_in *>(&sto);
  return ntohl(p->sin_addr.s_addr);
}
bt_ushort sockaddr_storage::get_in_port() const
{
  if (sto.ss_family != AF_INET) {
    return 0;
  }
  const sockaddr_in *p = reinterpret_cast<const sockaddr_in *>(&sto);
  return ntohs(p->sin_port);
}
}; // namespace pxcio

