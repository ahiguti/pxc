namespace io::net::socket;
public import numeric::integral -;
public import container::string -;
public import pointer -;
public import io -;
public import io::file -;
public import io::errno -;
public import io::net::addrinfo ai;

public multithreaded extern "pxcio::socket_acceptor" "nodefault"
  struct socket_acceptor { }
public multithreaded extern "pxcio::socket_connector" "nodefault"
  struct socket_connector { }

public multithreaded extern "pxcio::socket_factory" "linear"
  struct socket_factory(io const& iop, bool passive,
    ai::sockaddr_storage const& addr, ai::socktype_t socktype,
    ai::protocol_t protocol, uint listen_backlog, uint connect_timeout_sec,
    errno_handler& eh) { }

public threaded extern "pxcio::accept" function
  file accept(socket_acceptor const& sfp, ai::sockaddr_storage& addr_r,
    errno_handler& ej);
public threaded extern "pxcio::connect" function
  file connect(socket_connector const& sfp, errno_handler& ej);
public threaded extern "pxcio::socket_set_recv_timeout" function
  void socket_set_recv_timeout(file const& f, uint sec, errno_handler& eh);
public threaded extern "pxcio::socket_set_send_timeout" function
  void socket_set_send_timeout(file const& f, uint sec, errno_handler& eh);

public threaded function socket_acceptor create_acceptor(io const& iop,
  cstrref const& host, cstrref const& service, ai::family_t family,
  ai::socktype_t socktype, uint backlog, uint timeout_sec)
{
  var gaieh = ai::gai_eh(error::handle_throw);
  var ioeh = errno_handler(error::handle_throw);
  var ai = ai::addrinfo(iop, host, service, family, socktype, ai::PROTO_UNSPEC, 
    ai::AI_PASSIVE, gaieh);
  var sfp = create_socket_acceptor(iop, ai.get_sockaddr(), socktype,
    ai::PROTO_UNSPEC, backlog, timeout_sec, ioeh);
  return sfp;
}

public threaded function socket_connector create_connector(io const& iop,
  cstrref const& host, cstrref const& service, ai::family_t family,
  ai::socktype_t socktype, uint timeout_sec)
{
  var gaieh = ai::gai_eh(error::handle_throw);
  var ioeh = errno_handler(error::handle_throw);
  var ai = ai::addrinfo(iop, host, service, family, socktype, ai::PROTO_UNSPEC, 
    0, gaieh);
  var sfp = create_socket_connector(iop, ai.get_sockaddr(), socktype,
    ai::PROTO_UNSPEC, timeout_sec, ioeh);
  return sfp;
}

private threaded extern "pxcio::create_socket_acceptor" function
  socket_acceptor create_socket_acceptor(io const& iop,
    ai::sockaddr_storage const& addr, ai::socktype_t socktype,
    ai::protocol_t protocol, uint listen_backlog, uint accept_timeout_sec,
    errno_handler& eh);
private threaded extern "pxcio::create_socket_connector" function
  socket_connector create_socket_connector(io const& iop,
    ai::sockaddr_storage const& addr, ai::socktype_t socktype,
    ai::protocol_t protocol, uint connect_timeout_sec, errno_handler& eh);

extern "type" inline
namespace pxcio {
struct socket_acceptor_rep {
  /* NOTE: must be immutable. */
  socket_acceptor_rep(sockaddr_storage const& addr, int socktype,
    int protocol, bt_uint backlog, bt_uint timeout_sec, errno_handler& eh);
  const sockaddr_storage addr;
  const int socktype;
  const int protocol;
  const bt_uint timeout_sec;
  const file listener; /* tiptr */
};
struct socket_connector_rep {
  /* NOTE: must be immutable. */
  socket_connector_rep(sockaddr_storage const& addr, int socktype,
    int protocol, bt_uint timeout_sec, errno_handler& eh);
  const sockaddr_storage addr;
  const int socktype;
  const int protocol;
  const bt_uint timeout_sec;
};
typedef pxcrt::rcptr< pxcrt::tircval<socket_acceptor_rep> > socket_acceptor;
typedef pxcrt::rcptr< pxcrt::tircval<socket_connector_rep> > socket_connector;
};

extern "fdecl" inline
namespace pxcio {
};

extern "fdef" inline
namespace pxcio {
static int socket_acceptor_fd(sockaddr_storage const& addr,
  int socktype, int protocol, int backlog, int timeout_sec, errno_handler& eh)
{
  int fd = ::socket(addr.get_family(), socktype, protocol);
  int e = 0;
  do {
    if (fd < 0) {
      e = -1;
      break;
    }
    e = ::bind(fd, addr.get_sockaddr(), addr.get_socklen());
    if (e != 0) {
      break;
    }
    e = ::listen(fd, backlog);
  } while (0);
  if (e != 0) {
    if (fd >= 0) {
      close(fd);
    }
    ioeh_set(eh, errno);
    return -1;
  }
  return fd;
}
socket_acceptor_rep::socket_acceptor_rep(sockaddr_storage const& addr,
  int socktype, int protocol, bt_uint backlog, bt_uint timeout_sec,
  errno_handler& eh)
  : addr(addr), socktype(socktype), protocol(protocol),
    timeout_sec(timeout_sec),
    listener(create_file(socket_acceptor_fd(addr, socktype, protocol, backlog,
      timeout_sec, eh)))
{
}
socket_acceptor create_socket_acceptor(::pxcio::io const& iop,
  sockaddr_storage const& addr, int socktype, int protocol, bt_uint backlog,
  bt_uint timeout_sec, errno_handler& eh)
{
  socket_acceptor sa(new pxcrt::tircval<socket_acceptor_rep>(
    socket_acceptor_rep(addr, socktype, protocol, backlog, timeout_sec, eh)));
  return sa;
}
socket_connector_rep::socket_connector_rep(sockaddr_storage const& addr,
  int socktype, int protocol, bt_uint timeout_sec, errno_handler& eh)
  : addr(addr), socktype(socktype), protocol(protocol),
    timeout_sec(timeout_sec)
{
}
socket_connector create_socket_connector(::pxcio::io const& iop,
  sockaddr_storage const& addr, int socktype, int protocol,
  bt_uint timeout_sec, errno_handler& eh)
{
  socket_connector sc(new pxcrt::tircval<socket_connector_rep>(
    socket_connector_rep(addr, socktype, protocol, timeout_sec, eh)));
  return sc;
}
file accept(socket_acceptor const& sfp, sockaddr_storage& addr_r,
  errno_handler& eh)
{
  socket_acceptor_rep& sf = sfp->value$z;
  socklen_t len = addr_r.get_socklen();
  int fd = ::accept(sf.listener->value$z.get(), addr_r.get_sockaddr(), &len);
  if (fd < 0) {
    ioeh_set(eh, errno);
    fd = -1;
  }
  return create_file(fd);
}
file connect(socket_connector const& sfp, errno_handler& eh)
{
  socket_connector_rep& sf = sfp->value$z;
  int e = 0;
  int fd = ::socket(sf.addr.get_family(), sf.socktype, sf.protocol);
  do {
    if (fd < 0) {
      e = -1;
      break;
    }
    if (sf.timeout_sec != 0) {
      struct ::timeval tv = { 0 };
      tv.tv_sec = sf.timeout_sec;
      e = ::setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
      if (e != 0) {
	break;
      }
    }
    e = ::connect(fd, sf.addr.get_sockaddr(), sf.addr.get_socklen());
  } while (0);
  if (e != 0) {
    if (fd >= 0) {
      close(fd);
    }
    ioeh_set(eh, errno);
    fd = -1;
  }
  return create_file(fd);
}
static void setsockopt_common(int fd, int level, int optname, const void *val,
  socklen_t valsz, errno_handler& eh)
{
  const int e = ::setsockopt(fd, level, optname, val, valsz);
  if (e != 0) {
    ioeh_set(eh, errno);
  }
}
void socket_set_recv_timeout(file const& f, bt_uint sec, errno_handler& eh)
{
  struct ::timeval tv = { 0 };
  tv.tv_sec = sec;
  setsockopt_common(f->value$z.get(), SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv),
    eh);
}
void socket_set_send_timeout(file const& f, bt_uint sec, errno_handler& eh)
{
  struct ::timeval tv = { 0 };
  tv.tv_sec = sec;
  setsockopt_common(f->value$z.get(), SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv),
    eh);
}
};

