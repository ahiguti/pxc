namespace meta::common;

public extern "@error" "@error" struct {x} error { }

public extern "@is_type" "@is_type" struct {x} is_type { }
public extern "@is_function" "@is_function" struct {x} is_function { }
public extern "@is_metafunction" "@is_metafunction"
  struct {x} is_metafunction { }
public extern "@is_int" "@is_int" struct {x} is_int { }
public extern "@is_string" "@is_string" struct {x} is_string { }
public extern "@eq" "@eq" struct {x, y} eq { }
public extern "@not" "@not" struct {x} not { }

public extern "@imports" "@imports" struct {ns} imports { }
public extern "@functions" "@functions" struct {ns} functions { }
public extern "@types" "@types" struct {ns} types { }
public extern "@global_variables" "@global_variables"
  struct {ns} global_variables { }
  /* list{list{name, typ, byref(=0), mutable}} */

public extern "@local" "@local" struct {t, n, opt_args} local { }
public extern "@symbol" "@symbol" struct {name, opt_t} symbol { }
public extern "@attribute" "@attribute" struct {t} attribute { }
public extern "@family" "@family" struct {t} family { }
public extern "@nsname" "@nsname" struct {x} nsname { }
public extern "@num_tparams" "@num_tparams" struct {x} num_tparams { }
public extern "@num_targs" "@num_targs" struct {x} num_targs { }
public extern "@targs" "@targs" struct {x} targs { }
public extern "@values" "@values" struct {x} values { }
public extern "@typeof" "@typeof" struct {x} typeof { }

public extern "@rettype" "@rettype" struct {f} rettype { }
public extern "@argnum" "@argnum" struct {f, i} argnum { }
public extern "@argtype" "@argtype" struct {f, i} argtype { }
public extern "@argbyref" "@argbyref" struct {f, i} argbyref { }
public extern "@argtypes" "@argtypes" struct {f} argtypes { }
public extern "@argnames" "@argnames" struct {f} argnames { }
public extern "@args" "@args" struct {f} args { }
  /* list{list{name, typ, byref, mutable}} */

public extern "@is_copyable_type" "@is_copyable_type"
  struct {t} is_copyable_type { }
public extern "@is_asignable_type" "@is_asignable_type"
  struct {t} is_asignable_type { }

public extern "@field_types" "@field_types" struct {t} field_types { }
public extern "@field_names" "@field_names" struct {t} field_names { }
public extern "@fields" "@fields" struct {t} fields { }
public extern "@member_functions" "@member_functions"
  struct {t} member_functions { }

public extern "@apply" "@apply" struct {mf, lst} apply { }

public extern "@to_int" "@to_int" struct {x} to_int { }
public extern "@to_string" "@to_string" struct {x} to_string { }
public extern "@full_string" "@full_string" struct {x} full_string { }

public extern "@concat" "@concat" struct {x} concat { }
public extern "@index" "@index" struct {x, y} index { }
public extern "@substring" "@substring" struct {x, i, j} substring { }

public extern "@@cond" "@@cond" struct {c, x, y} cond { }
public extern "@@or" "@@or" struct {x, y} or { }
public extern "@@and" "@@and" struct {x, y} and { }
public extern "@@quote" "@@quote" struct {x} quote { }

public extern "@list" "@list" struct {x, y} list { }
public extern "@size" "@size" struct {x} size { }
public extern "@slice" "@slice" struct {lst, i0, i1} slice { }
public extern "@at" "@at" struct {lst, idx} at { }
public extern "@seq" "@seq" struct {x, y} seq { }
public extern "@map" "@map" struct {lists, mf, args} map { }
  /* map{list_0, ... , lst_n, func, arg_0, ... , arg_n} */
public extern "@filter" "@filter" struct {lst, f} filter { }
public extern "@join" "@join" struct {list_of_lists} join { }
public extern "@join_all" "@join_all" struct {lst1, lst2} join_all { }
public extern "@join_tail" "@join_tail" struct {cons} join_tail { }
public extern "@sort" "@sort" struct {lst} sort { }
public extern "@unique" "@unique" struct {lst} unique { }

public extern "@add" "@add" struct {x, y} add { }
public extern "@sub" "@sub" struct {x, y} sub { }
public extern "@mul" "@mul" struct {x, y} mul { }
public extern "@div" "@div" struct {x, y} div { }
public extern "@mod" "@mod" struct {x, y} mod { }
public extern "@gt" "@gt" struct {x, y} gt { }
public extern "@lt" "@lt" struct {x, y} lt { }
public extern "@ge" "@ge" struct {x, y} ge { }
public extern "@le" "@le" struct {x, y} le { }

public metafunction ne{x, y} not{eq{x, y}};

public metafunction at0{lst} at{lst, 0};
public metafunction at1{lst} at{lst, 1};
public metafunction at2{lst} at{lst, 2};
public metafunction at3{lst} at{lst, 3};
public metafunction at4{lst} at{lst, 4};
public metafunction at5{lst} at{lst, 5};
public metafunction at6{lst} at{lst, 6};
public metafunction at7{lst} at{lst, 7};
public metafunction at8{lst} at{lst, 8};
public metafunction at9{lst} at{lst, 9};
public metafunction empty{lst} eq{size{lst}, 0};

public metafunction fix{v, f} fix_iter{v, f{v}, f};
  private metafunction fix_iter{v0, v1, f}
    cond{eq{v0, v1}, v0, fix_iter{v1, f{v1}, f}};

public metafunction imports_transitive{ns} fix{imports_init{ns}, imports_iter};
  private metafunction is_import_pub{ent} eq{at1{ent}, 0};
  private metafunction imports_name_pub{ns}
    map{filter{imports{ns}, is_import_pub}, at0};
  private metafunction imports_name{ns} map{imports{ns}, at0};
  private metafunction imports_init{ns}
    sort{unique{join_all{list{ns}, imports_name{ns}}}};
  private metafunction imports_iter{lst}
    sort{unique{join_all{lst, join{map{lst, imports_name_pub}}}}};

public metafunction field_type{t, fname}
  field_type_iter{field_types{t}, field_names{t}, fname};
  private metafunction field_type_iter{tlst, nlst, n}
    cond{eq{at0{nlst}, n},
      at0{tlst},
      field_type_iter{slice{tlst, 1}, slice{nlst, 1}, n}};

