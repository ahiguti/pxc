public threaded namespace container::bit_array;
public import numeric::integral -;
public import numeric::cast -;
public import pointer;
public import container::array::array_common -;
public import container::array -;
public import meta m;
public import meta::family mf;
public import exception -;

// TODO: test
public mtvaluetype struct bit_varray {
  public metafunction key_type size_t;
  public metafunction mapped_type bool;
  public function bool empty() const { return len == 0; }
  public function size_t size() const { return len; }
  public function void resize(size_t nlen, bool v)
  {
    if (nlen + 7u < nlen) {
      throw bad_alloc_template{"bit_varray"}();
    }
    fill_tail(v && nlen > len);
      // fill with 0 if nlen <= len in order to make to_string() consistent
    size_t nlen_uc = (nlen + 7u) / 8u;
    value.resize(nlen_uc, v ? 0xffu : 0u);
    len = nlen;
  }
  public function bool __getelem(size_t i) const
  {
    check_bounds(i);
    const ev = value[i >> 3u];
    return (ev & static_cast{uchar}(1u << (i & 7u))) != 0;
  }
  public function void __setelem(size_t i, bool v)
  {
    check_bounds(i);
    mutable ev = value[i >> 3u];
    if (v) {
      ev |= static_cast{uchar}(1u << (i & 7u));
    } else {
      ev &= static_cast{uchar}(~(1u << (i & 7u)));
    }
    value[i >> 3u] = ev;
  }
  private function void check_bounds(size_t i) const
  {
    if (m::is_false{pxc_no_bounds_checking}) {
      if (i >= len) {
	throw invalid_index();
      }
    }
  }
  private function void fill_tail(bool v)
  {
    uint const b = static_cast{uint}(len & 7u);
    if (b == 0) {
      return;
    }
    uchar const mask = static_cast{uchar}((1u << b) - 1u);
    value[len - 1] =
      ((value[len - 1] & mask) | static_cast{uchar}(v ? 0xffu : 0u));
  }
  private size_t len;
  private varray{uchar} value;
}

