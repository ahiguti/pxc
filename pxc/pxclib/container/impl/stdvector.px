namespace container::impl::stdvector;
public import container::impl::array_common;

extern "type" inline
#include <vector>
namespace array {
template <typename T>
struct stdvector {
  template <typename Tc> friend struct pxcrt::guard_ref;
  template <typename Tc> friend struct pxcrt::guard_val;
  typedef typename std::vector<T>::size_type size_type;
  typedef typename std::vector<T>::iterator iterator;
  typedef typename std::vector<T>::const_iterator const_iterator;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  stdvector() : invalidate_guard_count(0) { }
  stdvector(const stdvector& x) : v(x.v), invalidate_guard_count(0) { }
  stdvector(const range_type& x) : v(x.rawarr(), x.rawarr() + x.size()) { }
  stdvector(const crange_type& x) : v(x.rawarr(), x.rawarr() + x.size()) { }
  stdvector& operator =(const stdvector& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  bool empty() const { return v.empty(); }
  size_type size() const { return v.size(); }
  T& operator [](size_type idx) {
    if (idx >= v.size()) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= v.size()) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  T value_at(size_type idx) const {
    if (idx >= v.size()) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  void resize(size_type sz, T const& x) {
    check_resize();
    v.resize(sz, x);
  }
  void clear() {
    check_resize();
    v.clear();
  }
  void push_back(T const& x) {
    check_resize();
    v.push_back(x);
  }
  T pop_back() {
    check_resize();
    if (v.empty()) { pxcrt::throw_invalid_index(); }
    const T r = v.back();
    v.pop_back();
    return r;
  }
  void append(const crange_type& x) {
    v.insert(v.end(), x.rawarr(), x.rawarr() + x.size());
  }
  void reserve(size_type sz) {
    check_resize();
    v.reserve(sz);
  }
  iterator begin() { return v.begin(); }
  const_iterator begin() const { return v.begin(); }
  iterator end() { return v.end(); }
  const_iterator end() const { return v.end(); }
  T *rawarr() { return &v[0]; }
  const T *rawarr() const { return &v[0]; }
private:
  void check_resize() {
    if (invalidate_guard_count != 0) { pxcrt::throw_would_invalidate(); }
  }
  void inc_invalidate_guard() const {
    ++invalidate_guard_count;
  }
  void dec_invalidate_guard() const {
    --invalidate_guard_count;
  }
public:
  std::vector<T> v;
private:
  mutable size_type invalidate_guard_count;
};
}; // namespace array
;

