namespace serialize::string;
public import type::builtin "";
public import meta::builtin m;
public import numeric::cast n;
public import numeric::positional n;

public threaded function {t} string to_string(t const& x)
{
  string s;
  append_to_string(x, s);
  return s;
}

public threaded function {t} void append_to_string(t const& x, string& s)
{
  macro symstr m::concat{t, "_append_to_string"};
  macro sym m::symbol{t, symstr}; // t's namespace
  macro cat m::family{t};
  if (m::or{
    m::eq{t, type::builtin::string},
    m::eq{t, type::builtin::strlit},
    m::eq{t, type::builtin::cslice{type::builtin::uchar}},
    m::eq{t, type::builtin::slice{type::builtin::uchar}}}) {
    s.append(x);
  } else if (m::eq{m::to_string{sym}, symstr}) {
    sym(x, s);
  } else if (n::is_integral{t}) {
    n::integral_to_decimal(x, s);
  } else if (m::or{
    m::eq{cat, "varray"},
    m::eq{cat, "farray"},
    m::eq{cat, "darray"},
    m::eq{cat, "slice"},
    m::eq{cat, "cslice"}}) {
    s.append("{");
    foreach (size_t i, m::at{t, 0} v : x) {
      if (i != 0) {
	s.append(",");
      }
      append_to_string(v, s);
    }
    s.append("}");
  } else if (m::or{
    m::eq{cat, "tree_map"},
    m::eq{cat, "tree_map_range"},
    m::eq{cat, "tree_map_crange"}}) {
    s.append("{");
    bool first = true;
    foreach (m::at{t, 0} k, m::at{t, 1} v : x) {
      if (first) {
	first = false;
      } else {
	s.append(",");
      }
      append_to_string(k, s);
      s.append(":");
      append_to_string(v, s);
      s.append(")");
    }
    s.append("}");
  } else if (m::or{m::eq{cat, "ptr"}, m::eq{cat, "cptr"},
      m::eq{cat, "tptr"}, m::eq{cat, "tcptr"}}) {
    s.append("{");
    append_to_string(*x, s);
    s.append("}");
  } else if (m::eq{cat, "struct"}) {
    s.append("{");
    bool first = true;
    foreach (name, fld : t) {
      if (first) {
	first = false;
      } else {
	s.append(",");
      }
      s.append(name);
      s.append(":");
      append_to_string(x.fld, s);
    }
    s.append("}");
  } else if (m::eq{cat, "union"}) {
    s.append("{");
    foreach (name, fld : t) {
      if (case x.fld) {
	s.append(name);
	s.append(":");
	append_to_string(x.fld, s);
      }
    }
    s.append("}");
  } else {
    s.append("-");
  }
}

