namespace serialize::string;
public import type::builtin "";
public import meta::builtin m;
public import numeric::cast n;
public import numeric::positional n;

public threaded function {t} string to_string(t const& x)
{
  macro symstr m::concat{t, "_to_string"};
  macro sym1 m::symbol{t, symstr}; // t's namespace
  macro sym2 m::symbol{to_string, symstr}; // our namespace // TODO
  macro cat m::category{t};
  if (m::or{
    m::eq{t, type::builtin::string},
    m::eq{t, type::builtin::strlit},
    m::eq{t, type::builtin::cslice{type::builtin::uchar}},
    m::eq{t, type::builtin::slice{type::builtin::uchar}}}) {
    return x;
  } else if (m::eq{m::to_string{sym1}, symstr}) {
    return sym1(x);
  } else if (m::eq{m::to_string{sym2}, symstr}) {
    return sym2(x);
  } else if (n::is_integral{t}) {
    string s;
    n::integral_to_decimal(x, s);
    return s;
  // } else if (m::eq{cat, "uint"}) {
  //   return bt_ulong_to_string(n::numeric_cast{ulong, t}(x)); // TODO
  // } else if (m::eq{cat, "int"}) {
  //   return bt_long_to_string(n::numeric_cast{long, t}(x)); // TODO
  } else if (m::or{
    m::eq{cat, "varray"},
    m::eq{cat, "farray"},
    m::eq{cat, "darray"},
    m::eq{cat, "slice"},
    m::eq{cat, "cslice"}}) {
    string s = "{";
    foreach (size_t i, m::at{t, 0} v : x) {
      if (i != 0) {
	s.append(",");
      }
      s.append(to_string(v));
    }
    s.append("}");
    return s;
  } else if (m::or{
    m::eq{cat, "tree_map"},
    m::eq{cat, "tree_map_range"},
    m::eq{cat, "tree_map_crange"}}) {
    string s = "{";
    bool first = true;
    foreach (m::at{t, 0} k, m::at{t, 1} v : x) {
      if (first) {
	first = false;
      } else {
	s.append(",");
      }
      s.append(to_string(k));
      s.append(":");
      s.append(to_string(v));
      s.append(")");
    }
    s.append("}");
    return s;
  } else if (m::or{m::eq{cat, "ptr"}, m::eq{cat, "cptr"},
      m::eq{cat, "tptr"}, m::eq{cat, "tcptr"}}) {
    string s = "{";
    s.append(to_string(*x));
    s.append("}");
    return s;
  } else if (m::eq{cat, "struct"}) {
    string s = "{";
    bool first = true;
    foreach (name, fld : t) {
      if (first) {
	first = false;
      } else {
	s.append(",");
      }
      s.append(name);
      s.append(":");
      s.append(to_string(x.fld));
    }
    s.append("}");
    return s;
  } else if (m::eq{cat, "union"}) {
    string s = "{";
    foreach (name, fld : t) {
      if (case x.fld) {
	s.append(name);
	s.append(":");
	s.append(to_string(x.fld));
      }
    }
    s.append("}");
    return s;
  } else {
    return "-";
  }
}

