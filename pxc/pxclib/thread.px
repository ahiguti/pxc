namespace thread;
public import numeric::integral -;
public import pointer -;
public import container::array;
public import exception;
public import meta -;

public multithreaded struct extern "pxcthread::thread_ptr" thread { }
public threaded function {targs} thread create_thread(targs const& args)
{
  tptr{thrdata} r = to_tptr{thrdata_impl{targs}}(thrdata_impl{targs}(args));
  return create_thread_impl(r);
}
public threaded function extern "pxcthread::thread_join"
  void thread_join(thread const& thr);

private multithreaded interface thrdata {
  function void main();
}
private multithreaded struct {targs} thrdata_impl(targs const& a) < thrdata > {
  targs args = a;
  function void main() {
    args.main();
  }
}
private threaded function extern "pxcthread::create_thread_impl"
  thread create_thread_impl(tptr{thrdata} const& f);

extern "types" inline
namespace pxcthread {
struct thread_rep;
typedef pxcrt::rcptr< pxcrt::trcval<thread_rep> > thread_ptr;
};
;

extern "functions" inline
namespace pxcthread {

typedef pxcrt::rcptr< thread$n::thrdata$i > thrdata_ptr;
typedef thread$n::thrdata$i *thrdata_rawptr;

struct thread_rep {
  thread_rep(thrdata_ptr const& m) : tid(), need_join(false), mptr(m) { }
  ~thread_rep() { join(); }
  void join();
  pthread_t tid;
  bool need_join;
  thrdata_ptr mptr;
private:
  thread_rep(const thread_rep&);
  thread_rep& operator =(const thread_rep&);
};

thread_ptr create_thread_impl(thrdata_ptr const& m);
void thread_join(thread_ptr const& t);

};
;

extern "implementation" inline
#define DBG(x)
namespace pxcthread {

void *pxc_thread_child_main(void *arg)
{
  thrdata_rawptr m = static_cast<thrdata_rawptr>(arg);
  /* no need to lock m */
  try {
    try {
      m->main$f();
    } catch (const std::exception& e) {
      std::string mess;
      pxcrt::bt_string s0 = pxcrt::c_exception_message(e);
      mess.insert(mess.end(), s0.begin(), s0.end());
      if (!mess.empty() && mess[mess.size() - 1] != '\n') {
        mess += "\n";
      }
      pxcrt::bt_string st = pxcrt::c_exception_stack_trace(e);
      mess.insert(mess.end(), st.begin(), st.end());
      ::write(2, mess.data(), mess.size());
      //::abort();
    }
  } catch (...) {
    const char *const mess = "thread: uncaught exception\n";
    ::write(2, mess, strlen(mess));
    // ::abort();
  }
  pxcrt::clear_local_pool();
  return 0;
}

thread_ptr create_thread_impl(thrdata_ptr const& m)
{
  thread_ptr thr(thread_ptr::create_rawptr(m));
  thread_rep& impl = thr->value$z;
  if (pthread_create(&impl.tid, 0, pxc_thread_child_main, m.get()) != 0) {
    DBG(fprintf(stderr, "failed to create thread\n"));
  } else {
    DBG(fprintf(stderr, "thread create\n"));
    impl.need_join = true;
  }
  return thr;
}

void thread_join(thread_ptr const& t)
{
  if (t.get() == 0) {
    return;
  }
  pxcrt::guard_val<thread_ptr> grd(t);
  grd.get()->value$z.join();
}

void thread_rep::join()
{
  if (!need_join) {
    DBG(fprintf(stderr, "no need to join\n"));
    return;
  }
  if (tid == pthread_self()) {
    DBG(fprintf(stderr, "detach\n"));
    const int e = pthread_detach(tid);
    assert(e == 0);
  } else {
    DBG(fprintf(stderr, "join\n"));
    const int e = pthread_join(tid, 0);
    assert(e == 0);
  }
  need_join = false;
}

};
#undef DBG
;

