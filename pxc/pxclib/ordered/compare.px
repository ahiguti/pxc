namespace ordered::compare;
public import numeric::integral -;
public import numeric::fp -;
public import numeric::union_tag -;
public import container::string -;
public import meta::common m;
public import meta::family mf;

public threaded function {t} int compare(t const& x, t const& y)
{
  metafunction symstr m::concat{t, "_compare"};
  metafunction sym m::symbol{symstr, t};
  metafunction fam m::family{t};
  if (m::eq{m::to_string{sym}, symstr}) {
    return sym(x, y);
  } else if (m::eq{t, unit}) {
    return 0;
  } else if (mf::is_string_family_type{t}) {
    if (m::eq{t, string}) {
      return memcmp_string(x, y);
    } else if (m::eq{t, strlit}) {
      return memcmp_strlit(x, y);
    } else if (m::eq{t, strref}) {
      return memcmp_strref(x, y);
    } else if (m::eq{t, cstrref}) {
      return memcmp_cstrref(x, y);
    } else {
      return m::error{"internal error"};
    }
  } else if (m::or{
    m::eq{fam, "builtin"}, m::eq{fam, "int"}, m::eq{fam, "uint"},
    m::eq{fam, "float"}, m::eq{fam, "numeric"}}) {
    return x < y ? -1 : x > y ? 1 : 0;
  } else if (m::eq{fam, "farray"}) {
    size_t const sz = m::at{t, 1};
    size_t i = 0;
    for (i = 0; i < n; ++i) {
      int const c = compare(x[i], y[i]);
      if (c != 0) {
	return c;
      }
    }
    return 0;
  } else if (m::or{m::eq{fam, "varray"}, m::eq{fam, "darray"}}) {
    size_t const xsz = x.size();
    size_t const ysz = y.size();
    size_t const sz = xsz < ysz ? xsz : ysz;
    size_t i = 0;
    for (i = 0; i < n; ++i) {
      int const c = compare(x[i], y[i]);
      if (c != 0) {
	return c;
      }
    }
    if (xsz > sz) {
      return -1;
    } else if (ysz > sz) {
      return 1;
    }
    return 0;
  } else if (m::eq{fam, "tree_map"}) {
    return m::error{"not implemented for tree_map"};
  } else if (m::eq{fam, "struct"}) {
    expand (fld, idx : m::field_names{t}) {
      {
	int const c = compare(x.fld, y.fld);
	if (c != 0) {
	  return c;
	}
      }
    }
    return 0;
  } else if (m::eq{fam, "union"}) {
    int const tc = compare(union_tag(x), union_tag(y));
    if (tc != 0) {
      return tc;
    }
    expand (fld, idex : m::field_names{t}) {
      {
	if (case x.fld) {
	  int const c = compare(x.fld, y.fld);
	  if (c != 0) {
	    return c;
	  }
	}
      }
    }
    return 0;
  } else {
    return m::error{m::concat{"not implemented for type '", t, "'"}};
  }
}

