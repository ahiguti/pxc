namespace type::impl::slice;
import type::impl::stdvector;
import type::impl::pxcvector;
import type::impl::farray;

extern "type" inline
namespace array {
template <typename T>
struct slice {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::refvar_igrd;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd;
  typedef size_t size_type;
  slice() : v(0), len(0) { }
  explicit slice(stdvector<T>& x) : v(x.rawarr()), len(x.size()) { }
  explicit slice(pxcvector<T>& x) : v(x.rawarr()), len(x.size()) { }
  template <typename Ta, size_t sz>
  slice(farray<Ta, sz>& x) : v(x.rawarr()), len(sz) { }
  template <typename Tc> slice(Tc& c, size_t o1, size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  size_type size() const { return len; }
  void next() {
    if (len == 0) { pxcrt::throw_invalid_index(); }
    ++v;
    --len;
  }
  T& operator [](size_type idx) const {
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  T& operator *() const {
    if (len == 0) { pxcrt::throw_invalid_index(); }
    return *v;
  }
  T *rawarr() const { return v; }
private:
  T *v;
  size_t len;
};
template <typename T>
struct cslice {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::refvar_igrd;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd;
  typedef size_t size_type;
  cslice() : v(0), len(0) { }
  cslice(const slice<T>& x) : v(x.rawarr()), len(x.size()){ }
  explicit cslice(const stdvector<T>& x) : v(x.rawarr()), len(x.size()) { }
  explicit cslice(const pxcvector<T>& x) : v(x.rawarr()), len(x.size()) { }
  template <typename Tc> cslice(const Tc& c, size_t o1, size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  size_type size() const { return len; }
  const T& operator [](size_type idx) const {
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  const T& operator *() const {
    if (len == 0) { pxcrt::throw_invalid_index(); }
    return *v;
  }
  const T *rawarr() const { return v; }
private:
  const T *v;
  size_t len;
};
}; // namespace array

