namespace type::impl::stdmap;
public import type::builtin;

extern "type" inline
#include <map>
#include <stdint.h>
#include <stdio.h>
namespace tree_map {
template <typename Tf>
struct compare_less {
  Tf f;
  template <typename Tk>
  inline bool operator () (const Tk& x, const Tk& y) const {
    return f.call$f(x, y) < 0;
  }
};
template <typename Tk, typename Tm, typename Tf> struct tree_map_range;
template <typename Tk, typename Tm, typename Tf> struct tree_map_crange;
template <typename Tk, typename Tm, typename Tf>
struct tree_map_compare {
  template <typename Tc> friend struct pxcrt::guard_ref;
  template <typename Tc> friend struct pxcrt::guard_val;
  typedef std::map< Tk, Tm, compare_less<Tf> > map_type;
  typedef typename map_type::size_type size_type;
  typedef typename map_type::iterator iterator;
  typedef typename map_type::const_iterator const_iterator;
  typedef tree_map_range<Tk, Tm, Tf> range_type;
  typedef tree_map_crange<Tk, Tm, Tf> crange_type;
  tree_map_compare() : invalidate_guard_count(0) { }
  tree_map_compare(const tree_map_compare& x)
    : v(x.v), invalidate_guard_count(0) { }
  tree_map_compare(const range_type& x)
    : v(x.begin(), x.end()), invalidate_guard_count(0) { }
  tree_map_compare(const crange_type& x)
    : v(x.begin(), x.end()), invalidate_guard_count(0) { }
  tree_map_compare& operator =(const tree_map_compare& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  Tm& operator [](const Tk& k) { return v[k]; }
  Tm value_at(const Tk& k) { return v[k]; }
  iterator find(const Tk& k) { return v.find(k); }
  const_iterator find(const Tk& k) const { return v.find(k); }
  crange_type equal_range(const Tk& k) const {
    const std::pair<const_iterator, const_iterator> r = v.equal_range(k);
    return crange_type(r.first, r.second);
  }
  range_type equal_range(const Tk& k) {
    const std::pair<iterator, iterator> r = v.equal_range(k);
    return range_type(r.first, r.second);
  }
  size_type size() const { return v.size(); }
  void erase(const Tk& k) {
    check_resize();
    v.erase(k);
  }
  void clear() {
    check_resize();
    v.clear();
  }
  iterator begin() { return v.begin(); }
  const_iterator begin() const { return v.begin(); }
  iterator end() { return v.end(); }
  const_iterator end() const { return v.end(); }
private:
  void check_resize() {
    if (invalidate_guard_count != 0) { pxcrt::throw_would_invalidate(); }
  }
  void inc_invalidate_guard() const { ++invalidate_guard_count; }
  void dec_invalidate_guard() const { --invalidate_guard_count; }
private:
  map_type v;
  mutable size_t invalidate_guard_count;
};
}; // namespace tree_map

