namespace type::impl::pxcvector;
public import type::impl::array_common;

extern "type" inline
namespace array {
template <typename T>
struct pxcvector {
  template <typename Tc> friend struct pxcrt::guard_ref;
  template <typename Tc> friend struct pxcrt::guard_val;
  typedef pxcrt::bt_size_t size_type;
  typedef T *iterator;
  typedef const T *const_iterator;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  pxcvector() : start(0), valid_len(0), alloc_len(0), invalidate_guard_count(0)
    { }
  ~pxcvector() {
    deinitialize_n(start, valid_len);
    deallocate_uninitialized(start);
  }
  pxcvector(const pxcvector& x) {
    construct_internal(x.start, x.valid_len);
  }
  pxcvector(const crange_type& x) {
    construct_internal(x.rawarr(), x.size());
  }
  pxcvector(const range_type& x) {
    construct_internal(x.rawarr(), x.size());
  }
  pxcvector& operator =(const pxcvector& x) {
    check_resize();
    if (&x != this) {
      clear_internal();
      append_internal(x.start, x.valid_len);
    }
    return *this;
  }
  bool empty() const { return valid_len == 0; }
  size_type size() const { return valid_len; }
  T& operator [](size_type idx) {
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    return start[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    return start[idx];
  }
  T value_at(size_type idx) const {
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    return start[idx];
  }
  void resize(size_type sz, T const& x) {
    check_resize();
    if (sz > valid_len) {
      reserve_internal(sz);
      initialize_fill_n(start + valid_len, sz - valid_len, x);
    } else {
      deinitialize_n(start + sz, valid_len - sz);
    }
    valid_len = sz;
  }
  void clear() {
    check_resize();
    clear_internal();
  }
  void push_back(T const& x) {
    check_resize();
    reserve_internal(valid_len + 1);
    initialize_1(start + valid_len, x);
    ++valid_len;
  }
  T pop_back() {
    check_resize();
    if (empty()) { pxcrt::throw_invalid_index(); }
    const T r = start[valid_len - 1];
    deinitialize_1(start + valid_len);
    --valid_len;
    return r;
  }
  void reserve(size_type sz) {
    check_resize();
    reserve_internal(sz);
  }
  void append(const crange_type& x) {
    check_resize();
    append_internal(x.rawarr(), x.size());
  }
  void insert(size_type pos, const crange_type& x) {
    check_resize();
    insert_internal(pos, x.rawarr(), x.size());
  }
  void erase(size_type first, size_type last) {
    check_resize();
    erase_internal(first, last);
  }
  iterator begin() { return start; }
  const_iterator begin() const { return start; }
  iterator end() { return start + valid_len; }
  const_iterator end() const { return start + valid_len; }
  T *rawarr() { return start; }
  const T *rawarr() const { return start; }
private:
  void construct_internal(const T *ptr, size_type len) {
    invalidate_guard_count = 0;
    alloc_len = valid_len = len;
    start = allocate_uninitialized<T>(valid_len);
    if (is_trivially_copyable<T>::value) {
      initialize_copy_n(start, valid_len, ptr);
    } else {
      try {
	initialize_copy_n(start, valid_len, ptr);
      } catch (...) {
	deallocate_uninitialized(start);
	throw;
      }
    }
  }
  void clear_internal() {
    deinitialize_n(start, valid_len);
    valid_len = 0;
  }
  void append_internal(const T *p, size_type len) {
    size_type nlen = valid_len + len;
    reserve_internal(nlen);
    initialize_copy_n(start + valid_len, len, p);
    valid_len = nlen;
  }
  void insert_internal(size_type pos, const T *p, size_type plen) {
    if (plen == 0) {
      return;
    }
    if (pos >= valid_len) {
      pos = valid_len;
    }
    const size_type vlen = valid_len;
    const size_type nlen = vlen + plen;
    if (nlen < vlen) {
      pxcrt::throw_bad_alloc(); /* overflow */
    }
    reserve_internal(nlen);
    if (vlen - pos >= plen) {
      initialize_copy_n(start + valid_len, plen, start + vlen - plen);
      valid_len = nlen;
      copy_backward_n(start + pos + plen, vlen - plen - pos, start + pos);
      copy_n(start + pos, plen, p);
    } else {
      initialize_copy_n(start + valid_len, plen - (vlen - pos),
	p + (vlen - pos));
      valid_len = pos + plen;
      initialize_copy_n(start + valid_len, vlen - pos, start + pos);
      valid_len = nlen;
      copy_n(start + pos, vlen - pos, p);
    }
  }
  void erase_internal(size_type first, size_type last) {
    if (last >= valid_len) {
      last = valid_len;
    }
    if (first >= last) {
      return;
    }
    const size_type elen = last - first;
    copy_n(start + first, valid_len - last, start + last);
    deinitialize_n(start + valid_len - elen, elen);
    valid_len -= elen;
  }
  void reserve_internal(size_type len) {
    if (len <= alloc_len) {
      return;
    }
    size_type nl = alloc_len;
    do {
      const size_type nl_n = (nl >= 1) ? (nl * 2) : 1;
      const size_type max_len = ((size_t)-1) / sizeof(T);
      if (nl_n <= nl || nl_n > max_len) {
        throw std::bad_alloc(); /* overflow */
      }
      nl = nl_n;
    } while (nl < len);
    start = reserve_n(start, valid_len, nl);
    alloc_len = nl;
  }
  void check_resize() {
    if (invalidate_guard_count != 0) { pxcrt::throw_would_invalidate(); }
  }
  void inc_invalidate_guard() const {
    ++invalidate_guard_count;
  }
  void dec_invalidate_guard() const {
    --invalidate_guard_count;
  }
private:
  T *start;
  size_type valid_len;
  size_type alloc_len;
  mutable size_type invalidate_guard_count;
};
}; // namespace array

