namespace type::impl::darray;
public import type::impl::array_common;

extern "type" inline
namespace array {
template <typename T>
struct darray {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  typedef pxcrt::bt_size_t size_type;
  typedef T *iterator;
  typedef const T *const_iterator;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  ~darray() {
    deinitialize_n(start, valid_len);
    deallocate_uninitialized(start);
  }
  darray(size_type len, const T& val) {
    valid_len = len;
    start = allocate_uninitialized<T>(valid_len);
    if (is_trivially_copyable<T>::value) {
      initialize_fill_n(start, valid_len, val);
    } else {
      try {
	initialize_fill_n(start, valid_len, val);
      } catch (...) {
	deallocate_uninitialized(start);
	throw;
      }
    }
  }
  darray(const darray& x) {
    valid_len = x.valid_len;
    start = allocate_uninitialized<T>(valid_len);
    if (is_trivially_copyable<T>::value) {
      initialize_copy_n(start, valid_len, x.start);
    } else {
      try {
	initialize_copy_n(start, valid_len, x.start);
      } catch (...) {
	deallocate_uninitialized(start);
	throw;
      }
    }
  }
  bool empty() const { return valid_len == 0; }
  size_type size() const { return valid_len; }
  T& operator [](size_type idx) {
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    return start[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    return start[idx];
  }
  iterator begin() { return start; }
  const_iterator begin() const { return start; }
  iterator end() { return start + valid_len; }
  const_iterator end() const { return start + valid_len; }
  T *rawarr() { return start; }
  const T *rawarr() const { return start; }
private:
  T *start;
  size_type valid_len;
  darray(); /* not allowed */
  darray& operator =(const darray& x); /* not allowed */
};
}; // namespace array

