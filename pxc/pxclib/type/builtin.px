namespace type::builtin;
public import compiler::runtime;

public extern "@0void" "@0void" struct void { }
public extern "@0unit" "@0unit" struct unit { }
public extern "@0bool" "@0bool" struct bool { }
public extern "@0uchar" "@0uchar" struct uchar { }
public extern "@0char" "@0char" struct char { }
public extern "@0ushort" "@0ushort" struct ushort { }
public extern "@0short" "@0short" struct short { }
public extern "@0uint" "@0uint" struct uint { }
public extern "@0int" "@0int" struct int { }
public extern "@0ulong" "@0ulong" struct ulong { }
public extern "@0long" "@0long" struct long { }
public extern "@0size_t" "@0size_t" struct size_t { }
public extern "@0float" "@0float" struct float { }
public extern "@0double" "@0double" struct double { }
public extern "@0string" "@0string" struct string { }
public extern "@0strlit" "@0strlit" struct strlit { }
public macro slice{t} compiler::runtime::bt_slice{t};
public macro cslice{t} compiler::runtime::bt_cslice{t};
public macro strref slice{uchar};
public macro cstrref cslice{uchar};

public threaded extern "pxcrt::ptr" "ptr" struct {t} ptr { } 
public threaded extern "pxcrt::cptr" "cptr" struct {t} cptr { }
public valuetype extern "pxcrt::iptr" "iptr" struct {t} iptr { }
public multithreaded extern "pxcrt::tptr" "tptr" struct {t} tptr { }
public multithreaded extern "pxcrt::tcptr" "tcptr" struct {t} tcptr { }
public tsvaluetype extern "pxcrt::tiptr" "tiptr" struct {t} tiptr { }

public mtvaluetype extern "pxcrt::lockobject" "lockobject"
  struct {t} lockobject { }
public mtvaluetype extern "pxcrt::clockobject" "clockobject"
  struct {t} clockobject { }

public threaded extern "pxcrt::bool_append_to_string"
  function void bt_bool_append_to_string(bool x, string& s);
public threaded extern "pxcrt::float_append_to_string"
  function void bt_float_append_to_string(float x, string& s);
public threaded extern "pxcrt::double_append_to_string"
  function void bt_double_append_to_string(double x, string& s);

public threaded extern "pxcrt::string_to_unit"
  function unit string_to_bt_unit(cstrref const& x);
public threaded extern "pxcrt::string_to_bool"
  function bool string_to_bt_bool(cstrref const& x);
public threaded extern "pxcrt::string_to_uchar"
  function uchar string_to_bt_ucahr(cstrref const& x);
public threaded extern "pxcrt::string_to_char"
  function char string_to_bt_char(cstrref const& x);
public threaded extern "pxcrt::string_to_ushort"
  function ushort string_to_bt_ushort(cstrref const& x);
public threaded extern "pxcrt::string_to_short"
  function short string_to_bt_short(cstrref const& x);
public threaded extern "pxcrt::string_to_uint"
  function uint string_to_bt_uint(cstrref const& x);
public threaded extern "pxcrt::string_to_int"
  function int string_to_bt_int(cstrref const& x);
public threaded extern "pxcrt::string_to_ulong"
  function ulong string_to_bt_ulong(cstrref const& x);
public threaded extern "pxcrt::string_to_long"
  function long string_to_bt_long(cstrref const& x);
public threaded extern "pxcrt::string_to_float"
  function float string_to_bt_float(cstrref const& x);
public threaded extern "pxcrt::string_to_double"
  function double string_to_bt_double(cstrref const& x);
public threaded extern "pxcrt::string_to_size_t"
  function size_t string_to_bt_size_t(cstrref const& x);

extern "type" inline
#include <string>
#include <stdint.h>
#include <stdexcept>
#include <stdio.h>
#include <pthread.h>
#include <assert.h>
#include <unistd.h>
#ifdef PXCRT_DBG_RC
#define DBG_RC(x) x
#else
#define DBG_RC(x)
#endif
#ifdef PXCRT_DBG_MTX
#define DBG_MTX(x) x
#else
#define DBG_MTX(x)
#endif
namespace pxcrt {
struct mutex {
  mutex() {
    init();
  }
  mutex(const mutex&) {
    init();
  }
  mutex& operator =(const mutex&) {
    return *this;
  }
  ~mutex() {
    const int __attribute__((unused)) e = pthread_mutex_destroy(&mtx);
    assert(e == 0);
  }
  void lock() {
    DBG_MTX(fprintf(stderr, "lock %p\n", &mtx));
    const int __attribute__((unused)) e = pthread_mutex_lock(&mtx);
    assert(e == 0);
  }
  void unlock() {
    DBG_MTX(fprintf(stderr, "unlock %p\n", &mtx));
    const int __attribute__((unused)) e = pthread_mutex_unlock(&mtx);
    assert(e == 0);
  }
private:
  void init() {
    pthread_mutexattr_t mattr;
    pthread_mutexattr_init(&mattr);
    pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);
    const int e = pthread_mutex_init(&mtx, &mattr);
    pthread_mutexattr_destroy(&mattr);
    if (e != 0) {
      throw std::runtime_error("pthread_mutex_init"); // FIXME
    }
  }
private:
  pthread_mutex_t mtx;
};
struct mtcount { /* reference counter for multi-threaded objects */ 
  mtcount() : count$z(1) { }
  void incref$z() { __sync_fetch_and_add(&count$z, 1); } /* gcc >= 4 */
  bool decref$z() { return (__sync_fetch_and_add(&count$z, -1) == 1); }
private:
  long count$z;
};
struct stcount { /* reference counter for single-threaded objects */
  stcount() : count$z(1) { }
  void incref$z() { ++count$z; }
  bool decref$z() { return (--count$z == 0); }
private:
  long count$z;
};
template <typename T> struct uninit_mem { char value[sizeof(T)]; };
/* NOTE: emit_vardef_constructor_fast_boxing() depends on the internals
 * of rcval/trcval/tircval. */
template <typename T>
struct rcval {
  /* rcval: single threaded, mutable and immutable */
  typedef T value_type;
  rcval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit rcval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  rcval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  rcval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  rcval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (count$z.decref$z()) {
      delete this;
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  void lock$z() const { }
  void unlock$z() const { }
public:
  mutable stcount count$z;
public:
  T value$z;
private:
  rcval(const rcval&);
  rcval& operator =(const rcval&);
};
template <typename T>
struct trcval {
  /* trcval: multithreaded, mutable */
  typedef T value_type;
  trcval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit trcval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  trcval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  trcval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  trcval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (count$z.decref$z()) {
      delete this;
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  void lock$z() const { mutex$z.lock(); }
  void unlock$z() const { mutex$z.unlock(); }
public:
  mutable mtcount count$z;
  mutable mutex mutex$z;
public:
  T value$z;
private:
  trcval(const trcval&);
  trcval& operator =(const trcval&);
};
template <typename T>
struct tircval {
  /* tircval: multithreded, immutable */
  typedef T value_type;
  tircval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit tircval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  tircval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  tircval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  tircval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (count$z.decref$z()) {
      delete this;
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  void lock$z() const { }
  void unlock$z() const { }
public:
  mutable mtcount count$z;
public:
  T value$z;
private:
  tircval(const tircval&);
  tircval& operator =(const tircval&);
};
template <typename T>
struct rcptr { /* T must have an intrusive count */
  typedef void range_type; /* guard object requires this */
  typedef void crange_type; /* guard object requires this */
  template <typename Tx> friend struct rcptr;
  rcptr() : ptr(0) { }
  rcptr(T *rawptr) : ptr(rawptr) { } /* for fast boxing constr */
  rcptr(const rcptr& x) : ptr(x.ptr) { if (ptr) ptr->incref$z(); }
  /* ptr{foo} to ptr{ifoo} */
  template <typename Tx> rcptr(const rcptr<Tx>& x) : ptr(x.get()) {
    if (ptr) ptr->incref$z();
  }
  /* boxing foo to ptr{ifoo} */
  template <typename Tx> explicit rcptr(const Tx& x) : ptr(new T(x)) { }
  ~rcptr() { if (ptr) ptr->decref$z(); }
  rcptr& operator =(T *x) { return set(x); }
  template <typename Tx> rcptr& operator =(Tx *x) { return set(x); }
  rcptr& operator =(const rcptr& x) { return set(x.ptr); }
  template <typename Tx> rcptr& operator =(const rcptr<Tx>& x) {
    return set(x.ptr);
  }
  T *get() const { return ptr; }
  T& operator *() const { return *ptr; }
  T *operator ->() const { return ptr; }
  void inc_invalidate_guard() const { ptr->lock$z(); }
  void dec_invalidate_guard() const { ptr->unlock$z(); }
private:
  T *ptr;
private:
  rcptr& set(T *x) {
    if (x) x->incref$z();
    if (ptr) ptr->decref$z();
    ptr = x;
    return *this;
  }
};
template <typename T> struct lockobject
{
  lockobject(const rcptr<T>& p) : ptr(p), objref(*p) { objref.lock$z(); }
  ~lockobject() { objref.unlock$z(); }
  T *get() const { return &objref; }
  T& operator *() const { return objref; }
  T *operator ->() const { return &objref; }
private:
  lockobject(const lockobject&);
  lockobject& operator =(const lockobject&);
private:
  rcptr<T> ptr;
  T& objref;
};
template <typename T> typename T::value_type deref_value$z(const rcptr<T>& p)
{
  return p->value$z;
}
template <typename T> T deref(const rcptr<T>& p)
{
  return *p;
}
}; // namespace pxcrt

extern "fdecl" inline
namespace pxcrt {
}; // namespace pxcrt

extern "fdef" inline
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <boost/lexical_cast.hpp>
#include <boost/range/iterator_range.hpp>
namespace pxcrt {
void bool_append_to_string(bt_bool v, bt_string& s)
{
  static const bt_strlit str_t("true");
  static const bt_strlit str_f("false");
  s.append(v ? str_t : str_f);
}
void double_append_to_string(bt_double v, bt_string& s)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%f", v);
  s.append(reinterpret_cast<const unsigned char *>(buf), len);
}
void float_append_to_string(bt_float v, bt_string& s)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%f", double(v));
  s.append(reinterpret_cast<const unsigned char *>(buf), len);
}
bt_unit string_to_unit(const bt_string& v)
{
  return bt_unit();
}
bt_bool string_to_bool(const bt_string& v)
{
  const bt_size_t len = v.size();
  if (len == 4 && memcmp(v.rawarr(), "true", 4) == 0) {
    return true;
  }
  if (len == 5 && memcmp(v.rawarr(), "false", 5) == 0) {
    return false;
  }
  if (len == 1 && v.rawarr()[0] == '0') {
    return false;
  }
  return true;
}
template <typename Tt, typename Tf> inline Tt
string_to_numeric_tmpl(const Tf& a)
{
  const char *const p = reinterpret_cast<const char *>(a.rawarr());
  const size_t len = a.size();
  return boost::lexical_cast<Tt>(boost::make_iterator_range(p, p + len));
}
bt_uchar string_to_uchar(const cstrref& v)
  { return string_to_numeric_tmpl<bt_uchar, cstrref>(v); }
bt_char string_to_char(const cstrref& v)
  { return string_to_numeric_tmpl<bt_char, cstrref>(v); }
bt_ushort string_to_ushort(const cstrref& v)
  { return string_to_numeric_tmpl<bt_ushort, cstrref>(v); }
bt_short string_to_short(const cstrref& v)
  { return string_to_numeric_tmpl<bt_short, cstrref>(v); }
bt_uint string_to_uint(const cstrref& v)
  { return string_to_numeric_tmpl<bt_uint, cstrref>(v); }
bt_int string_to_int(const cstrref& v)
  { return string_to_numeric_tmpl<bt_int, cstrref>(v); }
bt_ulong string_to_ulong(const cstrref& v)
  { return string_to_numeric_tmpl<bt_ulong, cstrref>(v); }
bt_long string_to_long(const cstrref& v)
  { return string_to_numeric_tmpl<bt_long, cstrref>(v); }
bt_double string_to_double(const cstrref& v)
  { return string_to_numeric_tmpl<bt_double, cstrref>(v); }
bt_float string_to_float(const cstrref& v)
  { return string_to_numeric_tmpl<bt_float, cstrref>(v); }
bt_size_t string_to_size_t(const cstrref& v)
  { return string_to_numeric_tmpl<bt_size_t, cstrref>(v); }
}; // namespace pxcrt

