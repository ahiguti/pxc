namespace type::builtin;

public extern "@0void" "@0void" struct void { }
public extern "@0unit" "@0unit" struct unit { }
public extern "@0bool" "@0bool" struct bool { }
public extern "@0uchar" "@0uchar" struct uchar { }
public extern "@0char" "@0char" struct char { }
public extern "@0ushort" "@0ushort" struct ushort { }
public extern "@0short" "@0short" struct short { }
public extern "@0uint" "@0uint" struct uint { }
public extern "@0int" "@0int" struct int { }
public extern "@0ulong" "@0ulong" struct ulong { }
public extern "@0long" "@0long" struct long { }
public extern "@0size_t" "@0size_t" struct size_t { }
public extern "@0float" "@0float" struct float { }
public extern "@0double" "@0double" struct double { }
public extern "@0string" "@0string" struct string { }
public extern "@0strlit" "@0strlit" struct strlit { }
public macro slice{t} compiler::runtime::bt_slice{t};
public macro cslice{t} compiler::runtime::bt_cslice{t};

public threaded extern "pxcrt::ptr" "ptr" struct {t} ptr { } 
public threaded extern "pxcrt::cptr" "cptr" struct {t} cptr { }
public valuetype extern "pxcrt::iptr" "iptr" struct {t} iptr { }
public multithreaded extern "pxcrt::tptr" "tptr" struct {t} tptr { }
public multithreaded extern "pxcrt::tcptr" "tcptr" struct {t} tcptr { }
public tsvaluetype extern "pxcrt::tiptr" "tiptr" struct {t} tiptr { }

public threaded extern "pxcrt::unit_to_string"
  function string bt_unit_to_string(unit x);
public threaded extern "pxcrt::bool_to_string"
  function string bt_bool_to_string(bool x);
public threaded extern "pxcrt::uchar_to_string"
  function string bt_uchar_to_string(uchar x);
public threaded extern "pxcrt::char_to_string"
  function string bt_char_to_string(char x);
public threaded extern "pxcrt::ushort_to_string"
  function string bt_ushort_to_string(ushort x);
public threaded extern "pxcrt::short_to_string"
  function string bt_short_to_string(short x);
public threaded extern "pxcrt::uint_to_string"
  function string bt_uint_to_string(uint x);
public threaded extern "pxcrt::int_to_string"
  function string bt_int_to_string(int x);
public threaded extern "pxcrt::ulong_to_string"
  function string bt_ulong_to_string(ulong x);
public threaded extern "pxcrt::long_to_string"
  function string bt_long_to_string(long x);
public threaded extern "pxcrt::size_t_to_string"
  function string bt_size_t_to_string(size_t x);
public threaded extern "pxcrt::float_to_string"
  function string bt_float_to_string(float x);
public threaded extern "pxcrt::double_to_string"
  function string bt_double_to_string(double x);

public threaded extern "pxcrt::string_to_unit"
  function unit string_to_bt_unit(string const& x);
public threaded extern "pxcrt::string_to_bool"
  function bool string_to_bt_bool(string const& x);
public threaded extern "pxcrt::string_to_uchar"
  function uchar string_to_bt_ucahr(string const& x);
public threaded extern "pxcrt::string_to_char"
  function char string_to_bt_char(string const& x);
public threaded extern "pxcrt::string_to_ushort"
  function ushort string_to_bt_ushort(string const& x);
public threaded extern "pxcrt::string_to_short"
  function short string_to_bt_short(string const& x);
public threaded extern "pxcrt::string_to_uint"
  function uint string_to_bt_uint(string const& x);
public threaded extern "pxcrt::string_to_int"
  function int string_to_bt_int(string const& x);
public threaded extern "pxcrt::string_to_ulong"
  function ulong string_to_bt_ulong(string const& x);
public threaded extern "pxcrt::string_to_long"
  function long string_to_bt_long(string const& x);
public threaded extern "pxcrt::string_to_float"
  function float string_to_bt_float(string const& x);
public threaded extern "pxcrt::string_to_double"
  function double string_to_bt_double(string const& x);
public threaded extern "pxcrt::string_to_size_t"
  function size_t string_to_bt_size_t(string const& x);

extern "type" inline
#include <string>
#include <stdint.h>
#include <stdexcept>
#include <stdio.h>
#include <pthread.h>
#include <assert.h>
#include <unistd.h>
#ifdef PXCRT_DBG_RC
#define DBG_RC(x) x
#else
#define DBG_RC(x)
#endif
#ifdef PXCRT_DBG_MTX
#define DBG_MTX(x) x
#else
#define DBG_MTX(x)
#endif
namespace pxcrt {
struct mutex {
  friend struct lockobject;
  mutex() {
    init();
  }
  mutex(const mutex&) {
    init();
  }
  mutex& operator =(const mutex&) {
    return *this;
  }
  ~mutex() {
    const int __attribute__((unused)) e = pthread_mutex_destroy(&mtx);
    assert(e == 0);
  }
  void lock() {
    DBG_MTX(fprintf(stderr, "lock %p\n", &mtx));
    const int __attribute__((unused)) e = pthread_mutex_lock(&mtx);
    assert(e == 0);
  }
  void unlock() {
    DBG_MTX(fprintf(stderr, "unlock %p\n", &mtx));
    const int __attribute__((unused)) e = pthread_mutex_unlock(&mtx);
    assert(e == 0);
  }
private:
  void init() {
    pthread_mutexattr_t mattr;
    pthread_mutexattr_init(&mattr);
    pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);
    const int e = pthread_mutex_init(&mtx, &mattr);
    pthread_mutexattr_destroy(&mattr);
    if (e != 0) {
      throw std::runtime_error("pthread_mutex_init"); // FIXME
    }
  }
private:
  pthread_mutex_t mtx;
};
struct lockobject {
  lockobject(mutex& x) : m(x) { m.lock(); }
  ~lockobject() { m.unlock(); }
private:
  mutex& m;
private:
  lockobject(lockobject&);
  lockobject& operator =(lockobject&);
};
struct nomutex { };
struct mtcount {
  mtcount() : count$z(1) { }
  void incref$z() { __sync_fetch_and_add(&count$z, 1); } /* gcc >= 4 */
  bool decref$z() { return (__sync_fetch_and_add(&count$z, -1) == 1); }
private:
  long count$z;
};
struct stcount {
  stcount() : count$z(1) { }
  void incref$z() { ++count$z; }
  bool decref$z() { return (--count$z == 0); }
private:
  long count$z;
};
struct boxing { };
template <typename T>
struct rcval { /* single threaded, mutable and immutable */
  rcval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit rcval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0>
  rcval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  rcval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  rcval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (count$z.decref$z()) {
      delete this;
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  nomutex& get_mutex$z() const { return mutex$z; }
private:
  mutable stcount count$z;
  mutable nomutex mutex$z;
public:
  T value$z;
private:
  rcval(const rcval&);
  rcval& operator =(const rcval&);
};
template <typename T>
struct trcval { /* multithreaded, mutable */
  trcval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit trcval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0>
  trcval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  trcval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  trcval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (count$z.decref$z()) {
      delete this;
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  mutex& get_mutex$z() const { return mutex$z; }
private:
  mutable mtcount count$z;
  mutable mutex mutex$z;
public:
  T value$z;
private:
  trcval(const trcval&);
  trcval& operator =(const trcval&);
};
template <typename T>
struct tircval { /* multithreded, immutable */
  tircval() : value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit tircval(const T& v) : value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0>
  tircval(const T0& a0) : value$z(a0) { }
  template <typename T0, typename T1>
  tircval(const T0& a0, const T1& a1) : value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  tircval(const T0& a0, const T1& a1, const T2& a2) : value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (count$z.decref$z()) {
      delete this;
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  mutex& get_mutex$z() const { return mutex$z; }
private:
  mutable mtcount count$z;
  mutable nomutex mutex$z;
public:
  T value$z;
private:
  tircval(const tircval&);
  tircval& operator =(const tircval&);
};
template <typename T>
struct rcptr { /* T must have an intrusive count */
  typedef T value_type;
  template <typename Tx> friend struct rcptr;
  rcptr() : ptr(0) { }
  rcptr(const rcptr& x) : ptr(x.ptr) { if (ptr) ptr->incref$z(); }
  /* rcptr(T *x) : ptr(x) { if (ptr) ptr->incref$z(); } */
  /* ptr{foo} to ptr{ifoo} */
  template <typename Tx> rcptr(const rcptr<Tx>& x) : ptr(x.get()) {
    if (ptr) ptr->incref$z();
  }
  /* boxing foo to ptr{ifoo} */
  template <typename Tx> explicit rcptr(const Tx& x) : ptr(new T(x)) { }
  /* boxing */
  rcptr(const boxing& c) : ptr(new T()) { }
  template <typename T0>
  rcptr(const boxing& c, const T0& a0)
    : ptr(new T(a0)) { }
  template <typename T0, typename T1>
  rcptr(const boxing& c, const T0& a0, const T1& a1)
    : ptr(new T(a0, a1)) { }
  template <typename T0, typename T1, typename T2>
  rcptr(const boxing& c, const T0& a0, const T1& a1, const T2& a2)
    : ptr(new T(a0, a1, a2)) { }
  ~rcptr() { if (ptr) ptr->decref$z(); }
  rcptr& operator =(T *x) { return set(x); }
  template <typename Tx> rcptr& operator =(Tx *x) { return set(x); }
  rcptr& operator =(const rcptr& x) { return set(x.ptr); }
  template <typename Tx> rcptr& operator =(const rcptr<Tx>& x) {
    return set(x.ptr);
  }
  operator T *() const { return ptr; }
  T *get() const { return ptr; }
  T& operator *() const { return *ptr; }
  T *operator ->() const { return ptr; }
private:
  T *ptr;
private:
  rcptr& set(T *x) {
    if (x) x->incref$z();
    if (ptr) ptr->decref$z();
    ptr = x;
    return *this;
  }
};
}; // namespace pxcrt

extern "fdecl" inline
namespace pxcrt {
}; // namespace pxcrt

extern "fdef" inline
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <boost/lexical_cast.hpp>
#include <boost/range/iterator_range.hpp>
namespace pxcrt {
const bt_unit unit_value = bt_unit();
bt_string void_to_string(void)
{
  return bt_string();
}
bt_string unit_to_string(bt_unit x)
{
  return bt_string();
}
bt_string bool_to_string(bt_bool v)
{
  static const bt_strlit str_t("true");
  static const bt_strlit str_f("false");
  return v ? str_t : str_f;
}
bt_string uchar_to_string(bt_uchar v)
{
  char buf[4];
  const int len = snprintf(buf, sizeof(buf), "%hhu", (unsigned char)v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string char_to_string(bt_char v)
{
  char buf[4];
  const int len = snprintf(buf, sizeof(buf), "%hhd", (char)v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string ushort_to_string(bt_ushort v)
{
  char buf[8];
  const int len = snprintf(buf, sizeof(buf), "%hu", v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string short_to_string(bt_short v)
{
  char buf[8];
  const int len = snprintf(buf, sizeof(buf), "%hd", v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string uint_to_string(bt_uint v)
{
  char buf[16];
  const int len = snprintf(buf, sizeof(buf), "%u", v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string int_to_string(bt_int v)
{
  char buf[16];
  const int len = snprintf(buf, sizeof(buf), "%d", v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string ulong_to_string(bt_ulong v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%llu", (unsigned long long)v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string long_to_string(bt_long v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%lld", (long long)v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string double_to_string(bt_double v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%f", v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string float_to_string(bt_float v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%f", double(v));
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_string size_t_to_string(bt_size_t v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%zu", (size_t)v);
  return bt_string(reinterpret_cast<unsigned char *>(buf), len);
}
bt_unit string_to_unit(const bt_string& v)
{
  return bt_unit();
}
bt_bool string_to_bool(const bt_string& v)
{
  const bt_size_t len = v.size();
  if (len == 4 && memcmp(v.rawarr(), "true", 4) == 0) {
    return true;
  }
  if (len == 5 && memcmp(v.rawarr(), "false", 5) == 0) {
    return false;
  }
  if (len == 1 && v.rawarr()[0] == '0') {
    return false;
  }
  return true;
}
template <typename Tt, typename Tf> inline Tt
string_to_numeric_tmpl(const Tf& a)
{
  const char *const p = reinterpret_cast<const char *>(a.rawarr());
  const typename Tf::size_type len = a.size();
  return boost::lexical_cast<Tt>(boost::make_iterator_range(p, p + len));
}
bt_uchar string_to_uchar(const bt_string& v)
  { return string_to_numeric_tmpl<bt_uchar, bt_string>(v); }
bt_char string_to_char(const bt_string& v)
  { return string_to_numeric_tmpl<bt_char, bt_string>(v); }
bt_ushort string_to_ushort(const bt_string& v)
  { return string_to_numeric_tmpl<bt_ushort, bt_string>(v); }
bt_short string_to_short(const bt_string& v)
  { return string_to_numeric_tmpl<bt_short, bt_string>(v); }
bt_uint string_to_uint(const bt_string& v)
  { return string_to_numeric_tmpl<bt_uint, bt_string>(v); }
bt_int string_to_int(const bt_string& v)
  { return string_to_numeric_tmpl<bt_int, bt_string>(v); }
bt_ulong string_to_ulong(const bt_string& v)
  { return string_to_numeric_tmpl<bt_ulong, bt_string>(v); }
bt_long string_to_long(const bt_string& v)
  { return string_to_numeric_tmpl<bt_long, bt_string>(v); }
bt_double string_to_double(const bt_string& v)
  { return string_to_numeric_tmpl<bt_double, bt_string>(v); }
bt_float string_to_float(const bt_string& v)
  { return string_to_numeric_tmpl<bt_float, bt_string>(v); }
bt_size_t string_to_size_t(const bt_string& v)
  { return string_to_numeric_tmpl<bt_size_t, bt_string>(v); }
}; // namespace pxcrt

