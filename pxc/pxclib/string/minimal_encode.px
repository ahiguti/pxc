namespace string::minimal_encode;
import numeric::integral -;
import container::string -;

public threaded function extern "pxclib::minimal_encode"
  void minimal_encode(string mutable& buf, cstrref const& src);
public threaded function extern "pxclib::minimal_decode"
  void minimal_decode(string mutable& buf, cstrref const& src);

extern "functions" inline
namespace pxclib {

using namespace pxcrt;

void minimal_encode(bt_string& buf, cstrref const& src);
void minimal_decode(bt_string& buf, cstrref const& src);

}; // namespace pxclib
;

extern "implementation" inline
#include <assert.h>
namespace pxclib {

void minimal_encode(bt_string& buf, cstrref const& src)
{
  const size_t srclen = src.size();
  const bt_uchar *const start = src.rawarr();
  const bt_uchar *const end = start + srclen;
  const size_t osize = buf.size();
  bt_uchar *const wstart = buf.reserve_back<2>(srclen); /* srclen * 2 */
  bt_uchar *wptr = wstart;
  for (const bt_uchar *p = start; p != end; ++p) {
    const bt_uchar c = p[0];
    if ((c >= 0x10 && c <= 0x7a) || c >= 0x80) {
      wptr[0] = c;
      ++wptr;
    } else if (c < 0x10) {
      wptr[0] = '~';
      wptr[1] = c + 0x20;
    } else {
      wptr[0] = '~';
      wptr[1] = c - 0x20;
    }
  }
  assert((size_t)(wptr - wstart) <= srclen * 2);
  buf.rawarr_set_valid_len(osize + wptr - wstart);
}

void minimal_decode(bt_string& buf, cstrref const& src)
{
  const size_t srclen = src.size();
  const bt_uchar *const start = src.rawarr();
  const bt_uchar *const end = start + srclen;
  const size_t osize = buf.size();
  bt_uchar *const wstart = buf.reserve_back<1>(srclen);
  bt_uchar *wptr = wstart;
  for (const bt_uchar *p = start; p != end; ++p) {
    if (p[0] == '~' && p + 1 != end) {
      bt_uchar ch = p[1];
      (*wptr++) = ch < 0x40 ? ch - 0x20 : ch + 0x20;
      p++;
    } else {
      (*wptr++) = p[0];
    }
  }
  assert((size_t)(wptr - wstart) <= srclen);
  buf.rawarr_set_valid_len(osize + wptr - wstart);
}

}; // namespace pxclib
;

