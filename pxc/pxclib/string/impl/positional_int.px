namespace string::impl::positional_int;
public import numeric::integral -;
public import container::string -;
public import numeric::cast -;
public import numeric::limit lim;
public import container::algorithm algo;

public threaded function {t} void integral_to_decimal(t v, string& buf)
{
  if (v == 0) {
    buf.push_back('0');
    return;
  }
  size_t pos0 = buf.size();
  if (v < 0) {
    buf.push_back('-');
    pos0 += 1;
    while (v != 0) {
      t rem = v % 10;
      v /= 10;
      buf.push_back(- static_cast{uchar, t}(rem) + '0');
    }
  } else {
    while (v != 0) {
      t rem = v % 10;
      v /= 10;
      buf.push_back(static_cast{uchar, t}(rem) + '0');
    }
  }
  algo::reverse(buf[pos0 .. buf.size()]);
}

public threaded function {t} t decimal_to_integral_nocheck(cstrref const& buf)
{
  if (buf.size() == 0) {
    return t();
  }
  uchar const ch = buf[0];
  if (ch == '-') {
    return decimal_to_integral_nocheck_internal{t, 1}(buf[1 .. buf.size()]);
  } else if (ch == '+') {
    return decimal_to_integral_nocheck_internal{t, 0}(buf[1 .. buf.size()]);
  } else {
    return decimal_to_integral_nocheck_internal{t, 0}(buf);
  }
}

private threaded function {t, negative} t
decimal_to_integral_nocheck_internal(cstrref const& buf)
{
  t r;
  for (size_t idx, uchar v : buf) {
    if (v >= '0' && v <= '9') {
      r *= 10;
      t const dig = static_cast{t, uchar}(v - '0');
      if (negative) {
	r -= dig;
      } else {
	r += dig;
      }
    } else {
      break;
    }
  }
  return r;
}

public threaded function {t} t
decimal_to_integral(cstrref& buf)
{
  if (buf.size() == 0) {
    return t();
  }
  uchar const ch = buf[0];
  if (ch == '-') {
    buf.pop_front(1);
    return decimal_to_integral_internal{t, 1}(buf);
  } else if (ch == '+') {
    buf.pop_front(1);
    return decimal_to_integral_internal{t, 0}(buf);
  } else {
    return decimal_to_integral_internal{t, 0}(buf);
  }
}

private threaded function {t, negative} t
decimal_to_integral_internal(cstrref& buf)
{
  t r;
  for (size_t idx, uchar v : buf) {
    if (v >= '0' && v <= '9') {
      if (negative) {
	if (r < (lim::lowest{t}() / 10)) {
	  buf.pop_front(idx);
	  return r;
	}
      } else {
	if (r > (lim::highest{t}() / 10)) {
	  buf.pop_front(idx);
	  return r;
	}
      }
      r *= 10;
      t const dig = static_cast{t, uchar}(v - '0');
      if (negative) {
	t const nr = r - dig;
	if (nr > r) {
	  buf.pop_front(idx);
	  return r;
	}
	r = nr;
      } else {
	t const nr = r + dig;
	if (nr < r) {
	  buf.pop_front(idx);
	  return r;
	}
	r = nr;
      }
    } else {
      buf.pop_front(idx);
      return r;
    }
  }
  buf.pop_front(buf.size());
  return r;
}

