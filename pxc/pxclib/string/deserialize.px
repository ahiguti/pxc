namespace string::deserialize;
public import numeric::integral -;
public import numeric::cast -;
public import container::string -;
public import meta::common m;
public import meta::family mf;
public import io::debug -;

public threaded function {tpl, t} t deserialize(
  m::local{tpl, "source_type"}& s, size_t& epos)
{
  metafunction fam m::family{t};
  if (m::not{m::eq{m::local{tpl, "specialized_func", t}, 0}}) {
    return m::local{tpl, "specialized_func", t}(s, epos);
  } else if (mf::is_array_family{fam}) {
    /* TODO: farray, darray */
    t r;
    m::local{tpl, "array_begin"}(s, epos);
    bool is_first = true;
    while (true) {
      if (m::local{tpl, "array_end_cond"}(s)) {
	break;
      }
      if (is_first) {
	is_first = false;
      } else {
	m::local{tpl, "array_sep"}(s, epos);
      }
      m::at{t, 0} ent = deserialize{tpl, m::at{t, 0}}(s, epos);
      if (epos != 0) {
	break;
      }
      r.push_back(ent);
    }
    return r;
  } else if (mf::is_map_family{fam}) {
    t r;
    m::local{tpl, "map_begin"}(s, epos);
    bool is_first = true;
    while (true) {
      if (m::local{tpl, "map_end_cond"}(s)) {
	break;
      }
      if (is_first) {
	is_first = false;
      } else {
	m::local{tpl, "map_sep"}(s, epos);
      }
      m::local{tpl, "map_entry_begin"}(s, epos);
      m::at{t, 0} k = deserialize{tpl, m::at{t, 0}}(s, epos);
      m::local{tpl, "map_entry_sep"}(s, epos);
      m::at{t, 1} m = deserialize{tpl, m::at{t, 1}}(s, epos);
      m::local{tpl, "map_entry_end"}(s, epos);
      if (epos != 0) {
	break;
      }
      r[k] = m;
    }
    return r;
  } else if (mf::is_pointer_family{fam}) {
    m::local{tpl, "pointer_begin"}(s, epos);
    t r = t(deserialize{tpl, m::at{t, 0}}(s, epos));
    m::local{tpl, "pointer_end"}(s, epos);
    return r;
  } else if (mf::is_struct_family{fam}) {
    t r;
    m::local{tpl, "struct_begin"}(s, epos);
    // debug_log("struct_begin", epos);
    bool is_first = true;
    while (true) {
      if (m::local{tpl, "struct_end_cond"}(s)) {
	break;
      }
      if (is_first) {
	is_first = false;
      } else {
	m::local{tpl, "struct_sep"}(s, epos);
      }
      m::local{tpl, "struct_entry_begin"}(s, epos);
      m::local{tpl, "source_type"} s0 = s;
      m::local{tpl, "struct_field_name"}(s0, s, epos);
      // debug_log("struct_field_name", epos);
      m::local{tpl, "struct_entry_sep"}(s, epos);
      // debug_log("struct_entry_sep", epos);
      /* TODO: slow */
      expand (fld, idx : m::field_names{t}) {
	if (s0 == m::to_string{fld}) {
	  m::at{m::field_types{t}, idx} v = 
	    deserialize{tpl, m::at{m::field_types{t}, idx}}(s, epos);
	  if (epos != 0) {
	    break;
	  }
	  r.fld = v;
	  // debug_log("struct_entry field name", s0);
	  // debug_log("struct_entry field value", r.fld);
	}
      }
      m::local{tpl, "struct_entry_end"}(s, epos);
      // debug_log("struct_entry_end", epos);
    }
    return r;
  } else if (mf::is_union_family{fam}) {
    t r;
    m::local{tpl, "union_begin"}(s, epos);
    bool is_first = true;
    while (true) {
      if (m::local{tpl, "union_end_cond"}(s)) {
	break;
      }
      if (is_first) {
	is_first = false;
      } else {
	m::local{tpl, "union_sep"}(s, epos);
      }
      m::local{tpl, "union_entry_begin"}(s, epos);
      m::local{tpl, "source_type"} s0 = s;
      m::local{tpl, "union_field_name"}(s0, s, epos);
      m::local{tpl, "union_entry_sep"}(s, epos);
      expand (fld, idx : m::field_names{t}) {
	if (s0 == m::to_string{fld}) {
	  m::at{m::field_types{t}, idx} v = 
	    deserialize{tpl, m::at{m::field_types{t}, idx}}(s, epos);
	  if (epos != 0) {
	    break;
	  }
	  r.fld = v;
	}
      }
      m::local{tpl, "union_entry_end"}(s, epos);
    }
    return r;
  } else {
    t r;
    m::local{tpl, "unknown", t}(s, epos);
    return r;
  }
}

