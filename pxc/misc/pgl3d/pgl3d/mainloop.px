public namespace pgl3d::mainloop "use-unsafe";
public import common -;
public import pointer::raw -;
public import numeric::fpmath -;
public import glm;
public import io::time -;
public import io::environ -;
public import exception -;
public import meta m;
public import text::string::positional -;
public import pgl3d::glgeometry -;
public import pgl3d::scene_node -;
public import pgl3d::pglmotion -;
public import pgl3d::pglbase -;
public import pgl3d::pglcommon -;
public import pgl3d::application -;
public import pgl3d::wfobj -;
public import pgl3d::pglconfig -;
public import mainloop -;

private import GL::compat -;
private import pgl3d::glresource -;
private import pgl3d::glshader -;
private import pgl3d::glbuffer -;
private import pgl3d::pglshader -;
private import pgl3d::sdlcontext -;
private import pgl3d::sdlutil -;
private import pgl3d::resource_pool -;

public function void mainloop(ptr{pgl3d_application} const& app,
  cstrref const& conf_filename)
{
  string confstr;
  sdl_load_file(conf_filename, confstr);
  const conf = pgl3d_config(confstr);
  GL::base::set_check_error_enabled(conf.get("gldebug", 0, 0, 1));
  const ml = make_ptr{mainloop_internal}(app, conf);
  set_mainloop(ml);
}

struct
frame_statistics()
{
  public metafunction ticks_t farray{uint, 8};
  public uint tprevsec = 0;
  public uint frames = 0;
  public float mutable fps = 0.0;
  public ticks_t ticks;
  public ticks_t ticks_sum;
  public ticks_t ticks_sum_saved;
  init();
  function void init() {
    const t = SDL_GetTicks();
    for (const i, mutable& e : ticks) {
      e = t;
    }
  }
  public function void save_ticks(size_t idx, uint v) {
    const prev_tick = ticks[idx == 0 ? ticks.size() - 1 : idx - 1];
    mutable& cur_tick = ticks[idx];
    cur_tick = v;
    ticks_sum[idx] += cur_tick - prev_tick;
  }
  public function void measure()
  {
    ++frames;
    uint t = SDL_GetTicks();
    if (t - tprevsec >= 1000) {
      const seconds = cast_float(t - tprevsec) / 1000.0;
      fps = cast_float(frames) / seconds;
      ticks_sum_saved = ticks_sum;
      ticks_sum = ticks_t();
      tprevsec = t;
      frames = 0;
    }
  }
}

private function int set_swap_interval(int vsync)
{
  return SDL_GL_SetSwapInterval(vsync);
}

struct
framerate_control(int vsync0)
{
  public int mutable vsync = vsync0;
  public int mutable swap_interval = set_swap_interval(vsync0);
  public ulonglong time_prev = io::system.high_resolution_timer();
  public ulonglong time_den = io::system.high_resolution_timer_frequency();
  public double sleep_carry = 0.0;
  public double max_fps = 60.0;
  public double target_interval = 1.0 / max_fps;
  public float frame_speed_mul = 1.0;
  public function void start()
  {
    target_interval = 1.0 / max_fps;
    time_prev = io::system.high_resolution_timer();
  }
  public function void toggle_vsync()
  {
    vsync = vsync != 0 ? 0 : 1;
    sdllog("vsync=", vsync);
    swap_interval = set_swap_interval(vsync);
  }
  public function double time_subtract_sec(ulonglong tx, ulonglong ty)
  {
    const v = static_cast{double}(tx - ty) / static_cast{double}(time_den);
    return min(v, 1.0);
  }
  public function void rate_control()
  {
    const time_now = io::system.high_resolution_timer();
    const cur_interval = time_subtract_sec(time_now, time_prev);
    if (target_interval > cur_interval) {
      mutable tfr = 1.0 / target_interval;
      tfr += min(1.0 / tfr, 1.0); // increase 1.0 fps per sec
      tfr = max(min(tfr, max_fps), 1.0);
      target_interval = 1.0 / tfr;
      //sdllog("tfr", tfr, sleep_carry);
    } else {
      target_interval = cur_interval;
    }
    const sleep_sec = target_interval - cur_interval + sleep_carry;
    //const sleep_sec = target_interval - cur_interval;
    //sdllog("tgt", target_interval, "cur", cur_interval, "sl", sleep_sec);
    if (sleep_sec > 0.002 && target_interval > 0.02) {
      const ss = sleep_sec;
      io::system.usleep(static_cast{uint}((ss - 0.002) * 1000000.0));
    }
    const time_before_swapwindow = io::system.high_resolution_timer();
    const slept = time_subtract_sec(time_before_swapwindow, time_now);
    sleep_carry = max(min(sleep_sec - slept, 0.01), -0.01);
    time_prev = time_before_swapwindow;
    frame_speed_mul = static_cast{float}(target_interval * 60.0);
  }
}

/*
struct
framerate_control(int vsync0)
{
  public bool const vsync_adaptive = vsync0 > 1;
  public int vsync = vsync0 > 0 ? 1 : 0;
  public int swap_interval = set_swap_interval(vsync0);
  public ulonglong const timer_res
    = io::system.high_resolution_timer_frequency();
  public double const timer_res_inv = 1.0 / static_cast{double}(timer_res);
  public farray{ulonglong, 2} values;
  public size_t cur = 0;
  public float frame_speed_mul = 1.0;
  public int fast_frame_count = 0;
  public int slow_frame_count = 0;
  public function void toggle_vsync()
  {
    vsync = vsync != 0 ? 0 : 1;
    sdllog("vsync=", vsync);
    swap_interval = set_swap_interval(vsync);
  }
  public function void start()
  {
    const t = io::system.high_resolution_timer();
    sdllog("t=", t);
    for (const i, mutable& v: values) {
      v = t;
    }
    cur = 0;
  }
  public function void control()
  {
    const t = io::system.high_resolution_timer();
    // sdllog("t=", t);
    const t0 = values[cur];
    values[cur] = t;
    mutable avg_tdiff = static_cast{double}(t - t0) * timer_res_inv
      / static_cast{double}(values.size());
    if (avg_tdiff < 0.0001 || avg_tdiff > 1.0) {
      avg_tdiff = 1.0 / 60.0;
    }
    frame_speed_mul = static_cast{float}(avg_tdiff * 60.0);
    if (vsync_adaptive) {
      if (frame_speed_mul > 1.2 && vsync != 0) {
	if (++slow_frame_count > 4) {
	  slow_frame_count = 0;
	  vsync = 0;
	  debug_log("adaptive vsync", vsync);
	  set_swap_interval(vsync);
	}
      } else if (frame_speed_mul <= 1.0 && vsync == 0) {
	if (++fast_frame_count > 20) {
	  fast_frame_count = 0;
	  vsync = 1;
	  debug_log("adaptive vsync", vsync);
	  set_swap_interval(vsync);
	}
      }
      if (frame_speed_mul < 1.2) {
	slow_frame_count = 0;
      }
      if (frame_speed_mul > 1.0) {
	fast_frame_count = 0;
      }
    }
    if (++cur >= values.size()) {
      cur = 0;
    }
    // const t_prev = values[cur > 0 ? cur : values.size() - 1];
    // const last_tdiff = static_cast{double}(t - t_prev) * timer_res_inv;
    //if (last_tdiff < avg_tdiff - 0.002) {
    //  const time_to_sleep = (avg_tdiff - 0.002) - last_tdiff;
    //  debug_log("sleep", time_to_sleep);
    //  io::system.usleep(static_cast{uint}(time_to_sleep * 1000000.0));
    //}
  }
}
*/

private struct mainloop_internal(ptr{pgl3d_application} const& app0,
  pgl3d_config const& conf)
<mainloop_i>
{
  private ptr{pgl3d_application} app = app0;
  private sdlcontext sdlc = sdlcontext(conf);
  private shader_config sconf = shader_config(sdlc.gles_flag, sdlc.glmajor,
    sdlc.glminor, sdlc.enable_msaa, conf);
  private ptr{resource_pool} respool = make_ptr{resource_pool}();
  private tree_map{string, ptr{pgldrawer_export_i}} drawers
    = app->on_init_drawers(sconf, respool);
  private pglshader pgs = pglshader(sconf, respool, drawers, sdlc.init_w,
    sdlc.init_h);
  private whole_instances_type local_whole_instances;
  private node_factory nfac;
  private option{ptr{motion_thread_client}} motion_thr;
  private size_t saved_stat_num_objects;
  private projection_info cam_drawing_frame;
  private frame_statistics mutable fr;
  private framerate_control mutable frctl = framerate_control(sdlc.vsync);
  private string_map commands;
  private int fullscreen = 0;
  private bool done = false;
  private bool paused = false;
  private varray{short} joy_axes;
  private varray{bool} joy_buttons;
  init();
  private function void init()
  {
    sdllog("PGL3D main");
    sdllog("shader config", sconf);
    // SDL_EventState(SDL_KEYDOWN, 0); // FIXME
    SDL_EventState(SDL_KEYUP, 0);
    SDL_EventState(SDL_TEXTEDITING, 0);
    SDL_EventState(SDL_TEXTINPUT, 0);
    SDL_JoystickEventState(0);
    if (m::or{is_android, is_ios}) {
      SDL_EventState(SDL_MOUSEBUTTONDOWN, 0);
      SDL_EventState(SDL_MOUSEBUTTONUP, 0);
      SDL_EventState(SDL_MOUSEMOTION, 0);
    }
    if (m::ne{is_macos, 0}) {
      SDL_EventState(SDL_FINGERDOWN, 0);
      SDL_EventState(SDL_FINGERUP, 0);
      SDL_EventState(SDL_FINGERMOTION, 0);
    }
    sdllog("PGL3D init0");
    app->on_build_vertices(pgs);
    pgs.prepare(local_whole_instances, nfac);

    /* spawn motion thread */
    motion_thr.some = make_ptr{motion_thread_client}(nfac,
      local_whole_instances, app->get_scene_shared(), pgs.pidft);
    motion_thr.some->start();
  }
  private function void toggle_fullscreen()
  {
    fullscreen = fullscreen != 0 ? 0 : 1;
    sdllog("fullscreen=", fullscreen);
    SDL_Enum flag = 0;
    if (m::ne{is_macos, 0}) {
      flag = SDL_WINDOW_FULLSCREEN_DESKTOP;
    } else {
      flag = SDL_WINDOW_FULLSCREEN;
    }
    SDL_SetWindowFullscreen(sdlc.sdl_window, fullscreen != 0 ? flag : 0);
  }
  private function void do_commands()
  {
    if (!commands.empty()) {
      for (const& k, const& v: commands) {
	if (k == "vsync") {
	  frctl.toggle_vsync();
	} else if (k == "fullscreen") {
	  toggle_fullscreen();
	}
      }
      commands.clear();
    }
  }
  public function bool step()
  {
    try {
      return step_internal();
    } catch (exception::c_exception ex) {
      sdllog("uncaught exception", ex);
    }
    return true;
  }
  private function bool step_internal()
  {
    // bool scene_next_flag = false;
    SDL_Event ev;
    while (SDL_PollEvent(address(ev)) != 0) {
      const etype = ev.type;
      /*
      sdllog("event", cast_int(ev.type));
       */
      if (etype == SDL_WINDOWEVENT) {
	if (ev.window.event == SDL_WINDOWEVENT_RESIZED) {
	  int w;
	  int h;
	  SDL_GL_GetDrawableSize(sdlc.sdl_window, address(w), address(h));
	  pgs.resize_screen(w, h);
	  frctl.start();
	  sdllog("resized w=", w, " h=", h);
	} else if (ev.window.event == SDL_WINDOWEVENT_HIDDEN) {
	  sdllog("hidden");
	} else if (ev.window.event == SDL_WINDOWEVENT_MINIMIZED ||
	    ev.window.event == SDL_WINDOWEVENT_FOCUS_LOST) {
	  // paused = true;
	  // sdllog("paused");
	} else if (ev.window.event == SDL_WINDOWEVENT_RESTORED ||
	    ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) {
	  paused = false;
	  frctl.start();
	  sdllog("restored");
	} else {
	  /*
	  sdllog("window event ", cast_int(ev.window.event));
	  */
	}
      } else if (etype == SDL_QUIT) {
	done = true;
	break;
      }
      /* invoke event handler */
      app->on_event(ev, frctl.frame_speed_mul, pgs.cam, commands);
      do_commands();
    }
    if (sdlc.joystick.get() != rawptr{SDL_Joystick}()) {
      SDL_JoystickUpdate();
      joy_axes.resize(static_cast{size_t}(sdlc.joystick_num_axes), 0);
      joy_buttons.resize(static_cast{size_t}(sdlc.joystick_num_buttons), 0);
      for (const i: 0 .. sdlc.joystick_num_axes) {
	const v = SDL_JoystickGetAxis(sdlc.joystick.get(), i);
	joy_axes[static_cast{size_t}(i)] = v;
      }
      for (const i: 0 .. sdlc.joystick_num_buttons) {
	const v = SDL_JoystickGetButton(sdlc.joystick.get(), i);
	joy_buttons[static_cast{size_t}(i)] = (v != 0);
      }
      // sdllog("joy", joy_axes, joy_buttons);
    }
    {
      int numkeys;
      const ksp = SDL_GetKeyboardState(address(numkeys));
      const ks = ksp.to_cslice(static_cast{size_t}(numkeys));
      /* invoke key handler */
      app->on_scankeys(ks, joy_axes, joy_buttons, frctl.frame_speed_mul,
	pgs.cam, commands);
      do_commands();
    }
    fr.save_ticks(0, SDL_GetTicks());
    if (paused) {
      SDL_Delay(100);
      fr.tprevsec = SDL_GetTicks();
      return done;
    }
    /* motion and prepare instance data */
    {
//debug_log(fr.fps, "fps");
      const mess = string_join{" "}(fr.fps, frctl.frame_speed_mul,
	fr.ticks_sum_saved,
	saved_stat_num_objects);
      motion_thr.some->finish();
      {
	mutable& mts = *motion_thr.some->shared;
	// fr.save_ticks(1, SDL_GetTicks());
	cam_drawing_frame = mts.cam;
	mts.cam = pgs.cam;
	mts.frame_speed_mul = frctl.frame_speed_mul;
	mts.message = mess;
	mts.commands.swap(commands);
	local_whole_instances.swap(mts.whole_instances);
	saved_stat_num_objects = mts.stat_num_objects;
      }
      motion_thr.some->start();
      do_commands();
    }
    // FIXME: shadowmapping
    {
      // const cam_inv = cam_drawing_frame.cam.conjugate().to_mat3();
      /*
      const cam_inv = cam_drawing_frame.camera.angle.to_mat3().inverse(); // TODO:slow
      mutable pers = cam_drawing_frame.camera_pers;
      pers.far /= 10.0f;
      const w2 = pers.width * pers.far / pers.near;
      const h2 = pers.height * pers.far / pers.near;
      farray{glm::vec3, 8} arr;
      arr[0] = cam_inv * glm::make_vec3(-pers.width, -pers.height, pers.near);
      arr[1] = cam_inv * glm::make_vec3( pers.width, -pers.height, pers.near);
      arr[2] = cam_inv * glm::make_vec3( pers.width,  pers.height, pers.near);
      arr[3] = cam_inv * glm::make_vec3(-pers.width,  pers.height, pers.near);
      arr[4] = cam_inv * glm::make_vec3(-w2, -h2, pers.far);
      arr[5] = cam_inv * glm::make_vec3( w2, -h2, pers.far);
      arr[6] = cam_inv * glm::make_vec3( w2,  h2, pers.far);
      arr[7] = cam_inv * glm::make_vec3(-w2,  h2, pers.far);
      glm::vec3 mi = arr[0];
      glm::vec3 mx = arr[0];
      for (size_t i: 1 .. 8) {
	mi.x = min(mi.x, arr[i].x);
	mi.y = min(mi.y, arr[i].y);
	mi.z = min(mi.z, arr[i].z);
	mx.x = max(mx.x, arr[i].x);
	mx.y = max(mx.y, arr[i].y);
	mx.z = max(mx.z, arr[i].z);
      }
      */
      /*
      debug_log("mi", mi.to_cslice(), "mx", mx.to_cslice());
      */
      /*
      cam_drawing_frame.sm_projection =
	glm::ortho(mi.x, mx.x, mi.y, mx.y, mi.z, mx.z);
      */
      /*
      debug_log("lipos", cam_drawing_frame.light.position.to_slice());
      debug_log("liang", cam_drawing_frame.light.angle.to_slice());
      debug_log("capos", cam_drawing_frame.camera.position.to_slice());
      debug_log("caang", cam_drawing_frame.camera.angle.to_slice());
      */
      // cam_drawing_frame.light.position = glm::make_vec3(0.0f, -60.0f, 0.0f);
      // cam_drawing_frame.light.angle = glm::make_quat_wxyz(0.70711f, 0.70711f, 0.0f, 0.0f);
      /*
      */
// FIXME : here
    }
    fr.save_ticks(1, SDL_GetTicks());
    {
      /* draw frame */
      varray{uint} tick_draw;
      tick_draw = pgs.draw_frame(local_whole_instances, cam_drawing_frame);
      if (tick_draw.size() > 2) {
	fr.save_ticks(2, tick_draw[0]);
	fr.save_ticks(3, tick_draw[1]);
      } else {
	fr.save_ticks(2, SDL_GetTicks());
	fr.save_ticks(3, SDL_GetTicks());
      }
      fr.save_ticks(4, SDL_GetTicks());
      fr.measure();
    }
    fr.save_ticks(5, SDL_GetTicks());
    frctl.rate_control();
    fr.save_ticks(6, SDL_GetTicks());
    SDL_GL_SwapWindow(sdlc.sdl_window);
    // debug_log("swapwindow");
    fr.save_ticks(7, SDL_GetTicks());
    // if (scene_next_flag) { frctl.start(); }
    return done;
  }
}

