private namespace pgl3d::drawer "export-unsafe";
public import common -;
public import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
public import glm::raw;
public import io::time -;
public import exception -;
public import meta m;
public import pointer::tfuncptr -;
public import GL::compat -;
public import pgl3d::glresource -;
public import pgl3d::glshader -;
public import pgl3d::glgeometry -;
public import pgl3d::glbuffer -;
public import pgl3d::scenenode -;
public import pgl3d::pglbase -;
public import pgl3d::intern_pool -;
public import pgl3d::shader_config -;
public import pgl3d::aggregated_ibuffer -;

public enum draw_step {
  draw_step_shadowmapping = 1,
  draw_step_zprepass = 2,
  draw_step_solid = 3,
  draw_step_blend = 4
}

public metafunction prepare_instance_data_funcptr
  pointer::tfuncptr::tfuncptr_matching_function{prepare_instance_data_default};

public multithreaded struct prepare_instance_data_cb
<prepare_instance_data_i>
{
  public varray{prepare_instance_data_funcptr} func_table;
  public function void prepare_instance_data(scene_node{node_data} const& sn,
    node_common_data mutable& ncd, varray{instances_type} mutable& ibs)
  {
    prepare_instance_data_ft_rec(sn, ncd, func_table, ibs);
  }
}

public threaded function void prepare_instance_data_cb_add(
  prepare_instance_data_cb mutable& picb, vertex_buffer_id vbid,
  prepare_instance_data_funcptr const& fp)
{
  size_t i = static_cast{size_t}(vbid);
  if (picb.func_table.size() <= i) {
    picb.func_table.resize(i + 1,
      make_tfuncptr{prepare_instance_data_default}());
  }
  picb.func_table[i] = fp;
}

public interface pgldrawer_i <pgldrawer_export_i> {
  public function string get_vbid_name() const;
  public function prepare_instance_data_funcptr
    get_prepare_instance_data_funcptr() const;
  public function ptr{vertex_buffer} make_vertex_buffer() const;
  public function void draw(draw_step step, vertex_buffer const& bo,
    instances_type const& ibs, aggregated_ibuffer const& aibuf,
    vertex_buffer_id bo_id, shader_config const& glc,
    projection_info const& cam_df);
}

public struct drawer_triangles(shader_config const& glc)
<pgldrawer_i>
{
  triangles_shader_ptr{1} const sdr_solid = init_triangles_shader{1}(glc);
  zprepass_shader_ptr{1} const sdr_zp = init_zprepass_shader{1}(glc);
  shadowmap_shader_ptr{1} const sdr_shadow = init_shadowmap_shader{1}(glc);
  public function string get_vbid_name() const { return "vbid_triangles"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_triangles}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_ptr{vertex_buffer}(
      static_cast{size_t}(num_float_struct{triangles_vertex_attributes}),
      false);
  }
  public function void draw(draw_step step, vertex_buffer const& bo,
    instances_type const& ibs, aggregated_ibuffer const& aibuf,
    vertex_buffer_id bo_id, shader_config const& glc,
    projection_info const& cam_df)
  {
    if (step == draw_step_shadowmapping) {
      glUseProgram(sdr_shadow->program);
      aibuf.draw(*sdr_shadow, bo, ibs, bo_id, 1, glc.enable_instanced,
	glc.enable_uniform_instancing);
    } else if (step == draw_step_zprepass) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      mutable& sdr = *sdr_zp;
      glUseProgram(sdr.program);
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      aibuf.draw(sdr, bo, ibs, bo_id, 0, glc.enable_instanced,
	  glc.enable_uniform_instancing);
    } else if (step == draw_step_solid) {
      const sm_view = cam_df.light.to_mat4().inverse();
      const sm_vp = cam_df.sm_projection * sm_view;
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
      mutable& sdr = *sdr_solid;
      glUseProgram(sdr.program);
      glUniform3fv(sdr.u_light_pos, 1, cam_df.light.position.to_crawptr());
      glUniform3fv(sdr.u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glUniform1i(sdr.u_sampler, 1);
      glUniform1i(sdr.u_sampler_tilemap, 2);
      glUniform1i(sdr.u_sampler_sm, 3);
      glUniform1f(sdr.u_light_on, 1.0f);
      glUniformMatrix4fv(sdr.u_shadowmap_vp, 1, 0, sm_vp.to_crawptr());
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0, vp.to_crawptr());
      aibuf.draw(sdr, bo, ibs, bo_id, 0, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_triangles2(shader_config const& glc)
<pgldrawer_i>
{
  triangles_shader_ptr{0} sdr_solid = init_triangles_shader{0}(glc);
  zprepass_shader_ptr{0} sdr_zp = init_zprepass_shader{0}(glc);
  shadowmap_shader_ptr{0} sdr_shadow = init_shadowmap_shader{0}(glc);
  public function string get_vbid_name() const { return "vbid_triangles2"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_triangles}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_ptr{vertex_buffer}(
      static_cast{size_t}(num_float_struct{triangles_vertex_attributes}),
      false);
  }
  public function void draw(draw_step step, vertex_buffer const& bo,
    instances_type const& ibs, aggregated_ibuffer const& aibuf,
    vertex_buffer_id bo_id, shader_config const& glc,
    projection_info const& cam_df)
  {
    if (step == draw_step_shadowmapping) {
      glUseProgram(sdr_shadow->program);
      aibuf.draw(*sdr_shadow, bo, ibs, bo_id, 1, false, false);
    } else if (step == draw_step_zprepass) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      glUseProgram(sdr_zp->program);
      glUniformMatrix4fv(sdr_zp->u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      aibuf.draw(*sdr_zp, bo, ibs, bo_id, 0, false, false);
    } else if (step == draw_step_solid) {
      const sm_view = cam_df.light.to_mat4().inverse();
      const sm_vp = cam_df.sm_projection * sm_view;
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
      mutable& sdr = *sdr_solid;
      glUseProgram(sdr.program);
      glUniform3fv(sdr.u_light_pos, 1,
	cam_df.light.position.to_crawptr());
      glUniform3fv(sdr.u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glUniform1i(sdr.u_sampler, 1);
      glUniform1i(sdr.u_sampler_tilemap, 2);
      glUniform1i(sdr.u_sampler_sm, 3);
      glUniform1f(sdr.u_light_on, 1.0f);
      glUniformMatrix4fv(sdr.u_shadowmap_vp, 1, 0, sm_vp.to_crawptr());
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      aibuf.draw(sdr, bo, ibs, bo_id, 0, false, false);
    }
  }
}

public struct drawer_lineparticle(shader_config const& glc)
<pgldrawer_i>
{
  lineparticle_shader_ptr sdr_lp = init_lineparticle_shader(glc);
  public function string get_vbid_name() const { return "vbid_lineparticle"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_lineparticle}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_ptr{vertex_buffer}(
      static_cast{size_t}(num_float_struct{lineparticle_vertex_attributes}),
      false);
  }
  public function void draw(draw_step step, vertex_buffer const& bo,
    instances_type const& ibs, aggregated_ibuffer const& aibuf,
    vertex_buffer_id bo_id, shader_config const& glc,
    projection_info const& cam_df)
  {
    if (step == draw_step_solid) {
      glDisable(GL_CULL_FACE);
      glDepthFunc(GL_LEQUAL);
      glDepthMask(1);
      mutable cam_mat = glm::mat4();
      cam_mat = cam_df.camera.to_mat4();
      const vp = cam_df.projection * (cam_mat.inverse());
      const screen_size_px = make_farray{float}(
	cast_float(cam_df.screen_width), cast_float(cam_df.screen_height));
      const screen_size_base = cast_float(
	max(cam_df.screen_width, cam_df.screen_height));
      mutable& sdr = *sdr_lp;
      glUseProgram(sdr.program);
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      glUniform2fv(sdr.u_screen_size_px, 1, screen_size_px.to_crawptr());
      glUniform1fv(sdr.u_screen_size_base, 1, caddress(screen_size_base));
      aibuf.draw(sdr, bo, ibs, bo_id, 0, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_particle(shader_config const& glc)
<pgldrawer_i>
{
  particle_shader_ptr sdr_sp = init_particle_shader(glc);
  public function string get_vbid_name() const { return "vbid_particle"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_particle}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_ptr{vertex_buffer}(
      static_cast{size_t}(num_float_struct{particle_vertex_attributes}), true);
  }
  public function void draw(draw_step step, vertex_buffer const& bo,
    instances_type const& ibs, aggregated_ibuffer const& aibuf,
    vertex_buffer_id bo_id, shader_config const& glc,
    projection_info const& cam_df)
  {
    if (step == draw_step_blend) {
      glBlendFunc(GL_ONE, GL_ONE);
      mutable& sdr = *sdr_sp;
      glUseProgram(sdr.program);
      glUniform1f(sdr.u_point_size_base,
	0.1f * static_cast{float}(max(
	  cam_df.screen_width, cam_df.screen_height)));
      aibuf.draw(sdr, bo, ibs, bo_id, 0, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_particle_bb(shader_config const& glc)
<pgldrawer_i>
{
  particle_bb_shader_ptr sdr_pb = init_particle_bb_shader(glc);
  public function string get_vbid_name() const { return "vbid_particle_bb"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_default}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_ptr{vertex_buffer}(
      static_cast{size_t}(num_float_struct{particle_bb_vertex_attributes}),
      false);
  }
  public function void draw(draw_step step, vertex_buffer const& bo,
    instances_type const& ibs, aggregated_ibuffer const& aibuf,
    vertex_buffer_id bo_id, shader_config const& glc,
    projection_info const& cam_df)
  {
    if (step == draw_step_blend) {
      glBlendFunc(GL_ONE, GL_ONE);
      mutable& sdr = *sdr_pb;
      glUseProgram(sdr.program);
      mutable cam_mat = glm::mat4();
      cam_mat = cam_df.camera.to_mat4();
      const vp = cam_df.projection * (cam_mat.inverse());
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      glUniformMatrix3fv(sdr.u_camera_matrix, 1, 0,
	cam_mat.to_3().to_crawptr());
      glUniform1f(sdr.u_point_size_base, 0.1f);
      aibuf.draw(sdr, bo, ibs, bo_id, 0, 
	glc.enable_instanced, glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_font2(shader_config const& glc)
<pgldrawer_i>
{
  font2_shader_ptr sdr_fn = init_font2_shader(glc);
  public function string get_vbid_name() const { return "vbid_font2"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_font2}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_ptr{vertex_buffer}(
      static_cast{size_t}(num_float_struct{font2_vertex_attributes}), true);
  }
  public function void draw(draw_step step, vertex_buffer const& bo,
    instances_type const& ibs, aggregated_ibuffer const& aibuf,
    vertex_buffer_id bo_id, shader_config const& glc,
    projection_info const& cam_df)
  {
    if (step == draw_step_blend) {
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      const screen_size_px = glm::make_vec2(
	static_cast{float}(cam_df.screen_width),
	static_cast{float}(cam_df.screen_height));
      mutable& sdr = *sdr_fn;
      glUseProgram(sdr.program);
      glUniform1i(sdr.u_sampler, 0);
      glUniform2fv(sdr.u_screen_size_px, 1, screen_size_px.to_crawptr());
      aibuf.draw(sdr, bo, ibs, bo_id, 0,
	glc.enable_instanced, glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_rect2d(shader_config const& glc)
<pgldrawer_i>
{
  rect2d_shader_ptr sdr_re = init_rect2d_shader(glc);
  public function string get_vbid_name() const { return "vbid_rect2d"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_rect2d}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_ptr{vertex_buffer}(
      static_cast{size_t}(num_float_struct{rect2d_vertex_attributes}), false);
  }
  public function void draw(draw_step step, vertex_buffer const& bo,
    instances_type const& ibs, aggregated_ibuffer const& aibuf,
    vertex_buffer_id bo_id, shader_config const& glc,
    projection_info const& cam_df)
  {
    if (step == draw_step_blend) {
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      mutable& sdr = *sdr_re;
      glUseProgram(sdr.program);
      aibuf.draw(sdr, bo, ibs, bo_id, 0, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

/* private */

metafunction triangles_shader_ptr{instancing}
  ptr{glshader{
    triangles_uniforms, triangles_instance_attributes,
    m::cond{instancing,
      triangles_vertex_attributes, triangles2_vertex_attributes}}};
metafunction shadowmap_shader_ptr{instancing}
  ptr{glshader{
    shadowmap_uniforms, triangles_instance_attributes,
    m::cond{instancing,
      shadowmap_vertex_attributes, shadowmap2_vertex_attributes}}};
metafunction zprepass_shader_ptr{instancing}
  ptr{glshader{
    zprepass_uniforms, triangles_instance_attributes,
    m::cond{instancing,
      zprepass_vertex_attributes, zprepass2_vertex_attributes}}};
metafunction font2_shader_ptr
  ptr{glshader{
    font2_uniforms, font2_instance_attributes, font2_vertex_attributes}};
metafunction rect2d_shader_ptr
  ptr{glshader{
    rect2d_uniforms, rect2d_instance_attributes, rect2d_vertex_attributes}};
metafunction particle_shader_ptr
  ptr{glshader{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}};
metafunction particle_bb_shader_ptr
  ptr{glshader{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}};
metafunction lineparticle_shader_ptr
  ptr{glshader{lineparticle_uniforms, lineparticle_instance_attributes,
    lineparticle_vertex_attributes}};

function {instancing} shadowmap_shader_ptr{instancing}
init_shadowmap_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  /* note: passes mvp as model_matrix */
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", instancing != 0, true);
  v += g.vert_in() + "vec3 position;\n";
  if (!g.enable_depth_texture) {
    v += g.vert_out() + "vec4 vary_smpos;\n";
  }
  v += "void main(void) {\n";
  v += "vec4 p = " + g.instance_attr("model_matrix", instancing != 0, true);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_Position = p;\n";
  if (!g.enable_depth_texture) {
    v += "vary_smpos = p;\n";
  }
  v += "}\n";
  string f;
  if (g.enable_depth_texture) {
    f += g.empty_shader_frag();
  } else {
    f += g.prepend();
    f += g.frag_in() + "vec4 vary_smpos;\n";
    f += g.decl_fragcolor();
    f += "void main(void) {\n";
    f += "vec4 p = vary_smpos;\n";
    f += "  float pz = (p.z/p.w + 1.0) / 2.0;\n";
    f += "  float z = pz * 256.0;\n";/* [0.0, 256.0] */
    f += "  float z0 = floor(z);\n"; /* [0, 256] */
    f += "  z = (z - z0) * 256.0;\n"; /* [0.0, 256.0) */
    f += "  float z1 = floor(z);\n"; /* [0, 256) */
    f += "  z = (z - z1) * 256.0;\n"; /* [0.0, 256.0) */
    f += "  float z2 = floor(z);\n";  /* [0, 256) */
    f += g.fragcolor() + "= vec4(z0/255.0, z1/255.0, z2/255.0, 1.0);\n";
    f += "}\n";
  }
  return make_glshader_ptr{
    shadowmap_uniforms,
    triangles_instance_attributes,
    m::cond{instancing,
      shadowmap_vertex_attributes,
      shadowmap2_vertex_attributes}
  }(v, f, "model_matrix");
}

function {instancing} zprepass_shader_ptr{instancing}
init_zprepass_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", instancing != 0, true);
  v += g.vert_in() + "vec3 position;\n";
  v += "void main(void) {\n";
  v += "vec4 gpos4 = " + g.instance_attr("model_matrix", instancing != 0, true);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_Position = view_projection_matrix * gpos4;\n";
  v += "}\n";
  string f = g.empty_shader_frag();
  return make_glshader_ptr{
    zprepass_uniforms,
    triangles_instance_attributes,
    m::cond{instancing,
      zprepass_vertex_attributes,
      zprepass2_vertex_attributes}
  }(v, f, "model_matrix");
}

function string
triangles_shader_vert(shader_config const& g, bool instancing)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat4 shadowmap_vp;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", instancing, true);
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec3 normal;\n";
  v += g.vert_in() + "vec3 tangent;\n";
  v += g.vert_in() + "vec3 uvw;\n";
  v += g.vert_out() + "vec3 vary_position;\n";
  v += g.vert_out() + "vec3 vary_normal;\n";
  v += g.vert_out() + "vec3 vary_tangent;\n";
  v += g.vert_out() + "vec3 vary_uvw;\n";
  v += g.vert_out() + "vec3 vary_binormal;\n";
  if (g.enable_shadowmapping) {
    v += g.vert_out() + "vec4 vary_smpos;\n";
  }
  v += "void main(void) {\n";
  v += "  vec4 gpos4 = " + g.instance_attr("model_matrix", instancing, true);
  v += "    * vec4(position, 1.0);\n";
  v += "  gl_Position = view_projection_matrix * gpos4;\n";
  if (g.is_gl3_or_gles3()) {
    v += "  mat3 normal_matrix = mat3("
      + g.instance_attr("model_matrix", instancing, true)
      + ");\n";
  } else {
    v += "  mat4 mm = "
      + g.instance_attr("model_matrix", instancing, true)
      + ";\n";
    v += "  mat3 normal_matrix = mat3(mm[0].xyz, mm[1].xyz, mm[2].xyz);\n";
  }
  v += "  vary_position = gpos4.xyz / gpos4.w;\n";
  v += "  vary_normal = normal_matrix * normal;\n";
  v += "  vary_tangent = normal_matrix * tangent;\n";
  v += "  vary_uvw = uvw;\n";
  v += "  vary_binormal = cross(vary_normal, vary_tangent);\n";
  if (g.enable_shadowmapping) {
    v += "  vary_smpos = shadowmap_vp * gpos4;\n";
  }
  v += "}\n";
  return v;
}

function string triangles_shader_frag(shader_config const& g, bool instancing)
{
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += "uniform sampler2D sampler_tilemap;\n";
  if (g.enable_sampler2dshadow) {
    f += "uniform sampler2DShadow sampler_sm;\n";
  } else {
    f += "uniform sampler2D sampler_sm;\n";
  }
  f += "uniform vec3 camera_pos;\n";
  f += "uniform vec3 light_pos;\n";
  f += "uniform float light_on;\n";
  f += "uniform mat4 shadowmap_vp;\n";
  f += g.frag_in() + "vec3 vary_position;\n";
  f += g.frag_in() + "vec3 vary_normal;\n";
  f += g.frag_in() + "vec3 vary_tangent;\n";
  f += g.frag_in() + "vec3 vary_uvw;\n";
  f += g.frag_in() + "vec3 vary_binormal;\n";
  if (g.enable_shadowmapping) {
    f += g.frag_in() + "vec4 vary_smpos;\n";
  }
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec3 light_dir = normalize(light_pos - vary_position);\n";
  f += "float light_distance = length(light_pos - vary_position);\n";
  f += "vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n";
  if (instancing) {
    f += "vec4 color_dif = vec4(0.42, 0.42, 0.42, 1.0);\n";
  } else {
    f += "vec4 color_dif = vec4(0.43, 0.42, 0.44, 1.0);\n";
  }
  f += "float mate_ambient = 0.2;\n";
  f += "float mate_specular = 0.5;\n";
  if (g.enable_shadowmapping) {
    f += "vec4 smp = vary_smpos;\n";
    f += "vec3 smpos = ((smp.xyz / smp.w) + 1.0) * 0.5;\n";
    f += "float lflag = float(int(smpos.x <= 0.0) + int(smpos.x >= 1.0)";
    f += "  + int(smpos.y <= 0.0) + int(smpos.y >= 1.0) == 0);\n";
  } else {
    f += "float lflag = 1.0;\n";
  }
  f += "float lstr = lflag;\n";
  /*
  f += "float distbr = min(3000.0 / (light_distance * light_distance), ";
  f += "  light_on);\n";
  */
  f += "float distbr = min(100.0 / light_distance , light_on);\n";
  f += "vec3 nor = vary_normal;\n";
  if (g.enable_normalmapping) {
    f += "const float tile_size = 32.0;\n";
    f += "const float tilemap_size = 128.0;\n";
    f += "const float tiletex_size = 256.0;\n";
    f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
    f += "vec2 uv_tm = floor(uv0);\n";
	  /* tilemap coordinate */
    f += "vec2 uv_tmfr = uv0 - uv_tm;\n";
	  /* coordinate inside a tile (0, 1) */
    f += "vec2 uv_ti = uv_tmfr * tile_size;\n";
    f += "vec2 uvi = floor(uv_ti);\n";
	  /* coordinate inside a tile, integral */
    f += "vec2 uvj = uv_ti - uvi;\n";
	  /* subpixel coordinate */
    f += "vec4 ti = " +  g.texture2d();
    f += "  (sampler_tilemap, uv_tm / tilemap_size);\n";
	  /* lookup the tilemap */
    f += "vec2 uv_pixel = floor(ti.xy * 255.0 + 0.5) * tile_size + uvi;\n";
	  /* tile pattern coordinate */
    f += "mate_ambient = ti.z;\n";
    f += "mate_specular = ti.w;\n";
    f += "vec4 c0 = " + g.texture2d();
    f += "  (sampler, uv_pixel / tiletex_size);\n";
	  /* lookup the tilepattern */
    f += "float alv0 = floor(c0.a * 255.0 + 0.5);\n";
    f += "float avol = floor(alv0 / 16.0);\n";
    f += "int alv = int(alv0 - avol * 16.0 + 0.5);\n";
    f += "float lt = float(uvj.y - uvj.x >= 0.0);\n";
    f += "float lb = float(uvj.y + uvj.x <= 1.0);\n";
    f += "vec4 avlv = vec4(float(alv == 1), float(alv == 3), ";
    f += "  float(alv == 5), float(alv == 7));\n";
    f += "float ut1 = dot(avlv, vec4(-lt, 1.0-lb, 1.0-lt, -lb));\n";
    f += "float vt1 = dot(avlv, vec4(lt-1.0, -lb, lt, 1.0-lb));\n";
    f += "ut1 += float(alv == 4);\n";
    f += "vt1 -= float(alv == 2);\n";
    f += "avol = (avol - 8.0) * distbr * 0.2;\n";
    f += "color += vec4(c0.xyz, 0.0) * float(alv == 10);\n";
    // f += "color_dif = vec4(c0.xyz, 0.0) * float(alv != 10);\n";
    f += "distbr *= float(alv != 10);\n";
    f += "nor += vary_tangent * ut1 * avol;\n";
    f += "nor += vary_binormal * vt1 * avol;\n";
    f += "nor = normalize(nor);\n";
  }
  f += "vec3 reflection_vec = reflect(-light_dir, nor);\n";
  f += "vec3 camera_dir = normalize(camera_pos - vary_position);\n";
  f += "float cos_angle = max(0.0, dot(camera_dir, reflection_vec));\n";
  f += "float specular = pow(cos_angle, 16.0);\n";
  f += "float diffuse = clamp(dot(light_dir, nor), 0.0, 1.0);\n";
  if (g.enable_shadowmapping) {
    if (g.enable_depth_texture) {
      if (g.enable_sampler2dshadow) {
	f += "smpos.z *= 0.9995;\n";
	if (g.enable_shadowmapping_multisample) {
	  f += "lstr = (";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(-0.0003,-0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(-0.0003,0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(0.0003,-0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(0.0003,0.0003,0.0)))";
	  if (!g.is_gl3_or_gles3()) {
	    f += ".r";
	  }
	  f += "  / 4.0;\n";
	} else {
	  f += "lstr = " + g.shadow2d() + "(sampler_sm, smpos)";
	  if (!g.is_gl3_or_gles3()) {
	    f += ".r";
	  }
	  f += ";\n";
	}
      } else {
	f += "float zval = " + g.texture2d();
	f += "   (sampler_sm, smpos.xy * lflag).x;\n";
	f += "lstr = float(smpos.z < zval * 1.0005) * lflag;\n";
      }
    } else {
      f += "vec4 smz = " + g.texture2d();
      f += "  (sampler_sm, smpos.xy * lflag);\n";
      f += "float z0 = floor(smz.r * 255.0 + 0.5);\n";
      f += "float z1 = floor(smz.g * 255.0 + 0.5);\n";
      f += "float z2 = floor(smz.b * 255.0 + 0.5);\n";
      f += "float zval = z0 * 65536.0 + z1 * 256.0 + z2;\n";
      f += "lstr = float(smpos.z * 16770000.0 < zval) * lflag;\n";
    }
    f += "color += vec4(1.0, 1.0, 1.0, 1.0)";
    f += "  * (mate_specular * specular * distbr * distbr * lstr);\n";
  }
  f += g.fragcolor() +  " = color + ";
  f += "  (color_dif * (diffuse * distbr * lstr + mate_ambient));\n";
  f += "}\n";
  return f;
}

function {instancing} triangles_shader_ptr{instancing}
init_triangles_shader(shader_config const& g)
{
  const v = triangles_shader_vert(g, instancing != 0);
  const f = triangles_shader_frag(g, instancing != 0);
//sdllog("triangles_shader", v);
  return
    make_glshader_ptr{
      triangles_uniforms,
      triangles_instance_attributes,
      m::cond{instancing,
	triangles_vertex_attributes, triangles2_vertex_attributes}
    }(v, f, "model_matrix");
}

function particle_shader_ptr
init_particle_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_id(false);
  v += g.decl_instance_attr("mat4", "model_matrix", true, false);
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += "void main(void) {\n";
  v += "gl_Position = " + g.instance_attr("model_matrix", true, false);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_PointSize = point_size_base / gl_Position.w;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord * 2.0 - 1.0;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}(v, f, "model_matrix");
}

function particle_bb_shader_ptr
init_particle_bb_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_id(false);
  v += g.decl_instance_attr("mat4", "model_matrix", true, false);
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat3 camera_matrix;\n";
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec2 local_position;\n";
  v += g.vert_out() + "vec2 point_coord;\n";
  v += "void main(void) {\n";
  v += "vec4 pos = " + g.instance_attr("model_matrix", true, false);
  v += "  * vec4(position, 1.0);\n";
  v += "vec3 posb = camera_matrix";
  v += "  * vec3(local_position * point_size_base, 0.0);\n";
  v += "gl_Position = view_projection_matrix * vec4(pos.xyz + posb, 1.0);\n";
  v += "point_coord = local_position;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec2 point_coord;\n";
  f += "void main(void) {\n";
  f += "vec2 xy = point_coord;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}(v, f, "model_matrix");
}

function lineparticle_shader_ptr
init_lineparticle_shader(shader_config const& g)
{
  const has_inst = true;
  string v;
  v += g.prepend();
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat3", "idata", true, has_inst);
  /*
  v += g.decl_instance_attr("vec3", "position0", true, has_inst);
  v += g.decl_instance_attr("vec3", "position1", true, has_inst);
  v += g.decl_instance_attr("float", "point_size_base", true, has_inst);
  */
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform vec2 screen_size_px;\n";
  v += "uniform float screen_size_base;\n";
  v += g.vert_in() + "vec2 vert;\n";
  v += g.vert_out() + "vec3 vary_coord;\n";
  v += g.vert_out() + "vec2 edge;\n";
  v += "void main(void) {\n";
  v += "vec4 p0p = view_projection_matrix * vec4("
    + g.instance_attr("idata", true, has_inst) + "[0], 1.0);\n";
  v += "vec4 p1p = view_projection_matrix * vec4("
    + g.instance_attr("idata", true, has_inst) + "[1], 1.0);\n";
  v += "float pz0 = p0p.z / p0p.w;\n";
  v += "float pz1 = p1p.z / p1p.w;\n";
  v += "float pz = (pz0 + pz1) * 0.5;\n";
  v += "vec2 p0 = p0p.xy * screen_size_px / p0p.w;\n";
  v += "vec2 p1 = p1p.xy * screen_size_px / p1p.w;\n";
  v += "float is_posi = min(float(p0p.w > 0.0), float(p1p.w > 0.0));\n"; 
  v += "vec2 pvec = p1 - p0;\n"; // FIXME: must be non-zero
  v += "float plen = length(pvec);\n";
  v += "vec2 r = screen_size_base * "
    + g.instance_attr("idata", true, has_inst) + "[2].x"
    + " / vec2(p0p.w, p1p.w);\n";
  v += "float rmx = max(r[0], r[1]);\n";
  // v += "r = max(r, rmx - plen * 0.0625);\n";
  v += "r = max(r, rmx - plen * 0.5);\n";
  v += "float rp = r[0] + (r[1] - r[0]) * vert.x;\n";
  v += "vec2 qvec = normalize(vec2(-pvec.y, pvec.x)) * rp;\n";
  v += "float x_extend_0 = (vert.x - 1.0) * r[0] * 0.5 / plen;\n";
  v += "float x_extend_1 = vert.x * r[1] * 0.5 / plen;\n";
  v += "vec2 vert_ex = vec2(vert.x + x_extend_0 + x_extend_1, vert.y);\n";
  v += "vec2 vpos = p0 + mat2(pvec, qvec) * vert_ex;\n";
  v += "gl_Position = vec4(vpos * is_posi / screen_size_px, pz, 1.0);\n";
  v += "vec2 c = vec2(vert.x - 0.5, vert.y) * 2.0;\n";
  v += "float rrat = r[1] / r[0];\n";
  v += "float rrat_v = 1.0 + (rrat - 1.0) * vert.x;\n";
  v += "vary_coord = vec3(c, 1.0) * rrat_v;\n";
  v += "float edge_rat = clamp(max(r[0], r[1]) / plen, 0.125, 1.0);\n";
  v += "edge = vec2(1.0 - edge_rat, 1.0 / edge_rat);\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec3 vary_coord;\n";
  f += g.frag_in() + "vec2 edge;\n";
  f += "void main(void) {\n";
  f += "vec2 c = vary_coord.xy / vary_coord.z;\n";
  f += "c.x = max(abs(c.x) - edge.x, 0.0) * edge.y;\n";
  f += "float a = 1.0 - length(c);\n";
  f += "if (a < 0.25) { discard; };\n";
  f += g.fragcolor() + " = vec4(a * 2.0, a * 2.0, a * 4.0, 1.0);\n";
  // f += g.fragcolor() + " = vec4(1.0, 1.0, 0.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{lineparticle_uniforms,
    lineparticle_instance_attributes, lineparticle_vertex_attributes}
    (v, f, "");
}

function font2_shader_ptr
init_font2_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += "uniform vec2 screen_size_px;\n";
  v += g.vert_in() + "vec2 texture_size_px;\n";
  v += g.vert_in() + "vec2 texture_origin_px;\n";
  v += g.vert_in() + "vec2 char_size_px;\n";
  v += g.vert_in() + "vec2 coord_clamp;\n";
  v += g.vert_in() + "float char_point_size;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("vec4", "idata", true, true);
  v += g.vert_out() + "vec2 vary_texture_size_px;\n";
  v += g.vert_out() + "vec2 vary_texture_origin_px;\n";
  v += g.vert_out() + "vec2 vary_char_size_px;\n";
  v += g.vert_out() + "vec2 vary_coord_clamp;\n";
  v += g.vert_out() + "float vary_point_size;\n";
  v += "void main(void) {\n";
  v += "vec4 idata_i = " + g.instance_attr("idata", true, true) + ";\n";
  v += "float ch = idata_i.x;\n";
  v += "vec2 screen_pos = idata_i.zw;\n";
  v += "vec2 screen_px = ";
  v += "  floor((screen_pos + 1.0) * screen_size_px * 0.5 + 0.5);\n";
  v += "screen_px += char_point_size * 0.5;\n";
  v += "screen_pos = screen_px / screen_size_px * 2.0 - 1.0;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "gl_PointSize = char_point_size;\n";
  v += "vary_texture_size_px = texture_size_px;\n";
  v += "vary_texture_origin_px = texture_origin_px";
  v += "  + vec2(char_size_px.x * ch, 0.0);\n";
  v += "vary_char_size_px = char_size_px;\n";
  v += "vary_coord_clamp = coord_clamp;\n";
  v += "vary_point_size = char_point_size;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += g.frag_in() + "vec2 vary_texture_size_px;\n";
  f += g.frag_in() + "vec2 vary_texture_origin_px;\n";
  f += g.frag_in() + "vec2 vary_char_size_px;\n";
  f += g.frag_in() + "vec2 vary_coord_clamp;\n";
  f += g.frag_in() + "float vary_point_size;\n";
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord;\n";
  f += "if (xy.x > vary_coord_clamp.x) { discard; }\n";
  f += "vec2 pcoord = vary_point_size * xy;\n";
  f += "vec2 texcoord = (vary_texture_origin_px + pcoord)";
  f += "  / vary_texture_size_px;\n";
  f += "vec4 col = " +  g.texture2d() + "(sampler, texcoord);\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 0.0, col.a);\n";
  f += "}\n";
  return make_glshader_ptr{font2_uniforms, font2_instance_attributes,
    font2_vertex_attributes}(v, f, "idata");
}

function rect2d_shader_ptr
init_rect2d_shader(shader_config const& g)
{
  string v;
  string f;
  v += g.prepend();
  v += g.vert_in() + "vec2 vert;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("vec4", "idata", true, true);
  v += "void main(void) {\n";
  v += "vec4 idata_i = " + g.instance_attr("idata", true, true) + ";\n";
  v += "vec2 screen_pos = idata_i.xy + idata_i.zw * vert;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "}\n";
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 1.0, 0.3);\n";
  f += "}\n";
  return make_glshader_ptr{rect2d_uniforms, rect2d_instance_attributes,
    rect2d_vertex_attributes}(v, f, "idata");
}

private threaded function {t} void
buffer_append(varray{float} mutable& arr, t const& v)
{
  if (m::eq{t, float}) {
    arr.push_back(v);
  } else if (m::or{
    m::eq{t, glm::vec2},
    m::eq{t, glm::vec3},
    m::eq{t, glm::vec4},
    m::eq{t, glm::mat2},
    m::eq{t, glm::mat3},
    m::eq{t, glm::mat4}}) {
    arr.append(v.to_cslice());
  } else {
    expand (sym: m::field_names{t})
    {
      buffer_append(arr, v.sym);
    }
  }
}

private threaded function void prepare_instance_data_default(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  buffer_append(ibarr[0].instance_buffer, sn.trans);
}

private threaded function void prepare_instance_data_triangles(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  buffer_append(ibarr[0].instance_buffer, sn.trans); /* model matrix */
  const smvp = ncd.shadowmapping_vp * sn.trans;
  buffer_append(ibarr[1].instance_buffer, smvp); /* shadowmapping mvp */
}

private threaded function void prepare_instance_data_particle(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  const mvp = ncd.vp * sn.trans;
  buffer_append(ibarr[0].instance_buffer, mvp);
}

private threaded function void prepare_instance_data_lineparticle(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  const sli = sn.trans.to_cslice();
  ibarr[0].instance_buffer.append(sli[0 .. 9]);
}

private threaded function void prepare_instance_data_rect2d(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  const sli = sn.trans.to_cslice();
  ibarr[0].instance_buffer.append(sli[0 .. 4]);
}

private threaded function void prepare_instance_data_font2(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  const sli = sn.trans.to_cslice();
  ibarr[0].instance_buffer.append(sli[0 .. 4]);
}

private threaded function void prepare_instance_data_ft_rec(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  cslice{prepare_instance_data_funcptr} const& ftable,
  varray{instances_type} mutable& ibs)
{
  const bo_id = sn.joint_id.bo_id;
  const vs_id = sn.joint_id.vs_id;
  if (bo_id >= 0 && vs_id >= 0) {
    ++ncd.stat_num_objects;
    mutable& ibarr = ibs[bo_id][static_cast{size_t}(vs_id)];
    ftable[bo_id](sn, ncd, ibarr);
  }
  for (const i, const& snp: sn.children) {
    prepare_instance_data_ft_rec(*snp, ncd, ftable, ibs);
  }
}

