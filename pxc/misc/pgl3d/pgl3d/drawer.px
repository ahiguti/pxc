private threaded namespace pgl3d::drawer "export-unsafe";
public import common -;
public import pointer::raw -;
public import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
public import glm::raw;
public import io::time -;
public import exception -;
public import meta m;
public import pointer::tfuncptr -;
public import GL::compat -;
public import pgl3d::glresource -;
public import pgl3d::glshader -;
public import pgl3d::glgeometry -;
public import pgl3d::glbuffer -;
public import pgl3d::scene_node -;
public import pgl3d::pglbase -;
public import pgl3d::intern_pool -;
public import pgl3d::shader_config -;
public import pgl3d::aggregated_ibuffer -;
public import pgl3d::drawer_base -;
private import io::time -;

public enum draw_step {
  draw_step_shadowmapping = 1,
  draw_step_zprepass = 2,
  draw_step_solid = 3,
  draw_step_blend = 4
}

private tsvaluetype struct triangles_uniforms()
{
  public glm::mat4 view_projection_matrix;
  public int sampler;
  public int sampler_tilemap;
  public int sampler_sm0;
  public int sampler_sm1;
  public int sampler_sm2;
  public int sampler_sm3;
  public glm::vec3 camera_pos;
  public glm::vec3 light_dir;
  public float light_on;
  public float ndelta_scale; // 0.02 / 40. if light_fixed, 0.02 otherwise
  public glm::vec4 shadowmap_distances;
  public glm::vec4 shadowmap_scales;
  public glm::mat4 shadowmap_vp0;
  public glm::mat4 shadowmap_vp1;
  public glm::mat4 shadowmap_vp2;
  public glm::mat4 shadowmap_vp3;
}

private tsvaluetype struct triangles_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
}

private tsvaluetype struct zprepass_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
}

private tsvaluetype struct shadowmap_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
}

private tsvaluetype struct triangles_instance_attributes()
{
  public glm::mat4 model_matrix;
}

private tsvaluetype struct zprepass_uniforms()
{
  public glm::mat4 view_projection_matrix;
}

private tsvaluetype struct shadowmap_uniforms()
{
  public glm::mat4 shadowmap_vp;
  public glm::vec3 trans; // used if light_fixed
  public float scale;     // used if light_fixed
}

private tsvaluetype struct font_uniforms()
{
  public int sampler;
}

private tsvaluetype struct font2_uniforms()
{
  public glm::vec2 screen_size_px;
  public int sampler;
}

private tsvaluetype struct font2_instance_attributes()
{
  public glm::vec4 idata;
}

private tsvaluetype struct font2_vertex_attributes()
{
  public glm::vec2 texture_size_px;
  public glm::vec2 texture_origin_px;
  public glm::vec2 char_size_px;
  public glm::vec2 coord_clamp;
  public float char_px;
  public float char_point_size;
}

private tsvaluetype struct rect2d_vertex_attributes()
{
  public glm::vec2 vert;
}

private tsvaluetype struct rect2d_instance_attributes()
{
  public glm::vec4 idata; // x0, y0, dx, dy
}

private tsvaluetype struct rect2d_uniforms()
{
}

private tsvaluetype struct particle_uniforms()
{
  public float point_size_base;
}

private tsvaluetype struct particle_instance_attributes()
{
  public glm::mat4 model_matrix; // vp applied
}

private tsvaluetype struct particle_vertex_attributes()
{
  public glm::vec3 position;
}

private tsvaluetype struct particle_bb_uniforms()
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 camera_matrix;
  public float point_size_base;
}

private tsvaluetype struct particle_bb_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec2 local_position;
}

private tsvaluetype struct lineparticle_uniforms()
{
  public glm::mat4 view_projection_matrix;
  public glm::vec2 screen_size_px;
  public float screen_size_base;
}

private tsvaluetype struct lineparticle_vertex_attributes()
{
  public glm::vec2 vert;
}

private tsvaluetype struct lineparticle_instance_attributes()
{
  public glm::mat3 idata;
}

private function {tattr} ptr{vertex_buffer}
make_tattr_vertex_buffer(bool points_mode, bool is_sub)
{
  return make_ptr{vertex_buffer}(static_cast{size_t}(num_float_struct{tattr}),
    points_mode, is_sub);
}

public interface pgldrawer_i <pgldrawer_export_i> {
  public function string get_vbid_name() const;
  public function string get_main_vbid_name() const;
    /* returns get_vbid_name() if it's a main drawer */
  public function prepare_instance_data_funcptr
    get_prepare_instance_data_funcptr() const;
  public function ptr{vertex_buffer} make_vertex_buffer() const;
  public function string builtin_vertex_set_name() const;
    /* empty if no builtin vertex set */
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const;
    /* called when builtin_vertex_set_name is not empty */
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const;
  public function texture_info get_texture_info(cstrref const& name) const;
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df);
}

public struct drawer_triangles(shader_config const& glc, int opt0)
<pgldrawer_i>
{
  metafunction tattr triangles_vertex_attributes;
  int const opt = opt0;
  triangles_shader_ptr const sdr_solid = init_triangles_shader(glc, opt);
  zprepass_shader_ptr const sdr_zp = init_zprepass_shader(glc, opt);
  shadowmap_shader_ptr const sdr_shadow = init_shadowmap_shader(glc, opt);
  texture_data texture_dpat;
  texture_data texture_tilemap;
  init();
  private function void init()
  {
    init_main_texture(texture_dpat, texture_tilemap);
  }
  public function string get_vbid_name() const {
    return "vbid_triangles_" + to_string(opt);
  }
  public function string get_main_vbid_name() const {
    return "vbid_triangles_0";
  }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_triangles}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, opt != 0);
  }
  public function string builtin_vertex_set_name() const { return ""; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const { }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_polygon_filler{tattr}(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    if (name == "main") {
      r.surface_w = texture_dpat.surface_w;
      r.surface_h = texture_dpat.surface_h;
    }
    return r;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df)
  {
    if (step == draw_step_shadowmapping) {
      const sm_view = cam_df.light.to_mat4().inverse();
      glm::mat4 sm_vp;
      float scale = 1.0;
      if (iter == 0) { // FIXME
	sm_vp = cam_df.sm_projection0 * sm_view;
	scale = 1.0f / 40.0f;
	//debug_log("sm_vp", sm_vp.to_cslice());
      } else if (iter == 1) {
	sm_vp = cam_df.sm_projection1 * sm_view;
	scale = 1.0f / 120.0f;
      } else if (iter == 2) {
	sm_vp = cam_df.sm_projection2 * sm_view;
	scale = 1.0f / 360.0f;
      } else if (iter == 3) {
	sm_vp = cam_df.sm_projection3 * sm_view;
	scale = 1.0f / 1080.0f;
      }
      glUseProgram(sdr_shadow->program);
      {
	if (glc.light_fixed) {
	  //debug_log("scale", scale);
	  const trans = -cam_df.camera.position;
	  glUniform3fv(sdr_shadow->u_trans, 1, trans.to_crawptr());
	  glUniform1f(sdr_shadow->u_scale, scale);
	} else {
	  glUniformMatrix4fv(sdr_shadow->u_shadowmap_vp, 1, 0,
	    sm_vp.to_crawptr());
	}
	aibuf.draw(*sdr_shadow, bo, bo_ib, bo_id, glc.enable_instanced,
	  glc.enable_uniform_instancing);
      }
    } else if (step == draw_step_zprepass) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      mutable& sdr = *sdr_zp;
      glUseProgram(sdr.program);
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	  glc.enable_uniform_instancing);
    } else if (step == draw_step_solid) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
      mutable& sdr = *sdr_solid;
      glUseProgram(sdr.program);
      if (glc.light_fixed) {
	glUniform3fv(sdr.u_light_dir, 1,
	  glm::make_vec3(0.0, 0.0, -1.0).to_crawptr());
      } else {
	glUniform3fv(sdr.u_light_dir, 1,
	  (cam_df.light.angle * glm::make_vec3(0.0, 0.0, 1.0)).to_crawptr());
      }
      glUniform3fv(sdr.u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glUniform1i(sdr.u_sampler, 1);
      glUniform1i(sdr.u_sampler_tilemap, 2);
      glUniform1i(sdr.u_sampler_sm0, 3);
      glUniform1i(sdr.u_sampler_sm1, 4);
      glUniform1i(sdr.u_sampler_sm2, 5);
      glUniform1i(sdr.u_sampler_sm3, 6);
      glUniform1f(sdr.u_light_on, 1.0f);
      if (glc.light_fixed) {
	const scales = glm::make_vec4(1.0f/40.0f, 1.0f/120.0f, 1.0f/360.0f,
	  1.0f/1080.0f);
	glUniform4fv(sdr.u_shadowmap_scales, 1, scales.to_crawptr());
	glUniform1f(sdr.u_ndelta_scale,
	  static_cast{float}(8192 / cam_df.shadowmap_size) * 0.02 / 40.0);
      } else {
	const sm_view = cam_df.light.to_mat4().inverse();
	const sm_vp0 = cam_df.sm_projection0 * sm_view;
	const sm_vp1 = cam_df.sm_projection1 * sm_view;
	const sm_vp2 = cam_df.sm_projection2 * sm_view;
	const sm_vp3 = cam_df.sm_projection3 * sm_view;
	glUniformMatrix4fv(sdr.u_shadowmap_vp0, 1, 0, sm_vp0.to_crawptr());
	glUniformMatrix4fv(sdr.u_shadowmap_vp1, 1, 0, sm_vp1.to_crawptr());
	glUniformMatrix4fv(sdr.u_shadowmap_vp2, 1, 0, sm_vp2.to_crawptr());
	glUniformMatrix4fv(sdr.u_shadowmap_vp3, 1, 0, sm_vp3.to_crawptr());
	glUniform1f(sdr.u_ndelta_scale,
	  static_cast{float}(8192 / cam_df.shadowmap_size) * 0.02);
      }
      glUniform4fv(sdr.u_shadowmap_distances, 1,
	cam_df.sm_distances.to_crawptr());
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0, vp.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_lineparticle(shader_config const& glc)
<pgldrawer_i>
{
  metafunction tattr lineparticle_vertex_attributes;
  lineparticle_shader_ptr sdr_lp = init_lineparticle_shader(glc);
  public function string get_vbid_name() const { return "vbid_lineparticle"; }
  public function string get_main_vbid_name() const {
    return "vbid_lineparticle"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_lineparticle}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, false);
  }
  public function string builtin_vertex_set_name() const {
    return "lineparticle";
  }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const
  {
    farray{lineparticle_vertex_attributes, 4} vs;
    vs[0].vert = glm::make_vec2(0.0, -0.5);
    vs[1].vert = glm::make_vec2(1.0, -0.5);
    vs[2].vert = glm::make_vec2(1.0, 0.5);
    vs[3].vert = glm::make_vec2(0.0, 0.5);
    vptr->push_polygon_distinct{lineparticle_vertex_attributes, 0}(vs);
  }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df)
  {
    if (step == draw_step_solid) {
      mutable cam_mat = glm::mat4();
      cam_mat = cam_df.camera.to_mat4();
      const vp = cam_df.projection * (cam_mat.inverse());
      const screen_size_px = make_farray{float}(
	cast_float(cam_df.screen_width), cast_float(cam_df.screen_height));
      const screen_size_base = cast_float(
	max(cam_df.screen_width, cam_df.screen_height));
      mutable& sdr = *sdr_lp;
      glUseProgram(sdr.program);
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      glUniform2fv(sdr.u_screen_size_px, 1, screen_size_px.to_crawptr());
      glUniform1fv(sdr.u_screen_size_base, 1, caddress(screen_size_base));
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_particle(shader_config const& glc)
<pgldrawer_i>
{
  metafunction tattr particle_vertex_attributes;
  particle_shader_ptr sdr_sp = init_particle_shader(glc);
  public function string get_vbid_name() const { return "vbid_particle"; }
  public function string get_main_vbid_name() const { return "vbid_particle"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_particle}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(true, false);
  }
  public function string builtin_vertex_set_name() const { return ""; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const { }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_particle_filler(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df)
  {
    if (step == draw_step_blend) {
      glBlendFunc(GL_ONE, GL_ONE);
      mutable& sdr = *sdr_sp;
      glUseProgram(sdr.program);
      glUniform1f(sdr.u_point_size_base,
	0.1f * static_cast{float}(max(
	  cam_df.screen_width, cam_df.screen_height)));
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_particle_bb(shader_config const& glc)
<pgldrawer_i>
{
  metafunction tattr particle_bb_vertex_attributes;
  particle_bb_shader_ptr sdr_pb = init_particle_bb_shader(glc);
  public function string get_vbid_name() const { return "vbid_particle_bb"; }
  public function string get_main_vbid_name() const {
    return "vbid_particle_bb"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_default}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, false);
  }
  public function string builtin_vertex_set_name() const { return ""; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const { }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_particle_bb_filler(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df)
  {
    if (step == draw_step_blend) {
      glBlendFunc(GL_ONE, GL_ONE);
      mutable& sdr = *sdr_pb;
      glUseProgram(sdr.program);
      mutable cam_mat = glm::mat4();
      cam_mat = cam_df.camera.to_mat4();
      const vp = cam_df.projection * (cam_mat.inverse());
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      glUniformMatrix3fv(sdr.u_camera_matrix, 1, 0,
	cam_mat.to_3().to_crawptr());
      glUniform1f(sdr.u_point_size_base, 0.1f);
      aibuf.draw(sdr, bo, bo_ib, bo_id,
	glc.enable_instanced, glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_font2(shader_config const& glc)
<pgldrawer_i>
{
  metafunction tattr font2_vertex_attributes;
  font2_shader_ptr sdr_fn = init_font2_shader(glc);
  texture_data texture_font;
  init();
  private function void init()
  {
    init_font(texture_font);
  }
  public function string get_vbid_name() const { return "vbid_font2"; }
  public function string get_main_vbid_name() const { return "vbid_font2"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_font2}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(true, false);
  }
  public function string builtin_vertex_set_name() const {
    return "default_font";
  }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const
  {
    const ti = get_texture_info("font");
    const char_w = static_cast{float}(ti.char_w);
    const char_h = static_cast{float}(ti.char_h);
    const point_size = static_cast{float}(max(ti.char_w, ti.char_h));
    const char_size_px = glm::make_vec2(char_w, char_h);
    const texture_size_px = glm::make_vec2(
      static_cast{float}(ti.surface_w),
      static_cast{float}(ti.surface_h));
    const clamp_x = char_w / point_size;
    const clamp_y = char_h / point_size;
    font2_vertex_attributes v;
    v.char_size_px = char_size_px;
    v.texture_size_px = texture_size_px;
    v.texture_origin_px = glm::make_vec2(0.0, 0.0);
    v.coord_clamp = glm::make_vec2(clamp_x, clamp_y);
    v.char_px = static_cast{float}(ti.char_w);
    v.char_point_size = point_size;
    vptr->push_point{font2_vertex_attributes}(v);
  }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    if (name == "font") {
      r.surface_w = texture_font.surface_w;
      r.surface_h = texture_font.surface_h;
      r.char_w = texture_font.char_w;
      r.char_h = texture_font.char_h;
    }
    return r;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df)
  {
    if (step == draw_step_blend) {
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      const screen_size_px = glm::make_vec2(
	static_cast{float}(cam_df.screen_width),
	static_cast{float}(cam_df.screen_height));
      mutable& sdr = *sdr_fn;
      glUseProgram(sdr.program);
      glUniform1i(sdr.u_sampler, 0);
      glUniform2fv(sdr.u_screen_size_px, 1, screen_size_px.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id,
	glc.enable_instanced, glc.enable_uniform_instancing);
    }
  }
}

public struct drawer_rect2d(shader_config const& glc)
<pgldrawer_i>
{
  metafunction tattr rect2d_vertex_attributes;
  rect2d_shader_ptr sdr_re = init_rect2d_shader(glc);
  public function string get_vbid_name() const { return "vbid_rect2d"; }
  public function string get_main_vbid_name() const { return "vbid_rect2d"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_rect2d}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, false);
  }
  public function string builtin_vertex_set_name() const { return "rect2d"; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const
  {
    farray{rect2d_vertex_attributes, 4} vs;
    vs[0].vert = glm::make_vec2(0.0, 0.0);
    vs[1].vert = glm::make_vec2(1.0, 0.0);
    vs[2].vert = glm::make_vec2(1.0, 1.0);
    vs[3].vert = glm::make_vec2(0.0, 1.0);
    vptr->push_polygon_distinct{rect2d_vertex_attributes, 0}(vs);
  }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df)
  {
    if (step == draw_step_blend) {
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      mutable& sdr = *sdr_re;
      glUseProgram(sdr.program);
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

/* private */

private threaded function {tattr} void
dgf_fill_tattr_internal(ptr{vertices} const& vptr, bool flat_flag,
  poly_t const& poly, mesh_index const& mp)
{
  const sz = poly.size();
  if (sz < 3) { return; }
  glm::vec3 mutable nor;
  glm::vec3 mutable tang;
  if (flat_flag) {
    nor = normal_from_poly(poly);
    tang = (poly[1].pos - poly[0].pos).normalize();
  }
  mutable vtxs = darrayst{tattr}(sz, tattr());
  for (const i: 0 .. sz) {
    mutable& v = vtxs[i];
    v.position = poly[i].pos;
    if (flat_flag) {
      v.normal = nor;
      v.tangent = glm::make_vec3(tang.x, tang.y, tang.z);
    } else {
      v.normal = poly[i].nor;
      v.tangent = poly[i].tan;
    }
    v.uvw = glm::vec3();
  }
  if (sz == 4) {
    const c0 = (poly[0].pos + poly[1].pos);
    const c1 = (poly[1].pos + poly[2].pos);
    const c2 = (poly[2].pos + poly[3].pos);
    const c3 = (poly[3].pos + poly[0].pos);
    const c02 = c2 - c0;
    const c13 = c3 - c1;
    if (fabs(glm::dot(c02, c13)) < glm::length(c02) * glm::length(c13) * 0.05)
    {
      /* 01, 23 */
      const v01 = poly[1].pos - poly[0].pos;
      const v23 = poly[3].pos - poly[2].pos;
      const dotv0123 = glm::dot(v01, -v23);
      const lenv01 = glm::length(v01);
      const lenv23 = glm::length(v23);
      const cosv0123 = dotv0123 / (lenv01 * lenv23);
      const ratv2301 = lenv23 / lenv01;
      /* 12, 30 */
      const v12 = poly[2].pos - poly[1].pos;
      const v30 = poly[0].pos - poly[3].pos;
      const dotv1230 = glm::dot(v12, -v30);
      const lenv12 = glm::length(v12);
      const lenv30 = glm::length(v30);
      const cosv1230 = dotv1230 / (lenv12 * lenv30);
      const ratv3012 = lenv30 / lenv12;
      /* */
      const lenv0123 = lenv01 + lenv23;
      const lenv1230 = lenv12 + lenv30;
      mutable co = glm::make_vec2(32.0f, 32.0f);
      co.x = max(4.0f, min(128.0f, floor(lenv0123)));
      co.y = max(4.0f, min(128.0f, floor(lenv1230)));
      /*
      if (lenv0123 > lenv1230) {
	co.y = min(floor(lenv0123 * 4.0f / lenv1230), 128.0f);
      } else {
	co.x = min(floor(lenv1230 * 4.0f / lenv0123), 128.0f);
      }
      */
      if (cosv0123 > cosv1230) {
	if (ratv2301 > 0.25 && ratv2301 < 4.0 && cosv0123 > 0.95f) {
	  vtxs[0].uvw = glm::make_vec3(0.0f, 0.0f, 1.0f);
	  vtxs[1].uvw = glm::make_vec3(co.x, 0.0f, 1.0f);
	  vtxs[2].uvw = glm::make_vec3(co.x, co.y, 1.0f);
	  vtxs[3].uvw = glm::make_vec3(0.0f, co.y, 1.0f);
	  if (ratv2301 > 1.0f) {
	    vtxs[2].uvw *= ratv2301;
	    vtxs[3].uvw *= ratv2301;
	  } else if (ratv2301 < 1.0f) {
	    vtxs[0].uvw /= ratv2301;
	    vtxs[1].uvw /= ratv2301;
	  }
	}
      } else {
	if (ratv3012 > 0.25 && ratv3012 < 4.0 && cosv1230 > 0.95f) {
	  vtxs[0].uvw = glm::make_vec3(0.0f, 0.0f, 1.0f);
	  vtxs[1].uvw = glm::make_vec3(co.x, 0.0f, 1.0f);
	  vtxs[2].uvw = glm::make_vec3(co.x, co.y, 1.0f);
	  vtxs[3].uvw = glm::make_vec3(0.0f, co.y, 1.0f);
	  if (ratv3012 > 1.0f) {
	    vtxs[3].uvw *= ratv3012;
	    vtxs[0].uvw *= ratv3012;
	  } else if (ratv3012 < 1.0f) {
	    vtxs[1].uvw /= ratv3012;
	    vtxs[2].uvw /= ratv3012;
	  }
	}
      }
    }
  }
  vptr->push_polygon_distinct{tattr, 1}(vtxs);
}

private threaded function {tattr} void
dgf_polygon_filler_tattr(ptr{vertices} const& vptr, bool flat_flag,
  poly_t const& poly, mesh_index const& mp)
{
  dgf_fill_tattr_internal{tattr}(vptr, flat_flag, poly, mp);
}

private threaded function void
dgf_particle_internal(ptr{vertices} const& vptr, bool flat_flag,
  poly_t const& poly, mesh_index const& mp)
{
  for (const i, const& p: poly) {
    particle_vertex_attributes x;
    x.position = p.pos;
    vptr->push_point{particle_vertex_attributes}(x);
  }
}

private threaded function void
dgf_particle_bb_internal(ptr{vertices} const& vptr, bool flat_flag,
  poly_t const& poly, mesh_index const& mp)
{
  for (const i, const& p: poly) {
    farray{particle_bb_vertex_attributes, 4} vtxs;
    for (const j, mutable& v: vtxs) {
      v.position = p.pos;
    }
    vtxs[0].local_position = glm::make_vec2(-1.0, -1.0);
    vtxs[1].local_position = glm::make_vec2( 1.0, -1.0);
    vtxs[2].local_position = glm::make_vec2( 1.0,  1.0);
    vtxs[3].local_position = glm::make_vec2(-1.0,  1.0);
    vptr->push_polygon_distinct{particle_bb_vertex_attributes, 0}(vtxs);
  }
}

private threaded function void
dgf_noop(ptr{vertices} const& vptr, bool flat_flag, poly_t const& poly,
  mesh_index const& mp)
{
}

public metafunction dgf_filler
  callable_ptr{void, {bool, poly_t, mesh_index}};

private threaded function {tattr} dgf_filler
make_dgf_polygon_filler(ptr{vertices} const& vptr)
{
  return make_callable_ptr{dgf_polygon_filler_tattr{tattr}, 1}(vptr);
}

private threaded function dgf_filler
make_dgf_particle_filler(ptr{vertices} const& vptr)
{
  return make_callable_ptr{dgf_particle_internal, 1}(vptr);
}

private threaded function dgf_filler
make_dgf_particle_bb_filler(ptr{vertices} const& vptr)
{
  return make_callable_ptr{dgf_particle_bb_internal, 1}(vptr);
}

private threaded function dgf_filler
make_dgf_noop(ptr{vertices} const& vptr)
{
  return make_callable_ptr{dgf_noop, 1}(vptr);
}

metafunction triangles_shader_ptr
  ptr{glshader{
    triangles_uniforms, triangles_instance_attributes,
    triangles_vertex_attributes}};
metafunction shadowmap_shader_ptr
  ptr{glshader{
    shadowmap_uniforms, triangles_instance_attributes,
    shadowmap_vertex_attributes}};
metafunction zprepass_shader_ptr
  ptr{glshader{
    zprepass_uniforms, triangles_instance_attributes,
    zprepass_vertex_attributes}};
metafunction font2_shader_ptr
  ptr{glshader{
    font2_uniforms, font2_instance_attributes, font2_vertex_attributes}};
metafunction rect2d_shader_ptr
  ptr{glshader{
    rect2d_uniforms, rect2d_instance_attributes, rect2d_vertex_attributes}};
metafunction particle_shader_ptr
  ptr{glshader{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}};
metafunction particle_bb_shader_ptr
  ptr{glshader{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}};
metafunction lineparticle_shader_ptr
  ptr{glshader{lineparticle_uniforms, lineparticle_instance_attributes,
    lineparticle_vertex_attributes}};

function shadowmap_shader_ptr
init_shadowmap_shader(shader_config const& g, int opt)
{
  string v;
  v += g.prepend();
  if (g.light_fixed) {
    v += "uniform vec3 trans;\n";
    v += "uniform float scale;\n";
  } else {
    v += "uniform mat4 shadowmap_vp;\n";
  }
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += g.vert_in() + "vec3 position;\n";
  if (opt != 0) {
    v += g.vert_in() + "vec3 uvw;\n";
    v += g.vert_out() + "vec3 vary_uvw;\n";
  }
  if (!g.enable_depth_texture) {
    v += g.vert_out() + "vec4 vary_smpos;\n";
  }
  v += "void main(void) {\n";
  if (g.light_fixed) {
    v += "vec4 p = ";
    v += g.instance_attr("model_matrix");
    v += "  * vec4(position, 1.0);\n";
    v += "vec3 p1 = p.xyz + trans;\n";
    v += "p1 *= scale;\n";
    // v += "p1.z = -p1.z;\n";
    v += "p = vec4(p1, 1.0);\n";
    v += "gl_Position = p;\n";
  } else {
    v += "vec4 p = shadowmap_vp * (";
    v += g.instance_attr("model_matrix");
    v += "  * vec4(position, 1.0));\n";
    v += "gl_Position = p;\n";
  }
  if (!g.enable_depth_texture) {
    v += "vary_smpos = p;\n";
  }
  if (opt != 0) {
    v += "vary_uvw = uvw;\n";
  }
  v += "}\n";
  string f;
  if (g.enable_depth_texture && opt == 0) {
    f += g.empty_shader_frag();
  } else {
    f += g.prepend();
    if (opt != 0) {
      f += g.frag_in() + "vec3 vary_uvw;\n";
    }
    if (!g.enable_depth_texture) {
      f += g.frag_in() + "vec4 vary_smpos;\n";
      f += g.decl_fragcolor();
    }
    f += "void main(void) {\n";
    if (opt != 0) {
      if (g.enable_normalmapping) {
	f += "const float tile_size = 32.0;\n";
	f += "const float tilemap_size = 128.0;\n";
	f += "const float tiletex_size = 256.0;\n";
	f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
	f += "vec2 uv_tm = floor(uv0);\n";
	      /* tilemap coordinate */
	f += "vec2 uv_tmfr = uv0 - uv_tm;\n";
	      /* coordinate inside a tile (0, 1) */
	f += "vec2 uvp = uv_tmfr - 0.5;\n";
	f += "if (dot(uvp, uvp) < 0.125) { discard; }\n";
      }
    }
    if (!g.enable_depth_texture) {
      f += "  vec4 p = vary_smpos;\n";
      f += "  float pz = (p.z/p.w + 1.0) / 2.0;\n";
      // TODO: vectorize
      f += "  float z = pz * 256.0;\n";/* [0.0, 256.0] */
      f += "  float z0 = floor(z);\n"; /* [0, 256] */
      f += "  z = (z - z0) * 256.0;\n"; /* [0.0, 256.0) */
      f += "  float z1 = floor(z);\n"; /* [0, 256) */
      f += "  z = (z - z1) * 256.0;\n"; /* [0.0, 256.0) */
      f += "  float z2 = floor(z);\n";  /* [0, 256) */
      f += g.fragcolor() + "= vec4(z0/255.0, z1/255.0, z2/255.0, 1.0);\n";
    }
    f += "}\n";
  }
  return make_glshader_ptr{
    shadowmap_uniforms,
    triangles_instance_attributes,
    shadowmap_vertex_attributes
  }(v, f, "model_matrix", g.debug_level);
}

function zprepass_shader_ptr
init_zprepass_shader(shader_config const& g, int opt)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += g.vert_in() + "vec3 position;\n";
  if (opt != 0) {
    v += g.vert_in() + "vec3 uvw;\n";
    v += g.vert_out() + "vec3 vary_uvw;\n";
  }
  v += "void main(void) {\n";
  v += "vec4 gpos4 = " + g.instance_attr("model_matrix");
  v += "  * vec4(position, 1.0);\n";
  v += "gl_Position = view_projection_matrix * gpos4;\n";
  if (opt != 0) {
    v += "vary_uvw = uvw;\n";
  }
  v += "}\n";
  string f;
  if (opt == 0) {
    f = g.empty_shader_frag();
  } else {
    f += g.prepend();
    f += g.frag_in() + "vec3 vary_uvw;\n";
    // f += g.decl_fragcolor();
    f += "void main(void) {\n";
    if (g.enable_normalmapping) {
      f += "const float tile_size = 32.0;\n";
      f += "const float tilemap_size = 128.0;\n";
      f += "const float tiletex_size = 256.0;\n";
      f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
      f += "vec2 uv_tm = floor(uv0);\n";
	    /* tilemap coordinate */
      f += "vec2 uv_tmfr = uv0 - uv_tm;\n";
	    /* coordinate inside a tile (0, 1) */
      f += "vec2 p = uv_tmfr - 0.5;\n";
      f += "if (dot(p, p) < 0.125) { discard; }\n";
    }
    f += "}\n";
  }
  return make_glshader_ptr{
    zprepass_uniforms,
    triangles_instance_attributes,
    zprepass_vertex_attributes
  }(v, f, "model_matrix", g.debug_level);
}

function string
triangles_shader_vert(shader_config const& g, int opt)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  if (g.light_fixed) {
    v += "uniform vec4 shadowmap_scales;\n";
    v += "uniform vec3 camera_pos;\n";
  } else {
    v += "uniform mat4 shadowmap_vp0;\n";
    v += "uniform mat4 shadowmap_vp1;\n";
    v += "uniform mat4 shadowmap_vp2;\n";
    v += "uniform mat4 shadowmap_vp3;\n";
  }
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec3 normal;\n";
  v += g.vert_in() + "vec3 tangent;\n";
  v += g.vert_in() + "vec3 uvw;\n";
  v += g.vert_out() + "vec3 vary_position;\n";
  v += g.vert_out() + "vec3 vary_normal;\n";
  v += g.vert_out() + "vec3 vary_tangent;\n";
  v += g.vert_out() + "vec3 vary_uvw;\n";
  v += g.vert_out() + "vec3 vary_binormal;\n";
  v += g.vert_out() + "vec3 vary_color;\n";
  if (g.enable_shadowmapping) {
    if (!g.light_fixed) {
      v += g.vert_out() + "vec3 vary_smpos0;\n";
      v += g.vert_out() + "vec3 vary_smpos1;\n";
      v += g.vert_out() + "vec3 vary_smpos2;\n";
      v += g.vert_out() + "vec3 vary_smpos3;\n";
      v += "uniform float ndelta_scale;\n"; // 0.02
    }
  }
  v += "void main(void) {\n";
  v += "  mat4 mm = "
    + g.instance_attr("model_matrix")
    + ";\n";
  if (g.is_gl3_or_gles3()) {
    v += "  vary_color = vec3(0.5 + float(gl_InstanceID % 4) * 0.0625, 0.4,";
    v += "    float(gl_InstanceID % 8) * 0.0625);\n";
  } else {
    v += "  vary_color = vec3(0.5, 0.4, 0.5);\n";
  }
  v += "  vec4 gpos4 = mm * vec4(position, 1.0);\n";
  v += "  gl_Position = view_projection_matrix * gpos4;\n";
  if (g.is_gl3_or_gles3()) {
    v += "  mat3 normal_matrix = mat3(mm);\n";
  } else {
    v += "  mat3 normal_matrix = mat3(mm[0].xyz, mm[1].xyz, mm[2].xyz);\n";
  }
  v += "  vary_position = gpos4.xyz / gpos4.w;\n";
  v += "  vary_normal = normal_matrix * normal;\n";
  v += "  vary_tangent = normal_matrix * tangent;\n";
  v += "  vary_uvw = uvw;\n";
  v += "  vary_binormal = cross(vary_normal, vary_tangent);\n";
  if (g.enable_shadowmapping) {
    if (!g.light_fixed) {
      v += "  vec3 ndelta = mat3(shadowmap_vp0) * vary_normal ";
      v += "    * ndelta_scale;\n"; // 0.02
      v += "  vec4 p;\n";
      v += "  vec4 ngpos4 = vec4(vary_position, 1.0);\n";
      v += "  p = shadowmap_vp0 * ngpos4;\n";
      v += "  vary_smpos0 = p.xyz / p.w + ndelta;\n";
      v += "  p = shadowmap_vp1 * ngpos4;\n";
      v += "  vary_smpos1 = p.xyz / p.w + ndelta;\n";
      v += "  p = shadowmap_vp2 * ngpos4;\n";
      v += "  vary_smpos2 = p.xyz / p.w + ndelta;\n";
      v += "  p = shadowmap_vp3 * ngpos4;\n";
      v += "  vary_smpos3 = p.xyz / p.w + ndelta;\n";
    }
  }
  v += "}\n";
  return v;
}

function string triangles_shader_frag(shader_config const& g, int opt)
{
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += "uniform sampler2D sampler_tilemap;\n";
  f += "uniform vec4 shadowmap_distances;\n";
  if (g.enable_sampler2dshadow) {
    f += "uniform sampler2DShadow sampler_sm0;\n";
    f += "uniform sampler2DShadow sampler_sm1;\n";
    f += "uniform sampler2DShadow sampler_sm2;\n";
    f += "uniform sampler2DShadow sampler_sm3;\n";
  } else {
    f += "uniform sampler2D sampler_sm0;\n";
    f += "uniform sampler2D sampler_sm1;\n";
    f += "uniform sampler2D sampler_sm2;\n";
    f += "uniform sampler2D sampler_sm3;\n";
  }
  f += "uniform vec3 camera_pos;\n";
  f += "uniform vec3 light_dir;\n";
  f += "uniform float light_on;\n";
  f += g.frag_in() + "vec3 vary_position;\n";
  f += g.frag_in() + "vec3 vary_normal;\n";
  f += g.frag_in() + "vec3 vary_tangent;\n";
  f += g.frag_in() + "vec3 vary_uvw;\n";
  f += g.frag_in() + "vec3 vary_binormal;\n";
  f += g.frag_in() + "vec3 vary_color;\n";
  if (g.enable_shadowmapping) {
    if (!g.light_fixed) {
      f += g.frag_in() + "vec3 vary_smpos0;\n";
      f += g.frag_in() + "vec3 vary_smpos1;\n";
      f += g.frag_in() + "vec3 vary_smpos2;\n";
      f += g.frag_in() + "vec3 vary_smpos3;\n";
    } else {
      f += "uniform float ndelta_scale;\n"; // 0.02 / 40.0
    }
  }
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  /*
  f += "vec3 light_dir = normalize(light_pos - vary_position);\n";
  f += "float light_distance = length(light_pos - vary_position);\n";
  */
  // f += "vec3 light_dir = normalize(light_pos);\n";
  // f += "vec3 light_dir = vec3(0.0, -1.0, 0.0);\n";
  f += "float light_distance = 1.0;\n";
  f += "vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n";
  if (opt != 0) {
    f += "vec4 color_dif = vec4(0.52, 0.28, 0.42, 1.0);\n";
  } else {
    f += "vec4 color_dif = vec4(vary_color, 1.0);\n";
    // f += "vec4 color_dif = vec4(0.20, 0.22, 0.21, 1.0);\n";
  }
  f += "float mate_ambient = 0.2;\n";
  f += "float mate_specular = 0.5;\n";
  /*
  f += "float distbr = min(3000.0 / (light_distance * light_distance), ";
  f += "  light_on);\n";
  */
  // f += "float distbr = 1.0;\n";
  f += "vec3 nor = vary_normal;\n";
  f += "vec3 rel_camera_pos = camera_pos - vary_position;\n";
  f += "vec3 camera_dir = normalize(rel_camera_pos);\n";
  f += "float is_front = float(dot(camera_dir, nor) > 0.0);\n";
  f += "float frag_distance = length(rel_camera_pos);\n";
  f += "float distbr = clamp(30.0 / frag_distance , 0.0, 1.0);\n";
  if (g.enable_normalmapping) {
    f += "const float tile_size = 32.0;\n";
    f += "const float tilemap_size = 128.0;\n";
    f += "const float tiletex_size = 256.0;\n";
    f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
    f += "vec2 uv_tm = floor(uv0);\n";
	  // tilemap coordinate
    f += "vec2 uv_tmfr = uv0 - uv_tm;\n";
	  // coordinate inside a tile (0, 1)
    if (opt != 0) {
      f += "vec2 p = uv_tmfr - 0.5;\n";
      f += "if (dot(p, p) < 0.125) { discard; }\n";
    }
    f += "vec2 uv_ti = uv_tmfr * tile_size;\n";
    f += "vec2 uvi = floor(uv_ti);\n";
	  // coordinate inside a tile, integral
    f += "vec2 uvj = uv_ti - uvi;\n";
	  // subpixel coordinate
    f += "vec4 ti = " +  g.texture2d();
    f += "  (sampler_tilemap, uv_tm / tilemap_size);\n";
	  // lookup the tilemap
    f += "vec2 uv_pixel = floor(ti.xy * 255.0 + 0.5) * tile_size + uvi;\n";
	  // tile pattern coordinate
    // f += "mate_ambient = ti.z;\n";
    f += "mate_specular = ti.w;\n";
    f += "vec4 c0 = " + g.texture2d();
    f += "  (sampler, uv_pixel / tiletex_size);\n";
	  // lookup the tilepattern
    f += "float alv0 = floor(c0.a * 255.0 + 0.5);\n";
    f += "float avol = floor(alv0 / 16.0);\n";
    f += "int alv = int(alv0 - avol * 16.0 + 0.5);\n";
    f += "float lt = float(uvj.y - uvj.x >= 0.0);\n";
    f += "float lb = float(uvj.y + uvj.x <= 1.0);\n";
    f += "vec4 avlv = vec4(float(alv == 1), float(alv == 3), ";
    f += "  float(alv == 5), float(alv == 7));\n";
    f += "float ut1 = dot(avlv, vec4(-lt, 1.0-lb, 1.0-lt, -lb));\n";
    f += "float vt1 = dot(avlv, vec4(lt-1.0, -lb, lt, 1.0-lb));\n";
    f += "ut1 += float(alv == 4);\n";
    f += "vt1 -= float(alv == 2);\n";
    f += "avol = (avol - 8.0) * distbr * 0.2;\n";
    f += "color += vec4(c0.xyz, 0.0) * float(alv == 10);\n";
    // f += "color_dif = vec4(c0.xyz, 0.0) * float(alv != 10);\n";
    f += "distbr *= float(alv != 10);\n";
    f += "vec3 nor_delta = vary_tangent * ut1 * avol\n";
    f += "  + vary_binormal * vt1 * avol;\n";
    if (opt != 0) {
      f += "nor_delta *= is_front;\n";
    }
    f += "nor = normalize(nor + nor_delta);\n";
  }
  f += "vec3 reflection_vec = reflect(-light_dir, nor);\n";
  f += "float cos_angle = max(0.0, dot(camera_dir, reflection_vec));\n";
  f += "float specular = pow(cos_angle, 16.0);\n";
  f += "float diffuse = clamp(dot(light_dir, nor), 0.0, 1.0);\n";
  if (opt == 0) {
    /* no specular and diffuse for opt0 shader */
    f += "specular = min(specular, is_front);\n";
    f += "diffuse = min(diffuse, is_front);\n";
  }
  if (g.enable_shadowmapping) {
    /*
    f += "vec3 smpos = ((vary_smpos0.xyz / vary_smpos0.w) + 1.0) * 0.5;\n";
    f += "float lflag = float(";
    f += " all(greaterThan(smpos, vec3(0.0f))) && ";
    f += " all(lessThan(smpos, vec3(1.0f))));\n";
    */
    /*
    f += "float lflag = float(int(smpos.x <= 0.0) + int(smpos.x >= 1.0)";
    f += "  + int(smpos.y <= 0.0) + int(smpos.y >= 1.0) + int(smpos.z <= 0.0)";
    f += "  + int(smpos.z >= 1.0) == 0);\n";
      // FIXME: clamp?
    */
    f += "float lflag = 1.0;\n";
  } else {
    f += "float lflag = 1.0;\n";
  }
  f += "float lstr = lflag;\n";
    /* lstr := 0 for backface */
  if (g.enable_shadowmapping) {
    if (true) {
    if (g.light_fixed) {
      f += "vec3 ndelta = vary_normal * ndelta_scale;\n"; // 0.02 / 40.
      f += "vec3 prel = vary_position - camera_pos;\n";
      f += "vec3 p0 = prel / 40. + ndelta;\n";
      f += "vec3 p1 = prel / 120. + ndelta;\n";
      f += "vec3 p2 = prel / 360. + ndelta;\n";
      f += "vec3 p3 = prel / 1080. + ndelta;\n";
    } else {
      f += "vec3 p0 = vary_smpos0;\n";
      f += "vec3 p1 = vary_smpos1;\n";
      f += "vec3 p2 = vary_smpos2;\n";
      f += "vec3 p3 = vary_smpos3;\n";
    }
    for (int i: 0 .. 4) {
      const x = to_string(i);
      if (g.enable_depth_texture) {
	if (i == 0) {
	  f += "vec3 smpos;\n";
	}
	f += "smpos = (p"+x+" + 1.0) * 0.5;\n";
	f += "float zval"+x+" = " + g.texture2d();
	f += "  (sampler_sm"+x+", smpos.xy).x;\n";
	f += "float smd"+x+" = (smpos.z - zval"+x+" * 1.0005);\n";
      } else {
	if (i == 0) {
	  f += "vec3 smpos;\n";
	  f += "vec3 smz;\n";
	}
	f += "smpos = (p"+x+" + 1.0) * 0.5;\n";
	f += "smz = " + g.texture2d();
	f += "  (sampler_sm"+x+", smpos.xy * lflag).rgb;\n";
	f += "smz = floor(smz * 255.0 + 0.5);\n";
	f += "float zval"+x+" = ";
	f += "  smz.r / 256. + smz.g / 65536.0 + smz.b / 16777216.;\n";
	f += "float smd"+x+" = (smpos.z - zval"+x+" * 1.0005);\n";
      }
    }
    f += "float smv0 = float(smd0 < 0. ||";
    f += "  any(greaterThanEqual(p0, vec3(1.0,1.0,1.0))));\n";
    f += "bool n1 = all(lessThan(abs(p1),vec3(0.32,0.32,0.32))) &&";
    f += "  abs(zval1 - 0.5) * 2.0 < 0.32;\n";
    f += "float smv1 = float(smd1 < 0. || n1 ||";
    f += "  any(greaterThanEqual(p1, vec3(1.0,1.0,1.0))));\n";
    f += "bool n2 = all(lessThan(abs(p2),vec3(0.32,0.32,0.32))) &&";
    f += "  abs(zval2 - 0.5) * 2.0 < 0.32;\n";
    f += "float smv2 = float(smd2 < 0. || n2 ||";
    f += "  any(greaterThanEqual(p2, vec3(1.0,1.0,1.0))));\n";
    f += "bool n3 = all(lessThan(abs(p3),vec3(0.32,0.32,0.32))) &&";
    f += "  abs(zval3 - 0.5) * 2.0 < 0.32;\n";
    f += "float smv3 = float(smd3 < 0. || n3 ||";
    f += "  any(greaterThanEqual(p3, vec3(1.0,1.0,1.0))));\n";
    f += "lstr = smv0 * smv1 * smv2 * smv3;\n";
    // f += "lstr = smv0 * smv1 * smv2;\n";
    // f += "color += vec4(1.0 - float(n1), 1.0 - float(n2), 1.0 - float(n3), 0.0);\n";
    }
    else
    {
      if (g.light_fixed) {
	f += "vec3 ndelta = vary_normal * 0.02 / 40.;\n";
	f += "vec3 prel = vary_position - camera_pos;\n";
	f += "vec3 p0 = prel / 40. + ndelta;\n";
	f += "vec3 p1 = prel / 120. + ndelta;\n";
	f += "vec3 p2 = prel / 360. + ndelta;\n";
	f += "vec3 p3 = prel / 1080. + ndelta;\n";
      } else {
	f += "vec3 p0 = vary_smpos0;\n";
	f += "vec3 p1 = vary_smpos1;\n";
	f += "vec3 p2 = vary_smpos2;\n";
	f += "vec3 p3 = vary_smpos3;\n";
      }
      f += "vec3 smpos = (p0 + 1.0) * 0.5;\n";
      f += "vec4 smz = " + g.texture2d();
      f += "  (sampler_sm0, smpos.xy * lflag);\n";
      f += "float z0 = floor(smz.r * 255.0 + 0.5);\n";
      f += "float z1 = floor(smz.g * 255.0 + 0.5);\n";
      f += "float z2 = floor(smz.b * 255.0 + 0.5);\n";
      f += "float zval = z0 * 65536.0 + z1 * 256.0 + z2;\n";
      f += "lstr = float(smpos.z * 16770000.0 < zval) * lflag;\n";
    }
    /*
    */
    f += "color += vec4(1.0, 1.0, 1.0, 1.0)";
    f += "  * (mate_specular * specular * lstr);\n";
  }
  // f += "color = vec4(0.5, 0.5, 0.5, 1.0);\n"; // FIXME
  f += g.fragcolor() +  " = color + ";
  f += "  (color_dif * (diffuse * lstr + mate_ambient));\n";
  f += "}\n";
  return f;
}

function triangles_shader_ptr
init_triangles_shader(shader_config const& g, int opt)
{
  const v = triangles_shader_vert(g, opt);
  const f = triangles_shader_frag(g, opt);
  return
    make_glshader_ptr{
      triangles_uniforms,
      triangles_instance_attributes,
      triangles_vertex_attributes
    }(v, f, "model_matrix", g.debug_level);
}

function particle_shader_ptr
init_particle_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += "void main(void) {\n";
  v += "gl_Position = " + g.instance_attr("model_matrix");
  v += "  * vec4(position, 1.0);\n";
  v += "gl_PointSize = point_size_base / gl_Position.w;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord * 2.0 - 1.0;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}(v, f, "model_matrix", g.debug_level);
}

function particle_bb_shader_ptr
init_particle_bb_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat3 camera_matrix;\n";
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec2 local_position;\n";
  v += g.vert_out() + "vec2 point_coord;\n";
  v += "void main(void) {\n";
  v += "vec4 pos = " + g.instance_attr("model_matrix");
  v += "  * vec4(position, 1.0);\n";
  v += "vec3 posb = camera_matrix";
  v += "  * vec3(local_position * point_size_base, 0.0);\n";
  v += "gl_Position = view_projection_matrix * vec4(pos.xyz + posb, 1.0);\n";
  v += "point_coord = local_position;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec2 point_coord;\n";
  f += "void main(void) {\n";
  f += "vec2 xy = point_coord;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}(v, f, "model_matrix", g.debug_level);
}

function lineparticle_shader_ptr
init_lineparticle_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_attr("mat3", "idata");
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform vec2 screen_size_px;\n";
  v += "uniform float screen_size_base;\n";
  v += g.vert_in() + "vec2 vert;\n";
  v += g.vert_out() + "vec3 vary_coord;\n";
  v += g.vert_out() + "vec2 edge;\n";
  v += "void main(void) {\n";
  v += "vec4 p0p = view_projection_matrix * vec4("
    + g.instance_attr("idata") + "[0], 1.0);\n";
  v += "vec4 p1p = view_projection_matrix * vec4("
    + g.instance_attr("idata") + "[1], 1.0);\n";
  v += "float pz0 = p0p.z / p0p.w;\n";
  v += "float pz1 = p1p.z / p1p.w;\n";
  v += "float pz = (pz0 + pz1) * 0.5;\n";
  v += "vec2 p0 = p0p.xy * screen_size_px / p0p.w;\n";
  v += "vec2 p1 = p1p.xy * screen_size_px / p1p.w;\n";
  v += "float is_posi = min(float(p0p.w > 0.0), float(p1p.w > 0.0));\n"; 
  v += "vec2 pvec = p1 - p0;\n"; // FIXME: must be non-zero
  v += "float plen = length(pvec);\n";
  v += "vec2 r = screen_size_base * "
    + g.instance_attr("idata") + "[2].x"
    + " / vec2(p0p.w, p1p.w);\n";
  v += "float rmx = max(r[0], r[1]);\n";
  // v += "r = max(r, rmx - plen * 0.0625);\n";
  v += "r = max(r, rmx - plen * 0.5);\n";
  v += "float rp = r[0] + (r[1] - r[0]) * vert.x;\n";
  v += "vec2 qvec = normalize(vec2(-pvec.y, pvec.x)) * rp;\n";
  v += "float x_extend_0 = (vert.x - 1.0) * r[0] * 0.5 / plen;\n";
  v += "float x_extend_1 = vert.x * r[1] * 0.5 / plen;\n";
  v += "vec2 vert_ex = vec2(vert.x + x_extend_0 + x_extend_1, vert.y);\n";
  v += "vec2 vpos = p0 + mat2(pvec, qvec) * vert_ex;\n";
  v += "gl_Position = vec4(vpos * is_posi / screen_size_px, pz, 1.0);\n";
  v += "vec2 c = vec2(vert.x - 0.5, vert.y) * 2.0;\n";
  v += "float rrat = r[1] / r[0];\n";
  v += "float rrat_v = 1.0 + (rrat - 1.0) * vert.x;\n";
  v += "vary_coord = vec3(c, 1.0) * rrat_v;\n";
  v += "float edge_rat = clamp(max(r[0], r[1]) / plen, 0.125, 1.0);\n";
  v += "edge = vec2(1.0 - edge_rat, 1.0 / edge_rat);\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec3 vary_coord;\n";
  f += g.frag_in() + "vec2 edge;\n";
  f += "void main(void) {\n";
  f += "vec2 c = vary_coord.xy / vary_coord.z;\n";
  f += "c.x = max(abs(c.x) - edge.x, 0.0) * edge.y;\n";
  f += "float a = 1.0 - length(c);\n";
  f += "if (a < 0.25) { discard; };\n";
  f += g.fragcolor() + " = vec4(a * 2.0, a * 2.0, a * 4.0, 1.0);\n";
  // f += g.fragcolor() + " = vec4(1.0, 1.0, 0.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{lineparticle_uniforms,
    lineparticle_instance_attributes, lineparticle_vertex_attributes}
    (v, f, "", g.debug_level);
}

function font2_shader_ptr
init_font2_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += "uniform vec2 screen_size_px;\n";
  v += g.vert_in() + "vec2 texture_size_px;\n";
  v += g.vert_in() + "vec2 texture_origin_px;\n";
  v += g.vert_in() + "vec2 char_size_px;\n";
  v += g.vert_in() + "vec2 coord_clamp;\n";
  v += g.vert_in() + "float char_point_size;\n";
  v += g.decl_instance_attr("vec4", "idata");
  v += g.vert_out() + "vec2 vary_texture_size_px;\n";
  v += g.vert_out() + "vec2 vary_texture_origin_px;\n";
  v += g.vert_out() + "vec2 vary_char_size_px;\n";
  v += g.vert_out() + "vec2 vary_coord_clamp;\n";
  v += g.vert_out() + "float vary_point_size;\n";
  v += "void main(void) {\n";
  v += "vec4 idata_i = " + g.instance_attr("idata") + ";\n";
  v += "float ch = idata_i.x;\n";
  v += "vec2 screen_pos = idata_i.zw;\n";
  v += "vec2 screen_px = ";
  v += "  floor((screen_pos + 1.0) * screen_size_px * 0.5 + 0.5);\n";
  v += "screen_px += char_point_size * 0.5;\n";
  v += "screen_pos = screen_px / screen_size_px * 2.0 - 1.0;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "gl_PointSize = char_point_size;\n";
  v += "vary_texture_size_px = texture_size_px;\n";
  v += "vary_texture_origin_px = texture_origin_px";
  v += "  + vec2(char_size_px.x * ch, 0.0);\n";
  v += "vary_char_size_px = char_size_px;\n";
  v += "vary_coord_clamp = coord_clamp;\n";
  v += "vary_point_size = char_point_size;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += g.frag_in() + "vec2 vary_texture_size_px;\n";
  f += g.frag_in() + "vec2 vary_texture_origin_px;\n";
  f += g.frag_in() + "vec2 vary_char_size_px;\n";
  f += g.frag_in() + "vec2 vary_coord_clamp;\n";
  f += g.frag_in() + "float vary_point_size;\n";
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord;\n";
  f += "if (xy.x > vary_coord_clamp.x) { discard; }\n";
  f += "vec2 pcoord = vary_point_size * xy;\n";
  f += "vec2 texcoord = (vary_texture_origin_px + pcoord)";
  f += "  / vary_texture_size_px;\n";
  f += "vec4 col = " +  g.texture2d() + "(sampler, texcoord);\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 0.0, col.a);\n";
  f += "}\n";
  return make_glshader_ptr{font2_uniforms, font2_instance_attributes,
    font2_vertex_attributes}(v, f, "idata", g.debug_level);
}

function rect2d_shader_ptr
init_rect2d_shader(shader_config const& g)
{
  string v;
  string f;
  v += g.prepend();
  v += g.vert_in() + "vec2 vert;\n";
  v += g.decl_instance_attr("vec4", "idata");
  v += "void main(void) {\n";
  v += "vec4 idata_i = " + g.instance_attr("idata") + ";\n";
  v += "vec2 screen_pos = idata_i.xy + idata_i.zw * vert;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "}\n";
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 1.0, 0.3);\n";
  f += "}\n";
  return make_glshader_ptr{rect2d_uniforms, rect2d_instance_attributes,
    rect2d_vertex_attributes}(v, f, "idata", g.debug_level);
}

private threaded function {t} void
buffer_append(varray{float} mutable& arr, t const& v)
{
  if (m::eq{t, float}) {
    arr.push_back(v);
  } else if (m::or{
    m::eq{t, glm::vec2},
    m::eq{t, glm::vec3},
    m::eq{t, glm::vec4},
    m::eq{t, glm::mat2},
    m::eq{t, glm::mat3},
    m::eq{t, glm::mat4}}) {
    arr.append(v.to_cslice());
  } else {
    expand (sym: m::field_names{t})
    {
      buffer_append(arr, v.sym);
    }
  }
}

private threaded function void prepare_instance_data_default(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  buffer_append(idata.instance_buffer, sn.trans);
}

private threaded function void prepare_instance_data_triangles(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  buffer_append(idata.instance_buffer, sn.trans); /* model matrix */
}

private threaded function void prepare_instance_data_particle(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  const mvp = ncd.vp * sn.trans.value;
  buffer_append(idata.instance_buffer, mvp);
}

private threaded function void prepare_instance_data_lineparticle(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  const sli = sn.trans.value.to_cslice();
  idata.instance_buffer.append(sli[0 .. 9]);
}

private threaded function void prepare_instance_data_rect2d(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  const sli = sn.trans.value.to_cslice();
  idata.instance_buffer.append(sli[0 .. 4]);
}

private threaded function void prepare_instance_data_font2(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  const sli = sn.trans.value.to_cslice();
  idata.instance_buffer.append(sli[0 .. 4]);
}

private threaded function void prepare_instance_data_ft_rec(
  scene_node const& sn, node_common_data mutable& ncd,
  cslice{prepare_instance_data_funcptr} const& ftable,
  whole_instances_type mutable& whole_instances)
{
  const& bo_id = sn.joint_id.bo_id;
  const& vs_id = sn.joint_id.vs_id;
  if (bo_id >= 0 && vs_id >= 0) {
    ++ncd.stat_num_objects;
    mutable& idata = whole_instances[bo_id][static_cast{size_t}(vs_id)];
    ftable[bo_id](sn, ncd, idata);
  }
  for (const i, const& snp: sn.children) {
    prepare_instance_data_ft_rec(snp, ncd, ftable, whole_instances);
  }
}

private threaded function {t} t power_of_2(t v)
{
  mutable t r = static_cast{t}(1);
  while (r != 0 && r < v) { r <<= 1; }
  return r;
}

private threaded struct texture_data
{
  public uint surface_w;
  public uint surface_h;
  public uint char_w;
  public uint char_h;
  public varray{uint} char_x;
  public auto_texture texture_id;
}

private function extern "sdl_byteorder" int sdl_byteorder();
private function extern "sdl_lil_endian" int sdl_lil_endian();
private function extern "sdl_big_endian" int sdl_big_endian();

extern "functions" inline
namespace pgl3d$n { namespace drawer$n {
static inline ::pxcrt::bt_int sdl_byteorder()
{ return SDL_BYTEORDER; }
static inline ::pxcrt::bt_int sdl_lil_endian()
{ return SDL_LIL_ENDIAN; }
static inline ::pxcrt::bt_int sdl_big_endian()
{ return SDL_BIG_ENDIAN; }
}; };
;

function void check_byteorder()
{
  if (sdl_byteorder() != sdl_lil_endian()
      && sdl_byteorder() != sdl_big_endian()) {
      throw runtime_error_template{"unknown byteorder"}("1");
  }
  sdllog("byteorder ", sdl_byteorder());
}

function uint read_3_uint(cslice{uchar} const& buf, size_t o)
{
  uint v;
  if (sdl_byteorder() == sdl_lil_endian()) {
    v += buf[o+2]; v *= 256;
    v += buf[o+1]; v *= 256;
    v += buf[o+0];
  } else if (sdl_byteorder() == sdl_big_endian()) {
    v += buf[o+0]; v *= 256;
    v += buf[o+1]; v *= 256;
    v += buf[o+2];
  }
  return v;
}
function void write_4_uint(slice{uchar} const& buf, size_t o, uint val)
{
  if (sdl_byteorder() == sdl_lil_endian()) {
    buf[o+3] = static_cast{uchar}(val >> 24);
    buf[o+2] = static_cast{uchar}(val >> 16);
    buf[o+1] = static_cast{uchar}(val >>  8);
    buf[o+0] = static_cast{uchar}(val);
  } else if (sdl_byteorder() == sdl_big_endian()) {
    buf[o+0] = static_cast{uchar}(val >> 24);
    buf[o+1] = static_cast{uchar}(val >> 16);
    buf[o+2] = static_cast{uchar}(val >>  8);
    buf[o+3] = static_cast{uchar}(val);
  }
}

metafunction SDL_Surface_Scoped scoped_nullable{SDL_FreeSurface};

function void
init_font(texture_data mutable& fnt)
{
  check_byteorder();
  {
    /* font */
    mutable fnames = make_farray{string}(
      "mplus-1m-bold.ttf",
      // "/Library/Fonts/Tahoma.ttf",
      "/Library/Fonts/Osaka.ttf",
      "/usr/share/fonts/mplus/mplus-1m-bold.ttf",
      "/usr/share/fonts/liberation/LiberationMono-Regular.ttf");
    scoped_nullable{TTF_CloseFont} font;
    for (size_t i, mutable& fn: fnames) {
      const p = TTF_OpenFont(fn.c_str(), 18);
      sdllog("openfont", fn, p.to_size_t());
      font.reset(p);
      if (font.get() != rawptr{TTF_Font}()) {
	break;
      }
    }
    if (font.get() == rawptr{TTF_Font}()) {
      sdllog("failed to load font");
      throw runtime_error_template{"load font"}("1");
    }
    SDL_Color mutable fg;
    fg.r = 255;
    fg.g = 255;
    fg.b = 255;
    fg.a = 255;
    uint hmax = 0;
    uint wmax = 0;
    // uint wtotal = 0;
    varray{ptr{SDL_Surface_Scoped}} sur_arr;
    for (const i: 0 .. 0x60) {
      farray{uchar, 2} z;
      z[0] = static_cast{uchar}(i + 0x20);
      z[1] = 0u;
      const sur = make_ptr{SDL_Surface_Scoped}();
      sur->reset(TTF_RenderUTF8_Blended(font,
	z.range().to_crawptr().to_ccharptr(), fg));
      /* sdllog(z, sur.W(), sur.H()); */
      sur_arr.push_back(sur);
      const sur_ref = sur->get().to_slice(1);
      hmax = max(hmax, static_cast{uint}(sur_ref->h));
      wmax = max(wmax, static_cast{uint}(sur_ref->w));
    }
    SDL_Surface_Scoped sur_chars;
    sur_chars.reset(SDL_CreateRGBSurface(0,
      cast_int(power_of_2(wmax * 0x60u)),
      cast_int(power_of_2(hmax)), 32, 0, 0, 0, 0));
    sdllog("wmax, hmax", wmax, hmax);
    fnt.char_x.clear();
    uint xcur = 0;
    for (const i, const ep: sur_arr) {
      const& e = *ep->get().to_slice(1);
      SDL_Rect r0;
      SDL_Rect r1;
      r0.x = 0;
      r0.y = 0;
      r0.w = e.w;
      r0.h = e.h;
      r1.x = cast_int(xcur);
      r1.y = 0;
      r1.w = r0.w;
      r1.h = r1.h;
      const v = SDL_UpperBlit(*ep, caddress(r0), sur_chars, address(r1));
      xcur += cast_uint(wmax);
      fnt.char_x.push_back(xcur);
    }
    fnt.char_w = wmax;
    fnt.char_h = hmax;
    const& sur_chars_ref = *sur_chars.get().to_slice(1);
    fnt.surface_w = static_cast{uint}(sur_chars_ref.w);
    fnt.surface_h = static_cast{uint}(sur_chars_ref.h);
    /* const sur = sur_chars; */
    const sur_chars_buf = sur_chars_ref.pixels.reinterpret_cast{uchar}()
      .to_slice(static_cast{size_t}(sur_chars_ref.pitch * sur_chars_ref.h));
    // const sur_chars_buf = sur_chars.Pixels();
    for (const x: 0 .. sur_chars_ref.w) {
      for (const y: 0 .. sur_chars_ref.h) {
	const i = static_cast{size_t}((y * sur_chars_ref.w + x) * 4);
	sur_chars_buf[i+0] = 255;
	sur_chars_buf[i+1] = 255;
	sur_chars_buf[i+2] = 255;
      }
    }
    /* font texture */
    glActiveTexture(GL_TEXTURE0);
    fnt.texture_id.generate();
    sdllog("font_texture_id", fnt.texture_id.get());
    glBindTexture(GL_TEXTURE_2D, fnt.texture_id.get());
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA),
      sur_chars_ref.w, sur_chars_ref.h,
      0, GL_RGBA, GL_UNSIGNED_BYTE, sur_chars_ref.pixels);
    /*
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_LINEAR));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_LINEAR));
    */
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
  }
}

function void
init_main_texture(texture_data mutable& tex_dpat,
  texture_data mutable& tex_tilemap)
{
  check_byteorder();
  {
    // const sur = IMG_Load("img-c1024.jpg").some;
    SDL_Surface_Scoped sur0;
    sur0.reset(IMG_Load("dpat.png"));
    const& sur0ref = *sur0.get().to_slice(1);
    const fmtp = sur0ref.format;
    const& fmt = *sur0ref.format.to_slice(1);
    const bpp = fmt.BytesPerPixel;
    if (bpp != 4 && bpp != 3) {
      throw runtime_error_template{"img_load"}("1");
    }
    const sur0_w = static_cast{uint}(sur0ref.w);
    const sur0_h = static_cast{uint}(sur0ref.h);
    mutable tex_w = power_of_2(sur0_w);
    mutable tex_h = power_of_2(sur0_h);
    varray{uint} uibuf;
    uibuf.resize(tex_w * tex_h, 0);
    uint rmask = fmt.Rmask;
    uint gmask = fmt.Gmask;
    uint bmask = fmt.Bmask;
    uint amask = fmt.Amask;
    function uint get_shift(uint m) {
      uint r = 0;
      for (uint i: 0 .. 32) {
	if ((m & 1) != 0) {
	  break;
	}
	r += 1;
	m >>= 1;
      }
      return r;
    }
    uint rshift = get_shift(rmask);
    uint gshift = get_shift(gmask);
    uint bshift = get_shift(bmask);
    uint ashift = get_shift(amask);
    /*
    sdllog("Masks", rmask, gmask, bmask, amask, rshift, gshift, bshift,
      ashift);
    */
    const& sur0_ref = *sur0.get().to_slice(1);
    const sur0buf = sur0_ref.pixels.reinterpret_cast{uchar}()
      .to_slice(static_cast{size_t}(sur0_ref.pitch * sur0_ref.h));
    // const sur0buf = sur0_ref.Pixels();
    for (const by: 0 .. sur0_h / 64) {
      for (const iy: 0 .. 32U) {
	for (const x: 0 .. sur0_w) {
	  const o0n = ((by * 64 + iy     ) * sur0_w + x) * bpp;
	  const o0c = ((by * 64 + iy + 32) * sur0_w + x) * bpp;
	  const o1 = ((by * 32 + iy) * tex_w + x) * 4;
	  const nor0 = read_3_uint(sur0buf, o0n);
	  const col0 = read_3_uint(sur0buf, o0c);
	  uint norr = (nor0 >> rshift) & 0xffU;
	  uint norg = (nor0 >> gshift) & 0xffU;
	  uint norb = (nor0 >> bshift) & 0xffU;
	  const nor = (norr << 16) | (norg << 8) | norb;
	  uint colr = (col0 >> rshift) & 0xffU;
	  uint colg = (col0 >> gshift) & 0xffU;
	  uint colb = (col0 >> bshift) & 0xffU;
	  const col = (colb << 16) | (colg << 8) | colr;
	  uint val; /* avol for higher 4bits, alv for lower 4bits */
	  if (nor == 0xff0000) {
	    val = 0x91; /* convex left-upper */
	  } else if (nor == 0x00ff00) {
	    val = 0x92; /* convex upper, or concave lower */
	  } else if (nor == 0xffff00) {
	    val = 0x93; /* convex right-upper */
	  } else if (nor == 0x0000ff) {
	    val = 0x94; /* convex right, or concave left */
	  } else if (nor == 0xff00ff) {
	    val = 0x95; /* convex right-lower */
	  } else if (nor == 0x00ffff) {
	    val = 0x72; /* convex lower, or concave upper */
	  } else if (nor == 0xffffff) {
	    val = 0x97; /* convex left-lower */
	  } else if (nor == 0x808080) {
	    val = 0x74; /* convex left, or concave right */
	  } else if (nor == 0xc04040) {
	    val = 0x71; /* concave left-upper */
	  } else if (nor == 0xc0c040) {
	    val = 0x73; /* concave right-upper */
	  } else if (nor == 0xc040c0) {
	    val = 0x75; /* concave right-lower */
	  } else if (nor == 0xc0c0c0) {
	    val = 0x77; /* concave left-lower */
	  } else if (nor == 0x8080c0) {
	    val = 0x0f; /* discard */
	  }
	  uibuf[(by * 32 + iy) * tex_w + x] = (val << 24) | col;
	}
      }
    }
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE1);
    tex_dpat.texture_id.generate();
    glBindTexture(GL_TEXTURE_2D, tex_dpat.texture_id.get());
    /*
    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, cast_int(GL_TRUE));
    */
    int mipmap_level = 0;
    while (true) {
      glTexImage2D(GL_TEXTURE_2D, mipmap_level, cast_int(mode),
	cast_int(tex_w), cast_int(tex_h),
	0, mode, GL_UNSIGNED_BYTE, uibuf.to_crawptr().to_cvoidptr());
      const tex_w_prev = tex_w;
      const tex_h_prev = tex_h;
      tex_w /= 2;
      tex_h /= 2;
      // if (tex_w == 0 || tex_h == 0 || mipmap_level >= 5) {
      if (tex_w == 0 || tex_h == 0 || mipmap_level >= 0) {
	break;
      }
      ++mipmap_level;
      for (const y: 0 .. tex_h) {
	for (const x: 0 .. tex_w) {
	  farray{uint, 4} v;
	  v[0] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 0)];
	  v[1] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 1)];
	  v[2] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 0)];
	  v[3] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 1)];
	  uint mutable val_b;
	  uint mutable val_g;
	  uint mutable val_r;
	  size_t opaque_count = 0;
	  for (size_t j: 0 .. 4) {
	    val_b += (v[j] >> 16) & 0xff;
	    val_g += (v[j] >>  8) & 0xff;
	    val_r += (v[j] >>  0) & 0xff;
	    if (((v[j] >> 24) & 0x0f) == 10) { ++opaque_count; }
	  }
	  val_b /= 4;
	  val_g /= 4;
	  val_r /= 4;
	  const val_a = opaque_count > 0 ? 10U : (v[0] >> 24) & 0xff; // TODO
	  /*
	  uibuf[y * tex_w + x] = (val_a << 24) +
	    (val_b << 16) + (val_g << 8) + (val_r << 0);
	  uibuf[y * tex_w + x] = v[0];
	  */
	}
      }
    }
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(mipmap_level > 0 ? GL_NEAREST_MIPMAP_NEAREST : GL_NEAREST));
    tex_dpat.surface_w = tex_w;
    tex_dpat.surface_h = tex_h;
    if (m::ne{is_gl3_or_gles3, 0}) {
      if (mipmap_level != 0) {
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, mipmap_level);
      }
    }
  }
  {
    /* tile map */
    SDL_Surface_Scoped sur1;
    sur1.reset(SDL_CreateRGBSurface(0, 128, 128, 32, 0, 0, 0, 0));
    const& sur1_ref = *sur1.get().to_slice(1);
    const sur1buf = sur1_ref.pixels.reinterpret_cast{uchar}()
      .to_slice(static_cast{size_t}(sur1_ref.pitch * sur1_ref.h));
    const sur1_w = static_cast{uint}(sur1_ref.w);
    const sur1_h = static_cast{uint}(sur1_ref.h);
    // const sur1buf = sur1.Pixels();
    const rnd = make_rand_generator(333U);
    for (const y: 0 .. sur1_h) {
      for (const x: 0 .. sur1_w) {
	const o1 = (y * sur1_w + x) * 4;
	const v0 = rnd->generate() / 65536;
	const v1 = v0 % 8;
	const v2 = (v0 / 8) % 8;
	const uint specular_ambient = 0xff60;
	if (x == 0 && y == 0) {
	  write_4_uint(sur1buf, o1, specular_ambient << 16);
	} else {
	  write_4_uint(sur1buf, o1, (v1 % 8) | specular_ambient << 16);
	}
      }
    }
    sdllog("sur1buf", sur1_w, sur1_h);
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE2);
    tex_tilemap.surface_w = sur1_w;
    tex_tilemap.surface_h = sur1_h;
    tex_tilemap.texture_id.generate();
    glBindTexture(GL_TEXTURE_2D, tex_tilemap.texture_id.get());
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(mode),
      cast_int(sur1_ref.w), cast_int(sur1_ref.h),
      0, mode, GL_UNSIGNED_BYTE, sur1buf.to_crawptr().to_cvoidptr());
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
  }
}

