private namespace pgl3d::pglshader "export-unsafe";
public import common -;
public import pointer::raw -;
public import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
public import glm::raw;
public import io::time -;
public import exception -;
public import meta m;
public import pointer::tfuncptr -;
public import GL::compat -;
public import pgl3d::glresource -;
public import pgl3d::glshader -;
public import pgl3d::glgeometry -;
public import pgl3d::glbuffer -;
public import pgl3d::scene_node -;
public import pgl3d::pglbase -;
public import pgl3d::intern_pool -;
public import pgl3d::shader_config -;
public import pgl3d::aggregated_ibuffer -;
public import pgl3d::drawer_base -;
public import pgl3d::drawer -;

public struct
pglshader(shader_config const& sconf0,
  tree_map{string, ptr{pgldrawer_export_i}} const& drawers0, int width0,
  int height0)
<make_vertices_i>
{
  public shader_config const glc = sconf0;
  public tree_map{string, size_t} drawer_names = get_drawer_names(drawers0);
  public varray{ptr{pgldrawer_i}} drawers = downcast_drawers(drawers0);
  public varray{vertex_buffer_id} drawer_vbids;
  public varray{vertex_buffer_id} drawer_main_vbids;
  // public varray{size_t} vbid_to_drawer_one;
  public varray{ptr{shadowmap_fbo}} sfbo_array;
  public projection_info cam;
  public varray{ptr{vertex_buffer}} vertex_buffers;
  public aggregated_ibuffer agg_ibuffer;
  public tptr{pidf_table} const pidft = make_tptr{pidf_table}();
  private auto_vertexarray vtxarr;
  private tree_map{string, vertex_buffer_id} vertex_buffer_id_map;
  private intern_pool{vertex_buffer_pool_key} vbid_pool;
  init();
  resize_screen(width0, height0);
  /*
  public function vertex_buffer_id to_vbid(cstrref const& name) const {
    return vbid_pool.to_id(name);
  }
  */
  public function vertex_buffer_id intern_vbid(cstrref const& name) {
    const r = vbid_pool.intern(name);
    sdllog("intern ", name, r);
    return r;
  }
  public function void set_vertex_buffer(vertex_buffer_id vbid,
    ptr{vertex_buffer} const& p) {
    vertex_buffers.resize(static_cast{size_t}(vbid) + 1,
      make_ptr{vertex_buffer}(0u, false, false));
    vertex_buffers[static_cast{size_t}(vbid)] = p;
  }
  private function void init()
  {
    /*
    {
      int val;
      glGetIntegerv(GL_DEPTH_BITS, address(val));
      sdllog("depth bits", val);
    }
    */
    if (m::ne{is_gl3_or_gles3, 0}) {
      vtxarr.generate();
      glBindVertexArray(vtxarr.get());
      sdllog("glBindVertexArray", vtxarr.get());
    }
    if (m::eq{is_gles, 0}) {
      farray{float, 2} arr;
      float step;
      glGetFloatv(GL_POINT_SIZE_RANGE, arr.to_rawptr());
      glGetFloatv(GL_POINT_SIZE_GRANULARITY, address(step));
      sdllog("GL_POINT_SIZE_RANGE", arr, step);
    }
    /*
    if (m::ne{is_gl3_or_gles3, 0}) {
      if (glc.enable_msaa) {
	glEnable(GL_MULTISAMPLE);
      }
    }
    */
    if (m::eq{is_gles, 0}) {
      if (!glc.is_gl3_or_gles3()) {
	glEnable(GL_POINT_SPRITE);
	sdllog("GL_POINT_SPRITE enabled");
      }
      glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
    }
    drawer_vbids.resize(drawers.size(), 0);
    drawer_main_vbids.resize(drawers.size(), 0);
    for (const i, const& pd: drawers) {
      drawer_vbids[i] = intern_vbid(pd->get_vbid_name());
      drawer_main_vbids[i] = intern_vbid(pd->get_main_vbid_name());
      size_t j = static_cast{size_t}(drawer_vbids[i]);
      /*
      if (vbid_to_drawer_one.size() <= j) {
	vbid_to_drawer_one.resize(j + 1, 0);
      }
      vbid_to_drawer_one[j] = i;
      */
      {
	mutable& pidftv = *pidft;
	if (pidftv.size() <= j) {
	  pidftv.resize(j + 1, make_tfuncptr{prepare_instance_data_noop}());
	  pidftv[j] = pd->get_prepare_instance_data_funcptr();
	}
      }
      set_vertex_buffer(drawer_vbids[i], pd->make_vertex_buffer());
    }
    if (sfbo_array.empty()) {
      for (size_t i: 0 .. 4) {
	sfbo_array.push_back(make_ptr{shadowmap_fbo}());
      }
    }
  }
  public function void prepare(whole_instances_type mutable& whole_instances_r,
    node_factory mutable& nfac_r)
  {
    prepare_builtin_vertex_sets();
    prepare_vertex_buffers();
    prepare_whole_instances(whole_instances_r);
    prepare_node_factory(nfac_r);
  }
  private function void prepare_builtin_vertex_sets()
  {
    for (const i, const& pd: drawers) {
      const name = pd->builtin_vertex_set_name();
      if (name.empty()) {
	continue;
      }
      const bo_id = drawer_vbids[i];
      const vtx = make_vertices(bo_id, name);
      pd->make_builtin_vertex_sets(vtx);
    }
  }
  private function void prepare_vertex_buffers()
  {
    for (const i, const& bo: vertex_buffers) {
      bo->create_vbo();
    }
  }
  private function void prepare_whole_instances(
    whole_instances_type mutable& whole_instances) const
  {
    whole_instances.resize(vertex_buffers.size(), bo_instances_type());
    for (const i, const& bo: vertex_buffers) {
      mutable& instances = whole_instances[i];
      for (const j: 0 .. bo->vs_arr.size()) {
	instances.push_back(instance_data());
      }
    }
  }
  private function void prepare_node_factory(node_factory mutable& nf) const
  {
    for (size_t bo_id, const& bop: vertex_buffers) {
      for (const& n, const id: bop->vs_names) {
	if (bop->is_sub_drawer) {
	  // sub_drawer bo_id must not used for joint_id
	  continue;
	}
	joint_id_type jid;
	jid.bo_id = static_cast{uint}(bo_id);
	jid.vs_id = static_cast{int}(id);
	nf.name_to_id[n] = jid;
      }
      nf.binfo.push_back(node_buffer_info());
      node_buffer_info mutable& nbi = nf.binfo[nf.binfo.size() - 1];
      for (const i, const& vsp: bop->vs_arr) {
	nbi.vs_arr.push_back(node_vs_info());
	node_vs_info mutable& nvi = nbi.vs_arr[nbi.vs_arr.size() - 1];
	for (const j, const& nj: vsp->vtxs->joints) {
	  node_joint_info nji;
	  nji.joint_id = find_joint_id_by_name(nj.joint_name);
	  nji.trans = nj.trans;
	  nvi.joints.push_back(nji);
	}
      }
    }
  }
  public function joint_id_type find_joint_id_by_name(cstrref const& name)
    const
  {
    joint_id_type scene_id;
    for (const i, const& bo: vertex_buffers) {
      // sub_drawer bo_id must not used for joint_id
      if (!bo->is_sub_drawer && bo->has_name(name)) {
        scene_id.bo_id = static_cast{uint}(i);
        scene_id.vs_id = static_cast{int}(bo->get_id_by_name(name));
        break;
      }
    }
    return scene_id;
  }
  public function cptr{vertices} get_vertices(cstrref const& name) const
  {
    joint_id_type jid = find_joint_id_by_name(name);
    return vertex_buffers[static_cast{size_t}(jid.bo_id)]
      ->get_vertices(static_cast{size_t}(jid.vs_id));
  }
  public function joint_id_type get_joint_id(cstrref const& name) const {
    return find_joint_id_by_name(name);
  }
  public function ptr{vertices} make_vertices(vertex_buffer_id bo_id,
    cstrref const& name)
  {
    return vertex_buffers[static_cast{size_t}(bo_id)]->make_if(name)->vtxs;
  }
  public function void make_vertex_set(cslice{string} const& dr_names,
    cstrref const& shape_name, gf_poly const& expr)
  {
    // make vertex set by geometry expression
    varray{ptr{vertices}} vptrs;
    varray{dgf_filler} fillers;
    for (const i, const& dr_name: dr_names) {
      size_t dr_id = *drawer_names.equal_range(dr_name);
      const bo_id = drawer_vbids[dr_id];
      ptr{vertices} vptr = make_vertices(bo_id, shape_name);
      dgf_filler filler = drawers[dr_id]->make_filler(vptr);
      vptrs.push_back(vptr);
      fillers.push_back(filler);
    }
    ptr{build_context_i} ctx = make_ptr{build_context_impl}(vptrs, fillers);
    expr(*ctx, poly_t(), mesh_index());
  }
  public function void make_vertex_set_by_triangles(string const& dr_name,
    cstrref const& shape_name, cslice{float} const& verts, size_t nfpv,
    cslice{uint} const& elems)
  {
    size_t dr_id = *drawer_names.equal_range(dr_name);
    const bo_id = drawer_vbids[dr_id];
    ptr{vertices} vptr = make_vertices(bo_id, shape_name);
    vptr->set_triangles(verts, nfpv, elems);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    // FIXME: slow
    for (const i, const& pd: drawers) {
      const bo_id = drawer_vbids[i];
      r = pd->get_texture_info(name);
      if (r.surface_w != 0) {
	break;
      }
    }
    return r;
  }
  public function void resize_screen(int width, int height)
  {
    const default_scale = m::ne{is_gles, 0} ? 0.25f : 1.0f;
    const scale = glc.conf.get("shadowmap_resolution", default_scale);
    const wh = static_cast{int}(static_cast{float}(max(width, height))
      * scale);
    int sm_size = 1;
    for (int i: 8 .. 16) {
      sm_size = 1 << i;
      if (sm_size > wh) {
	break;
      }
    }
    cam.screen_width = width;
    cam.screen_height = height;
    cam.shadowmap_size = sm_size;
    for (size_t i: 0 .. 4) {
      mutable& sfbo = *sfbo_array[i];
      if (m::ne{is_gles, 0}) {
	sfbo.sm_width = sm_size;
	sfbo.sm_height = sm_size;
      } else {
	sfbo.sm_width = sm_size;
	sfbo.sm_height = sm_size;
      }
      init_shadowmap_fbo(glc, sfbo,
	static_cast{GLenum}(static_cast{size_t}(GL_TEXTURE3) + i));
    }
    update_mvp(cam);
  }
}

public function varray{uint}
pglshader_draw_frame(pglshader mutable& pgs,
  whole_instances_type mutable& whole_instances, projection_info const& cam_df)
{
  const& bos = pgs.vertex_buffers;
  /* prepare instance data */
  const tick1 = SDL_GetTicks();
  pgs.agg_ibuffer.frame_begin(whole_instances,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  const tick2 = SDL_GetTicks();
  /* shadowmapping shader */
  if (pgs.glc.enable_shadowmapping) {
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    glDisable(GL_CULL_FACE);
    /*
    glEnable(GL_CULL_FACE);
    glCullFace(GL_FRONT);
    */
    glEnable(GL_DEPTH_TEST);
    glDepthMask(1);
    if (pgs.glc.enable_depth_texture) {
      glColorMask(0, 0, 0, 0);
    } else {
      glColorMask(1, 1, 1, 1);
    }
    glDepthFunc(GL_LEQUAL);
    glDisable(GL_BLEND);
    for (size_t iter: 0 .. 4) {
      /* set fb */
      const& sfbo = *pgs.sfbo_array[iter];
      glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
      glViewport(0, 0, static_cast{GLsizei}(sfbo.sm_width),
	static_cast{GLsizei}(sfbo.sm_height));
      if (!pgs.glc.enable_depth_texture) {
	glClearColor(1.0, 1.0, 1.0, 1.0);
      }
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      /* note: view_projection is pre-applied to model_matrix */
      // FIXME: cascading
      for (const i, const& pd: pgs.drawers) {
	const bo_id = pgs.drawer_vbids[i];
	const main_bo_id = pgs.drawer_main_vbids[i];
	pd->draw(draw_step_shadowmapping, iter,
	  *bos[static_cast{size_t}(bo_id)],
	  whole_instances[static_cast{size_t}(main_bo_id)], pgs.agg_ibuffer,
	  bo_id, pgs.glc, cam_df);
      }
    }
    /* restore fb */
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
  glViewport(0, 0, static_cast{GLsizei}(pgs.cam.screen_width),
    static_cast{GLsizei}(pgs.cam.screen_height));
  /* z-prepass shader */
  if (pgs.glc.enable_zprepass) {
    glDisable(GL_CULL_FACE);
    // glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glDepthMask(1);
    glDisable(GL_BLEND);
    glClear(GL_DEPTH_BUFFER_BIT);
    glColorMask(0, 0, 0, 0);
    for (const i, const& pd: pgs.drawers) {
      const bo_id = pgs.drawer_vbids[i];
      const main_bo_id = pgs.drawer_main_vbids[i];
      pd->draw(draw_step_zprepass, 0,
	*bos[static_cast{size_t}(bo_id)],
	whole_instances[static_cast{size_t}(main_bo_id)], pgs.agg_ibuffer,
	bo_id, pgs.glc, cam_df);
    }
  }
  /* main */
  {
    glDisable(GL_BLEND);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    if (pgs.glc.enable_zprepass) {
      glColorMask(1, 1, 1, 1);
      glDepthFunc(GL_LEQUAL); // FIXME GL_EQUAL is better?
      glClearColor(0.0, 0.0, 0.0, 0.0);
      glClear(GL_COLOR_BUFFER_BIT);
    } else {
      glDepthMask(1);
      glDepthFunc(GL_LESS);
      glColorMask(1, 1, 1, 1);
      glClearColor(0.0, 0.0, 0.0, 0.0);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
    for (const i, const& pd: pgs.drawers) {
      const bo_id = pgs.drawer_vbids[i];
      const main_bo_id = pgs.drawer_main_vbids[i];
      pd->draw(draw_step_solid, 0,
	*bos[static_cast{size_t}(bo_id)],
	whole_instances[static_cast{size_t}(main_bo_id)], pgs.agg_ibuffer,
	bo_id, pgs.glc, cam_df);
    }
  }
  /* blend */
  {
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    for (const i, const& pd: pgs.drawers) {
      const bo_id = pgs.drawer_vbids[i];
      const main_bo_id = pgs.drawer_main_vbids[i];
      pd->draw(draw_step_blend, 0,
	*bos[static_cast{size_t}(bo_id)],
	whole_instances[static_cast{size_t}(main_bo_id)], pgs.agg_ibuffer,
	bo_id, pgs.glc, cam_df);
    }
  }
  pgs.agg_ibuffer.frame_end(pgs.glc.enable_instanced,
    pgs.glc.enable_uniform_instancing);
  return make_varray{uint}(tick1, tick2);
}

/* private */

private function tree_map{string, size_t}
get_drawer_names(tree_map{string, ptr{pgldrawer_export_i}} const& drawers)
{
  size_t i = 0;
  tree_map{string, size_t} r;
  for (const& k, const& e: drawers) {
    r[k] = i;
    ++i;
  }
  return r;
}

private function varray{ptr{pgldrawer_i}}
downcast_drawers(tree_map{string, ptr{pgldrawer_export_i}} const& drawers)
{
  varray{ptr{pgldrawer_i}} r;
  for (const& k, const& e: drawers) {
    r.push_back(pointer_downcast{ptr{pgldrawer_i}}(e));
  }
  return r;
}

private threaded struct
build_context_impl(varray{ptr{vertices}} mutable& vptrs0,
  varray{dgf_filler} mutable& fillers0)
  <build_context_i>
{
  public varray{ptr{vertices}} vptrs;
  public varray{dgf_filler} fillers;
  vptrs.swap(vptrs0);
  fillers.swap(fillers0);
  function void fill(bool flat_flag, bool polyjoint, size_t n,
    string const& joint_name, poly_t const& poly, mesh_index const& mp) const
  {
    if (joint_name.empty()) {
      fillers[n](flat_flag, poly, mp);
    } else if (polyjoint) {
      dgf_poly_joint_internal(vptrs[0], joint_name, poly, mp);
    } else {
      dgf_point_joint_internal(vptrs[0], joint_name, poly, mp);
    }
  }
}

private threaded function void
dgf_poly_joint_internal(ptr{vertices} const& vptr, string const& joint_name,
  poly_t const& poly, mesh_index const& mp)
{
  // calculates normal/tangent from poly
  if (poly.size() < 1) { return; }
  node_joint e;
  e.trans = poly_trans(poly);
  e.joint_name = joint_name;
  vptr->push_joint(e);
}

private threaded function void
dgf_point_joint_internal(ptr{vertices} const& vptr, string const& joint_name,
  poly_t const& poly, mesh_index const& mp)
{
  if (poly.size() < 1) { return; }
  const p = poly[0].pos;
  const ex = poly[0].nor.normalize();
  const ey = poly[0].tan.normalize();
  const ez = glm::cross(ex, ey);
  node_joint e;
  e.trans = glm::make_mat4(
    ex.x, ex.y, ex.z,  0.0,
    ey.x, ey.y, ey.z,  0.0,
    ez.x, ez.y, ez.z,  0.0,
     p.x,  p.y,  p.z,  1.0);
  e.joint_name = joint_name;
  vptr->push_joint(e);
}

function void update_mvp(projection_info mutable& cam)
{
  float const perspective_distance = 1.0;
  float const distance_max = 999.0;
  const ssbase = max(cam.screen_height, cam.screen_width);
  const h = cast_float(cam.screen_height) / cast_float(ssbase);
  const w = cast_float(cam.screen_width) / cast_float(ssbase);
  glViewport(0, 0, static_cast{GLsizei}(cam.screen_width),
    static_cast{GLsizei}(cam.screen_height));
  glDepthMask(1);
  glColorMask(1, 1, 1, 1);
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  const d = cast_float(perspective_distance);
  {
    const near = cast_float(d);
    const far = cast_float(d + distance_max);
    const left = cast_float(-w);
    const right = cast_float(w);
    const bottom = cast_float(-h);
    const top = cast_float(h);
    cam.camera_pers.near = near;
    cam.camera_pers.far = far;
    cam.camera_pers.width = w;
    cam.camera_pers.height = h;
    cam.projection = glm::frustum{float}(left, right, bottom, top, near, far);
  }
  /*
  {
    const sm_w = max(1.0, w);
    const sm_h = max(1.0, h);
    const near = cast_float(d);
    const far = cast_float(d + distance_max);
    const left = cast_float(-sm_w);
    const right = cast_float(sm_w);
    const bottom = cast_float(-sm_h);
    const top = cast_float(sm_h);
    cam.sm_projection = glm::frustum{float}(left, right, bottom, top, near,
      far);
  }
  */
  {
    const sm_w = 1.0f;
    const sm_h = 1.0f;
    const near = cast_float(d);
    function void set_sm(glm::mat4 mutable& dst, float mutable& distance_r,
      float far)
    {
      const near = -far;
      const left = -far;
      const right = far;
      const bottom = -far;
      const top = far;
      dst = glm::ortho{float}(left, right, bottom, top, near, far);
      distance_r = far;
    }
    set_sm(cam.sm_projection0, cam.sm_distances.x, 40.0f);
    set_sm(cam.sm_projection1, cam.sm_distances.y, 120.0f);
    set_sm(cam.sm_projection2, cam.sm_distances.z, 360.0f);
    set_sm(cam.sm_projection3, cam.sm_distances.w, 1080.0f);
    debug_log(cam.sm_distances.to_cslice());
    debug_log("smp0", cam.sm_projection0.to_cslice());
    debug_log("smp1", cam.sm_projection1.to_cslice());
  }
}

struct shadowmap_fbo
{
  public auto_framebuffer fbo;
  public auto_texture sm_texture;
  public int sm_width;
  public int sm_height;
  public auto_renderbuffer depthbuf;
}

function void init_shadowmap_fbo(shader_config const& glc,
  shadowmap_fbo mutable& sfbo, GLenum tex)
{
  if (glc.enable_shadowmapping) {
    sdllog("shadowmap size", sfbo.sm_width, sfbo.sm_height);
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    /* texture */
    // glActiveTexture(GL_TEXTURE3 + i);
    glActiveTexture(tex);
    sfbo.sm_texture.generate();
    glBindTexture(GL_TEXTURE_2D, sfbo.sm_texture.get());
    if (glc.enable_depth_texture) {
      sdllog("depth_texture");
      const f = glc.enable_sampler2dshadow ? GL_LINEAR : GL_NEAREST;
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, cast_int(f));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, cast_int(f));
      if (m::ne{is_gl3_or_gles3, 0}) {
	if (glc.enable_sampler2dshadow) {
	  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE,
	    cast_int(GL_COMPARE_REF_TO_TEXTURE));
	  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC,
	    cast_int(GL_LEQUAL));
	}
      }
      if (!glc.is_gles) {
	sdllog("depth_texture byte");
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT),
	  sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	  GL_UNSIGNED_BYTE, offset_to_void_cp(0));
      } else {
	if (glc.is_gl3_or_gles3()) {
	  /* ios gles3: COMPONENT16, UNSIGNED_INT */
	  sdllog("depth_texture int");
	  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT16),
	    sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	    GL_UNSIGNED_INT, offset_to_void_cp(0));
	} else {
	  /* ios gles2: COMPONENT, UNSIGNED_SHORT */
	  sdllog("depth_texture short");
	  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT),
	    sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	    GL_UNSIGNED_SHORT, offset_to_void_cp(0));
	}
      }
      sdllog("depth_texture done");
    } else {
      sdllog("no depth_texture");
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
	cast_int(GL_NEAREST));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
	cast_int(GL_NEAREST));
      sdllog("no depth_texture rbga byte");
      glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA), sfbo.sm_width,
	sfbo.sm_height, 0, GL_RGBA, GL_UNSIGNED_BYTE,
	offset_to_void_cp(0));
    }
    if (m::eq{is_gles, 0}) {
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
	cast_int(GL_CLAMP_TO_BORDER));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
	cast_int(GL_CLAMP_TO_BORDER));
      const border = make_farray{float}(1.0, 1.0, 1.0, 1.0);
      glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, border.crange().to_crawptr());
    }
    /* framebuffer */
    sfbo.fbo.generate();
    glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
    if (glc.enable_depth_texture) {
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
    } else {
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
	GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
    }
    /* renderbuffer */
    if (glc.enable_depth_texture) {
      if (m::eq{is_gles, 0}) {
	glDrawBuffer(GL_NONE);
	glReadBuffer(GL_NONE);
      }
    } else {
      int orig_rb;
      glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
      /*
      sdllog("orig_rb", orig_rb);
      */
      sfbo.depthbuf.generate();
      glBindRenderbuffer(GL_RENDERBUFFER, sfbo.depthbuf.get());
      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16,
	sfbo.sm_width, sfbo.sm_height);
      glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	GL_RENDERBUFFER, sfbo.depthbuf.get());
      glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));
    }
    const e = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (e != GL_FRAMEBUFFER_COMPLETE) {
      sdllog("incomplete framebuffer", cast_int(e));
    } else {
      sdllog("complete framebuffer");
    }
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
}

