private threaded namespace pgl3d::texture "export-unsafe";
public import common -;
public import pointer::raw -;
public import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
public import glm::raw;
public import io::time -;
public import exception -;
public import meta m;
public import pointer::tfuncptr -;
public import text::string::positional -;
public import GL::compat -;
public import pgl3d::glresource -;
public import pgl3d::glshader -;
public import pgl3d::glgeometry -;
public import pgl3d::glbuffer -;
public import pgl3d::scene_node -;
public import pgl3d::pglbase -;
public import pgl3d::intern_pool -;
public import pgl3d::shader_config -;
public import pgl3d::aggregated_ibuffer -;

public threaded struct gl_texture
{
  public uint surface_w;
  public uint surface_h;
  public uint char_w;
  public uint char_h;
  public varray{uint} char_x; // for variable width font
  public auto_texture texture_id;
}

public threaded struct shadowmap_fbo
{
  public auto_framebuffer fbo;
  public auto_renderbuffer depthbuf;
  public auto_texture sm_texture;
  public int sm_width;
  public int sm_height;
}

public function void
load_fixedwidth_font(gl_texture mutable& fnt, cslice{string} const& fnames)
{
  check_byteorder();
  sdllog("loading fonts");
  scoped_nullable{TTF_CloseFont} font;
  for (size_t i, const& fn0: fnames) {
    string fn = fn0;
    const p = TTF_OpenFont(fn.c_str(), 18);
    sdllog("openfont", fn, p.to_size_t());
    font.reset(p);
    if (font.get() != rawptr{TTF_Font}()) {
      break;
    }
  }
  if (font.get() == rawptr{TTF_Font}()) {
    sdllog("failed to load font");
    throw runtime_error_template{"load font"}("1");
  }
  sdllog("loading fonts: loaded");
  SDL_Color mutable fg;
  fg.r = 255;
  fg.g = 255;
  fg.b = 255;
  fg.a = 255;
  uint hmax = 0;
  uint wmax = 0;
  // uint wtotal = 0;
  varray{ptr{SDL_Surface_Scoped}} sur_arr;
  for (const i: 0 .. 0x60) {
    farray{uchar, 2} z;
    z[0] = static_cast{uchar}(i + 0x20);
    z[1] = 0u;
    const sur = make_ptr{SDL_Surface_Scoped}();
    sur->reset(TTF_RenderUTF8_Blended(font,
      z.range().to_crawptr().to_ccharptr(), fg));
    // sdllog(z, sur.W(), sur.H());
    sur_arr.push_back(sur);
    const sur_ref = sur->get().to_slice(1);
    hmax = max(hmax, static_cast{uint}(sur_ref->h));
    wmax = max(wmax, static_cast{uint}(sur_ref->w));
  }
  SDL_Surface_Scoped sur_chars;
  sur_chars.reset(SDL_CreateRGBSurface(0,
    cast_int(power_of_2(wmax * 0x60u)),
    cast_int(power_of_2(hmax)), 32, 0, 0, 0, 0));
  sdllog("wmax, hmax", wmax, hmax);
  fnt.char_x.clear();
  uint xcur = 0;
  for (const i, const ep: sur_arr) {
    const& e = *ep->get().to_slice(1);
    SDL_Rect r0;
    SDL_Rect r1;
    r0.x = 0;
    r0.y = 0;
    r0.w = e.w;
    r0.h = e.h;
    r1.x = cast_int(xcur);
    r1.y = 0;
    r1.w = r0.w;
    r1.h = r1.h;
    const v = SDL_UpperBlit(*ep, caddress(r0), sur_chars, address(r1));
    xcur += cast_uint(wmax);
    fnt.char_x.push_back(xcur);
  }
  fnt.char_w = wmax;
  fnt.char_h = hmax;
  const& sur_chars_ref = *sur_chars.get().to_slice(1);
  fnt.surface_w = static_cast{uint}(sur_chars_ref.w);
  fnt.surface_h = static_cast{uint}(sur_chars_ref.h);
  const sur_chars_buf = sur_chars_ref.pixels.reinterpret_cast{uchar}()
    .to_slice(static_cast{size_t}(sur_chars_ref.pitch * sur_chars_ref.h));
  for (const x: 0 .. sur_chars_ref.w) {
    for (const y: 0 .. sur_chars_ref.h) {
      const i = static_cast{size_t}((y * sur_chars_ref.w + x) * 4);
      sur_chars_buf[i+0] = 255;
      sur_chars_buf[i+1] = 255;
      sur_chars_buf[i+2] = 255;
    }
  }
  glActiveTexture(GL_TEXTURE0);
  fnt.texture_id.generate();
  sdllog("font_texture_id", fnt.texture_id.get());
  glBindTexture(GL_TEXTURE_2D, fnt.texture_id.get());
  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA),
    sur_chars_ref.w, sur_chars_ref.h,
    0, GL_RGBA, GL_UNSIGNED_BYTE, sur_chars_ref.pixels);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
    cast_int(GL_NEAREST));
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
    cast_int(GL_NEAREST));
}

public function void
load_tilemap_texture(gl_texture mutable& tex_dpat,
  gl_texture mutable& tex_pmpat, gl_texture mutable& tex_tilemap,
  string const& dpat_fn, string const& pmpat_fn)
{
  check_byteorder();
  merge_png_to_texture(dpat_fn, tex_dpat,
    make_callable_ptr{merge_dpat, 0}(),
    make_callable_ptr{modify_func_noop, 0}());
  merge_png_to_texture(pmpat_fn, tex_pmpat,
    make_callable_ptr{merge_pmpat, 0}(),
    make_callable_ptr{modify_func_parallax, 0}());
  SDL_Surface_Scoped sur1;
  sur1.reset(SDL_CreateRGBSurface(0, 128, 128, 32, 0, 0, 0, 0));
  const& sur1_ref = *sur1.get().to_slice(1);
  const sur1buf = sur1_ref.pixels.reinterpret_cast{uchar}()
    .to_slice(static_cast{size_t}(sur1_ref.pitch * sur1_ref.h));
  const sur1_w = static_cast{uint}(sur1_ref.w);
  const sur1_h = static_cast{uint}(sur1_ref.h);
  const rnd = make_rand_generator(333U);
  for (const y: 0 .. sur1_h) {
    for (const x: 0 .. sur1_w) {
      const o1 = (y * sur1_w + x) * 4;
      const v0 = rnd->generate() / 65536;
      const v1 = v0 % 8;
      const v2 = (v0 / 8) % 8;
      const uint specular_ambient = 0xff60;
      if (x == 0 && y == 0) {
	write_4_uint(sur1buf, o1, specular_ambient << 16);
      } else {
	write_4_uint(sur1buf, o1, (v1 % 8) | specular_ambient << 16);
      }
    }
  }
  sdllog("sur1buf", sur1_w, sur1_h);
  const mode = GL_RGBA;
  glActiveTexture(GL_TEXTURE0);
  tex_tilemap.surface_w = sur1_w;
  tex_tilemap.surface_h = sur1_h;
  tex_tilemap.texture_id.generate();
  glBindTexture(GL_TEXTURE_2D, tex_tilemap.texture_id.get());
  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(mode),
    cast_int(sur1_ref.w), cast_int(sur1_ref.h),
    0, mode, GL_UNSIGNED_BYTE, sur1buf.to_crawptr().to_cvoidptr());
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
    cast_int(GL_NEAREST));
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
    cast_int(GL_NEAREST));
}

public function void
load_cube_texture(gl_texture mutable& ctex, cslice{string} const& fnames)
{
  glActiveTexture(GL_TEXTURE0);
  ctex.texture_id.generate();
  glBindTexture(GL_TEXTURE_CUBE_MAP, ctex.texture_id.get());
  for (const i: 0 .. 6) {
    const td = load_texture_data(fnames[static_cast{uint}(i)]);
    ctex.surface_w = td->width;
    ctex.surface_h = td->height;
    const use_mipmap = false;
    const tgt = static_cast{GLenum}(
      static_cast{int}(GL_TEXTURE_CUBE_MAP_POSITIVE_X) + i);
    set_gl_texture(*td, ctex, tgt, use_mipmap);
  }
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER,
    cast_int(GL_LINEAR));
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER,
    cast_int(GL_LINEAR));
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S,
    cast_int(GL_CLAMP_TO_EDGE));
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T,
    cast_int(GL_CLAMP_TO_EDGE));
  if (m::is_true{is_gl3_or_gles3}) {
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R,
      cast_int(GL_CLAMP_TO_EDGE));
  }
}

public function void
load_2d_texture(gl_texture mutable& tx, string const& fname)
{
  const td = load_texture_data(fname);
  glActiveTexture(GL_TEXTURE0);
  tx.texture_id.generate();
  glBindTexture(GL_TEXTURE_2D, tx.texture_id.get());
  tx.surface_w = td->width;
  tx.surface_h = td->height;
  const use_mipmap = false;
  set_gl_texture(*td, tx, GL_TEXTURE_2D, use_mipmap);
}

/* private */

private threaded function {t} t power_of_2(t v)
{
  mutable t r = static_cast{t}(1);
  while (r != 0 && r < v) { r <<= 1; }
  return r;
}

private function extern "sdl_byteorder" int sdl_byteorder();
private function extern "sdl_lil_endian" int sdl_lil_endian();
private function extern "sdl_big_endian" int sdl_big_endian();

extern "functions" inline
namespace pgl3d$n { namespace texture$n {
static inline ::pxcrt::bt_int sdl_byteorder()
{ return SDL_BYTEORDER; }
static inline ::pxcrt::bt_int sdl_lil_endian()
{ return SDL_LIL_ENDIAN; }
static inline ::pxcrt::bt_int sdl_big_endian()
{ return SDL_BIG_ENDIAN; }
}; };
;

function void check_byteorder()
{
  if (sdl_byteorder() != sdl_lil_endian()
      && sdl_byteorder() != sdl_big_endian()) {
      throw runtime_error_template{"unknown byteorder"}("1");
  }
  sdllog("byteorder ", sdl_byteorder());
}

function uint read_4_uint(cslice{uchar} const& buf, size_t o)
{
  uint v;
  if (sdl_byteorder() == sdl_lil_endian()) {
    v += buf[o+3]; v *= 256;
    v += buf[o+2]; v *= 256;
    v += buf[o+1]; v *= 256;
    v += buf[o+0];
  } else if (sdl_byteorder() == sdl_big_endian()) {
    v += buf[o+0]; v *= 256;
    v += buf[o+1]; v *= 256;
    v += buf[o+2]; v *= 256;
    v += buf[o+3];
  }
  return v;
}

function uint read_3_uint(cslice{uchar} const& buf, size_t o)
{
  uint v;
  if (sdl_byteorder() == sdl_lil_endian()) {
    v += buf[o+2]; v *= 256;
    v += buf[o+1]; v *= 256;
    v += buf[o+0];
  } else if (sdl_byteorder() == sdl_big_endian()) {
    v += buf[o+0]; v *= 256;
    v += buf[o+1]; v *= 256;
    v += buf[o+2];
  }
  return v;
}

function void write_4_uint(slice{uchar} const& buf, size_t o, uint val)
{
  if (sdl_byteorder() == sdl_lil_endian()) {
    buf[o+3] = static_cast{uchar}(val >> 24);
    buf[o+2] = static_cast{uchar}(val >> 16);
    buf[o+1] = static_cast{uchar}(val >>  8);
    buf[o+0] = static_cast{uchar}(val);
  } else if (sdl_byteorder() == sdl_big_endian()) {
    buf[o+0] = static_cast{uchar}(val >> 24);
    buf[o+1] = static_cast{uchar}(val >> 16);
    buf[o+2] = static_cast{uchar}(val >>  8);
    buf[o+3] = static_cast{uchar}(val);
  }
}

metafunction SDL_Surface_Scoped scoped_nullable{SDL_FreeSurface};

struct texture_data()
{
  public uint width;
  public uint height;
  public varray{uint} data; // (a << 24) | (b << 16) | (b << 8) | (r << 0)
}

function ptr{texture_data}
load_texture_data(string const& fn0)
{
  const p = make_ptr{texture_data}();
  string fn = fn0;
  fn.push_back(0);
  SDL_Surface_Scoped sur0;
  sur0.reset(IMG_Load(fn.to_crawptr().to_ccharptr()));
  if (sur0.get() == rawptr{SDL_Surface}()) {
    sdllog("failed to load", fn);
    throw runtime_error_template{"img_load"}(fn0);
  }
  sdllog("loading image: loaded", fn);
  const& sur0ref = *sur0.get().to_slice(1);
  const fmtp = sur0ref.format;
  const& fmt = *sur0ref.format.to_slice(1);
  const bpp = fmt.BytesPerPixel;
  if (bpp != 4 && bpp != 3) {
    throw runtime_error_template{"img_load"}("bpp");
  }
  const sur0_w = static_cast{uint}(sur0ref.w);
  const sur0_h = static_cast{uint}(sur0ref.h);
  mutable tex_w = power_of_2(sur0_w);
  mutable tex_h = power_of_2(sur0_h);
  p->width = tex_w;
  p->height = tex_h;
  mutable& uibuf = p->data;
  uibuf.resize(tex_w * tex_h, 0);
  uint rmask = fmt.Rmask;
  uint gmask = fmt.Gmask;
  uint bmask = fmt.Bmask;
  uint amask = fmt.Amask;
  function uint get_shift(uint m) {
    uint r = 0;
    for (uint i: 0 .. 32) {
      if ((m & 1) != 0) {
	break;
      }
      r += 1;
      m >>= 1;
    }
    return r;
  }
  uint rshift = get_shift(rmask);
  uint gshift = get_shift(gmask);
  uint bshift = get_shift(bmask);
  uint ashift = get_shift(amask);
  const& sur0_ref = *sur0.get().to_slice(1);
  const sur0buf = sur0_ref.pixels.reinterpret_cast{uchar}()
    .to_slice(static_cast{size_t}(sur0_ref.pitch * sur0_ref.h));
  for (const y: 0 .. sur0_h) {
    for (const x: 0 .. sur0_w) {
      const o = (y * sur0_w + x) * bpp;
      uint v;
      uint vr;
      uint vg;
      uint vb;
      uint va;
      if (bpp == 3) {
	v = read_3_uint(sur0buf, o);
      } else if (bpp == 4) {
	v = read_4_uint(sur0buf, o);
      }
      vr = (v >> rshift) & 0xffU;
      vg = (v >> gshift) & 0xffU;
      vb = (v >> bshift) & 0xffU;
      if (bpp == 4) {
	va = (v >> ashift) & 0xffU;
      }
      uint v1 = (va << 24) | (vb << 16) | (vg << 8) | (vr << 0);
      uibuf[y * tex_w + x] = v1;
    }
  }
  return p;
}

function void dump_buf(varray{uint} const& buf)
{
  debug_log("dump_buf_begin");
  for (const i, const& v: buf) {
    debug_log(i, v);
  }
  debug_log("dump_buf_end");
}

function void set_gl_texture(texture_data mutable& td, gl_texture mutable& ti,
  GLenum target, bool use_mipmap)
{
  uint tex_w = td.width;
  uint tex_h = td.height;
  mutable& uibuf = td.data;
  int mipmap_level = 0;
  const mode = GL_RGBA;
  while (true) {
    // dump_buf(uibuf);
    // TODO: assumes little endian
    glTexImage2D(target, mipmap_level, cast_int(mode),
      cast_int(tex_w), cast_int(tex_h),
      0, mode, GL_UNSIGNED_BYTE, uibuf.to_crawptr().to_cvoidptr());
    const tex_w_prev = tex_w;
    const tex_h_prev = tex_h;
    tex_w /= 2;
    tex_h /= 2;
    if (!use_mipmap) {
      break;
    }
    if (tex_w == 0 || tex_h == 0) {
      break;
    }
    ++mipmap_level;
    for (const y: 0 .. tex_h) {
      for (const x: 0 .. tex_w) {
	farray{uint, 4} v;
	v[0] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 0)];
	v[1] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 1)];
	v[2] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 0)];
	v[3] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 1)];
	uint mutable val_b;
	uint mutable val_g;
	uint mutable val_r;
	size_t opaque_count = 0;
	for (size_t j: 0 .. 4) {
	  val_b += (v[j] >> 16) & 0xff;
	  val_g += (v[j] >>  8) & 0xff;
	  val_r += (v[j] >>  0) & 0xff;
	  if (((v[j] >> 24) & 0x0f) == 10) { ++opaque_count; }
	}
	val_b /= 4;
	val_g /= 4;
	val_r /= 4;
	const val_a = opaque_count > 0 ? 10U : (v[0] >> 24) & 0xff; // TODO
	/*
	uibuf[y * tex_w + x] = (val_a << 24) +
	  (val_b << 16) + (val_g << 8) + (val_r << 0);
	uibuf[y * tex_w + x] = v[0];
	*/
      }
    }
  }
  if (target == GL_TEXTURE_2D) {
    glTexParameteri(target, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(target, GL_TEXTURE_MIN_FILTER,
      cast_int(mipmap_level >= 1 ? GL_NEAREST_MIPMAP_NEAREST : GL_NEAREST));
    if (m::is_true{is_gl3_or_gles3}) {
      if (mipmap_level != 0) {
	glTexParameteri(target, GL_TEXTURE_BASE_LEVEL, 0);
	glTexParameteri(target, GL_TEXTURE_MAX_LEVEL, mipmap_level);
      }
    }
  }
}

function ptr{texture_data} merge_tile(texture_data mutable& td, uint tile_size,
  callable_ptr{uint, {uint, uint, uint, uint}} const& merge_func)
{
  const r = make_ptr{texture_data}();
  r->width = td.width;
  r->height = td.width;
  mutable& ndata = r->data;
  {
    const& data = td.data;
    ndata.resize(data.size(), 0U);
    for (const by : 0 .. td.height / tile_size / 2) {
      for (const iy: 0 .. tile_size) {
	for (const x: 0 .. td.width) {
	  const o0 = (by * tile_size * 2 + iy            ) * td.width + x;
	  const o1 = (by * tile_size * 2 + iy + tile_size) * td.width + x;
	  const v0 = data[o0];
	  const v1 = data[o1];
	  const y = by * tile_size + iy;
	  ndata[y * td.width + x] = merge_func(v0, v1, x, y);
	}
      }
    }
  }
  return r;
}

function void merge_png_to_texture(string const& fn,
  gl_texture mutable& tex,
  callable_ptr{uint, {uint, uint, uint, uint}} const& merge_func,
  callable_ptr{void, {ptr{texture_data}}} const& modify_func)
{
  const td = load_texture_data(fn);
  const td2 = merge_tile(*td, 32, merge_func);
  modify_func(td2);
  glActiveTexture(GL_TEXTURE0);
  tex.texture_id.generate();
  glBindTexture(GL_TEXTURE_2D, tex.texture_id.get());
  tex.surface_w = td->width;
  tex.surface_h = td->height;
  set_gl_texture(*td2, tex, GL_TEXTURE_2D, false);
}

function void modify_func_noop(ptr{texture_data} const& td)
{
}

threaded function {t} string to_hexstring(t v)
{
  string r;
  integral_to_hexadecimal{t}(v, r);
  return r;
}

threaded function uint merge_dpat(uint v0, uint v1, uint x, uint y)
{
  // debug_log(x, y, to_hexstring(v0), to_hexstring(v1));
  const nor = v0 & 0xffffffU;
  const col = v1 & 0xffffffU;
  uint val; /* avol for higher 4bits, alv for lower 4bits */
  if (nor == 0x0000ff) {
    val = 0x91; /* convex left-upper */
  } else if (nor == 0x00ff00) {
    val = 0x92; /* convex upper, or concave lower */
  } else if (nor == 0x00ffff) {
    val = 0x93; /* convex right-upper */
  } else if (nor == 0xff0000) {
    val = 0x94; /* convex right, or concave left */
  } else if (nor == 0xff00ff) {
    val = 0x95; /* convex right-lower */
  } else if (nor == 0xffff00) {
    val = 0x72; /* convex lower, or concave upper */
  } else if (nor == 0xffffff) {
    val = 0x97; /* convex left-lower */
  } else if (nor == 0x808080) {
    val = 0x74; /* convex left, or concave right */
  } else if (nor == 0x4040c0) {
    val = 0x71; /* concave left-upper */
  } else if (nor == 0x40c0c0) {
    val = 0x73; /* concave right-upper */
  } else if (nor == 0xc040c0) {
    val = 0x75; /* concave right-lower */
  } else if (nor == 0xc0c0c0) {
    val = 0x77; /* concave left-lower */
  } else if (nor == 0xc08080) {
    val = 0x0f; /* discard */
  }
  return (val << 24) | col;
}

threaded function uint merge_pmpat(uint v0, uint v1, uint x, uint y)
{
  const nor = v0 >> 8;
  const col = v1 >> 8;
  threaded function int babs(int x) {
    return x < 0 ? (-1 - x) : x;
  }
  int mx = static_cast{int}(x % 32U);
  int my = static_cast{int}(y % 32U);
  int x1 = babs(mx - 16); // [0, 15]
  int y1 = babs(my - 16); // [0, 15]
  uint z = 0;
  if (x1 >= 12 || y1 >= 12) {
    z = 0;
  } else if (x1 == 0 || y1 == 0) {
    z = 1;
  } else {
    z = 2;
  }
  z *= 16U;
  return z << 16;
}

function void modify_func_parallax(ptr{texture_data} const& td)
{
  mutable& data = td->data;
  uint const tile_size = 32;
  for (const by : 0 .. td->height / tile_size) {
    for (const bx : 0 .. td->width / tile_size) {
      for (const y : 0 .. tile_size) {
	for (const x : 0 .. tile_size) {
	  const offset = (by * tile_size + y) * td->height
	    + (bx * tile_size + x);
	  const v0 = data[offset];
	  const depth0 = (v0 >> 16) & 0xffU;
	  // clearance values
	  uint c_nn = min(x, y);
	  uint c_np = min(x, tile_size - 1 - y);
	  uint c_pn = min(tile_size - 1 - x, y);
	  uint c_pp = min(tile_size - 1 - x, tile_size - 1 - y);
	  for (const y1 : 0 .. tile_size) {
	    for (const x1 : 0 .. tile_size) {
	      const offset1 = (by * tile_size + y1) * td->height
		+ (bx * tile_size + x1);
	      const v1 = data[offset1];
	      const depth1 = v1 >> 16 & 0xffU;
	      if (depth1 >= depth0) {
		continue;
	      }
	      // ok to wrap uint values
	      uint nn = max(x - x1, y - y1) - 1;
	      c_nn = min(c_nn, nn);
	      uint np = max(x - x1, y1 - y) - 1;
	      c_np = min(c_np, np);
	      uint pn = max(x1 - x, y - y1) - 1;
	      c_pn = min(c_pn, pn);
	      uint pp = max(x1 - x, y1 - y) - 1;
	      c_pp = min(c_pp, pp);
	    }
	  }
	  c_nn = min(c_nn, 15);
	  c_np = min(c_np, 15);
	  c_pn = min(c_pn, 15);
	  c_pp = min(c_pp, 15);
	  // W = unused(8), Z = depth(8), Y = CNN(4) CNP(4), X = CPN(4) CPP(4)
	  data[offset] = (depth0 << 16) |
	    (c_nn << 12) | (c_np << 8) | (c_pn << 4) | (c_pp << 0);
	  if (by == 0 && bx == 0) {
	    // debug_log("cl", x, y, depth0, to_hexstring(data[offset]));
	  }
	}
      }
    }
  }
}

