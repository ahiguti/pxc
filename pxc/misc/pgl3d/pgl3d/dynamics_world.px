public namespace pgl3d::dynamics_world "use-unsafe";
public import common -;
private import Bullet::base -;
private import Bullet::constants -;
private import Bullet::api +;
public import pointer::raw -;
private import pointer::raw_unsafe -;
public import meta m;
public import meta::vararg va;
public import pgl3d::scene_node -;
public import numeric::fpmath -;
public import glm;
private import pgl3d::grid_broadphase -;
private import pgl3d::collision_gjk -;

public threaded interface
collision_shape_i
{
}

public threaded interface
triangle_mesh_i triangle_mesh
{
  public function void add_triangle(
    float v00, float v01, float v02,
    float v10, float v11, float v12,
    float v20, float v21, float v22);
}

public threaded function ptr{triangle_mesh_i}
make_triangle_mesh()
{
  return make_ptr{triangle_mesh}();
}

public threaded function ptr{collision_shape_i}
make_triangle_mesh_shape(ptr{triangle_mesh_i} const& mesh0)
{
  return make_ptr{triangle_mesh_shape}(
    pointer_downcast{ptr{triangle_mesh}}(mesh0));
}

public threaded function ptr{collision_shape_i}
make_sphere_shape(float radius)
{
  const r = make_ptr{collision_shape_tmpl{btSphereShape}}(radius);
  r->radius = radius;
  return r;
}

public threaded function ptr{collision_shape_i}
make_box_shape(float x, float y, float z)
{
  const r = make_ptr{collision_shape_tmpl{btBoxShape}}(btVector3_(x, y, z));
  const sq = x * x + y * y + z * z;
  r->radius = sqrt(sq);
  return r;
}

public threaded function ptr{collision_shape_i}
make_convex_hull_shape(cslice{float} const& v)
{
  const r = make_ptr{collision_shape_tmpl{btConvexHullShape}}(
    v.to_crawptr(), static_cast{int}(v.size() / 3), 3 * 4);
  float sqmax = 0.0f;
  for (const i: 0 .. v.size() / 3) {
    const x = v[i * 3];
    const y = v[i * 3 + 1];
    const z = v[i * 3 + 2];
    const sq = x * x + y * y + z * z;
    sqmax = max(sqmax, sq);
  }
  r->radius = sqrt(sqmax);
  debug_log("ch", r->radius);
  return r;
}

public threaded interface
rigid_body_i rigid_body
{
  public function joint_id_type get_joint_id() const;
  public function void apply_central_impulse(float x, float y, float z);
  public function void apply_torque_impulse(float x, float y, float z);
  public function void get_world_transform_mat4(glm::mat4 mutable& m);
}

public threaded function ptr{rigid_body_i}
make_rigid_body(joint_id_type const& joint_id,
  ptr{collision_shape_i} const& shape, float mass, cslice{float} const& t)
{
  const m3 = btMatrix3x3_(
    t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]);
  const v3 = btVector3_(t[12], t[13], t[14]);
  const btr = btTransform_(m3, v3);
  const sh = pointer_downcast{ptr{collision_shape_priv_i}}(shape);
  return make_ptr{rigid_body}(joint_id, sh, mass, btr);
}

public threaded interface
dynamic_object_i
{
  public function void on_collide();
  public function void on_step(float speed);
}

public multithreaded interface
swarm_i
{
  public function size_t size() const;
  public function uint get(size_t i, glm::vec3 mutable& pos_r,
    float mutable& radius_r) const;
  public function void on_collide(size_t i, size_t dynobj_id);
  public function void on_step(float speed);
}

public threaded struct
dynamics_world()
{
  private tsvaluetype struct grid_rbinfo
  {
    public btTransform trans;
    public float radius;
    public crawptr{btCollisionShape} shape;
    public function glm::vec3 get_aabb_min() const {
      const& org = trans.cgetOrigin();
      return glm::make_vec3(
	org.x() - radius,
	org.y() - radius,
	org.z() - radius);
    }
    public function glm::vec3 get_aabb_max() const {
      const& org = trans.cgetOrigin();
      return glm::make_vec3(
	org.x() + radius,
	org.y() + radius,
	org.z() + radius);
    }
  }
  private metafunction broadphase_to_use 2;
  private btDefaultCollisionConfiguration mutable collisionConfiguration 
    = btDefaultCollisionConfiguration(btDefaultCollisionConstructionInfo());
  private btCollisionDispatcher mutable dispatcher
    = btCollisionDispatcher(address(collisionConfiguration));
  expand(s: m::seq{m::eq{broadphase_to_use, 2}}) {
  private btSimpleBroadphase mutable broadphase
    = btSimpleBroadphase(65536U, rawptr{btOverlappingPairCache}());
  }
  expand(s: m::seq{m::eq{broadphase_to_use, 1}}) {
  private btDbvtBroadphase mutable broadphase
    = btDbvtBroadphase(rawptr{btOverlappingPairCache}());
  }
  expand(s: m::seq{m::eq{broadphase_to_use, 0}}) {
  private bt32BitAxisSweep3 mutable broadphase
    = bt32BitAxisSweep3_(
      btVector3_(-1000.0f, -1000.0f, -1000.0f),
      btVector3_( 1000.0f,  1000.0f,  1000.0f),
      65536U, rawptr{btOverlappingPairCache}(), false);
  }
  private btSequentialImpulseConstraintSolver mutable solver;
  private btDiscreteDynamicsWorld mutable dynamicsWorld
    = btDiscreteDynamicsWorld(address(dispatcher), address(broadphase),
      address(solver), address(collisionConfiguration));
  private grid_broadphase mutable grid_bp = grid_broadphase(6, 10.0f);
  private varray{bool} grid_bp_work_near;
  private varray{uint} grid_bp_work_near_ents;
  private varray{ptr{rigid_body}} rigid_bodies;
  private varray{grid_rbinfo} grid_rbinfo_array; // same size as rigid_bodies
  private varray{tptr{swarm_i}} swarms;
  init();
  private function void init() {
    dynamicsWorld.setForceUpdateAllAabbs(false);
    // dynamicsWorld.getSimulationIslandManager()->setSplitIslands(false);
  }
  private function ~
  {
    clear();
  }
  public function size_t rigid_bodies_size() const {
    return rigid_bodies.size();
  }
  public function void set_gravity(float x, float y, float z)
  {
    dynamicsWorld.setGravity(btVector3_(x, y, z));
  }
  public function void clear()
  {
    for (size_t i, const& rb: rigid_bodies) {
      dynamicsWorld.removeCollisionObject(address(rb->rigidBody));
    }
    rigid_bodies.clear();
    grid_rbinfo_array.clear();
    swarms.clear();
  }
  public function void add_swarm(tptr{swarm_i} const& s)
  {
    swarms.push_back(s);
  }
  public function void add_rigid_body(ptr{rigid_body_i} const& rb)
  {
    const rb1 = pointer_downcast{ptr{rigid_body}}(rb);
    if (rb1->offset != static_cast{size_t}(-1)) {
      return;
    }
    rb1->offset = rigid_bodies.size();
    grid_rbinfo rbi;
    rbi.radius = rb1->shape->get_radius();
    rbi.shape = rb1->shape->get();
    rigid_bodies.push_back(rb1);
    grid_rbinfo_array.push_back(rbi);
    dynamicsWorld.addRigidBody(address(rb1->rigidBody));
  }
  public function void remove_rigid_body(ptr{rigid_body_i} const& rb)
  {
    const rb1 = pointer_downcast{ptr{rigid_body}}(rb);
    const offset = rb1->offset;
    if (offset == static_cast{size_t}(-1)) {
      return;
    }
    const sz = rigid_bodies.size();
    if (sz > 1) {
      swap(rigid_bodies[offset], rigid_bodies[sz - 1]);
      swap(grid_rbinfo_array[offset], grid_rbinfo_array[sz - 1]);
      rigid_bodies[offset]->offset = offset;
    }
    rigid_bodies.erase(sz - 1, sz);
    grid_rbinfo_array.erase(sz - 1, sz);
    dynamicsWorld.removeCollisionObject(address(rb1->rigidBody));
  }
  public function {f} void rigid_bodies_foreach()
  {
    for (const i, const& obj: rigid_bodies) {
      f(i, obj);
    }
  }
  public function void step_simulation(float timestep, int max_sub_steps,
    float fixed_timestep)
  {
    start_grid_collision();
    dynamicsWorld.stepSimulation(timestep, max_sub_steps, fixed_timestep);
    finish_grid_collision();
  }
  private function void start_grid_collision()
  {
    float rad_sum = 0.0f;
    // copy position from rigid bodies
    {
      const rbisli = grid_rbinfo_array.range();
      for (const i, const& obj: rigid_bodies) {
	mutable& rbi = rbisli[i];
	rbi.trans = obj->rigidBody.cgetWorldTransform();
	rad_sum += rbi.radius;
      }
    }
    const rad_avg = rad_sum / static_cast{float}(rigid_bodies.size());
    grid_bp.set_mesh_size(rad_avg * 4.0f);
    // fill grid
    grid_bp.add_objects(grid_rbinfo_array);
    /*
    debug_log("fillings", rad_avg, grid_rbinfo_array.size(),
      grid_bp.fillings.size());
    */
    glm::vec3 pos;
    float radius;
    collision_gjk gjk;
    size_t bp_count = 0;
    size_t bp1_count = 0;
    size_t np_count = 0;
    size_t np1_count = 0;
    if (grid_bp_work_near.size() < rigid_bodies.size()) {
      grid_bp_work_near.resize(rigid_bodies.size(), false);
    }
    for (const i, const& swp: swarms) {
      mutable& sw = *swp;
      const sz = sw.size();
      // debug_log("sw", i, sz);
      for (const j: 0 .. sz) {
	// debug_log("j", j);
	if (j + 1 < sz) {
	  // prefetch
	  /*
	  if (sw.get(j + 1, pos, radius) != 0U) {
	    const btpos = btVector3_(pos.x, pos.y, pos.z);
	    const d = glm::make_vec3(radius, radius, radius);
	    grid_bp.prefetch(pos - d, pos + d);
	  }
	  */
	}
	if (sw.get(j, pos, radius) != 0U) {
	  const btpos = btVector3_(pos.x, pos.y, pos.z);
	  const d = glm::make_vec3(radius, radius, radius);
	  threaded function bool near_cb(col_id_type col_id) {
	    ++bp_count;
	    if (!grid_bp_work_near[col_id]) {
	      grid_bp_work_near[col_id] = true;
	      grid_bp_work_near_ents.push_back(col_id);
	    }
	    return false;
	  }
	  grid_bp.find{near_cb}(pos - d, pos + d);
	  bp1_count += grid_bp_work_near_ents.size();
	  for (const k, const col_id: grid_bp_work_near_ents) {
	    grid_bp_work_near[col_id] = false;
	    // sw.on_collide(j, col_id);
	    const& rbi = grid_rbinfo_array[col_id];
	    const& rbpos = rbi.trans.cgetOrigin();
	    const rel = glm::make_vec3(pos.x - rbpos.x(), pos.y - rbpos.y(),
	      pos.z - rbpos.z());
	    const reldist2 = glm::dot(rel, rel);
	    const radsum = rbi.radius + radius;
	    if (reldist2 >= radsum * radsum) {
	      continue;
	    }
	    ++np_count;
	    /*
	    const p = rbi.shape.dynamic_cast{btConvexShape}();
	    if (!gjk.collide_convex_sphere(*p, rbi.trans, radius, btpos)) {
	      continue;
	    }
	    */
	    ++np1_count;
	    sw.on_collide(j, col_id);
	  }
	  grid_bp_work_near_ents.clear();
	}
      }
    }
    // debug_log("bp", bp_count, bp1_count, "np", np_count, np1_count);
  }
  private function void finish_grid_collision()
  {
    grid_bp.clear();
  }
}

/* private */

private threaded interface collision_shape_priv_i <collision_shape_i> {
  public function crawptr{btCollisionShape} get() const;
  public function float get_radius() const;
}

private threaded struct {t}
collision_shape_tmpl(expand(m::args{t}))
  <collision_shape_priv_i>
{
  public t value = t(expand(a: m::arg_names{t}; a));
  public float radius = 0.0f;
  public function crawptr{btCollisionShape} get() const
  {
    return caddress(value);
  }
  public function float get_radius() const
  {
    return radius;
  }
}

private threaded struct
triangle_mesh()
<triangle_mesh_i>
{
  public btTriangleMesh mesh = btTriangleMesh(true, true);
  public float radius_square = 0.0f;
  public function void add_triangle(
    float v00, float v01, float v02,
    float v10, float v11, float v12,
    float v20, float v21, float v22)
  {
    mesh.addTriangle(btVector3_(v00, v01, v02), btVector3_(v10, v11, v12),
      btVector3_(v20, v21, v22), true);
    update_radius(v00, v01, v02);
    update_radius(v10, v11, v12);
    update_radius(v20, v21, v22);
  }
  private function void update_radius(float x, float y, float z)
  {
    const v = x * x + y * y + z * z;
    radius_square = max(radius_square, v);
  }
}

private threaded struct
triangle_mesh_shape(ptr{triangle_mesh} const& mesh0)
  <collision_shape_priv_i>
{
  public ptr{triangle_mesh} mesh = mesh0;
  public btBvhTriangleMeshShape value = btBvhTriangleMeshShape(
    address(mesh->mesh), true, true);
  public float const radius = sqrt(mesh->radius_square);
  public function crawptr{btCollisionShape} get() const
  {
    return caddress(value);
  }
  public function float get_radius() const
  {
    return radius;
  }
}

private threaded struct
rigid_body(joint_id_type const& joint_id0,
  ptr{collision_shape_priv_i} const& shape0, btScalar mass0,
  btTransform const& tr0)
<rigid_body_i>
{
  public joint_id_type const joint_id = joint_id0;
  public ptr{collision_shape_priv_i} const shape = shape0;
  public btRigidBody rigidBody = makeRigidBody(shape->get(), tr0, mass0);
  public size_t offset = static_cast{size_t}(-1);
  init(mass0);
  function void init(float mass) {
    if (mass == 0.0f) {
      rigidBody.setCollisionFlags(rigidBody.getCollisionFlags() |
	CF_KINEMATIC_OBJECT);
      rigidBody.setActivationState(DISABLE_DEACTIVATION);
    }
  }
  public function joint_id_type get_joint_id() const
  {
    return joint_id;
  }
  public function void apply_central_impulse(float x, float y, float z)
  {
    rigidBody.applyCentralImpulse(btVector3_(x, y, z));
  }
  public function void apply_torque_impulse(float x, float y, float z)
  {
    rigidBody.applyTorqueImpulse(btVector3_(x, y, z));
  }
  public function void get_world_transform_mat4(glm::mat4 mutable& m)
  {
    const sli = m.to_slice();
    rigidBody.getWorldTransform().getOpenGLMatrix(sli.to_rawptr());
  }
}

private threaded function btRigidBody makeRigidBody(
  crawptr{btCollisionShape} shape, btTransform const& tr0, btScalar mass)
{
  const isDynamic = (mass != 0.0f);
  mutable localInertia = btVector3_(0.0f, 0.0f, 0.0f);
  if (isDynamic) {
    shape->calculateLocalInertia(mass, localInertia);
  }
  mutable rbInfo = btRigidBody_btRigidBodyConstructionInfo(mass,
    rawptr{btDefaultMotionState}(), shape.const_cast(), localInertia);
  rbInfo.m_startWorldTransform = tr0;
  // rbInfo.m_friction = 0.0f;
  // rbInfo.m_rollingFriction = 0.0f;
  // rbInfo.m_restitution = 0.0f;
  const r = btRigidBody(rbInfo);
  return r;
}

