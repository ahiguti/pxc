public namespace pgl3d::dynamics_world "export-unsafe";
public import common -;
public import Bullet::base -;
public import Bullet::api +;
public import pointer::raw_unsafe -;
public import pgl3d::collision_shape *;
public import meta m;
public import meta::vararg va;

// extern "types" inline
// #include <bullet/BulletCollision/CollisionDispatch/btSimulationIslandManager.h>
// ;

public metafunction broadphase_to_use 2;

public threaded struct pgl3dDynamicsWorld()
  // <pgl3dDynamicsWorld_i>
{
  public btDefaultCollisionConfiguration mutable collisionConfiguration 
    = btDefaultCollisionConfiguration(btDefaultCollisionConstructionInfo());
  public btCollisionDispatcher mutable dispatcher
    = btCollisionDispatcher(address(collisionConfiguration));
  expand(s: m::seq{m::eq{broadphase_to_use, 2}}) {
  public btSimpleBroadphase mutable broadphase
    = btSimpleBroadphase(65536U, rawptr{btOverlappingPairCache}());
  }
  expand(s: m::seq{m::eq{broadphase_to_use, 1}}) {
  public btDbvtBroadphase mutable broadphase
    = btDbvtBroadphase(rawptr{btOverlappingPairCache}());
  }
  expand(s: m::seq{m::eq{broadphase_to_use, 0}}) {
  public bt32BitAxisSweep3 mutable broadphase
    = bt32BitAxisSweep3_(
      btVector3_(-1000.0f, -1000.0f, -1000.0f),
      btVector3_( 1000.0f,  1000.0f,  1000.0f),
      65536U, rawptr{btOverlappingPairCache}(), false);
  }
  public btSequentialImpulseConstraintSolver mutable solver;
  public btDiscreteDynamicsWorld mutable dynamicsWorld
    = btDiscreteDynamicsWorld(address(dispatcher), address(broadphase),
      address(solver), address(collisionConfiguration));
  private varray{ptr{pgl3dRigidBody}} rigidBodies;
  init();
  private function void init() {
    dynamicsWorld.setForceUpdateAllAabbs(false);
    // dynamicsWorld.getSimulationIslandManager()->setSplitIslands(false);
  }
  function ~
  {
    clear();
  }
  public function void clear()
  {
    for (size_t i, const& rb: rigidBodies) {
      dynamicsWorld.removeCollisionObject(address(rb->rigidBody));
    }
    rigidBodies.clear();
  }
  public function void addRigidBody(ptr{pgl3dRigidBody} const& rigidBody)
  {
    if (rigidBody->offset != static_cast{size_t}(-1)) {
      return;
    }
    dynamicsWorld.addRigidBody(address(rigidBody->rigidBody));
    rigidBody->offset = rigidBodies.size();
    rigidBodies.push_back(rigidBody);
  }
  public function void removeRigidBody(ptr{pgl3dRigidBody} const& rigidBody)
  {
    const offset = rigidBody->offset;
    if (offset == static_cast{size_t}(-1)) {
      return;
    }
    dynamicsWorld.removeCollisionObject(address(rigidBody->rigidBody));
    const sz = rigidBodies.size();
    if (sz > 1) {
      swap(rigidBodies[offset], rigidBodies[sz - 1]);
      rigidBodies[offset]->offset = offset;
    }
    rigidBodies.erase(sz - 1, sz);
  }
}

