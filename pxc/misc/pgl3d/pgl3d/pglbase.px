public threaded namespace pgl3d::pglbase;
public import common -;
public import meta m;
public import glm;
public import pgl3d::glvertex *;
public import pgl3d::glgeometry *;
public import pgl3d::glconf -;
public import pgl3d::scene_node -;
public import pgl3d::intern_pool -;

public multithreaded struct instance_data {
  public varray{float} instance_buffer;
  public size_t glbuffer_offset_float;
}

// public metafunction vs_instances_type varray{instance_data};
public metafunction bo_instances_type varray{instance_data};
public metafunction whole_instances_type varray{bo_instances_type};

public tsvaluetype struct position_angle
{
  public glm::vec3 position;
  public glm::quat angle;
  public function glm::mat4 to_mat4() const
  {
    return glm::mat4().translate(position) * angle.to_mat4();
  }
  public function void translate_relative(glm::vec3 const& v)
  {
    position += angle.to_mat3() * v;
  }
  public function void rotate_angle_axis(float a, float x, float y, float z)
  {
    angle *= glm::make_quat_angle_axis(a, x, y, z);
  }
  public function void normalize()
  {
    angle.normalize();
  }
}

public tsvaluetype struct
projection_info()
{
  public glm::mat4 projection;
  public glm::mat4 sm_projection;
  public position_angle camera;
  public position_angle light;
  public int screen_width;
  public int screen_height;
}

public tsvaluetype struct vertex_buffer_pool_key { }
public metafunction vertex_buffer_id
  m::symbol{intern_pool{vertex_buffer_pool_key}, "id_type"};

public tsvaluetype struct
texture_info()
{
  public uint surface_w;
  public uint surface_h;
  public uint char_w;
  public uint char_h;
}

public interface make_vertices_i
{
  public function void make_vertex_set(cslice{string} const& bo_name,
    cstrref const& name, gf_poly const& expr);
  public function cptr{vertices} get_vertices(cstrref const& name) const;
  public function joint_id_type get_joint_id(cstrref const& name) const;
  /*
  // FIXME:remove
  public function ptr{vertices} make_vertices(vertex_buffer_id bo_id,
    cstrref const& name);
  */
  /*
  // FIXME:remove
  public function gf_poly make_filler(ptr{vertices} const& vptr,
    vertex_buffer_id bo_id, bool smooth, cstrref const& name) const;
  // FIXME:remove
  public function gf_poly make_joint(ptr{vertices} const& vptr,
    vertex_buffer_id bo_id, bool polyjoint, cstrref const& name) const;
  */
  public function texture_info get_texture_info(cstrref const& name) const;
  /*
  public function vertex_buffer_id to_vbid(cstrref const& name) const;
  */
}

public threaded struct node_common_data()
{
  public glm::mat4 shadowmapping_vp;
  public glm::mat4 vp;
  public size_t stat_num_objects;
}

public interface pgldrawer_export_i { }

/* built-in shaders */

/*
private metafunction instance_id_type
  m::cond{use_copying_instancing, float, unit};

public tsvaluetype struct triangles_uniforms
{
  public glm::mat4 view_projection_matrix;
  public int sampler;
  public int sampler_tilemap;
  public int sampler_sm;
  public glm::vec3 camera_pos;
  public glm::vec3 light_pos;
  public float light_on;
  public glm::mat4 shadowmap_vp;
}

public tsvaluetype struct triangles_vertex_attributes
{
  public instance_id_type instance_id;
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
}

public tsvaluetype struct triangles2_vertex_attributes
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
}

public tsvaluetype struct zprepass_vertex_attributes
{
  public instance_id_type instance_id;
  public glm::vec3 position;
}

public tsvaluetype struct zprepass2_vertex_attributes
{
  public glm::vec3 position;
}

public tsvaluetype struct shadowmap_vertex_attributes
{
  public instance_id_type instance_id;
  public glm::vec3 position;
}

public tsvaluetype struct shadowmap2_vertex_attributes
{
  public glm::vec3 position;
}

public tsvaluetype struct triangles_instance_attributes
{
  public glm::mat4 model_matrix;
}

public tsvaluetype struct zprepass_uniforms
{
  public glm::mat4 view_projection_matrix;
}

public tsvaluetype struct shadowmap_uniforms
{
  public glm::mat4 shadowmap_vp;
}

public tsvaluetype struct font_uniforms
{
  public int sampler;
}

public tsvaluetype struct font_instance_attributes
{
}

public tsvaluetype struct font_vertex_attributes
{
  public glm::vec2 pos;
  public glm::vec2 uvpos;
}

public tsvaluetype struct font2_uniforms
{
  public glm::vec2 screen_size_px;
  public int sampler;
}

public tsvaluetype struct font2_instance_attributes
{
  public glm::vec4 idata;
}

public tsvaluetype struct font2_vertex_attributes
{
  public instance_id_type instance_id;
  public glm::vec2 texture_size_px;
  public glm::vec2 texture_origin_px;
  public glm::vec2 char_size_px;
  public glm::vec2 coord_clamp;
  public float char_px;
  public float char_point_size;
}

public tsvaluetype struct rect2d_vertex_attributes
{
  public instance_id_type instance_id;
  public glm::vec2 vert;
}

public tsvaluetype struct rect2d_instance_attributes
{
  public glm::vec4 idata; // x0, y0, dx, dy
}

public tsvaluetype struct rect2d_uniforms
{
}

public tsvaluetype struct particle_uniforms
{
  public float point_size_base;
}

public tsvaluetype struct particle_instance_attributes
{
  public glm::mat4 model_matrix; // vp applied
}

public tsvaluetype struct particle_vertex_attributes
{
  public glm::vec3 position;
}

public tsvaluetype struct particle_bb_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 camera_matrix;
  public float point_size_base;
}

public tsvaluetype struct particle_bb_vertex_attributes
{
  public glm::vec3 position;
  public glm::vec2 local_position;
}

public tsvaluetype struct lineparticle_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::vec2 screen_size_px;
  public float screen_size_base;
}

public tsvaluetype struct lineparticle_vertex_attributes
{
  public instance_id_type instance_id;
  public glm::vec2 vert;
}

public tsvaluetype struct lineparticle_instance_attributes
{
  public glm::mat3 idata;
}

*/

