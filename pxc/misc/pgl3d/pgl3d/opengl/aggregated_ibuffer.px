private threaded namespace pgl3d::opengl::aggregated_ibuffer "export-unsafe";
public import common -;
public import pointer::raw -;
public import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
public import GL::compat -;
public import io::time -;
public import meta m;
public import exception -;
public import pgl3d::opengl::glshader -;
public import pgl3d::opengl::glresource -;
public import pgl3d::opengl::glvertex -;
public import pgl3d::opengl::glbuffer -;
public import pgl3d::engine::pglbase -;

public threaded struct aggregated_ibuffer()
{
  private varray{ptr{async_buffer}} buffers;
  private size_t buffer_current;
  public function ptr{async_buffer} get_current() const {
    return buffers[buffer_current];
  }
  public function void switch_buffer() {
    ++buffer_current;
    if (buffer_current >= buffers.size()) {
      buffer_current = 0;
    }
  }
  init();
  private function void init() {
    for (const i: 0 .. 2) {
      buffers.push_back(make_ptr{async_buffer}());
    }
  }
}

public function void
aggregated_ibuffer_frame_begin(aggregated_ibuffer mutable& aibuf,
  whole_instances_type mutable& whole_instances, bool enable_instanced,
  bool enable_uniform_instancing)
{
  if (enable_instanced && !enable_uniform_instancing) {
    size_t offset_float = 0;
    for (const bo_id, mutable& bo_ib: whole_instances) {
      for (const vs_id, mutable& inst: bo_ib) {
	mutable& arr = inst.instance_buffer;
	inst.glbuffer_offset_float = offset_float;
	offset_float += arr.size();
      }
    }
    if (offset_float != 0) {
      mutable& cur_buf = *aibuf.get_current();
      const size_t total_size_float = offset_float;
      offset_float = 0;
      cur_buf.client_wait_sync(1000000000 * 10);
      cur_buf.map_buffer(total_size_float * 4U);
      const rawptr{float} mapped_ptr = cur_buf.mapped_ptr;
      //sdl_log("mapped_ptr", mapped_ptr, total_size_float * 4U);
      for (const bo_id, mutable& bo_ib: whole_instances) {
	for (const vs_id, mutable& inst: bo_ib) {
	  const& arr = inst.instance_buffer;
	  // if (bo_id == 3) { sdl_log("font2 instance", arr); }
	  const size_t sz = arr.size();
	  mutable sli = rawptr_to_slice{float}(mapped_ptr + offset_float, sz);
	  /*
	  pod_array_copy{varray{float}, slice{float}}(arr, sli);
	  */
	  for (const j: 0 .. sz) {
	    sli[j] = arr[j];
	  }
	  /*
	  */
	  offset_float += sz;
	}
      }
      cur_buf.unmap_buffer();
    }
  }
}

public function void
aggregated_ibuffer_frame_end(aggregated_ibuffer mutable& aibuf,
  bool enable_instanced, bool enable_uniform_instancing)
{
  if (enable_instanced && !enable_uniform_instancing) {
    aibuf.get_current()->fence_sync();
    aibuf.switch_buffer();
  }
}

public function void
aggregated_ibuffer_draw(aggregated_ibuffer const& aibuf,
  glshader_i mutable& sdr, vertex_buffer const& bo,
  bo_instances_type const& bo_ib, vertex_buffer_id bo_id,
  bool enable_instanced, bool enable_uniform_instancing)
{
  bo.draw_pre(sdr);
  if (enable_instanced && !enable_uniform_instancing) {
    sdr.enable_instance_attrib_array(true);
    glBindBuffer(GL_ARRAY_BUFFER, aibuf.get_current()->vbo.get());
  }
  for (const vs_id: 0 .. bo.num_vs()) {
    const& instance = bo_ib[vs_id];
    const& arr = instance.instance_buffer;
    if (arr.empty()) {
      continue;
    }
    // sdl_log("draw_elems", ji.bo_id, ji.vs_id, "model=", arr.size());
    if (enable_instanced && !enable_uniform_instancing) {
      if (m::ne{is_gl3_or_gles3, 0}) {
	/*
	sdl_log("instancing bo", bo_id, "iattr_num_float",
	  sdr.instance_attrib_num_float());
	*/
	sdr.instance_attrib_pointer(instance.glbuffer_offset_float);
	bo.draw_elems_instanced(vs_id,
	  arr.size() / sdr.instance_attrib_num_float());
      }
    } else if (enable_uniform_instancing) {
      size_t const iattr_num_float = sdr.instance_attrib_num_float();
      size_t j;
      size_t const jmax = arr.size() / iattr_num_float;
      /*
      sdl_log("uniforminstancing bo", bo_id, "iattr_num_float",
	iattr_num_float, jmax);
      */
      for (j = 0; j < jmax; j += uniform_instancing_mul) {
	size_t k = min((jmax - j), uniform_instancing_mul);
	sdr.instance_attrib_set_uniform(arr, j * iattr_num_float, k);
	bo.draw_elems_instanced(vs_id, k);
      }
      /*
      size_t const jmax = arr.size();
      sdl_log("uniforminstancing bo", bo_id, "iattr_num_float",
	iattr_num_float, jmax);
      for (j = 0; j < jmax; j += iattr_num_float * uniform_instancing_mul) {
	size_t k = min((jmax - j) / iattr_num_float, uniform_instancing_mul);
	sdr.instance_attrib_set_uniform(arr, j, k);
	bo.draw_elems_instanced(vs_id, k);
      }
      */
    } else { /* no instancing (copying is not supported anymore) */
      size_t const iattr_num_float = sdr.instance_attrib_num_float();
      size_t j;
      const& be = *bo.get_by_id(vs_id);
      size_t const jmax = arr.size() / iattr_num_float;
      size_t inst_mul = 1; // this value was > 1 when copying is supported
      /*
      sdl_log("noinstancing bo", bo_id, "iattr_num_float",
	iattr_num_float, jmax, inst_mul);
      */
      for (j = 0; j < jmax; j += inst_mul) {
	size_t k = min((jmax - j), inst_mul);
	sdr.instance_attrib_set_uniform(arr, j * iattr_num_float, k);
	bo.draw_elems(vs_id, k);
      }
      /*
      size_t const jmax = arr.size();
      const inst_mul = be.vtxs->num_copies;
      sdl_log("noinstancing bo", bo_id, "iattr_num_float",
	iattr_num_float, jmax);
      for (j = 0; j < jmax; j += iattr_num_float * inst_mul) {
	size_t k = min((jmax - j) / iattr_num_float, inst_mul);
	sdr.instance_attrib_set_uniform(arr, j, k);
	bo.draw_elems(vs_id, k);
      }
      */
    }
  }
  if (enable_instanced && !enable_uniform_instancing) {
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    sdr.enable_instance_attrib_array(false);
  }
  bo.draw_post(sdr);
}

