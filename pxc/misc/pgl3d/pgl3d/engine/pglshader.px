private namespace pgl3d::engine::pglshader "export-unsafe";
public import common -;
public import pointer::raw -;
public import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
public import glm::raw;
public import io::time -;
public import exception -;
public import meta m;
public import pointer::tfuncptr -;
public import GL::compat -;
public import pgl3d::geometry::funcs -;
public import pgl3d::opengl::glresource -;
public import pgl3d::opengl::glshader -;
public import pgl3d::opengl::glbuffer -;
public import pgl3d::opengl::shader_config -;
public import pgl3d::opengl::aggregated_ibuffer -;
public import pgl3d::opengl::resource_pool -;
public import pgl3d::opengl::framebuffer -;
public import pgl3d::drawer::base -;
public import pgl3d::engine::pglbase -;
public import pgl3d::engine::intern_pool -;

public struct
pglshader(shader_config const& sconf0, ptr{resource_pool} const& respool0,
  tree_map{string, ptr{pgldrawer_export_i}} const& drawers0, int width0,
  int height0)
<make_vertices_i>
{
  public shader_config const glc = sconf0;
  public ptr{resource_pool} const respool = respool0;
  public tree_map{string, size_t} drawer_names = get_drawer_names(drawers0);
  public varray{ptr{pgldrawer_i}} drawers = downcast_drawers(drawers0);
  public varray{size_t} drawers_postprocess;
  public varray{vertex_buffer_id} drawer_vbids;
  public varray{vertex_buffer_id} drawer_main_vbids;
  // public varray{size_t} vbid_to_drawer_one;
  public varray{ptr{gl_framebuffer}} sfbo_array;
  public gl_framebuffer ppfbo;
  public projection_info cam;
  public varray{ptr{vertex_buffer}} vertex_buffers;
  public aggregated_ibuffer agg_ibuffer;
  public tptr{pidf_table} const pidft = make_tptr{pidf_table}();
  private auto_vertexarray vtxarr;
  private tree_map{string, vertex_buffer_id} vertex_buffer_id_map;
  private intern_pool{vertex_buffer_pool_key} vbid_pool;
  init();
  resize_screen(width0, height0, width0, height0);
  /*
  public function vertex_buffer_id to_vbid(cstrref const& name) const {
    return vbid_pool.to_id(name);
  }
  */
  public function vertex_buffer_id intern_vbid(cstrref const& name) {
    const r = vbid_pool.intern(name);
    sdl_log("intern ", name, r);
    return r;
  }
  public function void set_vertex_buffer(vertex_buffer_id vbid,
    ptr{vertex_buffer} const& p) {
    vertex_buffers.resize(vbid + 1u,
      make_ptr{vertex_buffer}(0u, false, false));
    vertex_buffers[vbid] = p;
  }
  private function void init()
  {
    /*
    {
      int val;
      glGetIntegerv(GL_DEPTH_BITS, address(val));
      sdl_log("depth bits", val);
    }
    */
    if (m::ne{is_gl3_or_gles3, 0}) {
      vtxarr.generate();
      glBindVertexArray(vtxarr.get());
      sdl_log("glBindVertexArray", vtxarr.get());
    }
    if (m::eq{is_gles, 0}) {
      farray{float, 2} arr;
      float step;
      glGetFloatv(GL_POINT_SIZE_RANGE, arr.to_rawptr());
      glGetFloatv(GL_POINT_SIZE_GRANULARITY, address(step));
      sdl_log("GL_POINT_SIZE_RANGE", arr, step);
    }
    if (m::and{is_gl3_or_gles3, m::not{is_gles}}) {
      if (glc.enable_msaa != 0) {
	glEnable(GL_MULTISAMPLE);
      }
    }
    /*
    */
    if (m::eq{is_gles, 0}) {
      if (!glc.is_gl3_or_gles3()) {
	glEnable(GL_POINT_SPRITE);
	sdl_log("GL_POINT_SPRITE enabled");
      }
      glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
    }
    drawer_vbids.resize(drawers.size(), 0);
    drawer_main_vbids.resize(drawers.size(), 0);
    for (const i, const& pd: drawers) {
      drawer_vbids[i] = intern_vbid(pd->get_vbid_name());
      drawer_main_vbids[i] = intern_vbid(pd->get_main_vbid_name());
      size_t j = drawer_vbids[i];
      /*
      if (vbid_to_drawer_one.size() <= j) {
	vbid_to_drawer_one.resize(j + 1, 0);
      }
      vbid_to_drawer_one[j] = i;
      */
      {
	mutable& pidftv = *pidft;
	if (pidftv.size() <= j) {
	  pidftv.resize(j + 1, make_tfuncptr{prepare_instance_data_noop}());
	  pidftv[j] = pd->get_prepare_instance_data_funcptr();
	}
      }
      set_vertex_buffer(drawer_vbids[i], pd->make_vertex_buffer());
    }
    if (sfbo_array.empty()) {
      for (size_t i: 0 .. static_cast{size_t}(glc.num_shadowmaps)) {
	sfbo_array.push_back(make_ptr{gl_framebuffer}());
      }
    }
    for (const i, const& pd: drawers) {
      if (pd->has_step(draw_step_postprocess)) {
	drawers_postprocess.push_back(i);
      }
    }
  }
  public function void prepare(whole_instances_type mutable& whole_instances_r,
    node_factory mutable& nfac_r)
  {
    prepare_builtin_vertex_sets();
    prepare_vertex_buffers();
    prepare_whole_instances(whole_instances_r);
    prepare_node_factory(nfac_r);
  }
  private function void prepare_builtin_vertex_sets()
  {
    for (const i, const& pd: drawers) {
      const name = pd->builtin_vertex_set_name();
      if (name.empty()) {
	continue;
      }
      const bo_id = drawer_vbids[i];
      const vtx = make_vertices(bo_id, name);
      pd->make_builtin_vertex_sets(vtx);
    }
  }
  private function void prepare_vertex_buffers()
  {
    for (const i, const& bo: vertex_buffers) {
      bo->create_vbo();
    }
  }
  private function void prepare_whole_instances(
    whole_instances_type mutable& whole_instances) const
  {
    whole_instances.resize(vertex_buffers.size(), bo_instances_type());
    for (const i, const& bo: vertex_buffers) {
      mutable& instances = whole_instances[i];
      for (const j: 0 .. bo->vs_arr.size()) {
	instances.push_back(instance_data());
      }
    }
  }
  private function void prepare_node_factory(node_factory mutable& nf) const
  {
    for (const bo_id, const& bop: vertex_buffers) {
      for (const& n, const id: bop->vs_names) {
	if (bop->is_sub_drawer) {
	  // sub_drawer bo_id must not used for joint_id
	  continue;
	}
	joint_id_type jid;
	jid.bo_id = static_cast{bo_id_t}(bo_id);
	jid.vs_id = id;
	nf.name_to_id[n] = jid;
      }
      nf.binfo.push_back(node_buffer_info());
      node_buffer_info mutable& nbi = nf.binfo[nf.binfo.size() - 1];
      for (const i, const& vsp: bop->vs_arr) {
	nbi.vs_arr.push_back(node_vs_info());
	node_vs_info mutable& nvi = nbi.vs_arr[nbi.vs_arr.size() - 1];
	for (const j, const& nj: vsp->vtxs->joints) {
	  node_joint_info nji;
	  nji.joint_id = find_joint_id_by_name(nj.joint_name);
	  nji.trans = nj.trans;
	  nvi.joints.push_back(nji);
	}
      }
    }
  }
  public function joint_id_type find_joint_id_by_name(cstrref const& name)
    const
  {
    joint_id_type scene_id;
    for (const i, const& bo: vertex_buffers) {
      // sub-drawer bo_id must not used for joint_id
      if (!bo->is_sub_drawer && bo->has_name(name)) {
        scene_id.bo_id = static_cast{bo_id_t}(i);
        scene_id.vs_id = bo->get_id_by_name(name);
        break;
      }
    }
    return scene_id;
  }
  public function cptr{vertices} get_nonempty_vertices(cstrref const& name)
    const
  {
    joint_id_type scene_id;
    for (const i, const& bo: vertex_buffers) {
      // allow sub-drawer bo_id
      if (bo->has_name(name)) {
        scene_id.bo_id = static_cast{bo_id_t}(i);
        scene_id.vs_id = bo->get_id_by_name(name);
	if (!vertex_buffers[scene_id.bo_id]->get_vertices(scene_id.vs_id)
	    ->vertex_values.empty()) {
	  break;
	}
      }
    }
    /*
    joint_id_type jid = find_joint_id_by_name(name);
    */
    return vertex_buffers[scene_id.bo_id]
      ->get_vertices(scene_id.vs_id);
  }
  public function joint_id_type get_joint_id(cstrref const& name) const {
    return find_joint_id_by_name(name);
  }
  public function ptr{vertices} make_vertices(vertex_buffer_id bo_id,
    cstrref const& name)
  {
    return vertex_buffers[bo_id]->make_if(name)->vtxs;
  }
  public function void make_vertex_set(cslice{string} const& dr_names,
    cstrref const& shape_name, gf_poly const& expr)
  {
    // make vertex set by geometry expression
    varray{ptr{vertices}} vptrs;
    varray{dgf_filler} fillers;
    for (const i, const& dr_name: dr_names) {
      size_t dr_id = *drawer_names.equal_range(dr_name);
      const bo_id = drawer_vbids[dr_id];
      ptr{vertices} vptr = make_vertices(bo_id, shape_name);
      dgf_filler filler = drawers[dr_id]->make_filler(vptr);
      vptrs.push_back(vptr);
      fillers.push_back(filler);
    }
    ptr{build_context_i} ctx = make_ptr{build_context_impl}(vptrs, fillers);
    expr(*ctx, poly_t(), mesh_index());
  }
  public function void make_vertex_set_by_triangles(string const& dr_name,
    cstrref const& shape_name, cslice{float} const& verts, size_t nfpv,
    cslice{uint} const& elems)
  {
    size_t dr_id = *drawer_names.equal_range(dr_name);
    const bo_id = drawer_vbids[dr_id];
    ptr{vertices} vptr = make_vertices(bo_id, shape_name);
    vptr->set_triangles(verts, nfpv, elems);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    // FIXME: slow
    for (const i, const& pd: drawers) {
      const bo_id = drawer_vbids[i];
      r = pd->get_texture_info(name);
      if (r.surface_w != 0) {
	break;
      }
    }
    return r;
  }
  public function void resize_screen(int width, int height, int w_width,
    int w_height)
  {
    const default_scale = m::ne{is_gles, 0} ? 0.5f : 1.0f;
    const scale = glc.conf.get("shadowmap_resolution", default_scale,
      256.0f, 16384.0f);
    mutable wh = static_cast{int}(static_cast{float}(max(width, height))
      * scale);
    if (scale >= 512.0f) {
      wh = static_cast{int}(scale);
    }
    int sm_size = 1;
    for (int i: 8 .. 16) {
      sm_size = 1 << i;
      if (sm_size >= wh) {
	break;
      }
    }
    sdl_log("shadowmap size", sm_size, scale);
    cam.screen_width = width;
    cam.screen_height = height;
    cam.window_width = w_width;
    cam.window_height = w_height;
    cam.shadowmap_size = sm_size;
    for (size_t i: 0 .. sfbo_array.size()) {
      mutable& sfbo = *sfbo_array[i];
      if (m::ne{is_gles, 0}) {
	sfbo.width = sm_size;
	sfbo.height = sm_size;
      } else {
	sfbo.width = sm_size;
	sfbo.height = sm_size;
      }
      init_shadowmap_fbo(glc, sfbo);
    }
    for (const i, const& pd: drawers) {
      pd->resize_screen(glc, width, height);
    }
    update_mvp(glc, cam);
  }
  public function void reload_shaders()
  {
    for (const i, const& pd: drawers) {
      pd->reload_shaders();
    }
  }
}

public function varray{uint}
pglshader_draw_frame(pglshader mutable& pgs,
  whole_instances_type mutable& whole_instances, projection_info const& cam_df)
{
  const& bos = pgs.vertex_buffers;
  /* prepare instance data */
  pgs.agg_ibuffer.frame_begin(whole_instances,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  const tick1 = SDL_GetTicks();
  /* shadowmapping shader */
  darrayst{GLuint} smtex_arr = darrayst{GLuint}(pgs.sfbo_array.size(), 0U);
  for (size_t iter: 0 .. pgs.sfbo_array.size()) {
    smtex_arr[iter] = pgs.sfbo_array[iter]->texture.get();
  }
  if (pgs.glc.enable_shadowmapping) {
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    glDisable(GL_CULL_FACE);
    /*
    glEnable(GL_CULL_FACE);
    glCullFace(GL_FRONT);
    */
    glEnable(GL_DEPTH_TEST);
    glDepthMask(1);
    if (pgs.glc.enable_depth_texture) {
      glColorMask(0, 0, 0, 0);
    } else {
      glColorMask(1, 1, 1, 1);
    }
    glDepthFunc(GL_LEQUAL);
    glDisable(GL_BLEND);
    for (size_t iter: 0 .. pgs.sfbo_array.size()) {
      /* set fb */
      const& sfbo = *pgs.sfbo_array[iter];
      glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
      glViewport(0, 0, static_cast{GLsizei}(sfbo.width),
	static_cast{GLsizei}(sfbo.height));
      if (!pgs.glc.enable_depth_texture) {
	glClearColor(1.0, 1.0, 1.0, 1.0);
      }
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      /* note: view_projection is pre-applied to model_matrix */
      // FIXME: cascading
      for (const i, const& pd: pgs.drawers) {
	const bo_id = pgs.drawer_vbids[i];
	const main_bo_id = pgs.drawer_main_vbids[i];
	pd->draw(draw_step_shadowmapping, iter,
	  *bos[bo_id],
	  whole_instances[main_bo_id], pgs.agg_ibuffer,
	  bo_id, pgs.glc, cam_df, smtex_arr);
      }
      /*
      if (pgs.glc.enable_vsm) {
	// FIXME FIXME
	glActiveTexture(static_cast{GLenum}(static_cast{size_t}(GL_TEXTURE3) + iter));
	glGenerateMipmap(GL_TEXTURE_2D);
      }
      */
    }
    /* restore fb */
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
  glViewport(0, 0, static_cast{GLsizei}(pgs.cam.screen_width),
    static_cast{GLsizei}(pgs.cam.screen_height));
  int saved_fb = 0;
  if (!pgs.drawers_postprocess.empty()) {
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    glBindFramebuffer(GL_FRAMEBUFFER,
      pgs.drawers[pgs.drawers_postprocess[0]]->get_postprocess_framebuffer());
  }
  /* z-prepass shader */
  if (pgs.glc.enable_zprepass) {
    glDisable(GL_CULL_FACE);
    // glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glDepthMask(1);
    glDisable(GL_BLEND);
    glClear(GL_DEPTH_BUFFER_BIT);
    glColorMask(0, 0, 0, 0);
    for (const i, const& pd: pgs.drawers) {
      const bo_id = pgs.drawer_vbids[i];
      const main_bo_id = pgs.drawer_main_vbids[i];
      pd->draw(draw_step_zprepass, 0,
	*bos[bo_id],
	whole_instances[main_bo_id], pgs.agg_ibuffer,
	bo_id, pgs.glc, cam_df, smtex_arr);
    }
  }
  const tick2 = SDL_GetTicks();
  /* main */
  {
    glDisable(GL_BLEND);
    glEnable(GL_CULL_FACE);
    // glDisable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    if (pgs.glc.enable_zprepass) {
      // glDepthMask(0); // TODO: disable depth mask
      glColorMask(1, 1, 1, 1);
      glDepthFunc(GL_LEQUAL); // FIXME GL_EQUAL is better?
      glClearColor(0.0, 0.0, 0.0, 0.0);
      glClear(GL_COLOR_BUFFER_BIT);
    } else {
      glDepthMask(1);
      glDepthFunc(GL_LESS);
      glColorMask(1, 1, 1, 1);
      glClearColor(0.0, 0.0, 0.0, 0.0);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
    for (const i, const& pd: pgs.drawers) {
      const bo_id = pgs.drawer_vbids[i];
      const main_bo_id = pgs.drawer_main_vbids[i];
      pd->draw(draw_step_solid, 0,
	*bos[bo_id],
	whole_instances[main_bo_id], pgs.agg_ibuffer,
	bo_id, pgs.glc, cam_df, smtex_arr);
    }
  }
  /* blend */
  {
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    for (const i, const& pd: pgs.drawers) {
      const bo_id = pgs.drawer_vbids[i];
      const main_bo_id = pgs.drawer_main_vbids[i];
      pd->draw(draw_step_blend, 0,
	*bos[bo_id],
	whole_instances[main_bo_id], pgs.agg_ibuffer,
	bo_id, pgs.glc, cam_df, smtex_arr);
    }
  }
  if (!pgs.drawers_postprocess.empty()) {
    size_t n = pgs.drawers_postprocess.size();
    size_t i;
    for (i = 0; i < n; ++i) {
      uint fb = static_cast{uint}(saved_fb);
      if (i < n - 1) {
	fb = pgs.drawers[pgs.drawers_postprocess[i + 1]]
	  ->get_postprocess_framebuffer();
      }
      glBindFramebuffer(GL_FRAMEBUFFER, fb);
      const j = pgs.drawers_postprocess[i];
      const& pd = pgs.drawers[j];
      const bo_id = pgs.drawer_vbids[j];
      const main_bo_id = pgs.drawer_main_vbids[j];
      pd->draw(draw_step_postprocess, 0,
	*bos[bo_id],
	whole_instances[main_bo_id], pgs.agg_ibuffer,
	bo_id, pgs.glc, cam_df, smtex_arr);
    }
  }
  pgs.agg_ibuffer.frame_end(pgs.glc.enable_instanced,
    pgs.glc.enable_uniform_instancing);
  return make_varray{uint}(tick1, tick2);
}

/* private */

private function tree_map{string, size_t}
get_drawer_names(tree_map{string, ptr{pgldrawer_export_i}} const& drawers)
{
  size_t i = 0;
  tree_map{string, size_t} r;
  for (const& k, const& e: drawers) {
    r[k] = i;
    ++i;
  }
  return r;
}

private function varray{ptr{pgldrawer_i}}
downcast_drawers(tree_map{string, ptr{pgldrawer_export_i}} const& drawers)
{
  varray{ptr{pgldrawer_i}} r;
  for (const& k, const& e: drawers) {
    r.push_back(pointer_downcast{ptr{pgldrawer_i}}(e));
  }
  return r;
}

private threaded struct
build_context_impl(varray{ptr{vertices}} mutable& vptrs0,
  varray{dgf_filler} mutable& fillers0)
  <build_context_i>
{
  public varray{ptr{vertices}} vptrs;
  public varray{dgf_filler} fillers;
  vptrs.swap(vptrs0);
  fillers.swap(fillers0);
  function void fill(bool flat_flag, bool polyjoint, size_t n,
    string const& joint_name, poly_t const& poly, mesh_index const& mp) const
  {
    if (joint_name.empty()) {
      fillers[n](flat_flag, poly, mp);
    } else if (polyjoint) {
      dgf_poly_joint_internal(vptrs[0], joint_name, poly, mp);
    } else {
      dgf_point_joint_internal(vptrs[0], joint_name, poly, mp);
    }
  }
}

private threaded function void
dgf_poly_joint_internal(ptr{vertices} const& vptr, string const& joint_name,
  poly_t const& poly, mesh_index const& mp)
{
  // calculates normal/tangent from poly
  if (poly.size() < 1) { return; }
  node_joint e;
  e.trans = poly_trans(poly);
  e.joint_name = joint_name;
  vptr->push_joint(e);
}

private threaded function void
dgf_point_joint_internal(ptr{vertices} const& vptr, string const& joint_name,
  poly_t const& poly, mesh_index const& mp)
{
  if (poly.size() < 1) { return; }
  const p = poly[0].pos;
  const ex = poly[0].nor.normalize();
  const ey = poly[0].tan.normalize();
  const ez = glm::cross(ex, ey);
  node_joint e;
  e.trans = glm::make_mat4(
    ex.x, ex.y, ex.z,  0.0,
    ey.x, ey.y, ey.z,  0.0,
    ez.x, ez.y, ez.z,  0.0,
     p.x,  p.y,  p.z,  1.0);
  e.joint_name = joint_name;
  vptr->push_joint(e);
}

function void
update_mvp(shader_config const& glc, projection_info mutable& cam)
{
  float const perspective_near =
    glc.conf.get("perspective_near", 1.0f, 0.001f, 100.0f);
  float const perspective_far =
    glc.conf.get("perspective_far", 10000.0f, 10.0f, 1000000.0f);
  float const perspective_wh =
    glc.conf.get("perspective_wh", 1.0f, 0.001f, 100.0f);
  const ssbase = max(cam.screen_height, cam.screen_width);
  const h = perspective_wh * cast_float(cam.screen_height)
    / cast_float(ssbase);
  const w = perspective_wh * cast_float(cam.screen_width)
    / cast_float(ssbase);
  glViewport(0, 0, static_cast{GLsizei}(cam.screen_width),
    static_cast{GLsizei}(cam.screen_height));
  glDepthMask(1);
  glColorMask(1, 1, 1, 1);
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  {
    // camera projection
    const near = perspective_near;
    const far = perspective_far;
    const left = cast_float(-w);
    const right = cast_float(w);
    const bottom = cast_float(-h);
    const top = cast_float(h);
    cam.camera_pers.near = near;
    cam.camera_pers.far = far;
    cam.camera_pers.width = w;
    cam.camera_pers.height = h;
    cam.projection = glm::frustum{float}(left, right, bottom, top, near, far);
  }
  {
    // shadowmap projection
    const sm_w = 1.0f;
    const sm_h = 1.0f;
    function void set_sm(glm::mat4 mutable& dst, float far)
    {
      const near = -far;
      const left = -far;
      const right = far;
      const bottom = -far;
      const top = far;
      dst = glm::ortho{float}(left, right, bottom, top, near, far);
    }
    float far = glc.shadowmap_distance;
    for (const i: 0 .. static_cast{size_t}(glc.num_shadowmaps)) {
      set_sm(cam.sm_projection[i], far);
      far *= glc.shadowmap_scale;
    }
    // debug_log("smp0", cam.sm_projection[0].to_cslice());
    // debug_log("smp1", cam.sm_projection[1].to_cslice());
  }
}

