public threaded namespace pgl3d::texture::texture "use-unsafe";
public import common -;
public import pointer::raw -;
private import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import text::serialize::compact_pod -;
public import glm;
private import glm::raw;
public import io::time -;
public import exception -;
public import meta m;
public import pointer::tfuncptr -;
public import pgl3d::engine::util -;
public import pgl3d::sdl::sdlutil -;
private import SDL2::api_base -;
private import SDL2::api_types -;
private import SDL2::api_functions -;
private import SDL2::api_wrappers -;
private import SDL2::misc -;

public tsvaluetype struct {t} array3_pot()
{
  public metafunction mapped_type m::symbol{t, "mapped_type"};
  public function void set_size_l2(uint w_l2, uint h_l2, uint d_l2) {
    data.resize(0u, mapped_type());
    width_l2 = w_l2;
    height_l2 = h_l2;
    depth_l2 = d_l2;
    size_t sz = static_cast{size_t}(1u) << (width_l2 + height_l2 + depth_l2);
    data.resize(sz, mapped_type());
  }
  public function uint get_width_l2() const { return width_l2; }
  public function uint get_height_l2() const { return height_l2; }
  public function uint get_depth_l2() const { return depth_l2; }
  public function uint get_width() const { return 1u << width_l2; }
  public function uint get_height() const { return 1u << height_l2; }
  public function uint get_depth() const { return 1u << depth_l2; }
  public function uint index(uint x, uint y, uint z) const {
    return (z << (width_l2 + height_l2)) | (y << width_l2) | x;
  }
  public function uint size() const {
    return 1u << (width_l2 + height_l2 + depth_l2);
  }
  public function void set(uint x, uint y, uint z, mapped_type v) {
    data[index(x, y, z)] = v;
  }
  public function mapped_type get(uint x, uint y, uint z) const {
    return data[index(x, y, z)];
  }
  public function void set_index(uint i, mapped_type v) {
    data[i] = v;
  }
  public function mapped_type get_index(uint i) {
    return data[i];
  }
  public function {tpl} void
  append_to_string(m::find{tpl, "ser_target_type", 0} mutable& s) const
  {
    serialize_sequence{tpl}(width_l2, height_l2, depth_l2, data, s);
  }
  public function {tpl} void
  parse_from_string(m::find{tpl, "des_source_type", 0} mutable& s) {
    deserialize_sequence{tpl}(s, width_l2, height_l2, depth_l2, data);
  }
  public function crawptr{mapped_type} get_crawptr() const {
    if (m::or{m::symbol_exists{t, "to_crawptr"},
      m::symbol_exists{m::nsof{t}, m::concat{t, "_to_crawptr"}}}) {
      return data.to_crawptr();
    } else {
      return crawptr{mapped_type}();
    }
  }
  public function rawptr{mapped_type} get_rawptr() {
    if (m::or{m::symbol_exists{t, "to_rawptr"},
      m::symbol_exists{m::nsof{t}, m::concat{t, "_to_rawptr"}}}) {
      return data.to_rawptr();
    } else {
      return rawptr{mapped_type}();
    }
  }
  private uint width_l2;
  private uint height_l2;
  private uint depth_l2;
  private t data;
}

public metafunction texture_data array3_pot{varray{uint}};

public function ptr{texture_data}
load_texture_data_raw(string const& fn0)
{
  const p = make_ptr{texture_data}();
  string buf;
  sdl_load_file(fn0, buf);
  *p = from_string_compact_pod{texture_data}(buf);
  return p;
}

public function bool
save_texture_data_raw(string const& fn0, texture_data const& td)
{
  const buf = to_string_compact_pod(td);
  return sdl_save_file(fn0, buf);
}

public function varray{ptr{texture_data}}
load_texture_data_array_raw(string const& fn0)
{
  string buf;
  sdl_load_file(fn0, buf);
  return from_string_compact_pod{varray{ptr{texture_data}}}(buf);
}

public function bool
save_texture_data_array_raw(string const& fn0,
  varray{ptr{texture_data}} const& tds)
{
  const buf = to_string_compact_pod(tds);
  return sdl_save_file(fn0, buf);
}

public function ptr{texture_data}
load_texture_data(string const& fn0)
{
  debug_log("load_texture_data", fn0);
  const p = make_ptr{texture_data}();
  string fn = fn0;
  fn.push_back(0);
  SDL_Surface_Scoped sur0;
  sur0.reset(IMG_Load(fn.to_crawptr().to_ccharptr()));
  if (sur0.get() == rawptr{SDL_Surface}()) {
    sdl_log("failed to load", fn);
    throw runtime_error_template{"img_load"}(fn0);
  }
  sdl_log("loading image: loaded", fn);
  debug_log("load_texture_data p0");
  const& sur0ref = *sur0.get().to_slice(1);
  const fmtp = sur0ref.format;
  const& fmt = *sur0ref.format.to_slice(1);
  const bpp = fmt.BytesPerPixel;
  if (bpp != 4 && bpp != 3) {
    throw runtime_error_template{"img_load"}("bpp");
  }
  debug_log("load_texture_data p1");
  const sur0_w = static_cast{uint}(sur0ref.w);
  const sur0_h = static_cast{uint}(sur0ref.h);
  debug_log("load_texture_data p2", sur0_w, sur0_h);
  mutable tex_w = power_of_2(sur0_w);
  mutable tex_h = power_of_2(sur0_h);
  p->set_size_l2(integral_log2(tex_w), integral_log2(tex_h), 0);
  mutable& buf = *p;
  uint rmask = fmt.Rmask;
  uint gmask = fmt.Gmask;
  uint bmask = fmt.Bmask;
  uint amask = fmt.Amask;
  function uint get_shift(uint m) {
    uint r = 0;
    for (uint i: 0 .. 32) {
      if ((m & 1) != 0) {
	break;
      }
      r += 1;
      m >>= 1;
    }
    return r;
  }
  uint rshift = get_shift(rmask);
  uint gshift = get_shift(gmask);
  uint bshift = get_shift(bmask);
  uint ashift = get_shift(amask);
  const& sur0_ref = *sur0.get().to_slice(1);
  const sur0buf = sur0_ref.pixels.reinterpret_cast{uchar}()
    .to_slice(static_cast{size_t}(sur0_ref.pitch * sur0_ref.h));
  debug_log("load_texture_data p3", sur0_w, sur0_h);
  for (const y: 0 .. sur0_h) {
    for (const x: 0 .. sur0_w) {
      const o = (y * sur0_w + x) * bpp;
      // debug_log("load_texture_data p4r", x, y, o);
      uint v;
      uint vr;
      uint vg;
      uint vb;
      uint va;
      if (bpp == 3) {
	v = read_3_uint(sur0buf, o);
      } else if (bpp == 4) {
	v = read_4_uint(sur0buf, o);
      }
      // debug_log("load_texture_data p5r", v);
      // debug_log("load_texture_data p5r00", v);
      // debug_log("load_texture_data p5r0", rshift, gshift, bshift);
      // debug_log("load_texture_data p5r030", (v >> 16));
      // debug_log("load_texture_data p5r031", (v >> 8));
      // debug_log("load_texture_data p5r032", (v >> 0));
      // debug_log("load_texture_data p5r03", (v >> bshift));
      vb = (v >> bshift) & 0xffU;
      // debug_log("load_texture_data p5r02", vb);
      vg = (v >> gshift) & 0xffU;
      // debug_log("load_texture_data p5r02", vg);
      vr = (v >> rshift) & 0xffU;
      // debug_log("load_texture_data p5r02", vr);
      // debug_log("load_texture_data p5r1", vr, vg, vb);
      if (bpp == 4) {
	va = (v >> ashift) & 0xffU;
      }
      // debug_log("load_texture_data p5r2", va);
      uint v1 = (va << 24) | (vb << 16) | (vg << 8) | (vr << 0);
      // debug_log("load_texture_data p5r3", v1);
      // debug_log("load_texture_data p7r", x, y, tex_w, x * tex_w + x);
      buf.set(x, y, 0, v1);
      // debug_log("load_texture_data p6r", y * tex_w + x, v1);
    }
  }
  debug_log("load_texture_data done", fn0);
  return p;
}

metafunction SDL_Surface_Scoped scoped_nullable{SDL_FreeSurface};

