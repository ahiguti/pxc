public threaded namespace pgl3d::texture::voxel_surface;
public import common -;
public import exception -;
public import pointer::tfuncptr -;
public import meta m;
public import pgl3d::engine::util -;
public import pgl3d::texture::voxel_octree -;
public import pgl3d::texture::texture -;
public import glm -;

public multithreaded struct bitarray3
{
  public uint w_l2;
  public uint h_l2;
  public uint d_l2;
  public bit_varray data;
  // public varray{uchar} data;
  public function uint index(uint x, uint y, uint z) const {
    return (z << (w_l2 + h_l2)) | (y << w_l2) | x;
  }
  public function void set(uint x, uint y, uint z, bool v) {
    // data[index(x, y, z)] = static_cast{uchar}(v ? 1u : 0u);
    data[index(x, y, z)] = v;
  }
  public function bool get(uint x, uint y, uint z) const {
    // return data[index(x, y, z)] != 0;
    return data[index(x, y, z)];
  }
}

public threaded function {f} bitarray3
bitarray3_resize(bitarray3 const& arr)
{
  bitarray3 rarr;
  rarr.w_l2 = arr.w_l2 - 1;
  rarr.h_l2 = arr.h_l2 - 1;
  rarr.d_l2 = arr.d_l2 - 1;
  rarr.data.resize(
    static_cast{size_t}(1u) << (rarr.w_l2 + rarr.h_l2 + rarr.d_l2), false);
  for (const x: 0 .. (1u << rarr.w_l2)) {
    for (const y: 0 .. (1u << rarr.h_l2)) {
      for (const z: 0 .. (1u << rarr.d_l2)) {
	const x2 = x * 2u;
	const y2 = y * 2u;
	const z2 = z * 2u;
	const val =
	  f(
	    f(f(arr.get(x2 + 0, y2 + 0, z2 + 0),
	        arr.get(x2 + 1, y2 + 0, z2 + 0)),
	      f(arr.get(x2 + 0, y2 + 1, z2 + 0),
		arr.get(x2 + 1, y2 + 1, z2 + 0))),
	    f(f(arr.get(x2 + 0, y2 + 0, z2 + 1),
		arr.get(x2 + 1, y2 + 0, z2 + 1)),
	      f(arr.get(x2 + 0, y2 + 1, z2 + 1),
		arr.get(x2 + 1, y2 + 1, z2 + 1))));
	rarr.set(x, y, z, val);
      }
    }
  }
  return rarr;
}

threaded function void
bitarray3_fill(bitarray3 mutable& arr, uint x, uint y, uint z, uint size_l2,
  bool v)
{
  uint const sz = 1u << size_l2;
  for (uint ix: 0 .. sz) {
    for (uint iy: 0 .. sz) {
      for (uint iz: 0 .. sz) {
	arr.set(x + ix, y + iy, z + iz, v);
      }
    }
  }
}

/*
threaded struct octree_info(cptr{texture_data} const& tex0)
{
  public uint const bshift = tex0->bshift;
  public uint const w_l2 = integral_log2(tex0->width);
  public uint const h_l2 = integral_log2(tex0->height);
  public uint const d_l2 = integral_log2(tex0->depth);
  public cptr{texture_data} const tex = tex0;
  public function uint get(uint x, uint y, uint z) const {
    return tex->data[(z << (w_l2 + h_l2)) | (y << w_l2) | x];
  }
}
*/

public threaded function bitarray3
octree_external(cptr{texture_data} const& tex, uint reclevel)
{
  /*
  octree_info const oi = octree_info(tex);
  */
  uint const size_l2 = reclevel * tex->bshift;
  bitarray3 arr;
  arr.w_l2 = size_l2;
  arr.h_l2 = size_l2;
  arr.d_l2 = size_l2;
  arr.data.resize(static_cast{size_t}(1u) << (size_l2 * 3u), false);
  octree_external_rec(*tex, arr, 0, 0, 0, 0, 0, 0, size_l2 - tex->bshift);
  return arr;
}

threaded function void
octree_external_rec(texture_data const& tex, bitarray3 mutable& arr, uint nx,
  uint ny, uint nz, uint bwx, uint bwy, uint bwz, uint fill_size_l2)
{
  const bshift = tex.bshift;
  const bsz = 1u << bshift;
  const bmask = bsz - 1;
  for (const i: 0 .. bsz * bsz * bsz) {
    const ix = (i >> (bshift * 0)) & bmask;
    const iy = (i >> (bshift * 1)) & bmask;
    const iz = (i >> (bshift * 2)) & bmask;
    const e = tex.get((nx << bshift) + ix, (ny << bshift) + iy,
      (nz << bshift) + iz);
    const wx = (ix << fill_size_l2) + bwx;
    const wy = (iy << fill_size_l2) + bwy;
    const wz = (iz << fill_size_l2) + bwz;
    if (fill_size_l2 == 0) {
      // debug_log("oer", wx, wy, wz, !is_space_voxel(e));
      arr.set(wx, wy, wz, !is_space_voxel(e));
    } else if (!is_node_reference(e)) {
      bitarray3_fill(arr, wx, wy, wz, fill_size_l2, !is_space_voxel(e));
    } else {
      const nref = get_node_reference(e);
      const cnx = (nref & 0xffu);
      const cny = ((nref >> 8u) & 0xffu);
      const cnz = ((nref >> 16u) & 0xffu);
      octree_external_rec(tex, arr, cnx, cny, cnz, wx, wy, wz,
	fill_size_l2 - bshift);
    }
  }
}

public threaded function bitarray3
octree_internal(cptr{texture_data} const& tex, uint reclevel)
{
  /*
  octree_info const oi = octree_info(tex);
  */
  uint const size_l2 = reclevel * tex->bshift;
  bitarray3 arr;
  arr.w_l2 = size_l2;
  arr.h_l2 = size_l2;
  arr.d_l2 = size_l2;
  arr.data.resize(static_cast{size_t}(1u) << (size_l2 * 3u), false);
  octree_internal_rec(*tex, arr, 0, 0, 0, 0, 0, 0, size_l2 - tex->bshift);
  return arr;
}

threaded function void
octree_internal_rec(texture_data const& tex, bitarray3 mutable& arr, uint nx,
  uint ny, uint nz, uint bwx, uint bwy, uint bwz, uint fill_size_l2)
{
  const bshift = tex.bshift;
  const bsz = 1u << bshift;
  const bmask = bsz - 1;
  for (const i: 0 .. bsz * bsz * bsz) {
    const ix = (i >> (bshift * 0)) & bmask;
    const iy = (i >> (bshift * 1)) & bmask;
    const iz = (i >> (bshift * 2)) & bmask;
    const e = tex.get((nx << bshift) + ix, (ny << bshift) + iy,
      (nz << bshift) + iz);
    const wx = (ix << fill_size_l2) + bwx;
    const wy = (iy << fill_size_l2) + bwy;
    const wz = (iz << fill_size_l2) + bwz;
    if (fill_size_l2 == 0) {
      // debug_log("oer", wx, wy, wz, !is_space_voxel(e));
      arr.set(wx, wy, wz, is_filled(e));
    } else if (!is_node_reference(e)) {
      bitarray3_fill(arr, wx, wy, wz, fill_size_l2, is_filled(e));
    } else {
      const nref = get_node_reference(e);
      const cnx = (nref & 0xffu);
      const cny = ((nref >> 8u) & 0xffu);
      const cnz = ((nref >> 16u) & 0xffu);
      octree_internal_rec(tex, arr, cnx, cny, cnz, wx, wy, wz,
	fill_size_l2 - bshift);
    }
  }
}

public threaded function varray{varray{vec3}}
get_surface_quads(bitarray3 const& ba)
{
  varray{varray{vec3}} quads;
  // not optimal
  get_surface_quads_one_dir(ba, quads, 0, false);
  get_surface_quads_one_dir(ba, quads, 1, false);
  get_surface_quads_one_dir(ba, quads, -1, false);
  get_surface_quads_one_dir(ba, quads, 0, true);
  get_surface_quads_one_dir(ba, quads, 1, true);
  get_surface_quads_one_dir(ba, quads, -1, true);
  return quads;
}

threaded function void
get_surface_quads_one_dir(bitarray3 const& ba,
  varray{varray{vec3}} mutable& quads, int axis, bool back)
{
  // axis==1のとき変数xyzはbaのzxy, axis=-1のとき変数xyzはbaのyxz
  threaded function {t} void
  rotate_axis(t mutable& x, t mutable& y, t mutable& z)
  {
    if (axis == 1) {
      const v = x;
      x = y;
      y = z;
      z = v;
    } else if (axis == -1) {
      const v = z;
      z = y;
      y = x;
      x = v;
    }
  }
  uint xmax = 1u << ba.w_l2;
  uint ymax = 1u << ba.h_l2;
  uint zmax = 1u << ba.d_l2;
  rotate_axis(zmax, ymax, xmax); // baの軸から変数の軸への変換なのでzyxの順
  threaded function bool
  voxel_get(uint x, uint y, uint z)
  {
    if (back) {
      z = zmax - z - 1;
    }
    rotate_axis(x, y, z); // 変数の軸からbaの軸へ変換
    return ba.get(x, y, z);
  }
  threaded function vec3
  to_vec3(uint x, uint y, uint z)
  {
    mutable xf = static_cast{float}(x) / static_cast{float}(xmax);
    mutable yf = static_cast{float}(y) / static_cast{float}(ymax);
    mutable zf = static_cast{float}(z) / static_cast{float}(zmax);
    // zf += 0.000001f;
    if (back) {
      zf = 1.0f - zf;
    }
    rotate_axis(xf, yf, zf); // 変数の軸からbaの軸へ変換
    return make_vec3(xf, yf, zf);
  }
  for (const z: 0 .. zmax) {
    bit_varray bm;
    bm.resize(xmax * ymax, false);
    for (const x: 0 .. xmax) {
      for (const y: 0 .. ymax) {
	const v0 = (z == 0) ? false : voxel_get(x, y, z - 1);
	const v1 = voxel_get(x, y, z);
	bm[x + xmax * y] = (!v0) && v1;
      }
    }
    for (const x0: 0 .. xmax) {
      for (const y0: 0 .. ymax) {
	if (!bm[x0 + xmax * y0]) {
	  continue;
	}
	uint x1;
	uint y1;
	for (x1 = x0 + 1; x1 < xmax; ++x1) {
	  if (!bm[x1 + xmax * y0]) {
	    break;
	  }
	}
	bool done = false;
	for (y1 = y0 + 1; y1 < ymax; ++y1) {
	  for (const xi: x0 .. x1) {
	    if (!bm[xi + xmax * y1]) {
	      done = true;
	      break;
	    }
	  }
	  if (done) {
	    break;
	  }
	}
	for (const xi: x0 .. x1) {
	  for (const yi: y0 .. y1) {
	    bm[xi + xmax * yi] = false;
	  }
	}
	mutable x0f = static_cast{float}(x0);
	mutable y0f = static_cast{float}(y0);
	mutable x1f = static_cast{float}(x1);
	mutable y1f = static_cast{float}(y1);
	mutable zf = static_cast{float}(z);
	if (back) {
	  quads.push_back(make_varray{vec3}(
	    to_vec3(x0, y0, z),
	    to_vec3(x1, y0, z),
	    to_vec3(x1, y1, z),
	    to_vec3(x0, y1, z)));
	} else {
	  quads.push_back(make_varray{vec3}(
	    to_vec3(x0, y1, z),
	    to_vec3(x1, y1, z),
	    to_vec3(x1, y0, z),
	    to_vec3(x0, y0, z)));
	}
      }
    }
  }
}

