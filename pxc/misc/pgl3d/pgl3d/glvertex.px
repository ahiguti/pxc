public threaded namespace pgl3d::glvertex "use-unsafe";
public import common -;
private import pointer::raw -;
private import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
// public import GL::compat -;
public import io::time -;
public import meta m;
public import exception -;
public import pgl3d::glconf -;

public metafunction num_float_struct{t}
  m::fold{m::map{m::field_types{t}, num_float_fld}, m::add, 0};

public metafunction num_float_fld{t}
  m::cond{
    m::eq{t, float}, 1,
    m::eq{t, int}, 1,
    m::eq{t, unit}, 0,
    m::eq{t, glm::vec2}, 2,
    m::eq{t, glm::vec3}, 3,
    m::eq{t, glm::vec4}, 4,
    m::eq{t, glm::mat2}, 4,
    m::eq{t, glm::mat3}, 9,
    m::eq{t, glm::mat4}, 16,
    m::error{"invalid type"}};

public metafunction num_attrib_fld{t}
  m::cond{
    m::eq{t, float}, 1,
    m::eq{t, int}, 1,
    m::eq{t, unit}, 0,
    m::eq{t, glm::vec2}, 1,
    m::eq{t, glm::vec3}, 1,
    m::eq{t, glm::vec4}, 1,
    m::eq{t, glm::mat2}, 2,
    m::eq{t, glm::mat3}, 3,
    m::eq{t, glm::mat4}, 4,
    m::error{"invalid type"}};

public multithreaded struct node_joint()
{
  public string joint_name;
  public glm::mat4 trans; /* or quat and vec3 ? */
}

private threaded function void
float_slice_set_int(slice{float} const& s, int v)
{
  if (s.size() < 1) {
    return;
  }
  const si = size_t_to_rawptr{int}(slice_to_rawptr(s).to_size_t()).to_slice(1);
  si[0] = v;
}

private threaded function {t} void
push_float(varray{float} mutable& arr, t const& v)
{
  if (m::eq{t, float}) {
    arr.push_back(v);
  } else if (m::eq{t, int}) {
    arr.push_back(0.0f);
    float_slice_set_int(arr[arr.size() - 1 .. arr.size()], v);
  } else {
    expand (fld: m::field_names{t}) {
      push_float(arr, v.fld);
    }
  }
}

public multithreaded struct
vertices(size_t num_float_per_vertex0)
{
  public size_t const num_float_per_vertex = num_float_per_vertex0;
  public varray{float} vertex_values; /* for glDrawElements */
  public varray{uint} elements;       /* for glDrawElements */
  public varray{float} positions;     /* used for physics engine */
  public varray{node_joint} joints;
  public size_t num_copies_hint = 1;
  public bool has_instance_id;
  public size_t num_copies = 1;
  public size_t vertex_values_size_per_copy;
  public size_t elements_size_per_copy;
  public function void prepare_multiple_copies(bool enable_copying_instancing)
  {
    vertex_values_size_per_copy = vertex_values.size();
    elements_size_per_copy = elements.size();
    num_copies = 1;
    if (!has_instance_id || !use_copying_instancing ||
	!enable_copying_instancing) {
      return;
    }
    num_copies = min(num_copies_hint, uniform_instancing_mul);
    sdllog("vertices::prepare_multiple_copies", num_copies);
    const num_vertices = vertex_values.size() / num_float_per_vertex;
    vertex_values.resize(vertex_values_size_per_copy * num_copies, float());
    elements.resize(elements_size_per_copy * num_copies, uint());
    for (const i: 1 .. num_copies) {
      const vi = vertex_values_size_per_copy * i;
      const ei = elements_size_per_copy * i;
      for (const j: 0 .. vertex_values_size_per_copy) {
	vertex_values[vi + j] = vertex_values[j];
      }
      for (const j: 0 .. num_vertices) {
	/* set instance_id */
	/* instance_id must be the first field of tattr */
	vertex_values[vi + j * num_float_per_vertex] = static_cast{float}(i);
	/*
	const k = vi + j * num_float_per_vertex;
	float_slice_set_int(vertex_values[k .. k + 1], static_cast{int}(i));
	*/
      }
      for (const j: 0 .. elements_size_per_copy) {
	mutable e = elements[j];
	if (e != 0xffffffffU) {
	  e += static_cast{uint}(num_vertices * i);
	}
	elements[ei + j] = e;
      }
    }
  }
  public function {tattr, split_convex} void
  push_polygon_distinct(cslice{tattr} const& vals)
  {
    /* tattr must have 'public glm::vec3 position' */
    if (num_float_per_vertex != num_float_struct{tattr}) {
      throw runtime_error_template{"vertices::push_polygon_distinct"}(
	  string_join{" "}(m::to_string{tattr}, num_float_struct{tattr},
	    num_float_per_vertex));
    }
    if (m::eq{m::at0{m::field_names{tattr}}, "instance_id"}) {
      //sdllog("has_instance_id true", m::to_string{tattr});
      has_instance_id = true;
    } else {
      //sdllog("has_instance_id false", m::to_string{tattr},
      //  m::to_string{m::at0{m::field_names{tattr}}});
    }
    /* no dedup */
    const first_id = vertex_values.size() / num_float_struct{tattr};
    for (const i, const& val: vals) {
      push_float{tattr}(vertex_values, val);
      if (m::symbol_exists{tattr, "position"}) {
	positions.append(val.position.to_cslice());
      }
    }
    threaded function void push_convex()
    {
      if (m::ne{use_primitive_restart, 0}) {
	elements.push_back(0xffffffffU);
	for (const i, const& val: vals) {
	  elements.push_back(static_cast{uint}(first_id + i));
	}
      } else {
	for (const i: 0 .. vals.size() - 2) {
	  elements.push_back(static_cast{uint}(first_id));
	  elements.push_back(static_cast{uint}(first_id + i + 1));
	  elements.push_back(static_cast{uint}(first_id + i + 2));
	}
      }
    }
    if (m::eq{split_convex, 0}) {
      push_convex();
    } else {
      /* polygon triangulation */
      /* TODO: optimize for use_primitive_restart and convex polygons */
      varray{size_t} ia;
      ia.resize(vals.size(), 0u);
      for (const i, mutable& v: ia) {
	v = i;
      }
      threaded function glm::vec3 ia_pos(size_t i) {
	return vals[ia[i]].position;
      }
      threaded function size_t ia_prev(size_t i) {
	return (i == 0) ? (ia.size() - 1) : (i - 1);
      }
      threaded function size_t ia_next(size_t i) {
	return (i != ia.size() - 1) ? (i + 1) : 0u;
      }
      threaded function glm::vec3 cross_one(size_t i)
      {
	/* TODO: optimize */
	return glm::cross(
	  ia_pos(i) - ia_pos(ia_prev(i)),
	  ia_pos(ia_next(i)) - ia_pos(i));
      }
      glm::vec3 cross_sum;
      for (const i: 0 .. ia.size()) {
	cross_sum += cross_one(i);
      }
      while (ia.size() >= 3) {
	size_t i = ia.size() - 1;
	while (true) {
	  threaded function bool removable() {
	    const ci = cross_one(i);
	    if (m::nonzero{debug_triangulation}) {
	      if (vals.size() >= 5) {
		sdllog("dir", ia.size(), i, glm::dot(cross_sum, ci));
	      }
	    }
	    if (glm::dot(cross_sum, ci) <= -0.000001f) {
	      return false;
	    }
	    size_t j;
	    for (j = ia_next(ia_next(i)); j != ia_prev(i); j = ia_next(j)) {
	      const c0 = glm::cross(
		ia_pos(i) - ia_pos(ia_prev(i)),
		ia_pos(j) - ia_pos(i));
	      const c1 = glm::cross(
		ia_pos(ia_next(i)) - ia_pos(i),
		ia_pos(j) - ia_pos(ia_next(i)));
	      const c2 = glm::cross(
		ia_pos(ia_prev(i)) - ia_pos(ia_next(i)),
		ia_pos(j) - ia_pos(ia_prev(i)));
	      const s0 = glm::dot(c0, c1);
	      const s1 = glm::dot(c0, c2);

	      if (s0 > 0.0f && s1 > 0.0f) {
		if (m::nonzero{debug_triangulation}) {
		  if (vals.size() >= 5)
		  {
		    sdllog("posi012", ia_pos(ia_prev(i)), ia_pos(i),
			ia_pos(ia_next(i)));
		    sdllog("posj", ia_pos(j));
		    sdllog("s0s1", ia.size(), i, j, s0, s1);
		  }
		}
		return false;
	      }
	      /*
	      if (glm::dot(ci, c0) > 0.0f && glm::dot(ci, c1) > 0.0f &&
		glm::dot(ci, c2) > 0.0f) {
		return false;
	      }
	      */
	    }
	    return true;
	  }
	  threaded function void push_one()
	  {
	    if (m::ne{use_primitive_restart, 0}) {
	      elements.push_back(0xffffffffU);
	    }
	    elements.push_back(static_cast{uint}(first_id + ia[ia_prev(i)]));
	    elements.push_back(static_cast{uint}(first_id + ia[i]));
	    elements.push_back(static_cast{uint}(first_id + ia[ia_next(i)]));
	  }
	  if (removable()) {
	    push_one();
	    ia.erase(i, i + 1);
	    break;
	  }
	  if (i == 0) {
	    sdllog("warning: split_convex failed", ia.size(), vals.size(),
	      vals, ia);
	    i = ia.size() - 1;
	    push_one();
	    ia.erase(i, i + 1);
	  }
	  --i;
	}
      }
    }
  }
  public function {tattr} void push_point(tattr const& val)
  {
    if (num_float_per_vertex != num_float_struct{tattr}) {
      throw runtime_error_template{"vertices::push_point"}("");
    }
    //sdllog("push_point0", vertex_values.size());
    const first_id = vertex_values.size() / num_float_struct{tattr};
    push_float{tattr}(vertex_values, val);
    //sdllog("push_point1", vertex_values.size());
    //sdllog("push_point val", val);
    elements.push_back(static_cast{uint}(first_id));
    if (m::symbol_exists{tattr, "position"}) {
      positions.append(val.position.to_cslice());
    }
  }
  public function void push_joint(node_joint const& e)
  {
    joints.push_back(e);
  }
}

