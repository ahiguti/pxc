private threaded namespace pgl3d::drawer::skybox "export-unsafe";
public import common -;
public import pgl3d::drawer::internal -;
public import meta m;

private tsvaluetype struct skybox_vertex_attributes()
{
  public glm::vec2 vert;
}

private tsvaluetype struct skybox_instance_attributes()
{
  public glm::vec4 idata; // x0, y0, dx, dy
}

private tsvaluetype struct skybox_uniforms()
{
  public glm::mat4 projection_inv;
  public glm::mat3 camera_dir_matrix;
  public glm::vec3 light_dir;
  public int sampler_cube;
  // public int sampler_2dtex; // FIXME
}

public struct drawer_skybox(shader_config const& glc,
  resource_pool_ptr const& res0)
<pgldrawer_i>
{
  metafunction tattr skybox_vertex_attributes;
  ptr{resource_pool} res = pointer_downcast{ptr{resource_pool}}(res0);
  skybox_shader_ptr sdr_sb = init_skybox_shader(glc);
  ptr{gl_texture} texture_cube = make_ptr{gl_texture}();
  // gl_texture texture_2dtex; // FIXME
  init();
  private function void init()
  {
    /*
    const fnames = make_farray{string}(
      "cube0.png", "cube0.png", "cube0.png",
      "cube0.png", "cube0.png", "cube0.png");
      */
    const fnames = make_farray{string}(
      "cube_right1.png",
      "cube_left2.png",
      "cube_top3.png",
      "cube_bottom4.png",
      "cube_front5.png",
      "cube_back6.png");
    load_cube_texture(*texture_cube, fnames);
    res->textures.insert("environ", texture_cube);
    // load_2d_texture(texture_2dtex, "cube0.png"); // FIXME
  }
  public function string get_vbid_name() const { return "vbid_skybox"; }
  public function string get_main_vbid_name() const { return "vbid_skybox"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_skybox}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, false);
  }
  public function string builtin_vertex_set_name() const { return "skybox"; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const
  {
    farray{skybox_vertex_attributes, 4} vs;
    vs[0].vert = glm::make_vec2(-1.0, -1.0);
    vs[1].vert = glm::make_vec2(1.0, -1.0);
    vs[2].vert = glm::make_vec2(1.0, 1.0);
    vs[3].vert = glm::make_vec2(-1.0, 1.0);
    vptr->push_polygon_distinct{skybox_vertex_attributes, 0}(vs);
  }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (step == draw_step_solid) {
/*
const pinv = cam_df.projection.inverse();
const center = glm::make_vec4(0.0f, 0.0f, 1.0f, 1.0f);
const center_unproj = pinv * center;
const cam_angle = cam_df.camera.angle.to_mat3();
const eye = cam_angle * glm::make_vec3(center_unproj.x, center_unproj.y, center_unproj.z);
debug_log("center_unproj", center_unproj);
debug_log("eye", eye);
*/
/*
const sbpos = cam_df.projection * glm::make_vec4(0.0f, 0.0f, 10000.0f, 1.0f);
debug_log("sbpos", sbpos / sbpos.w);
debug_log("far,near", cam_df.camera_pers.far, cam_df.camera_pers.near);
*/
      glDepthMask(0);
      // glEnable(GL_TEXTURE_CUBE_MAP); // FIXME ??
      // glDisable(GL_DEPTH_TEST); // FIXME
      mutable& sdr = *sdr_sb;
      glUseProgram(sdr.program);
      glActiveTexture(GL_TEXTURE0);
      // FIXME
      glBindTexture(GL_TEXTURE_CUBE_MAP, texture_cube->texture_id.get());
      // glBindTexture(GL_TEXTURE_2D, texture_2dtex.texture_id.get());
      // debug_log("cube texture", texture_cube.texture_id.get());
      // debug_log("2d texture", texture_2dtex.texture_id.get());
      glUniform1i(sdr.u_sampler_cube, 0); // FIXME
      // glUniform1i(sdr.u_sampler_2dtex, 0);
      glm::mat4 proj_inv = cam_df.projection.inverse();
      glUniformMatrix4fv(sdr.u_projection_inv, 1, 0, proj_inv.to_crawptr());
      glm::mat3 cam_dir_mat = cam_df.camera.angle.to_mat3();
      glUniformMatrix3fv(sdr.u_camera_dir_matrix, 1, 0,
	cam_dir_mat.to_crawptr());
      if (glc.light_fixed) {
	glUniform3fv(sdr.u_light_dir, 1,
	  glm::make_vec3(0.0, 0.0, -1.0).to_crawptr());
      } else {
	glUniform3fv(sdr.u_light_dir, 1,
	  (cam_df.light.angle * glm::make_vec3(0.0, 0.0, 1.0)).to_crawptr());
      }
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

metafunction skybox_shader_ptr
  ptr{glshader{
    skybox_uniforms, skybox_instance_attributes, skybox_vertex_attributes}};

function skybox_shader_ptr
init_skybox_shader(shader_config const& g)
{
  string v;
  string f;
  v += g.prepend();
  v += g.vert_in() + "vec2 vert;\n";
  v += g.vert_out() + "vec3 vary_dir;\n";
  v += "uniform mat4 projection_inv;\n";
  v += "uniform mat3 camera_dir_matrix;\n";
  v += "void main(void) {\n";
  v += "vec4 pos = vec4(vert, 1.0, 1.0);\n";
  v += "vec3 pos_unproj = (projection_inv * pos).xyz;\n";
  v += "vary_dir = camera_dir_matrix * pos_unproj;\n";
  v += "gl_Position = pos;\n";
  v += "}\n";
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "uniform samplerCube sampler_cube;\n";
  f += "uniform vec3 light_dir;\n";
  // f += "uniform sampler2D sampler_2dtex;\n";
  f += g.frag_in() + "vec3 vary_dir;\n";
  f += "void main(void) {\n";
  f += "vec4 color = vec4(" + g.texture_cube();
  f += "(sampler_cube, vary_dir).xyz, 1.0);\n";
  f += "float cos_angle = max(0.0, dot(normalize(vary_dir), light_dir));\n";
  f += "float s = pow(cos_angle, 32.0);\n";
  f += "color += vec4(s, s, s, 0.0);\n";
  f += g.fragcolor() + " = color;\n";
  /*
  f += g.fragcolor() + " = vec4(" + g.texture2d();
  f += "(sampler_2dtex, vary_dir.xy).xyz, 1.0);\n";
  */
  // f += g.fragcolor() + " = vec4(normalize(vary_dir), 0.0);\n";
  // f += g.fragcolor() + " = vec4(normalize(vary_dir), 0.0);\n";
  //f += g.fragcolor() + " = vec4(0.0, 0.0, 1.0, 0.0);\n";
  f += "}\n";
  return make_glshader_ptr{skybox_uniforms, skybox_instance_attributes,
    skybox_vertex_attributes}(v, f, "idata", g.debug_level);
}

private threaded function void prepare_instance_data_skybox(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  const sli = sn.trans.value.to_cslice();
  idata.instance_buffer.append(sli[0 .. 4]);
}

