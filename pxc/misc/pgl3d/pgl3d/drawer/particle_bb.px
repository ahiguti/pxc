private threaded namespace pgl3d::drawer::particle_bb "export-unsafe";
public import common -;
public import pgl3d::drawer::base -;
public import meta m;

private tsvaluetype struct particle_bb_uniforms()
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 camera_matrix;
  public float point_size_base;
}

private tsvaluetype struct particle_bb_instance_attributes()
{
  public glm::mat4 model_matrix; // vp applied
}

private tsvaluetype struct particle_bb_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec2 local_position;
}

public struct drawer_particle_bb(shader_config const& glc,
  resource_pool_ptr const& res)
<pgldrawer_i>
{
  metafunction tattr particle_bb_vertex_attributes;
  particle_bb_shader_ptr sdr_pb = init_particle_bb_shader(glc);
  public function string get_vbid_name() const { return "vbid_particle_bb"; }
  public function string get_main_vbid_name() const {
    return "vbid_particle_bb"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_default}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, false);
  }
  public function string builtin_vertex_set_name() const { return ""; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const { }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_particle_bb_filler(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function option{cptr{texture_data}} get_texture_data(
    cstrref const& name) const
  { 
    return option{cptr{texture_data}}();
  }
  public function void resize_screen(shader_config const& glc, int width,
    int height, int sm_width, int sm_height) 
  { 
  }
  public function void reload_shaders()
  {
  }
  public function uint get_postprocess_framebuffer(draw_step step) const
  {
    return 0U;
  }
  public function bool has_step(draw_step step) const
  {
    return step == draw_step_blend;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (step == draw_step_blend) {
      glEnable(GL_DEPTH_TEST);
      glBlendFunc(GL_ONE, GL_ONE);
      mutable& sdr = *sdr_pb;
      glUseProgram(sdr.program);
      mutable cam_mat = glm::mat4();
      cam_mat = cam_df.camera.to_mat4();
      const vp = cam_df.projection * (cam_mat.inverse());
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      glUniformMatrix3fv(sdr.u_camera_matrix, 1, 0,
	cam_mat.to_3().to_crawptr());
      glUniform1f(sdr.u_point_size_base, 0.1f);
      aibuf.draw(sdr, bo, bo_ib, bo_id,
	glc.enable_instanced, glc.enable_uniform_instancing);
    }
  }
  public function option{ptr{edit_mode_i}} get_edit_mode() const
  {
    return option{ptr{edit_mode_i}}();
  }
}

private threaded function void
dgf_particle_bb_internal(ptr{vertices} const& vptr, bool flat_flag,
  poly_t const& poly, mesh_index const& mp)
{
  for (const i, const& p: poly) {
    farray{particle_bb_vertex_attributes, 4} vtxs;
    for (const j, mutable& v: vtxs) {
      v.position = p.pos;
    }
    vtxs[0].local_position = glm::make_vec2(-1.0, -1.0);
    vtxs[1].local_position = glm::make_vec2( 1.0, -1.0);
    vtxs[2].local_position = glm::make_vec2( 1.0,  1.0);
    vtxs[3].local_position = glm::make_vec2(-1.0,  1.0);
    vptr->push_polygon_distinct{particle_bb_vertex_attributes, 0}(vtxs);
  }
}

private threaded function dgf_filler
make_dgf_particle_bb_filler(ptr{vertices} const& vptr)
{
  return make_callable_ptr{dgf_particle_bb_internal, 1}(vptr);
}

metafunction particle_bb_shader_ptr
  ptr{glshader{particle_bb_uniforms, particle_bb_instance_attributes,
    particle_bb_vertex_attributes}};

function particle_bb_shader_ptr
init_particle_bb_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat3 camera_matrix;\n";
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec2 local_position;\n";
  v += g.vert_out() + "vec2 point_coord;\n";
  v += "void main(void) {\n";
  v += "vec4 pos = " + g.instance_attr("model_matrix");
  v += "  * vec4(position, 1.0);\n";
  v += "vec3 posb = camera_matrix";
  v += "  * vec3(local_position * point_size_base, 0.0);\n";
  v += "gl_Position = view_projection_matrix * vec4(pos.xyz + posb, 1.0);\n";
  v += "point_coord = local_position;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec2 point_coord;\n";
  f += "void main(void) {\n";
  f += "vec2 xy = point_coord;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{particle_bb_uniforms,
    particle_bb_instance_attributes,
    particle_bb_vertex_attributes}(v, f, "model_matrix", g.debug_level);
}

