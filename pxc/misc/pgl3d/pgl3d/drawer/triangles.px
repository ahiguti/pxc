private threaded namespace pgl3d::drawer::triangles "export-unsafe";
public import common -;
public import pgl3d::drawer::internal -;
public import meta m;

private tsvaluetype struct triangles_uniforms()
{
  public glm::mat4 view_projection_matrix;
  public int sampler_dpat;
  public int sampler_pmpat;
  public int sampler_tilemap;
  public int sampler_env;
  public int sampler_voxpat;
  public int sampler_sm; // array
  public glm::vec3 camera_pos;
  public glm::vec3 light_dir;
  public float light_on;
  public float ndelta_scale; // 0.02 / 40. if light_fixed, 0.02 otherwise
  public glm::mat4 shadowmap_vp; // array
  public float option_value;
}

private tsvaluetype struct triangles_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 uv_aabb;
}

private tsvaluetype struct zprepass_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 uv_aabb;
}

private tsvaluetype struct shadowmap_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 uv_aabb;
}

private tsvaluetype struct triangles_instance_attributes()
{
  public glm::mat4 model_matrix;
}

private tsvaluetype struct zprepass_uniforms()
{
  public glm::mat4 view_projection_matrix;
}

private tsvaluetype struct shadowmap_uniforms()
{
  public glm::mat4 shadowmap_vp;
  public glm::vec3 trans; // used if light_fixed
  public float scale;     // used if light_fixed
}

public struct drawer_triangles(shader_config const& glc,
  resource_pool_ptr const& res0, int opt0)
<pgldrawer_i>
{
  metafunction tattr triangles_vertex_attributes;
  metafunction octree_bshift 5;
  ptr{resource_pool} res = pointer_downcast{ptr{resource_pool}}(res0);
  int const opt = opt0;
  option{triangles_shader_ptr} sdr_solid;
  option{zprepass_shader_ptr} sdr_zp;
  option{shadowmap_shader_ptr} sdr_shadow;
  ptr{gl_texture} texture_dpat = make_ptr{gl_texture}();
  ptr{gl_texture} texture_pmpat = make_ptr{gl_texture}();
  ptr{gl_texture} texture_tilemap = make_ptr{gl_texture}();
  ptr{gl_texture} texture_env = make_ptr{gl_texture}();
  ptr{gl_texture} texture_voxpat = make_ptr{gl_texture}();
  init(glc);
  private function void init(shader_config const& glc)
  {
  /*
    load_gl_texture_tilemap(*texture_dpat, *texture_pmpat, *texture_tilemap,
      "dpat.png", "pmpat.png");
  */
    const tex_col = load_texture_data("default-color.png");
    const tex_dep = load_texture_data("default-depth.png");
    const tex_tilemap = make_ptr{texture_data}();
    prepare_texture_data(*tex_col, *tex_dep, *tex_tilemap);
    texture_data_to_gl_texture(GL_TEXTURE_2D, *texture_dpat, tex_col);
    texture_data_to_gl_texture(GL_TEXTURE_2D, *texture_pmpat, tex_dep);
    texture_data_to_gl_texture(GL_TEXTURE_2D, *texture_tilemap, tex_tilemap);
    res->textures.insert("tile_color", texture_dpat);
    res->textures.insert("tile_parallax", texture_pmpat);
    res->textures.insert("tile", texture_tilemap);
    uint mutable octree_wh_l2 = 4;
    uint mutable octree_d_l2 = octree_wh_l2;
    if (opt != 0) {
      mutable tex_octree = load_texture_data_raw("octree.raw");
      if (tex_octree->width == 0) {
	debug_log("generate octree.raw");
	const bshift = static_cast{uint}(octree_bshift);
	const tex_voxpat = make_ptr{texture_data}();
	const tex_voxmap = make_ptr{texture_data}();
	const pattern_size = 8u;
	const virt_size_x = 15u;
	const virt_size_y = 15u;
	const virt_size_z = 13u;
	prepare_texture_data_3d_tpat(*tex_voxpat, pattern_size, bshift);
	prepare_texture_data_3d_tmap(*tex_voxmap, pattern_size,
	  virt_size_x - bshift, virt_size_y - bshift, virt_size_z - bshift,
	  bshift);
	tex_octree = convert_to_octree{octree_bshift}(tex_voxpat,
	  tex_voxmap);
	save_texture_data_raw("octree.raw", *tex_octree);
	debug_log("saved octree.raw", tex_octree->width,
	  tex_octree->height, tex_octree->depth, tex_octree->data.size());
      } else {
	debug_log("loaded from octree.raw", tex_octree->width,
	  tex_octree->height, tex_octree->depth,
	  "bytes=", tex_octree->data.size() * 4u);
      }
      texture_data_to_gl_texture(GL_TEXTURE_3D, *texture_voxpat, tex_octree);
      octree_wh_l2 = integral_log2(tex_octree->width) - octree_bshift;
      octree_d_l2 = integral_log2(tex_octree->depth) - octree_bshift;
      debug_log("octree_d_l2", octree_d_l2);
    }
    sdr_solid.some = init_triangles_shader(glc, opt, octree_bshift,
      octree_wh_l2, octree_d_l2);
    sdr_zp.some = init_zprepass_shader(glc, opt);
    sdr_shadow.some = init_shadowmap_shader(glc, opt);
  }
  public function string get_vbid_name() const {
    return "vbid_triangles_" + to_string(opt);
  }
  public function string get_main_vbid_name() const {
    return "vbid_triangles_0";
  }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_triangles}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, opt != 0);
  }
  public function string builtin_vertex_set_name() const { return ""; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const { }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_polygon_filler{tattr}(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    if (name == "main") {
      r.surface_w = texture_dpat->surface_w;
      r.surface_h = texture_dpat->surface_h;
    }
    return r;
  }
  public function void resize_screen(shader_config const& glc, int width,
    int height)
  {
  }
  public function uint get_postprocess_framebuffer() const
  {
    return 0U;
  }
  public function bool has_step(draw_step step) const
  {
    if (opt != 0) {
      if (// step == draw_step_shadowmapping ||
	step == draw_step_solid) {
	return true;
      }
    } else {
      if (step == draw_step_shadowmapping ||
	step == draw_step_zprepass ||
	step == draw_step_solid) {
	return true;
      }
    }
    return false;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (step == draw_step_shadowmapping) {
      if (opt != 0) { return; }
      const sm_view = cam_df.light.to_mat4().inverse();
      const sm_vp = cam_df.sm_projection[iter] * sm_view;
      float scale = 1.0f / glc.shadowmap_distance;
      for (const i: 0 .. iter) {
	scale /= glc.shadowmap_scale;
      }
      glUseProgram(sdr_shadow.some->program);
      if (glc.light_fixed) {
	//debug_log("scale", scale);
	const trans = -cam_df.camera.position;
	glUniform3fv(sdr_shadow.some->u_trans, 1, trans.to_crawptr());
	glUniform1f(sdr_shadow.some->u_scale, scale);
      } else {
	glUniformMatrix4fv(sdr_shadow.some->u_shadowmap_vp, 1, 0,
	  sm_vp.to_crawptr());
      }
      aibuf.draw(*sdr_shadow.some, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    } else if (step == draw_step_zprepass) {
      if (opt != 0) { return; }
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      mutable& sdr = *sdr_zp.some;
      glUseProgram(sdr.program);
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	  glc.enable_uniform_instancing);
    } else if (step == draw_step_solid) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
      mutable& sdr = *sdr_solid.some;
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, texture_dpat->texture_id.get());
      /*
      // FIXME: enable
      glActiveTexture(GL_TEXTURE1);
      glBindTexture(GL_TEXTURE_2D, texture_pmpat.texture_id.get());
      glActiveTexture(GL_TEXTURE2);
      glBindTexture(GL_TEXTURE_2D, texture_tilemap.texture_id.get());
      */
      glUseProgram(sdr.program);
      if (glc.light_fixed) {
	glUniform3fv(sdr.u_light_dir, 1,
	  glm::make_vec3(0.0, 0.0, -1.0).to_crawptr());
      } else {
	glUniform3fv(sdr.u_light_dir, 1,
	  (cam_df.light.angle * glm::make_vec3(0.0, 0.0, 1.0)).to_crawptr());
      }
      glUniform3fv(sdr.u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, texture_dpat->texture_id.get());
      glActiveTexture(GL_TEXTURE1);
      glUniform1i(sdr.u_sampler_dpat, 0);
      glBindTexture(GL_TEXTURE_2D, texture_pmpat->texture_id.get());
      glUniform1i(sdr.u_sampler_pmpat, 1);
      glActiveTexture(GL_TEXTURE2);
      glBindTexture(GL_TEXTURE_2D, texture_tilemap->texture_id.get());
      glUniform1i(sdr.u_sampler_tilemap, 2);
      if (texture_env->texture_id.get() == 0) { // TODO: cleanup
	if (const te: res->textures["environ"]) {
	  texture_env = te;
	  // debug_log("texture_env", texture_env);
	}
      }
      if (texture_env->texture_id.get() != 0) {
	glActiveTexture(GL_TEXTURE3);
	glBindTexture(GL_TEXTURE_CUBE_MAP, texture_env->texture_id.get());
	glUniform1i(sdr.u_sampler_env, 3);
      }
      if (opt != 0) {
	glCullFace(GL_FRONT);
	glActiveTexture(GL_TEXTURE4);
	glBindTexture(GL_TEXTURE_3D, texture_voxpat->texture_id.get());
	// glBindTexture(GL_TEXTURE_1D, texture_voxpat->texture_id.get());
	glUniform1i(sdr.u_sampler_voxpat, 4);
      }
      darrayst{int} sampler_smarr = darrayst{int}(
	static_cast{size_t}(glc.num_shadowmaps), 0);
      for (const i: 0 .. glc.num_shadowmaps) {
	glActiveTexture(static_cast{GLenum}(
	  static_cast{int}(GL_TEXTURE5) + i));
	glBindTexture(GL_TEXTURE_2D, smtex_arr[static_cast{size_t}(i)]);
	sampler_smarr[static_cast{size_t}(i)] = 5 + i;
      }
      glUniform1iv(sdr.u_sampler_sm, glc.num_shadowmaps,
	caddress(sampler_smarr[0]));
      if (glc.light_fixed) {
	glUniform1f(sdr.u_ndelta_scale,
	  static_cast{float}(8192 / cam_df.shadowmap_size)
	    * 0.02f / glc.shadowmap_distance);
      } else {
	const sm_view = cam_df.light.to_mat4().inverse();
	darrayst{glm::mat4} sm_vparr = darrayst{glm::mat4}(
	  static_cast{size_t}(glc.num_shadowmaps), glm::mat4());
	for (const i: 0 .. static_cast{size_t}(glc.num_shadowmaps)) {
	  sm_vparr[i] = cam_df.sm_projection[i] * sm_view;
	}
	glUniformMatrix4fv(sdr.u_shadowmap_vp, glc.num_shadowmaps, 0,
	  sm_vparr[0].to_crawptr());
	glUniform1f(sdr.u_ndelta_scale,
	  static_cast{float}(8192 / cam_df.shadowmap_size) * 0.02);
      }
      mutable opval = static_cast{int}(cam_df.option_value);
      opval /= 2;
      opval %= 4;
      glUniform1f(sdr.u_option_value, static_cast{float}(opval));
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0, vp.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
      if (opt != 0) {
	glCullFace(GL_BACK);
      }
    }
  }
}

private function void prepare_texture_data_3d_tmap(texture_data mutable& tmap,
  uint pattern_sz_l2, uint vx_l2, uint vy_l2, uint vz_l2, uint bshift)
{
/*
  const tsz_l2 = max(vx_l2, max(vy_l2, vz_l2));
  const tsz = 1 << tsz_l2;
  const utsz = static_cast{uint}(tsz);
  if (tsz_l2 >= 32u) {
    throw runtime_error_template{"texture_3d_tmap"}("1");
  }
*/
  const vtxsz = 1 << vx_l2;
  const uvtxsz = static_cast{uint}(vtxsz);
  const uvtxmask = uvtxsz - 1u;
  const vtysz = 1 << vy_l2;
  const uvtysz = static_cast{uint}(vtysz);
  const uvtymask = uvtysz - 1u;
  const vtzsz = 1 << vz_l2;
  const uvtzsz = static_cast{uint}(vtzsz);
  const uvtzmask = uvtzsz - 1u;
  const ptshift = pattern_sz_l2 - bshift;
  const ptmask = (1u << ptshift) - 1u;
  debug_log("ptmask", ptmask);
  debug_log("vtxsz", vtxsz);
  tmap.width = uvtxsz;
  tmap.height = uvtysz;
  tmap.depth = uvtzsz;
  tmap.data.resize(static_cast{size_t}(uvtxsz) * uvtysz * uvtzsz, 0U);
  if (tmap.data.size() == 0) {
    throw runtime_error_template{"texture_3d_tmap"}("size0");
  }
  const rnd = make_rand_generator(1u);
  metafunction ui static_cast{uint};
  metafunction si static_cast{int};
  function void set(int x, int y, int z, uint v) {
    const idx = (ui(z) << (vy_l2 + vx_l2)) | (ui(y) << vx_l2) | ui(x);
    tmap.data[idx] = v;
  }
  function uint get(int x, int y, int z) {
    if (x < 0 || x >= vtxsz) { return 0; }
    if (y < 0 || y >= vtysz) { return 0; }
    if (z < 0 || z >= vtzsz) { return 0; }
    const idx = (ui(z) << (vy_l2 + vx_l2)) | (ui(y) << vx_l2) | ui(x);
    return tmap.data[idx];
  }
  function void append_6dir()
  {
    for (const x: 0 .. vtxsz) {
      for (const y: 0 .. vtysz) {
	for (const z: 0 .. vtzsz) {
	  function bool cval(int x, int y, int z) {
	    const v = get(x, y, z);
	    return (v & 0xff000000) >= 0x02000000;
	  }
	  const v0 = cval(x, y, z);
	  if (v0) { continue; }
	  const vxp = cval(x + 1, y, z);
	  const vxn = cval(x - 1, y, z);
	  const vyp = cval(x, y + 1, z);
	  const vyn = cval(x, y - 1, z);
	  const vzp = cval(x, y, z + 1);
	  const vzn = cval(x, y, z - 1);
	  mutable pz = 6u;
	  if (vxp && !vxn) {
	    pz = 0;
	  } else if (!vxp && vxn) {
	    pz = 1;
	  } else if (vyp && !vyn) {
	    pz = 2;
	  } else if (!vyp && vyn) {
	    pz = 3;
	  } else if (vzp && !vzn) {
	    pz = 4;
	  } else if (!vzp && vzn) {
	    pz = 5;
	  } else {
	    continue;
	  }
	  mutable rv = rnd->generate();
	  const px = rv & ptmask;
	  rv >>= ptshift;
	  const py = rv & ptmask;
	  const idx = (pz << (ptshift * 2)) | (py << ptshift) | px;
	  const v = 0x01000000u | idx;
	  // debug_log("detail", x, y, z, to_hexstring(v));
	  set(x, y, z, v);
	}
      }
    }
  }
  function int rand_gen(int v)
  {
    if (v < 1) { return 0; }
    return si(rnd->generate() % ui(v));
  }
  if (true) {
    function void fill_range(int x0, int y0, int z0, int w)
    {
      for (const x: x0 - w .. x0 + w + 1) {
	for (const y: y0 - w .. y0 + w + 1) {
	  for (const z: z0 - w .. z0 + w + 1) {
	    set(x, y, z, 0xffb090a0);
	  }
	}
      }
    }
    function void make_branch_rec(int x, int y, int z, int w, int dir)
    {
      int dx = 0;
      int dy = 0;
      int dz = 0;
      int len = 0;
      if (dir == 0) { // xp
	dx =  1; len = rand_gen(min(vtxsz - 1 - x - w, vtxsz / 8));
      } else if (dir == 1) {
	dx = -1; len = rand_gen(min(x - w, vtxsz / 8));
      } else if (dir == 2) {
	dy =  1; len = rand_gen(min(vtysz - 1 - y - w, vtysz / 8));
      } else if (dir == 3) {
	dy = -1; len = rand_gen(min(y - w, vtysz / 8));
      } else if (dir == 4) {
	dz =  1; len = rand_gen(min(vtzsz - 1 - z - w, vtzsz / 8));
      } else if (dir == 5) {
	dz = -1; len = rand_gen(min(z - w, vtzsz / 8));
      }
      if (len == 0) {
	return;
      }
      for (int i: 0 .. len + 1) {
	x += dx;
	y += dy;
	z += dz;
	fill_range(x, y, z, w);
      }
      if (w > 1) {
	for (int d: 0 .. 6) {
	  if (d == dir) {
	    continue;
	  }
	  make_branch_rec(x, y, z, w - 1, d);
	}
      }
    }
    for (int d: 0 .. 6) {
      make_branch_rec(vtxsz / 2, vtysz / 2, vtzsz / 2, 9, d);
    }
    append_6dir();
  } else if (true) {
    // 6dir bump
    for (const x: 2 .. vtxsz - 2) {
      for (const y: 2 .. vtysz - 2) {
	for (const z: vtzsz - 4 .. vtzsz - 3) {
	  set(x, y, z, 0xffb090a0);
	}
      }
    }
    function void make_bump_rec(int rec, int x0, int x1, int y0, int y1, int z)
    {
      if (x1 - x0 < 2 || y1 - y0 < 2 || z < 4) {
	return;
      }
      for (const i: 0 .. 30) {
	const x = rand_gen(x1 - x0) + x0;
	const y = rand_gen(y1 - y0) + y0;
	const w = rand_gen((x1 - x0) / 8) + (x1 - x0) / 8;
	const h = rand_gen((y1 - y0) / 16) + (y1 - y0) / 8;
	const d = rand_gen(z / 6) + (z / 8);
	// debug_log("xywhd", x, y, w, h, d);
	if (x - w < x0 || x + w >= x1 || y - h < y0 || y + h >= y1 ||
	  z - d < 0)
	{
	  continue;
	}
	for (const ix: x - w .. x + w + 1) {
	  for (const iy: y - h .. y + h + 1) {
	    for (const iz: z - d .. z) {
	      set(ix, iy, iz, 0xffb090a0);
	    }
	  }
	}
	if (rec > 0) {
	  make_bump_rec(rec - 1, x - w, x + w, y - h, y + h, z - d);
	}
      }
    }
    make_bump_rec(5, 0 + 2, vtxsz - 2, 0 + 2, vtysz - 2, vtzsz - 2);
    append_6dir();
  } else {
    // repeat tpat data
    for (const i, mutable& m: tmap.data) {
      const px = i & uvtxmask;
      const py = (i >> vx_l2) & uvtymask;
      const pz = (i >> (vy_l2 + vx_l2)) & uvtzmask;
/*
      const mg1 = 32u;
      const mg2 = 0u;
      if (px >= mg1 && px < uvtxsz - mg1 &&
	  py >= mg1 && py < uvtysz - mg1 &&
	  pz >= mg1 && pz < uvtzsz - mg1)
      {
	const w = (px + py + pz) & 1;
	const v = w != 0 ? 0xff040400 : 0xffd0d0d0;
	m = static_cast{uint}(v);
//      } else if (pz == 0) {
//	m = 0xff00d0d0;
      } else if (
	  px >= mg2 && px < uvtxsz - mg2 &&
	  py >= mg2 && py < uvtysz - mg2 &&
	  pz >= mg2 && pz < uvtzsz - mg2)
*/
      {
	const x = (i & ptmask);
	const y = ((i >> vx_l2) & ptmask);
	const z = ((i >> (vx_l2 + vy_l2)) & ptmask);
	mutable v = (z << (ptshift * 2)) | (y << ptshift) | x | 0x01000000;
	  // node reference flag
	// debug_log("i,x,y,z", to_hexstring(i), to_hexstring(x), to_hexstring(y), to_hexstring(z));
/*
	if (x >= 0u || y >= 0u) {
	  // mutable v = rnd->generate();
	  const x0 = static_cast{uint}(rnd->generate()) % ptmask;
	  const y0 = static_cast{uint}(rnd->generate()) % ptmask;
	  const z0 = static_cast{uint}(rnd->generate()) % ptmask;
	  v = (z0 << (ptshift * 2)) | (y0 << ptshift) | x0 | 0x01000000u;
	  // v = (static_cast{uint}(rnd->generate()) &
	  //   ((1u << (ptshift * 3)) - 1u)) | 0x01000000;
	}
*/
	m = static_cast{uint}(v);
	// debug_log("i,v", to_hexstring(i), to_hexstring(v));
/*
      } else {
	m = 0u;
*/
      }
    }
  }
}

private function void prepare_texture_data_3d_tpat(texture_data mutable& tpat,
  uint pattern_sz_l2, uint bshift)
{
  const color0 = 0x00000000u;
  const color1 = 0xff102020u;
  const color2 = 0xff201010u;
  const psz = 1 << pattern_sz_l2;
  const usz = static_cast{uint}(psz);
  tpat.width = usz;
  tpat.height = usz;
  tpat.depth = usz;
  tpat.data.resize(usz * usz * usz, 0U);
  metafunction si static_cast{int};
  metafunction ui static_cast{uint};
  if (true) {
    // 6dir bump
    const rnd = make_rand_generator(333U);
    function void set_bump(uint bx, uint by, uint bz, uint x0, uint y0,
      uint z0, uint dir)
    {
      const bsz = 1u << bshift;
      uint x;
      uint y;
      uint z;
      if (dir == 0u) {
	x = bsz - z0 - 1; y = x0; z = y0;
      } else if (dir == 1u) {
	x = z0; y = x0; z = y0;
      } else if (dir == 2u) {
	x = y0; y = bsz - z0 - 1; z = x0;
      } else if (dir == 3u) {
	x = y0; y = z0; z = x0;
      } else if (dir == 4u) {
	x = x0; y = y0; z = bsz - z0 - 1;
      } else {
	x = x0; y = y0; z = z0;
      }
      x += bx;
      y += by;
      z += bz;
      if (x > 255 || y > 255 || z > 255) { // FIXME
	// debug_log("set_bump", x, y, z, bx, by, bz, x0, y, z0, dir);
      }
      const idx = (z << (pattern_sz_l2 * 2)) | (y << pattern_sz_l2) | x;
      // debug_log("set_color", x & 16, y & 16, z, x0, y0, z0, dir);
      tpat.data[idx] = 0xffb090a0;
    }
    function void make_bump_one(uint x0, uint y0, uint z0, uint dir) {
      const bsz = 1 << bshift;
      const bmask = (1u << bshift) - 1u;
      mutable rv = rnd->generate();
      const x = si(rv & bmask);
      rv >>= bshift;
      const y = si(rv & bmask);
      rv >>= bshift;
      mutable w = si(rv & bmask) / 2;
      rv >>= bshift;
      mutable h = si(rv & bmask) / 4;
      rv >>= bshift;
      const d = si(rv & bmask);
      rv >>= bshift;
      if (x - w < 0) { w = x; }
      if (x + w >= bsz) { w = bsz - x - 1; }
      if (y - h < 0) { h = y; }
      if (y + h >= bsz) { h = bsz - y - 1; }
      for (const ix: x - w .. x + w + 1) {
	for (const iy: y - h .. y + h + 1) {
	  for (const iz: 0 .. d) {
	    set_bump(x0, y0, z0, ui(ix), ui(iy), ui(iz), dir);
	  }
	}
      }
    }
    if ((usz >> bshift) < 6u) {
      throw runtime_error_template{"3d_tpat"}("usz is too small");
    }
    for (const z: 0 .. 6u) {
      for (const y: 0 .. usz >> bshift) {
	for (const x: 0 .. usz >> bshift) {
	  debug_log("bump xyz", x, y, z);
	  for (const i: 0 .. 10u) {
	    make_bump_one(x << bshift, y << bshift, z << bshift, z);
	  }
	}
      }
    }
  } else if (false) {
    const rnd = make_rand_generator(333U);
    for (const i: 0 .. 500) {
      mutable v = static_cast{uint}(rnd->generate());
      const x0 = static_cast{int}(v % usz);
      v /= usz;
      const y0 = static_cast{int}(v % usz);
      v /= usz;
      const z0 = static_cast{int}(v % usz);
      v /= usz;
      v = static_cast{uint}(rnd->generate());
      const w0 = static_cast{int}(v % 8 + 1);
      v /= 8;
      const h0 = static_cast{int}(v % 32 + 1);
      v /= 32;
      const d0 = static_cast{int}(v % 16 + 5);
      v /= 16;
      mutable uv = static_cast{uint}(rnd->generate());
      /*
      const r0 = static_cast{uint}(x0) / 3u;
      const g0 = static_cast{uint}(y0) / 3u;
      const b0 = static_cast{uint}(z0) / 3u;
      const r0 = (uv % 4 + 1) * 16;
      uv /= 4;
      const g0 = (uv % 4 + 1) * 16;
      uv /= 4;
      const b0 = (uv % 4 + 1) * 16;
      uv /= 4;
      const c0 = 0xff000000u | (b0 << 16u) | (g0 << 8u) | (r0 << 0u);
      {
	string s;
	integral_to_hexadecimal{uint}(c0, s);
	// debug_log("color", s, r0, g0, b0);
      }
      */
      for (const x: x0 - w0 .. x0 + w0 + 1) {
	if (x < 0 || x >= psz - 0) { continue; }
	for (const y: y0 - h0 .. y0 + h0 + 1) {
	  if (y < 0 || y >= psz - 0) { continue; }
	  for (const z: z0 - d0 .. z0 + d0 + 1) {
	    if (z < 0 || z >= psz - 0) { continue; }
	    const r0 = static_cast{uint}(x) / 3u;
	    const g0 = static_cast{uint}(y) / 3u;
	    const b0 = static_cast{uint}(z) / 3u;
	    const c0 = 0xff000000u | (b0 << 16u) | (g0 << 8u) | (r0 << 0u);
	    tpat.data[static_cast{size_t}(((z * psz) + y) * psz + x)] = c0;
	  }
	}
      }
    }
  } else if (false) {
    // sphere clamped
    for (const x: 0 .. psz) {
      for (const y: 0 .. psz) {
	for (const z: 0 .. psz) {
	  const x1 = static_cast{float}(x * 2 + 1 - psz)
	      / static_cast{float}(psz);
	  const y1 = static_cast{float}(y * 2 + 1 - psz)
	      / static_cast{float}(psz);
	  const z1 = static_cast{float}(z * 2 + 1 - psz)
	      / static_cast{float}(psz);
	  const n2 = x1 * x1 + y1 * y1 + z1 * z1;
	  const m = (x + y + z) & 1;
	  mutable v = (n2 < 1.5f) ? ((m != 0) ? color2 : color1) : color0;
	  // debug_log(x1, y1, z1, v != color0);
	  tpat.data[static_cast{size_t}(((z * psz) + y) * psz + x)] = v;
	}
      }
    }
  } else {
    // sphere
    const sphere_radius = 0.9f;
    const fpsz = static_cast{float}(psz);
    const fipsz = 1.0f / fpsz;
    for (const x: 0 .. psz) {
      for (const y: 0 .. psz) {
	for (const z: 0 .. psz) {
	  const x1 = static_cast{float}(x * 2 + 1 - psz) * fipsz;
	  const y1 = static_cast{float}(y * 2 + 1 - psz) * fipsz;
	  const z1 = static_cast{float}(z * 2 + 1 - psz) * fipsz;
	  const n2 = x1 * x1 + y1 * y1 + z1 * z1;
	  const vec3 nor = make_vec3(x1, y1, z1).normalize();
	  const vec3 pos = nor * sphere_radius;
	  const vec3 v0pos = make_vec3(x1 - fipsz, y1 - fipsz, z1 - fipsz);
	  const vec3 lpos = (pos - v0pos) * fpsz * 0.5f;
	    // voxel-local (0,1) coordinate
	  const float mi = min(nor.x, 0.0f) + min(nor.y, 0.0f)
	    + min(nor.z, 0.0f);
	  const float mx = max(nor.x, 0.0f) + max(nor.y, 0.0f)
	    + max(nor.z, 0.0f);
	  const d = dot(nor, lpos); // ax+by+cz=d, abc=nor, xyz=lpos
	  mutable v = color0;
	  if (d < mi) {
	    v = color0;
	  } else if (d > mx + 0.3f) {
	    v = color0; // FIXME
	  } else {
	    const vec3 cval = (nor * 127.0f)
	      + make_vec3(128.0f, 128.0f, 128.0f);
	    const cx = static_cast{uint}(cval.x + 0.5);
	    const cy = static_cast{uint}(cval.y + 0.5);
	    const cz = static_cast{uint}(cval.z + 0.5);
	    const cw = static_cast{uint}(d / 2.0f * 127.0f + 128.0f + 0.5);
	    // cw must be greater than 1
	    const vc = (cw << 24u) | (cz << 16u) | (cy << 8u) | cx;
	    v = vc;
	    // v = color2; // FIXME
	  }
	  /*
	  const cw = 0xffu;
	  const vc = (cw << 24u) | (cz << 16u) | (cy << 8u) | cx;
	  const v = (n2 < sphere_radius) ? vc : 0u;
	  */
	  // const m = (x + y + z) & 1;
	  // mutable v = (n2 < 0.9f) ? ((m != 0) ? color2 : color1) : color0;
	  // debug_log(x1, y1, z1, v != color0);
	  tpat.data[static_cast{size_t}(((z * psz) + y) * psz + x)] = v;
	}
      }
    }
  }
}

private function void prepare_texture_data(texture_data mutable& tcol,
  texture_data mutable& tdep, texture_data mutable& tmap)
{
  // generate tilemap
  tmap.width = 128;
  tmap.height = 128;
  tmap.data.resize(tmap.width * tmap.height, 0U);
  const rnd = make_rand_generator(333U);
  for (const x: 0 .. tmap.width) {
    for (const y: 0 .. tmap.height) {
      const v0 = rnd->generate() / 65536;
      const v1 = 1U + v0 % 2U;
      // const v2 = (v0 / 8) % 8;
      // const v1 = 1;
      const v2 = 0U;
      const v = v2 * 256U + v1;
      tmap.data[y * tmap.width + x] = static_cast{uint}(v);
    }
  }
  parallax_png_decode(tdep);
  set_normal_pattern(tdep, tcol);
  parallax_set_clearance(tdep);
}

private function void set_normal_pattern(texture_data const& tdep,
  texture_data mutable& tcol)
{
  function uint read_depth(int x, int y) {
    if (x < 0 || y < 0 || static_cast{uint}(x) >= tdep.width ||
      static_cast{uint}(y) >= tdep.height) {
      return 0;
    }
    return tdep.data[static_cast{uint}(y) * tdep.width + static_cast{uint}(x)];
  }
  for (const x : 0 .. tdep.width) {
    for (const y : 0 .. tdep.height) {
      const xi = static_cast{int}(x);
      const yi = static_cast{int}(y);
      const d0  = read_depth(xi, yi);
      const dlu = read_depth(xi - 1, yi - 1);
      const du  = read_depth(xi    , yi - 1);
      const dru = read_depth(xi + 1, yi - 1);
      const dl  = read_depth(xi - 1, yi    );
      const dr  = read_depth(xi + 1, yi    );
      const dld = read_depth(xi - 1, yi + 1);
      const dd  = read_depth(xi    , yi + 1);
      const drd = read_depth(xi + 1, yi + 1);
      function bool is_convex1(uint v0, uint v1, uint v2, uint v3) {
	return v0 > d0 && v1 <= d0 && v2 <= d0 && v3 <= d0;
      }
      function bool is_convex2(uint v0, uint v1, uint v2, uint v3) {
	return v0 > d0 && v1 > d0 && v2 <= d0 && v3 <= d0;
      }
      function bool is_flat4() {
	return du == d0 && dl == d0 && dr == d0 && dd == d0;
      }
      uint val;
      if (is_convex1(du, dl, dd, dr)) {
	val = 0x92; // convex upper
	// debug_log(x, y, "cu");
      } else if (is_convex1(dl, dd, dr, du)) {
	val = 0x74; // convex left
	// debug_log(x, y, "cl");
      } else if (is_convex1(dd, dr, du, dl)) {
	val = 0x72; // convex lower
	// debug_log(x, y, "cd");
      } else if (is_convex1(dr, du, dl, dd)) {
	val = 0x94; // convex right
	// debug_log(x, y, "cr");
      } else if (is_convex2(du, dl, dd, dr)) {
	val = 0x91; // convex left-upper
	// debug_log(x, y, "clu");
      } else if (is_convex2(dl, dd, dr, du)) {
	val = 0x97; // convex left-lower
	// debug_log(x, y, "cld");
      } else if (is_convex2(dd, dr, du, dl)) {
	val = 0x95; // convex right-lower
	// debug_log(x, y, "crd");
      } else if (is_convex2(dr, du, dl, dd)) {
	val = 0x93; // convex right-upper
	// debug_log(x, y, "cru");
      } else if (is_flat4()) {
	if (is_convex1(dlu, dld, drd, dru)) {
	  val = 0x75; // concave right-lower
	} else if (is_convex1(dld, drd, dru, dlu)) {
	  val = 0x73; // concave right-upper
	} else if (is_convex1(drd, dru, dlu, dld)) {
	  val = 0x71; // concave left-upper
	} else if (is_convex1(dru, dlu, dld, drd)) {
	  val = 0x77; // concave left-lower
	}
      }
      // debug_log(x, y, val);
      tcol.data[y * tcol.width + x] &= 0xffffffU;
      tcol.data[y * tcol.width + x] |= val << 24;
    }
  }
}

private function void parallax_png_decode(texture_data mutable& td)
{
  for (const i, mutable& v: td.data) {
    const depth = (v & 0xff) / 1;
    v = depth << 16;
  }
}

private function void parallax_set_clearance(texture_data mutable& td)
{
  mutable& data = td.data;
  uint const tile_size = 64;
  for (const by : 0 .. td.height / tile_size) {
    for (const bx : 0 .. td.width / tile_size) {
      for (const y : 0 .. tile_size) {
	for (const x : 0 .. tile_size) {
	  const offset = (by * tile_size + y) * td.height
	    + (bx * tile_size + x);
	  const v0 = data[offset];
	  const depth0 = (v0 >> 16) & 0xffU;
	  // clearance values
	  uint c_nn = min(x, y);
	  uint c_np = min(x, tile_size - 1 - y);
	  uint c_pn = min(tile_size - 1 - x, y);
	  uint c_pp = min(tile_size - 1 - x, tile_size - 1 - y);
	  const y1_min = (y >= 16) ? y - 16 : 0;
	  const y1_max = (y + 16 < tile_size) ? y + 16 : tile_size;
	  const x1_min = (x >= 16) ? x - 16 : 0;
	  const x1_max = (x + 16 < tile_size) ? x + 16 : tile_size;
	  // TODO: too slow
	  for (const y1 : y1_min .. y1_max) {
	    for (const x1 : x1_min .. x1_max) {
	      const offset1 = (by * tile_size + y1) * td.height
		+ (bx * tile_size + x1);
	      const v1 = data[offset1];
	      const depth1 = v1 >> 16 & 0xffU;
	      if (depth1 >= depth0) {
		continue;
	      }
	      // ok to wrap uint values
	      uint nn = max(x - x1, y - y1) - 1;
	      c_nn = min(c_nn, nn);
	      uint np = max(x - x1, y1 - y) - 1;
	      c_np = min(c_np, np);
	      uint pn = max(x1 - x, y - y1) - 1;
	      c_pn = min(c_pn, pn);
	      uint pp = max(x1 - x, y1 - y) - 1;
	      c_pp = min(c_pp, pp);
	    }
	  }
	  c_nn = min(c_nn, 15);
	  c_np = min(c_np, 15);
	  c_pn = min(c_pn, 15);
	  c_pp = min(c_pp, 15);
// c_nn = 0; // FIXME
// c_np = 0; // FIXME
	  // W = unused(8), Z = depth(8), Y = CNN(4) CNP(4), X = CPN(4) CPP(4)
	  data[offset] = (depth0 << 16) |
	    (c_nn << 12) | (c_np << 8) | (c_pn << 4) | (c_pp << 0);
	  if (by == 0 && bx == 0) {
	    // debug_log("cl", x, y, depth0, to_hexstring(data[offset]));
	  }
	}
      }
    }
  }
}

private threaded function void prepare_instance_data_triangles(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  buffer_append(idata.instance_buffer, sn.trans); /* model matrix */
}

private threaded function {tattr} void
dgf_polygon_filler_tattr(ptr{vertices} const& vptr, bool flat_flag,
  poly_t const& poly, mesh_index const& mp)
{
  dgf_fill_tattr_internal{tattr}(vptr, flat_flag, poly, mp);
}

private threaded function {tattr} dgf_filler
make_dgf_polygon_filler(ptr{vertices} const& vptr)
{
  return make_callable_ptr{dgf_polygon_filler_tattr{tattr}, 1}(vptr);
}

private metafunction shadowmap_shader_ptr
  ptr{glshader{
    shadowmap_uniforms, triangles_instance_attributes,
    shadowmap_vertex_attributes}};

private function shadowmap_shader_ptr
init_shadowmap_shader(shader_config const& g, int opt)
{
  tree_map{string, string} bnd;
  bnd["opt"] = to_string(opt);
  const v = load_shader_program(g, bnd, "triangles-sm.vsh");
  const f = load_shader_program(g, bnd, "triangles-sm.fsh");
//debug_log("shadowmap_vsh", v);
//debug_log("shadowmap_fsh", f);
  return make_glshader_ptr{
    shadowmap_uniforms,
    triangles_instance_attributes,
    shadowmap_vertex_attributes
  }(v, f, "model_matrix", g.debug_level);
}

private metafunction zprepass_shader_ptr
  ptr{glshader{
    zprepass_uniforms, triangles_instance_attributes,
    zprepass_vertex_attributes}};

private function zprepass_shader_ptr
init_zprepass_shader(shader_config const& g, int opt)
{
  tree_map{string, string} bnd;
  bnd["opt"] = to_string(opt);
  const v = load_shader_program(g, bnd, "triangles-zp.vsh");
  const f = load_shader_program(g, bnd, "triangles-zp.fsh");
//debug_log("zp_vsh", v);
//debug_log("zp_fsh", f);
  return make_glshader_ptr{
    zprepass_uniforms,
    triangles_instance_attributes,
    zprepass_vertex_attributes
  }(v, f, "model_matrix", g.debug_level);
}

private metafunction triangles_shader_ptr
  ptr{glshader{
    triangles_uniforms, triangles_instance_attributes,
    triangles_vertex_attributes}};

private function triangles_shader_ptr
init_triangles_shader(shader_config const& g, int opt, uint octree_bshift,
  uint octree_wh_l2, uint octree_d_l2)
{
  const smsz = g.num_shadowmaps_str();
  tree_map{string, string} bnd;
  bnd["smsz"] = g.num_shadowmaps_str();
  bnd["opt"] = to_string(opt);
  bnd["octree_block_factor"] = to_string(
    static_cast{float}(1u << octree_bshift));
  const wh_s = "1.0 / " + to_string(static_cast{float}(
    1 << (octree_bshift + octree_wh_l2)));
  const d_s = "1.0 / " + to_string(static_cast{float}(
    1 << (octree_bshift + octree_d_l2)));
  debug_log("scale: ", wh_s, wh_s, d_s);
  bnd["octree_texture_scale"] = "vec3(" + wh_s + "," + wh_s + "," + d_s + ")";
  // bnd["octree_size"] = to_string(1u << octree_size_l2);
  const v = triangles_shader_vert(g, bnd);
  const f = triangles_shader_frag(g, bnd);
  return
    make_glshader_ptr{
      triangles_uniforms,
      triangles_instance_attributes,
      triangles_vertex_attributes
    }(v, f, "model_matrix", g.debug_level);
}

private function string
triangles_shader_vert(shader_config const& g,
  tree_map{string, string} const& bnd)
{
  const v = load_shader_program(g, bnd, "triangles.vsh");
//debug_log("triangles_vsh", v);
  return v;
}

private function string triangles_shader_frag(shader_config const& g,
  tree_map{string, string} const& bnd)
{
  const f = load_shader_program(g, bnd, "triangles.fsh");
//debug_log("triangles fsh", f);
  return f;
}

