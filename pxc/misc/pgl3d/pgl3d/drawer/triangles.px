private threaded namespace pgl3d::drawer::triangles "export-unsafe";
public import common -;
public import meta m;
public import pgl3d::drawer::base -;
public import pgl3d::texture::tile -;
public import pgl3d::drawer::edit_mode -;

private metafunction raycast_cull_front 1;

private tsvaluetype struct triangles_uniforms()
{
  public glm::mat4 view_projection_matrix;
  public int sampler_dpat;
  public int sampler_pmpat;
  public int sampler_tilemap;
  public int sampler_env;
  public int sampler_octree;
  public int sampler_voxtmap;
  public int sampler_voxtpat;
  public int sampler_sm; // array
  public glm::vec3 camera_pos;
  public glm::vec3 light_dir;
  public float light_on;
  public float ndelta_scale; // 0.02 / 40. if light_fixed, 0.02 otherwise
  public glm::mat4 shadowmap_vp; // array
  public float exposure;
  public float option_value;
}

private tsvaluetype struct triangles_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 aabb_or_tconv;
  public glm::vec3 aabb_min;
  public glm::vec3 aabb_max;
}

private tsvaluetype struct zprepass_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 aabb_or_tconv;
  public glm::vec3 aabb_min;
  public glm::vec3 aabb_max;
}

private tsvaluetype struct shadowmap_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 aabb_or_tconv;
  public glm::vec3 aabb_min;
  public glm::vec3 aabb_max;
}

private tsvaluetype struct triangles_instance_attributes()
{
  public glm::mat4 model_matrix;
}

private tsvaluetype struct zprepass_uniforms()
{
  public glm::mat4 view_projection_matrix;
}

private tsvaluetype struct shadowmap_uniforms()
{
  public glm::mat4 shadowmap_vp;
  public glm::vec3 trans; // used if light_fixed
  public float scale;     // used if light_fixed
}

public struct drawer_triangles(shader_config const& glc0,
  resource_pool_ptr const& res0, int opt0)
<pgldrawer_i>
{
  metafunction tattr triangles_vertex_attributes;
/*
  metafunction octree_bshift 5;
  metafunction pattern_size 9;
  metafunction virt_size_x 15;
  metafunction virt_size_y 15;
  metafunction virt_size_z 8;
*/
  metafunction octree_bshift 4;
  metafunction pattern_size 8;
  metafunction virt_size_x 12;
  metafunction virt_size_y 12;
  metafunction virt_size_z 9;
  /*
  */
  ptr{resource_pool} res = pointer_downcast{ptr{resource_pool}}(res0);
  int const stype = opt0;
  option{triangles_shader_ptr} sdr_solid;
  option{zprepass_shader_ptr} sdr_zp;
  option{shadowmap_shader_ptr} sdr_shadow;
  ptr{texture_data} tex_octree = make_ptr{texture_data}();
  ptr{texture_data} tex_voxtpat = make_ptr{texture_data}();
  ptr{texture_data} tex_voxtmap = make_ptr{texture_data}();
  ptr{gl_texture} texture_dpat = make_ptr{gl_texture}();
  ptr{gl_texture} texture_pmpat = make_ptr{gl_texture}();
  ptr{gl_texture} texture_tilemap = make_ptr{gl_texture}();
  ptr{gl_texture} texture_env = make_ptr{gl_texture}();
  ptr{gl_texture} texture_octree = make_ptr{gl_texture}();
  ptr{gl_texture} texture_voxtpat = make_ptr{gl_texture}();
  ptr{gl_texture} texture_voxtmap = make_ptr{gl_texture}();
  option{ptr{edit_mode_i}} edit_mode_ptr;
  shader_config glc = glc0;
  uint octree_wh_l2 = 4;
  uint octree_d_l2 = octree_wh_l2;
  init(glc);
  private function void init(shader_config const& glc)
  {
    debug_log("drawer_triangles init ", stype);
  /*
    load_gl_texture_tilemap(*texture_dpat, *texture_pmpat, *texture_tilemap,
      "dpat.png", "pmpat.png");
  */
    const tex_col = load_texture_data("default-color.png");
    const tex_dep = load_texture_data("default-depth.png");
    const tex_tilemap = make_ptr{texture_data}();
    prepare_texture_data(*tex_col, *tex_dep, *tex_tilemap);
    texture_data_to_gl_texture(GL_TEXTURE_2D, *texture_dpat, tex_col);
    texture_data_to_gl_texture(GL_TEXTURE_2D, *texture_pmpat, tex_dep);
    texture_data_to_gl_texture(GL_TEXTURE_2D, *texture_tilemap, tex_tilemap);
    res->textures.insert("tile_color", texture_dpat);
    res->textures.insert("tile_parallax", texture_pmpat);
    res->textures.insert("tile", texture_tilemap);
    // uint mutable octree_wh_l2 = 4;
    // uint mutable octree_d_l2 = octree_wh_l2;
    if (stype == 1) {
      tex_voxtpat = load_texture_data_raw("voxtpat.raw");
      tex_voxtmap = load_texture_data_raw("voxtmap.raw");
      tex_octree = load_texture_data_raw("octree.raw");
      if (tex_octree->width == 0 || tex_voxtpat->width == 0
	|| tex_voxtmap->width == 0) {
	debug_log("generate octree.raw");
	const bshift = static_cast{uint}(octree_bshift);
	prepare_texture_data_3d_tpat(*tex_voxtpat, pattern_size, bshift);
	debug_log("tpat done");
	prepare_texture_data_3d_tmap(*tex_voxtmap, pattern_size,
	  static_cast{uint}(virt_size_x) - bshift,
	  static_cast{uint}(virt_size_y) - bshift,
	  static_cast{uint}(virt_size_z) - bshift,
	  static_cast{uint}(bshift));
	debug_log("tmap done");
	debug_log("tmap 0,0,1", to_hexstring(tex_voxtmap->get(0, 0, 1)));
	bool enable_calc_distance =
	  glc.conf.get("calc_distance", 1, 0, 1) != 0;
	tex_octree = convert_to_octree{octree_bshift}(tex_voxtpat,
	  tex_voxtmap, enable_calc_distance);
	debug_log("octree done");
	// 移行中。voxtmap, voxtpatにもdistanceを入れる。
	prepare_voxel_tilemap(*tex_voxtpat, *tex_voxtmap,
	  pattern_size, bshift, enable_calc_distance);
	save_texture_data_raw("octree.raw", *tex_octree);
	save_texture_data_raw("voxtpat.raw", *tex_voxtpat);
	save_texture_data_raw("voxtmap.raw", *tex_voxtmap);
	debug_log("saved octree.raw", tex_octree->width,
	  tex_octree->height, tex_octree->depth, tex_octree->data.size());
      } else {
	debug_log("loaded from octree.raw", tex_octree->width,
	  tex_octree->height, tex_octree->depth,
	  "bytes=", tex_octree->data.size() * 4u);
      }
      texture_data_to_gl_texture(GL_TEXTURE_3D, *texture_octree, tex_octree);
      texture_data_to_gl_texture(GL_TEXTURE_3D, *texture_voxtpat, tex_voxtpat);
      texture_data_to_gl_texture(GL_TEXTURE_3D, *texture_voxtmap, tex_voxtmap);
      octree_wh_l2 = integral_log2(tex_octree->width) - octree_bshift;
      octree_d_l2 = integral_log2(tex_octree->depth) - octree_bshift;
      uint bshift = octree_bshift;
      if (glc.conf.get("edit_mode", 0, 0, 1) != 0) {
	ptr{edit_mode_i} em = make_ptr{edit_mode}(bshift, tex_octree,
	  texture_octree);
	edit_mode_ptr = make_option(em);
      }
    }
    reload_shaders();
    debug_log("drawer_triangles init ", stype, "done");
  }
  public function string get_vbid_name() const {
    return "vbid_triangles_" + to_string(stype);
  }
  public function string get_main_vbid_name() const {
    return "vbid_triangles_0";
  }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_triangles}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, stype != 0);
  }
  public function string builtin_vertex_set_name() const { return ""; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const { }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    bool override_uvw = (stype != 1);
    return make_dgf_polygon_filler{tattr}(vptr, override_uvw);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    if (name == "main") {
      r.surface_w = texture_dpat->surface_w;
      r.surface_h = texture_dpat->surface_h;
    }
    return r;
  }
  public function option{cptr{texture_data}} get_texture_data(
    cstrref const& name) const
  {
    option{cptr{texture_data}} r;
    if (stype == 1 && name == "octree") {
      debug_log("get_texture_data: tex_octree", tex_octree->width);
      r = make_option{cptr{texture_data}}(tex_octree);
    }
    return r;
  }
  public function void resize_screen(shader_config const& glc, int width,
    int height, int sm_width, int sm_height)
  {
  }
  public function void reload_shaders()
  {
    debug_log("triangles reload_shaders init", stype);
    option{triangles_shader_ptr} s0;
    option{zprepass_shader_ptr} s1;
    option{shadowmap_shader_ptr} s2;
    try {
      debug_log("reload_shaders: octree_d_l2", octree_d_l2);
      s0.some = init_triangles_shader(glc, stype, octree_bshift,
	octree_wh_l2, octree_d_l2);
      s1.some = init_zprepass_shader(glc, stype);
      s2.some = init_shadowmap_shader(glc, stype);
    } catch (runtime_error ex) {
      debug_log("reload failed: " + ex.message());
      return;
    }
    sdr_solid = s0;
    sdr_zp = s1;
    sdr_shadow = s2;
    debug_log("triangles reload_shaders done");
  }
  public function uint get_postprocess_framebuffer(draw_step step) const
  {
    return 0U;
  }
  public function bool has_step(draw_step step) const
  {
    if (stype == 1) {
      if (
	step == draw_step_solid) {
	return true;
      }
    } else if (stype == 0) {
      if (
	step == draw_step_shadowmapping ||
	step == draw_step_zprepass ||
	step == draw_step_solid) {
	return true;
      }
    } else if (stype == 2) {
      /*
      // FIXME
      if (step == draw_step_shadowmapping) {
	return true;
      }
      */
      if (step == draw_step_shadowmapping ||
	step == draw_step_zprepass) {
	return true;
      }
      /*
      */
    }
    return false;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (step == draw_step_shadowmapping) {
      if (stype == 1) { return; }
      const sm_view = cam_df.light.to_mat4().inverse();
      const sm_vp = cam_df.sm_projection[iter] * sm_view;
      float scale = 1.0f / glc.shadowmap_distance;
      for (const i: 0 .. iter) {
	scale /= glc.shadowmap_scale;
      }
      glUseProgram(sdr_shadow.some->program);
      if (glc.light_fixed) {
	//debug_log("scale", scale);
	const trans = -cam_df.camera.position;
	glUniform3fv(sdr_shadow.some->u_trans, 1, trans.to_crawptr());
	glUniform1f(sdr_shadow.some->u_scale, scale);
      } else {
	glUniformMatrix4fv(sdr_shadow.some->u_shadowmap_vp, 1, 0,
	  sm_vp.to_crawptr());
      }
      aibuf.draw(*sdr_shadow.some, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    } else if (step == draw_step_zprepass) {
      if (stype == 1) { return; }
      // debug_log("zprepass " + to_string(stype));
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      mutable& sdr = *sdr_zp.some;
      glUseProgram(sdr.program);
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	  glc.enable_uniform_instancing);
    } else if (step == draw_step_solid) {
      if (stype == 2) { return; }
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
      mutable& sdr = *sdr_solid.some;
      // glActiveTexture(GL_TEXTURE0);
      // glBindTexture(GL_TEXTURE_2D, texture_dpat->texture_id.get());
      // glActiveTexture(GL_TEXTURE1);
      // glBindTexture(GL_TEXTURE_2D, texture_pmpat->texture_id.get());
      // glActiveTexture(GL_TEXTURE2);
      // glBindTexture(GL_TEXTURE_2D, texture_tilemap->texture_id.get());
      glUseProgram(sdr.program);
      if (glc.light_fixed) {
	glUniform3fv(sdr.u_light_dir, 1,
	  glm::make_vec3(0.0, 0.0, -1.0).to_crawptr());
      } else {
	glUniform3fv(sdr.u_light_dir, 1,
	  (cam_df.light.angle * glm::make_vec3(0.0, 0.0, 1.0)).to_crawptr());
      }
      glUniform3fv(sdr.u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, texture_dpat->texture_id.get());
      glActiveTexture(GL_TEXTURE1);
      glUniform1i(sdr.u_sampler_dpat, 0);
      glBindTexture(GL_TEXTURE_2D, texture_pmpat->texture_id.get());
      glUniform1i(sdr.u_sampler_pmpat, 1);
      glActiveTexture(GL_TEXTURE2);
      glBindTexture(GL_TEXTURE_2D, texture_tilemap->texture_id.get());
      glUniform1i(sdr.u_sampler_tilemap, 2);
      if (texture_env->texture_id.get() == 0) { // TODO: cleanup
	if (const te: res->textures["environ"]) {
	  texture_env = te;
	  // debug_log("texture_env", texture_env);
	}
      }
      if (texture_env->texture_id.get() != 0) {
	glActiveTexture(GL_TEXTURE3);
	glBindTexture(GL_TEXTURE_CUBE_MAP, texture_env->texture_id.get());
	glUniform1i(sdr.u_sampler_env, 3);
      }
      if (stype == 1) {
	if (m::is_true{raycast_cull_front}) {
	  glCullFace(GL_FRONT);
	}
	glActiveTexture(GL_TEXTURE4);
	glBindTexture(GL_TEXTURE_3D, texture_octree->texture_id.get());
	glUniform1i(sdr.u_sampler_octree, 4);
	glActiveTexture(GL_TEXTURE5);
	glBindTexture(GL_TEXTURE_3D, texture_voxtpat->texture_id.get());
	glUniform1i(sdr.u_sampler_voxtpat, 5);
	glActiveTexture(GL_TEXTURE6);
	glBindTexture(GL_TEXTURE_3D, texture_voxtmap->texture_id.get());
	glUniform1i(sdr.u_sampler_voxtmap, 6);
      }
      darrayst{int} sampler_smarr = darrayst{int}(
	static_cast{size_t}(glc.num_shadowmaps), 0);
      for (const i: 0 .. glc.num_shadowmaps) {
	glActiveTexture(static_cast{GLenum}(
	  static_cast{int}(GL_TEXTURE7) + i));
	glBindTexture(GL_TEXTURE_2D, smtex_arr[static_cast{size_t}(i)]);
	sampler_smarr[static_cast{size_t}(i)] = 7 + i;
      }
      glUniform1iv(sdr.u_sampler_sm, glc.num_shadowmaps,
	caddress(sampler_smarr[0]));
      if (glc.light_fixed) {
	glUniform1f(sdr.u_ndelta_scale,
	  static_cast{float}(8192 / cam_df.shadowmap_size)
	    * 0.02f / glc.shadowmap_distance);
      } else {
	const sm_view = cam_df.light.to_mat4().inverse();
	darrayst{glm::mat4} sm_vparr = darrayst{glm::mat4}(
	  static_cast{size_t}(glc.num_shadowmaps), glm::mat4());
	for (const i: 0 .. static_cast{size_t}(glc.num_shadowmaps)) {
	  sm_vparr[i] = cam_df.sm_projection[i] * sm_view;
	}
	glUniformMatrix4fv(sdr.u_shadowmap_vp, glc.num_shadowmaps, 0,
	  sm_vparr[0].to_crawptr());
	glUniform1f(sdr.u_ndelta_scale,
	  static_cast{float}(8192 / cam_df.shadowmap_size) * 0.02);
      }
      glUniform1f(sdr.u_exposure, cam_df.exposure);
      mutable opval = static_cast{int}(cam_df.option_value);
      opval /= 2;
      opval %= 4;
      glUniform1f(sdr.u_option_value, static_cast{float}(opval));
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0, vp.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
      if (stype == 1) {
	if (m::is_true{raycast_cull_front}) {
	  glCullFace(GL_BACK);
	}
	if (case edit_mode_ptr.some) {
	  edit_mode_ptr.some->on_frame();
	}
      }
    }
  }
  public function option{ptr{edit_mode_i}} get_edit_mode() const
  {
    return edit_mode_ptr;
  }
}

private function void prepare_voxel_tilemap(texture_data mutable& tpat,
  texture_data mutable& tmap, uint pattern_size, uint bshift,
  bool enable_calc_distance)
{
  debug_log("tmap 0,0,1", to_hexstring(tmap.get(0, 0, 1)));
  function void dump_cnt(texture_data const& t, string msg)
  {
    size_t sp_cnt = 0;
    size_t co_cnt = 0;
    size_t di_cnt = 0;
    size_t re_cnt = 0;
    for (const z: 0 .. t.depth) {
      for (const y: 0 .. t.height) {
	for (const x: 0 .. t.width) {
	  const v = t.get(x, y, z);
	  if ((v & 0xff000000) == 0x00000000) {
	    sp_cnt += 1;
	    if ((v & 0x00ffffff) != 0) {
	      di_cnt += 1;
	    }
	  } else if ((v & 0xff000000) == 0xff000000) {
	    co_cnt += 1;
	    // debug_log("co", x, y, z, to_hexstring(v));
	  } else if ((v & 0xff000000) == 0x01000000) {
	    re_cnt += 1;
	  } else {
	  }
	}
      }
    }
    debug_log(msg, t.width, t.height, t.depth);
    debug_log(msg, "sp_cnt", sp_cnt, "di_cnt", di_cnt, "co_cnt", co_cnt,
      "re_cnt", re_cnt);
  }
  dump_cnt(tmap, "tmap");
  dump_cnt(tpat, "tpat");
  // tmapのノード参照値を変換する。
  {
    uint s_l2 = pattern_size - bshift;
    uint s_mask = (1u << s_l2) - 1u;
    // 変換前のノード参照のxyzそれぞれのビット幅はs_l2になっている。
    // これをxyzそれぞれ8bitにする
    for (const z: 0 .. tmap.depth) {
      for (const y: 0 .. tmap.height) {
	for (const x: 0 .. tmap.width) {
	  const v = tmap.get(x, y, z);
	  if (!is_node_reference(v)) {
	    continue;
	  }
	  const nr = get_node_reference(v);
	  const nx = nr & s_mask;
	  const ny = (nr >> s_l2) & s_mask;
	  const nz = (nr >> (s_l2 * 2)) & s_mask;
	  const tnv = (nz << 16) | (ny << 8) | nx;
	  const tv = make_node_reference(tnv);
	  tmap.set(x, y, z, tv);
	}
      }
    }
  }
  /*
  for (const z: 0 .. 10u) {
    for (const y: 0 .. 10u) {
      for (const x: 0 .. 10u) {
	const v = tmap.get(x, y, z);
	debug_log("tmap", x, y, z, to_hexstring(v));
      }
    }
  }
  for (const z: 0 .. 10u) {
    for (const y: 0 .. 10u) {
      for (const x: 0 .. 10u) {
	const v = tpat.get(x, y, z);
	debug_log("tpat", x, y, z, to_hexstring(v));
      }
    }
  }
  */
  // tmapはタイル境界は無いので各ボクセルに全体の境界までの距離を埋め込む
  set_distance(tmap);
  // tpatはタイル境界までの距離を最大値とする。各タイルごとに個別に計算
  // const bshift = tpat.bshift;
  texture_data tile;
  tile.width = 1u << bshift;
  tile.height = 1u << bshift;
  tile.depth = 1u << bshift;
  tile.bshift = bshift;
  tile.data.resize(1u << (bshift * 3), 0u);
  for (const bx: 0 .. tpat.width >> bshift) {
    for (const by: 0 .. tpat.height >> bshift) {
      for (const bz: 0 .. tpat.depth >> bshift) {
	// copy to tile
	for (const x: 0 .. 1u << bshift) {
	  for (const y: 0 .. 1u << bshift) {
	    for (const z: 0 .. 1u << bshift) {
	      tile.set(x, y, z, tpat.get(
		(bx << bshift) + x,
		(by << bshift) + y,
		(bz << bshift) + z));
	    }
	  }
	}
	// set distance
	set_distance(tile);
	// copy back to tpat
	for (const x: 0 .. 1u << bshift) {
	  for (const y: 0 .. 1u << bshift) {
	    for (const z: 0 .. 1u << bshift) {
	      tpat.set(
		(bx << bshift) + x,
		(by << bshift) + y,
		(bz << bshift) + z,
		tile.get(x, y, z));
	    }
	  }
	}
      }
    }
  }
  dump_cnt(tmap, "tmap");
  dump_cnt(tpat, "tpat");
}

private function void prepare_texture_data(texture_data mutable& tcol,
  texture_data mutable& tdep, texture_data mutable& tmap)
{
  // generate tilemap
  tmap.width = 128;
  tmap.height = 128;
  tmap.data.resize(tmap.width * tmap.height, 0U);
  const rnd = make_rand_generator(333U);
  for (const x: 0 .. tmap.width) {
    for (const y: 0 .. tmap.height) {
      const v0 = rnd->generate() / 65536;
      const v1 = 1U + v0 % 2U;
      // const v2 = (v0 / 8) % 8;
      // const v1 = 1;
      const v2 = 0U;
      const v = v2 * 256U + v1;
      tmap.data[y * tmap.width + x] = static_cast{uint}(v);
    }
  }
  parallax_png_decode(tdep);
  set_normal_pattern(tdep, tcol);
  parallax_set_clearance(tdep);
}

private function void set_normal_pattern(texture_data const& tdep,
  texture_data mutable& tcol)
{
  function uint read_depth(int x, int y) {
    if (x < 0 || y < 0 || static_cast{uint}(x) >= tdep.width ||
      static_cast{uint}(y) >= tdep.height) {
      return 0;
    }
    return tdep.data[static_cast{uint}(y) * tdep.width + static_cast{uint}(x)];
  }
  for (const x : 0 .. tdep.width) {
    for (const y : 0 .. tdep.height) {
      const xi = static_cast{int}(x);
      const yi = static_cast{int}(y);
      const d0  = read_depth(xi, yi);
      const dlu = read_depth(xi - 1, yi - 1);
      const du  = read_depth(xi    , yi - 1);
      const dru = read_depth(xi + 1, yi - 1);
      const dl  = read_depth(xi - 1, yi    );
      const dr  = read_depth(xi + 1, yi    );
      const dld = read_depth(xi - 1, yi + 1);
      const dd  = read_depth(xi    , yi + 1);
      const drd = read_depth(xi + 1, yi + 1);
      function bool is_convex1(uint v0, uint v1, uint v2, uint v3) {
	return v0 > d0 && v1 <= d0 && v2 <= d0 && v3 <= d0;
      }
      function bool is_convex2(uint v0, uint v1, uint v2, uint v3) {
	return v0 > d0 && v1 > d0 && v2 <= d0 && v3 <= d0;
      }
      function bool is_flat4() {
	return du == d0 && dl == d0 && dr == d0 && dd == d0;
      }
      uint val;
      if (is_convex1(du, dl, dd, dr)) {
	val = 0x92; // convex upper
	// debug_log(x, y, "cu");
      } else if (is_convex1(dl, dd, dr, du)) {
	val = 0x74; // convex left
	// debug_log(x, y, "cl");
      } else if (is_convex1(dd, dr, du, dl)) {
	val = 0x72; // convex lower
	// debug_log(x, y, "cd");
      } else if (is_convex1(dr, du, dl, dd)) {
	val = 0x94; // convex right
	// debug_log(x, y, "cr");
      } else if (is_convex2(du, dl, dd, dr)) {
	val = 0x91; // convex left-upper
	// debug_log(x, y, "clu");
      } else if (is_convex2(dl, dd, dr, du)) {
	val = 0x97; // convex left-lower
	// debug_log(x, y, "cld");
      } else if (is_convex2(dd, dr, du, dl)) {
	val = 0x95; // convex right-lower
	// debug_log(x, y, "crd");
      } else if (is_convex2(dr, du, dl, dd)) {
	val = 0x93; // convex right-upper
	// debug_log(x, y, "cru");
      } else if (is_flat4()) {
	if (is_convex1(dlu, dld, drd, dru)) {
	  val = 0x75; // concave right-lower
	} else if (is_convex1(dld, drd, dru, dlu)) {
	  val = 0x73; // concave right-upper
	} else if (is_convex1(drd, dru, dlu, dld)) {
	  val = 0x71; // concave left-upper
	} else if (is_convex1(dru, dlu, dld, drd)) {
	  val = 0x77; // concave left-lower
	}
      }
      // debug_log(x, y, val);
      tcol.data[y * tcol.width + x] &= 0xffffffU;
      tcol.data[y * tcol.width + x] |= val << 24;
    }
  }
}

private function void parallax_png_decode(texture_data mutable& td)
{
  for (const i, mutable& v: td.data) {
    const depth = (v & 0xff) / 1;
    v = depth << 16;
  }
}

private function void parallax_set_clearance(texture_data mutable& td)
{
  mutable& data = td.data;
  uint const tile_size = 64;
  for (const by : 0 .. td.height / tile_size) {
    for (const bx : 0 .. td.width / tile_size) {
      for (const y : 0 .. tile_size) {
	for (const x : 0 .. tile_size) {
	  const offset = (by * tile_size + y) * td.height
	    + (bx * tile_size + x);
	  const v0 = data[offset];
	  const depth0 = (v0 >> 16) & 0xffU;
	  // clearance values
	  uint c_nn = min(x, y);
	  uint c_np = min(x, tile_size - 1 - y);
	  uint c_pn = min(tile_size - 1 - x, y);
	  uint c_pp = min(tile_size - 1 - x, tile_size - 1 - y);
	  const y1_min = (y >= 16) ? y - 16 : 0;
	  const y1_max = (y + 16 < tile_size) ? y + 16 : tile_size;
	  const x1_min = (x >= 16) ? x - 16 : 0;
	  const x1_max = (x + 16 < tile_size) ? x + 16 : tile_size;
	  // TODO: too slow
	  for (const y1 : y1_min .. y1_max) {
	    for (const x1 : x1_min .. x1_max) {
	      const offset1 = (by * tile_size + y1) * td.height
		+ (bx * tile_size + x1);
	      const v1 = data[offset1];
	      const depth1 = v1 >> 16 & 0xffU;
	      if (depth1 >= depth0) {
		continue;
	      }
	      // ok to wrap uint values
	      uint nn = max(x - x1, y - y1) - 1;
	      c_nn = min(c_nn, nn);
	      uint np = max(x - x1, y1 - y) - 1;
	      c_np = min(c_np, np);
	      uint pn = max(x1 - x, y - y1) - 1;
	      c_pn = min(c_pn, pn);
	      uint pp = max(x1 - x, y1 - y) - 1;
	      c_pp = min(c_pp, pp);
	    }
	  }
	  c_nn = min(c_nn, 15);
	  c_np = min(c_np, 15);
	  c_pn = min(c_pn, 15);
	  c_pp = min(c_pp, 15);
	  // W = unused(8), Z = depth(8), Y = CNN(4) CNP(4), X = CPN(4) CPP(4)
	  data[offset] = (depth0 << 16) |
	    (c_nn << 12) | (c_np << 8) | (c_pn << 4) | (c_pp << 0);
	  if (by == 0 && bx == 0) {
	    // debug_log("cl", x, y, depth0, to_hexstring(data[offset]));
	  }
	}
      }
    }
  }
}

private threaded function void prepare_instance_data_triangles(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  buffer_append(idata.instance_buffer, sn.trans); /* model matrix */
}

private threaded function {tattr} void
dgf_polygon_filler_tattr(ptr{vertices} const& vptr, bool override_uvw,
  bool flat_flag, poly_t const& poly, mesh_index const& mp)
{
  dgf_fill_tattr_internal{tattr}(vptr, flat_flag, override_uvw, poly, mp);
}

private threaded function {tattr} dgf_filler
make_dgf_polygon_filler(ptr{vertices} const& vptr, bool override_uvw)
{
  return make_callable_ptr{dgf_polygon_filler_tattr{tattr}, 2}(vptr,
    override_uvw);
}

private metafunction shadowmap_shader_ptr
  ptr{glshader{
    shadowmap_uniforms, triangles_instance_attributes,
    shadowmap_vertex_attributes}};

private function shadowmap_shader_ptr
init_shadowmap_shader(shader_config const& g, int stype)
{
  tree_map{string, string} bnd;
  bnd["stype"] = to_string(stype);
  const v = load_shader_program(g, bnd, "triangles-sm.vsh");
  const f = load_shader_program(g, bnd, "triangles-sm.fsh");
  //debug_log("shadowmap_vsh", v);
  //debug_log("shadowmap_fsh", f);
  return make_glshader_ptr{
    shadowmap_uniforms,
    triangles_instance_attributes,
    shadowmap_vertex_attributes
  }(v, f, "model_matrix", g.debug_level);
}

private metafunction zprepass_shader_ptr
  ptr{glshader{
    zprepass_uniforms, triangles_instance_attributes,
    zprepass_vertex_attributes}};

private function zprepass_shader_ptr
init_zprepass_shader(shader_config const& g, int stype)
{
  tree_map{string, string} bnd;
  bnd["stype"] = to_string(stype);
  const v = load_shader_program(g, bnd, "triangles-zp.vsh");
  const f = load_shader_program(g, bnd, "triangles-zp.fsh");
  //debug_log("zp_vsh", v);
  //debug_log("zp_fsh", f);
  return make_glshader_ptr{
    zprepass_uniforms,
    triangles_instance_attributes,
    zprepass_vertex_attributes
  }(v, f, "model_matrix", g.debug_level);
}

private metafunction triangles_shader_ptr
  ptr{glshader{
    triangles_uniforms, triangles_instance_attributes,
    triangles_vertex_attributes}};

private function triangles_shader_ptr
init_triangles_shader(shader_config const& g, int stype, uint octree_bshift,
  uint octree_wh_l2, uint octree_d_l2)
{
  const smsz = g.num_shadowmaps_str();
  tree_map{string, string} bnd;
  bnd["stype"] = to_string(stype);
  bnd["smsz"] = g.num_shadowmaps_str();
  bnd["octree_block_factor"] = to_string(
    static_cast{float}(1u << octree_bshift));
  const wh_s = "1.0 / " + to_string(static_cast{float}(
    1 << (octree_bshift + octree_wh_l2)));
  const d_s = "1.0 / " + to_string(static_cast{float}(
    1 << (octree_bshift + octree_d_l2)));
  debug_log("scale: ", wh_s, wh_s, d_s);
  bnd["octree_texture_scale"] = "vec3(" + wh_s + "," + wh_s + "," + d_s + ")";
  // bnd["octree_size"] = to_string(1u << octree_size_l2);
  bnd["raycast_cull_front"] = to_string(raycast_cull_front);
  bnd["update_frag_depth"] = to_string(
    g.conf.get("update_frag_depth", 0, 1, 1));
  const v = triangles_shader_vert(g, bnd);
  const f = triangles_shader_frag(g, bnd);
  return
    make_glshader_ptr{
      triangles_uniforms,
      triangles_instance_attributes,
      triangles_vertex_attributes
    }(v, f, "model_matrix", g.debug_level);
}

private function string
triangles_shader_vert(shader_config const& g,
  tree_map{string, string} const& bnd)
{
  const v = load_shader_program(g, bnd, "triangles.vsh");
  //debug_log("triangles_vsh", v);
  return v;
}

private function string triangles_shader_frag(shader_config const& g,
  tree_map{string, string} const& bnd)
{
  const f = load_shader_program(g, bnd, "triangles.fsh");
  //debug_log("triangles fsh", f);
  return f;
}

