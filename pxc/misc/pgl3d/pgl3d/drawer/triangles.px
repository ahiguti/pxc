private threaded namespace pgl3d::drawer::triangles "export-unsafe";
public import common -;
public import pgl3d::drawer::internal -;
public import meta m;

private tsvaluetype struct triangles_uniforms()
{
  public glm::mat4 view_projection_matrix;
  public int sampler_dpat;
  public int sampler_pmpat;
  public int sampler_tilemap;
  public int sampler_env;
  public int sampler_sm; // array
//  public int sampler_sm1;
//  public int sampler_sm2;
//  public int sampler_sm3;
  public glm::vec3 camera_pos;
  public glm::vec3 light_dir;
  public float light_on;
  public float ndelta_scale; // 0.02 / 40. if light_fixed, 0.02 otherwise
  public glm::mat4 shadowmap_vp; // array
  // public glm::mat4 shadowmap_vp1;
  // public glm::mat4 shadowmap_vp2;
  // public glm::mat4 shadowmap_vp3;
  public float option_value;
}

private tsvaluetype struct triangles_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 uv_aabb;
}

private tsvaluetype struct zprepass_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 uv_aabb;
}

private tsvaluetype struct shadowmap_vertex_attributes()
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
  public glm::vec4 uv_aabb;
}

private tsvaluetype struct triangles_instance_attributes()
{
  public glm::mat4 model_matrix;
}

private tsvaluetype struct zprepass_uniforms()
{
  public glm::mat4 view_projection_matrix;
}

private tsvaluetype struct shadowmap_uniforms()
{
  public glm::mat4 shadowmap_vp;
  public glm::vec3 trans; // used if light_fixed
  public float scale;     // used if light_fixed
}

public struct drawer_triangles(shader_config const& glc,
  resource_pool_ptr const& res0, int opt0)
<pgldrawer_i>
{
  metafunction tattr triangles_vertex_attributes;
  ptr{resource_pool} res = pointer_downcast{ptr{resource_pool}}(res0);
  int const opt = opt0;
  triangles_shader_ptr const sdr_solid = init_triangles_shader(glc, opt);
  zprepass_shader_ptr const sdr_zp = init_zprepass_shader(glc, opt);
  shadowmap_shader_ptr const sdr_shadow = init_shadowmap_shader(glc, opt);
  ptr{gl_texture} texture_dpat = make_ptr{gl_texture}();
  ptr{gl_texture} texture_pmpat = make_ptr{gl_texture}();
  ptr{gl_texture} texture_tilemap = make_ptr{gl_texture}();
  ptr{gl_texture} texture_env = make_ptr{gl_texture}();
  init();
  private function void init()
  {
  /*
    load_gl_texture_tilemap(*texture_dpat, *texture_pmpat, *texture_tilemap,
      "dpat.png", "pmpat.png");
  */
    const tex_col = load_texture_data("default-color.png");
    const tex_dep = load_texture_data("default-depth.png");
    const tex_tilemap = make_ptr{texture_data}();
    prepare_texture_data(*tex_col, *tex_dep, *tex_tilemap);
    texture_data_to_gl_texture_2d(*texture_dpat, tex_col);
    texture_data_to_gl_texture_2d(*texture_pmpat, tex_dep);
    texture_data_to_gl_texture_2d(*texture_tilemap, tex_tilemap);
    res->textures.insert("tile_color", texture_dpat);
    res->textures.insert("tile_parallax", texture_pmpat);
    res->textures.insert("tile", texture_tilemap);
  }
  public function string get_vbid_name() const {
    return "vbid_triangles_" + to_string(opt);
  }
  public function string get_main_vbid_name() const {
    return "vbid_triangles_0";
  }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_triangles}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, opt != 0);
  }
  public function string builtin_vertex_set_name() const { return ""; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const { }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_polygon_filler{tattr}(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    if (name == "main") {
      r.surface_w = texture_dpat->surface_w;
      r.surface_h = texture_dpat->surface_h;
    }
    return r;
  }
  public function void resize_screen(shader_config const& glc, int width,
    int height)
  {
  }
  public function uint get_postprocess_framebuffer() const
  {
    return 0U;
  }
  public function bool has_step(draw_step step) const
  {
    if (step == draw_step_shadowmapping ||
      step == draw_step_zprepass ||
      step == draw_step_solid) {
      return true;
    }
    return false;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vertex_buffer_id bo_id,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (step == draw_step_shadowmapping) {
      const sm_view = cam_df.light.to_mat4().inverse();
      const sm_vp = cam_df.sm_projection[iter] * sm_view;
      float scale = 1.0f / glc.shadowmap_distance;
      for (const i: 0 .. iter) {
	scale /= glc.shadowmap_scale;
      }
      glUseProgram(sdr_shadow->program);
      if (glc.light_fixed) {
	//debug_log("scale", scale);
	const trans = -cam_df.camera.position;
	glUniform3fv(sdr_shadow->u_trans, 1, trans.to_crawptr());
	glUniform1f(sdr_shadow->u_scale, scale);
      } else {
	glUniformMatrix4fv(sdr_shadow->u_shadowmap_vp, 1, 0,
	  sm_vp.to_crawptr());
      }
      aibuf.draw(*sdr_shadow, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    } else if (step == draw_step_zprepass) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      mutable& sdr = *sdr_zp;
      glUseProgram(sdr.program);
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	  glc.enable_uniform_instancing);
    } else if (step == draw_step_solid) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
      mutable& sdr = *sdr_solid;
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, texture_dpat->texture_id.get());
      /*
      // FIXME: enable
      glActiveTexture(GL_TEXTURE1);
      glBindTexture(GL_TEXTURE_2D, texture_pmpat.texture_id.get());
      glActiveTexture(GL_TEXTURE2);
      glBindTexture(GL_TEXTURE_2D, texture_tilemap.texture_id.get());
      */
      glUseProgram(sdr.program);
      if (glc.light_fixed) {
	glUniform3fv(sdr.u_light_dir, 1,
	  glm::make_vec3(0.0, 0.0, -1.0).to_crawptr());
      } else {
	glUniform3fv(sdr.u_light_dir, 1,
	  (cam_df.light.angle * glm::make_vec3(0.0, 0.0, 1.0)).to_crawptr());
      }
      glUniform3fv(sdr.u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, texture_dpat->texture_id.get());
      glActiveTexture(GL_TEXTURE1);
      glUniform1i(sdr.u_sampler_dpat, 0);
      glBindTexture(GL_TEXTURE_2D, texture_pmpat->texture_id.get());
      glUniform1i(sdr.u_sampler_pmpat, 1);
      glActiveTexture(GL_TEXTURE2);
      glBindTexture(GL_TEXTURE_2D, texture_tilemap->texture_id.get());
      glUniform1i(sdr.u_sampler_tilemap, 2);
      if (texture_env->texture_id.get() == 0) { // TODO: cleanup
	if (const te: res->textures["environ"]) {
	  texture_env = te;
	  // debug_log("texture_env", texture_env);
	}
      }
      if (texture_env->texture_id.get() != 0) {
	glActiveTexture(GL_TEXTURE3);
	glBindTexture(GL_TEXTURE_CUBE_MAP, texture_env->texture_id.get());
	glUniform1i(sdr.u_sampler_env, 3);
      }
      darrayst{int} sampler_smarr = darrayst{int}(
	static_cast{size_t}(glc.num_shadowmaps), 0);
      for (const i: 0 .. glc.num_shadowmaps) {
	glActiveTexture(static_cast{GLenum}(
	  static_cast{int}(GL_TEXTURE4) + i));
	glBindTexture(GL_TEXTURE_2D, smtex_arr[static_cast{size_t}(i)]);
	sampler_smarr[static_cast{size_t}(i)] = 4 + i;
      }
      glUniform1iv(sdr.u_sampler_sm, glc.num_shadowmaps,
	caddress(sampler_smarr[0]));
      if (glc.light_fixed) {
	glUniform1f(sdr.u_ndelta_scale,
	  static_cast{float}(8192 / cam_df.shadowmap_size)
	    * 0.02f / glc.shadowmap_distance);
      } else {
	const sm_view = cam_df.light.to_mat4().inverse();
	darrayst{glm::mat4} sm_vparr = darrayst{glm::mat4}(
	  static_cast{size_t}(glc.num_shadowmaps), glm::mat4());
	for (const i: 0 .. static_cast{size_t}(glc.num_shadowmaps)) {
	  sm_vparr[i] = cam_df.sm_projection[i] * sm_view;
	}
	glUniformMatrix4fv(sdr.u_shadowmap_vp, glc.num_shadowmaps, 0,
	  sm_vparr[0].to_crawptr());
	glUniform1f(sdr.u_ndelta_scale,
	  static_cast{float}(8192 / cam_df.shadowmap_size) * 0.02);
      }
      mutable opval = static_cast{int}(cam_df.option_value);
      opval /= 2;
      opval %= 4;
      glUniform1f(sdr.u_option_value, static_cast{float}(opval));
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0, vp.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, bo_id, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
}

private function void prepare_texture_data(texture_data mutable& tcol,
  texture_data mutable& tdep, texture_data mutable& tmap)
{
  // generate tilemap
  tmap.width = 128;
  tmap.height = 128;
  tmap.data.resize(tmap.width * tmap.height, 0U);
  const rnd = make_rand_generator(333U);
  for (const x: 0 .. tmap.width) {
    for (const y: 0 .. tmap.height) {
      const v0 = rnd->generate() / 65536;
      const v1 = 1U + v0 % 2U;
      // const v2 = (v0 / 8) % 8;
      // const v1 = 1;
      const v2 = 0U;
      const v = v2 * 256U + v1;
      tmap.data[y * tmap.width + x] = static_cast{uint}(v);
    }
  }
  parallax_png_decode(tdep);
  set_normal_pattern(tdep, tcol);
  parallax_set_clearance(tdep);
}

private function void set_normal_pattern(texture_data const& tdep,
  texture_data mutable& tcol)
{
  function uint read_depth(int x, int y) {
    if (x < 0 || y < 0 || static_cast{uint}(x) >= tdep.width ||
      static_cast{uint}(y) >= tdep.height) {
      return 0;
    }
    return tdep.data[static_cast{uint}(y) * tdep.width + static_cast{uint}(x)];
  }
  for (const x : 0 .. tdep.width) {
    for (const y : 0 .. tdep.height) {
      const xi = static_cast{int}(x);
      const yi = static_cast{int}(y);
      const d0  = read_depth(xi, yi);
      const dlu = read_depth(xi - 1, yi - 1);
      const du  = read_depth(xi    , yi - 1);
      const dru = read_depth(xi + 1, yi - 1);
      const dl  = read_depth(xi - 1, yi    );
      const dr  = read_depth(xi + 1, yi    );
      const dld = read_depth(xi - 1, yi + 1);
      const dd  = read_depth(xi    , yi + 1);
      const drd = read_depth(xi + 1, yi + 1);
      function bool is_convex1(uint v0, uint v1, uint v2, uint v3) {
	return v0 > d0 && v1 <= d0 && v2 <= d0 && v3 <= d0;
      }
      function bool is_convex2(uint v0, uint v1, uint v2, uint v3) {
	return v0 > d0 && v1 > d0 && v2 <= d0 && v3 <= d0;
      }
      function bool is_flat4() {
	return du == d0 && dl == d0 && dr == d0 && dd == d0;
      }
      uint val;
      if (is_convex1(du, dl, dd, dr)) {
	val = 0x92; // convex upper
	// debug_log(x, y, "cu");
      } else if (is_convex1(dl, dd, dr, du)) {
	val = 0x74; // convex left
	// debug_log(x, y, "cl");
      } else if (is_convex1(dd, dr, du, dl)) {
	val = 0x72; // convex lower
	// debug_log(x, y, "cd");
      } else if (is_convex1(dr, du, dl, dd)) {
	val = 0x94; // convex right
	// debug_log(x, y, "cr");
      } else if (is_convex2(du, dl, dd, dr)) {
	val = 0x91; // convex left-upper
	// debug_log(x, y, "clu");
      } else if (is_convex2(dl, dd, dr, du)) {
	val = 0x97; // convex left-lower
	// debug_log(x, y, "cld");
      } else if (is_convex2(dd, dr, du, dl)) {
	val = 0x95; // convex right-lower
	// debug_log(x, y, "crd");
      } else if (is_convex2(dr, du, dl, dd)) {
	val = 0x93; // convex right-upper
	// debug_log(x, y, "cru");
      } else if (is_flat4()) {
	if (is_convex1(dlu, dld, drd, dru)) {
	  val = 0x75; // concave right-lower
	} else if (is_convex1(dld, drd, dru, dlu)) {
	  val = 0x73; // concave right-upper
	} else if (is_convex1(drd, dru, dlu, dld)) {
	  val = 0x71; // concave left-upper
	} else if (is_convex1(dru, dlu, dld, drd)) {
	  val = 0x77; // concave left-lower
	}
      }
      // debug_log(x, y, val);
      tcol.data[y * tcol.width + x] &= 0xffffffU;
      tcol.data[y * tcol.width + x] |= val << 24;
    }
  }
}

private function void parallax_png_decode(texture_data mutable& td)
{
  for (const i, mutable& v: td.data) {
    const depth = (v & 0xff) / 8;
    v = depth << 16;
  }
}

private function void parallax_set_clearance(texture_data mutable& td)
{
  mutable& data = td.data;
  uint const tile_size = 64;
  for (const by : 0 .. td.height / tile_size) {
    for (const bx : 0 .. td.width / tile_size) {
      for (const y : 0 .. tile_size) {
	for (const x : 0 .. tile_size) {
	  const offset = (by * tile_size + y) * td.height
	    + (bx * tile_size + x);
	  const v0 = data[offset];
	  const depth0 = (v0 >> 16) & 0xffU;
	  // clearance values
	  uint c_nn = min(x, y);
	  uint c_np = min(x, tile_size - 1 - y);
	  uint c_pn = min(tile_size - 1 - x, y);
	  uint c_pp = min(tile_size - 1 - x, tile_size - 1 - y);
	  const y1_min = (y >= 16) ? y - 16 : 0;
	  const y1_max = (y + 16 < tile_size) ? y + 16 : tile_size;
	  const x1_min = (x >= 16) ? x - 16 : 0;
	  const x1_max = (x + 16 < tile_size) ? x + 16 : tile_size;
	  // TODO: too slow
	  for (const y1 : y1_min .. y1_max) {
	    for (const x1 : x1_min .. x1_max) {
	      const offset1 = (by * tile_size + y1) * td.height
		+ (bx * tile_size + x1);
	      const v1 = data[offset1];
	      const depth1 = v1 >> 16 & 0xffU;
	      if (depth1 >= depth0) {
		continue;
	      }
	      // ok to wrap uint values
	      uint nn = max(x - x1, y - y1) - 1;
	      c_nn = min(c_nn, nn);
	      uint np = max(x - x1, y1 - y) - 1;
	      c_np = min(c_np, np);
	      uint pn = max(x1 - x, y - y1) - 1;
	      c_pn = min(c_pn, pn);
	      uint pp = max(x1 - x, y1 - y) - 1;
	      c_pp = min(c_pp, pp);
	    }
	  }
	  c_nn = min(c_nn, 15);
	  c_np = min(c_np, 15);
	  c_pn = min(c_pn, 15);
	  c_pp = min(c_pp, 15);
	  // W = unused(8), Z = depth(8), Y = CNN(4) CNP(4), X = CPN(4) CPP(4)
	  data[offset] = (depth0 << 16) |
	    (c_nn << 12) | (c_np << 8) | (c_pn << 4) | (c_pp << 0);
	  if (by == 0 && bx == 0) {
	    // debug_log("cl", x, y, depth0, to_hexstring(data[offset]));
	  }
	}
      }
    }
  }
}

private threaded function void prepare_instance_data_triangles(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  buffer_append(idata.instance_buffer, sn.trans); /* model matrix */
}

private threaded function {tattr} void
dgf_polygon_filler_tattr(ptr{vertices} const& vptr, bool flat_flag,
  poly_t const& poly, mesh_index const& mp)
{
  dgf_fill_tattr_internal{tattr}(vptr, flat_flag, poly, mp);
}

private threaded function {tattr} dgf_filler
make_dgf_polygon_filler(ptr{vertices} const& vptr)
{
  return make_callable_ptr{dgf_polygon_filler_tattr{tattr}, 1}(vptr);
}

private metafunction shadowmap_shader_ptr
  ptr{glshader{
    shadowmap_uniforms, triangles_instance_attributes,
    shadowmap_vertex_attributes}};

private function shadowmap_shader_ptr
init_shadowmap_shader(shader_config const& g, int opt)
{
  tree_map{string, string} bnd;
  bnd["opt"] = to_string(opt);
  const v = load_shader_program(g, bnd, "triangles-sm.vsh");
  const f = load_shader_program(g, bnd, "triangles-sm.fsh");
/*
*/
/*
  string v;
  v += g.prepend();
  if (g.light_fixed) {
    v += "uniform vec3 trans;\n";
    v += "uniform float scale;\n";
  } else {
    v += "uniform mat4 shadowmap_vp;\n";
  }
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += g.vert_in() + "vec3 position;\n";
  if (opt != 0) {
    v += g.vert_in() + "vec3 uvw;\n";
    v += g.vert_out() + "vec3 vary_uvw;\n";
  }
  if (!g.enable_depth_texture) {
    v += g.vert_out() + "vec4 vary_smpos;\n";
  }
  v += "void main(void) {\n";
  if (g.light_fixed) {
    v += "vec4 p = ";
    v += g.instance_attr("model_matrix");
    v += "  * vec4(position, 1.0);\n";
    v += "vec3 p1 = p.xyz + trans;\n";
    v += "p1 *= scale;\n";
    // v += "p1.z = -p1.z;\n";
    v += "p = vec4(p1, 1.0);\n";
    v += "gl_Position = p;\n";
  } else {
    v += "vec4 p = shadowmap_vp * (";
    v += g.instance_attr("model_matrix");
    v += "  * vec4(position, 1.0));\n";
    v += "gl_Position = p;\n";
  }
  if (!g.enable_depth_texture) {
    v += "vary_smpos = p;\n";
  }
  if (opt != 0) {
    v += "vary_uvw = uvw;\n";
  }
  v += "}\n";
  string f;
  if (g.enable_depth_texture && opt == 0) {
    f += g.empty_shader_frag();
  } else {
    f += g.prepend();
    if (opt != 0) {
      f += g.frag_in() + "vec3 vary_uvw;\n";
    }
    if (!g.enable_depth_texture) {
      f += g.frag_in() + "vec4 vary_smpos;\n";
      f += g.decl_fragcolor();
    }
    f += "void main(void) {\n";
    // if (opt != 0) {
    //   if (g.enable_normalmapping) {
	//f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
	//f += "vec2 uv_tm = floor(uv0 / tile_size);\n"; // tilemap coordinate
	//f += "vec2 uv_tmfr = uv0 / tile_size - uv_tm;\n";
	  //// coordinate inside a tile (0, 1)
	//f += "vec2 uvp = uv_tmfr - 0.5;\n";
	//f += "if (dot(uvp, uvp) < 0.125) { discard; }\n";
      //}
    //}
    if (g.enable_vsm) {
      f += "  vec4 p = vary_smpos;\n";
      f += "  float pz = (p.z/p.w + 1.0) / 2.0;\n"; // TODO: calc in vsh
      f += g.fragcolor() + "= vec4(pz, pz * pz, 0.0, 0.0);\n";
    } else if (!g.enable_depth_texture) {
      f += "  vec4 p = vary_smpos;\n";
      f += "  float pz = (p.z/p.w + 1.0) / 2.0;\n"; // TODO: calc in vsh
      // TODO: vectorize
      f += "  float z = pz * 256.0;\n"; // [0.0, 256.0]
      f += "  float z0 = floor(z);\n"; // [0, 256]
      f += "  z = (z - z0) * 256.0;\n"; // [0.0, 256.0)
      f += "  float z1 = floor(z);\n"; // [0, 256)
      f += "  z = (z - z1) * 256.0;\n"; // [0.0, 256.0)
      f += "  float z2 = floor(z);\n";  // [0, 256)
      f += g.fragcolor() + "= vec4(z0/255.0, z1/255.0, z2/255.0, 1.0);\n";
    }
    f += "}\n";
  }
*/
debug_log("shadowmap_vsh", v);
debug_log("shadowmap_fsh", f);
  return make_glshader_ptr{
    shadowmap_uniforms,
    triangles_instance_attributes,
    shadowmap_vertex_attributes
  }(v, f, "model_matrix", g.debug_level);
}

private metafunction zprepass_shader_ptr
  ptr{glshader{
    zprepass_uniforms, triangles_instance_attributes,
    zprepass_vertex_attributes}};

private function zprepass_shader_ptr
init_zprepass_shader(shader_config const& g, int opt)
{
  tree_map{string, string} bnd;
  bnd["opt"] = to_string(opt);
  const v = load_shader_program(g, bnd, "triangles-zp.vsh");
  const f = load_shader_program(g, bnd, "triangles-zp.fsh");
/*
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += g.vert_in() + "vec3 position;\n";
  if (opt != 0) {
    v += g.vert_in() + "vec3 uvw;\n";
    v += g.vert_out() + "vec3 vary_uvw;\n";
  }
  v += "void main(void) {\n";
  v += "vec4 gpos4 = " + g.instance_attr("model_matrix");
  v += "  * vec4(position, 1.0);\n";
  v += "gl_Position = view_projection_matrix * gpos4;\n";
  if (opt != 0) {
    v += "vary_uvw = uvw;\n";
  }
  v += "}\n";
  string f;
  if (opt == 0) {
    f = g.empty_shader_frag();
  } else {
    f += g.prepend();
    f += g.frag_in() + "vec3 vary_uvw;\n";
    // f += g.decl_fragcolor();
    f += "void main(void) {\n";
    /*
    if (g.enable_normalmapping) {
      f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
      f += "vec2 uv_tm = floor(uv0 / tile_size);\n"; // tilemap coordinate
      f += "vec2 uv_tmfr = uv0 / tile_size - uv_tm;\n";
	// coordinate inside a tile (0, 1)
      f += "vec2 p = uv_tmfr - 0.5;\n";
      f += "if (dot(p, p) < 0.125) { discard; }\n";
    }
    *
    f += "}\n";
  }
*/
debug_log("zp_vsh", v);
debug_log("zp_fsh", f);
  return make_glshader_ptr{
    zprepass_uniforms,
    triangles_instance_attributes,
    zprepass_vertex_attributes
  }(v, f, "model_matrix", g.debug_level);
}

private metafunction triangles_shader_ptr
  ptr{glshader{
    triangles_uniforms, triangles_instance_attributes,
    triangles_vertex_attributes}};

private function triangles_shader_ptr
init_triangles_shader(shader_config const& g, int opt)
{
  const v = triangles_shader_vert(g, opt);
  const f = triangles_shader_frag(g, opt);
  return
    make_glshader_ptr{
      triangles_uniforms,
      triangles_instance_attributes,
      triangles_vertex_attributes
    }(v, f, "model_matrix", g.debug_level);
}

private function string
triangles_shader_vert(shader_config const& g, int opt)
{
  tree_map{string, string} bnd;
  bnd["smsz"] = g.num_shadowmaps_str();
  const v = load_shader_program(g, bnd, "triangles.vsh");
/*
  const smsz = g.num_shadowmaps_str();
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  if (g.light_fixed) {
    v += "uniform vec3 camera_pos;\n";
  } else {
    v += "uniform mat4 shadowmap_vp["+smsz+"];\n";
  }
  v += g.decl_instance_attr("mat4", "model_matrix");
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec3 normal;\n";
  v += g.vert_in() + "vec3 tangent;\n";
  v += g.vert_in() + "vec3 uvw;\n";
  v += g.vert_in() + "vec4 uv_aabb;\n";
  v += g.vert_out() + "vec3 vary_position;\n";
  v += g.vert_out() + "vec3 vary_normal;\n";
  v += g.vert_out() + "vec3 vary_tangent;\n";
  v += g.vert_out() + "vec3 vary_binormal;\n";
  v += g.vert_out() + "vec3 vary_uvw;\n";
  v += g.vert_out() + "vec4 vary_uv_aabb;\n";
  if (g.enable_shadowmapping) {
    if (!g.light_fixed) {
      v += g.vert_out() + "vec3 vary_smposa["+smsz+"];\n";
      v += "uniform float ndelta_scale;\n"; // 0.02
    }
  }
  v += "void main(void) {\n";
  v += "  mat4 mm = "
    + g.instance_attr("model_matrix")
    + ";\n";
  v += "  vec4 gpos4 = mm * vec4(position, 1.0);\n";
  v += "  gl_Position = view_projection_matrix * gpos4;\n";
  if (g.is_gl3_or_gles3()) {
    v += "  mat3 normal_matrix = mat3(mm);\n";
  } else {
    v += "  mat3 normal_matrix = mat3(mm[0].xyz, mm[1].xyz, mm[2].xyz);\n";
  }
  v += "  vary_position = gpos4.xyz / gpos4.w;\n";
  v += "  vary_normal = normal_matrix * normal;\n";
  v += "  vary_tangent = normal_matrix * tangent;\n";
  v += "  vary_uvw = uvw;\n";
  v += "  vary_binormal = cross(vary_normal, vary_tangent);\n";
  v += "  vary_uv_aabb = uv_aabb;\n";
  if (g.enable_shadowmapping) {
    if (!g.light_fixed) {
      v += "  vec3 ndelta = mat3(shadowmap_vp[0]) * vary_normal ";
      v += "    * ndelta_scale;\n"; // 0.02
      v += "  vec4 p;\n";
      v += "  vec4 ngpos4 = vec4(vary_position, 1.0);\n";
      int den = 1;
      for (int i: 0 .. g.num_shadowmaps) {
	const i_s = to_string(i);
	const den_s = to_string(den);
	v += "  p = shadowmap_vp["+i_s+"] * ngpos4;\n";
	v += "  vary_smposa["+i_s+"] = p.xyz / p.w + ndelta / "+den_s+".;\n";
	den *= 3;
      }
    }
  }
  v += "}\n";
*/
debug_log("triangles_vsh", v);
  return v;
}

private function string triangles_shader_frag(shader_config const& g, int opt)
{
  bool enable_macos_nvidia_wa = false;
  if (m::is_true{is_macos}) {
    string verstr = cubptr_to_string(glGetString_nocheck(GL_VERSION));
    string vn0;
    string vn1;
    string_split{' '}(verstr, vn0, vn1);
    string s = vn1[0 .. 6];
    if (s == "NVIDIA" && g.enable_macos_nvidia_wa) {
      enable_macos_nvidia_wa = true;
      sdllog("macos nvidia workaround enabled");
    }
  }
  const smsz = g.num_shadowmaps_str();
  tree_map{string, string} bnd;
  bnd["smsz"] = g.num_shadowmaps_str();
  bnd["opt"] = to_string(opt);
  bnd["enable_macos_nvidia_wa"] = to_string(enable_macos_nvidia_wa);
  const f = load_shader_program(g, bnd, "triangles.fsh");
/*
  string f;
  f += g.prepend();
  f += "const float tile_size = 64.0;\n";
  f += "const float tilemap_size = 128.0;\n";
  f += "const float tiletex_size = 1024.0;\n";
  f += "uniform sampler2D sampler_dpat;\n";
  f += "uniform sampler2D sampler_pmpat;\n";
  f += "uniform sampler2D sampler_tilemap;\n";
  f += "uniform samplerCube sampler_env;\n";
  if (g.enable_sampler2dshadow) {
    f += "uniform sampler2DShadow sampler_sm["+smsz+"];\n";
  } else {
    f += "uniform sampler2D sampler_sm["+smsz+"];\n";
  }
  f += "uniform vec3 camera_pos;\n";
  f += "uniform vec3 light_dir;\n";
  f += "uniform float light_on;\n";
  f += "uniform float option_value;\n";
  f += g.frag_in() + "vec3 vary_position;\n";
  f += g.frag_in() + "vec3 vary_normal;\n";
  f += g.frag_in() + "vec3 vary_tangent;\n";
  f += g.frag_in() + "vec3 vary_binormal;\n";
  f += g.frag_in() + "vec3 vary_uvw;\n";
  f += g.frag_in() + "vec4 vary_uv_aabb;\n";
  if (g.enable_shadowmapping) {
    if (!g.light_fixed) {
      f += g.frag_in() + "vec3 vary_smposa["+smsz+"];\n";
    } else {
      f += "uniform float ndelta_scale;\n"; // 0.02 / 40.0
    }
    f += "float linear_01(in float x, in float a, in float b) {\n";
    f += "return clamp((x - a) / (b - a), 0.0, 1.0);\n";
    f += "}\n";
    f += "float linear_10(in float x, in float a, in float b) {\n";
    f += "return clamp((b - x) / (b - a), 0.0, 1.0);\n";
    f += "}\n";
    f += "float max_vec3(in vec3 v) {\n";
    f += "return max(v.x, max(v.y, v.z));\n";
    f += "}\n";
    f += "float max3(in float x0, in float x1, in float x2) {\n";
    f += "return max(x0, max(x1, x2));\n";
    f += "}\n";
  }
  f += "bool uv_inside_aabb(in vec2 uv) {\n";
  f += "vec4 aabb = floor(vary_uv_aabb + 0.5);\n";
  f += "return uv.x >= aabb.x && uv.y >= aabb.y";
  f += " && uv.x < aabb.z && uv.y < aabb.w;\n";
  f += "}\n";
  /*
  f += "float distance_to_border(in vec2 uv, in vec3 delta) {\n";
  f += "vec4 aabb = floor(vary_uv_aabb + 0.5);\n";
  f += "vec2 dist = min(uv - aabb.xy, aabb.zw - uv);\n";
  f += "return min(dist.x, dist.y);\n";
  f += "}\n";
  f += "float distance_to_border(in vec2 uv, in vec3 delta) {\n";
  f += "vec4 aabb = floor(vary_uv_aabb + 0.5);\n";
  f += "vec2 dclamp = clamp(delta.xy, aabb.xy - uv, aabb.zw - uv);\n";
  // f += "float ratx = delta.x != 0.0 ? dclamp.x / delta.x : 0.0;\n";
  // f += "float raty = delta.y != 0.0 ? dclamp.y / delta.y : 0.0;\n";
  // f += "return min(ratx, raty);\n";
  f += "vec2 rat2 = dclamp / delta.xy;\n";
  // f += "return clamp(min(rat2.x, rat2.y), 0.0, 1.0);\n";
  f += "return min(rat2.x, rat2.y);\n";
  f += "}\n";
  *
  f += "vec3 clamp_to_border(in vec2 uv, in vec3 delta, inout vec4 dbg) {\n";
  f += "vec4 aabb = floor(vary_uv_aabb + 0.5);\n";
  f += "vec2 dclamp = clamp(delta.xy, aabb.xy - uv + 0.5, aabb.zw - uv - 0.5);\n";
  	///// FIXME FIXME FIXME
  f += "float ratx = (abs(delta.x) > 0.001) ? (dclamp.x / delta.x) : 0.0;\n";
  f += "float raty = (abs(delta.y) > 0.001) ? (dclamp.y / delta.y) : 0.0;\n";
  f += "float rat = clamp(min(ratx, raty), 0.0, 1.0);\n";
  // f += "vec2 rat2 = dclamp / delta.xy;\n";
  // f += "float rat = min(0.99, min(rat2.x, rat2.y));\n";
  f += "vec3 r = delta * rat;\n";
  f += "vec2 np = uv + r.xy;\n";   /// HAMIDASU
  // f += "vec2 np = uv + dclamp;\n";  /// HAMIDASANAI
  //////// f += "vec2 np = uv + clamp(delta.xy, vec2(0.0,0.0), aabb.zw -uv) * 0.99;\n";
  //////// f += "vec2 np = uv + clamp(delta.xy, aabb.xy - uv, aabb.zw -uv) * 0.99;\n";
  // f += "if (np.x >= aabb.z || np.y >= aabb.w) { dbg.r = 1.0; }\n";
  // f += "if (ratx < 0 || raty < 0) { dbg.b = 1.0; }\n";
  // f += "if (!uv_inside_aabb(np)) { dbg.r = 1.0; }\n";
  // f += "if (np.x < aabb.x || np.y < aabb.y || np.x >= aabb.z || np.y >= aabb.w) { dbg.r = 1.0; }\n";
  f += "return r;\n";
  f += "}\n";
  /*
  *
  f += g.decl_fragcolor();
  if (g.enable_normalmapping) {
    f += "void tilemap(in vec2 uv0, out vec4 tex_val, out vec2 subtex_uv) {\n";
    f += "vec2 uv_tm = floor(uv0 / tile_size);\n";
	  // tilemap coordinate
    f += "vec2 uv_tmfr = uv0 / tile_size - uv_tm;\n";
	  // coordinate inside a tile (0, 1)
    if (opt != 0) {
      f += "vec2 p = uv_tmfr - 0.5;\n";
      f += "if (dot(p, p) < 0.125) { discard; }\n";
    }
    f += "vec2 uv_ti = uv_tmfr * tile_size;\n";
    f += "vec2 uvi = floor(uv_ti);\n";
	  // coordinate inside a tile, integral
    f += "subtex_uv = uv_ti - uvi;\n";
	  // subtexel coordinate
    f += "vec4 ti_val = " +  g.texture2d();
    f += "  (sampler_tilemap, uv_tm / tilemap_size);\n";
	  // lookup the tilemap
    f += "vec2 uv_pixel = floor(ti_val.xy * 255.0 + 0.5) * tile_size + uvi;\n";
	  // tile pattern coordinate
    f += "if (uv_inside_aabb(uv0)) {\n";
    f += "tex_val = " + g.texture2d();
    f += "  (sampler_dpat, uv_pixel / tiletex_size);\n";
	  // lookup the tilepattern
    f += "} else {\n";
    f += "tex_val = vec4(0.5, 0.5, 0.5, 0.0);\n";
    f += "}\n"; // if
    f += "}\n";
  }
  if (g.enable_parallax) {
    f += "void parallax_read(in vec2 uv0, out vec4 tex_val) {\n";
    f += "vec2 uv_tm = floor(uv0 / tile_size);\n"; // tilemap coordinate
    f += "vec2 uv_tmfr = uv0 / tile_size - uv_tm;\n";
      // coordinate inside a tile (0, 1)
    f += "vec2 uvi = floor(uv_tmfr * tile_size);\n";
      // coordinate inside a tile (0, tile_size)
    f += "if (uv_inside_aabb(uv0)) {\n";
    f += "vec4 ti_val = " +  g.texture2d(); // lookup the tilemap
    f += "  (sampler_tilemap, uv_tm / tilemap_size);\n";
    f += "vec2 uv_pixel = floor(ti_val.xy * 255.0 + 0.5) * tile_size + uvi;\n";
	  // tile pattern coordinate
    f += "tex_val = " + g.texture2d(); // lookup the tilepattern
    f += "  (sampler_pmpat, uv_pixel / tiletex_size);\n";
    f += "} else {\n";
    f += "tex_val = vec4(0.0, 0.0, 0.0, 0.0);\n";
    f += "}\n";
    f += "}\n";
    f += "vec2 parallax_next(in vec3 tsub, out vec3 tsub_next, in float z,";
    f += " in vec3 d) {\n";
    f += "tsub.xy = clamp(tsub.xy, 0.0, 1.0);\n";
    f += "vec2 r = vec2(0.0, 0.0);\n";
    f += "float dypos = float(d.y > 0.0);\n";
    f += "float nx = tsub.x + (dypos - tsub.y) * d.x / d.y;\n";
    f += "if (d.y != 0.0 && nx > 0.0 && nx < 1.0) {\n";
    f += "float nz = tsub.z + (dypos - tsub.y) * d.z / d.y;\n";
    f += "tsub_next = vec3(nx, dypos, nz);\n";
    f += "r.y = dypos * 2.0 - 1.0;\n";
    f += "} else if (d.x != 0.0) {\n";
    f += "float dxpos = float(d.x > 0.0);\n";
    f += "float ny = tsub.y + (dxpos - tsub.x) * d.y / d.x;\n";
    f += "float nz = tsub.z + (dxpos - tsub.x) * d.z / d.x;\n";
    f += "tsub_next = vec3(dxpos, ny, nz);\n"; // clamp ny?
    f += "r.x = dxpos * 2.0 - 1.0;\n";
    f += "} else {\n";
    f += "tsub_next = vec3(tsub.xy, z);\n";
    f += "}\n";
    f += "return r;\n";
    f += "}\n";
    f += "void parallax_warp(in vec3 dir, inout vec4 tval, inout vec2 tpos,";
    f += " inout vec3 tsub, inout vec4 dbg) {\n";
    f += "tsub.xy = clamp(tsub.xy, 0.001, 0.999);\n";
    if (enable_macos_nvidia_wa) {
      f += "return;\n";
    }
    f += "dir /= max(abs(dir.x), abs(dir.y));\n"; // FIXME: compute by caller?
    // W = unused(8), Z = depth(8), Y = CNN(4) CNP(4), X = CPN(4) CPP(4)
    f += "float cvt = floor((dir.x > 0.0 ? tval.x : tval.y) * 255.0 + 0.5);\n";
    f += "float cval = dir.y > 0.0 ? fract(cvt / 16.0) * 16.0";
    f += " : floor(cvt / 16.0);\n";
    f += "cval = min(cval, (tval.z - tsub.z) / dir.z);\n"; // crop cval
    // f += "float dtb = distance_to_border(tpos + tsub.xy, dir * cval);\n";
    // f += "if (!uv_inside_aabb(tpos + tsub.xy)) { dbg.g = 1.0; }\n"; // FIXME
    f += "if (!uv_inside_aabb(tpos + tsub.xy)) { return; }\n"; // FIXME
    // f += "if (dtb < 0.0) { dbg.b = 1.0; }\n"; // FIXME
    // f += "cval = clamp(cval, 0.0, dtb - 0.002);\n";
    // f += "cval *= dtb;\n";
    // f += "vec3 delta = dir * cval;\n";
    f += "vec3 delta = clamp_to_border(tpos + tsub.xy, dir * cval, dbg);\n";
    f += "vec2 npos = tpos + tsub.xy + delta.xy;\n";
    // f += "if (!uv_inside_aabb(npos)) { dbg.g = 1.0; }\n"; // FIXME
    // f += "if (npos.x < 0.0 || npos.y < 0.0) { dbg.rgb = vec3(1.0, 1.0, 1.0); }\n"; // FIXME
    f += "tpos = floor(npos);\n";
    f += "tsub = vec3(npos - tpos, tsub.z + delta.z);\n";
    f += "parallax_read(tpos, tval);\n";
    f += "}\n";
    f += "void parallax_warp2(in vec3 dir, inout vec4 tval, inout vec2 tpos,";
    f += " inout vec3 tsub, inout vec4 dbg) {\n";
    f += "tsub.xy = clamp(tsub.xy, 0.001, 0.999);\n";
    f += "dir /= max(abs(dir.x), abs(dir.y));\n"; // FIXME: compute by caller?
    f += "float cvt = floor((dir.x > 0.0 ? tval.x : tval.y) * 255.0 + 0.5);\n";
    f += "float cval = dir.y > 0.0 ? fract(cvt / 16.0) * 16.0";
    f += " : floor(cvt / 16.0);\n";
    // f += "float dtb = distance_to_border(tpos + tsub.xy, dir * cval);\n";
    // f += "if (!uv_inside_aabb(tpos + tsub.xy)) { return; }\n"; // FIXME
    // f += "if (dtb < 0.5) { dbg.g = 1.0; }\n"; // FIXME
    // f += "cval = clamp(cval, 0.0, dtb - 0.002);\n";
    // f += "cval *= dtb;\n";
    // f += "vec3 delta = dir * cval;\n";
    f += "vec3 delta = clamp_to_border(tpos + tsub.xy, dir * cval, dbg);\n";
    // f += "dbg.r = 0.0;\n"; // FIXME
    f += "vec2 npos = tpos + tsub.xy + delta.xy;\n";
    // f += "if (!uv_inside_aabb(npos)) { dbg.g = 1.0; }\n"; // FIXME
    f += "tpos = floor(npos);\n";
    f += "tsub = vec3(npos - tpos, tsub.z + delta.z);\n";
    f += "parallax_read(tpos, tval);\n";
    f += "}\n";
    f += "void parallax_loop(inout vec2 pos, in vec3 eye, in vec3 light,";
    f += " out float z, out vec3 nor, out bool vertical, out float shval,";
    f += " inout vec4 dbg) {\n";
    f += "z = 0.0;\n";
    f += "nor = vary_normal;\n";
    f += "vertical = false;\n";
    f += "shval = 1.0;\n";
    f += "eye.z /= tile_size;\n";
    f += "light.z /= tile_size;\n";
    f += "vec2 pos_m = pos;\n"; // texel coord
    f += "vec2 tpos = floor(pos_m);\n";
    f += "vec3 tsub = vec3(pos_m - tpos, 0.0);\n";
    f += "vec4 tval;\n";
    f += "parallax_read(tpos, tval);\n";
    f += "if (tval.z == 0.0) {\n";
    f += "return;\n";
    f += "}\n";
    f += "for (int i = 0; i < 128; ++i) {\n";
    f += "vec3 tsub_next;\n";
    f += "vec2 tnext_diff = parallax_next(tsub, tsub_next, tval.z, eye);\n";
    f += "if (tsub_next.z >= tval.z) {\n"; // horizontal surface
    f += "if (tsub_next.z > tsub.z) {\n";
    f += "float ra = (tval.z - tsub.z) / (tsub_next.z - tsub.z);\n";
    f += "tsub += (tsub_next - tsub) * ra;\n";
    f += "}\n";
    f += "tsub.z = tval.z;\n";
    f += "break;\n";
    f += "}\n";
    f += "tsub = tsub_next;\n";
    f += "tpos += tnext_diff;\n";
    f += "tsub.xy -= tnext_diff;\n";
    f += "parallax_read(tpos, tval);\n";
    f += "if (tval.z < tsub.z) {\n"; // vertical surface
    f += "vertical = true;\n";
    f += "nor = vary_tangent * (-tnext_diff.x)";
    f += "  + vary_binormal * (-tnext_diff.y);\n";
    f += "break;\n";
    f += "}\n";
    f += "parallax_warp(eye, tval, tpos, tsub, dbg);\n";
    f += "}\n"; // for (i)
    f += "pos = (tpos + clamp(tsub.xy, 0.001, 0.999));\n";
    f += "z = tval.z;\n";
    if (g.enable_parallax_shadow) {
      f += "if (light.z < 0.0) {\n";
      f += "for (int i = 0; i < 128; ++i) {\n";
      f += "vec3 tsub_next;\n";
      f += "vec2 tnext_diff = parallax_next(tsub, tsub_next, 0.0, light);\n";
      f += "if (tsub_next.z <= 0.0) {\n";
      f += "break;\n";
      f += "}\n";
      f += "tsub = tsub_next;\n";
      f += "tpos += tnext_diff;\n";
      f += "tsub.xy -= tnext_diff;\n";
      f += "parallax_read(tpos, tval);\n";
      f += "if (tval.z < tsub.z) {\n";
      f += "shval = 0.0;\n";
      f += "break;\n";
      f += "}\n";
      f += "parallax_warp2(light, tval, tpos, tsub, dbg);\n";
      f += "}\n"; // for (i)
      f += "}\n"; // if (light.z < 0.0)
    }
    f += "}\n";
  }
  // fresnel
  f += "vec3 reflection_fresnel(in float cos_l_n, in vec3 fresnel0) {\n";
  f += "float fre_exp = pow(1.0 - cos_l_n, 5.0);\n";
  f += "return fresnel0 + (vec3(1.0, 1.0, 1.0) - fresnel0) * fre_exp;\n";
  f += "}\n";
  f += "vec3 light_specular_brdf(in float cos_l_h, in float cos_n_h,\n";
  f += " in float cos_n_v, in float cos_n_l, in float cos_v_h, float alpha,";
  f += " in vec3 material_specular) {\n";
  f += "float alpha2 = alpha * alpha;\n";
  f += "float den = cos_n_h * cos_n_h * (alpha2 - 1.0) + 1.0;\n";
  f += "float distribution = alpha2 / (3.141592 * den * den);\n";
  f += "float geo = 1.0;\n";
  f += "vec3 fresnel = reflection_fresnel(cos_l_h, material_specular);\n";
  f += "return fresnel * (distribution * geo * 3.141592 / 4.0);\n";
  f += "}\n";
  f += "vec3 light_diffuse(in float cos_n_l, in vec3 material_diffuse) {\n";
  f += "return material_diffuse * cos_n_l / 3.141592;\n";
  f += "}\n";
  f += "vec3 light_all(in vec3 light_color, in vec3 mate_specular,";
  f += " in vec3 mate_diffuse, in float mate_alpha, in vec3 camera_dir,";
  f += " in vec3 light_dir, samplerCube samp, in vec3 nor, bool vertical) {\n";
  f += "vec3 half_l_v = normalize(light_dir + camera_dir);\n";
  f += "float cos_l_h = clamp(dot(light_dir, half_l_v), 0.0, 1.0);\n";
  f += "float cos_n_h = clamp(dot(nor, half_l_v), 0.0, 1.0);\n";
  f += "float cos_n_l = clamp(dot(nor, light_dir), 0.0, 1.0);\n";
  f += "float cos_n_v = clamp(dot(nor, camera_dir), 0.0, 1.0);\n";
  f += "float cos_v_h = cos_l_h;\n";
  f += "vec3 light_sp_di = light_color * (\n";
  f += " light_specular_brdf(cos_l_h, cos_n_h, cos_n_v, cos_n_l, cos_v_h,";
  f += "  mate_alpha, mate_specular) +\n";
  f += " light_diffuse(cos_n_l, mate_diffuse));\n";
  f += "vec3 reflection_vec = reflect(-camera_dir, nor);\n";
  f += "vec3 env = " + g.texture_cube();
  f += "(sampler_env, reflection_vec).xyz;\n";
  f += "env = env * env * reflection_fresnel(";
  f += " clamp(dot(nor, reflection_vec), 0.0, 1.0), mate_specular)";
  f += " * (vertical ? mate_specular : vec3(1.0, 1.0, 1.0))";
  f += " * clamp(1.0 - mate_alpha, 0.0, 1.0);\n";
  f += "return clamp(light_sp_di + env, 0.0, 1.0);\n";
  f += "}\n";
  f += "void main(void) {\n";
  f += "vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n";
  f += "vec3 nor = vary_normal;\n";
  f += "vec3 rel_camera_pos = camera_pos - vary_position;\n";
  f += "vec3 camera_dir = normalize(rel_camera_pos);\n";
  f += "float is_front = float(dot(camera_dir, nor) > 0.0);\n";
  f += "float frag_distance = length(rel_camera_pos);\n";
  f += "float distbr = clamp(16.0 / frag_distance, 0.0, 1.0);\n";
  f += "float lstr = 1.0;\n";
  f += "float lstr_para = 1.0;\n";
  f += "float para_zval = 0.0;\n";
  f += "bool vertical = false;\n";
  f += "vec4 tex_val = vec4(0.5, 0.5, 0.5, 1.0);\n";
  if (g.enable_normalmapping) {
    f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
    if (g.enable_parallax) {
      f += "vec4 para_val;\n";
      f += "vec3 eye_tan = vec3("; // eye vector, tangent space
      f += "  -dot(camera_dir, vary_tangent), ";
      f += "  -dot(camera_dir, vary_binormal),";
      f += "  dot(camera_dir, vary_normal));\n";
      f += "vec3 light_tan = vec3("; // light vector, tangent space
      f += "  dot(light_dir, vary_tangent), ";
      f += "  dot(light_dir, vary_binormal),";
      f += "  -dot(light_dir, vary_normal));\n";
      f += "vec4 dbgval = vec4(0.0,0.0,0.0,0.0);\n";
      f += "parallax_loop(uv0, eye_tan, light_tan, para_zval, nor, vertical,";
      f += "  lstr_para, dbgval);\n";
      f += "color += dbgval;\n"; // FIXME
    }
    f += "vec2 subtex_uv;\n";
    f += "tilemap(uv0, tex_val, subtex_uv);\n";
    f += "float alv0 = floor(tex_val.a * 255.0 + 0.5);\n";
    f += "float avol = floor(alv0 / 16.0);\n";
    f += "int alv = int(alv0 - avol * 16.0 + 0.5);\n";
    f += "if (!vertical) {\n";
    f += "float lt = float(subtex_uv.y - subtex_uv.x >= 0.0);\n";
    f += "float lb = float(subtex_uv.y + subtex_uv.x <= 1.0);\n";
    f += "vec4 avlv = vec4(float(alv == 1), float(alv == 3), ";
    f += "  float(alv == 5), float(alv == 7));\n";
    f += "float ut1 = dot(avlv, vec4(-lt, 1.0-lb, 1.0-lt, -lb));\n";
    f += "float vt1 = dot(avlv, vec4(lt-1.0, -lb, lt, 1.0-lb));\n";
    f += "ut1 += float(alv == 4);\n";
    f += "vt1 -= float(alv == 2);\n";
    f += "float distbr2 = clamp(16.0 / frag_distance , 0.001, 1.0);\n";
    f += "avol = (avol - 8.0) * distbr2 * 0.2;\n";
    f += "vec3 nor_delta = vary_tangent * ut1 * avol\n";
    f += "  + vary_binormal * vt1 * avol;\n";
    if (opt != 0) {
      f += "nor_delta *= is_front;\n";
    }
    f += "nor = normalize(nor + nor_delta);\n";
    f += "}\n";
  }
  if (g.enable_shadowmapping) {
    if (g.light_fixed) {
      f += "vec3 ndelta = vary_normal * ndelta_scale;\n"; // 0.02 / 40.
      f += "vec3 prel = vary_position - camera_pos;\n";
      f += "vec3 p["+smsz+"];\n";
      float den = g.shadowmap_distance;
      for (int i: 0 .. g.num_shadowmaps) {
	const i_s = to_string(i);
	const den_s = to_string(den);
	f += "p["+i_s+"] = prel / "+den_s+" + ndelta;\n";
	den *= g.shadowmap_scale;
      }
    } else {
      if (g.is_gl3_or_gles3()) {
	f += "vec3 p["+smsz+"] = vary_smposa;\n";
      } else {
	f += "vec3 p["+smsz+"];\n";
	for (int i: 0 .. g.num_shadowmaps) {
	  const i_s = to_string(i);
	  f += "p["+i_s+"] = vary_smposa["+i_s+"];\n";
	}
      }
    }
    for (int i: 0 .. g.num_shadowmaps) {
      const x = to_string(i);
      if (g.enable_depth_texture) {
	if (g.enable_shadowmapping_multisample) {
	  if (i == 0) {
	    f += "vec3 smpos;\n";
	  }
	  f += "smpos = (p["+x+"] + 1.0) * 0.5;\n";
	  f += "float zval"+x+" = 0.0;\n";
	  f += "float zval"+x+"_cur = 0.0;\n";
	  f += "float sml"+x+" = 0.0;\n";
	  f += "for (float i = -1.; i <= 1.; ++i) {\n";
	  f += "for (float j = -1.; j <= 1.; ++j) {\n";
	  f += "zval"+x+"_cur = " + g.texture2d();
	  f += "  (sampler_sm["+x+"], smpos.xy + vec2(i,j)/4096.0).x;\n";
	  f += "zval"+x+" = min(zval"+x+", zval"+x+"_cur);\n";
	  f += "sml"+x+" += float(smpos.z < zval"+x+"_cur";
	  f += " * (1.0005 + (abs(i)+abs(j))/4096.0))/9.0;\n";
	  f += "}\n";
	  f += "}\n";
	} else {
	  // no multisample
	  if (i == 0) {
	    f += "vec3 smpos;\n";
	  }
	  f += "smpos = (p["+x+"] + 1.0) * 0.5;\n";
	  f += "float zval"+x+" = " + g.texture2d();
	  f += "  (sampler_sm["+x+"], smpos.xy).x;\n";
	  f += "float sml"+x+" = float(smpos.z < zval"+x+" * 1.0005);\n";
	}
      } else if (g.enable_vsm) {
	// vsm, no depth texture
	if (i == 0) {
	  f += "vec3 smpos;\n";
	  f += "vec2 smz;\n";
	  f += "float dist;\n";
	  f += "float variance;\n";
	}
	if (g.enable_shadowmapping_multisample) {
	  f += "smpos = (p["+x+"] + 1.0) * 0.5;\n";
	  f += "float zval"+x+" = 99999.0;\n";
	  f += "float sml"+x+" = 0.0;\n";
	  f += "for (float i = -1.0; i <= 1.0; i += 2.0) {\n";
	  f += "for (float j = -1.0; j <= 1.0; j += 2.0) {\n";
	  f += "smz = " + g.texture2d();
	  f += "  (sampler_sm["+x+"], smpos.xy + vec2(i, j) / 8192.0).rg;\n";
	  f += "zval"+x+" = min(zval"+x+", smz.r);\n";
	  f += "dist = smpos.z - smz.r * 1.001;\n";
	  f += "if (dist <= 0.0) {\n";
	  f += "sml"+x+" += 0.25;\n";
	  f += "} else {\n";
	  f += "variance = smz.g - smz.r * smz.r;\n";
	  f += "variance = max(variance, 0.000001);\n";
	  f += "sml"+x+" += 0.25 * variance / (variance + dist * dist);\n";
	  f += "}\n";
	  f += "}\n"; // for (j)
	  f += "}\n"; // for (i)
	  f += "sml"+x+" = clamp(sml"+x+" * 1.5 - 0.1, 0.0, 1.0);\n";
	} else {
	  // no multisample
	  f += "smpos = (p["+x+"] + 1.0) * 0.5;\n";
	  f += "smz = " + g.texture2d();
	  f += "  (sampler_sm["+x+"], smpos.xy).rg;\n";
	  f += "float zval"+x+" = smz.r;\n";
	  f += "float zval"+x+"_sq = smz.g;\n";
	  f += "float sml"+x+" = 0.0;\n";
	  f += "dist = smpos.z - smz.r * 1.001;\n";
	  f += "if (dist <= 0.0) {\n";
	  f += "sml"+x+" = 1.0;\n";
	  f += "} else {\n";
	  f += "variance = smz.g - smz.r * smz.r;\n";
	  f += "variance = max(variance, 0.000001);\n";
	  f += "sml"+x+" = clamp(";
	  f += " variance / (variance + dist * dist) * 1.5 - 0.1, 0.0, 1.0);\n";
	  f += "}\n";
	}
	debug_log("VSM enabled");
      } else {
	// no depth texture, no vsm
	if (i == 0) {
	  f += "vec3 smpos;\n";
	  f += "vec3 smz;\n";
	}
	f += "smpos = (p["+x+"] + 1.0) * 0.5;\n";
	f += "smz = " + g.texture2d();
	f += "  (sampler_sm["+x+"], smpos.xy).rgb;\n";
	f += "smz = floor(smz * 255.0 + 0.5);\n";
	f += "float zval"+x+" = ";
	f += "  smz.r / 256. + smz.g / 65536.0 + smz.b / 16777216.;\n";
	f += "float sml"+x+" = float(smpos.z < zval"+x+" * 1.0005);\n";
      }
    }
    if (g.enable_vsm) {
      f += "const float zval_thr = 0.1;\n";
    } else {
      f += "const float zval_thr = "+to_string(0.97f/g.shadowmap_scale)+";\n";
    }
    f += "const float psm_thr = "+to_string(0.9f/g.shadowmap_scale)+";\n";
    f += "if (zval0 < 0.0) { color.g += 1.0; };\n"; // FIXME
    f += "float smv0 = min(1.0, sml0";
    f += "  + linear_01(max_vec3(abs(p[0])), 0.9, 1.0));\n";
    f += "lstr = min(lstr, smv0);\n";
    for (int i: 1 .. g.num_shadowmaps) {
      const x = to_string(i);
      f += "float smv"+x+" = max3(sml"+x+",";
      f += "  min(linear_10(max_vec3(abs(p["+x+"])), psm_thr * 0.9, psm_thr),";
      f += "  linear_10(abs(zval"+x+"-0.5)*2.0, zval_thr * 0.9, zval_thr)),";
      f += "  linear_01(max_vec3(abs(p["+x+"])), 0.9, 1.0));\n";
      f += "lstr = min(lstr, smv"+x+");\n";
    }
    // FIXME?
    f += "lstr = clamp(dot(vary_normal, light_dir) * 4.0, 0.0, lstr);\n";
    // f += "lstr = clamp(dot(vary_normal, light_dir) * 32.0, 0.0, lstr);\n";
    // f += "lstr = min(lstr, float(dot(vary_normal, light_dir) > 0.0));\n";
  }
  // fresnel
  // f += "float cos_v_h = clamp(dot(camera_dir, half_l_v), 0.0, 1.0);\n";
  f += "float mate_alpha = 0.03;\n";
  f += "vec3 mate_specular = vec3(0.04, 0.04, 0.04);\n";
  f += "vec3 mate_diffuse = vec3(0.0, 0.0, 0.0);\n";
  f += "if (max(tex_val.r, max(tex_val.g, tex_val.b)) > 0.9) {\n";
  f += "mate_specular = tex_val.rgb;\n";
  f += "} else {\n";
  f += "mate_diffuse = tex_val.rgb;\n";
  f += "}\n";
  f += "if (int(option_value + 0.5) == 1) {\n";
  f += "mate_alpha = 0.03;\n";
  f += "mate_specular = vec3(0.95, 0.64, 0.54);\n";
  f += "mate_diffuse = vec3(0.0, 0.0, 0.0);\n";
  f += "}\n";
  f += "if (int(option_value + 0.5) == 2) {\n";
  f += "mate_alpha = 0.03;\n";
  f += "mate_specular = vec3(0.95, 0.93, 0.88);\n";
  f += "mate_diffuse = vec3(0.0, 0.0, 0.0);\n";
  f += "}\n";
  f += "if (int(option_value + 0.5) == 3) {\n";
  f += "mate_alpha = 0.1;\n";
  f += "mate_specular = vec3(0.04, 0.04, 0.04);\n";
  f += "mate_diffuse = vec3(0.6, 0.7, 0.4);\n";
  f += "}\n";
  f += "vec3 light_color2 = vec3(2.0, 2.0, 2.0) * lstr;\n"; // FIXME???
  f += "vec3 light_color1 = light_color2 * lstr_para;\n";
  f += "vec3 li1 = light_all(light_color1, mate_specular, mate_diffuse,";
  f += " mate_alpha, camera_dir, light_dir, sampler_env, nor, vertical);\n";
  /*
  f += "vec3 li2 = light_all(light_color2, mate_specular, mate_diffuse,";
  f += " mate_alpha, camera_dir, light_dir, sampler_env,";
  f += " normalize(vary_normal), false);\n";
  f += "color.xyz += sqrt(mix(li2, li1, distbr));\n";
  *
  f += "color.xyz += sqrt(li1);\n";
  f += g.fragcolor() + " = color;\n";
  f += "}\n";
*/
debug_log("triangles fsh", f);
  return f;
}

