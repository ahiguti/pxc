private threaded namespace pgl3d::drawer::edit_mode "export-unsafe";
public import common -;
public import meta m;
public import pgl3d::drawer::base -;
public import glm -;
public import SDL2::api_types -;
public import text::serialize::compact_pod -;

private struct edit_state {
  public bool edit_tpat;
  public ivec3 mappos;
  public ivec3 patpos;
}

public struct edit_mode(ptr{texture_data} const& voxtile0,
  ptr{texture_data} const& voxtpat0, ptr{texture_data} const& voxtmap0,
  ptr{gl_texture} const& gl_tpat0, ptr{gl_texture} const& gl_tmap0)
<edit_mode_i>
{
  metafunction ui static_cast{uint}; 
  metafunction si static_cast{int}; 
  private ptr{texture_data} const voxtile = voxtile0;
  private ptr{texture_data} const voxtpat = voxtpat0;
  private ptr{texture_data} const voxtmap = voxtmap0;
  private ptr{gl_texture} const gl_tpat = gl_tpat0;
  private ptr{gl_texture} const gl_tmap = gl_tmap0;
  private glm::ivec3 const tile_size = glm::make_ivec3(
    si(voxtile->get_width()), si(voxtile->get_height()),
    si(voxtile->get_depth()));
  private glm::ivec3 const map_size = glm::make_ivec3(
    si(voxtmap->get_width()), si(voxtmap->get_height()),
    si(voxtmap->get_depth()));
  private glm::ivec3 const pat_size = map{glm::ivec3, operator::div}(
    glm::make_ivec3(si(voxtpat->get_width()), si(voxtpat->get_height()),
      si(voxtpat->get_depth())),
    tile_size);
  private edit_state stat;
  private uint frame_cnt;
  private uint copy_single;
  private texture_data copy_block;
  private int edit_params;
  private glm::quat camera_angle;
  init();
  private function void init()
  {
    string buf;
    stat.mappos.z = 1u;
    sdl_load_file("edit_state.raw", buf);
    if (!buf.empty()) {
      stat = from_string_compact_pod{edit_state}(buf);
    }
  }
  private function void save_state()
  {
    debug_log("edit_mode: save");
    const buf = to_string_compact_pod(stat);
    sdl_save_file("edit_state.raw", buf);
    save_texture_data_raw("voxtmap_edit.raw", *voxtmap);
    save_texture_data_raw("voxtpat_edit.raw", *voxtpat);
  }
  public function void set_camera_angle(glm::quat const& angle)
  {
    camera_angle = angle;
  }
  public function void on_key_pressed(int scancode)
  {
    SDL_Scancode key = static_cast{SDL_Scancode}(scancode);
    if (key == SDL_SCANCODE_M) {
      save_state();
    } else if (key == SDL_SCANCODE_KP_MINUS) {
      set_space();
    } else if (key == SDL_SCANCODE_KP_PLUS) {
      set_brick();
    } else if (key == SDL_SCANCODE_KP_ENTER) {
      restore_blink();
      edit_params = (edit_params + 1) % 3;
    } else if (key == SDL_SCANCODE_C) {
      copy_value();
    } else if (key == SDL_SCANCODE_V) {
      paste_value();
    }
    if (edit_params == 0) {
      if (key == SDL_SCANCODE_KP_4) {
	restore_blink();
	move_cursor(-1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_6) {
	restore_blink();
	move_cursor(1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_2) {
	restore_blink();
	move_cursor(0, -1, 0);
      } else if (key == SDL_SCANCODE_KP_8) {
	restore_blink();
	move_cursor(0, 1, 0);
      } else if (key == SDL_SCANCODE_KP_1) {
	restore_blink();
	move_cursor(0, 0, -1);
      } else if (key == SDL_SCANCODE_KP_3) {
	restore_blink();
	move_cursor(0, 0, 1);
      } else if (key == SDL_SCANCODE_KP_7) {
	restore_blink();
	if (is_cur_tmap_node_reference()) {
	  stat.edit_tpat = true;
	}
      } else if (key == SDL_SCANCODE_KP_9) {
	restore_blink();
	stat.edit_tpat = false;
      }
    } else {
      if (key == SDL_SCANCODE_KP_4) {
	restore_blink();
	set_offset_scale(-1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_6) {
	restore_blink();
	set_offset_scale(1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_2) {
	restore_blink();
	set_offset_scale(0, -1, 0);
      } else if (key == SDL_SCANCODE_KP_8) {
	restore_blink();
	set_offset_scale(0, 1, 0);
      } else if (key == SDL_SCANCODE_KP_1) {
	restore_blink();
	set_offset_scale(0, 0, -1);
      } else if (key == SDL_SCANCODE_KP_3) {
	restore_blink();
	set_offset_scale(0, 0, 1);
      } else if (key == SDL_SCANCODE_KP_7) {
	restore_blink();
	set_radius(1);
      } else if (key == SDL_SCANCODE_KP_9) {
	restore_blink();
	set_radius(-1);
      }
    }
    // debug_log("scancode", scancode);
  }
  private function void rotate_dir(int mutable& x, int mutable& y,
    int mutable& z)
  {
  }
  private function void move_cursor(int x, int y, int z)
  {
    ivec3 d = make_ivec3(x, y, z);
    if (stat.edit_tpat) {
      mutable& pos = stat.patpos;
      pos = map{glm::ivec3, operator::add}(pos, d);
      pos = map{glm::ivec3, operator::add}(pos, pat_size);
      pos = map{glm::ivec3, operator::mod}(pos, pat_size);
    } else {
      mutable& pos = stat.mappos;
      pos = map{glm::ivec3, operator::add}(pos, d);
      pos = map{glm::ivec3, operator::add}(pos, map_size);
      pos = map{glm::ivec3, operator::mod}(pos, map_size);
    }
    /*
    rotate_dir(x, y, z);
    mutable& pos = stat.pos;
    pos.px = static_cast{uint}(static_cast{int}(pos.px) + x) & bmask;
    pos.py = static_cast{uint}(static_cast{int}(pos.py) + y) & bmask;
    pos.pz = static_cast{uint}(static_cast{int}(pos.pz) + z) & bmask;
    */
  }
  private function void set_offset_scale(int x, int y, int z)
  {
    /*
    rotate_dir(x, y, z);
    int px = 0;
    int py = 0;
    int pz = 0;
    int sx = 0;
    int sy = 0;
    int sz = 0;
    if (edit_params == 1) {
      px = x;
      py = y;
      pz = z;
    } else {
      sx = x;
      sy = y;
      sz = z;
    }
    mutable& tex = *tex_octree;
    mutable v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type == 1) {
      return;
    }
    uint rad = 0;
    if (node_type == 0 || node_type == 255) {
      v = 0x05484848;
      rad = 4;
    } else {
      rad = node_type - 1;
    }
    px = static_cast{int}(v         & 0x0fu) - 8 + px;
    py = static_cast{int}((v >>  8) & 0x0fu) - 8 + py;
    pz = static_cast{int}((v >> 16) & 0x0fu) - 8 + pz;
    sx = static_cast{int}((v >>  4) & 0x0fu) + sx;
    sy = static_cast{int}((v >> 12) & 0x0fu) + sy;
    sz = static_cast{int}((v >> 20) & 0x0fu) + sz;
    function void clip_i7(int mutable& v) {
      if (v < -7) { v = -7; }
      if (v >  7) { v =  7; }
    }
    function void clip_u15(int mutable& v) {
      if (v <  0) { v = 0; }
      if (v > 15) { v = 15; }
    }
    clip_i7(px);
    clip_i7(py);
    clip_i7(pz);
    clip_u15(sx);
    clip_u15(sy);
    clip_u15(sz);
    debug_log("p:", px, py, pz, "s:", sx, sy, sz, "r:", rad);
    uint nv = 0;
    nv |= static_cast{uint}(px + 8)      ;
    nv |= static_cast{uint}(py + 8) <<  8;
    nv |= static_cast{uint}(pz + 8) << 16;
    nv |= static_cast{uint}(sx    ) <<  4;
    nv |= static_cast{uint}(sy    ) << 12;
    nv |= static_cast{uint}(sz    ) << 20;
    tex.set_index(cur_offset(), (nv & 0xffffffu) | ((rad + 1) << 24u));
    */
  }
  private function void set_radius(int diff)
  {
    /*
    mutable& tex = *tex_octree;
    mutable v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type == 1) {
      return;
    }
    int rad = 0;
    if (node_type == 0 || node_type == 255) {
      v = 0x05484848;
      rad = 4;
    } else {
      rad = static_cast{int}(node_type - 1);
      rad += diff;
      if (rad < 1) { rad = 64; }
      if (rad > 64) { rad = 1; }
    }
    debug_log("r:", rad);
    tex.set_index(cur_offset(),
      (v & 0xffffffu) | ((static_cast{uint}(rad) + 1) << 24u));
    */
  }
  private function void copy_value()
  {
    if (stat.edit_tpat) {
      copy_single = get_cur_tpat();
    } else {
      copy_block = copy_cur_tile();
    }
  }
  private function void paste_value()
  {
    if (stat.edit_tpat) {
      set_cur_tpat(copy_single);
    } else {
      paste_cur_tile(copy_block);
    }
  }
  private function void set_space()
  {
    /*
    mutable& tex = *tex_octree;
    const v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type == 1) {
      return;
    }
    tex.set_index(cur_offset(), 0);
    */
  }
  private function void set_brick()
  {
    /*
    mutable& tex = *tex_octree;
    const v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type == 1) {
      return;
    }
    tex.set_index(cur_offset(), 0xff808080);
    */
  }
  private function void go_down()
  {
    /*
    mutable& tex = *tex_octree;
    const v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type != 1) {
      return;
    }
    mutable& pos = stat.pos;
    const bx = (v      ) & 0xff;
    const by = (v >>  8) & 0xff;
    const bz = (v >> 16) & 0xff;
    stat.pos_stack.push_back(pos);
    pos.node_x = bx;
    pos.node_y = by;
    pos.node_z = bz;
    pos.x = 0;
    pos.y = 0;
    pos.z = 0;
    */
  }
  private function void go_up()
  {
    /*
    if (stat.pos_stack.empty()) {
      return;
    }
    stat.pos = stat.pos_stack.pop_back();
    */
  }
  private function uint cur_offset() const
  {
    return 0u;
    /*
    mutable& tex = *tex_octree;
    const& pos = stat.pos;
    uint cur_x = (pos.node_x << bshift) | pos.x;
    uint cur_y = (pos.node_y << bshift) | pos.y;
    uint cur_z = (pos.node_z << bshift) | pos.z;
    return tex.index(cur_x, cur_y, cur_z);
    */
  }
  private function void restore_blink()
  {
    frame_cnt = 0;
    sync_gl_texture();
  }
  private function ivec3 cur_tpat_base() const
  {
    const& mp = stat.mappos;
    const v = voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
    if (!is_node_reference(v)) {
      return glm::ivec3();
    }
    const z = (v >> 16u) & 0xff;
    const y = (v >>  8u) & 0xff;
    const x = (v >>  0u) & 0xff;
    const r = glm::make_ivec3(si(x), si(y), si(z));
    return map{glm::ivec3, operator::mul}(r, tile_size);
  }
  private function uint get_cur_tmap() const
  {
    const& mp = stat.mappos;
    return voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
  }
  private function void set_cur_tmap(uint value)
  {
    const& mp = stat.mappos;
    return voxtmap->set(ui(mp.x), ui(mp.y), ui(mp.z), value);
  }
  private function bool is_cur_tmap_node_reference() const
  {
    const& mp = stat.mappos;
    const v = voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
    return is_node_reference(v);
  }
  private function ivec3 cur_tpat_index() const
  {
    return map{glm::ivec3, operator::add}(cur_tpat_base(), stat.patpos);
  }
  private function uint get_cur_tpat() const
  {
    const p = cur_tpat_index();
    return voxtpat->get(ui(p.x), ui(p.y), ui(p.z));
  }
  private function void set_cur_tpat(uint value)
  {
    const p = cur_tpat_index();
    voxtpat->set(ui(p.x), ui(p.y), ui(p.z), value);
  }
  private function texture_data copy_cur_tile() const
  {
    ivec3 bp = cur_tpat_base();
    const& tp = *voxtpat;
    mutable tl = *voxtile;
    // debug_log("mp", stat.mappos, "bp", bp);
    for (const z: 0 .. tl.get_depth()) {
      for (const y: 0 .. tl.get_height()) {
	for (const x: 0 .. tl.get_width()) {
	  const v = tp.get(x + ui(bp.x), y + ui(bp.y), z + ui(bp.z));
	  tl.set(x, y, z, v);
	}
      }
    }
    return tl;
  }
  private function void paste_cur_tile(texture_data const& tl)
  {
    ivec3 bp = cur_tpat_base();
    mutable& tp = *voxtpat;
    for (const z: 0 .. tl.get_depth()) {
      for (const y: 0 .. tl.get_height()) {
	for (const x: 0 .. tl.get_width()) {
	  const v = tl.get(x, y, z);
	  tp.set(x + ui(bp.x), y + ui(bp.y), z + ui(bp.z), v);
	}
      }
    }
  }
  private function void sync_gl_texture()
  {
    const& tp = stat.patpos;
    const& mp = stat.mappos;
    mutable tl = copy_cur_tile();
    mutable md = *voxtmap; // copy
    if (stat.edit_tpat) {
      for (const z: ui(tp.z) + 1 .. tl.get_depth()) {
	for (const y: 0 .. tl.get_height()) {
	  for (const x: 0 .. tl.get_width()) {
	    tl.set(x, y, z, 0u);
	  }
	}
      }
    }
    const blink = frame_cnt >= 8;
    if (blink) {
      if (stat.edit_tpat) {
	tl.set(ui(tp.x), ui(tp.y), ui(tp.z), 0xffff0000u);
      } else {
	if (is_cur_tmap_node_reference()) {
	  for (const z: 0 .. tl.get_depth()) {
	    for (const y: 0 .. tl.get_height()) {
	      for (const x: 0 .. tl.get_width()) {
		tl.set(x, y, z, 0xff00ff00u);
	      }
	    }
	  }
	} else {
	  md.set(ui(mp.x), ui(mp.y), ui(mp.z), 0u);
	}
      }
    }
    const z0 = ui(stat.edit_tpat ? mp.z : mp.z + 1);
    for (const z: z0 .. md.get_depth()) {
      for (const x: 0 .. md.get_width()) {
	for (const y: 0 .. md.get_height()) {
	  if (z == ui(mp.z) && x == ui(mp.x) && y == ui(mp.y)) {
	    continue;
	  }
	  md.set(x, y, z, 0u);
	}
      }
    }
    {
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_3D, gl_tmap->texture_id.get());
      glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, si(md.get_width()),
	si(md.get_height()), si(md.get_depth()), GL_RGBA, GL_UNSIGNED_BYTE,
	md.get_crawptr().to_cvoidptr());
    }
    {
      const cp = cur_tpat_base();
      glBindTexture(GL_TEXTURE_3D, gl_tpat->texture_id.get());
      glTexSubImage3D(GL_TEXTURE_3D, 0, cp.x, cp.y, cp.z, tile_size.x,
	tile_size.y, tile_size.z, GL_RGBA, GL_UNSIGNED_BYTE,
	tl.get_crawptr().to_cvoidptr());
    }
  }
  public function void on_frame()
  {
    sync_gl_texture();
    frame_cnt = (frame_cnt + 1) & 15;
  }
}

