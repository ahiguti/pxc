private threaded namespace pgl3d::drawer::edit_mode "export-unsafe";
public import common -;
public import meta m;
public import pgl3d::drawer::base -;
public import glm -;
public import SDL2::api_types -;
public import text::serialize::compact_pod -;

private struct edit_state {
  public bool edit_tpat;
  public ivec3 mappos;
  public ivec3 patpos;
}

public struct edit_mode(ptr{texture_data} const& voxtile0,
  ptr{texture_data} const& voxtpat0, ptr{texture_data} const& voxtmap0,
  ptr{gl_texture} const& gl_tpat0, ptr{gl_texture} const& gl_tmap0)
<edit_mode_i>
{
  metafunction ui static_cast{uint}; 
  metafunction si static_cast{int}; 
  private ptr{texture_data} const voxtile = voxtile0;
  private ptr{texture_data} const voxtpat = voxtpat0;
  private ptr{texture_data} const voxtmap = voxtmap0;
  private ptr{gl_texture} const gl_tpat = gl_tpat0;
  private ptr{gl_texture} const gl_tmap = gl_tmap0;
  private glm::ivec3 const tile_size = glm::make_ivec3(
    si(voxtile->get_width()), si(voxtile->get_height()),
    si(voxtile->get_depth()));
  private glm::ivec3 const map_size = glm::make_ivec3(
    si(voxtmap->get_width()), si(voxtmap->get_height()),
    si(voxtmap->get_depth()));
  private glm::ivec3 const pat_size = map{glm::ivec3, operator::div}(
    glm::make_ivec3(si(voxtpat->get_width()), si(voxtpat->get_height()),
      si(voxtpat->get_depth())),
    tile_size);
  private edit_state stat;
  private uint frame_cnt;
  private uint copy_single;
  private texture_data copy_block;
  private int edit_params;
  private string param_str;
  private glm::quat camera_angle;
  init();
  private function void init()
  {
    string buf;
    stat.mappos.z = 1u;
    sdl_load_file("c:/build/edit_state.raw", buf);
    if (!buf.empty()) {
      stat = from_string_compact_pod{edit_state}(buf);
    }
  }
  private function void save_state()
  {
    debug_log("edit_mode: save");
    const buf = to_string_compact_pod(stat);
    sdl_save_file("c:/build/edit_state.raw", buf);
    save_texture_data_raw("c:/build/voxtmap_edit.raw", *voxtmap);
    save_texture_data_raw("c:/build/voxtpat_edit.raw", *voxtpat);
  }
  public function void set_camera_angle(glm::quat const& angle)
  {
    camera_angle = angle;
  }
  public function void on_key_pressed(int scancode)
  {
    restore_blink();
    SDL_Scancode key = static_cast{SDL_Scancode}(scancode);
    if (key == SDL_SCANCODE_M) {
      save_state();
    } else if (key == SDL_SCANCODE_KP_MINUS) {
      set_space();
    } else if (key == SDL_SCANCODE_KP_PLUS) {
      set_brick();
    } else if (key == SDL_SCANCODE_KP_ENTER) {
      edit_params = (edit_params + 1) % 3;
    } else if (key == SDL_SCANCODE_C) {
      copy_value();
    } else if (key == SDL_SCANCODE_V) {
      paste_value();
    }
    if (edit_params == 0) {
      if (key == SDL_SCANCODE_KP_4) {
	move_cursor(-1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_6) {
	move_cursor(1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_2) {
	move_cursor(0, -1, 0);
      } else if (key == SDL_SCANCODE_KP_8) {
	move_cursor(0, 1, 0);
      } else if (key == SDL_SCANCODE_KP_1) {
	move_cursor(0, 0, -1);
      } else if (key == SDL_SCANCODE_KP_3) {
	move_cursor(0, 0, 1);
      } else if (key == SDL_SCANCODE_KP_7) {
	if (is_cur_tmap_node_reference()) {
	  stat.edit_tpat = true;
	}
      } else if (key == SDL_SCANCODE_KP_9) {
	stat.edit_tpat = false;
      }
    } else if (stat.edit_tpat) {
      if (key == SDL_SCANCODE_KP_4) {
	set_param(0);
      } else if (key == SDL_SCANCODE_KP_6) {
	set_param(1);
      } else if (key == SDL_SCANCODE_KP_2) {
	set_param(2);
      } else if (key == SDL_SCANCODE_KP_8) {
	set_param(3);
      } else if (key == SDL_SCANCODE_KP_1) {
	set_param(4);
      } else if (key == SDL_SCANCODE_KP_3) {
	set_param(5);
      } else if (key == SDL_SCANCODE_KP_7) {
	set_param(6);
      } else if (key == SDL_SCANCODE_KP_9) {
	set_param(7);
      }
    }
    // debug_log("scancode", scancode);
  }
  private function void move_cursor(int x, int y, int z)
  {
    ivec3 d = make_ivec3(x, y, z);
    if (stat.edit_tpat) {
      mutable& pos = stat.patpos;
      pos = map{glm::ivec3, operator::add}(pos, d);
      pos = map{glm::ivec3, operator::add}(pos, pat_size);
      pos = map{glm::ivec3, operator::mod}(pos, pat_size);
    } else {
      mutable& pos = stat.mappos;
      pos = map{glm::ivec3, operator::add}(pos, d);
      pos = map{glm::ivec3, operator::add}(pos, map_size);
      pos = map{glm::ivec3, operator::mod}(pos, map_size);
    }
  }
  private function void set_param(int v)
  {
    // edit_params != 0
    const cur = get_cur_tpat();
    const node_type = cur >> 24u;
    int r = si(cur & 0xffu);
    int g = si((cur >> 8u) & 0xffu);
    int b = si((cur >> 16u) & 0xffu);
    int a = si(node_type);
    if (node_type == 0 || node_type == 255) {
      return;
    }
    function int abs(int x) {
      return x > 0 ? x : -x;
    }
    if (node_type >= 160) {
      // 平面切断
      a = a - 208;
      r = r / 16 - 8;
      g = g / 16 - 8;
      b = b / 16 - 8;
      if (v == 0) {
	r = (r > -7) ? (r - 1) : r;
	a = 0;
      } else if (v == 1) {
	r = (r < 7) ? (r + 1) : r;
	a = 0;
      } else if (v == 2) {
	g = (g > -7) ? (g - 1) : g;
	a = 0;
      } else if (v == 3) {
	g = (g < 7) ? (g + 1) : g;
	a = 0;
      } else if (v == 4) {
	b = (b > -7) ? (b - 1) : b;
	a = 0;
      } else if (v == 5) {
	b = (b < 7) ? (b + 1) : b;
	a = 0;
      } else if (v == 6) {
	const d = abs(r) + abs(g) + abs(b);
	if (a > -d + 1) { a -= 1; }
      } else if (v == 7) {
	const d = abs(r) + abs(g) + abs(b);
	if (a < d - 1) { a += 1; }
      }
      if (r == 0 && g == 0 && b == 0) {
	return;
      }
      a = a + 208;
      r = (r + 8) * 16;
      g = (g + 8) * 16;
      b = (b + 8) * 16;
    } else {
      // sp_scaleは座標aを(-0.5,0.5)から何倍に拡大するか
      //   rgbの上位4bit
      // sp_centerは球の中心座標でa*sp_scaleと比較
      //   rgbの下位64bitから32を引く
      // radiusは半径
      //   (node_type - 1)
      a = a - 1;
      ivec3 val = make_ivec3(r, g, b);
      ivec3 sc = map{glm::ivec3, operator::div}(val, make_ivec3(64, 64, 64));
      ivec3 ce = map{glm::ivec3, operator::mod}(val, make_ivec3(64, 64, 64));
      ce = map{glm::ivec3, operator::sub}(ce, make_ivec3(32, 32, 32));
      if (edit_params == 1) {
	if (v == 0) {
	  ce.x = (ce.x > -31) ? (ce.x - 1) : ce.x;
	} else if (v == 1) {
	  ce.x = (ce.x < 31) ? (ce.x + 1) : ce.x;
	} else if (v == 2) {
	  ce.y = (ce.y > -31) ? (ce.y - 1) : ce.y;
	} else if (v == 3) {
	  ce.y = (ce.y < 31) ? (ce.y + 1) : ce.y;
	} else if (v == 4) {
	  ce.z = (ce.z > -31) ? (ce.z - 1) : ce.z;
	} else if (v == 5) {
	  ce.z = (ce.z < 31) ? (ce.z + 1) : ce.z;
	}
      } else {
	if (v == 0) {
	  sc.x = (sc.x > 0) ? (sc.x - 1) : sc.x;
	} else if (v == 1) {
	  sc.x = (sc.x < 3) ? (sc.x + 1) : sc.x;
	} else if (v == 2) {
	  sc.y = (sc.y > 0) ? (sc.y - 1) : sc.y;
	} else if (v == 3) {
	  sc.y = (sc.y < 3) ? (sc.y + 1) : sc.y;
	} else if (v == 4) {
	  sc.z = (sc.z > 0) ? (sc.z - 1) : sc.z;
	} else if (v == 5) {
	  sc.z = (sc.z < 3) ? (sc.z + 1) : sc.z;
	}
	if (sc.x == 0 && sc.y == 0 && sc.z == 0) {
	  return;
	}
      }
      if (v == 6) {
	a = (a > 1) ? (a - 1) : a;
      } else if (v == 7) {
	a = (a < 127) ? (a + 1) : a;
      }
      ce = map{glm::ivec3, operator::add}(ce, make_ivec3(32, 32, 32));
      sc = map{glm::ivec3, operator::mul}(sc, make_ivec3(64, 64, 64));
      val = map{glm::ivec3, operator::add}(sc, ce);
      a = a + 1;
      r = val.x;
      g = val.y;
      b = val.z;
    }
    const nv = ui(a << 24u) | ui(b << 16u) | ui(g << 8u) | ui(r);
    set_cur_tpat(nv);
  }
  private function void set_offset_scale(int x, int y, int z)
  {
    /*
    rotate_dir(x, y, z);
    int px = 0;
    int py = 0;
    int pz = 0;
    int sx = 0;
    int sy = 0;
    int sz = 0;
    if (edit_params == 1) {
      px = x;
      py = y;
      pz = z;
    } else {
      sx = x;
      sy = y;
      sz = z;
    }
    mutable& tex = *tex_octree;
    mutable v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type == 1) {
      return;
    }
    uint rad = 0;
    if (node_type == 0 || node_type == 255) {
      v = 0x05484848;
      rad = 4;
    } else {
      rad = node_type - 1;
    }
    px = static_cast{int}(v         & 0x0fu) - 8 + px;
    py = static_cast{int}((v >>  8) & 0x0fu) - 8 + py;
    pz = static_cast{int}((v >> 16) & 0x0fu) - 8 + pz;
    sx = static_cast{int}((v >>  4) & 0x0fu) + sx;
    sy = static_cast{int}((v >> 12) & 0x0fu) + sy;
    sz = static_cast{int}((v >> 20) & 0x0fu) + sz;
    function void clip_i7(int mutable& v) {
      if (v < -7) { v = -7; }
      if (v >  7) { v =  7; }
    }
    function void clip_u15(int mutable& v) {
      if (v <  0) { v = 0; }
      if (v > 15) { v = 15; }
    }
    clip_i7(px);
    clip_i7(py);
    clip_i7(pz);
    clip_u15(sx);
    clip_u15(sy);
    clip_u15(sz);
    debug_log("p:", px, py, pz, "s:", sx, sy, sz, "r:", rad);
    uint nv = 0;
    nv |= static_cast{uint}(px + 8)      ;
    nv |= static_cast{uint}(py + 8) <<  8;
    nv |= static_cast{uint}(pz + 8) << 16;
    nv |= static_cast{uint}(sx    ) <<  4;
    nv |= static_cast{uint}(sy    ) << 12;
    nv |= static_cast{uint}(sz    ) << 20;
    tex.set_index(cur_offset(), (nv & 0xffffffu) | ((rad + 1) << 24u));
    */
  }
  private function void set_radius(int diff)
  {
    /*
    mutable& tex = *tex_octree;
    mutable v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type == 1) {
      return;
    }
    int rad = 0;
    if (node_type == 0 || node_type == 255) {
      v = 0x05484848;
      rad = 4;
    } else {
      rad = static_cast{int}(node_type - 1);
      rad += diff;
      if (rad < 1) { rad = 64; }
      if (rad > 64) { rad = 1; }
    }
    debug_log("r:", rad);
    tex.set_index(cur_offset(),
      (v & 0xffffffu) | ((static_cast{uint}(rad) + 1) << 24u));
    */
  }
  private function void copy_value()
  {
    if (stat.edit_tpat) {
      copy_single = get_cur_tpat();
    } else {
      copy_block = copy_cur_tile();
    }
  }
  private function void paste_value()
  {
    if (stat.edit_tpat) {
      set_cur_tpat(copy_single);
    } else {
      paste_cur_tile(copy_block);
    }
  }
  private function void set_space()
  {
    set_cur_tpat(0u);
  }
  private function void set_brick()
  {
    if (!stat.edit_tpat) {
      return;
    }
    const cur = get_cur_tpat();
    const node_type = cur >> 24u;
    uint r;
    uint g;
    uint b;
    uint a;
    if (node_type == 0u) { // 空白
      a = 255u; // 壁
    } else if (node_type == 255u) { // 壁
      a = 208u; // 平面
      r = 9;
      g = 9;
      b = 9;
    } else if (node_type >= 160u) { // 曲面
      // sp_scaleは座標aを(-0.5,0.5)から何倍に拡大するか
      //   rgbの上位4bit
      // sp_centerは球の中心座標でa*sp_scaleと比較
      //   rgbの下位64bitから32を引く
      // radiusは半径
      //   (node_type - 1)
      a = 2u; // 曲面
      r = 64u * 2u + 32u;
      g = 64u * 2u + 32u;
      b = 64u * 2u + 32u;
    } else { // 曲面
      a = 255u; // 壁
    }
    const v = (a << 24u) | (b << 16u) | (g << 8u) | r;
    set_cur_tpat(v);
  }
  private function uint cur_offset() const
  {
    return 0u;
    /*
    mutable& tex = *tex_octree;
    const& pos = stat.pos;
    uint cur_x = (pos.node_x << bshift) | pos.x;
    uint cur_y = (pos.node_y << bshift) | pos.y;
    uint cur_z = (pos.node_z << bshift) | pos.z;
    return tex.index(cur_x, cur_y, cur_z);
    */
  }
  private function void restore_blink()
  {
    frame_cnt = 0;
    sync_gl_texture();
  }
  private function ivec3 cur_tpat_base() const
  {
    const& mp = stat.mappos;
    const v = voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
    if (!is_node_reference(v)) {
      return glm::ivec3();
    }
    const z = (v >> 16u) & 0xff;
    const y = (v >>  8u) & 0xff;
    const x = (v >>  0u) & 0xff;
    const r = glm::make_ivec3(si(x), si(y), si(z));
    return map{glm::ivec3, operator::mul}(r, tile_size);
  }
  private function uint get_cur_tmap() const
  {
    const& mp = stat.mappos;
    return voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
  }
  private function void set_cur_tmap(uint value)
  {
    const& mp = stat.mappos;
    return voxtmap->set(ui(mp.x), ui(mp.y), ui(mp.z), value);
  }
  private function bool is_cur_tmap_node_reference() const
  {
    const& mp = stat.mappos;
    const v = voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
    return is_node_reference(v);
  }
  private function ivec3 cur_tpat_index() const
  {
    return map{glm::ivec3, operator::add}(cur_tpat_base(), stat.patpos);
  }
  private function uint get_cur_tpat() const
  {
    const p = cur_tpat_index();
    return voxtpat->get(ui(p.x), ui(p.y), ui(p.z));
  }
  private function void set_cur_tpat(uint value)
  {
    const p = cur_tpat_index();
    voxtpat->set(ui(p.x), ui(p.y), ui(p.z), value);
  }
  private function texture_data copy_cur_tile() const
  {
    ivec3 bp = cur_tpat_base();
    const& tp = *voxtpat;
    mutable tl = *voxtile;
    // debug_log("mp", stat.mappos, "bp", bp);
    for (const z: 0 .. tl.get_depth()) {
      for (const y: 0 .. tl.get_height()) {
	for (const x: 0 .. tl.get_width()) {
	  const v = tp.get(x + ui(bp.x), y + ui(bp.y), z + ui(bp.z));
	  tl.set(x, y, z, v);
	}
      }
    }
    return tl;
  }
  private function void paste_cur_tile(texture_data const& tl)
  {
    ivec3 bp = cur_tpat_base();
    mutable& tp = *voxtpat;
    for (const z: 0 .. tl.get_depth()) {
      for (const y: 0 .. tl.get_height()) {
	for (const x: 0 .. tl.get_width()) {
	  const v = tl.get(x, y, z);
	  tp.set(x + ui(bp.x), y + ui(bp.y), z + ui(bp.z), v);
	}
      }
    }
  }
  private function void sync_gl_texture()
  {
    const& tp = stat.patpos;
    const& mp = stat.mappos;
    mutable tl = copy_cur_tile();
    mutable md = *voxtmap; // copy
    if (stat.edit_tpat) {
      for (const z: ui(tp.z) + 1 .. tl.get_depth()) {
	for (const y: 0 .. tl.get_height()) {
	  for (const x: 0 .. tl.get_width()) {
	    tl.set(x, y, z, 0u);
	  }
	}
      }
    }
    const blink = frame_cnt >= 8;
    if (blink) {
      if (stat.edit_tpat) {
	uint v = 0xffff0000u;
	if (edit_params == 1) {
	  v = 0xff00ff00u;
	} else if (edit_params == 2) {
	  v = 0xff0000ffu;
	}
	tl.set(ui(tp.x), ui(tp.y), ui(tp.z), v);
      } else {
	if (is_cur_tmap_node_reference()) {
	  for (const z: 0 .. tl.get_depth()) {
	    for (const y: 0 .. tl.get_height()) {
	      for (const x: 0 .. tl.get_width()) {
		tl.set(x, y, z, 0xffffffffu);
	      }
	    }
	  }
	} else {
	  md.set(ui(mp.x), ui(mp.y), ui(mp.z), 0u);
	}
      }
    }
    const z0 = ui(stat.edit_tpat ? mp.z : mp.z + 1);
    for (const z: z0 .. md.get_depth()) {
      for (const x: 0 .. md.get_width()) {
	for (const y: 0 .. md.get_height()) {
	  if (z == ui(mp.z) && x == ui(mp.x) && y == ui(mp.y)) {
	    continue;
	  }
	  md.set(x, y, z, 0u);
	}
      }
    }
    {
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_3D, gl_tmap->texture_id.get());
      glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, si(md.get_width()),
	si(md.get_height()), si(md.get_depth()), GL_RGBA, GL_UNSIGNED_BYTE,
	md.get_crawptr().to_cvoidptr());
    }
    {
      const cp = cur_tpat_base();
      glBindTexture(GL_TEXTURE_3D, gl_tpat->texture_id.get());
      glTexSubImage3D(GL_TEXTURE_3D, 0, cp.x, cp.y, cp.z, tile_size.x,
	tile_size.y, tile_size.z, GL_RGBA, GL_UNSIGNED_BYTE,
	tl.get_crawptr().to_cvoidptr());
    }
  }
  public function void on_frame()
  {
    sync_gl_texture();
    frame_cnt = (frame_cnt + 1) & 15;
  }
}

