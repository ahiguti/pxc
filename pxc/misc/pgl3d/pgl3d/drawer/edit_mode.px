private threaded namespace pgl3d::drawer::edit_mode "export-unsafe";
public import common -;
public import meta m;
public import pgl3d::drawer::base -;
public import glm -;
public import SDL2::api_types -;
public import text::serialize::compact_pod -;

metafunction ui static_cast{uint}; 
metafunction si static_cast{int}; 
metafunction to_ivec3 map{ivec3, static_cast{int, uint}};
metafunction to_uvec3 map{uvec3, static_cast{uint, int}};

private struct edit_state {
  public bool edit_tpat;
  public uvec3 mappos;
  public uvec3 patpos;
}

/*
private struct copy_buffer {
  public texture_data data;
  public uvec3 size;
}
*/

private function void texture_data_copy_range(texture_data mutable& dest,
  uvec3 const& dpos, texture_data const& src, uvec3 const& spos,
  uvec3 const& sz)
{
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	const v = src.get(spos.x + x, spos.y + y, spos.z + z);
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

private function void texture_data_set_range(texture_data mutable& dest,
  uvec3 const& dpos, uvec3 const& sz, uint v)
{
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

private struct texture_edit(texture_data const& data0,
  texture_data const& grid0)
{
  private ptr{texture_data} const data = make_ptr{texture_data}(data0);
  private texture_data grid = grid0;
  private uvec3 const grid_size = make_uvec3(grid.get_width(),
    grid.get_height(), grid.get_depth());
  private uvec3 modified_pos;
  private uvec3 modified_sz;
  public function cptr{texture_data} get_texture_data() const {
    return data;
  }
  public function pair{uvec3, uvec3} get_modified_range(bool reset_flag) {
    const r = pair{uvec3, uvec3}(modified_pos, modified_sz);
    if (reset_flag) {
      modified_pos = uvec3();
      modified_sz = uvec3();
    }
    return r;
  }
  public function void set(uvec3 const& pos, uint v)
  {
    const prev = data->get(pos.x, pos.y, pos.z);
    data->set(pos.x, pos.y, pos.z, v);
    recalc_distance_range(pos, make_uvec3(1, 1, 1), is_space_voxel(v));
  }
  public function void copy_range(uvec3 const& dpos, uvec3 const& sz,
    texture_data const& src, uvec3 const& spos)
  {
    texture_data_copy_range(*data, dpos, src, spos, sz);
    recalc_distance_range(dpos, sz, false);
  }
  public function void set_range(uvec3 const& dpos, uvec3 const& sz, uint v)
  {
    if (v == 0) {
      clear_range(dpos, sz);
    } else {
      texture_data_set_range(*data, dpos, sz, v);
      recalc_distance_range(dpos, sz, false);
    }
  }
  public function void clear_range(uvec3 const& dpos, uvec3 const& sz)
  {
    texture_data_set_range(*data, dpos, sz, 0);
    recalc_distance_range(dpos, sz, true);
  }
  private function void recalc_distance_range(uvec3 const& pos,
    uvec3 const& sz, bool clear_flag)
  {
    ivec3 mod_mi = to_ivec3(pos);
    ivec3 mod_mx = mod_mi + to_ivec3(sz) - make_ivec3(1, 1, 1);
    if (grid_size.x == 1) {
      update_distance(true, *data, mod_mi, mod_mx, clear_flag);
      modified_pos = to_uvec3(mod_mi);
      modified_sz = to_uvec3(mod_mx - mod_mi + make_ivec3(1, 1, 1));
    } else {
      ivec3 mod_mi_g = map{ivec3, operator::div}(mod_mi, to_ivec3(grid_size));
      ivec3 mod_mx_g = map{ivec3, operator::div}(mod_mx, to_ivec3(grid_size));
      for (const z: mod_mi_g.z .. mod_mx_g.z + 1) {
	for (const y: mod_mi_g.y .. mod_mx_g.y + 1) {
	  for (const x: mod_mi_g.x .. mod_mx_g.x + 1) {
	    const p = map{uvec3, operator::mul}(
	      make_uvec3(ui(x), ui(y), ui(z)),
	      grid_size);
	    texture_data_copy_range(grid, uvec3(), *data, p, grid_size);
	    set_distance(true, grid);
	    texture_data_copy_range(*data, p, grid, uvec3(), grid_size);
	  }
	}
      }
      modified_pos = map{uvec3, operator::mul}(
	to_uvec3(mod_mi_g), grid_size);
      modified_sz = map{uvec3, operator::mul}(
	to_uvec3(mod_mx_g - mod_mi_g + make_ivec3(1, 1, 1)), grid_size);
    }
  }
}

private struct texture_edit_view(texture_data const& data0,
  texture_data const& grid0)
{
  private ptr{texture_edit} current_edit =
    make_ptr{texture_edit}(data0, grid0);
  private ptr{texture_edit} current_view =
    make_ptr{texture_edit}(data0, grid0);
  private uint cursor_color;
  private uvec3 cursor_mi = make_uvec3(0, 0, data0.get_depth() - 1);
  private uvec3 cursor_mx = make_uvec3(0, 0, data0.get_depth() - 1);
  private edit_state state;
  private uvec3 const tex_sz = make_uvec3(data0.get_width(),
    data0.get_height(), data0.get_depth());
  private function uvec3 clamp(uvec3 v) const {
    v = map{uvec3, min}(v, make_uvec3(tex_sz.z - 1, tex_sz.z - 1,
      tex_sz.z - 1));
    return v;
  }
  public function cptr{texture_edit} get_edit() const {
    return current_edit;
  }
  public function cptr{texture_edit} get_view() const {
    return current_edit;
  }
  public function void set_cursor_color(uint c)
  {
    if (c == cursor_color) {
      return;
    }
    if (c == 0) {
      current_view->copy_range(cursor_mi,
	map{uvec3, operator::add}(
	  map{uvec3, operator::sub}(cursor_mx, cursor_mi),
	  make_uvec3(1, 1, 1)), *current_edit->get_texture_data(), cursor_mi);
    } else {
      current_view->set_range(cursor_mi,
	map{uvec3, operator::add}(
	  map{uvec3, operator::sub}(cursor_mx, cursor_mi),
	  make_uvec3(1, 1, 1)),
	c);
    }
    cursor_color = c;
  }
  public function void set_cursor_pos(uvec3 mi, uvec3 mx)
  {
    mi = clamp(mi);
    mx = clamp(mx);
    mx = map{uvec3, max}(mx, mi);
    uint const prev_z = cursor_mx.z;
    uint const next_z = mx.z;
    if (prev_z > next_z) {
      current_view->clear_range(make_uvec3(0, 0, next_z + 1),
	make_uvec3(tex_sz.x, tex_sz.y, prev_z - next_z));
    } else if (prev_z < next_z) {
      current_view->copy_range(make_uvec3(0, 0, prev_z + 1),
	make_uvec3(tex_sz.x, tex_sz.y, next_z - prev_z),
	*current_edit->get_texture_data(), make_uvec3(0, 0, prev_z + 1));
    }
    cursor_mi = mi;
    cursor_mx = mx;
  }
}

public struct edit_mode(ptr{texture_data} const& voxtile0,
  ptr{texture_data} const& voxtpat0, ptr{texture_data} const& voxtmap0,
  ptr{gl_texture} const& gl_tpat0, ptr{gl_texture} const& gl_tmap0)
<edit_mode_i>
{
  private ptr{texture_data} const voxtile = voxtile0;
  private ptr{texture_data} const voxtpat = voxtpat0; // FIXME: remove
  private ptr{texture_data} const voxtmap = voxtmap0; // FIXME: remove
  private ptr{texture_edit_view} const ev_tpat =
    make_ptr{texture_edit_view}(*voxtpat, *voxtile);
  private ptr{texture_edit_view} const ev_tmap =
    make_ptr{texture_edit_view}(*voxtmap, texture_data());
  private ptr{gl_texture} const gl_tpat = gl_tpat0;
  private ptr{gl_texture} const gl_tmap = gl_tmap0;
  private glm::uvec3 const tile_size = glm::make_uvec3(
    voxtile->get_width(), voxtile->get_height(), voxtile->get_depth());
  private glm::uvec3 const map_size = glm::make_uvec3(
    voxtmap0->get_width(), voxtmap0->get_height(), voxtmap0->get_depth());
  private glm::uvec3 const pat_size = map{glm::uvec3, operator::div}(
    glm::make_uvec3(voxtpat0->get_width(), voxtpat0->get_height(),
      voxtpat0->get_depth()),
    tile_size);
  private edit_state stat;
  private uint frame_cnt;
  private uint copy_single;
  private texture_data copy_block;
  private int edit_params;
  private string param_str;
  private glm::quat camera_angle;
  init();
  private function void init()
  {
    string buf;
    stat.mappos.z = 1u;
    sdl_load_file("c:/build/edit_state.raw", buf);
    if (!buf.empty()) {
      stat = from_string_compact_pod{edit_state}(buf);
    }
  }
  private function void save_state()
  {
    debug_log("edit_mode: save");
    const buf = to_string_compact_pod(stat);
    sdl_save_file("c:/build/edit_state.raw", buf);
    /*
    save_texture_data_raw("c:/build/voxtmap_edit.raw",
      *ev_tmap->get_edit()->get_texture_data());
    save_texture_data_raw("c:/build/voxtpat_edit.raw",
      *);
    */
    save_texture_data_raw("c:/build/voxtmap_edit.raw", *voxtmap);
    save_texture_data_raw("c:/build/voxtpat_edit.raw", *voxtpat);
  }
  public function void set_camera_angle(glm::quat const& angle)
  {
    camera_angle = angle;
  }
  public function void on_key_pressed(int scancode)
  {
    restore_blink();
    SDL_Scancode key = static_cast{SDL_Scancode}(scancode);
    if (key == SDL_SCANCODE_M) {
      save_state();
    } else if (key == SDL_SCANCODE_KP_MINUS) {
      set_space();
    } else if (key == SDL_SCANCODE_KP_PLUS) {
      set_brick();
    } else if (key == SDL_SCANCODE_KP_ENTER) {
      edit_params = (edit_params + 1) % 3;
    } else if (key == SDL_SCANCODE_C) {
      copy_value();
    } else if (key == SDL_SCANCODE_V) {
      paste_value();
    } else if (key == SDL_SCANCODE_I) {
      set_mark();
    }
    if (edit_params == 0) {
      if (key == SDL_SCANCODE_KP_4) {
	move_cursor(-1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_6) {
	move_cursor(1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_2) {
	move_cursor(0, -1, 0);
      } else if (key == SDL_SCANCODE_KP_8) {
	move_cursor(0, 1, 0);
      } else if (key == SDL_SCANCODE_KP_1) {
	move_cursor(0, 0, -1);
      } else if (key == SDL_SCANCODE_KP_3) {
	move_cursor(0, 0, 1);
      } else if (key == SDL_SCANCODE_KP_7) {
	if (is_cur_tmap_node_reference()) {
	  stat.edit_tpat = true;
	}
      } else if (key == SDL_SCANCODE_KP_9) {
	stat.edit_tpat = false;
      }
    } else if (stat.edit_tpat) {
      if (key == SDL_SCANCODE_KP_4) {
	set_param(0);
      } else if (key == SDL_SCANCODE_KP_6) {
	set_param(1);
      } else if (key == SDL_SCANCODE_KP_2) {
	set_param(2);
      } else if (key == SDL_SCANCODE_KP_8) {
	set_param(3);
      } else if (key == SDL_SCANCODE_KP_1) {
	set_param(4);
      } else if (key == SDL_SCANCODE_KP_3) {
	set_param(5);
      } else if (key == SDL_SCANCODE_KP_7) {
	set_param(6);
      } else if (key == SDL_SCANCODE_KP_9) {
	set_param(7);
      }
    }
    // debug_log("scancode", scancode);
  }
  private function void set_mark()
  {
  }
  private function void move_cursor(int x, int y, int z)
  {
    uvec3 d = make_uvec3(ui(x), ui(y), ui(z));
    if (stat.edit_tpat) {
      mutable& pos = stat.patpos;
      pos = map{glm::uvec3, operator::add}(pos, d);
      pos = map{glm::uvec3, operator::add}(pos, pat_size);
      pos = map{glm::uvec3, operator::mod}(pos, pat_size);
    } else {
      mutable& pos = stat.mappos;
      pos = map{glm::uvec3, operator::add}(pos, d);
      pos = map{glm::uvec3, operator::add}(pos, map_size);
      pos = map{glm::uvec3, operator::mod}(pos, map_size);
    }
  }
  private function void set_param(int v)
  {
    // edit_params != 0
    const cur = get_cur_tpat();
    const node_type = cur >> 24u;
    int r = si(cur & 0xffu);
    int g = si((cur >> 8u) & 0xffu);
    int b = si((cur >> 16u) & 0xffu);
    int a = si(node_type);
    if (node_type == 0 || node_type == 255) {
      return;
    }
    function int abs(int x) {
      return x > 0 ? x : -x;
    }
    if (node_type >= 160) {
      // 平面切断
      a = a - 208;
      r = r / 16 - 8;
      g = g / 16 - 8;
      b = b / 16 - 8;
      if (v == 0) {
	r = (r > -7) ? (r - 1) : r;
	a = 0;
      } else if (v == 1) {
	r = (r < 7) ? (r + 1) : r;
	a = 0;
      } else if (v == 2) {
	g = (g > -7) ? (g - 1) : g;
	a = 0;
      } else if (v == 3) {
	g = (g < 7) ? (g + 1) : g;
	a = 0;
      } else if (v == 4) {
	b = (b > -7) ? (b - 1) : b;
	a = 0;
      } else if (v == 5) {
	b = (b < 7) ? (b + 1) : b;
	a = 0;
      } else if (v == 6) {
	const d = abs(r) + abs(g) + abs(b);
	if (a > -d + 1) { a -= 1; }
      } else if (v == 7) {
	const d = abs(r) + abs(g) + abs(b);
	if (a < d - 1) { a += 1; }
      }
      if (r == 0 && g == 0 && b == 0) {
	return;
      }
      a = a + 208;
      r = (r + 8) * 16;
      g = (g + 8) * 16;
      b = (b + 8) * 16;
    } else {
      // sp_scaleは座標aを(-0.5,0.5)から何倍に拡大するか
      //   rgbの上位4bit
      // sp_centerは球の中心座標でa*sp_scaleと比較
      //   rgbの下位64bitから32を引く
      // radiusは半径
      //   (node_type - 1)
      a = a - 1;
      ivec3 val = make_ivec3(r, g, b);
      ivec3 sc = map{glm::ivec3, operator::div}(val, make_ivec3(64, 64, 64));
      ivec3 ce = map{glm::ivec3, operator::mod}(val, make_ivec3(64, 64, 64));
      ce = map{glm::ivec3, operator::sub}(ce, make_ivec3(32, 32, 32));
      if (edit_params == 1) {
	if (v == 0) {
	  ce.x = (ce.x > -31) ? (ce.x - 1) : ce.x;
	} else if (v == 1) {
	  ce.x = (ce.x < 31) ? (ce.x + 1) : ce.x;
	} else if (v == 2) {
	  ce.y = (ce.y > -31) ? (ce.y - 1) : ce.y;
	} else if (v == 3) {
	  ce.y = (ce.y < 31) ? (ce.y + 1) : ce.y;
	} else if (v == 4) {
	  ce.z = (ce.z > -31) ? (ce.z - 1) : ce.z;
	} else if (v == 5) {
	  ce.z = (ce.z < 31) ? (ce.z + 1) : ce.z;
	}
      } else {
	if (v == 0) {
	  sc.x = (sc.x > 0) ? (sc.x - 1) : sc.x;
	} else if (v == 1) {
	  sc.x = (sc.x < 3) ? (sc.x + 1) : sc.x;
	} else if (v == 2) {
	  sc.y = (sc.y > 0) ? (sc.y - 1) : sc.y;
	} else if (v == 3) {
	  sc.y = (sc.y < 3) ? (sc.y + 1) : sc.y;
	} else if (v == 4) {
	  sc.z = (sc.z > 0) ? (sc.z - 1) : sc.z;
	} else if (v == 5) {
	  sc.z = (sc.z < 3) ? (sc.z + 1) : sc.z;
	}
	if (sc.x == 0 && sc.y == 0 && sc.z == 0) {
	  return;
	}
      }
      if (v == 6) {
	a = (a > 1) ? (a - 1) : a;
      } else if (v == 7) {
	a = (a < 127) ? (a + 1) : a;
      }
      ce = map{glm::ivec3, operator::add}(ce, make_ivec3(32, 32, 32));
      sc = map{glm::ivec3, operator::mul}(sc, make_ivec3(64, 64, 64));
      val = map{glm::ivec3, operator::add}(sc, ce);
      a = a + 1;
      r = val.x;
      g = val.y;
      b = val.z;
    }
    const nv = ui(a << 24u) | ui(b << 16u) | ui(g << 8u) | ui(r);
    set_cur_tpat(nv);
  }
  private function void set_offset_scale(int x, int y, int z)
  {
    /*
    rotate_dir(x, y, z);
    int px = 0;
    int py = 0;
    int pz = 0;
    int sx = 0;
    int sy = 0;
    int sz = 0;
    if (edit_params == 1) {
      px = x;
      py = y;
      pz = z;
    } else {
      sx = x;
      sy = y;
      sz = z;
    }
    mutable& tex = *tex_octree;
    mutable v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type == 1) {
      return;
    }
    uint rad = 0;
    if (node_type == 0 || node_type == 255) {
      v = 0x05484848;
      rad = 4;
    } else {
      rad = node_type - 1;
    }
    px = static_cast{int}(v         & 0x0fu) - 8 + px;
    py = static_cast{int}((v >>  8) & 0x0fu) - 8 + py;
    pz = static_cast{int}((v >> 16) & 0x0fu) - 8 + pz;
    sx = static_cast{int}((v >>  4) & 0x0fu) + sx;
    sy = static_cast{int}((v >> 12) & 0x0fu) + sy;
    sz = static_cast{int}((v >> 20) & 0x0fu) + sz;
    function void clip_i7(int mutable& v) {
      if (v < -7) { v = -7; }
      if (v >  7) { v =  7; }
    }
    function void clip_u15(int mutable& v) {
      if (v <  0) { v = 0; }
      if (v > 15) { v = 15; }
    }
    clip_i7(px);
    clip_i7(py);
    clip_i7(pz);
    clip_u15(sx);
    clip_u15(sy);
    clip_u15(sz);
    debug_log("p:", px, py, pz, "s:", sx, sy, sz, "r:", rad);
    uint nv = 0;
    nv |= static_cast{uint}(px + 8)      ;
    nv |= static_cast{uint}(py + 8) <<  8;
    nv |= static_cast{uint}(pz + 8) << 16;
    nv |= static_cast{uint}(sx    ) <<  4;
    nv |= static_cast{uint}(sy    ) << 12;
    nv |= static_cast{uint}(sz    ) << 20;
    tex.set_index(cur_offset(), (nv & 0xffffffu) | ((rad + 1) << 24u));
    */
  }
  private function void set_radius(int diff)
  {
    /*
    mutable& tex = *tex_octree;
    mutable v = tex.get_index(cur_offset());
    const node_type = (v >> 24u);
    if (node_type == 1) {
      return;
    }
    int rad = 0;
    if (node_type == 0 || node_type == 255) {
      v = 0x05484848;
      rad = 4;
    } else {
      rad = static_cast{int}(node_type - 1);
      rad += diff;
      if (rad < 1) { rad = 64; }
      if (rad > 64) { rad = 1; }
    }
    debug_log("r:", rad);
    tex.set_index(cur_offset(),
      (v & 0xffffffu) | ((static_cast{uint}(rad) + 1) << 24u));
    */
  }
  private function void copy_value()
  {
    if (stat.edit_tpat) {
      copy_single = get_cur_tpat();
    } else {
      copy_block = copy_cur_tile();
    }
  }
  private function void paste_value()
  {
    if (stat.edit_tpat) {
      set_cur_tpat(copy_single);
    } else {
      paste_cur_tile(copy_block);
    }
  }
  private function void set_space()
  {
    set_cur_tpat(0u);
  }
  private function void set_brick()
  {
    if (!stat.edit_tpat) {
      return;
    }
    const cur = get_cur_tpat();
    const node_type = cur >> 24u;
    uint r;
    uint g;
    uint b;
    uint a;
    if (node_type == 0u) { // 空白
      a = 255u; // 壁
    } else if (node_type == 255u) { // 壁
      a = 208u; // 平面
      r = 9;
      g = 9;
      b = 9;
    } else if (node_type >= 160u) { // 曲面
      // sp_scaleは座標aを(-0.5,0.5)から何倍に拡大するか
      //   rgbの上位4bit
      // sp_centerは球の中心座標でa*sp_scaleと比較
      //   rgbの下位64bitから32を引く
      // radiusは半径
      //   (node_type - 1)
      a = 2u; // 曲面
      r = 64u * 2u + 32u;
      g = 64u * 2u + 32u;
      b = 64u * 2u + 32u;
    } else { // 曲面
      a = 255u; // 壁
    }
    const v = (a << 24u) | (b << 16u) | (g << 8u) | r;
    set_cur_tpat(v);
  }
  private function uint cur_offset() const
  {
    return 0u;
    /*
    mutable& tex = *tex_octree;
    const& pos = stat.pos;
    uint cur_x = (pos.node_x << bshift) | pos.x;
    uint cur_y = (pos.node_y << bshift) | pos.y;
    uint cur_z = (pos.node_z << bshift) | pos.z;
    return tex.index(cur_x, cur_y, cur_z);
    */
  }
  private function void restore_blink()
  {
    frame_cnt = 0;
    sync_gl_texture();
  }
  private function uvec3 cur_tpat_base() const
  {
    const& mp = stat.mappos;
    const v = voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
    if (!is_node_reference(v)) {
      return glm::uvec3();
    }
    const z = (v >> 16u) & 0xff;
    const y = (v >>  8u) & 0xff;
    const x = (v >>  0u) & 0xff;
    const r = glm::make_uvec3(x, y, z);
    return map{glm::uvec3, operator::mul}(r, tile_size);
  }
  private function uint get_cur_tmap() const
  {
    const& mp = stat.mappos;
    return voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
  }
  private function void set_cur_tmap(uint value)
  {
    const& mp = stat.mappos;
    return voxtmap->set(mp.x, mp.y, mp.z, value);
  }
  private function bool is_cur_tmap_node_reference() const
  {
    const& mp = stat.mappos;
    const v = voxtmap->get(ui(mp.x), ui(mp.y), ui(mp.z));
    return is_node_reference(v);
  }
  private function uvec3 cur_tpat_index() const
  {
    return map{glm::uvec3, operator::add}(cur_tpat_base(), stat.patpos);
  }
  private function uint get_cur_tpat() const
  {
    const p = cur_tpat_index();
    return voxtpat->get(p.x, p.y, p.z);
  }
  private function void set_cur_tpat(uint value)
  {
    const p = cur_tpat_index();
    voxtpat->set(p.x, p.y, p.z, value);
  }
  private function texture_data copy_cur_tile() const
  {
    uvec3 bp = cur_tpat_base();
    const& tp = *voxtpat;
    mutable tl = *voxtile;
    // debug_log("mp", stat.mappos, "bp", bp);
    for (const z: 0 .. tl.get_depth()) {
      for (const y: 0 .. tl.get_height()) {
	for (const x: 0 .. tl.get_width()) {
	  const v = tp.get(x + bp.x, y + bp.y, z + bp.z);
	  tl.set(x, y, z, v);
	}
      }
    }
    return tl;
  }
  private function void paste_cur_tile(texture_data const& tl)
  {
    uvec3 bp = cur_tpat_base();
    mutable& tp = *voxtpat;
    for (const z: 0 .. tl.get_depth()) {
      for (const y: 0 .. tl.get_height()) {
	for (const x: 0 .. tl.get_width()) {
	  const v = tl.get(x, y, z);
	  tp.set(x + bp.x, y + bp.y, z + bp.z, v);
	}
      }
    }
  }
  private function void sync_gl_texture()
  {
    const& tp = stat.patpos;
    const& mp = stat.mappos;
    mutable tl = copy_cur_tile();
    mutable md = *voxtmap; // copy
    if (stat.edit_tpat) {
      // パターン編集中は座標+1より上を非表示
      for (const z: ui(tp.z) + 1 .. tl.get_depth()) {
	for (const y: 0 .. tl.get_height()) {
	  for (const x: 0 .. tl.get_width()) {
	    tl.set(x, y, z, 0u);
	  }
	}
      }
    }
    const blink = frame_cnt >= 8;
    if (blink) {
      if (stat.edit_tpat) {
	uint v = 0xffff0000u;
	if (edit_params == 1) {
	  v = 0xff00ff00u;
	} else if (edit_params == 2) {
	  v = 0xff0000ffu;
	}
	tl.set(ui(tp.x), ui(tp.y), ui(tp.z), v);
      } else {
	if (is_cur_tmap_node_reference()) {
	  for (const z: 0 .. tl.get_depth()) {
	    for (const y: 0 .. tl.get_height()) {
	      for (const x: 0 .. tl.get_width()) {
		tl.set(x, y, z, 0xffffffffu);
	      }
	    }
	  }
	} else {
	  md.set(ui(mp.x), ui(mp.y), ui(mp.z), 0u);
	}
      }
    }
    const z0 = ui(stat.edit_tpat ? mp.z : mp.z + 1);
    for (const z: z0 .. md.get_depth()) {
      for (const x: 0 .. md.get_width()) {
	for (const y: 0 .. md.get_height()) {
	  if (z == ui(mp.z) && x == ui(mp.x) && y == ui(mp.y)) {
	    continue;
	  }
	  md.set(x, y, z, 0u);
	}
      }
    }
    {
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_3D, gl_tmap->texture_id.get());
      glTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, si(md.get_width()),
	si(md.get_height()), si(md.get_depth()), GL_RGBA, GL_UNSIGNED_BYTE,
	md.get_crawptr().to_cvoidptr());
    }
    {
      const cp = cur_tpat_base();
      glBindTexture(GL_TEXTURE_3D, gl_tpat->texture_id.get());
      glTexSubImage3D(GL_TEXTURE_3D, 0, si(cp.x), si(cp.y), si(cp.z),
	si(tile_size.x), si(tile_size.y), si(tile_size.z),
	GL_RGBA, GL_UNSIGNED_BYTE, tl.get_crawptr().to_cvoidptr());
    }
  }
  public function void on_frame()
  {
    sync_gl_texture();
    frame_cnt = (frame_cnt + 1) & 15;
  }
}

