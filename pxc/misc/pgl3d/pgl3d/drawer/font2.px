private threaded namespace pgl3d::drawer::font2 "export-unsafe";
public import common -;
public import pgl3d::drawer::base -;
public import meta m;

private tsvaluetype struct font2_uniforms()
{
  public glm::vec2 screen_size_px;
  public int sampler_font;
}

private tsvaluetype struct font2_instance_attributes()
{
  public glm::vec4 idata;
}

private tsvaluetype struct font2_vertex_attributes()
{
  public glm::vec2 texture_size_px;
  public glm::vec2 texture_origin_px;
  public glm::vec2 char_size_px;
  public glm::vec2 coord_clamp;
  public float char_px;
  public float char_point_size;
}

public struct drawer_font2(shader_config const& glc,
  resource_pool_ptr const& res)
<pgldrawer_i>
{
  metafunction tattr font2_vertex_attributes;
  font2_shader_ptr sdr_fn = init_font2_shader(glc);
  gl_texture texture_font;
  init();
  private function void init()
  {
    const fnames = make_farray{string}(
      "mplus-1m-bold.ttf",
      // "/Library/Fonts/Tahoma.ttf",
      "/Library/Fonts/Osaka.ttf",
      "/usr/share/fonts/mplus/mplus-1m-bold.ttf",
      "/usr/share/fonts/liberation/LiberationMono-Regular.ttf");
    load_gl_texture_fixedwidth_font(texture_font, fnames);
  }
  public function string get_vbid_name() const { return "vbid_font2"; }
  public function string get_instances_vbid_name() const {
    return "vbid_font2"; }
  public function string get_vertices_vbid_name() const {
    return "vbid_font2"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_font2}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(true, false);
  }
  public function string builtin_vertex_set_name() const {
    return "default_font";
  }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const
  {
    const ti = get_texture_info("font");
    const char_w = static_cast{float}(ti.char_w);
    const char_h = static_cast{float}(ti.char_h);
    const point_size = static_cast{float}(max(ti.char_w, ti.char_h));
    const char_size_px = glm::make_vec2(char_w, char_h);
    const texture_size_px = glm::make_vec2(
      static_cast{float}(ti.surface_w),
      static_cast{float}(ti.surface_h));
    const clamp_x = char_w / point_size;
    const clamp_y = char_h / point_size;
    font2_vertex_attributes v;
    v.char_size_px = char_size_px;
    v.texture_size_px = texture_size_px;
    v.texture_origin_px = glm::make_vec2(0.0, 0.0);
    v.coord_clamp = glm::make_vec2(clamp_x, clamp_y);
    v.char_px = static_cast{float}(ti.char_w);
    v.char_point_size = point_size;
    vptr->push_point{font2_vertex_attributes}(v);
  }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    if (name == "font") {
      r.surface_w = texture_font.surface_w;
      r.surface_h = texture_font.surface_h;
      r.char_w = texture_font.char_w;
      r.char_h = texture_font.char_h;
    }
    return r;
  }
  public function void resize_screen(shader_config const& glc, int width,
    int height)
  { 
  }
  public function void reload_shaders()
  {
  }
  public function uint get_postprocess_framebuffer(draw_step step) const
  {
    return 0U;
  }
  public function bool has_step(draw_step step) const
  {
    return step == draw_step_hud;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vbid_t vbid,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (step == draw_step_hud) {
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, texture_font.texture_id.get());
      glDisable(GL_DEPTH_TEST);
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      const screen_size_px = glm::make_vec2(
	static_cast{float}(cam_df.display_width),
	static_cast{float}(cam_df.display_height));
      mutable& sdr = *sdr_fn;
      glUseProgram(sdr.program);
      glUniform1i(sdr.u_sampler_font, 0);
      glUniform2fv(sdr.u_screen_size_px, 1, screen_size_px.to_crawptr());
      aibuf.draw(sdr, bo, bo_ib, vbid,
	glc.enable_instanced, glc.enable_uniform_instancing);
    }
  }
  public function option{ptr{edit_mode_i}} get_edit_mode() const
  {
    return option{ptr{edit_mode_i}}();
  }
}

metafunction font2_shader_ptr
  ptr{glshader{
    font2_uniforms, font2_instance_attributes, font2_vertex_attributes}};

function font2_shader_ptr
init_font2_shader(shader_config const& g)
{
  string v;
  v += g.prepend();
  v += "uniform vec2 screen_size_px;\n";
  v += g.vert_in() + "vec2 texture_size_px;\n";
  v += g.vert_in() + "vec2 texture_origin_px;\n";
  v += g.vert_in() + "vec2 char_size_px;\n";
  v += g.vert_in() + "vec2 coord_clamp;\n";
  v += g.vert_in() + "float char_point_size;\n";
  v += g.decl_instance_attr("vec4", "idata");
  v += g.vert_out() + "vec2 vary_texture_size_px;\n";
  v += g.vert_out() + "vec2 vary_texture_origin_px;\n";
  v += g.vert_out() + "vec2 vary_char_size_px;\n";
  v += g.vert_out() + "vec2 vary_coord_clamp;\n";
  v += g.vert_out() + "float vary_point_size;\n";
  v += "void main(void) {\n";
  v += "vec4 idata_i = " + g.instance_attr("idata") + ";\n";
  v += "float ch = idata_i.x;\n";
  v += "vec2 screen_pos = idata_i.zw;\n";
  v += "vec2 screen_px = ";
  v += "  floor((screen_pos + 1.0) * screen_size_px * 0.5 + 0.5);\n";
  v += "screen_px += char_point_size * 0.5;\n";
  v += "screen_pos = screen_px / screen_size_px * 2.0 - 1.0;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "gl_PointSize = char_point_size;\n";
  v += "vary_texture_size_px = texture_size_px;\n";
  v += "vary_texture_origin_px = texture_origin_px";
  v += "  + vec2(char_size_px.x * ch, 0.0);\n";
  v += "vary_char_size_px = char_size_px;\n";
  v += "vary_coord_clamp = coord_clamp;\n";
  v += "vary_point_size = char_point_size;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler_font;\n";
  f += g.frag_in() + "vec2 vary_texture_size_px;\n";
  f += g.frag_in() + "vec2 vary_texture_origin_px;\n";
  f += g.frag_in() + "vec2 vary_char_size_px;\n";
  f += g.frag_in() + "vec2 vary_coord_clamp;\n";
  f += g.frag_in() + "float vary_point_size;\n";
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord;\n";
  f += "if (xy.x > vary_coord_clamp.x) { discard; }\n";
  f += "vec2 pcoord = vary_point_size * xy;\n";
  f += "vec2 texcoord = (vary_texture_origin_px + pcoord)";
  f += "  / vary_texture_size_px;\n";
  f += "vec4 col = " +  g.texture2d() + "(sampler_font, texcoord);\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 0.0, col.a);\n";
  f += "}\n";
  return make_glshader_ptr{font2_uniforms, font2_instance_attributes,
    font2_vertex_attributes}(v, f, "idata", g.debug_level, "font2");
}

private threaded function void prepare_instance_data_font2(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  const sli = sn.trans.value.to_cslice();
  idata.instance_buffer.append(sli[0 .. 4]);
}

