public threaded namespace pgl3d::scene_node;
public import common -;
public import numeric::fpmath -;
public import glm;
public import meta m;
public import exception -;

public metafunction vs_id_t distinct_uint{uint, "pgl3d::vs_id"};
public metafunction bo_id_t distinct_uint{uint, "pgl3d::bo_id"};

public threaded function bo_id_t
bo_id_invalid() { return static_cast{bo_id_t}(-1); }
public threaded function vs_id_t
vs_id_invalid() { return static_cast{vs_id_t}(-1); }

public tsvaluetype struct
joint_id_type()
{
  public bo_id_t bo_id = bo_id_invalid();
  public vs_id_t vs_id = vs_id_invalid();
}

public threaded struct
scene_node(joint_id_type const& joint_id0, glm::mat4 const& trans0)
{
  // FIXME: expects allocator always returns 16byte-aligned addresses
  public aligned_16{glm::mat4} const trans = aligned_16{glm::mat4}(trans0);
  public joint_id_type const joint_id = joint_id0;
  public varray{scene_node} children;
}

public mtvaluetype struct
node_factory
{
  public varray{node_buffer_info} binfo;
  public tree_map{string, joint_id_type} name_to_id;
  public function scene_node
  make_node_by_id(joint_id_type const& joint_id, glm::mat4 const& trans) const
  {
    mutable sn = scene_node(joint_id, trans);
    if (joint_id.bo_id != bo_id_invalid() &&
      joint_id.vs_id != vs_id_invalid())
    {
      const& nbi = binfo[joint_id.bo_id];
      const& nvi = nbi.vs_arr[joint_id.vs_id];
      for (const i, const& nji: nvi.joints) {
	const csn = make_node_by_id(nji.joint_id, nji.trans);
	sn.children.push_back(csn);
      }
    }
    return sn;
  }
  public function scene_node
  make_node_by_name(cstrref const& name, glm::mat4 const& trans) const
  {
    const rng = name_to_id.equal_crange(name);
    return make_node_by_id(*rng, trans);
  }
  public function joint_id_type get_joint_id_by_name(cstrref const& name) const
  {
    const rng = name_to_id.equal_crange(name);
    return *rng;
  }
}

public mtvaluetype struct
node_buffer_info
{
  public varray{node_vs_info} vs_arr;
}

public mtvaluetype struct
node_vs_info
{
  public varray{node_joint_info} joints;
}

public tsvaluetype struct
node_joint_info()
{
  public joint_id_type joint_id;
  public glm::mat4 trans;
}

