public namespace pglscene;
public import common -;
public import numeric::fpmath -;
public import glm;
public import io::time -;
public import io::environ -;
public import exception -;
public import meta m;
public import text::string::positional -;

public import glnode -;
public import pglbase -;
public import pglcommon -;
public import pglapi -;

public multithreaded struct
motion_thread_shared(varray{instances_type} const& bo_instances0,
  tptr{pgl3d_scene_shared} const& pss0)
{
  public varray{instances_type} bo_instances = bo_instances0;
  public tptr{pgl3d_scene_shared} pss = pss0;
  public bool modifying = false;
  public bool terminate_motion_thread = false;
  public float frame_speed_mul = 1.0f;
  public projection_info cam;
  public string message;
  public size_t stat_num_objects;
}

public struct
motion_thread_object(node_factory const& nfac,
  varray{instances_type} const& bo_instances,
  tptr{pgl3d_scene_shared} const& pss)
{
  public tptr{motion_thread_shared} const sharedp =
    make_tptr{motion_thread_shared}(bo_instances, pss);
  private callable_ptr{void, m::nil} const thr =
    make_thread_ptr{motion_thread_main}(sharedp, nfac);
  function ~ {
    mutable lck = lock_guard{motion_thread_shared}(sharedp);
    lck->terminate_motion_thread = true;
    lck.notify_one();
  }
  public function {f} void wait_and_exec()
  {
    mutable lck = lock_guard{motion_thread_shared}(sharedp);
    mutable& shared = *lck;
    while (true) {
      if (!shared.modifying) {
	break;
      }
      lck.wait();
    }
    f(shared);
    shared.modifying = true;
    lck.notify_one();
  }
}

/* private */

threaded function void
motion_thread_main(tptr{motion_thread_shared} const& sptr,
  node_factory const& nfac0)
{
  ptr{pgl3d_scene} const ps = sptr->pss->make_scene(nfac0);
  mutable lck = lock_guard{motion_thread_shared}(sptr);
  while (true) {
    mutable& shared = *lck;
    /* wait until shared.modifying == false */
    if (shared.terminate_motion_thread) {
      break;
    }
    if (!shared.modifying) {
      lck.wait();
      continue;
    }
    /* motion step */
    {
      position_angle camera_upd;
      position_angle light_upd;
      const nodep = ps->on_motion_step(shared.frame_speed_mul, shared.cam,
	shared.message, *shared.pss, camera_upd, light_upd);
      shared.cam.camera = camera_upd;
      shared.cam.light = light_upd;
      const sm_view = shared.cam.light.to_mat4().inverse();
      const sm_vp = shared.cam.sm_projection * sm_view;
      const vp = shared.cam.projection * shared.cam.camera.to_mat4().inverse();
      node_common_data ncd;
      ncd.shadowmapping_vp = sm_vp;
      ncd.vp = vp;
      {
	clear_instances(shared.bo_instances);
	prepare_instance_data(*nodep, ncd, shared.bo_instances);
      }
      shared.stat_num_objects = ncd.stat_num_objects;
    }
    shared.modifying = false;
    lck.notify_one();
  }
}

metafunction nodeptr ptr{scene_node{node_data}};

threaded function nodeptr make_nodeptr()
{
  return make_ptr{scene_node{node_data}}(joint_id_type(), glm::mat4());
}

threaded struct node_common_data
{
  public glm::mat4 shadowmapping_vp;
  public glm::mat4 vp;
  public size_t stat_num_objects;
}

threaded function {t} void
buffer_append(varray{float} mutable& arr, t const& v)
{
  if (m::eq{t, float}) {
    arr.push_back(v);
  } else if (m::or{
    m::eq{t, glm::vec2},
    m::eq{t, glm::vec3},
    m::eq{t, glm::vec4},
    m::eq{t, glm::mat2},
    m::eq{t, glm::mat3},
    m::eq{t, glm::mat4}}) {
    arr.append(v.to_cslice());
  } else {
    expand (sym: m::field_names{t})
    {
      buffer_append(arr, v.sym);
    }
  }
}

threaded function void
clear_instances(varray{instances_type} mutable& ibs)
{
  for (const bo_id, mutable& instances: ibs) {
    for (const i, mutable& ai: instances) {
      for (const j, mutable& aj: ai) {
	aj.instance_buffer.clear();
      }
    }
  }
}

threaded function {tsn} void
prepare_instance_data(tsn const& sn, node_common_data mutable& ncd,
  varray{instances_type} mutable& ibs)
{
  const bo_id = sn.joint_id.bo_id;
  const vs_id = sn.joint_id.vs_id;
  if (bo_id >= 0 && vs_id >= 0) {
    ++ncd.stat_num_objects;
    mutable& ibarr = ibs[bo_id][static_cast{size_t}(vs_id)];
    if (bo_id == vbid_particle) {
      /* particle */
      const mvp = ncd.vp * sn.trans;
      buffer_append(ibarr[0].instance_buffer, mvp);
    } else if (bo_id == vbid_lineparticle) {
      /* lineparticle */
      const sli = sn.trans.to_cslice();
      ibarr[0].instance_buffer.append(sli[0 .. 9]);
    } else if (bo_id == vbid_rect2d) {
      /* rect2d */
      const sli = sn.trans.to_cslice();
      ibarr[0].instance_buffer.append(sli[0 .. 4]);
    } else if (bo_id == vbid_font2) {
      const sli = sn.trans.to_cslice();
      ibarr[0].instance_buffer.append(sli[0 .. 4]);
    } else {
      /* ibuf_id == 0 for model matrix */
      buffer_append(ibarr[0].instance_buffer, sn.trans);
      if (bo_id == vbid_main || bo_id == vbid_main2) {
	/* ibuf_id == 1 for shadowmapping mvp */
	const smvp = ncd.shadowmapping_vp * sn.trans;
	buffer_append(ibarr[1].instance_buffer, smvp);
      }
    }
  }
  for (const i, const& snp: sn.children) {
    prepare_instance_data(*snp, ncd, ibs);
  }
}

