private threaded namespace demoapp::texture::triangles_texture;
public import common -;
public import meta m;
public import pgl3d::texture::texture -;
public import pgl3d::texture::voxel -;
public import pgl3d::engine::util -;
public import pgl3d::engine::pglconfig -;
public import pgl3d::engine::pglbase -;
public import pgl3d::geometry::funcs -;
public import demoapp::texture::tile -;
public import glm -;

struct demoapp_textures(bool edit_mode)
{
  public ivec3 const voxtile_size_l2 = make_ivec3(4, 4, 4);
  public ivec3 const voxtpat_size_l2 = make_ivec3(4, 4, 4);
  // public ivec3 const voxtmap_size_l2 = make_ivec3(10, 10, 7);
  public ivec3 const voxtmap_size_l2 = make_ivec3(8, 8, 5);
  // 3d texture, voxel raycasting
  public ptr{texture_data} tex_voxtpat = make_ptr{texture_data}();
  public ptr{texture_data} tex_voxtmap = make_ptr{texture_data}();
  public ptr{texture_data} tex_voxtile = make_ptr{texture_data}();
  public varray{ptr{texture_data}} voxtpat_mip;
  public varray{ptr{texture_data}} voxtmap_mip;
  // 2d texture, parallax mapping
  public ptr{texture_data} tex_tcol = make_ptr{texture_data}();
  public ptr{texture_data} tex_tdep = make_ptr{texture_data}();
  public ptr{texture_data} tex_tmap = make_ptr{texture_data}();
}

public function void
prepare_triangles_texture_data(pgl3d_config const& cfg,
  textures_ptr const& textures)
{
  demoapp_textures txs = demoapp_textures(cfg.get("edit_mode", 0, 0, 1) != 0);
  prepare_parallax_mapping_texture_data(txs);
  prepare_raycasting_texture_data(cfg, txs);
  textures->insert("triangles.tile_color", txs.tex_tcol);
  textures->insert("triangles.tile_depth", txs.tex_tdep);
  textures->insert("triangles.tile_map", txs.tex_tmap);
  for (const i, const& t: txs.voxtpat_mip) {
    string k = "triangles.voxtpat." + to_string(i);
    textures->insert(k, t);
  }
  for (const i, const& t: txs.voxtmap_mip) {
    string k = "triangles.voxtmap." + to_string(i);
    textures->insert(k, t);
  }
  textures->insert("triangles.voxtile", txs.tex_voxtile);
}

function void
prepare_raycasting_texture_data(pgl3d_config const& cfg,
  demoapp_textures mutable& txs)
{
  metafunction ui static_cast{uint};
  mutable& tex_voxtmap = txs.tex_voxtmap;
  mutable& tex_voxtpat = txs.tex_voxtpat;
  mutable& tex_voxtile = txs.tex_voxtile;
  tex_voxtile->set_size_l2(ui(txs.voxtile_size_l2.x),
    ui(txs.voxtile_size_l2.y), ui(txs.voxtile_size_l2.z));
  const edit_mode = cfg.get("edit_mode", 0, 0, 1) != 0;
  if (!edit_mode) {
    txs.voxtpat_mip = load_texture_data_array_raw("voxtpat_mip.raw");
    txs.voxtmap_mip = load_texture_data_array_raw("voxtmap_mip.raw");
  }
  if (!txs.voxtpat_mip.empty()) {
    tex_voxtpat = txs.voxtpat_mip[0];
  }
  if (!txs.voxtmap_mip.empty()) {
    tex_voxtmap = txs.voxtmap_mip[0];
  }
  if (tex_voxtpat->get_width() == 1 || tex_voxtmap->get_width() == 1) {
    debug_log("generate raw texture");
    prepare_texture_data_3d_tpat(edit_mode, *tex_voxtpat, txs.voxtile_size_l2,
      txs.voxtpat_size_l2);
    debug_log("tpat done");
    prepare_texture_data_3d_tmap(edit_mode, *tex_voxtmap, txs.voxtpat_size_l2,
      txs.voxtmap_size_l2);
    debug_log("tmap done");
    debug_log("tmap 0,0,1", to_hexstring(tex_voxtmap->get(0, 0, 1)));
    bool enable_calc_distance = cfg.get("calc_distance", 1, 0, 1) != 0;
    bool enable_short_circuit = cfg.get("short_circuit", 0, 0, 1) != 0;
    const rnd = make_ptr{rand_generator}(333U);
    function void texture_make_mipmap(texture_data const& tsrc,
      texture_data mutable& tdest, uint miplevel)
    {
      tdest.set_size_l2(tsrc.get_width_l2() - 1, tsrc.get_height_l2() - 1,
	tsrc.get_depth_l2() - 1);
      for (const x: 0 .. tdest.get_width()) {
	for (const y: 0 .. tdest.get_height()) {
	  for (const z: 0 .. tdest.get_depth()) {
	    const v0 = rnd->generate() >> 24;
	    const x1 = x * 2 + (v0 & 1);
	    const y1 = y * 2 + ((v0 >> 1) & 1);
	    const z1 = z * 2 + ((v0 >> 2) & 1);
	    mutable v = tsrc.get(x1, y1, z1);
	    if (!is_space_voxel(v)) {
	      v |= 0xff000000; // 空白以外は塗りつぶしに変換
	    }
	    tdest.set(x, y, z, v);
	  }
	}
      }
    }
    const uint miplevel_max = ui(
      fold_list{max}(0, txs.voxtile_size_l2));
    {
      txs.voxtpat_mip.push_back(tex_voxtpat); // tpat miplevel 0
      mutable tex = tex_voxtpat;
      for (const miplevel: 0 .. miplevel_max) {
	debug_log("tpat miplevel", miplevel);
	const tex_m = make_ptr{texture_data}();
	texture_make_mipmap(*tex, *tex_m, miplevel);
	txs.voxtpat_mip.push_back(tex_m);
	tex = tex_m;
      }
    }
    {
      txs.voxtmap_mip.push_back(tex_voxtmap); // tmap miplevel 0
      mutable tex = tex_voxtmap;
      for (const miplevel: 0 .. miplevel_max) {
	debug_log("tmap miplevel", miplevel);
	const tex_m = make_ptr{texture_data}();
	texture_make_mipmap(*tex, *tex_m, miplevel);
	txs.voxtmap_mip.push_back(tex_m);
	tex = tex_m;
      }
    }
    for (const i, const& tex: txs.voxtpat_mip) {
      prepare_voxel_tpat(*tex, miplevel_max, static_cast{uint}(i),
	enable_calc_distance, enable_short_circuit);
    }
    for (const i, const& tex: txs.voxtmap_mip) {
      prepare_voxel_tmap(*tex, miplevel_max,
	static_cast{uint}(i), enable_calc_distance, enable_short_circuit);
    }
    if (!edit_mode) {
      save_texture_data_array_raw("voxtpat_mip.raw", txs.voxtpat_mip);
      save_texture_data_array_raw("voxtmap_mip.raw", txs.voxtmap_mip);
    }
  } else {
    debug_log("loaded from raw");
  }
  if (edit_mode) {
    const tp = load_texture_data_raw("c:/build/voxtpat_edit.raw");
    const tm = load_texture_data_raw("c:/build/voxtmap_edit.raw");
    if (tp->get_width() != 1 && tm->get_width() != 1) {
      txs.voxtpat_mip[0] = tp;
      txs.voxtmap_mip[0] = tm;
    }
  }
}

function void dump_cnt(texture_data const& t, string msg)
{
  size_t sp_cnt = 0;
  size_t co_cnt = 0;
  size_t di_cnt = 0;
  size_t re_cnt = 0;
  for (const z: 0 .. t.get_depth()) {
    for (const y: 0 .. t.get_height()) {
      for (const x: 0 .. t.get_width()) {
	const v = t.get(x, y, z);
	if ((v & 0xff000000) == 0x00000000) {
	  sp_cnt += 1;
	  if ((v & 0x00ffffff) != 0) {
	    di_cnt += 1;
	  }
	} else if ((v & 0xff000000) == 0xff000000) {
	  co_cnt += 1;
	  // debug_log("co", x, y, z, to_hexstring(v));
	} else if ((v & 0xff000000) == 0x01000000) {
	  re_cnt += 1;
	} else {
	}
	/*
	if (x >= t.get_width() - 16 && y >= t.get_height() - 16 && z >= t.get_depth() - 16) {
	  dist_3d dv = get_dist_3d(v);
	  debug_log(msg, x - (t.get_width() - 16), y - (t.get_height() - 16), z - (t.get_depth() - 16), dv);
	}
	*/
      }
    }
  }
  debug_log(msg, t.get_width_l2(), t.get_height_l2(), t.get_depth_l2());
  debug_log(msg, "sp_cnt", sp_cnt, "di_cnt", di_cnt, "co_cnt", co_cnt,
    "re_cnt", re_cnt);
}

function void prepare_voxel_tmap(texture_data mutable& tmap,
  uint miplevel_max, uint miplevel,
  bool enable_calc_distance, bool enable_short_circuit)
{
  // debug_log("tmap 0,0,1", to_hexstring(tmap.get(0, 0, 1)));
  dump_cnt(tmap, "tmap");
  // tmapはタイル境界は無いので各ボクセルに全体の境界までの距離を埋め込む
  if (enable_calc_distance) {
    set_distance(enable_short_circuit, tmap);
  }
  dump_cnt(tmap, "tmap");
}

function void prepare_voxel_tpat(texture_data mutable& tpat,
  uint miplevel_max, uint miplevel, bool enable_calc_distance,
  bool enable_short_circuit)
{
  dump_cnt(tpat, "tpat");
  // tpatはタイル境界までの距離を最大値とする。各タイルごとに個別に計算
  texture_data tile;
  const sh = miplevel_max - miplevel;
  tile.set_size_l2(sh, sh, sh);
  for (const bx: 0 .. tpat.get_width() >> sh) {
    for (const by: 0 .. tpat.get_height() >> sh) {
      for (const bz: 0 .. tpat.get_depth() >> sh) {
        // copy to tile
        for (const x: 0 .. 1u << sh) {
          for (const y: 0 .. 1u << sh) {
            for (const z: 0 .. 1u << sh) {
              tile.set(x, y, z, tpat.get(
                (bx << sh) + x,
                (by << sh) + y,
                (bz << sh) + z));
            }
          }
        }
        // set distance
	if (enable_calc_distance) {
	  set_distance(enable_short_circuit, tile);
	}
        // copy back to tpat
        for (const x: 0 .. 1u << sh) {
          for (const y: 0 .. 1u << sh) {
            for (const z: 0 .. 1u << sh) {
              tpat.set(
                (bx << sh) + x,
                (by << sh) + y,
                (bz << sh) + z,
                tile.get(x, y, z));
            }
          }
        }
      }
    }
  }
  dump_cnt(tpat, "tpat");
}

function void
prepare_parallax_mapping_texture_data(demoapp_textures mutable& txs)
{
  // generate tilemap
  txs.tex_tcol = load_texture_data("default-color.png");
  txs.tex_tdep = load_texture_data("default-depth.png");
  mutable& tcol = *txs.tex_tcol;
  mutable& tdep = *txs.tex_tdep;
  mutable& tmap = *txs.tex_tmap;
  tmap.set_size_l2(7, 7, 0);
  const rnd = make_ptr{rand_generator}(333U);
  for (const x: 0 .. tmap.get_width()) {
    for (const y: 0 .. tmap.get_height()) {
      const v0 = rnd->generate() / 65536;
      // const v2 = (v0 / 8) % 8;
      // const v1 = 1;
      const v1 = 1U + v0 % 2U;
      const v2 = 0U;
      const v = v2 * 256U + v1;
      tmap.set(x, y, 0, static_cast{uint}(v));
    }
  }
  parallax_png_decode(tdep);
  set_normal_pattern(tdep, tcol);
  parallax_set_clearance(tdep);
}

function void parallax_png_decode(texture_data mutable& td)
{
  for (const i: 0 .. td.size()) {
    const depth = (td.get_index(i) & 0xff) / 1;
    td.set_index(i, depth << 16u);
  }
}

function void set_normal_pattern(texture_data const& tdep,
  texture_data mutable& tcol)
{
  function uint read_depth(int x, int y) {
    if (x < 0 || y < 0 || static_cast{uint}(x) >= tdep.get_width() ||
      static_cast{uint}(y) >= tdep.get_height()) {
      return 0;
    }
    return tdep.get(static_cast{uint}(x), static_cast{uint}(y), 0);
  }
  for (const x : 0 .. tdep.get_width()) {
    for (const y : 0 .. tdep.get_height()) {
      const xi = static_cast{int}(x);
      const yi = static_cast{int}(y);
      const d0  = read_depth(xi, yi);
      const dlu = read_depth(xi - 1, yi - 1);
      const du  = read_depth(xi    , yi - 1);
      const dru = read_depth(xi + 1, yi - 1);
      const dl  = read_depth(xi - 1, yi    );
      const dr  = read_depth(xi + 1, yi    );
      const dld = read_depth(xi - 1, yi + 1);
      const dd  = read_depth(xi    , yi + 1);
      const drd = read_depth(xi + 1, yi + 1);
      function bool is_convex1(uint v0, uint v1, uint v2, uint v3) {
        return v0 > d0 && v1 <= d0 && v2 <= d0 && v3 <= d0;
      }
      function bool is_convex2(uint v0, uint v1, uint v2, uint v3) {
        return v0 > d0 && v1 > d0 && v2 <= d0 && v3 <= d0;
      }
      function bool is_flat4() {
        return du == d0 && dl == d0 && dr == d0 && dd == d0;
      }
      uint val;
      if (is_convex1(du, dl, dd, dr)) {
        val = 0x92; // convex upper
        // debug_log(x, y, "cu");
      } else if (is_convex1(dl, dd, dr, du)) {
        val = 0x74; // convex left
        // debug_log(x, y, "cl");
      } else if (is_convex1(dd, dr, du, dl)) {
        val = 0x72; // convex lower
        // debug_log(x, y, "cd");
      } else if (is_convex1(dr, du, dl, dd)) {
        val = 0x94; // convex right
        // debug_log(x, y, "cr");
      } else if (is_convex2(du, dl, dd, dr)) {
        val = 0x91; // convex left-upper
        // debug_log(x, y, "clu");
      } else if (is_convex2(dl, dd, dr, du)) {
        val = 0x97; // convex left-lower
        // debug_log(x, y, "cld");
      } else if (is_convex2(dd, dr, du, dl)) {
        val = 0x95; // convex right-lower
        // debug_log(x, y, "crd");
      } else if (is_convex2(dr, du, dl, dd)) {
        val = 0x93; // convex right-upper
        // debug_log(x, y, "cru");
      } else if (is_flat4()) {
        if (is_convex1(dlu, dld, drd, dru)) {
          val = 0x75; // concave right-lower
        } else if (is_convex1(dld, drd, dru, dlu)) {
          val = 0x73; // concave right-upper
        } else if (is_convex1(drd, dru, dlu, dld)) {
          val = 0x71; // concave left-upper
        } else if (is_convex1(dru, dlu, dld, drd)) {
          val = 0x77; // concave left-lower
        }
      }
      // debug_log(x, y, val);
      tcol.set(x, y, 0, (tcol.get(x, y, 0) & 0xffffffu) | (val << 24));
    }
  }
}

function void parallax_set_clearance(texture_data mutable& td)
{
  uint const tile_size = 64;
  for (const by : 0 .. td.get_height() / tile_size) {
    for (const bx : 0 .. td.get_width() / tile_size) {
      for (const y : 0 .. tile_size) {
        for (const x : 0 .. tile_size) {
          const offset = (by * tile_size + y) * td.get_height()
            + (bx * tile_size + x);
          const v0 = td.get_index(offset);
          const depth0 = (v0 >> 16) & 0xffU;
          // clearance values
          uint c_nn = min(x, y);
          uint c_np = min(x, tile_size - 1 - y);
          uint c_pn = min(tile_size - 1 - x, y);
          uint c_pp = min(tile_size - 1 - x, tile_size - 1 - y);
          const y1_min = (y >= 16) ? y - 16 : 0;
          const y1_max = (y + 16 < tile_size) ? y + 16 : tile_size;
          const x1_min = (x >= 16) ? x - 16 : 0;
          const x1_max = (x + 16 < tile_size) ? x + 16 : tile_size;
          // TODO: too slow
          for (const y1 : y1_min .. y1_max) {
            for (const x1 : x1_min .. x1_max) {
              const offset1 = (by * tile_size + y1) * td.get_height()
                + (bx * tile_size + x1);
              const v1 = td.get_index(offset1);
              const depth1 = v1 >> 16 & 0xffU;
              if (depth1 >= depth0) {
                continue;
              }
              // ok to wrap uint values
              uint nn = max(x - x1, y - y1) - 1;
              c_nn = min(c_nn, nn);
              uint np = max(x - x1, y1 - y) - 1;
              c_np = min(c_np, np);
              uint pn = max(x1 - x, y - y1) - 1;
              c_pn = min(c_pn, pn);
              uint pp = max(x1 - x, y1 - y) - 1;
              c_pp = min(c_pp, pp);
            }
          }
          c_nn = min(c_nn, 15);
          c_np = min(c_np, 15);
          c_pn = min(c_pn, 15);
          c_pp = min(c_pp, 15);
          // W = unused(8), Z = depth(8), Y = CNN(4) CNP(4), X = CPN(4) CPP(4)
          td.set_index(offset, (depth0 << 16) |
            (c_nn << 12) | (c_np << 8) | (c_pn << 4) | (c_pp << 0));
          if (by == 0 && bx == 0) {
            // debug_log("cl", x, y, depth0, to_hexstring(data[offset]));
          }
        }
      }
    }
  }
}


