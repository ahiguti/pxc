public namespace demoapp;
public import common -;
public import exception -;
public import numeric::fpmath -;
public import pointer::raw -;
public import meta m;
public import glm;
public import text::string::positional -;
public import pgl3d::application -;
public import pgl3d::mainloop -;
public import pgl3d::pglcommon -;
public import pgl3d::glconf -;
public import pgl3d::glgeometry -;
public import pgl3d::wfobj -;
public import pgl3d::drawer_export -;
public import pgl3d::input_control -;
public import pgl3d::collision_shape -;
public import pgl3d::dynamics_world -;
public import pgl3d::pglconfig -;
public import pgl3d::sdlutil -;
public import io::time -;
public import mainloop -;

// public import pgl3d::bullet_test -;
// public import KnightModel -; // FIXME
// public import pgl3d::grid_broadphase -; // FIXME
// FIXME: projection_infoではなくscreen_infoだけ渡すように
// public import pushtest -;

// FIXME
{
  function float distr(float alpha, float cos_n_h)
  {
    const alpha2 = alpha * alpha;
    float den = cos_n_h * cos_n_h * (alpha2 - 1.0f) + 1.0f;
    float distr = alpha2 / (3.141592f * den * den);
    return distr;
  }
  float alpha = 0.0;
  for (; alpha <= 5.0; alpha = alpha + 0.1f) {
    float d = distr(alpha, 1.0f);
    float d2 = distr(alpha, 0.98f);
    float d3 = distr(alpha, 0.9f);
    debug_log(alpha, d, d2, d3);
  }
}

load_filesystem_async{app_main}("/persist");

public function void app_main()
{
  pgl3d::mainloop::mainloop(make_ptr{demoapp_application}(), "pgl3d.cnf");
}

public struct demoapp_application()
  <pgl3d_application>
{	
  public app_impl app;
  public function tree_map{string, ptr{pgldrawer_export_i}} on_init_drawers(
    shader_config const& conf, resource_pool_ptr const& res)
  {
    return init_drawers(app, conf, res);
  }
  public function void on_build_vertices(make_vertices_i mutable& mvx)
  {
    build_vertices(app, mvx);
  }
  public function void on_event(SDL_Event const& ev, float speed,
    projection_info const& pjinfo, string_map mutable& commands_r)
  {
    handle_event(app, ev, speed, pjinfo, commands_r);
  }
  public function void on_scankeys(cslice{Uint8} const& keys,
    cslice{short} const& joy_axes, cslice{bool} const& joy_buttons,
    float speed, projection_info const& pjinfo,
    string_map mutable& commands_r)
  {
    handle_keys(app, keys, joy_axes, joy_buttons, speed, pjinfo, commands_r);
  }
  public function tptr{pgl3d_scene_shared} get_scene_shared()
  {
    return app.scene_shared;
  }
}

private struct app_impl()
{
  public tptr{demoapp_scene_shared} const scene_shared
    = make_tptr{demoapp_scene_shared}(io::system);
  public input_control_target player;
  public input_control ictl = input_control(io::system);
  public bool scene_next_flag;
  public float light_on = 0.0f;
  public string_map app_commands;
  public varray{bool} prev_joy_buttons;
  init();
  private function void init() {
    player.position = glm::make_vec3(0.0, -30.0, 0.0);
    player.angle = glm::make_quat_wxyz(0.70711, 0.70711, 0.0, 0.0);
  }
}

public tsvaluetype enum collision_shape_e {
  collision_shape_e_sphere = 0,
  collision_shape_e_box = 1,
  collision_shape_e_convex_hull = 2,
  collision_shape_e_concave = 3,
}

public multithreaded struct
collision_shape_data(string const& name0, joint_id_type joint_id0,
  float mass0, collision_shape_e shape0, varray{float} const& values0,
  varray{uint} elements0)
{
  public string name = name0;
  public joint_id_type joint_id = joint_id0;
  public float mass = mass0;
  public collision_shape_e shape = shape0;
  public varray{float} values = values0;
  public varray{uint} elements = elements0;
}

public metafunction collision_shape_data_array
  varray{tcptr{collision_shape_data}};

public multithreaded struct demoapp_scene_shared(io const& sys0)
  <pgl3d_scene_shared>
{
  public position_angle posang;
  public bool scene_next_flag;
  public float light_on;
  public texture_info default_font_texture_info;
  public string_map app_commands;
  public io::io sys = sys0;
  /* constatnt */
  public collision_shape_data_array shapes;
  function ptr{pgl3d_scene} make_scene(node_factory const& nodefac) {
    return make_ptr{demoapp_scene}(nodefac, shapes, sys);
  }
}

public threaded function double get_time(io::io const& sys)
{
  const t = sys.high_resolution_timer();
  const d = sys.high_resolution_timer_frequency();
  return static_cast{double}(t) / static_cast{double}(d);
}

private threaded function float time_diff(double t0, double t1)
{
  return static_cast{float}(t1 - t0);
}

private threaded function glm::mat3 light_angle(glm::vec3 const& dir,
  glm::mat3 const& cam)
{
  const sli = cam.to_cslice();
  const v0 = glm::make_vec3(sli[0], sli[1], sli[2]);
  const v1 = glm::make_vec3(sli[3], sli[4], sli[5]);
  const v2 = glm::make_vec3(sli[6], sli[7], sli[8]);
  const d0 = fabs(glm::dot(dir, v0));
  const d1 = fabs(glm::dot(dir, v1));
  const d2 = fabs(glm::dot(dir, v2));
  glm::vec3 x;
  if (d0 >= d1 && d0 >= d2) {
    x = glm::cross(v0, dir);
  } else if (d1 >= d0 && d1 >= d2) {
    x = glm::cross(v1, dir);
  } else {
    x = glm::cross(v2, dir);
  }
  x = x.normalize();
  const y = glm::cross(dir, x).normalize();
  return glm::make_tmat3(x.x, x.y, x.z, y.x, y.y, y.z, dir.x, dir.y, dir.z);
}

public threaded struct demoapp_scene(node_factory const& nodefac0,
  collision_shape_data_array const& shapes0, io::io const& sys0)
  <pgl3d_scene>
{
  public scene_control sctl = scene_control(nodefac0, shapes0);
  public io::io sys = sys0;
  public string timings;
  private function void update_camera_light(position_angle mutable& camera,
    position_angle mutable& light)
  {
    light.position = // camera.angle * glm::make_vec3(0.0, 0.0, -50.0) +
      camera.position + glm::make_vec3(0.0, 0.0, 0.0);
    light.angle = glm::make_quat_wxyz(1.0, 0.0, 0.0, 0.0);
    //light.angle = light_angle(glm::make_vec3(0.0, 0.0, 1.0),
    //  camera.angle.to_mat3()).to_quat();
    /*
    light.position = glm::make_vec3(0.0, -50.0, 0.0);
    */
    // light.angle = generate_rand_quat(make_rand_generator(1234U));
    // light.angle.normalize();
    // debug_log("light", light.angle.to_cslice());
    //debug_log("light m4", light.to_mat4().inverse().to_cslice());
    //debug_log("campos", camera.position.to_cslice());
    /*
    debug_log("cam m4", camera.to_mat4().to_cslice());
    debug_log("cam axis", glm::axis(camera.angle).to_cslice());
    */
    /*
    light.position = camera.position +
      camera.angle.to_mat3() * glm::make_vec3(3.0, 3.0, 5.0);
    light.angle = camera.angle;
    */
  }
  public function void on_motion_step(float frame_speed,
    projection_info mutable& pjinfo, cstrref const& status_message,
    cslice{prepare_instance_data_funcptr} const& ftable,
    whole_instances_type mutable& whole_instances,
    pgl3d_scene_shared mutable& ss, string_map mutable& commands_r)
  {
    const t0 = get_time(sys);
    mutable& dss = downcast_mutable{demoapp_scene_shared}(ss);
    // const t0 = io::debug_system().gettimeofday_double();
    pjinfo.camera = dss.posang;
    update_camera_light(pjinfo.camera, pjinfo.light);
    const sm_view = pjinfo.light.to_mat4().inverse();
    // const sm_vp = pjinfo.sm_projection * sm_view;
    const vp = pjinfo.projection * pjinfo.camera.to_mat4().inverse();
    node_common_data ncd;
    // ncd.shadowmapping_vp = sm_vp; // FIXME: remove: unused
    ncd.vp = vp;
    scene_control_update_buttons(sctl, sctl.node_buttons);
    scene_control_update_skybox(sctl, sctl.node_skybox);
    size_t swarm_total = 0;
    for (const i, const& lpb: sctl.lpbullet_swarms) {
      swarm_total += lpb->size();
    }
    string s = string_join{" "}("O:", sctl.sco.dworld.rigid_bodies_size(),
      swarm_total, "T:", timings, status_message);
    scene_control_set_message(sctl, sctl.node_status_message, s,
      0, 0,
      dss.default_font_texture_info.char_w,
      dss.default_font_texture_info.char_h,
      static_cast{float}(pjinfo.screen_width),
      static_cast{float}(pjinfo.screen_height));
    const t1 = get_time(sys);
    scene_control_step(sctl, dss, frame_speed, ncd, ftable, whole_instances);
    const t2 = get_time(sys);
    prepare_instance_data_ft_rec(ncd, sctl.node_status_message, ftable,
      whole_instances);
    const t3 = get_time(sys);
    prepare_instance_data_ft_rec(ncd, sctl.node_buttons, ftable,
      whole_instances);
    prepare_instance_data_ft_rec(ncd, sctl.node_skybox, ftable,
      whole_instances);
    const t4 = get_time(sys);
    prepare_instance_data_lp(ncd, ftable, whole_instances);
    const t5 = get_time(sys);
    timings = string_join{" "}(
      time_diff(t0, t1),
      time_diff(t1, t2),
      time_diff(t2, t5));
//    debug_log("timings", timings);
  }
  private function size_t prepare_instance_data_ft_rec(
    node_common_data mutable& ncd,
    scene_node const& sn,
    cslice{prepare_instance_data_funcptr} const& ftable,
    whole_instances_type mutable& whole_instances)
  {
    size_t r = 0;
    const& bo_id = sn.joint_id.bo_id;
    const& vs_id = sn.joint_id.vs_id;
    if (bo_id >= 0 && vs_id >= 0) {
      ++r;
      mutable& idata = whole_instances[bo_id][static_cast{size_t}(vs_id)];
      ftable[bo_id](sn, ncd, idata);
    }
    for (const i, const& snp: sn.children) {
      r += prepare_instance_data_ft_rec(ncd, snp, ftable, whole_instances);
    }
    return r;
  }
  private function void prepare_instance_data_lp(
    node_common_data mutable& ncd,
    cslice{prepare_instance_data_funcptr} const& ftable,
    whole_instances_type mutable& whole_instances)
  {
    // FIXME: 
    const bo_id = sctl.joint_id_lp.bo_id;
    const vs_id = sctl.joint_id_lp.vs_id;
    mutable& idata = whole_instances[bo_id][static_cast{size_t}(vs_id)];
    for (const k, const& lpbsw: sctl.lpbullet_swarms) {
      const& lparr = lpbsw->lparr;
      for (const i, const& lpb: lparr) {
	const sli = lpb.value.crange();
	idata.instance_buffer.append(sli[0 .. 9]);
      }
    }
  }
}

function void handle_event(app_impl mutable& app,
  SDL_Event const& ev, float frame_speed, projection_info const& pjinfo,
  string_map mutable& commands_r)
{
  const etype = ev.type;
  if (etype == SDL_MOUSEBUTTONDOWN) {
    const bx = cast_float(ev.button.x) / cast_float(pjinfo.screen_width);
    const by = cast_float(ev.button.y) / cast_float(pjinfo.screen_height);
    if (bx < 0.1 && by < 0.1) {
      app.scene_next_flag = true;
      return;
    } else if (bx > 0.9 && by > 0.9) {
      app.light_on = app.light_on > 0.5f ? 0.0f : 1.0f;
      return;
    }
  } else if (etype == SDL_FINGERDOWN) {
    if (ev.tfinger.x < 0.1 && ev.tfinger.y < 0.1) {
      app.scene_next_flag = true;
      return;
    } else if (ev.tfinger.x > 0.9 && ev.tfinger.y > 0.9) {
      app.light_on = app.light_on > 0.5f ? 0.0f : 1.0f;
      return;
    }
  } else if (etype == SDL_KEYDOWN) {
    // sdllog("KEYDOWN event", static_cast{int}(ev.key.keysym.scancode));
    if (ev.key.keysym.scancode == SDL_SCANCODE_TAB) {
      app.scene_next_flag = true;
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_0) {
      commands_r["fullscreen"] = "1";
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_LEFTBRACKET) {
      commands_r["vsync"] = "1";
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_T) {
      app.app_commands["throw"] = "1";
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_L) {
      app.light_on = app.light_on > 0.5f ? 0.0f : 1.0f;
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_M) {
      app.app_commands["scene_pause"] = "1";
      return;
    }
  }
  app.ictl.handle_event(ev, frame_speed, pjinfo, app.app_commands);
}

function void handle_keys(app_impl mutable& app,
  cslice{Uint8} const& keys, cslice{short} const& axes,
  cslice{bool} const& buttons, float frame_speed,
  projection_info const& pjinfo, string_map mutable& commands_r)
{
  app.ictl.handle_keys(app.player, keys, axes, buttons, frame_speed, pjinfo,
    commands_r);
  if (app.ictl.get_button(buttons, 10) != 0) {
    app.app_commands["throw"] = "1";
  }
  if (app.ictl.get_button(buttons, 4) != 0 &&
    app.ictl.get_button(app.prev_joy_buttons, 4) == 0) {
    app.scene_next_flag = true;
  }
  glm::quat camera_rel;
  const cam_ax0 = app.ictl.get_axis(axes, 3);
  const cam_ax1 = app.ictl.get_axis(axes, 2);
  if (cam_ax0 != 0.0f || cam_ax1 != 0.0f) {
    camera_rel *= glm::make_quat_angle_axis(
      app.ictl.get_axis(axes, 3) * -3.14159f / 2.0f, 1.0, 0.0, 0.0);
    camera_rel *= glm::make_quat_angle_axis(
      app.ictl.get_axis(axes, 2) * -3.14159f / 2.0f, 0.0, 1.0, 0.0);
  }
  app.ictl.action_step(app.player, app.player.pos_delta, frame_speed);
  {
    mutable& ss = *app.scene_shared;
    ss.light_on = app.light_on;
    ss.scene_next_flag = app.scene_next_flag;
    ss.posang.position = app.player.position;
    ss.posang.angle = app.player.angle * camera_rel;
    ss.app_commands.swap(app.app_commands);
    app.scene_next_flag = false;
    // sdllog("posang = ", ss.posang);
  }
  app.app_commands.clear();
  app.prev_joy_buttons = buttons;
}

private function tree_map{string, ptr{pgldrawer_export_i}} init_drawers(
  app_impl mutable& app, shader_config const& sconf,
  resource_pool_ptr const& res)
{
  tree_map{string, ptr{pgldrawer_export_i}} r;
  r.insert("drawer_0_triangles", make_drawer_triangles(sconf, res, 0));
  r.insert("drawer_0_triangles_alt", make_drawer_triangles(sconf, res, 1));
  r.insert("drawer_1_lineparticle", make_drawer_lineparticle(sconf, res));
  r.insert("drawer_2_skybox", make_drawer_skybox(sconf, res));
  r.insert("drawer_particle", make_drawer_particle(sconf, res));
  r.insert("drawer_particle_bb", make_drawer_particle_bb(sconf, res));
  r.insert("drawer_rect2d", make_drawer_rect2d(sconf, res));
  r.insert("drawer_font2", make_drawer_font2(sconf, res));
  return r;
}

private function void build_vertices(app_impl mutable& app,
  make_vertices_i mutable& pgs)
{
  /* import */
  const objs = make_farray{string}(
      "parts"
      // "al",
      // "cessna",
      // "skyscraper",
      // "airboat"
      );
  const tr = make_varray{string}(
    "drawer_0_triangles", "drawer_0_triangles_alt");
  // const tr = make_varray{string}("drawer_triangles");
  const parti = make_varray{string}("drawer_particle");
  const parti_bb = make_varray{string}("drawer_particle_bb");
  for (const i, const name: objs) {
    string fn = name + ".obj";
    sdllog("load", fn);
    string fcontent;
    sdl_load_file(fn, fcontent);
    const wfobjp = wfobject_read(fcontent);
    for (const j, mutable& v: wfobjp->v) {
      // v *= 10.0f;
    }
    for (const k, const g: wfobjp->groups) {
      pgs.make_vertex_set(tr, name,
	import_wfobj(*wfobjp, *g, ctx_fill(0)));
    }
  }
  sdllog("load prebuild");
  mutable rnd = make_rand_generator(1U);
  mutable m = glm::mat4();
  mutable m1 = glm::mat4();
  m = glm::mat4()
    .translate(glm::make_vec3(0.0, 0.0, 2.0));
  m1 = glm::mat4()
    .translate(glm::make_vec3(0.0, 0.0, -1.0))
    .rotate(to_radians(45.0), glm::make_vec3(0.0, 0.0, 1.0));
  pgs.make_vertex_set(tr, "box",
    regular_polygon(1.4142f * 1.0f, 4,
      apply(m1,
	bump_apply(m, false, ctx_fill(0), ctx_fill(0))),
      apply(m1,
	ctx_fill(0))));
  pgs.make_vertex_set(tr, "box50",
    regular_polygon(1.4142f * 50.0f, 4,
      apply(m1,
	bump_apply(m, false, ctx_fill(0), ctx_fill(0))),
      apply(m1,
	ctx_fill(0))));
  pgs.make_vertex_set(tr, "saucer",
    regular_polygon(3.0, 40,
      bump_rec(10.8, 0.5, 1, ctx_fill(0), ctx_fill(0)),
      bump_rec(0.05, 0.9, 5,
	ctx_fill(0),
	sphere(10, ctx_fill_smooth(0)))));
  pgs.make_vertex_set(tr, "saucer-multi",
    regular_polygon(1.0, 3,
      bump_rec(1.0, 1.0, 1, ctx_poly_joint("saucer"), hole()),
      hole()));
  pgs.make_vertex_set(tr, "block-multi",
    regular_polygon(600.0, 4,
      rectangle_split(9, 8, ctx_poly_joint("block")),
      hole()));
  {
    const m1 = glm::mat4().rotate(to_radians(90.0),
	glm::make_vec3(1.0, 0.0, 0.0));
    const m2 = glm::mat4().rotate(to_radians(-90.0),
	glm::make_vec3(1.0, 0.0, 0.0));
    pgs.make_vertex_set(tr, "block-smtest",
      regular_polygon(3.0, 4,
	ctx_poly_joint("box"),
	apply(m1, bump_rec(1.0, 1.0, 1, hole(), ctx_poly_joint("block")))));
  }
  rnd = make_rand_generator(1U);
  pgs.make_vertex_set(tr, "block",
    regular_polygon(30.0, 4,
      rotate_local(glm::make_quat_angle_axis(to_radians(45.0),
	0.0, 0.0, 1.0),
	rectangle_split(30, 30,
	// rectangle_split(1, 1,
	// rectangle_split(4, 4,
	  rand_bump(1, 0.8, 0.4, 0.4, 0.4, 0.4, 2.0, 2.0, rnd,
	    ctx_fill(0), ctx_fill(0), ctx_fill(0)))),
      rotate_local(glm::make_quat_angle_axis(to_radians(-45.0),
	0.0, 0.0, 1.0),
	bump_rec(0.5, 1.0, 1, ctx_fill(0), ctx_fill(0)))));
  rnd = make_rand_generator(1U);
  pgs.make_vertex_set(tr, "nest",
    regular_polygon(50.0, 4,
      rotate_local(glm::make_quat_angle_axis(to_radians(45.0), 0.0, 0.0, 1.0),
	bump_rec(0.03, 1.0, 1, ctx_fill(0),
	  rand_bump2(100, 0.5, 0.2, 0.8, 0.05, 0.05, 0.5, 0.5, rnd,
	    ctx_fill(0),
	    rand_bump2(30, 10.0, 0.1, 0.2, 0.1, 0.2, 0.2, 0.5, rnd,
	      ctx_fill(0), ctx_fill(0), ctx_fill(0)),
	    ctx_fill(0)))),
      rotate_local(glm::make_quat_angle_axis(to_radians(45.0), 0.0, 0.0, 1.0),
	bump_rec(0.03, 1.0, 1, ctx_fill(0),
	  rand_bump2(100, 0.5, 0.2, 0.8, 0.05, 0.05, 0.5, 0.5, rnd,
	    ctx_fill(0),
	    rand_bump2(30, 10.0, 0.1, 0.2, 0.1, 0.2, 0.2, 0.5, rnd,
	      ctx_fill(0), ctx_fill(0), ctx_fill(0)),
	    ctx_fill(0))))));
  m = glm::mat4()
    .translate(glm::make_vec3(100.0, 100.0, 100.0))
    .rotate(to_radians(30.0), glm::make_vec3(0.0, 0.0, 1.0));
  pgs.make_vertex_set(tr, "nest-multi",
    regular_polygon(600.0, 4,
      bump_apply(m, false, hole(),
	bump_rec_seq(0.2, 1.0, 5, hole(),
	  rectangle_split(10, 10, ctx_poly_joint("nest")))),
      hole()));
  m = glm::mat4()
    .translate(glm::make_vec3(0.0, 0.0, 1.0))
    .rotate(to_radians(10.0), glm::make_vec3(0.0, 0.0, 1.0));
  pgs.make_vertex_set(tr, "bullet",
    regular_polygon(1.0, 6,
      bump_apply(m, false, ctx_fill(0), ctx_fill(0)),
      bump_apply(m, false, ctx_fill(0), ctx_fill(0))));
  // 60fps, macosx/linux mbp gt750m
  pgs.make_vertex_set(tr, "bullet-multi",
    regular_polygon(600.0, 4,
      rectangle_split(170, 170, ctx_poly_joint("bullet")),
      hole()));
  m = glm::mat4()
    .translate(glm::make_vec3(0.0, 0.0, 1.0))
    .rotate(10.0, glm::make_vec3(0.0, 0.0, 1.0)); // FIXME: to_radians?
  pgs.make_vertex_set(tr, "bullet2",
    regular_polygon(1.0, 5,
      bump_rec(2.3, 0.8, 1, ctx_fill(0), ctx_fill(0)),
      bump_rec(3.1, 0.8, 1, ctx_fill(0), ctx_fill(0))));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi",
    rand_sphere(200.0, 37000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "block-multi2",
    rand_sphere(500.0, 300, false, true, rnd,
      ctx_point_joint("block")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2",
    rand_sphere(200.0, 20000, false, true, rnd,
      ctx_point_joint("bullet2")));
  {
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s1",
    rand_sphere(200.0, 2000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s2",
    rand_sphere(200.0, 3000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s3",
    rand_sphere(200.0, 4000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s4",
    rand_sphere(200.0, 5000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s5",
    rand_sphere(200.0, 6000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s6",
    rand_sphere(200.0, 7000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s7",
    rand_sphere(200.0, 8000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s8",
    rand_sphere(200.0, 9000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s9",
    rand_sphere(200.0, 10000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s10",
    rand_sphere(200.0, 11000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s11",
    rand_sphere(200.0, 12000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi2s12",
    rand_sphere(200.0, 13000, false, true, rnd,
      ctx_point_joint("bullet2")));
  }
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "bullet2-multi3",
    rand_sphere(50.0, 1000, false, true, rnd,
      ctx_point_joint("bullet2")));
  pgs.make_vertex_set(tr, "bullet-multi-2",
    regular_polygon(600.0, 4,
      rectangle_split(80, 80, ctx_poly_joint("bullet")),
      hole()));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "saucer-multi3",
    rand_sphere(200.0, 200, false, true, rnd,
      ctx_point_joint("saucer")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr, "ab-multi3",
    rand_sphere(100.0, 100, false, true, rnd,
      ctx_point_joint("airboat")));
  rnd = make_rand_generator(1U);
  pgs.make_vertex_set(parti, "particle",
    rand_sphere(1.0, 100, true, true, rnd, ctx_fill(0)));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(parti, "particle-multi",
    rand_sphere(60.0, 10000, true, true, rnd,
      ctx_point_joint("particle")));
  rnd = make_rand_generator(1U);
  pgs.make_vertex_set(parti, "particle-bb",
    rand_sphere(1.0, 100, true, true, rnd, ctx_fill(0)));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(parti_bb, "particle-bb-multi",
    rand_sphere(60.0, 10000, true, true, rnd,
      ctx_point_joint("particle-bb")));
  pgs.make_vertex_set(parti_bb, "mixed",
    regular_polygon(1.0, 5,
      bump_rec(1.0, 10.0, 1, hole(), ctx_poly_joint("saucer")),
      ctx_poly_joint("particle-bb")));
  /* for dynamics test */
  pgs.make_vertex_set(tr, "rigidbody-multi",
    regular_polygon(100.0, 4,
      rectangle_split(10, 10, ctx_poly_joint("box")),
      hole()));
  /* for shadowmapping test */
  /*
  {
    float scale = 10.0;
    const& sli = KnightModel::vertices.to_cslice();
    const& elems = KnightModel::indices.to_cslice();
    varray{float} verts;
    debug_log("knight: ", sli.size(), elems.size());
    for (const i: 0 .. sli.size()) {
      const& p = sli[i].position.to_cslice();
      for (const j, const& v: p) {
	verts.push_back(v * scale);
      }
      verts.append(sli[i].normal.to_cslice());
    }
    size_t nfpv = 6; // position and normal
    pgs.make_vertex_set_by_triangles("drawer_triangles", "knight", verts,
      nfpv, elems);
    pgs.make_vertex_set(tr, "knight-multi",
      regular_polygon(600.0, 4,
	rectangle_split(50, 50, ctx_poly_joint("knight")),
	hole()));
  }
  */

  /* save default font metrics */
  app.scene_shared->default_font_texture_info = pgs.get_texture_info("font");

  /* save shapes for physics engine */
  function void shapes_add_convex(cstrref const& name, float mass) {
    const& p = pgs.get_vertices(name)->positions;
    const& elems = pgs.get_vertices(name)->elements;
    // const reduced = reduce_vertices(posdt, 0.00001f);
    // debug_log("reduced", name, posdt.size()/3, reduced.size()/3);
    app.scene_shared->shapes.push_back(make_tptr{collision_shape_data}(
      name, pgs.get_joint_id(name), mass,
      collision_shape_e_convex_hull, p, elems));
  }
  function void shapes_add_sphere(cstrref const& name, float radius,
    float mass) {
    varray{float} v = make_varray{float}(radius);
    app.scene_shared->shapes.push_back(make_tptr{collision_shape_data}(
      name, pgs.get_joint_id(name), mass,
      collision_shape_e_sphere, v, varray{uint}()));
  }
  function void shapes_add_concave(cstrref const& name, float mass) {
    const& p = pgs.get_vertices(name)->positions;
    const& elems = pgs.get_vertices(name)->elements;
    app.scene_shared->shapes.push_back(make_tptr{collision_shape_data}(
      name, pgs.get_joint_id(name), mass,
      collision_shape_e_concave, p, elems));
  }
  shapes_add_sphere("box", 1.0f, 1.0f);
  shapes_add_convex("nest", 1000.0f);
  shapes_add_sphere("box50", 50.0f, 1.0f);
  shapes_add_convex("bullet2", 2.0f);
  // shapes_add_sphere("bullet2", 1.0f, 2.0f);
  shapes_add_sphere("bullet", 2.0f, 1.0f);
  shapes_add_sphere("saucer", 10.0f, 1.0f);
  // shapes_add_concave("block", 0.0f);
  shapes_add_convex("block", 100.0f);
  // shapes_add_convex("knight", 10.0f);
  shapes_add_sphere("particle", 1.0f, 3.0f);
  shapes_add_sphere("particle-bb", 1.0f, 3.0f);
}

function varray{float} reduce_vertices(cslice{float} const& shape, float delta)
{
  varray{float} a;
  for (size_t i : 0 .. shape.size() / 3) {
    const oi = i * 3;
    const vec = glm::make_vec3(shape[oi], shape[oi+1], shape[oi+2]);
    size_t j = 0;
    const asz = a.size() / 3;
    for (j = 0; j < asz; ++j) {
      const oj = j * 3;
      const dx = a[oj    ] - vec.x;
      const dy = a[oj + 1] - vec.y;
      const dz = a[oj + 2] - vec.z;
      if (fabs(dx) + fabs(dy) + fabs(dz) < delta) {
	break;
      }
    }
    if (j == asz) {
      a.append(vec.to_cslice());
    }
  }
  return a;
}

metafunction node scene_node;

threaded function node make_node()
{
  return scene_node(joint_id_type(), glm::mat4());
}

tsvaluetype struct lpbullet_data {
  public farray{float, 9} value;
  public function glm::vec3 get_pos0() const {
    return glm::make_vec3(value[0], value[1], value[2]);
  }
  public function glm::vec3 get_pos1() const {
    return glm::make_vec3(value[3], value[4], value[5]);
  }
  public function float get_size() const {
    return value[6];
  }
  public function float get_step() const {
    return value[7];
  }
  public function float get_step_limit() const {
    return value[8];
  }
  public function void set_pos0(glm::vec3 const& v) {
    value[0] = v.x;
    value[1] = v.y;
    value[2] = v.z;
  }
  public function void set_pos1(glm::vec3 const& v) {
    value[3] = v.x;
    value[4] = v.y;
    value[5] = v.z;
  }
  public function void set_size(float v) {
    value[6] = v;
  }
  public function void set_step(float v) {
    value[7] = v;
  }
  public function void set_step_limit(float v) {
    value[8] = v;
  }
}

threaded struct
collision_shape_ptr(ptr{collision_shape_i} const& ptr0, float mass0)
{
  public ptr{collision_shape_i} shape_ptr = ptr0;
  public float mass = mass0;
}

threaded struct
scene_objects(collision_shape_data_array const& shape0, size_t num_split0)
{
  public dynamics_world dworld = dynamics_world(num_split0);
  public tree_map{string, collision_shape_ptr} shapes_by_name;
  public tree_map{joint_id_type, collision_shape_ptr} shapes_by_id;
  public tree_map{string, joint_id_type} name_to_joint_id;
  add_collision_shapes(shape0);
  public function void clear_objects() 
  {
    dworld.clear();
    dworld.set_gravity(0.0f, 0.0f, 0.0f);
  }
  public function void
  add_collision_shapes(collision_shape_data_array const& sa)
  {
    for (const i, const& val: sa) {
      add_collision_shape(*val);
    }
  }
  private function void
  add_collision_shape(collision_shape_data const& sh)
  {
    const& name = sh.name;
    const& joint_id = sh.joint_id;
    name_to_joint_id.insert(name, joint_id);
    const& v = sh.values;
    const& e = sh.elements;
    const mass = sh.mass;
    threaded function ptr{collision_shape_i} get_shape() {
      if (sh.shape == collision_shape_e_sphere) {
	return make_sphere_shape(v[0]);
      } else if (sh.shape == collision_shape_e_box) {
	return make_box_shape(v[0], v[1], v[2]);
      } else if (sh.shape == collision_shape_e_convex_hull) {
	return make_convex_hull_shape(v, e);
      } else if (sh.shape == collision_shape_e_concave) {
	return make_triangle_mesh_shape(v, e);
      } else {
	throw runtime_error_template{"get_shape"}("1");
      }
    }
    add_collision_shape_one(name, joint_id, get_shape(), mass);
  }
  private function void add_collision_shape_one(string const& name,
    joint_id_type const& id, ptr{collision_shape_i} const& sh,
    float mass)
  {
    const csp = collision_shape_ptr(sh, mass);
    shapes_by_name.insert(name, csp);
    shapes_by_id.insert(id, csp);
  }
  public function option{ptr{rigid_body_i}} add_collision_object(
    scene_node const& sn)
  {
    option{ptr{rigid_body_i}} r;
    if (sn.joint_id.vs_id < 0) {
      return r;
    }
    if (const& shape: shapes_by_id[sn.joint_id]) {
      const& t = sn.trans.value.to_cslice();
      const rb = make_rigid_body(sn.joint_id, shape.shape_ptr, shape.mass, t);
      dworld.add_rigid_body(rb);
      r.some = rb;
      return r;
    }
    return r;
  }
}

multithreaded struct
lpbullet_swarm <swarm_i>
{
  public varray{lpbullet_data} lparr;
  public function size_t size() const { return lparr.size(); }
  public function uint get(size_t i, glm::vec3 mutable& pos_r,
    float mutable& radius_r) const
  {
    const& o = lparr[i];
    pos_r = (o.get_pos0() + o.get_pos1()) * 0.5f;
    radius_r = 1.5f;
    return o.get_step() > 5.0f ? 0xffffffffU : 0U;
  }
  public function void on_collide(size_t i, size_t o)
  {
    mutable& lpb = lparr[i];
    lpb.set_step(lpb.get_step_limit());
  }
  public function void on_step(float speed)
  {
    for (const i, mutable& lpb: lparr) {
      mutable vec0 = lpb.get_pos0();
      mutable vec1 = lpb.get_pos1();
      const vd = vec1 - vec0;
      vec0 += vd * speed / 4.0f;
      vec1 += vd * speed / 4.0f;
      const step = lpb.get_step() + speed;
      const slim = lpb.get_step_limit();
      const sz = min(1.0f, (slim - step) / 20.0f);
      lpb.set_pos0(vec0);
      lpb.set_pos1(vec1);
      lpb.set_size(0.25f * sz);
      lpb.set_step(step);
    }
    threaded function bool lp_is_finished(lpbullet_data const& lpb)
    {
      return lpb.get_step() > lpb.get_step_limit();
    }
    erase_cond{lp_is_finished}(lparr);
  }
}

threaded struct
scene_control(node_factory const& nfac,
  collision_shape_data_array const& shapes0)
{
  public size_t const num_split = 3;
  public node_factory nodefac = nfac;
  public bool scene_paused = false;
  public float prev_spawn = 0.0;
  public joint_id_type joint_id_lp =
    nodefac.get_joint_id_by_name("lineparticle");
  public joint_id_type joint_id_font =
    nodefac.get_joint_id_by_name("default_font");
  public joint_id_type joint_id_rect2d =
    nodefac.get_joint_id_by_name("rect2d");
  public joint_id_type joint_id_skybox =
    nodefac.get_joint_id_by_name("skybox");
  public size_t cur_scene = 0;
  public varray{tptr{lpbullet_swarm}} lpbullet_swarms;
  // public varray{lpbullet_data} lpbullet;
  public node mutable node_scene = make_node();
  public node mutable node_status_message = make_node();
  public node mutable node_buttons = make_node();
  public node mutable node_skybox = make_node();
  public scene_objects sco = scene_objects(shapes0, num_split);
  public darray{string} const scene_names = make_darray{string}(
    // "untitled", "saucer", "saucer-multi", "block-multi", "block",
    // "ab-multi", "ab-multi3", "skyscraper",
    // "al", "cessna", "skyscraper", "airboat",
    /*
    "parts",
    */
    // "knight-multi",
    "block-smtest",
    "block-multi",
    "bullet2-multi2s1",
    "bullet2-multi2s2",
    "bullet2-multi2s3",
    "bullet2-multi2s4",
    "bullet2-multi2s5",
    "bullet2-multi2s6",
    "bullet2-multi2s7",
    // "bullet2-multi2s8",
    // "bullet2-multi2s9",
    // "bullet2-multi2s10",
    // "bullet2-multi2s11",
    // "bullet2-multi2s12",
    "saucer-multi",
    "nest",
    "nest-multi",
    "rigidbody-multi",
    "saucer",
    "block-multi2",
    /*
    "bullet2-multi",
    "bullet-multi", "saucer-multi3",
    */
    "particle", "particle-multi",
    "particle-bb", "particle-bb-multi"
    );
  init();
  private function void init()
  {
    for (const i: 0 .. num_split) {
      lpbullet_swarms.push_back(make_tptr{lpbullet_swarm}());
    }
    node_scene = instantiate_cur_scene();
  }
  private function node instantiate_cur_scene()
  {
    const name = scene_names[cur_scene];
    mutable r = nodefac.make_node_by_name(name, glm::mat4());
    sco.clear_objects();
    for (const i, const& lpbsw: lpbullet_swarms) {
      sco.dworld.add_swarm(lpbsw, i);
    }
    if (r.children.empty()) {
      sco.add_collision_object(r);
    } else {
      mutable rnd = make_rand_generator(1U);
      /*
      if (cur_scene == 0) {
	const ch = r.children[1];
	const rb = sco.add_collision_object(ch).some;
	rb->apply_central_impulse(1.0f, 0.0f, 0.0f);
      } else
      */
      {
	for (const i, const& ch: r.children) {
	  const rb = sco.add_collision_object(ch).some;
	  rb->apply_torque_impulse(
	    rnd->generate_float() * 10.0f - 5.0f,
	    rnd->generate_float() * 10.0f - 5.0f,
	    rnd->generate_float() * 10.0f - 5.0f);
	  rb->apply_central_impulse(
	    rnd->generate_float() * 10.0f - 5.0f,
	    rnd->generate_float() * 10.0f - 5.0f,
	    rnd->generate_float() * 10.0f - 5.0f);
	}
      }
    }
    return r;
  }
  public function void scene_next()
  {
    ++cur_scene;
    if (cur_scene >= scene_names.size()) {
      cur_scene = 0;
    }
    node_scene = instantiate_cur_scene();
  }
}

threaded function void
scene_control_set_message(scene_control mutable& sctl,
  scene_node mutable& sn_text,
  cstrref const& text, uint x, uint y, uint font_width, uint font_height,
  float screen_w, float screen_h)
{
  {
    mutable& nd = sn_text;
    const n = text.size();
    while (nd.children.size() < n) {
      const p = scene_node(sctl.joint_id_font, glm::mat4());
      nd.children.push_back(p);
    }
    if (nd.children.size() > n) {
      nd.children.erase(n, nd.children.size());
    }
    for (const i, mutable& p: nd.children) {
      const& sli = p.trans.value.to_slice();
      sli[2] = (static_cast{float}(x) / screen_w) * 2.0f - 1.0f;
      sli[3] = (static_cast{float}(y) / screen_h) * 2.0f - 1.0f;
      x += font_width;
     if (i < text.size()) {
	sli[0] = static_cast{float}(text[i] - 0x20);
      } else {
	sli[0] = 0.0f;
      }
    }
  }
}

threaded function void
scene_control_update_buttons(scene_control mutable& sctl,
  scene_node mutable& sn_buttons)
{
  /* box */
  mutable& nd = sn_buttons;
  if (nd.children.size() < 1) {
    const p = scene_node(sctl.joint_id_rect2d, glm::mat4());
    nd.children.push_back(p);
  }
  mutable& cn = nd.children[0];
  const& sli = cn.trans.value.to_slice();
  sli[0] = -0.99f;
  sli[1] = 0.81f;
  sli[2] = 0.18f;
  sli[3] = 0.18f;
}

threaded function void
scene_control_update_skybox(scene_control mutable& sctl,
  scene_node mutable& sn_skybox)
{
  mutable& nd = sn_skybox;
  if (nd.children.size() < 1) {
    const p = scene_node(sctl.joint_id_skybox, glm::mat4());
    nd.children.push_back(p);
  }
}

threaded function void
scene_control_step(scene_control mutable& sctl,
  demoapp_scene_shared const& ss, float frame_speed,
    node_common_data mutable& ncd,
    cslice{prepare_instance_data_funcptr} const& ftable,
    whole_instances_type mutable& whole_instances)
{
  if (ss.scene_next_flag) {
    sctl.scene_next();
  }
  const speed = frame_speed;
  // mutable& snode = *sctl.snode;
  threaded function void step_lp()
  {
    for (const i, const& lpbsw: sctl.lpbullet_swarms) {
      lpbsw->on_step(speed);
    }
  }
  threaded function void spawn_lp_one(glm::mat4 const& m, float steplim,
    float length)
  {
    // size_t const lim = is_gles != 0 ? 20000U : 200000U;
    size_t const lim = static_cast{size_t}(200000U)
      / sctl.lpbullet_swarms.size();
    size_t min_n = lim;
    size_t min_lpsw = sctl.lpbullet_swarms.size();
    for (const i, const& lpbsw: sctl.lpbullet_swarms) {
      if (lpbsw->size() < min_n) {
	min_lpsw = i;
	min_n = lpbsw->size();
      }
    }
    if (min_n >= lim) {
      return;
    }
    {
      lpbullet_data lpb;
      const& s = m.to_cslice();
      const pos = glm::make_vec3(s[12], s[13], s[14]);
      const rot = m.to_3();
      const dir = rot * glm::make_vec3(0.0f, 0.0f, -1.5f);
      const p0 = pos + dir * 2.0f;
      const p1 = pos + dir * (2.0f + length);
      lpb.set_pos0(p0);
      lpb.set_pos1(p1);
      lpb.set_size(0.25f);
      lpb.set_step(0.0f);
      lpb.set_step_limit(steplim);
      sctl.lpbullet_swarms[min_lpsw]->lparr.push_back(lpb);
    }
    return;
  }
  scene_node sn_work = make_node();
  threaded function void prepare_one(scene_node const& sn)
  {
    const& bo_id = sn.joint_id.bo_id;
    const& vs_id = sn.joint_id.vs_id;
    if (bo_id >= 0 && vs_id >= 0) {
      mutable& idata = whole_instances[bo_id][static_cast{size_t}(vs_id)];
      ftable[bo_id](sn, ncd, idata);
    }	
  }
  threaded function void step_snobj_dynamics(bool spawn_obj, bool spawn_lp_flag)
  {
    if (!sctl.scene_paused) {
      if (spawn_obj) {
	const a = ss.posang.angle * glm::make_vec3(0.0f, 0.0f, -50.0f);
	mutable posang = ss.posang;
	posang.position += a * 0.1f;
	scene_node cnode = scene_node(
	  sctl.sco.name_to_joint_id["box"], posang.to_mat4());
	const rb = sctl.sco.add_collision_object(cnode).some;
	rb->apply_central_impulse(a.x, a.y, a.z);
	// debug_log("spawn_obj", sctl.sco.dworld.objects_size());
      }
    }
    sctl.sco.dworld.step_simulation(sctl.scene_paused, speed*1.0f/60.0f, 1,
      speed*1.0f/60.0f);
    scene_node cursn = scene_node(joint_id_type(), glm::mat4());
    threaded function void step_obj(size_t i, ptr{rigid_body_i} const& obj)
    {
      cursn.joint_id = obj->get_joint_id();
      obj->get_world_transform_mat4(cursn.trans.value);
      prepare_one(cursn);
      if (!sctl.scene_paused && spawn_lp_flag) {
	spawn_lp_one(cursn.trans.value, 200.0f, 1.0f);
      }
    }
    sctl.sco.dworld.rigid_bodies_foreach{step_obj}();
    if (sctl.scene_paused && spawn_lp_flag) {
      mutable posang = ss.posang;
      posang.position += posang.angle * glm::make_vec3(0.0f, 5.0f, -5.0f);
      posang.angle *= glm::make_quat_angle_axis(to_radians(-90.0f),
	1.0f, 0.0f, 0.0f);
      const m = posang.to_mat4();
      spawn_lp_one(m, 10000.0f, 0.1f);
    }
  }
  step_lp(); /* lineparticle */
  bool spawn_lp_flag = false;
  {
    sctl.prev_spawn += speed;
    if (sctl.prev_spawn > 3.0) {
      spawn_lp_flag = ss.light_on != 0.0f;
      sctl.prev_spawn -= 3.0;
    }
  }
  if (const& v: ss.app_commands["scene_pause"]) {
    sctl.scene_paused = !sctl.scene_paused;
  }
  {
    bool spawn_obj_flag = false;
    if (const& v: ss.app_commands["throw"]) {
      spawn_obj_flag = true;
    }
    step_snobj_dynamics(spawn_obj_flag, spawn_lp_flag);
  }
}

