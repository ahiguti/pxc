
---------------------------------------------------------------------------
TODO

- linuxでのjoystick有効に

- 選択領域をセーブ・ロード(done)

- 網目や格子状の模様をシェーダで描く

- tpat参照の色パラメータをパレット色として使う

- マップ: バンプ生成の手順

- タイルパターン: 内訳と割り当て量を決める

- タイルパターン: ほぼfilledなタイル、表面に張り付ける凸タイル

- 多層縦横: 中点変位で生成するか

- edit_modeで編集したあとはF5で再計算しないとmiplevel=-1での表示が
  正しくならないので注意

- edit_modeではviewのmipmapを更新していないので、viewとeditに差があるときは
  miplevel0以外の表示は正しくないので注意。ttev->set_cursor_pos()の処理。

- procedural: ボクセル書き込みの際のand, or

- procedural: 再帰的領域分割

- tpat回転反転: miplevelを固定すると表示がおかしい(done)

- tpat回転反転の平面と球面切断テスト

- tpat回転反転: edit_modeの拡大処理の対応

- raycast_sortの分離数を増やしてもシェーダが増えないように共通化する

- raycast_sortの分離数を増やすとbox500個で速くなった。最適な分離数を見つけよ。

- procedural生成の種となるパターンをたくさん用意

- tpatのサイズを大きくして性能劣化するか見る
  (4,4,4)より(3,3,6)が少し速い? 参照パターンが減るから？

- voxelテクスチャの全体サイズによらず一定の大きさの範囲だけをセーブ・ロード
  (done)

- pnoise: floatに揃えたら少し遅くなった？

- mipmapのlocal lightとroughness

- "throw" 投げる元のオブジェクトからの相対速度を与えるようにする(done)

- drawer::drawer openglのリソースはsafeにしてよいのか

- drawer間共有データの整理

- 衝突判定後のテクスチャ変更(done)

- 衝突判定後のテクスチャ変更。edit_mode=0のとき(done)

- FIXME: raycast_sortするとspawnされた小さいraycastオブジェクトが見えない。
  (done)

- 二面、edit_modeのほうが大幅にフレームレート低い理由を調べる
  miplevelのデフォルト値の違い(done)

- edit_voxel_11_11_6.rawをシリアライズしなおし(done)

- 3dテクスチャの衝突判定(done)

- miplevelをキー操作で固定できるように(done)

- 新raycastで欠落することがある。mipの距離がおかしい？(done)

- シャドウマップ0から1の切り替え付近がIntel GPUでおかしい。Windows/Mac両方
  で再現。(done)

- 3dテクスチャを切り出してオブジェクトを作る(done)

- miplevelが上がるとroughnessあるいは別のパラメータで影になりやすくする

- 一部のオブジェクト以外は影をキャストしていない。raycastソートの影響？

- glvertexのpositionsは削除してvertex_attrsを使う

- 数字キーでmiplevelを固定できるように

- mipmap計算を外だししてedit_modeでも使えるように

- ローカルライトテスト中

- auxテクスチャの意味を決める

- raycastオブジェクトの衝突判定

- depth_rd再整理。zprepassするかどうか決める。

- miplevelをテクスチャのスケーリングを含めて計算

- zpとsolidでわずかにずれている。debug_zprepass=1にするとわかる。

- voxelに更にテクスチャはりつけorプロシージャルな何か

- t6 と t5 を比較。どれだけ遅くなったか。

- miplevelが大きくなるとroughnessを大きく?

- 平面切断と曲面切断ボクセルのmipmap

- zprepassは近いインスタンスだけを描画

- 現状動く環境: GL 2.1以上またはGLES 3.0以上。
   GLES 2は3dテクスチャが使えないので不可。

- シャドウマップの届く範囲をこえたときの処理

- 影の中をAO的な何かでそれらしく

- waffleでz-prepass

- 使っていないssubtypeはdepth_rdコピーをしない

- dummy_flip有効のときは専用のフレームバッファに描画するように

- 小さいオブジェクトを作る

- 大きいオブジェクトのソート

- その次: mainとsmのオブジェクトソート、大小重ね合わせ

- 小さなオブジェクトは近接する大きなオブジェクトが差す影をraycastで計算


- cull_frontでもiquadsでシャドウマップを書くようにする

- PXC_ARG%d やめる

- 引数で設定ファイルを指定できるように


- postprocessフィルタのテクスチャを共有、サイズ指定


- AO

- inline c の末尾に余分なセミコロンが出ている

- deserialize_sequenceテスト


- 表面voxel貼り付け、単体voxelの二種類にわける。
  - 単体voxelは内側抽出でshadowとzprepass
  - 表面voxelは底面shadowとzprepass

- 底面はzrepassとshadow 内接はshadowだけ、表面は裏面カリングで書く。



- tex3d: タイルとパターンのサイズを変えられるように
  tile3_size = (16, 16, 16)                  パターンのボクセル数
  pat3_size = (16, 16, 16)                   パターンテクスチャのパターン数
  pattex3_size = tile3_size * tilepat3_size  パターンテクスチャのボクセル数
  map3_size = (256, 256, 256)                マップテクスチャのボクセル数
  virt3_size = (4096, 4096, 4096)            仮想テクスチャのボクセル数

- tex3d: prepassとshadowmapを内側覆いのメッシュで

- tex3d単体の頂点データセットを作れるように

- テクスチャの生成をdrawerの外側に出す。

- tex3d: 色をつけられるようにする

- tex3dのテクスチャの任意の位置・大きさを切り出した頂点データセットを作る

- ボクセルデータに基づくcollision

- tex3dの頂点データは無駄が多いのでデータ量を削る余地あり。
  - 少なくともpush_polygon_distinctはやめるか

- voxelカバー面実装したときに表面カリングを有効にするとメッシュの法線を
  知る必要がある(raycastの始点で衝突するケース)。頂点データに埋め込むの
  ではなく計算で求められないか。

- editmode: カメラの向きに近い軸を決めてカーソル移動

- windows: dbghelp.dllでminidump (google breakpadつかう?)


- パターンエディタ

- voxel: 斜面を使うデータを生成

- 頂点データ重複排除を再び有効に(tex3dで効果大きい)


- 切断面データ無し、法線のみで球のデータを作る


- 切断面データ無しで法線埋め込み
  - 切断面データ有りの場合
    切断面との交点を(0,1)にclamp
  - 切断面データ無し、法線だけ見る場合
    dとして-sqrt(3)未満の値をセットすると必ず埋まっている側と判定される。
    切断面との交点を(0,1)にclampした点へ移動。
  - 法線を見ない場合
    dとして255をセットする。壁に衝突する。hit_wallの処理で空白ボクセルへ
    移動する。

- raycast_octreeループ内整理

- webglで3dテクスチャ使えないので何か考える。


- sub-drawerの頂点データを作るとdrawer

- distance_to_boundary: 4方向の距離を正しく

- warp2でaabbを突き抜けるためself shadowがおかしい

- postprocess: depth bufferが不要なときはどうするか
- postprocess
- metalness
- envをぼかす方法

- skyboxをpngから読んでから逆ガンマ補正する

- collision_shape_iのconstメソッドがmt-safeでないといけないがエラーチェック
  できていない。
- grid_bp_sharedでgrid_rbinfoのmt-safeであることをチェックできていない。

- vsmのときglColorMask指定する？
- FIXME: mbp gt750m macosxでゴミが出る。intel graphicsだと出ない。windowsだと
  同ハードでも出ない。
  enable_macos_nvidia_wa
- subtexel specular: -1から1の値。負のときは内側が反射、正のときは外側が
  反射。0.8のときは内側から80%の範囲が非反射。
- smpos0 .. smpos3 共通化
- parallax: タイルマップを無駄に引かないようにしたほうが速いと思われる。
- parallax: memo: uv座標がどちらかに間延びしていると視差も間延びして歪む
- main描画でglDepthMask(0)にするとlineparticleの重ね合わせがおかしく
  なる。alpha加算であれば正しくなるが、glDepthMask(1)とどっちがいいか。
- emscripten IDBFS
  test_idbfs_sync.c  
- lineseg_point_distance2

- ios, android再テスト

- shadowmap無効の時もspecular付ける

- bulletのoperator *など

- 物体のemit

- discardするシェーダはzprepassとshadowmappingのシェーダでもdiscard必要

- 頂点データかインスタンスデータが空のときはdrawしない。

- textureのサイズ power_of_2 やめる
  だいたいの環境で non power of two テクスチャ使えるはず

- num_copies_hintが効いているか確認

- 正方行列ではない行列はGLES3以降

- aggregated_ibuffer 2個 or 3個
- prepare_instance_data_defaultの効率

- テクスチャとフォントの読み込みと利用の手順整理
- テクスチャ、フォントを複数読み込んで利用できるようにする
- 頂点属性型を整理、num_float的マクロ整理

- 頂点データを動的に入れ替えられるようにする

---------------------------------------------------------------------------
DONE

- 遠距離で乱れる(done)
- 初期miplevelを6にしたために格子状の影ができる(done)
- edit_mode ミップマップ更新(done)
- タイルパターンへ変更(done)
- 球面を平面で近似(done)
- 拡大縮小(done)
- 左右など反転(done)
- depth_rdとの比較の際にini_vpos.wが0以下となって表示が乱れる(done)
- 太陽をもう一つの軸を中心に回転(done)
- HLとJK方向キーの入れ替え可能に(done)
- 色とroughness, emission, metalness(done)
- edit_mode 文字列(done)
- boolの等値判定ができない(done)
- editmode復活(done)
- merge_edit_view: blk単位の穴あけと整合性を取る(done)
- edit_mode: pasteで範囲外をアクセスして死ぬ(done)
- edit_mode: auxもコピペ(done)
- edit_mode: holeのサイズを制限して1teravoxelまでの編集を可能に(done)
- 例外backtraceがログに出ない(done)
- make_distしたexeを実行するとログが出ない(done)
- FIXME: scene_nodeのjoint_idなど、constにしてもassignできる。(done)
- raycast_waffle(done)
- モーションブラー(done)
- 仮想テクスチャサイズを4096から可変にする(done)
  mapが256^3のとき64Mbyte(タイル番号が32bitのとき)
  mapが512^3のとき512Mbyte
  mapが1024^3のとき4Gbyte
  patが256^3のとき64Mbyte(16Mvoxel)
  patが512^3のとき512Mbyte(128Mvoxel)
- 初期ノードの全体ではなく一部の領域だけを貼り付けられるようにする。(done)
  - raycast_octreeは接触点と影点を返すようにし、呼ぶ側で判定するか。
  - 「一部の領域」がaabbでよいのであれば最上位レベルのaabbをraycast_octree
    の引数で渡し、eyeとlightを適当に変換するようにすればよい。
- ループ回数上限に達した時には影にする(done)
- curpos_t削除したほうがよいか(done)
  curpos_t + curpos_iをcurpos_tiに。block_factorの剰余が旧curpos_iになる
  curpos_t : pos_tile(curpos_x)
    floor(curpos_x * block_scale) * block_factor;
  curpos_i : pos_pat(curpos_x)
    fract(curpos_x * block_scale) * block_factor;
- 文字はフィルターの後に(done)
- tilemapの一部から切り出して貼り付けられるようにする。(done)
- 次: waffleをsmに (done)
- append_to_string/parse_from_stringはテンプレ引数としてser_?を取る(done)
- voxel平面切断(done)
- voxelのsurface抽出をoctreeでなくtilemapから。(done)
- mipleveの1以上は2次元曲面はやめるか(done)
- なんでmipmapレベル大きいほうが遅いのか(done)
  -> mip4の空白部のdistanceが0
- ボクセルに二次曲線パラメータを埋め込む (done)
- 複数板貼り付けた大きなオブジェクトを作る (done)
- cameraが内側外側の境目で乱れる (done)
- zprepass効いてない(done)
- FIXME 真横あたりから見ると乱れる(done)
- stype=2を使ってraycastシェーダの後ろを表示(done)
- normal値をボクセルに持たせる(done)
- 乱数(done)
- 元絵の仮想サイズがbshiftに制限されないように(done)
- 中にめりこんだときとそうでないときに少しずれている。epsilon調整(done) 
- 中にめりこんでも表示できるよう裏面描画処理(done)
- self影(done)
- triangles-o1.fsh なぜ遅いのか(done)
  -> value_r = valueの位置
- boxを拡大(done)
- nodesのサイズをxyzそれぞれ異なる値を取れるように(done)
- 4096*4096*4096試してみる(done)
- シェーダ用テンプレートエンジン(done)
- iosでvsm可能か？(done)
  GL_RG32Fを16Fにしたら動く
- postprocessのためのダミーインスタンスを入れるのはなくせないか(done)
- shapeの半径などは自動で計算(done)
- フレネル効果(done)
- skybox(done)
- shadowmapを4枚でなくてよいようにする(done)
- textureのロード時にはtexture unitは0ににし、描画時に各texture unitへ
  textureを明示的にbindする(done)
- 衝突判定がよくわかるようにカメラの前に衝突判定用オブジェクトを置く。(done)
- grid: box shape collider(done)
- grid_broadphase別スレ化(done)
- collision_shapeと球を衝突判定する方法調べよ(done)
- emccバックエンド: SDL2_ttfがportsに来たらもう一度try(done)
- nvのサンプルを見てshadowmapのコストが妥当か確認する(done)
  ほぼ同等のfps、shadowmapの有無でのfps変化も同等なので妥当と思われる。
  6043tri, 2500obj, 4shadowmaps, 4k, 24fps
  3.6億triangles/sec, シャドーマップ4枚, z-prepass, 本描画で合計6回
- init_triangles_shader{1} テンプレパラメータやめる(done)
  trnagles2削除(done)
- ライトの向きを軸と並行に固定することによって速くできるか。(done)
- lpの衝突判定(done)
- 物理エンジンの処理時間測定(done)
- 衝突判定のみのオブジェクトをどのように作るか(done)
  - 衝突のみ、kinematic、dynamicのそれぞれの振る舞いを表現するインタフェース
  - 衝突時に呼ばれるコールバック
- rigidbodyをscene_nodeと関連付ける(done)
- convex hullをglgeometry頂点データから作る(done)

---------------------------------------------------------------------------
ビルドメモ

iOS8.3でEAGLContext_renderbufferStorageがEXC_ARM_DA_ALIGNで死ぬのを回避
するにはEdit SchemeのOptionsのGPU Frame Captureを無効にする。

iosビルド
bulletは ./premake4_osx --ios xcode4 でios用xcodeprojができる
Architecturesがおかしいので修正。
Valid Architecturesがおかしいので修正。
Base SDKがOSXになっているので修正。
pgl3dプロジェクトにAdd Files ToでSDL, SDL_image, BulletCollisionなどの
xcodeprojを追加
Build PhasesのLink Binary With Librariesに.aを追加
TARGETSのpgl3dのHeader Search Pathsに
"$(SRCROOT)/pgl3d-extlib/SDL2/include"などを追加


windowsビルド
SDL/
SDL_image/
SDL_ttf/
PXCTest1/
のように配置

---------------------------------------------------------------------------
フレームレート記録

1280x720 vsm=0 shadow_ms=1 shadowmap_resolution=2048
高さ32/1 のちに 8/1

2016/07/23 pgl3d-720.cnf
macbookpro macosx iris pro        62 fps
macbookpro macosx gt750m          51 fps
pc windows 8.1 gtx980m           282 fps

2016/07/24 pgl3d-720.conf
pc windows 8.1 gtx980m           287 fps

2016/09/19 pgl3d-720.conf
pc windows 8.1 gtx980m           310 fps
その後高さ1/8に変更
pc windows 8.1 gtx980m           248 fps

2016/11/06
shadowmap waffle
short_circuit有効にする
pgl3d.conf
pc windows 8.1 gtx980m           233 fps


---------------------------------------------------------------------------
メモ: glsl

https://en.wikibooks.org/wiki/GLSL_Programming/Vector_and_Matrix_Operations

mat3 m = mat3(
   1.1, 2.1, 3.1, // first column (not row!)
   1.2, 2.2, 3.2, // second column
   1.3, 2.3, 3.3  // third column
);
mat3 id = mat3(1.0); // puts 1.0 on the diagonal
                     // all other components are 0.0
vec3 column0 = vec3(0.0, 1.0, 0.0);
vec3 column1 = vec3(1.0, 0.0, 0.0);
vec3 column2 = vec3(0.0, 0.0, 1.0);
mat3 n = mat3(column0, column1, column2); // sets columns of matrix n

---------------------------------------------------------------------------

- parts.obj 頂点座標が完全に一致しているものがあるせいで三角形分割できない
f 514 486 485 528 548
  vertex	{x,1.0123960,y,-4.8927202,z,0.0000000}
  vertex	{x,1.0123960,y,-4.8927202,z,0.0000000}
  vertex	{x,0.9611670,y,-4.9025478,z,-0.1911880}
  vertex	{x,1.8766540,y,-4.6193981,z,-0.3732890}
  vertex	{x,1.9134190,y,-4.6193981,z,-0.0000000}


- particleもinstance化してみる
- instance化しない版のvbo_mainを作り、頂点データが大きいものはそちらを使う
- vboが大きくなったら性能が落ちる
  - vbo分割で回避できるか？
  - glDrawRangeElementsが効くか？
- glgeometryの頂点属性を積むコードはtattrとしてmain_vertex_attributesと
  だいたい同じ構造体を渡すことを期待している。これを汎用化できるか。
- zprepassが効いていることを簡単に確認できないか

polygon三角形分割
外積を全て足し合わせる。向きが決定。
どれか一つの頂点とその前後で外積を取り、それが三角形と同じ向きだったら
その頂点をpolygonから削除し、三角形をpush
無くなるまで繰り返す。
三角形の内側に他の頂点があるときは削れない

頂点jが(i-1, i, i+1)の内側にあるかどうかの判定
(i-1, i)と(i-1, j)の外積
(i, i+1)と(i, j)の外積
(i+1, i-1)と(i+1, j)の外積
が全て同じ負号

---------------------------------------------------------------------------
エンジンの外に出すべき項目

pgl3d.px
  build_vertices()
    pgs.make_vertices() を起点にして頂点データをセットしている。
    これはinit_texture実行後でないといけない。フォントの情報を必要とするから。
  input_control ictl;
    これは入力デバイスの状態を保存するデータ
  player_info player;
    入力デバイスで制御するカメラ
pglscene.px
  struct scene_control
    シーンノードを構築・更新する
pglshader.px
  init_texture 画像ファイルやフォントを読んでテクスチャにセットする

motionスレッドに渡すデータ
  frame_speed_mul フレーム時間
  scene_reset シーンを次に進めるかどうか
  message 画面下に出す文字列
  font_width
  font_height
motionスレッドから受け取るでーた
  cam カメラ
  bo_instances 描画インスタンスデータ
  stat_num_objects オブジェクト数の

エンジンの外に持つデータとコード
- 頂点データを構築するコード
- イベントとキー状態からカメラやシーンなどを更新するコード

motionスレッドに移動しないもの:
  SDL_QUIT
  pausedフラグ
  SDL_WINDOWEVENT - リサイズなどのハンドルはメインスレッドで
  frctl - フレームレート計算はメインスレッドでやる
motionスレッドに移動するもの:
  キーイベント
  キーボード状態
  MOUSE, FINGERイベント

---------------------------------------------------------------------------
motionスレッドに移動せずにエンジン分離だけ実装

interface pgl3d_application {
  function void on_build_vertices();
  function void on_frame(float speed); // フレーム処理の最初に呼ばれる
  function void on_event(SDL_Event const& ev);
  function void on_keystate(cslice{Uint8} const& keys);
  function void on_prepare_motion(); // motionスレッドのフレーム処理の直前
}

multithreaded interface pgl3d_motion {
  function ptr{pgl3d_scene} make_scene(); // motionスレッドから呼ばれる
}

threaded interface pgl3d_scene {
  function void on_motion_step();
}

公開関数
function string pgl3d_get_statistics_message();

demoappに分離
- build_vertices() 移動
- struct input_control; 移動
- struct player_info; 移動
- motion_thread_sharedのうち以下のもの
    int scene_reset;
    string message;
- struct scene_control; 移動

---------------------------------------------------------------------------
テクスチャ、フォントを複数読み込んで利用できるようにする

---------------------------------------------------------------------------
シェーダのインタフェース

- ドローコール前のuniformなど設定、ドローコールの発行
- インスタンスデータ作成

interface shader_solid {
  ;
}

interface shader_particle {
  ;
}

---------------------------------------------------------------------------
シェーダ抽象化で切り出しが必要な箇所

pglscene.px
  prepare_instance_data
    シーングラフからインスタンスデータを作る処理。
pglshareder.px
  pglshaderコンストラクタ
    vbidを実行時に払い出すように変更必要。
    vbidごとのvertex_bufferを作る処理。
  draw_frame
    ドローコールを発行する。

手順:
とりあえずvbidの払い出しとvertex_buffer構築から書き換える。
  vbidはグローバルではなくpglshaderに問い合わせて取得するように変更。
  make_vertices_iに問い合わせることもできるように。
シェーダGLSL, uniform, 頂点属性, インスタンス属性

---------------------------------------------------------------------------
シェーダ抽象化

solidシェーダ群:
  - shadowmapシェーダ
  - zprepassシェーダ
  - mainシェーダ
  不透過で多面体で構成されるオブジェクトのためのシェーダ。
  それぞれinstancingするかどうかの違いで二種類のシェーダがあり、
  対応してvboがvbid_mainとvbid_main2の二種類ある。
  現状一つの実装しかない。
particleシェーダ:
  - particleシェーダ
  - particle_bbシェーダ
  - lineparticleシェーダ
  - font2シェーダ
  - rect2dシェーダ
  これらはshadowmappingやz-prepassをおこなわない単体のシェーダ
  描画順序を指定できるようにしなければならない
  シェーダ毎にインスタンスデータのフォーマットが違う
  シェーダ毎にprepare_instance_dataで入れる内容が違う

solidシェーダは3パスに分かれているのでGLSLプログラムは3つ作る必要がある
particleシェーダは1パスでGLSLプログラムは1つだけ

prepare_instance_data
  varray{instances_type} mutable& ibs これにインスタンスデータを入れる
  ibs[bo_id] : bo_idはvbid_???のいずれか。
  これの実装を抽象化する必要がある。

struct vertex_buffer
  vbo_valuesとvbo_elemsの二つのVBOハンドルを持つ

metafunction instance_type varray{varray{instance_data}};
  [vs_id][0or1]
  vs_id: vboに入れた頂点データのid
  0or1: 0にはmodel行列 1にはmvp行列を入れる
struct instance_data
  varray{float} instance_buffer;
  インスタンス1つのmodel行列など

draw_instancedの6番目の引数(0or1)はインスタンスデータのうち、
model or mvpのどちらを使うかの区別。shadowmapシェーダがmvpのほうを
使っている(やめるか？)

---------------------------------------------------------------------------
描画順序

pglshader_draw_frame()

shadowmapping
  vbid_main / smsdr
  vbid_main2 / sm2sdr
  インスタンスデータのmvpのほうを使う
zprepass
  vbid_main zpsdr
  vbid_main2 zp2sdr
main ---- solid
  vbid_main sdr
  vbid_main2 m2sdr
lineparticle ---- solid
  cullface無効、depthtest有効、depthmask有効、blend無効
  vbid_lineparticle lpsdr
particle_bb ---- blend
  cullface無効、depthtest有効、depthmask無効、blend有効
  vbid_particle_bb prtbsdr
particle ---- blend
  cullface無効、depthtest有効、depthmask無効、blend有効
  vbid_particle spsdr
rect2d ---- blend
  cullface無効、depthtest無効、depthmask無効、blend有効
  vbid_rect2d rsdr
font ---- blend
  cullface無効、depthtest無効、depthmask無効、blend有効
  vbid_font2 f2sdr


---------------------------------------------------------------------------
テクスチャ

drawer_triangles/triangles2がdpat.pngを使っている
  sampler, sampler_tilemap, sampler_smが1, 2, 3
drawer_font2がfontを使っている
  samplerが0
glActiveTexture/glBindTextureを毎フレーム呼ぶ。各デバイスで変更前後に性能差
あるか確認。


---------------------------------------------------------------------------
scene_nodeメモリ食いすぎ

geometryデータから子ノードの変換行列を得るためにscene_nodeを使っている。
インスタンスの状態を保持するためにはscene_nodeである必要はない。
GPUに渡すインスタンスデータを作るためにprepare_instance_data_ft_rec()
でノードについて再帰的に積んでいるが、ここではsn.transしか見ていない。
sn.transの全体または一部から(必要なら何らかの変換をして)対応するバッファ
に対してappendする。
(案1)
scene_nodeはテンプレ引数なくす。
scene_node使うのはgeometryから接点情報を取る箇所だけ。
インスタンスの状態はアプリが独自に型付けて保持。
描画のためのGPUに渡すインスタンスデータを作るのはcslice{float}を渡すよう
にし、アプリが付けた型がそれを呼ぶ。
(移行手順)

1. まずアプリ定義型実装
2. GPUへのインスタンスデータ渡すところを書き換え
3. scene_nodeのテンプレ引数削除

---------------------------------------------------------------------------
アプリ定義型インタフェース

scene_nodeへのポインタを持つ。
move_stepメソッド: 
  ステップ移動
prepare_instance_dataメソッド
  自分の位置データを引数に指定してscene_nodeごとの関数ポインタを呼び出す。

---------------------------------------------------------------------------
頂点データの作り方を改良

triangles_vertex_attributesのようなものをpublicにしない。

drawerを指定して利用するvboを決定する。
  triangles, font2のように。
pgs.make_vertex_set(name, 式);
式は評価コンテキストを引数に持つようにする。
  fill, fill_smooth, poly_joint, point_jointはテンプレ引数を取るが、
  これらはdrawer?がインスタンス化する。
  gf_surface()というのを用意し、これは評価コンテキストからfillなどを
  呼び出す。 particle, particle_bbもgf_surfaceから呼び出す。
pgs.make_vertex_set("saucer",
  regular_polygon(3.0, 40,
    bump_rec(0.2, 0.5, 1, surf_flat(), surf_flat()),
    bump_rec(0.01, 0.9, 5, surf_flat(), sphere(10, surf_smooth()))));
コンテキストは、
  ptr{vertices} vptr;
  tcallable{gf_poly, {vptr, 

評価コンテキストはthreadedでなければならない。pglshaderはdrawerに対して

---------------------------------------------------------------------------
triangles_vertex_attributesのようなものをpublicにしない。

glvertex::vertices::push_polygon_distinct{tattr, split_convex}
これはtattrがpos又はpositionという名前のフィールドを持っていることを
期待している。glgeometryの中ではpoly_tがvertex_attrの配列で、vertex_attr
はpos, nor, tan, uvwのそれぞれvec3を持っている。
glvertex::vertices
  push_polygon_distinct(cslice{tattr} const& vals);
  push_point(tattr const& val);
  push_joint(node_joint const& e);

glbuffer::vertex_set(num_float_per_vertex0)
  ptr{vertices} vtxs = make_ptr{vertices}(num_float_per_vertex0);
glbuffer::vertex_buffer(num_float_per_vertex0)
  varray{ptr{vertex_set}} vs_arr;

---------------------------------------------------------------------------
シェーダ混在

特定の面だけを別シェーダで描きたいときに使う
頂点セットを作るときに複数のbo_idへfillする必要がある
シェーダごとに頂点属性は変わる
vs_id

頂点データ
vertex_buffer: 特定シェーダ向けvertex_setの集まり。これにbo_idが振られる。
  (vbidとbo_idは同じもの)
vertex_set: 特定シェーダ向け芋一個ぶんの頂点データと
  vertex_buffer中のオフセット情報。これにvs_idが振られる。
vertices: 特定シェーダ向け芋一個ぶんの頂点データ(values, elements)。

インスタンスデータ
aggregated_ibuffer: async_bufferが3つ。
async_buffer: 1フレーム1回glBufferDataでまとめて送る全インスタンスデータ。
whole_instances_type: 1フレームの全インスタンスデータ。async_bufferにコピー。
bo_instances_type: 特定シェーダ向け全インスタンスデータ。
instance_data: 特定の芋一個向けインスタンスデータ。async_buffer中のオフセット。

実現方法
- subdrawerなるものを作れるようにする。subdrawerはそれ自体用のインスタンス
  データを持たず、関連するmain_drawerのインスタンスデータを使って描画する。
- zprepass, shadowmappingは共通化すると効率良いかもしれないが後回し。
- 「このbo_idは別bo_idのインスタンスデータを使って描画せよ」
  pglshader_draw_frameのpd->draw()中、whole_instances[bo_id]を渡している
  部分、これをmain_drawerのbo_idに変換すればよい。
- subdrawerとmaindrawerは別々の頂点データを持つ。
- plshader::make_vertex_setで複数のdrawer名を指定できるようにする。

---------------------------------------------------------------------------
rigidbodyをscene_nodeと関連付ける

shapeを作る
  - そのshapeをconvex_hullであるかconcave_trianglesであるか等を指定
  - もとデータとなるvertexをjoint_idで指定

sceneのscene_objectを作る
  - sceneのトップレベルnodeからnodeのリストを得る。それらのjoint_idから
    shapeを得て、transから初期位置を得てrigidbodyを作る。


---------------------------------------------------------------------------
shadowmap

4枚シャドウマップを作る
それぞれで影キャスト元と先の距離を計算(depth値とsmposのz値との差から計算)
それぞれのシャドウマップには有効な距離の範囲がある。有効な範囲に影距離が
入っていた場合にのみそのシャドウマップから影を落とす。 <- まちがい
smposのz値は見ているピクセルのライトからの距離のdepth値
それとシャドウマップを読んだdepth値との差を、sm_distanceで掛けた値が
影とピクセルとの距離。
一つ近いシャドウマップの90%から100%の間で無効から有効に。
一つ遠いシャドウマップの90%から100%の間で有効から無効に。

近いマップを使える条件
  - 描画ピクセルとカメラの距離がマップのサイズより小さい
  - 影のさす元とカメラの距離がマップのサイズより小さい
    (shadowmapを参照したdepth値が0.5の付近にある)

---------------------------------------------------------------------------
lpの衝突判定

衝突対象の物体をbroadphaseに登録。
  dyncamicsWorldと別スレッドで判定するためには、衝突対象の物体の位置と
  大きさくらいをbtRigidBodyからコピーしておかなければならない。
全lpについて、findで衝突判定。

---------------------------------------------------------------------------

smp0	{0.0250000,0.0000000,0.0000000,0.0000000,0.0000000,0.0250000,0.0000000,0.0000000,0.0000000,0.0000000,-0.0250000,0.0000000,-0.0000000,-0.0000000,-0.0000000,1.0000000}
smp1	{0.0083333,0.0000000,0.0000000,0.0000000,0.0000000,0.0083333,0.0000000,0.0000000,0.0000000,0.0000000,-0.0083333,0.0000000,-0.0000000,-0.0000000,-0.0000000,1.0000000}

sm_projection0を掛ける: xyzそれぞれ 1.0/40.0 倍、zは負号反転
sm_projection1を掛ける: xyzそれぞれ 1.0/120.0 倍、zは負号反転

light m4        {1.0000000,0.0000000,0.0000000,0.0000000,0.0000000,1.0000000,0.0000000,0.0000000,0.0000000,0.0000000,1.0000000,0.0000000,0.0000000,-30.0000000,0.0000000,1.0000000}

light_view.inverse()を掛ける: camera_posを引く

v += "  vec3 ndelta = vary_normal * 0.02 / 40.;\n";
v += "  vec3 p = vary_position - camera_pos;\n";
v += "  vary_smpos0 = p / 40. + ndelta;\n";
v += "  vary_smpos1 = p / 120. + ndelta;\n";
v += "  vary_smpos2 = p / 360. + ndelta;\n";
v += "  vary_smpos3 = p / 1080. + ndelta;\n";

---------------------------------------------------------------------------
init_triangles_shader{1} テンプレパラメータやめる

copying instancingは止める。vertexattribdivisorかuniform instancingのどちらか。

model_matrixをuniformにするかvertexattribにしてEnableVertexAttribArrayするか



---------------------------------------------------------------------------
kinematic_object_i

- dynamic objectかどうか。dynamics_worldに登録される。
- 子オブジェクトをもつこともある
- フレームごとに自分自身の位置を移動したりする。
- 衝突したときのコールバック。
- その他全体に関わる処理(シーン切り替えなど)も実行できるようにしておく。 
- kinematic_object_factoryにmake_scene()で再帰的にkinematic_object一式を
  作成してdynamics_worldに登録される。
- prepare_instance_dataでインスタンスデータを詰めこむ。

interface scene_factory_i {
  function ptr{scene_object_i} make_scene(application_i mutable& app);
}
scene_objectはdynamics_worldを保持する。make_sceneはscene_objectの
コンストラクタを呼び、その中ではkinematic_objectをたくさん作って
dynamics_worldに登録する。

interface scene_object_i {
  function void on_motion_step(application_i mutable& app);
}
on_motion_stepは各kinematic_objectのupdate_stepを呼んでから、
dynamics_worldのmotion_stepを実行する。衝突のコールバック
on_collideが呼ばれる？

interface kinematic_object_i {
  function void update_step(scene_object_i mutable& sco);
  function void on_collide(scene_object_i mutable& sco,
    kinematic_object_i mutable& other);
}

種類毎に分けた密な配列にデータを詰め込めば効率よいはず。
全ての種類について密配列化するか、
極端にインスタンスが多い物だけにするか、
kinematic(dynamicではない)なものだけにするか。


---------------------------------------------------------------------------
collision_shapeと球を衝突判定する方法調べよ

CollisionShapeのペアに対し、そのペアを衝突判定するにふさわしいアルゴリズム
を作るのが、
btDefaultCollisionConfiguration::getCollisionAlgorithmCreateFunc(i,j) これ。
たとえばConvexHullとSphereであればbtConvexConvexAlgorithmで、これは中で
btGjkPairDetectorを毎回作って近い点を探している。
btGjkPairDetector::getClosestPoints() これ。
The ConvexHullDistance demo demonstrates direct use of btGjkPairDetector.
とのこと。

ConcaveConvexの組についてはbtConvexConcaveCollisionAlgorithm これは単独で
取り出すのは難しい？
processCollision()
concaveの各triangleに対して相手と衝突判定してるだけ？全量ではない。


---------------------------------------------------------------------------

rigid_bodyにcallbackオブジェクトを付ける。callbackオブジェクトはrigid_body
インスタンス毎のデータを持たないのであれば共有してもいい。

dynamics_worldにgrid_broadphase追加。衝突判定のみのオブジェクトの衝突判定
に使う。

swarm_iをdynamics_worldに追加できるようにする。
- swarm_i自体は多数のオブジェクトを配列として保持する。
- swarm_iはmultithreadedにする。dynamicsとは別スレで衝突判定するため。
- 各オブジェクトのデータはmodel matrixの大きさより多分小さい

各swarm_iはフレーム毎にstep()が呼ばれる。位置にデルタを加算したり、向きを
変えたりする。

grid_broadphaseには毎フレーム、rigidbodyの全インスタンスの情報をgridに
入れ、swarm_iの全インスタンスに対して衝突判定する。衝突していればswarm_i
のコールバックを呼ぶ。

grid_broadphaseの衝突判定narrow phaseは、とりあえずGJKだけ試してみる。

シーンを初期化すると、dynamic_object_iとswarm_iが複数dynamics_worldに
追加される。dynamic_object_iがdynamics_worldに追加されると、含まれる
collision_shapeとtransformの情報を見て複数かもしれないrigid_bodyが作ら
れる。dynamic_objectがdynamics_worldから削除されるときにはrigid_body
が削除される。dynamics_worldはdynamics_objectの強参照を保持する。
swarm_iについてもdynamic_objectとだいたい同じ。

threaded interface dynamic_object_i
{
  public ptr{rigid_body_i} get_rigid_body() const;
  public void on_collide();
  public void on_step(float speed);
}

multithreaded interface swarm_i
{
  public size_t size() const;
  public uint_t get(size_t idx, vec3 mutable& pos_r, float mutable& radius_r)
    const; // マスクを返す
  public void on_collide(size_t idx, dynamic_object_i const& o);
  // 消滅させるかどうか判定できるデータを各要素に持たせる必要がある。
}

swarmの衝突判定
1 dynamic_object一式をgridに登録。このときbtCollisionShapeの生ポインタも
  gridに保持しておく。これはnarrow phaseをするために必要。
2 swarmの各オブジェクトをgridで判定、相手のdynamic_objectのshapeに
  応じてnarrow phase判定。

collision_shapeにradiusを追加。grid_broadphaseに追加するのに必要
(あるいはgetAabbを使うほうがよい？)

---------------------------------------------------------------------------
bulletのNP並列化切り戻し

NP並列化関連
CMakeLists.txt
btBroadphaseProxy.h
btCollisionAlgorithm.h
btDbvtBroadphase.cpp
btDispatcher.h
btCollisionCreateFunc.h
btCollisionDispatcher.cpp
btCollisionDispatcher.h
btCompoundCollisionAlgorithm.cpp
btCompoundCompoundCollisionAlgorithm.cpp
btConvexConcaveCollisionAlgorithm.cpp
btConvexConcaveCollisionAlgorithm.h
btConvexConvexAlgorithm.cpp
btConvexConvexAlgorithm.h
btDefaultCollisionConfiguration.cpp
btDefaultCollisionConfiguration.h
btSoftBodyConcaveCollisionAlgorithm.cpp
btSoftBodyConcaveCollisionAlgorithm.h

BP高速化関連
btSimpleBroadphase.cpp
btSimpleBroadphase.h
btSequentialImpulseConstraintSolver.cpp
btDiscreteDynamicsWorld.cpp
btRigidBody.cpp
btScalar.h
btTransformUtil.h


無関係
OpenGlexampleBrowser.cpp
btOverlappingPairCache.h
btDimulationIslandManager.cpp
btAlignedAllocator.cpp
btAlignedAllocator.h
btPoolAllocator.h

---------------------------------------------------------------------------
parallax_warp

warp有効にすると、特に深さが深いときに速くなる。

// W = unused(8), Z = depth(8), Y = CPP(4) CPN(4), X = CNP(4) CNN(4)

void parallax_warp(in vec3 dir, inout vec4 tval, inout vec2 tpos,
  inout vec3 tsub)
{
  float cvt = floor((dir.x > 0.0 ? tex_val.y : tex_val.x) * 255.0 + 0.5);
  float cval = dir.y > 0.0 ? floor(cvt / 16.0) : fract(cvt / 16.0) * 16.0;
  cval = clamp(cval, 0.001, (tval.z - tsub.z) / dir.z);
    // tsubが1.0ちょうどになるのを回避するために0.001だけ動かす
  vec3 delta = dir * cval;
  vec2 npos = tpos + tsub.xy + delta.xy;
  tpos = floor(npos);
  tsub = vec3(npos - tpos, tsub.z + delta.z);
  parallax_read(tpos / tile_size, tval);
}

---------------------------------------------------------------------------
6方向hightmap

三角形をzが負からみたときの高さを計算
三角形の(x, y)座標が視点の(x, y)を含むか判定。
 ABxAP, BCxBP, CAxCPの負号が全て同じ
含むなら、平面とP(x, y)の交点となるz座標が高さとなる。
平面上のどこか一点A、視線と平面の交点P、法線ベクトルNとすると
平面の方程式: dot(P - A, N) = 0
(Px - Ax) * Nx + (Py - Ay) * Ny + (Pz - Az) * Nz = 0
(Pz - Az) * Nz = (Ax - Px) * Nx + (Ay - Py) * Ny
(Pz - Az) = ((Ax - Px) * Nx + (Ay - Py) * Ny) / Nz
Pz = ((Ax - Px) * Nx + (Ay - Py) * Ny) / Nz + Az
外積使うのは遅いので三角形の内部の点を網羅するほうがいい。
3点のAABBを調べ、x最小の点A, x最大の点Bとする。
for (px = floor(ax + 0.9999) + 0.5; px < bx; px += 1.0) {
  rat = (px - ax) / (bx - ax);
  pab = a + (b - a) * rat;
  if (px < cx) {
    rat = (px - ax) / (cx - ax);
    pacb = a + (c - a) * rat;
  } else {
    ra = (px - cx) / (bx - cx);
    pacb = c + (b - c) * rat;
  }
  y0 = pab.y;
  y1 = pacb.y;
  if (y0 < y1) { swap(y0, y1); }
  for (py = floor(y0 + 0.9999) + 0.5; py < y1; py += 1.0) {
    pz = ((ax - px) * nx + (ay - py) * ny) / nz + az;
    floor(px, py)の位置の深さがpzである
  }
}
ループの中は最低一回まわるように調整する?
px0 = floor(ax + 0.9999) + 0.5; // グリッドの中心
px1 = bx;
if (px0 >= px1) {
  px0 = (ax + bx + cx) / 3.0;
  px1 = px0 + 1.0;
}
function pair{float} calc_range(float ax, float bx)
{
  pair{float} r;
  r.first = floor(ax + 0.9999) + 0.5;
  r.second = bx;
  if (r.first >= r.second) {
    r.first = (ax + bx) / 2.0; // なるべく近いグリッド
    r.second = r.first + 1.0;
  }
  return r;
}

shapeのローカルaabbを求め、各三角形を(0,sz)にスケール。szは分割数。

衝突判定
3x2枚のheightmapのすべてについて衝突していれば衝突。
各heightmapについては、x,yのマップを引いてzが最小と最大の範囲に
はいっていれば衝突。

---------------------------------------------------------------------------

float linear_01(in float x, in float a, in float b)
{
  return clamp((x - a) / (b - a), 0.0, 1.0);
}

float linear_10(in float x, in float a, in float b)
{
  return clamp((b - x) / (b - a), 0.0, 1.0);
}

float max_vec3(in vec3 v)
{
  return max(v.x, max(v.y, v.z));
}

f += "bool n1 = all(lessThan(abs(p1),vec3(0.32,0.32,0.32))) &&";
フラグメントの位置がシャドウマップの中央1/3に入っている(カメラに近い)なら1
linear_10(max_vec3(abs(p1)), 0.28, 0.32);
f += "  abs(zval1 - 0.5) * 2.0 < zval_thr;\n";
フラグメントとキャスタの距離が閾値より近いなら1
linear_10(max_vec3(abs(zval1 - 0.5)), zval_thr * 0.8, zval_thr);
f += "float smv1 = min(1.0, sml1 + float(n1 ||";
f += "  any(greaterThanEqual(p1, vec3(1.0,1.0,1.0)))));\n";
フラグメントの位置がシャドウマップの範囲外なら1
linear_01(max_vec3(abs(p1)), 0.9, 1.0);

float smv1 = min(1.0, sml1
  + linear_10(max_vec3(abs(p1)), 0.33 * 0.9, 0.33)
  + linear_10(max_vec3((zval1 - 0.5) * 2.0, zval_thr * 0.9, zval_thr)
  + linear_01(max_vec3(abs(p1)), 0.9, 1.0));

---------------------------------------------------------------------------
box collider

radiusで判定した後にlocal aabbで判定できるようにする。
collision_shape_iにlocal_aabbを返す関数追加? 判定関数を作る？
さらに、local_aabbで判定した後にheightmapで判定できるようにする。
function bool collide(btVector3 const& pos, float ra);
  shapeのローカル座標へ変換。

各shapeにlocal判定の有無を返す関数を用意。それがtrueを返したら
local座標に変換したターゲット座標を渡してlocal判定実行。

function bool has_local_collision();
function bool local_collision(vec3 const& local_pos, float radius);

---------------------------------------------------------------------------
framebuffer

shadowmap用framebufferを作るところ。depth_textureではないケース。
GL_COLOR_ATTACHMENT0はテクスチャ、GL_DEPTH_ATTACHMENTはrenderbufferを
アタッチ。

int saved_fb;
// bindしてあるframebufferを覚えておく
glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
sfbo.fbo.generate();
glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
// colorにtexture(sm_texture)をアタッチ
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
  GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
int orig_rb;
// bindしてあるrenderbufferを覚えておく
glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
// glGenRenderbuffersでrenderbufferを作成
sfbo.depthbuf.generate();
glBindRenderbuffer(GL_RENDERBUFFER, sfbo.depthbuf.get());
// renderbuffer(depthbuf)のストレージを設定
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16,
  sfbo.sm_width, sfbo.sm_height);
// framebuffer(fbo)のdepthにrenderbuffer(depthbuf)をアタッチ
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
  GL_RENDERBUFFER, sfbo.depthbuf.get());
// bindしたrenderbufferを元に戻す
glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));

---------------------------------------------------------------------------
マテリアル

dpat: RGBとsubtexel法線パターン
pmpat: 視差マップのためのheightとclearance

float metalness;
float roughness;
vec3 color;

現状
  dpat:
    8bit: alv, avol
      tex_val.aの上4bitがavol, 下4bitがalv(0から10まで？)
      alv: 1, 3, 5, 7がLU, RU, RD, LDの四隅。2, 4が左右と上下の辺。0は傾けない。
    8bit * 3: RGB
  pmpat:
    8bit: 空き
    8bit: depth
    4bit * 4: clearance
変更後
  dpat:
    8bit: alv, avol
    8bit * 3: RGB
  pmpat:
    8bit: metalnessが1bit、roughnessが7bit (これ追加した)
    8bit: depth
    4bit * 4: clearance

dpatのpng画像
depth値とRGB値を別pngファイルにする。タイルエディタはdepth値の画像を使う？
gimpのレイヤでdepthとRGBを管理。
depth値は下位ビットから、R8段階、G8段階、B4段階
RGB値が

法線データはdepth値から計算。
計算方法:
  タイル境界を越えた位置にあるテクセルのdepthはclamp-to-edgeとする
  隣接する4つのテクセルの深さを読む
  上だけが深く3方は同じ -> 上凸
  上と左が深く2方は同じ -> 上左凸
  ..同様に全8方向
  浅いケースも同様に全8方向
  それ以外のパターンでは傾斜させない

法線を連続値にする？
計算方法:
  隣接8マスと中央との深さの差からxy方向の傾きを求め、平均する。
  法線ベクトルを8bit値の範囲に (-127から+127)
  depthと法線ベクトルは線形補間してよい。
  垂直面と水平面は区別しなくてよい。
  -> POMでよいのでは？

dpat/pmpat
64x64テクセルが16x16個、1024x1024テクセルのテクスチャが2枚。
(もっと大きくてもよい？ 性能をみて検討)
1テクセルあたりRGBA8が二つ(8byte)、計8Mbyte
タイル番号は1byteで表現可能
(横長に256個並べるか？)
default_color.png
default_depth.png

タイルパターン
タイルマップは1024x1024サイズ。(もっと大きくてもよい？)
4Gテクセル
default_tile.png

タイルの貼りかた
四角形の一番長い辺を底辺とする。
対向の辺から垂線を下ろした線分を求める。
対向の辺の、底辺から近いほうから底辺に水平に直線をひき、
垂線と交わった点を求める。
できた長方形の範囲の縦横が単純な整数比になるようにcropする。
(具体的にはあとで考える。深さ0の枠を作るため少しマージンを持たせる。)
cropした長方形の四隅にテクスチャ座標を決める。
四角形の四隅のテクスチャ座標を計算。
テクスチャ座標のaabbも4点全ての頂点データに含めておく。
(これはcropの内側かどうか判定するため。)
シェーダでは内側でなければ深さ0のdepthを返す。そのときの色はデフォルト色。

頂点データにaabb追加

---------------------------------------------------------------------------
メモ

頂点データエントリを追加するのはctx_fill()
中でbuild_context_iのfill()()
build_context_iインスタンスはpglshader::make_vertex_set()で作られる
fillerはdrawer::make_filler()で作られる
trianglesのときfillerの実体は
dgf_fill_tattr_internal{triangles_vertex_attributes}
これはpoly_tからarray{tattr}へデータをコピーし、push_polygon_distinct()
を呼ぶ。頂点データの大きさはtattrの大きさで決まる。

移行手順
- trianglesの*_vertex_attributesにuv_aabbフィールド追加。vec4型。
- dgf_fill_tattr_internalにuv_aabbをセットする処理追加。
- parallax_read()でuv_aabbの範囲かどうか見る
- tilemap()でuv_aabbの範囲かどうか見る

---------------------------------------------------------------------------
視差マップで平面より凸を許可

適用する平面より浮かせた面(5面)を作る。shadowmappingとprepassでは非表示。
四角形内座標として3次元値xyzを与える
四角形内の座標をあらわすvaryingを用意。(0,1)範囲内なら内。
テクスチャ座標の起点とオフセットを与える
parallaxのイテレートをuvw値スタートで実行、四角形から出たらdiscard
視線が法線に対して対向向きとは限らなくなる。
  ->特に変更不要と思われる

方針
- uvwのw値の従来の動作は止める
- ボーダーaabbはいらない(が、とりあえず残しておく)
- 4頂点を0,1であらわした境界判定用の頂点データ用意
- とりあえずprepassは無視して、浮かせた面を作る方向で
- 底面はボーダー色で塗る
- parallaxの始点を深さ付きで開始できるようにする
- 境界から出たらdiscard

移行手順
- uvwのw値を使わないように変更
- parallax_loop(): 始点を深さ付きで
- 浮かせた面を生成
- 境界判定用の頂点データ作る
- 境界から出たらdiscard 

parallax_loop()
引数のzをinoutに変更する

---------------------------------------------------------------------------
タイル貼り

01をx軸とする。
2から01へ垂線をおろし、01内に入っているかみる。
  01と02のcosが正なら01内なので、そのぶん0を1側にずらした位置が原点
    もし1をこえてしまっていれば貼れない
  そうでないなら0が原点
3から01へ垂線をおろし、01内に入っているか見る。
  01と13のcosが負なら01内なので、そのぶん1を0側にずらした位置がxmax
    もし0をこえてしまっていれば貼れない
  そうでないなら1がxmax
01の垂線方向、02・sin0102と03・sin0113の小さいほうがymax
原点と単位ベクトルを求めて0123を変換した座標がuv座標。

---------------------------------------------------------------------------
ブロック単位ではなくテクセル単位で整数に丸める

1. uv座標を1テクセルが1になるように変更

parallax_loop()
{
  parallax_read();
  if (tval.z == 0.0) {
    return;
  }
  for () {
    tnext_diff = parallax_next();
    if (tsub_next.z >= tval.z) {
      // horizontal
      break;
    }
    tpos += tnext_diff;
    parallax_read();
    if (tval.z < tsub.z) {
      // vertical
      break;
    }
    この時点で現在居るテクセルの境界の内側に少し入っている。
    現在居るテクセルの深さにはまだ到達していない。
    parallax_warp();
  }
}

---------------------------------------------------------------------------
シェーダ用テンプレートエンジン

<%opt 0>
<%>
<%/>
<%instance_attr model_matrix/>
<%vert_out/>

文法
- タグがない文字列はそのまま文字列リテラル
  fobar
  "fubar"
- タグをシンボルと引数に。タグ内の引数は文字列へ。
  <%foo bar baz>hoge<%/>
  (foo "bar" "baz" "hoge")
- ブロック引数無し
  <%instance_attr model_matrix/>
  (instance_attr "model_matrix")
- 引数無しのときはconsにしない
  <%hoge/>
  hoge
- タグ間に空白のみからなる文字列があったら読み飛ばす
  <%foo/>    <%bar/>
  foo bar
- タグ直後の改行とタグ直前のインデントは読み飛ばす
  <%foo>
  <%/>

意味
- シンボルは評価
- シンボルが先頭のconsは評価
- シンボルが先頭で無いconsは各要素を評価して文字列連結

union stempl_expr {
  string literal;
  ptr{stempl_expr_cons} cons;
}
struct stempl_expr_cons {
  string symbol; // 性能重視しないのでinternしなくていい
  stempl_expr args;
}

stempl if-elseif-else文
<%if> COND exprs ...<%/>
exprsの中から<%else/>を見つける。
CONDを評価し、真なら<%else/>より前を評価して返す。
そうでないなら<%else/>よりあとを評価して返す。
(if cond ... (elseif) cond ... (else) ...)

stempl bind文、set文
<%bind 変数名> ... <%/>
<%set> 変数名 値</%>

closureを許可すると循環参照作れてしまうので、コンテキストは
グローバルとローカルだけにするか

---------------------------------------------------------------------------

parallax_next: 次に接触するのがxyzどの方向かを返す。テクスチャ読まない。
parallax_read: テクスチャを読む。
parallax_warp: 

parallax_read();
for {
  parallax_next() 次にどの方向へ移動するか決める
  if (tsub_next.z >= tval.z) { break; } 先にz方向に接触(テクセル水平面)
  tsub, tpos更新
  parallax_read() 移動先のテクセルを読む
  if (tval.z < tsub.z) { break; } xy方向に接触(垂直面)
  parallax_warp() clearanceを見て複数テクセル移動
}

parallax_read()
for {
  parallax_next() 次の隣接テクセルを決める
  if (tsub_next.z >= tval.z) { break; } 先にz方向に接触(テクセル水平面)
  parallax_warp() 接触しない範囲で可能なら複数テクセル移動 readは止める
  parallax_read() 移動先のテクセルを読む
  if (tval.z < tsub.z) { break; } xy方向に接触(垂直面)
}

垂直壁のとき、影判定の始点は、最後の移動方向の反対向きのテクセルへ
移動したうえでtsubをclampする

---------------------------------------------------------------------------
voxel

voxel_read()
if (すでに接触) { return; }
for {
  voxel_next() 次の隣接ボクセルを決める
  移動
  voxel_read()
  if (接触) { break; }
}

隣接するvoxelのどの方向に移動するか決める
vec3 voxel_next(in vec3 tsub, out vec3 tsub_next, in vec3 d)
{
  vec3 r = vec3(0.0, 0.0, 0.0);
  float dzpos = float(d.z > 0.0);
  float nz = (dzpos - tsub.z) / d.z;
  vec2 xy = tsub.xy + d.xy * nz;
  if (d.z != 0.0 && in_01(xy)) {
    tsub_next = vec3(xy.x, xy.y, dzpos);
    r.z = dzpos * 2.0 - 1.0;
  }
  float dxpos = float(d.x > 0.0);
  float nx = (dxpos - tsub.x) / d.x;
  vec2 yz = tsub.yz + d.yz * nx;
  if (d.x != 0.0 && in_01(yz)) {
    tsub_next = vec3(dxpos, yz.x, yz.y);
    r.x = dxpos * 2.0 - 1.0;
  }
  float dypos = float(d.y > 0.0);
  float ny = (dypos - tsub.y) / d.y;
  vec2 zx = tsub.zx + d.zx * ny;
  tsub_next = vec3(zx.y, dypos, zx.x);
  r.y = dypos * 2.0 - 1.0;
}

bool in_01(in vec2 v)
{
  // return v.x > 0.0 && v.y > 0.0 && v.x < 1.0 && v.y < 1.0;
  return min(v.x, v.y) > 0.0 && max(v.x, v.y) < 1.0;
}

z=1またはz=0と接触する位置を計算
  tz = d.z > 0.0 ? 1.0 : 0.0
  tsub + n * d == (px, py, tz)
  tsub.z + n * d.z == tz
  n == (tz - tsub.z) / d.z
  >> p.xy = tsub.xy + d.xy * (tz - tsub.z) / d.z
p.xyが(0,1)内であればz方向に移動する。return。
同様にxとyについても接触位置を計算する

最小ブロック 8*8*8 最低64byte必要
4096*4096の、およそ平らな物体であれば 64*64*2 = 8192 ブロック程度必要。
  重複パタンが無いとすると 64 * 8192 = 524288 byte
  タイルid 32bitとすると タイルデータは 64*64*2*4 = 32768 byte
  (8*8*8ブロック、32bitタイルで16倍の圧縮率)
4096*4096*4096 の物体、非重複 8192ブロックであればタイルデータ 1048576 byte
  タイルデータ1mb パターン512k
ブロック 8*8*8 = 512 色と法線で8byte 4096byte / ブロック
  8192ブロックで32Mb
ブロック 8*8*8 = 512 色と法線は平面なら 512byteですむ
  8192ブロックで4Mb

手順と変更箇所
sampler_dpat, sampler_pmpat, sampler_tilemapはとりあえず使わない
sampler_voxpatを用意。とりあえずRGB色をいれておく。
  64*64*64くらいの3dテクスチャを作る。
trianglesのopt=1を使う
enable_normalmappingとenable_shadowmappingのブロックのあたり
頂点シェーダでvary_uvwにローカル座標系での頂点座標を渡す(positionそのまま?)
normal, tangent, binormalは接空間ではなくローカル座標系

必要なもの
- グローバル座標をローカル座標に変換する行列(モデル行列の逆行列)
  ライトとカメラの向きをローカル座標に変換したものを頂点シェーダで計算
- 3dテクスチャ

---------------------------------------------------------------------------
八分木探索

多重タイル化と比較するべし
ノードは8テクセルからなる。あるいは64=4*4*4、512=8*8*8などでもよいかも
ノードには葉フラグ、節なら子ポインタなど、葉なら色など
256*256*256の3dテクスチャRGBAなら16Mb
RGBA32Fのほうがよいかも
テクスチャは1次元でもよいかも

根となるテクスチャ位置を渡す。
現在位置を8分割のうちのどれかをしらべ、テクスチャを読む
  葉ならば空白かどうか調べ、そうでないなら終了
  空白ならば次の隣接ポイントを計算
    それがブロックの外側ならば親に戻る
    そうでないならそこへ移動
  節なら子テクスチャのオフセットをしらべ、そこへ移動

GLSLで実装するために、再帰の上限を決めてループに直す必要あり。
各レベルにおいてどの枝にいるのかを表す値を配列で持つ
  vec3 texpos[32];
    整数値を取る。テクスチャ座標(をテクスチャのサイズで乗じたもの)。
    xyz座標をそれぞれ2(64分木なら4)で割った余りがブロック内位置になる。
  int level;
    再帰のレベル。texpos[level未満]が使われる。
  vec3 curtex;
    現在見ているブロックのテクスチャ座標。2の倍数しかとらない。
    (64分木なら4の倍数)
  vec3 curpos_i;
  vec3 curpos_f;
    現在見ているブロック内位置の整数部と小数部。整数部は0,1しかとらない。
    (64分木なら0,1,2,3)

出発点となる座標を(0,1)値で与える。 curpos_i, curpos_fにセット。
出発点となるブロックをテクスチャ座標(テクスチャサイズを乗じたもの)で与える。
curtexにセット。
while (true) {
  テクスチャを読む。位置はcurtex + curpos_i(をテクスチャサイズで割ったもの)。
  if (葉) {
    色がついていればbreak。
    次の隣接ポイントを計算。
    while (true) {
      if (ブロックの外側) {
	親がなければ外側ループをbreak;
	texpos[]をpop。
	親の位置を計算しそこへ移動。
      } else {
	その隣接ポイントへ移動。
	break;
      }
    }
  } else {
    現在の curtex + curpos_i を texpos[]へpush。
    子の位置を読んだテクスチャから求め、その位置へ移動。
  }
}

bool raycast_octree(inout vec3 pos, in vec3 roottexpos, in vec3 ray,
  out vec4 value_r, out vec3 dir_r)
{
  const float texture_size = 64.0;
  const float texture_scale = 1.0 / texture_size;
  const int level_max = 32;
  vec3 texpos_arr[level_max];
    // 整数値を取る。テクスチャ座標(をテクスチャのサイズで乗じたもの)。
    // xyz座標をそれぞれ2で割った余りがブロック内位置になる。
  int level = 0;
    // 再帰レベル
  vec3 curpos_t = roottexpos;
    // 現在見ているブロックのテクスチャ座標。2の倍数しかとらない。
  vec3 curpos_i = floor(pos * 2.0);
  vec3 curpos_f = (pos * 2.0) - curpos_i;
    // 現在見ているブロック内位置の整数部と小数部。整数部は0,1しかとらない。
  vec4 value;
  vec3 dir = vec3(0.0); // 最初の位置が接触していれば0をそのまま返す
  int i;
  for (i = 0; i < 65535; ++i) {
    value = voxel_read((curpos_t + curpos_i) * texture_scale);
    int node_type = int(value.a * 255.0 + 0.5);
    if (node_type > 1) { // 色のついた葉
      while (level > 0) {
	--level;
	vec3 parent = texpos_arr[level];
	curpos_f = (curpos_i + curpos_f) * 0.5;
	curpos_t = floor(parent * 0.5) * 2.0;
	curpos_i = parent - curpos_t;
      }
      break;
    }
    if (node_type == 0) { // 空白
      curpos_f = clamp(curpos_f, 0.001, 0.999);
      dir = voxel_move(curpos_f, ray); // updates curpos_f
      int j;
      while (true) {
	vec3 curpos_i_next = curpos_i + dir;
	if (inside(curpos_i_next, 0.0, 1.0)) {
	  curpos_i = curpos_i_next;
	  break;
	}
	--level;
	if (level < 0) {
	  break;
	}
	vec3 parent = texpos_arr[level];
	curpos_f = (curpos_i + curpos_f) * 0.5;
	curpos_t = floor(parent * 0.5) * 2.0;
	curpos_i = parent - curpos_t;
      }
      if (level < 0) {
	break;
      }
      curpos_i_next += dir;
      curpos_f -= dir;
    } else { // 節 node_type == 1
      texpos_arr[level] = curpos_t + curpos_i;
      ++level;
      curpos_t = floor(value.xyz * 255.0 + 0.5) * 2.0;
      curpos_i = floor(curpos_f * 2.0);
      curpos_f = (curpos_f * 2.0) - curpos_i;
    }
  }
  pos = (curpos_i + curpos_f) * 0.5;
  if (i >= 65536 || level < 0 || level >= level_max) {
    value_r = vec(0.0);
    dir_r = vec(0.0);
    return false;
  }
  value_r = value;
  dir_r = dir;
  return true;
}

---------------------------------------------------------------------------
八分木構築

metafunction texel_value distinct_integral{uint};
metafunction node_value farray{texel_value, 8};

texel_value: 0x01000000のビットが立っていればノード参照

struct level_data {
  size_t size;                  // must be a power of 2
  varray{texel_value} values;   // size*size*size
  uint octnode_id_base;         // nodesの最初のエントリのoctnode_id
  varray{node_value} nodes;     // variable length
}

末端レベル
  valuesの各要素に色(RGBA)。
  level_dataのvaluesにそれを入れる。nodesは空。
  octnode_id_baseは0。

make_octree_one_level()
  入力と出力level_dataを引数に取る。ilevel, olevel。
  最初のoctnode_idを引数に取る。使ったぶんだけ加えて返値にする。
  octnode_id_cur;
  tree_map{node_value, texel_value} nodeset; // mappedは常にノード参照
  for x, for y, for z
    8テクセルを読む。
    もし8つとも同じ値であってその値が葉ならば、valueはその値。
      (ただし根レベルの時は例外で、葉にはしない)
    そうでないなら、8テクセルを読んでnode_valueを作り、それがnodesetに
    入っているか調べ、入っていればそのmapped値、そうでないなら新しい
    octnode_idをnodesetに入れ、そのoctnode_id値をvalueとする。
    valueをolevel.values[x,y,z]にセット。

octreeデータ作成
  一次元テクスチャ
  octnode_id_curの値 * 8がテクセルの数になるのでその大きさにリサイズ
  全レベルについて、nodesの値

make_octree_one_level(uint mutable& octnode_id_cur, level_data mutable& olevel,
  level_data const& ilevel)
{
  const sz2 = ilevel.size;
  const sz = sz2 / 2;
  olevel.size = sz;
  olevel.values.resize(sz * sz * sz, 0);
  olevel.octnode_id_base = octnode_id_cur;
  tree_map{node_value, uint} nodeset;
  for (const x: 0 .. sz) { for (const y: 0 .. sz) { for (const z: 0 .. sz) {
    node_value nvalue;
    for (const xi: 0 .. 1) { for (const yi: 0 .. 1) { for (const zi: 0 .. 1) {
      nvalue[zi * 4 + yi + 2 + xi] =
	ilevel.values[
	  (z * 2 + zi) * sz * sz +
	  (y * 2 + yi) * sz +
	  (x * 2 + xi)];
    } } }
    texel_value tvalue;
    if (sz != 1 && is_leaf_value(nvalue)) {
      tvalue = nvalue[0];
    } else if (const& m: nodeset[nvalue]) {
      tvalue = m;
    } else {
      nodeset[nvalue] = octnode_id_cur;
      tvalue = octnode_id_cur | 0x01000000U;
      ++octnode_id_cur;
    }
    olevel.values[(z * sz + y) * sz + x] = tvalue;
  } } }
  const id_base = olevel.octnode_id_base;
  olevel.nodes.resize(octnode_id_cur - id_base, node_entry());
  for (const& k, const& m: nodeset) {
    olevel.nodes[m - id_base] = k;
  }
}

----
old

非圧縮レベルをmake_octree_one_levelに適用し、その返値1が次のレベルとなる。
返値1が1*1*1サイズであるようなものまで適用したら終了。

各レベルの返値2のそれぞれについて、葉となるかどうか調べる。
  葉となる条件は、node_valueが8つとも同じ値を持っていて、かつその値(次に
  小さいレベルの返値2のインデックス)を引いた結果が葉となること。最小レベ
  ルの返値2が葉となる条件は、node_valueが8つとも同じ値を持っていること。
葉ならばその色(空白ならa=0,そうでないならa=1)を記録。
各レベルの返値2のそれぞれについて、葉でないならoctnodeを一つ割り当てる。
ただし根レベルでは葉であってもoctnodeを一つ割りあてる。octnode idが0。
(テクスチャ全体が同じ値を持つような場合に根レベルが葉になる)
(octnode割り当ては根レベルから順にやる)
octnode idの大きさのnode_value配列を作る。
各octnodeについて、node_value配列のoctnode idの位置を埋める。
値は、返値2エントリの以下のもの。
  - 葉ならばその値
  - そうでないならnode_value値をlocal idからoctnode idに変換したもの。

function void
make_octree_one_level(level_data mutable& olevel, level_data const& ilevel)
{
  const sz2 = ilevel.size;
  const sz = sz2 / 2;
  olevel.size = sz;
  olevel.values.resize(sz * sz * sz, 0);
  tree_map{node_value, uint} nodeset;
  uint local_id = 0;
  for (const x: 0 .. sz) { for (const y: 0 .. sz) { for (const z: 0 .. sz) {
    node_value nvalue;
    for (const xi: 0 .. 1) { for (const yi: 0 .. 1) { for (const zi: 0 .. 1) {
      nvalue[zi * 4 + yi + 2 + xi] =
	ilevel.values[
	  (z * 2 + zi) * sz * sz +
	  (y * 2 + yi) * sz +
	  (x * 2 + xi)];
    } } }
    if (const& m: nodeset[nvalue]) {
      nodeset[nvalue] = local_id;
      olevel.values[(z * sz + y) * sz + x] = local_id;
      ++local_id;
    } else {
      olevel.values[(z * sz + y) * sz + x] = m;
    }
  } } }
  olevel.nodes.resize(local_id, node_entry());
  for (const& k, const& m: nodeset) {
    olevel.nodes[m].nvalue = k;
  }
}

---------------------------------------------------------------------------
八分木構築retry

非圧縮レベル: 2*2*2テクセルの値をキーにして、同じ値を持つものを

metafunction node_value farray{uint, 8};
tree_map{node_value, uint} nodeset;

struct texel_value {
  bool is_reference;
  uint value; // is_referenceなら参照先のoctnode_id、そうでないなら色
}

---------------------------------------------------------------------------
八分木の一次元テクスチャ化

とりあえずRGBAのまま一次元化する。あとで小さくする。
大きくできなくて困る。
ループ回数を見てみる

---------------------------------------------------------------------------
4*4*4分木

4*4*4分木などにすると元絵のサイズに制約が出る。
2^(n*3)分木ならば元絵の幅のlog2がnの倍数でなければならない。
4*4*4分木ならば元絵の幅のlog2が2の倍数でなければならない。
元絵を2倍等すればいい。そうすれば元絵の幅は2の冪であればよい。
-> だめ。データが無駄に大きくなる。

---------------------------------------------------------------------------
空白長さ

ブロック内各ボクセルについて、隣接空白の範囲を長方形で。
長方形の取りかたは複数ありうる。
最長の軸を優先方式:
- xyz正負それぞれの方向で空白の長さを調べ、最長のものを基準とする。
- xが最長だったとする。
- 確保したxの範囲でxy最長の空白の長さを調べ、長いほうを基準とする。
- yが長かったとする。
- 確保したxyの範囲でz最長の空白の長さを調べる。
最短距離優先方式:
- xを正方向に一つ伸ばす
- xを負方向に一つ伸ばす
- yとzについても同じく


---------------------------------------------------------------------------
sponge問題

octree_bshift 1;      2*2*2 = 8分木
octree_size_l2 4;     16*16*16 = 4096ノード

block_factor = 2;
texture_size = 16 * block_factor;

prepare_texture_data_3d(7u); 128*128*128 ボクセル
convert_to_octree{1}(4); 8分木 4096ノード

convert_to_texture{1}(4)
sz_l2 = 7のはず。
sz = 128のはず
rsz = 16のはず
rsz2_l2 = 5
rsz2 = 32のはず
rtd->width = 32 16*16*16ノード、32*32*32ボクセル
data = 32768 あってる
nodes = 4546
16*16*16 = 4096ノードまでしか格納できないのであふれる

意図的に壊してフラクタルにするなら特定ノードまでで剰余を取るのがよい。

---------------------------------------------------------------------------
距離埋め込み

16*16*16 又は 8*8*8
a==0のとき空白
空白のときはrgb値には周辺の空白のaabb min/maxを書き込む。
上位4bitが-aabb_min, 下位4bitがaabb_max-1。最大16voxelまでしかskipできない。

vec3 voxel_next(inout vec3 curpos_i, inout vec3 curpos_f, in vec3 aabb_min,
 in vec3 aabb_max, in vec3 ray)
aabb_min, aabb_maxは最短で(0,0), (1,1)、最長になる

変更前:
float dzpos = float(d.z > 0.0);
float nz = (dzpos - tsub.z) / d.z;
vec2 xy = tsub.xy + d.xy * nz;
if (d.z != 0.0 && pos2_inside(xy, 0.0, 1.0)) {
  tsub = vec3(xy.x, xy.y, dzpos);
  r.z = dzpos * 2.0 - 1.0;
  return r;
}

変更後:
aabb_min += 0.001;  truncしたときに小数部がギリギリ境界手前になるように
aabb_max -= 0.001;
float dzpos = d.z > 0.0 ? aabb_max.z : aabb_min.z;
// float zdelta = dzpos - tsub.z;
// vec2 xydelta = d.xy * nz / d.z;
vec3 delta = vec3(d.xy * nz / d.z, dzpos - tsub.z);
if (d.z != 0.0 && pos2_inside(tsub.xy + delta.xy, aabb_min.xy, aabb_max.xy)) {
  vec3 diff_i = trunc(delta); // 0方向に切り捨て。GLSL1.2では使えない。
  tval += diff_i;
  tsub += delta - diff_i;
  r.z = d.z > 0.0 ? 1.0 : -1.0;
}

変更前:
if (node_type == 0) { // 空白
  curpos_f = clamp(curpos_f, 0.001, 0.999);
  dir = voxel_next(curpos_f, ray);
  while (true) {
    if (pos3_inside(curpos_i + dir, -0.5, block_factor - 0.5)) {
      break;
    }
    --level;
    if (level < 0) {
      break;
    }
    curpos_f = (curpos_i + curpos_f) * block_scale;
    vec3 parent = texpos_arr[level];
    curpos_t = floor(parent * block_scale) * block_factor;
    curpos_i = parent - curpos_t;
    // decode_coord(texpos_arr[level], curpos_t, curpos_i);
  }
  if (level < 0) {
    break;
  }
  curpos_i += dir;
  curpos_f -= dir;
} else { // 節 node_type == 1

変更後:
if (node_type == 0) { // 空白
  curpos_f = clamp(curpos_f, 0.001, 0.999);
  vec3 distval = floor(value.xyz * 255.0 + 0.5);
  vec3 dist_p = floor(distval.xyz / 16.0);
  vec3 dist_n = distval.xyz  - dist_p * 16.0;
  dir = voxel_next(curpos_i, curpos_f, 0.0001 - dist_n, 0.9999 + dist_p, ray);
  while (true) {
    if (pos3_inside(curpos_i + dir, -0.5, block_factor - 0.5)) {
      break;
    }
    --level;
    if (level < 0) {
      break;
    }
    curpos_f = (curpos_i + curpos_f) * block_scale;
    vec3 parent = texpos_arr[level];
    curpos_t = floor(parent * block_scale) * block_factor;
    curpos_i = parent - curpos_t;
    // decode_coord(texpos_arr[level], curpos_t, curpos_i);
  }
  if (level < 0) {
    break;
  }
  curpos_i += dir;
  curpos_f -= dir;
} else { // 節 node_type == 1

---------------------------------------------------------------------------
nodesのサイズ

nodesのサイズより小さくない最小の2の冪を計算。
9ならばw,h,d=3,3,3
3で割ってw,h,dをその値に。割った余りはdに加える。

---------------------------------------------------------------------------
タイル

元絵がタイル化されているときのmake_octree_one_level。
bshiftとタイルサイズが同じとする。
通常のmake_octree_one_levelでolevelを作ってからタイルマップで変換すればよい。

仮想絵のサイズ = タイルマップのサイズ * (1 << bshift)

タイルサイズは16^3。
タイル数は16^3。
タイルパターンは256^3。座標をタイルサイズで割ったものがタイル番号。
タイルパターン(256^3)とタイルマップ(256^3)の二つをbuildに渡す。
タイルマップのデータサイズ(256^3など)にタイルサイズ(16^3など)を掛けたものが
仮想絵サイズになる。
タイルマップのテクセル値はタイルパターンの番号

タイルマップの値はタイルパターンをタイルサイズで割ったサイズの座標(タイル座標)

---------------------------------------------------------------------------
めりこんだとき

案1: 裏面カリング無効、裏面がみえたときはカメラ位置からraycast開始
  裏ポリゴンにnear面が接触しているときに不可視。near面の大きさよりも、
  立方体と可視ボクセルとの距離を大きくとればおきないはず。
  描画順序によっては無駄が出る。
案2: めりこんでいるときは全面そのオブジェクトをraycast
  他のオブジェクトが内側にあるときにどうするか
案3: 表面カリング有効。裏面だけ書く。カメラが物体の内側ならばその位置を
  始点、そうでないならフラグメント位置からカメラに向かってvoxel_next
  した位置が始点。


重ね合わせ:
カメラからオブジェクトをみたときのzが一番近い点を基準にソート、手前から描画。
z-prepassやめる。遅延シェーディングもしない。
フラグメントシェーダでgl_FragDepthを書き込む。内側に入り込んだオブジェクトの
重ね合わせが正確にできるはず。

vec3 camera_local = -camera_dir * normal_matrix;
vec3 light_local = light_dir * normal_matrix;
vec3 pos = clamp(vary_position_local * 0.05 + 0.5, 0.0001, 0.9999);
vec3 campos = (camera_pos * vary_model_matrix) * 0.05 + 0.5; // FIXME: calc vsh
if (pos3_inside(campos, 0.0, 1.0)) {
  pos = campos;
} else {
  vec3 pos_i_unused;
  voxel_next(pos_i_unused, pos, vec3(0.0), vec3(1.0), -camera_local);
}


---------------------------------------------------------------------------
_3d_tmap
pattern_sz_l2: パターンデータのボクセル数
virt_sz_l2: 仮想ボクセル数
bshift: 3か4くらい
virt_sz_l2はbshiftの定数倍である必要がある
vtshift = virt_sz_l2 - bshift   仮想タイル数



---------------------------------------------------------------------------

再帰的バンプ

与えられた平面の上に複数のバンプを作る

tpat: 6方向のバンプパターンを作るxp, xn, yp, yn, zp, zn
それぞれの方向に16*16個、合計256*6個。

tmap: z=128 +- 8に板を配置

pz=0 xp方向に色がある
pz=1 xn
pz=2 yp
pz=3 yn
pz=4 zp
pz=5 zn


---------------------------------------------------------------------------
RGBAにエンコード

cpuでエンコード
平面パラメータ(a,b,c,d) ax+by+cz=d
  両辺割ってもよいのでdの絶対値は固定可能だが、abc小さくすると誤差が大きく
  なるので、両辺なるべく大きく取るほうがよい。もっとうまい表現方法はあるか？
a,b,cは(-1,1)、dは(-3,3)
dの値は4で割る
abcdを127倍?し128を加えて四捨五入。[0,255]にclamp。dは2未満にならないよう
にする。

glslでデコード
abcd = floor(val * 255.0 + 0.5) で[0,255]に戻す
  ここでdが0ならば平面パラメータは無いものとする。
128を引き、128で割る。(割らなくてもいいが)
dは4倍する。

---------------------------------------------------------------------------
法線、接平面

面(a,b,c,d): ax + by + cz = d
位置 p=(px,py,pz), 視線方向 v=(vx, vy, vz)
  接触点c=(x,y,z) c=p+tvを満たす

1. 位置pが埋まっている側かどうか調べる
  dot(abc,p)-dが正なら空白側、そうでないなら埋まっている。
  埋まっている側なら壁に接触。return。
2. 接触点を計算
  接触点c = p + tv
    where t = (d - (dot(abc, p)) / dot(abc, v)
  もしcが(0,1)の内側であればそこが接触。return。
3. そうでないなら接触していない。

面をどうやって作るか？
ボクセル内全ての頂点の凸包を作り、それぞれの面が切断する体積を求め、
最大のものを採用する

球の接平面データを作る
全体256^3ボクセル
各ボクセルでの接平面データ
1. まず球がそのボクセルの内側・外側・境界のいずれかを判定。
  一番近い頂点と遠い頂点と球の中心との距離を計算、半径と比較
  境界でなければ終了。
2. 一番遠い頂点の位置ベクトル(オブジェクト中心を原点、(-1,1)範囲)をpとする。
  p = (px,py,pz)
  接平面の法線ベクトルは n = normalize(p) に一致する。
  オブジェクト座標で計算すると
    接平面 ax+by+cz=d, 法線(a,b,c)=n は点pを通るから
    d = dot(n,p) = 球の半径
  ボクセル内座標で計算すると
    接平面 ax+by+cz=d, 法線(a,b,c)=n はボクセル内座標lpを通るから
    nx.lpx+ny.lpy+nz.lpz=d
    d = dot(n,lp)

---------------------------------------------------------------------------
仮にpolygon meshに変換したとすると

直方体一個につき12tri
16x16x16で10個の直方体とする。120tri
256*256*32タイルとする
251658240tri。2億5000万tri。
voxelデータの仮想サイズを大きくするとそこそこ遅くなる

polygon meshでは1500万triくらい出ていた。
polygon + parallax + lod と voxel でも対等くらい？
polygon + voxel が最適か。
  - オブジェクト増やしてもほとんど遅くならない
  - ディテールの自由度が高い
  - self shadow を正確に描ける

---------------------------------------------------------------------------

x, y, z を 0 から pszまで
const x1 = float(x * 2 + 1 - psz) / float(psz)
  最小値 (1 - psz) / psz == -255 / 256
  最大値 (511 - 256) / psz == +255 / 256
これがオブジェクト座標系(-1,+1)でのボクセルの中心位置
ボクセルの隅は中心から 1.0 / psz を加減算した値。

vec3 nor = make_vec3(x1, y, z1).normalize();
ボクセル中心での法線ベクトル

(x1, y1, z1).normalize() * 半径 を p=(px, py, pz) とする。
これはボクセル中心と球の中心を結ぶ直線が表面に接する点。
これをボクセルローカル座標に変換したものを lp=(lpx, lpy, lpz)とする。
ボクセル内座標で
  ax+by+cz=d, 法線(a,b,c)=nor, 点lpを通るから、
  d = dot(nor, lp) と求まる。
この平面がボクセル座標(0,1)の範囲と接触するかどうか判定。
  xyzは0..1なのでax+by+czの最小値は以下のように計算。
  axの最小値は aが負の時a, そうでないとき0
  xmi = min(a, 0), ymi = min(b, 0), zmi = min(c, 0)
  mi = xmi + ymi + zmi
  axの最大値は aが正の時a, そうでないとき0
  xmx = max(a, 0), ymx = max(b, 0), zmx = max(c, 0)
  mi <= d <= mx となったときボクセルと球面は接触する。
  d < miなら空白 mx < di なら埋まっている。

オブジェクト座標(-1,+1)からボクセルローカル座標(0,1)への変換
  ボクセルの0点 v0 = (x1, y1, z1) - (1.0, 1.0, 1.0)
  ボクセルの1点 v1 = (x1, y1, z1) + (1.0, 1.0, 1.0)
  lpx = (px - v0) * psz (=256.0) * 0.5

---------------------------------------------------------------------------

voxel_nextで読み飛ばす処理を関数に
  速度確認せよ FIXME

---------------------------------------------------------------------------

bool raycast_octree
{
  for (0 .. 128) {
    value = texture(...);
    if (色) {
      if (平面に接触) {
	if (ボクセル内で接触していない) {
	  raycast_next(...);
	  continue;
	} else { // ボクセル内で平面に接触
	  dir = 平面の法線
	}
      } else { // 壁に接触
	// dir = 壁の向き？
	// hit_wall = true;
	dir = 平面の法線
      }
      if (影処理中) {
	lstr_para = 0.0;
	break;
      }
      value_r = 物体の色
      影処理中 = true;
      ray = light;
      if (hit_wall) {
	texpos_arr pop;
      } else {
	raycast_next(...);
      }
    } else if (節) {
      texpos_arr push;
    } else { // 空白
      raycast_next(...);
    }
  }
  return hit;
}

ループの最後でraycast_next(...)を通る形に書き換えるべし。


---------------------------------------------------------------------------
表面に3dテクスチャを貼る

ctx_fill(n)
-> build_context_i#fill(true, false, n, "", poly, mp)
-> build_context_impl#fill(...)
-> fillers[n](...)
   pglshader#make_vertex_set(...)
   n番目のdrawersのfillerが実行される
    r.insert("drawer_0_triangles", make_drawer_triangles(sconf, res, 0));
    r.insert("drawer_0_triangles_alt", make_drawer_triangles(sconf, res, 1));
  n == 1ならdrawer_0_traiangles_alt
  drawer_triangles#make_fillerは make_dgf_polygon_filler
-> dgf_fill_tattr_internal
  uvwとuv_aabbに書き込んでいるが_altシェーダでは見ないのでは？
  poly_tはcslice{vertex_attr}
  vertex_attrはstruct { vec3 pos, nor, tan, uvw; }

- gf_ctx_fill(n)のかわりに、3dテクスチャのための立体を作りuvwを設定して
  gf_ctx_fillするようなgfを作る
  gf_ctx_tex3d(n) ?
- dgf_fill_tattr_internal: uvwをpoly_tのものを反映するフラグかなにかを作る
- fshでuvwをテクスチャ座標として反映させるようにする

従来のシェーダ
<%vert_in/> vec3 position;
<%vert_in/> vec3 normal;
<%vert_in/> vec3 tangent;
<%vert_in/> vec3 uvw;
<%vert_in/> vec4 uv_aabb;
tex3dで渡す情報
- 3dテクスチャを貼る座標系(接空間)への変換行列が必要
- 各頂点の接空間での座標が必要
- 各頂点のuvw座標が必要
positionで接空間の原点位置、normalとtangentとその外積で回転、uvwでテクスチャ座標

dgf_polygon_filler_tattrのoverride_uvwフラグはtriangles drawerのoptが0のとき
有効になる。
optが1のときはuv_aabbのかわりにlocal_positionを入れるか
接空間からテクスチャ座標への変換とその逆変換が必要(gl_FragDepth計算に必要)
aabb_lposのxyzにuvw原点の接空間座標、wにuvwから接空間座標へのスケールを入れる。

tex3dシェーダでの頂点属性の解釈まとめ
- position, normal, tangentにはモデル座標から接空間座標への変換を入れる
- uvwには頂点のテクスチャ座標を入れる
- uv_aabb(名前変える)に頂点のテクスチャ座標から接空間座標への変換を入れる

手順
- uv_aabb -> aabb_or_lconv
- geometry::funcs::vertex_attrにlocal_pos追加(接空間での頂点座標)
- drawer::base::dgf_fill_tattr_internalでoverride_uvwが偽のときに
  local_posからaabb_or_lconvをセット
- gf_ctx_tex3dがpos, nor, tanを接空間の原点位置と回転、uvwにテクスチャ座標、
  local_posに接空間での頂点座標を入れるように変更
- vshの変更点
  - 方針: 接空間への変換も含めてmodel matrixとする
  - uvw以外のパラメータは全頂点で共通(勿体無い？)

頂点シェーダ
in vec3 position; // オブジェクト座標系での接空間の原点座標
in vec3 normal; // オブジェクト座標系での接空間のz軸
in vec3 tangent;  // オブジェクト座標系での接空間のx軸
in vec4 aabb_or_tconv;  // テクスチャ座標から接空間への変換
in vec3 uvw;  // 頂点のテクスチャ座標
out vec3 vary_position; // グローバルでの頂点座標 --------?
out vec3 vary_normal; // グローバルでの法線
out vec3 vary_tangent; // グローバルでの接線
out vec3 vary_binormal; // グローバルでの従法線
out vec3 vary_uvw; // 頂点のテクスチャ座標
out vec3 vary_aabb_or_tconv; // テクスチャ座標から接空間への変換
out mat4 vary_model_matrix; // 
out vec3 vary_position_local; // 接空間での頂点座標
out vec3 vary_camerapos_local; // 接空間でのカメラの位置
vary_uvw = uvw; // 頂点のテクスチャ座標
vary_position_local = aabb_or_tconv.xyz + uvw * aabb_or_tconv.w;
  // 接空間での頂点座標
binormal = cross(normal, tangent); // オブジェクト座標系での接空間のy軸
mat4 tan_to_obj = mat4(
    vec4(tangent, 0.0),
    vec4(binormal, 0.0),
    vec4(normal, 0.0),
    vec4(position, 1.0)) // 接空間からオブジェクト座標系への変換
mat4 obj_to_tan = inverse(tan_to_obj);
  // 接空間からオブジェクト座標系への変換
mat4 mm = <%instance_attr_model_matrix/>;
  // モデル行列(オブジェクト座標からグローバルへの変換)
mat4 tan_to_world = mm * tan_to_obj; // 接空間からグローバルへの変換
vec4 gpos4 = tan_to_world * vec4(vary_position_local, 1.0);
  // グローバルでの頂点の座標
gl_Position = view_projection_matrix * gpos4; // gl_Position書き込み
vary_position = gpos4.xyz / gpos4.w; // グローバルでの頂点の座標
vary_model_matrix = tan_to_world;
  // グローバルから接空間への変換
vec4 cp4 = = inverse(vary_model_matrix) * camera_pos;
vary_camerapos_local = cp4.xyz / cp4.w;
  // 接空間でのカメラ位置

接空間座標sをテクスチャ座標に変換
ts = texpos.xyz + s.xyz * texscale
  texscale = 1.0 / aabb_or_tconv.w
  texpos = - aabb_or_tconv.xyz * texscale

フラグメントシェーダ
vary_aabb_or_tconv = vec4(-32.0, -32.0, -32.0, 64.0);に一旦してテスト
テクスチャ座標posを接空間座標に戻すには
lpos = vary_aabb_or_tconv.xyz + pos * vary_aabb_or_tconv.w;

vec3 tpos = vary_uvw; // テクスチャ座標
vec3 lpos = vary_aabb_or_tconv.xyz + tpos * vary_aabb_or_tconv.w; // 接空間座標

tangent spaceの意味が曖昧
- tangent vector space 接ベクトル空間。接線が成すベクトル空間。
- tangent space (2) 接線と法線と従法線で作られるベクトル空間。

頂点データの計算
入力:
  - オブジェクト座標系での各頂点の座標pos
  - 貼り付けるテクスチャのオフセットtexpos
  - テクスチャのスケールtexscale (2ならばオブジェクト座標系の1がテクスチャの2)
多角形を覆う長方形を決め、その頂点の一つを接空間の原点とする。
その座標がposition属性(オブジェクト座標系での接空間の原点座標)。
オブジェクト座標での多角形の法線がnormal属性。
オブジェクト座標での原点から次の頂点へのベクトルをnormalizeしたのがtangent属性。
外積をとったのがbinormal(属性にはセット不要)。
原点から残りの頂点へのベクトルをtangent, binormal, normalと内積をとったものが
各頂点の接空間座標xyzとなる。
各頂点のテクスチャ座標は、texpos + 接空間座標 * texscale となる。uvw属性。
1.0/texscaleをaabb_or_tconv属性のw。
-texpos/texscaleをaabb_or_tconv属性のxyz。
検算
  原点のuvw属性はtexpos。
  vary_position_local
    = aot.xyz + uvw * aot.w
    = -texpos/texscale + texpos / texscale
    = 0
  あってる。

TODO: カメラが立体の内側に入ったかどうかの判定？

geometry生成時に設定するパラメータ
- テクスチャのxyサイズは、座標との比をパラメータとして渡して計算する？
- テクスチャのzサイズはgfに引数として渡す？
- テクスチャ座標offsetはgfにパラメータとして渡す。いずれテクスチャ生成関数を
  挟めるようにする
- テクスチャ座標のaabbをシェーダに渡す必要がある。頂点属性に追加する。


whに対しdが1/32のとき。

---------------------------------------------------------------------------
ctx_tex3d

縦横高さサイズを指定し、それに合った3dテクスチャをランダムに作る。
struct tex3_param {
  uint width;
  uint height;
  uint depth;
  その他生成のためのパラメータ
}
パラメータが同一なら同じパターンが複数箇所に貼られることがある。
ジェネレータはアトラス内のオフセットを返す。

低辺: 直方体のx軸にするのをどの辺にするかを指定 (0-3)
高さ: 接線座標のz方向の大きさ
テクスチャ位置: 接線座標の原点に貼り付けるテクスチャの座標 (0,1)
テクスチャ拡大率: 接線座標の1に対するテクスチャの大きさ

---------------------------------------------------------------------------
バンプ

斜面ボクセルに壁有りと壁無しを用意する
壁有り: 埋まっている側のボクセル壁に反射する
壁無し: 斜面のみに接触？斜面の裏側から見たときは壁に反射する？

左右だけが斜面のバンプ
  __/~~~~\__
  斜面ボクセルは壁有り斜面

8方向が斜面のバンプ
  斜面ボクセルは壁無し

---------------------------------------------------------------------------

+-----*
|    /|
|   / |
|  /  |
| /   |
|/    |
*-----+
x=y
x-y=0
逆向きは x+y=1

---------------------------------------------------------------------------

vec3 v; // 視線
vec3 a; // 始点 curpos_f
vec3 mul_pt; // 拡大率
vec3 c_pt; // 中心
float rad2_pt; // 半径の2乗

a_pt = mul_pt * (a * 2.0 - 1.0); // 変換後の始点
v_pt = mul_pt * v; // 変換後の視線
len_v_pt = length(v_pt);
v_ptn = normalize(v_pt);
ac_pt = c_pt - a_pt; // ベクトルAC
len2_ac_pt = dot(ac_pt, ac_pt);
if (len2_ac_pt < rad2_pt) { return 始点が球の内側 }
ac_v = dot(ac_pt, v_ptn);
d_pt = a_pt + v_ptr * ac_v; // Cから視線に垂線を下ろした点D
cd_pt = d_pt - c_pt; // ベクトルCD
len2_cd_pt = dot(cd_pt, cd_pt); // CDの大きさの2乗
if (len2_cd_pt < rad2_pt) { 視線と球は交わらない }
len_de_pt = sqrt(rad2_pt - len2_cd_pt); // DEの大きさ
len_ae_pt = ac_v - len_de_pt; // AEの大きさ
len_ae = len_ae_pt / len_v_pt; // 逆変換したAEの大きさ
e = a + v * len_ae; // 変換前の交点

---------------------------------------------------------------------------
android pause/resume

シェーダ

テクスチャ

インスタンスデータ
aggregated_ibuffer aibuffer pglshderが保持

GL3用VAO
auto_vertexarray vtxarr  pglshaderが保持

頂点データ
vertex_buffers pglshaderが保持
vertex_buffer glbuffer.px
auto_buffer vbo_values;
auto_buffer vbo_elems;
create_vbo()でGPU側に作成
  これの後半を分離、リロードできるようにする
  auto_buffer の generateをすればよい。自動で古い値は解放される。

#define SDL_EGL_MakeCurrent_impl(BACKEND) int \
BACKEND ## _GLES_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context) \
{\
    if (window && context) { \
        return SDL_EGL_MakeCurrent(_this, ((SDL_WindowData *) window->driverdata)->egl_surface, context); \
    }\
    else {\
        return SDL_EGL_MakeCurrent(_this, NULL, NULL);\
    }\
}

#define SDL_EGL_CreateContext_impl(BACKEND) SDL_GLContext \
BACKEND ## _GLES_CreateContext(_THIS, SDL_Window * window) \
{\
    return SDL_EGL_CreateContext(_this, ((SDL_WindowData *) window->driverdata)->egl_surface);\
}

windowはnullでないからwindow->driverdata->egl_surfaceがnullになっている

---------------------------------------------------------------------------
raycast_octreeをカメラとライトで分離するほうがよいか

なぜか分離しないほうがはるかに速い。
分離してみたものを置いておく。 saved/2step-traingles.fsh

---------------------------------------------------------------------------
nvidia control panel

レンダリング前最大フレーム数を小さくするとわずかに速くなる。
遅延も小さくなるので1にするのがよいか。
それ以外の項目はすべてデフォルト。

---------------------------------------------------------------------------
voxel_surface

ctx_tex3d
darrayst{vertex_attr} front = poly;

TODO: 境界値

---------------------------------------------------------------------------
raycast_tilemap

移行手順
1. calc_distanceをtexture_dataに適用できるよう改修
2. tpatとtmapをcalc_distance適用, tpatは16境界まで、tmapは境界なし
3. drawer/trianglesでtmapとtpatをuniformで渡す
4. triangles.fshにraycast_tilemap追加


---------------------------------------------------------------------------
voxtpatとvoxtmapのmipmap

16, 8, 4, 2, 1の5種類
distanceは2,4,8..倍した値を埋め込んでおく
calc_distanceにmipmap_levelを渡す
tpatのdistanceは16, 8, 4, 2, 1単位で


---------------------------------------------------------------------------
Version対応

OpenGL	GLSL
1.5	1.0
2.0	1.1
2.1	1.2
3.0	1.3
3.1	1.4
3.2	1.5
3.3	3.3

---------------------------------------------------------------------------
gf_ctx_tex3d_opt

テクスチャ座標
接線空間
  基準平面をxy軸とするような空間。
  フラグメントシェーダではローカル座標系ではなく専らこちらを使う。
  シェーダのmodel_matrixも接線空間からワールドへの変換。
ローカル座標系
  インスタンスデータのmodel_matrixがあらわす座標系。
ワールド座標系

aabb_or_tconvをセットする。テクスチャ座標からローカル座標への変換。
テクスチャ座標から接線空間への変換:
  pos = vary_aabb_or_tconv.xyz + pos * vary_aabb_or_tconv.w;

---------------------------------------------------------------------------
voxel_collision_sphere

v: (rayから) 光線の方向
a: (curpos_fから) 始点 中で-0.5から+0.5に移動される。
c: (rgb下位4bitから) 球の中心座標 -2から+1.75まで0.25きざみ
mul: (rgb上位4bitから) 倍率 0から1.875まで0.125きざみ
rad: (node_typeから) 半径 1/4から253/4まで0.25きざみ 中で2乗される。
aにmulを掛ける(楕円体や円柱にできる)
acの距離がradより小さいなら衝突

---------------------------------------------------------------------------
box_pointerの実装

rcval<foo> *const p = rcval<foo>::allocate();
try {
  new (p->value) foo(引数いろいろ);     // foo自体を初期化
  new (p->count) stcount(); // 参照カウンタを初期化(nothrow)
  try {
    new (p->monitor) monitor(); // モニタを初期化(throw)
  } catch (...) {
    // カウンタはpodなのでデストラクタ呼ばなくてよい
    p->value.~p(); // fooのデストラクタ
  }
} catch (...) {
  rcval<foo>::deallocate(p);
  throw;
}
rcptr<rcval<foo>> r(p);
return r;

template <typename T> auto_deallocate {
  auto_deallocate() : ptr(T::allocate()) { }
  ~auto_deallocate() { if (ptr) { T::deallocate(ptr); } }
  T *release() { T *r = ptr; ptr = 0; return r; }
  operator T *() { return ptr; }
private:
  T *ptr;
  auto_deallocate(auto_deallocate const&);
  auto_deallocate& operator =(auto_deallocate const&);
}

---------------------------------------------------------------------------
tilemapの一部から切り出し

gf_ctx_tex3d_int_surfのint_quadsはオブジェクト座標系で指定しているので
変更不要

gf_ctx_tex3d_surfのsurf_quadsはattr.aabb_minとaabb_maxが0.0と1.0で、
attr.posは接線空間原点のグローバル座標
attr.norは基準平面の法線ベクトル(接線空間のz軸) ノーマライズ
attr.tanは接線空間のx軸 ノーマライズ
attr.aabb_or_tconv = vec4(0, 0, 0, texscale);
  これのxyzはテクスチャ座標原点に対応する接線空間での座標
ここでtexscale = length(poly[1].pos - poly[0].pos);
  これはテクスチャ座標から接線空間座標への倍率
各頂点のattr.uvwにテクスチャ座標を入れる 0.0と1.0など
(vsh内)
vary_position_local = aabb_or_tconv.xyz + uvw * aabb_or_tconv.w
  // 接線空間での頂点座標をテクスチャ座標から計算

変更点
attr.aabb_minとaabb_maxでテクスチャ座標の範囲を示すように変更。
 (これはgf_ctx_tex3d_surfの引数で受け取る)
attr.uvw = aabb_min + uvw * (aabb_max - aabb_min) に変更。
aabb_or_tconv.w = texscale / (aabb_max.x - aabb_min.x) に変更。大きくなる。
aabb_or_tconv.xyz = -aabb_min * aabb_or_tconv.w に変更。

// poslocal = tconv.xyz + attr_uvw * tconv.w これが
// attr_uvw=aabb_minのとき0になる必要があるから
// tconv.xyz + aabb_min * tconv.w = 0
// tconv.xyz = -aabb_min * tconv.w

---------------------------------------------------------------------------
editmode復活

- 256x256x256程度を編集
- ボクセル単位の編集と、16x16x16ブロック単位の編集
- カーソルよりzが大きいボクセルは非表示
- 範囲指定して、平面切断、二次曲面切断

---------------------------------------------------------------------------
シェーダー整理

各shadowmapについて
  フレームバッファを設定
  glDepthMaskなど描画モードをshadowmap用に設定
  クリア
  glViewport設定
  各drawerについて
    描画
ターゲットフレームバッファを設定
描画モードをzprepass用に設定
各drawerについて    
  zprepass描画
描画モードをsolid用に設定
各drawerについて
  color描画
描画モードをblend用に設定
各drawerについて
  blend描画
各drawerについて
  ターゲットフレームバッファを設定
  postprocess描画

---------------------------------------------------------------------------
sp_scale, sp_center

2016/09/04
sp_scaleを2bitx3, sp_centerを6bitx3にした。720pで304fps->302fpsくらいに少し
遅くなった。
面取りのパラメータは
  sp_center = (1, 1, 0);
  sp_scale = (2, 2, 0);
  radius = 2;

---------------------------------------------------------------------------
edit mode

Mで始点を指定、もう一度Mでキャンセル。
Cは始点が指定されていれば範囲をコピー。

---------------------------------------------------------------------------
edit mode 混合編集

原点付近の16x16x16タイル範囲はパターン編集用でタイル番号は固定する。
それ以外の256x256x32範囲(最大32k,32k,128程度)はタイル番号を編集できる。
   (27bitタイル、12bitパターンで仮想サイズ39bit 500Gvoxel)

---------------------------------------------------------------------------

範囲をペーストした場合のdistance再計算。
その範囲に届くような全ボクセルについて、範囲の手前から計算しなおす。
範囲内のボクセルについては最初から計算しなおす。

範囲をクリアした場合のdistance再計算。
その範囲に届くような全ボクセルについて、現在値から計算しなおす。
範囲内のボクセルについては最初から計算しなおす。

非クリア時、範囲の手前から計算しなおす処理。zp方向の例。
範囲の最大zが対象座標z以下であればzp再計算不要。
そうでないならzp再計算必要。
範囲の最小zから対象座標zを引き、さらに1を引いたものがzp初期値。

クリア時、zp方向の再計算が必要かどうかの判定。
zpを一つ加えた位置が範囲の小さい側のz値と一致しなければ不要。
xy空白aabbを計算。それが範囲のxyと交わらないなら不要。
そうでないなら再計算必要。

---------------------------------------------------------------------------
edit mode 描画更新

int cursor_flick;
uint cursor_color;
bool edit_pat;
uvec3 cursor_tpat;
uvec3 cursor_tmap;

flick_cursor()
  - cursor_flick をインクリメントし、値に応じてカーソル点滅
reset_cursor()
  - cursor_flickを0にし、カーソルが点灯であればカーソル位置を書き戻す
edit_pat_switch()
  - reset_cursorする
  - edit_tpat 切り替え。
  - tmapからtpatに変更するときはcursor_tpatより上をviewクリア
  - tpatからtmapに変更するときはcursor_tpatより上をview戻し
set_cursor_color()
  - reset_cursorする
  - cursor_color書き換え
set_tpat()
  - edit_tpatでなければreturn
  - reset_cursorする
  - editとview両方に書き込み
set_tmap()
  - edit_tpatであればreturn
  - reset_cursorする
  - editとview両方に書き込み
move_cursor_tpat()
  - edit_tpatでなければreturn
  - reset_cursorする
  - 上に移動する場合は移動した領域をview戻し
  - 下に移動する場合は移動した領域をviewクリア
move_cursor_tmap()
  - edit_tpatであればreturn
  - reset_cursorする
  - 上に移動する場合は移動した領域をview戻し
  - 下に移動する場合は移動した領域をviewクリア


---------------------------------------------------------------------------
edit_mode z-clip

viewのz-clipを速くしないと実用にならない。
clipされない部分についてはeditからdistance変更なし。
clipされる部分については境界までの距離をdistanceとする。

カーソル点灯のときは、15以内に近接する部分はコンサバにdistanceを削る。
たとえばそのボクセルのxpは、カーソルの最小xがそのボクセルより大きいときは
その位置に届かないように削る。

カーソル消灯のときは、editからコピーするだけでよい。

---------------------------------------------------------------------------
edit_mode z-clip動作

tmapのカーソルより上は、カーソルがtmapにあるかどうかにかかわらず非表示
tpatにカーソルがあるときはの、現在のパターン内のカーソルより上は非表示

---------------------------------------------------------------------------

KP_PLUSで塗りつぶしブロック種類を切り替え。
  0空白、1壁、2平面、3球面。
  パラメータはリセットする。
KP_ENTERでedit_params_modeを0, 1, 2の順に切り替え
  空白か壁のときはパラメータは無い。
  平面のときは法線と距離だけを変更可能
  球面のときはオフセットと距離が1、拡大率が2

---------------------------------------------------------------------------

vec3 sp_scale = floor(distval / 64.0);
  上位2bit
vec3 sp_center = distval - scale * 64.0 - 32.0;
  下位6bit、0-63の範囲から32を引いて-32から+31の範囲
float sp_radius = float(node_type - 1) * 1.0;
  node_type=2がradius=1になる
voxel_collision_sphere(ray, curpos_f - 0.5, sp_center, sp_scale,
  sp_radius * sp_radius, hit_wall, sp_nor);
  curpos_fは0から1の範囲
a = curpos_f - 0.5
  -0.5から+0.5の範囲
c = sp_center;
  -32から+32の範囲
mul_pt = sp_scale;
  0から3の範囲
rad2_pt = sp_radius * sp_radius;
  1から63^2の範囲
a_pt = mul_pt * a;
c_pt = c;
ac_pt = c_pt - a_pt;
float len2_ac_pt = dot(ac_pt,, ac_pt);
if (len2_ac_pt <= rad2_pt) {
  始点aが球の内側
}

---------------------------------------------------------------------------
キーバインド

UP, DOWN, LEFT, RIGHT 向き
Z, X 回転
SPACE 加速
SHIFT 減速
RETURN 停止
W, A, S, D シフト
TAB シーン
RIGHTBRACKET -> F11 フルスクリーン
1 -> F5 リロード
LEFTBRACKET -> F10 VSYNC有効切り替え
M -> F1, F12 PAUSEと保存
J, K -> F8, F9 露出
PAGEDOWN, PAGEUP 太陽
T -> E 投げる
L -> Q パーティクル

---------------------------------------------------------------------------
sphereとplaneのパラメタがオフセットでどう変わるか

make_sphere_node:
  const c = p.center - offset * p.scale;
make_plane_node:
  const d1 = d - dot(nor, offset) * 2;

---------------------------------------------------------------------------
shadowmapとprepass課題整理

事前計算なしにraycastシェーダのshadowmapとprepassできるか。
1. raycastする物体を囲む直方体
2. raycastする3dテクスチャ

prepass案
1. カメラに近いほうからソート、デプステストあり、fsデプス書き込み無し
  - 大きい物体と小さい物体の順序が正しくなくなる
2. ソートしないでprepass、大小二回にわけで描画
  - 全オブジェクトの外側を表面カリングでprepass描画
  - 一回目は大きい物体、別バッファにデプス値を書き込む
  - 二回目は別バッファの値を読んで自前でデプステスト。
  - だめ。小さい物体のprepass書き込みにより描画漏れがおきる
  - raycastせずにprepass描画するためには、物体よりも内側の概形を知る必要がある
3. ソート、デプステストあり、大小二回にわけて描画
  - 一回目は大きい物体、別バッファにデプス値を書き込む
  - 二回目は別バッファの値を読んで自前でデプステスト。
    - あるいは一回目のデプス値とデプスバッファをマージするか
  - この方法が良さそう。

shadowmap

1. 大きい物体のディテールが小さい物体に影をさすようにできないか。
2. 3dテクスチャ変更に追従できないか。

shadowmap案

1. ワッフル状の頂点データ、ディテールも頂点データ
  - 頂点データは増えるがfsを空にできる
  - 事前計算は必要なので3dテクスチャ追従は難しい
  - iquadsをそのまま使えるがワッフル状に作ったほうが速くなるか
2. ワッフル状の頂点データ、ディテールは3dテクスチャを読む
  - 頂点データは少なくてよいがfsが少し重くなる
    - fsで一点のテクスチャを読む必要がある
  - 板をカメラに近いほうから順に描画する。fs無駄打ち防止のため。
3. 直方体の頂点データ、ディテールは3dテクスチャを読む
  - 完全なraycastではなく、ワッフル状の座標だけを拾う。
  - 頂点データはraycastと共通でよい。
  - 巨大な物体でも3ワッフルくらいで十分か。
  - 光源に近い順にソート。colorバッファにdepth値を書き込む。
4. ワッフル状の頂点データ、ディテールは2dテクスチャ
  - discard使うだけで相当遅くなるのではないか


---------------------------------------------------------------------------

テクスチャに描画し、またそのテクスチャをbindしてシェーダから読めるように
すると、テクスチャへの書き込みが読み出しに反映されることを保証するには
glTextureBarrierすればよい。


---------------------------------------------------------------------------
glewのinclude/GL/glew.h

constが抜けていてコンパイル通らなかったので以下のように直接書き換え。
typedef void (GLAPIENTRY * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value);
仕様ではglClearNamedFramebufferfvの型は以下のとおり。
        <command>
            <proto>void <name>glClearNamedFramebufferfv</name></proto>
            <param><ptype>GLuint</ptype> <name>framebuffer</name></param>
            <param><ptype>GLenum</ptype> <name>buffer</name></param>
            <param><ptype>GLint</ptype> <name>drawbuffer</name></param>
            <param>const <ptype>GLfloat</ptype> *<name>value</name></param>
        </command>

---------------------------------------------------------------------------
ワッフル

raycastの始点posは直方体の裏面。テクスチャ座標。
aabb_min, aabb_maxは直方体の端。テクスチャ座標。
ray=camera_localはテクスチャ座標での視線。

fz=(aabb_min.z + aabb_max.z) * 0.5 の平面と視線が交わる位置を求める。
pos.z + ray.z * a = fz
a = (fz - pos.z) / ray.z
交点c = pos + ray * a になる

---
vec3 pos = texpos + vary_position_local * texscale;
  // テクスチャ座標でのフラグメント位置
vec3 f = (aabb_min + aabb_max) * 0.5;
vec3 a = (f - pos) / ray; // 三か所の交点を一度に求める
cx = pos + ray * a.x; yz面との交点
cy = pos + ray * a.y; zx面との交点
cz = pos + ray * a.z; xy面との交点

triangles.fsh -> triangles-sm.fsh
uniform mat4 view_projection_matrix;
  -> shadowmap_vp
uniform vec3 camera_pos;
  -> とりあえず光源は無限遠のみを想定するので不要
uniform mat4 shadowmap_vp[<%smsz/>];
  -> 不要
<%decl_instance_attr mat4 model_matrix/>
  -> 同じ
<%vert_in/> vec3 position;
  // stype==1のときオブエジェクト座標系での接線空間の原点
  -> 同じ
<%vert_in/> vec3 normal;   // オブジェクト座標系での法線(接線空間のz軸)
  -> 同じ
<%vert_in/> vec3 tangent;  // オブジェクト座標系での接線(接線空間のx軸)
  -> 同じ
<%vert_in/> vec3 uvw;      // 頂点のテクスチャ座標
  -> 同じ
<%vert_in/> vec4 aabb_or_tconv;
  // stype==1のときテクスチャ座標から接線空間への変換
  -> 同じ
<%if><%eq><%stype/>1<%/>
  <%vert_in/> vec3 aabb_min; // テクスチャ座標の範囲aabb
    -> 同じ
  <%vert_in/> vec3 aabb_max; // テクスチャ座標の範囲aabb
    -> 同じ
<%/>
<%vert_out/> vec3 vary_position; // ワールドの頂点座標(オブジェクト原点)
  -> 同じ
<%vert_out/> vec3 vary_normal;   // ワールドでの法線
  -> 不要
<%vert_out/> vec3 vary_tangent;  // ワールドでの接線
  -> 不要
<%vert_out/> vec3 vary_binormal; // ワールドでの従法線
  -> 不要
<%if><%eq><%stype/>1<%/>
  <%flat/> <%vert_out/> vec4 vary_aabb_or_tconv; // aabb_or_tconvと同じ
    -> 同じ
  <%flat/> <%vert_out/> vec3 vary_aabb_min;
    -> 同じ
  <%flat/> <%vert_out/> vec3 vary_aabb_max;
    -> 同じ
  <%flat/> <%vert_out/> mat4 vary_model_matrix; // 接線空間からワールドへの変換
    -> 同じ
  <%vert_out/> vec3 vary_position_local; // 接線空間での頂点座標
    -> 同じ
  <%flat/> <%vert_out/> vec3 vary_camerapos_local; // 接線空間でのカメラ座標
    -> とりあえず不要
<%/>
mat4 mm = <%instance_attr model_matrix/>;
vary_position_local = aabb_or_tconv.xyz + uvw * aabb_or_tconv.w;
vec3 binormal = cross(normal, tangent);
mat4 tan_to_obj = mat4(
  vec4(tangent, 0.0),
  vec4(binormal, 0.0),
  vec4(normal, 0.0),
  vec4(position, 1.0)); // 接線空間からオブジェクト座標系への変換
mm = mm * tan_to_obj; // 接線空間からワールド座標への変換
mat3 normal_matrix = mat3(mm);
vec3 model_transform = mm[3].xyz;

---------------------------------------------------------------------------
ctx_tex3d

引数にはテクスチャ座標の範囲を指定する。
polyの最初の辺をx軸の大きさとして、それがテクスチャのx幅に一致するように
scaleを決める。


---------------------------------------------------------------------------
大小オブジェクト重ね合わせ

1. まず大きいオブジェクトを手前から描画。表面カリング
   - depthには裏面のdepth値が入る。
   - depthとは別にdepth_auxフレームバッファに頂点のdepth値を書く
2. 小さいオブジェクトを描画。

step1対象のフレームバッファ: color, depth, depth_alt
step2対象のフレームバッファ: color, depth
depth_altはstep2でuniform int sampler_depth_altに渡す
step2のfsで遠点をdepth_altから計算、そこまでに衝突しなければdiscard

---------------------------------------------------------------------------
メモ

tile3_size 16x16x16
pat3_size 16x16x16
map3_size 256x256x256
virt3_size

---------------------------------------------------------------------------
FragDepth更新

OpenGL 4.2以降か、GL_ARB_conservative_depth有効のとき。

layout (depth_less) out float gl_FragDepth;
gl_FragCoord.zより小さい値しかセットしない

---------------------------------------------------------------------------
重ね合わせ

detail_depth_curをCOLORにセットしたFBOを用意。テクスチャにしなくてもよい？
detail_depthテクスチャを作る。

detail_depth_curを1.0で埋める

大きいオブジェクト
近い順に描画
  detail_depthを読んで手動デプステスト
  detail_depth_curにfragdepthを書き込む
  draw後、detail_depth_curからdetail_depthにコピーする

小さいオブジェクト
  detail_depthを読んで手動デプステスト
  fragdepthは書き込まない


glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
  GLint x, GLint y, GLsizei width, GLsizei height);
現在描画対象となっているフレームバッファの(x,y,width,height)領域を、
現在bindしているテクスチャの(xoffset,yoffset)位置へコピーする。

変更手順
aggregated_ibufffer_drawを1インスタンス単位で呼べるようにする
aggregated_ibufffer_draw
  // 各vertex_set(形状データ)ごと
  for (const vs_id: 0 .. bo.num_vs()) {
    // draw call 一発で描画
    bo.draw_elems_instanced()
  }
大きいオブジェクトはvertex_setを専用のものにするか
trianglesシェーダのインスタンス間で共有データを持てるようにする。

vertex_set順に描画すると手前から順にソートする意味がない。
z-prepassも無効。
シェーダの描画順序でfs無駄打ちを防止するのがよいか。
分解しないオブジェクトは内接メッシュを作ってz-prepassでもよい。

ctx_fillなどに指定する整数値はmake_vertex_setの最初の引数として
渡す配列のインデックスを差し、そのmappedの文字列の名前に一致する
drawerで多角形を塗ることをいみする。fillの実体はengine/pglshader.px
のbuild_context_impl::fill()。
drawerごとのfillerを呼び出す。実体は各drawerのmake_fillerが返す
インスタンスで、中身はたとえば
dgf_fill_tattr_internal
で、中では
push_polygon_distinct()
を呼んでいる
make_vertex_setでは第二引数で示された名前のvertex setを作り、
そのvertex setに対して第三引数の関数オブジェクトを評価して
頂点データを埋める。

glvertex::vertices: 一つのオブジェクトの頂点データを保持する
glbuffer::vertex_set: verticesに加えてvertex_buffer内オフセットを保持する
glbuffer::vertex_buffer: drawerの全オブジェクトの頂点データを保持しVBOを作る
  drawerごとに一つ作られる。
  pglshaderのvertex_buffersに保持される。
pglshader::pglshader
  varray{ptr{pgldrawer_i}} drawers;


on_motion_step()のftable
motion_thread_sharedのpidft0
motion_thread_clientのpidft
pglshaderのpidft
pidf_table 各drawerのvbidに対し、get_prepare_instance_data_funcptr()を保持。
例えばprepare_instance_data_triangles()
  中身はinstance bufferにmodel行列を追加するだけ。
on_motion_step()ではツリーを辿ってleafのノードについてvbidを
見て対応するエントリをftableから取り、その関数を呼ぶ。そうするとインスタンス
データが積まれる。

不明点: main_vbidは何に使っているのか。

scene_nodeのbo_idにはmain_vbidのほうが入っている？

jointを作るときにctx_poly_jointを呼ぶが、
jointの名前からvbidを引くのは最初に見つかったものを返すから
drawersの中の先にあるdrawerのvbidを差すようになる。
それのインスタンスを積む際にはそのvbidのインスタンスデータのみが積まれる。

ctx.fill(true, true, 0, joint_name, poly, mp);
これは実体は
dgf_poly_joint_internal(vptrs[0], joint_name, poly, mp);
なので、make_vertex_setの第一引数の最初のdrawerの

次: ssubtype違いのシェーダ用に頂点データは完全に同一のものを用意
しなければならない
opt1のインスタンスデータを描画するときにはopt0の頂点データを読むようにする。

---------------------------------------------------------------------------
重ね合わせ案1

大きいオブジェクトについては順序が変わっても描画結果はからわらないが、
なるべく近い順に描くほうがfs無駄打ちが少なくなり効率的。
デプステスト無効でよい。
画面サイズの共有テクスチャを二つ作る。GL_R32Fでよいか。
detail_depth_wrとdetail_depth_rd。1.0fで塗りつぶす。
大きなオブジェクトについて、
  detail_depth_rdはbindしてシェーダに渡す。
  detail_depth_wrはフレームバッファを作り出力として使う。
  fsの中では、まずraycast始点でのdepth値を計算し、detail_depth_rdを読んだ
  値より大きければ必ず不可視なのでdiscardする。
  raycastし、その結果detail_depth_rdより大きければdiscard。
  そうでなければ色を塗り、detail_depth_wrにもdepth値を書き込む。
  detail_depth_rdはdetail_depth_wrからコピー。
  繰り返し。
残りのオブジェクトについては、detail_depth_wrに書き込まない以外は同じ動作。

---------------------------------------------------------------------------
重ね合わせ案2

ほぼ案1と同じだが、detail_depth_wrのかわりに普通のデプスバッファを使い、
fsではgl_FragDepthを書き込む。一つの大きなオブジェクトを書き終わると
デプスバッファをdetail_depth_rdにコピー。
glCopyTexSubImage2Dでコピーできる。
デプステストは無効でよく、かわりにfsで、raycast前後に1回ずつdetail_depth_rd
と比較する。
(あるいはdetail_depth_rdにコピーせず、デプスバッファをそのままbindして
draw毎にglTextureBarrierする。gl4.5以上。同一のtexelに一回だけ
read-modify-writeできる。)

ssubtype = 5くらいから2まで。大きなオブジェクトをひとつづつ描画。
ssubtype = 1。残りの大きなオブジェクトを描画。
ssubtype = 0。デプステストはenable。depth_rdのデプステストはしない。
  FragDepthも書き込まない。

depth値の計算
  posは接線空間の座標
  vec4 gpos = vary_model_matrix * vec4(pos, 1.0);
  vec4 vpos = view_projection_matrix * gpos;
  float depth = (vpos.z / vpos.w + 1.0) * 0.5;
  gl_FragDepth = clamp(depth, 0.0, 1.0);

次
- 描画前にdepth_rdへコピー(done)
- fsでdepth_rdを読んでデプステスト(done)
- 距離に応じてssubtypeの違うdrawerへ移動


---------------------------------------------------------------------------
drawer移動

描画順序決め。
1. 各インスタンスのmodel matrixから位置だけを取り出す。
2. カメラの逆行列で変換、相対位置を求める。
3. vbid,vsidの頂点データの最大半径を求める。(事前計算)
4. 相対位置と半径から、視錐台カリング(円錐で近似)
5. 残ったオブジェクトをzの小さい順にソート

視錐台に外接する円錐と点の距離
半画角のtangentはr/d where r=farの四隅の点の中心からの距離, d=farの距離
  haov_tan = r/d
オブジェクトのカメラからの相対位置をA=(ax,ay,az)とする
Aをxy平面上で回転させてy=0に下ろした点B=(bx,by,bz)
  bx = sqrt(ax^2 + ay^2);
  by = 0;
  bz = az;
原点(カメラ位置)を頂点としz軸を中心にする円錐が、y=0に接する直線のうち、
z>=0, x>=0の部分の半直線について、Bとの距離を計算する。
(すべてy=0上なので2次元で計算できる)
半直線の単位ベクトルdv
  dv = (haov_tan, 0, 1 - sqrt(haov_tan)) // まちがい
adv = dot(dv, A)
これが負のときは半直線とBの距離はlength(B)
これが正のときの半直線とBの距離はlength(B - dv * adv)
もしこの距離がオブジェクトの半径より大きいならオブジェクトは不可視。
(ただし円錐の内側であれば可視)
可視なオブジェクトを、z位置の小さい順にソートする。

pglshader
        const vert_vbid = pgs.drawer_vertices_vbids[i];
        const inst_vbid = pgs.drawer_instances_vbids[i];
        pd->draw(draw_step_solid, 0,
          *bos[vert_vbid],
          whole_instances[inst_vbid], pgs.agg_ibuffer,
          vert_vbid, pgs.glc, cam_df, smtex_arr);
このvert_vbidを引数に渡しているのは正しいのか？

  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vbid_t vbid,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (!has_instance_to_draw(bo, bo_ib, vbid)) {
      return; これではじかれるのでは。
    }
    ...
    aibuf.draw(sdr, bo, bo_ib, vbid, glc.enable_instanced,
      glc.enable_uniform_instancing);
  } 

public function void
aggregated_ibuffer_draw(aggregated_ibuffer const& aibuf,
  glshader_i mutable& sdr, vertex_buffer const& bo,
  bo_instances_type const& bo_ib, vbid_t vbid,
  bool enable_instanced, bool enable_uniform_instancing)
{
vbidは使われていない
        bo.draw_elems_instanced(vsid,
          arr.size() / sdr.instance_attrib_num_float());
}

public function void
vertex_buffer_draw_elems_instanced(vertex_buffer const& bo, vsid_t vsid,
  size_t num_instance)
{
このvsidは頂点データのvsidを期待している
vbidは使われていない
      const& be = *bo.get_by_id(vsid);
}

---------------------------------------------------------------------------
色データ


w: node_type
  0: 空白
  1: タイルパターン参照
  2-159: 楕円体で切断
  160-254: 平面で切断
  255: 壁
xyz: 
  平面のとき: xyz上位16bitが平面の法線abc。node_type-208がd
  楕円体のとき: xyz上位2bitが拡大率、下位6bitが中心の位置。

raycastの結果、衝突したらsec(aux)を読む。

aux_xyz: 色
aux_w:
  上位2bit: 1ならemission, 2なら金属、3か0なら非金属
  下位6bit: roughness

必要なデータ
- 色rgb
- roughness
- emission
- ローカルライトdiffuseの情報

---------------------------------------------------------------------------
色データedit_mode

texture_edit_viewにinteractiveフラグを付ける。これがfalseなら、カーソル表示
は無効になり、メソッド呼び出しでテクスチャ更新する機能だけが使えるようになり、
viewのテクスチャは保持せずeditテクスチャを直接GPUにコピーするようになる。

editとviewでそれぞれ tpat,tpax,tmap,tmaxとそれらのmipmapを持つ。
それぞれedit_mode_textureを保持すればよい。

texture_editは変更されるとrecalc_distance_rangeが呼ばれる。
これをmipmap更新とそれらのdistance再計算も実行するように変更する。

texture_edit_viewはeditが変更されるとmerge_edit_viewが呼ばれる。
これをmipmapもマージするように変更する。
カーソルが移動するとset_cursor_posが呼ばれる。
これをmipmapも反映するように変更する。

移行手順:
- mipmap levelを固定できるようにシェーダを変更
- edit_modeのtexture_editとtexture_edit_viewをmipmap保持するように変更

パターンを変更するとマップのmipmapを大量に更新する必要がある。
この場合のmipmap更新はリアルタイムでなくてもよいか？
マップの変更によるmipmap更新はリアルタイム更新する処理は作っておく。

---------------------------------------------------------------------------
edit_modeのhole

texture_edit_view::set_cursor_pos()
カーソルよりzが大きいボクセルを空白にする処理。
if (prev_z > next_z) {
  zが小さくなったので空白を広げる。
  next_z+1以上prev_z+15以下の範囲をクリアする。
} else if (prev_z < next_z) {
  zが大きくなったので描き戻す。
  prev_z+1以上next_z以下の範囲を描き戻す。
  next_z+1以上next_z+15以下の範囲は距離を更新。
}

---------------------------------------------------------------------------
edit_mode操作

常時有効
  F12: 状態セーブ
  Slash: 通常モードとパラメータ変更モード巡回

通常モード
  HLJKNP: xyz軸カーソル移動
  Minus: 空白にする
  Backslash: ボクセルのフィル種別を変更する
  At: パターン編集とマップ編集の切り替え
  I: 領域選択On/Off
  C: コピー
  V: ペースト

パラメータ変更モード(平面)
  HLJKNP: 法線xyz変更
  Comma,Period: 距離変更

パラメータ変更モード(曲面1)
  HLJKNP: 球の中心移動
  Comma,Period: 距離変更

パラメータ変更モード(曲面2)
  HLJKNP: 球の拡大率変更

---------------------------------------------------------------------------
edit_modeカーソル移動

カーソルがテクスチャ座標で移動したときにグローバルでの移動量を計算

テクスチャ座標posをグローバル座標に変換
    vec3 ini_tngpos = vary_aabb_or_tconv.xyz + pos * vary_aabb_or_tconv.w;
      // ini_tngposはposを接空間座標に変換したもの
    vec4 ini_gpos = vary_model_matrix * vec4(ini_tngpos, 1.0);
      // グローバル座標に変換。
ここでvary_model_matrixは接空間からグローバルへの変換。
    <%vert_in/> vec3 position;
      // stype==1のときオブエジェクト座標系での接線空間の原点
    <%vert_in/> vec3 normal;   // オブジェクト座標系での法線(接線空間のz軸)
    <%vert_in/> vec3 tangent;  // オブジェクト座標系での接線(接線空間のx軸)
    <%vert_in/> vec4 aabb_or_tconv;
      // stype==1のときテクスチャ座標から接線空間への変換
    vec3 binormal = cross(normal, tangent);
      // オブジェクト座標系での接線空間のy軸
    mat4 mm = <%instance_attr model_matrix/>;
    mat4 tan_to_obj = mat4(
      vec4(tangent, 0.0),
      vec4(binormal, 0.0),
      vec4(normal, 0.0),
      vec4(position, 1.0)); // 接線空間からオブジェクト座標系への変換
    mm = mm * tan_to_obj; // 接線空間からワールド座標への変換
    vary_model_matrix = mm; // 接線空間からワールドへの変換

	aabb_max	{x,1.0000000,y,1.0000000,z,0.0312500}
	aabb_min	{x,0.0000000,y,0.0000000,z,0.0000000}
	aabb_or_tconv	{w,63.9993820,x,-0.0000000,y,-0.0000000,z,-0.0000000}
	normal		{x,0.0000000,y,0.0000000,z,-1.0000000}
	position	{x,-31.9996910,y,-31.9996910,z,0.0000000}
	tangent		{x,-0.0000000,y,1.0000000,z,0.0000000}
	uvw		{x,0.0000000,y,0.0000000,z,0.0312500}

---------------------------------------------------------------------------
コピペ範囲

コピーした時点のコピー領域内のカーソルオフセットを取っておく。(copy_cur)
ペースト時
  ペースト先の領域の決定
    最小: mi_0 = cursor_pos - copy_cur
    最大: mx_0 = cursor_pos - copy_cur + copy_size - 1
    これをクリップする。
    mi = clip(mi_0)
    mx = clip(mx_0)
  コピーデータ内の最小最大
    cd_mi = mi - mi_0
    cd_mx = cd_mi + (mx - mi)

---------------------------------------------------------------------------
色パラメータ

A値に入れる情報
  emission 1bit
  metalness 1bit
  未使用 2bit
  roughness 4bit

タイルがreferenceだったときのaux値に色々入れられる。
- ローカルライト
- テクスチャマッピング


---------------------------------------------------------------------------
拡大

sphereのscaleの各成分が0か2でないと拡大できないのでは

  p.dist = p.dist * 2;
  cv = make_plane_node(p, make_ivec3(
              x * 2 - 1,
              y * 2 - 1,
              z * 2 - 1),
              1);
  offsetは-1から1、offset_mulは1
  const int d = p.dist;
  const d1 = d - dot_int(nor, offset) * offset_mul;
  // 拡大処理
  // distを2倍する。
  // dist -= dot_int(nor, offset)する。

  p.dist = p.dist * 2;
  p.center = p.center * 2;
  cv = make_sphere_node(p, make_ivec3(
              x * 2 - 1,
              y * 2 - 1,
              z * 2 - 1),
              1);
  const c = p.center -
    map{ivec3, operator::mul}(offset, p.scale) * offset_mul / 2;
  // 拡大処理
  // distとcenterを2倍する
  // center -= offset * p.scale / 2 する

r2 = 球の半径の2乗(*4)
d2 = 球の中心とボクセル中心の距離の2乗(*4)
rdiff = sqrt(d2) - sqrt(r2) 球の表面からの距離(*2)
nd = sqrt(dot(pp.nor, pp.nor)) a^2+b^2+c^2の平方根
pp.dist = rdiff * nd / 2 

dist 5 -1, 3, -2の位置が欠ける
sphere_node     {center,{x,0,y,0,z,0},dist,6,scale,{x,2,y,2,z,2}}       offset  {x,1,y,3,z,2}   2       c       {x,-2,y,-6,z,-4}        rdiff   2.9666295470957653      inor    {x,-4,y,-12,z,-8}       pp      {dist,6,nor,{x,-1,y,-3,z,-2}}   r       0
distが5でないといけない

0.45: 6, 10, 14, 
0.4: 10, 14, 

0.4, r=10
(1,3,3)
(4,3,3)
r=14
(3,4,6)

miplevel0 16
miplevel1 8
miplevel2 4
miplevel3 2
miplevel4 1

---------------------------------------------------------------------------
nvidiaバグ

raycast_waffle()で起きていた。

次の関数で再現
int foo()
{
  float x = 1.0;
  for (int i = 0; i < 0; ++i) { }
  if (x < 3.0) {
    return 1;
  }
  return -1;
}

---------------------------------------------------------------------------
3dテクスチャ衝突判定

大きなオブジェクトは物理エンジンの処理対象にはしない。
全オブジェクト衝突判定の対象には含める。
衝突判定のbroadphaseで大きなオブジェクトに接触しているオブジェクトを探し、
相対速度などから力を計算して適用する。


---------------------------------------------------------------------------

instantiate_cur_scene()の中でそのシーンのシーンノードをもとにcollision
objectを作成している。
sco.add_collision_object(r);
これの中ではそのjoint_idに対応するshapeがadd_collision_shape_one()で登録され
ていればそれをもとにmake_rigid_body()する。
それをそのままdworld.add_rigid_body(rb)する。
add_rigid_bodyはmassが負の時はbtのdynamicsWorldに登録しない。
massを負にしておくと、物理エンジンは使わないが衝突判定(grid_rbinfo_array)は
有効になる。


swarmと物体との衝突判定はgrid_bp_thread_object::__call()の中で実行している。
colshape->has_near_collision()のときにnear_collisionメソッドを呼ぶ。
pg3d/physics/collision_shape.pxでnear_collisionを実装すればよい。

swarmではない物体とraycastオブジェクトとの衝突判定は、grid_bp_thread_object
の__callに追加する必要がある。

手順
1. collision_shapeにraycastオブジェクトの衝突判定を追加
  1-1. 小物体の相対位置をオブジェクト座標から接線空間に変換
  1-2. テクスチャを読んで衝突判定
2. grid_bp_thread_objectの__callに大物体と小物体の衝突を追加

---------------------------------------------------------------------------
ループ

async_motion_threadが有効なら、mainloopのコンストラクタで
motion threadをforkする。

fundamental::mainloopがmainloopのstepを繰り返し呼ぶ。
mainloopのstep_internalの処理:
1. SDL_PollEventで全てのイベントを拾う。on_event()を呼ぶ。
2. joystickの入力を更新。
3. motionの処理
  3-1. async_motion_threadが有効なら、
  3-1-1. thr->finish()を呼ぶ
  3-1-2. whole_instancesをswapする(thrから受け取る)。カメラなど渡す。
  3-1-3. thr->start()を呼ぶ
  3-2. async_motion_threadが有効でないないなら、
  3-2-1. カメラなどを渡す
  3-2-2. thr->start()、thr->finish()を呼ぶ
  3-2-3. whole_instancesを受け取る
4. do_commands()
5. frame_begin(), 描画, swapwindow, frame_end()

async_motion_threadをtrueにすると多少改善するのでtrueにしておく。
ただしinput lagは大きくなる。

---------------------------------------------------------------------------
raycast_sort

raycast_sort有効のときは
  ssubtype==0のシェーダは描画しない(何故？)
  ssubtype==1は小さいオブジェクト用、2以上は大きいオブジェクト用で
  ssubtypeが大きい順に描画しdepth_rdを更新する

update_frag_depthも1にする必要がある。
有効にするにはenable_raycast_zprepassも1にする必要があるのはなぜ？
  -> 必要なくした
大きなraycastオブジェクトを手前から順に描画、描かれたピクセルはdepth値を
書き込む。次に描かれるオブジェクトはdepth値を自分の最小depth値と比較し、
上塗りする可能性がないならdiscardする。

10枚重ねたシーン。
無効だと最低150fps, 有効だと最低180fpsくらい。20170408 FullHD, miplevel=-1

FIXME: spawnされた小さいraycastオブジェクトが見えない。(done)

prepare_oneで小さいオブジェクトはftable[]()してインスタンス出力している。
  idta = whole_instances[vbid][vsid];
  ftable[vbid](sn, ncd, idata);
  on_motion_step -> scene_cotrol_step -> step_snobj_dynamics -> step_obj
    -> prepare_one
  prepare_one
on_motion_stepでscene_control_stepの次にrobjs.prepare_instancesしている。

---------------------------------------------------------------------------
drawer間共有データの整理

textures_ptr textures
  これはprepare_triangles_texture_dataで作る
tptr{tiled_voxel_texture} tvt
  これはprepare_triangles_texture_dataで作る
resource_pool_ptr res
  これはon_init_drawersにわたってくる
option{ptr{edit_mode_texture}} emt_shared
  drawer::trianglesが埋める


---------------------------------------------------------------------------
edit_mode衝突更新

edit_mode編集有効でなくてもedit_modeを作るようにする

---------------------------------------------------------------------------

make_plane_range(texture_data mutable& tex, uvec3 pos, ivec3 sz, uint para);
paraは0なら軸並行でない、1,2,3なら法線のx,y,z成分を0に。


---------------------------------------------------------------------------
マップ: バンプ生成の手順



---------------------------------------------------------------------------
タイルパターン

- ほぼfilledなタイル
  filledを置き換えるためのタイル。すべての面に多少の凹パターンをつける。
- 表面に張り付ける凸タイル
  特定の面がfilledに隣接するときに使うパターン。その面に多少の凸パターン
  をつける。

---------------------------------------------------------------------------
タイルパターン内訳と割り当て量

可能な最大サイズ voxtpat_size_l2 = (6, 6, 5)
2^17 = 128k個
タイル一個あたり16*16*16*8=32kbyte 4+4+4+3=15bit
2^32 = 4gbyte
VRAMが8GBならこれが限界
全体にランダムアクセスしてしまうと追いつかないのでtmapの近い座標には近いtpat
しか使わないように配置する。TODO: ブロックの単位を決める。
仮にブロックの単位 2^(4, 4, 3) 16*16*8=2048個 とする。
2^(2, 2, 2)分割、4*4*4=64のブロックに分割。
2048個の内訳。
- 一つの面を薄く埋め、その上に凸パターン。表面に張り付け用。256個
- 一つの面を薄く部分的に埋めてパターンを描くための部品。256個
- ほぼfilled。filledを置き換えて肉にする。256個。
- ほぼfilled、1辺面取り。32個。いらない？
- ほぼfilled、3辺面取り。32個。いらない？
- 軸並行斜面、傾き1から7まで
  - 傾き1 8個 計8個
  - 傾き2 8個 計16個
  - 傾き3 8個 計24個
  - 傾き4 8個 計32個
  - 傾き5 8個 計40個
  - 傾き6 8個 計48個
  - 傾き7 8個 計56個
  - 合計224個
- 合計 992個 + 64個いらない？


