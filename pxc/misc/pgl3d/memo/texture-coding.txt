
primary 32bit rgba
  value = texelFetch(sampler_voxtmap)
  node_type = int(value.a)
  node_type == 1 (タイル参照)ならtpatを引く
    tpat_sgn := value.rgbの上から2番目のbit。0なら正。
    tpat_rot := value.rgbの最上位bit
      rayの座標からテクスチャの座標を得るのにはsgnを適用後以下を順に適用
        1. .xが真ならxyいれかえ
        2. .yが真ならyzいれかえ
        3. .zが真ならzxいれかえ
    curpos_tp := value.rgbの下6bit
    tpat_coord := tpat_sgn_rotate_tile(...)で計算
    value = texelFetch(sampler_voxtpat, tpat_coord)
    node_type = int(value.a)
  node_type == 0 空白
    distval = value.xyzの何か。空白距離をエンコードしている。
  node_type == 255 壁
    value.rgbは未使用
  node_type >= 160 && node_type <= 254 平面切断
    param_d = node_type - 208 (-48, +46)
    param_abc = distvalの上位4bit - 8
    distvalの下位4bitは未使用
  node_type >= 2 && node_type <= 159 球面切断
    sp_scale = distvalの上位2bit
    sp_center = distvalの下位6bit
    sp_radius = node_type - 1 (1以上)
      ただしnode_type - 1 > 64のとき裏返し
      sp_radius = node_type - 65

  

secondary 32bit rgba
  aval := tex_val.a
    aval_me := avalの上位2bit
      aval_me == 0: 非金属
        mate_diffuse = tex_val.rgb
      aval_me == 1: emissionあり
        mate_emit = tex_val.rgb
      aval_me == 2: 金属
        mate_specular = tex_val.rgb
      aval_me == 3: 金属、emissionあり
      既定値
        mate_specular = vec3(0.04)
        mate_diffuse = vec3(0.0)
        mate_emit = vec3(0.0)


raycast_tilemap()
  raycastのジオメトリはsampler_voxtmap, sampler_voxtpatを読む。
  衝突したときにsampler_voxtmax, sampler_voxtpaxを読む。
    value_r = texelFetch(sampler_voxtmax)
    value_r = texelFetch(sampler_voxtpax)
  voxtmax, voxtpaxのテクスチャデータはそれぞれtmap_secとtpat_sec

