public threaded namespace glgeometry "use-unsafe";
public import common -;
public import exception -;
public import meta m;
public import glm -;
public import numeric::fpmath -;
public import operator op;
public import wfobj -;

private import glconf -;
private import glvertex -;

public metafunction modifier_t callable_ptr{darray{vertex_attr}, {poly_t}};

public tsvaluetype struct
vertex_attr()
{
  public vec3 pos;
  public vec3 nor;
  public vec3 tan;
  public vec3 uvw;
}

public tsvaluetype struct particle_vertex_attr {
  public vec3 pos;
}

public tsvaluetype struct particle_bb_vertex_attr {
  public vec3 pos;
  public vec2 lpos;
}

/* implicit conversion from vec3 to vertex_attr */
public function {tto, tfrom} vertex_attr
tvec3___to(vec3 const& x)
{
  vertex_attr r;
  r.pos = x;
  return r;
}

public metafunction poly_t cslice{vertex_attr};
public metafunction gf_poly callable_ptr{void, {poly_t, mesh_index}};
public metafunction to_gf_poly{f}
  make_callable_ptr{f, m::sub{m::size{m::args{f}}, 2}};

public metafunction rand_generator_ptr ptr{rand_generator};
public metafunction make_rand_generator make_ptr{rand_generator};

public tsvaluetype struct
rand_generator(uint seed0)
{
  private uint seed = seed0;
  public function uint generate() {
    uint rv = seed;
    seed = seed * 1664525U + 1013904223U;
    return rv;
  }
  public function float generate_float() {
    return cast_float(generate()) / 4294967296.0;
  }
}

public metafunction regular_polygon to_gf_poly{gf_regular_polygon};
public metafunction bump_rec to_gf_poly{gf_bump_rec};
public metafunction rand_bump to_gf_poly{gf_rand_bump};
public metafunction poly_joint{tattr} to_gf_poly{gf_poly_joint{tattr}};
public metafunction point_joint{tattr} to_gf_poly{gf_point_joint{tattr}};
public metafunction fill{tattr} to_gf_poly{gf_fill{tattr}};
public metafunction fill_smooth{tattr} to_gf_poly{gf_fill_smooth{tattr}};
public metafunction lid to_gf_poly{gf_lid};
public metafunction hole to_gf_poly{gf_hole};
public metafunction sphere to_gf_poly{gf_sphere};
public metafunction rectangle_split to_gf_poly{gf_rectangle_split};
public metafunction rotate_local to_gf_poly{gf_rotate_local};
public metafunction bump_apply to_gf_poly{gf_bump_apply};
public metafunction particle to_gf_poly{gf_particle};
public metafunction particle_bb to_gf_poly{gf_particle_bb};
public metafunction rand_sphere to_gf_poly{gf_rand_sphere};
public metafunction import_wfobj to_gf_poly{gf_import_wfobj};

public threaded function {t} float cast_float(t x)
{ return static_cast{float, t}(x); }
public threaded function {t} uint cast_uint(t x)
{ return static_cast{uint, t}(x); }
public threaded function {t} int cast_int(t x)
{ return static_cast{int, t}(x); }

public tsvaluetype struct mesh_index {
  public size_t x;
  public size_t y;
  public size_t z;
  public size_t w;
}

public threaded function float pi_float()
{
  return 3.1415926535897932384626433832795;
}

public threaded function {t} void polygon_scale(t mutable& poly, float scale)
{
  const c = polygon_center(poly);
  for (const i, mutable& p: poly) {
    p.pos = c + ((p.pos - c) * scale);
  }
}

public threaded function vec3 polygon_center(poly_t const& poly)
{
  vec3 mutable c;
  for (const i, const& p: poly) {
    c += p.pos;
  }
  c /= cast_float(poly.size());
  return c;
}

public threaded function float polygon_radius(poly_t const& poly)
{
  const c = polygon_center(poly);
  float mutable r = 0.0;
  for (const i, const& p: poly) {
    r = max(r, length(p.pos- c));
  }
  return r;
}

/* private */

private threaded function vec3 poly_cross_at(poly_t const& poly, size_t i)
{
  const sz = poly.size();
  const i1 = (i + 1) >= sz ? (i + 1 - sz) : (i + 1);
  const i2 = (i + 2) >= sz ? (i + 2 - sz) : (i + 2);
  return cross(poly[i1].pos - poly[i].pos, poly[i2].pos - poly[i1].pos);
}

private threaded function vec3 normal_scale_from_poly(poly_t const& poly)
{
  const sz = poly.size();
  if (sz < 3) { return vec3(); }
  if (sz == 3) {
    return cross(poly[1].pos - poly[0].pos, poly[2].pos - poly[1].pos) * 3.0f;
  } else {
    vec3 v;
    for (const i: 0 .. sz) {
      v += poly_cross_at(poly, i);
    }
    return v;
  }
}

private threaded function vec3 normal_from_poly(poly_t const& poly)
{
  return normal_scale_from_poly(poly).normalize();
}

private threaded function void gf_regular_polygon(float radius, size_t n,
  gf_poly const& c0, gf_poly const& c1, poly_t const& poly,
  mesh_index const& mp)
{
  /* poly is ignored */
  mutable arr = darray{vertex_attr}(n, vertex_attr());
  for (const i: 0 .. n) {
    const a = (cast_float(i) * 2.0f * pi_float()) / cast_float(n);
    arr[i].pos.x = sin(a) * radius;
    arr[i].pos.y = -cos(a) * radius;
    arr[i].pos.z = 0.0f;
  }
  c0(arr, mesh_index());
  reverse(arr.range());
  c1(arr, mesh_index());
}

private threaded function void gf_polygon_points(poly_t const& pts, 
  gf_poly const& c0, gf_poly const& c1, poly_t const& poly,
  mesh_index const& mp)
{
  /* poly is ignored */
  darrayst{vertex_attr} arr = pts;
  c0(arr, mesh_index());
  reverse(arr.range());
  c1(arr, mesh_index());
}

private threaded function void gf_bump_modifier(modifier_t const& mo,
  gf_poly const& c0, gf_poly const& c1, poly_t const& poly,
  mesh_index const& mp)
{
  darray{vertex_attr} front = mo(poly);
  if (front.size() < 3) { return; }
  /* front */
  c1(front, mesh_index());
  /* side */
  const sz = front.size();
  for (const i: 0 .. sz) {
    const i1 = i + 1 != sz ? i + 1 : 0;
    const side = make_farray{vertex_attr}(poly[i], poly[i1], front[i1],
      front[i]);
    c0(side, mesh_index());
  }
}

private threaded function void gf_bump_rec(float z, float scale, int recurse,
  gf_poly const& c0, gf_poly const& c1, poly_t const& poly,
  mesh_index const& mp)
{
  if (poly.size() < 3) { return; }
  darrayst{vertex_attr} front = poly;
  const nor = normal_scale_from_poly(poly) / static_cast{float}(poly.size());
  for (const i, mutable& e: front) {
    e.pos += nor * z;
  }
  polygon_scale(front, scale);
  /* front */
  if (recurse > 1) {
    gf_bump_rec(z, scale, recurse - 1, c0, c1, front, mesh_index());
  } else {
    c1(front, mesh_index());
  }
  /* side */
  const sz = front.size();
  for (const i: 0 .. sz) {
    const i1 = i + 1 != sz ? i + 1 : 0;
    const side = make_farray{vertex_attr}(poly[i], poly[i1], front[i1],
      front[i]);
    c0(side, mesh_index());
  }
}

private threaded function void gf_rand_bump(size_t num, float scale,
  float xmin, float xmax, float ymin, float ymax, float zmin, float zmax,
  rand_generator_ptr const& rnd, gf_poly const& c0, gf_poly const& c1,
  gf_poly const& c2, poly_t const& poly, mesh_index const& mp)
{
  if (poly.size() != 4) { return; }
  darrayst{vertex_attr} front = poly;
  /* bumps */
  polygon_scale(front, scale);
  for (const i: 0 .. num) {
    const xsz = xmin + (xmax - xmin) * rnd->generate_float();
    const ysz = ymin + (ymax - ymin) * rnd->generate_float();
    const zsz = zmin + (zmax - zmin) * rnd->generate_float();
    const xp = (1.0f - xsz) * rnd->generate_float();
    const yp = (1.0f - ysz) * rnd->generate_float();
    threaded function vec3 pos(vec3 const& vec, float x, float xmax)
    {
      return vec * x / xmax;
    }
    const s0 = poly[0].pos + (poly[1].pos - poly[0].pos) * xp;
    const s1 = poly[0].pos + (poly[1].pos - poly[0].pos) * (xp + xsz);
    const s2 = poly[3].pos + (poly[2].pos - poly[3].pos) * (xp + xsz);
    const s3 = poly[3].pos + (poly[2].pos - poly[3].pos) * xp;
    const t0 = s0 + (s3 - s0) * yp;
    const t1 = s1 + (s2 - s1) * yp;
    const t2 = s1 + (s2 - s1) * (yp + ysz);
    const t3 = s0 + (s3 - s0) * (yp + ysz);
    const poly1 = make_farray{vertex_attr}(t0, t1, t2, t3);
    gf_bump_rec(zsz, 1.0, 1, c0, c1, poly1, mp);
  }
  /* front */
  c2(poly, mesh_index());
}

public threaded function mat4
poly_trans(poly_t const& poly)
{
  vec3 ex;
  vec3 ey;
  vec3 ez;
  if (poly.size() >= 3) {
    ex = (poly[1].pos - poly[0].pos).normalize();
    ez = normal_from_poly(poly);
  } else {
    ex = make_vec3(1.0, 0.0, 0.0);
    ez = make_vec3(0.0, 1.0, 0.0);
  }
  ey = cross(ez, ex);
  const c = polygon_center(poly);
  return make_mat4(
    ex.x, ex.y, ex.z,  0.0, 
    ey.x, ey.y, ey.z,  0.0,
    ez.x, ez.y, ez.z,  0.0,
     c.x,  c.y,  c.z,  1.0);  
}

private threaded function {tattr} void
gf_poly_joint(ptr{vertices} const& vptr, string const& joint_name,
  gf_poly const& c0, poly_t const& poly, mesh_index const& mp)
{
  /* calculates normal/tangent from poly */
  if (poly.size() < 1) { return; }
  node_joint e;
  e.trans = poly_trans(poly);
  e.joint_name = joint_name;
  vptr->push_joint(e);
  c0(poly, mesh_index());
}

private threaded function {tattr} void
gf_point_joint(ptr{vertices} const& vptr, string const& joint_name,
  gf_poly const& c0, poly_t const& poly, mesh_index const& mp)
{
  if (poly.size() < 1) { return; }
  const p = poly[0].pos;
  const ex = poly[0].nor.normalize();
  const ey = poly[0].tan.normalize();
  const ez = cross(ex, ey);
  node_joint e;
  e.trans = make_mat4(
    ex.x, ex.y, ex.z,  0.0, 
    ey.x, ey.y, ey.z,  0.0,
    ez.x, ez.y, ez.z,  0.0,
     p.x,  p.y,  p.z,  1.0);  
  e.joint_name = joint_name;
  vptr->push_joint(e);
  c0(poly, mesh_index());
}

private threaded function void
gf_particle(ptr{vertices} const& vptr, poly_t const& poly,
  mesh_index const& mp)
{
  for (const i, const& p: poly) {
    particle_vertex_attr x;
    x.pos = p.pos;
    vptr->push_point{particle_vertex_attr}(x);
  }
}

private threaded function void
gf_particle_bb(ptr{vertices} const& vptr, poly_t const& poly,
  mesh_index const& mp)
{
  for (const i, const& p: poly) {
    farray{particle_bb_vertex_attr, 4} vtxs;
    for (const j, mutable& v: vtxs) {
      v.pos = p.pos;
    }
    vtxs[0].lpos = make_vec2(-1.0, -1.0);
    vtxs[1].lpos = make_vec2( 1.0, -1.0);
    vtxs[2].lpos = make_vec2( 1.0,  1.0);
    vtxs[3].lpos = make_vec2(-1.0,  1.0);
    vptr->push_polygon_distinct{particle_bb_vertex_attr, 0}(vtxs);
  }
}

private threaded function vec3 generate_rand_sphere(
  rand_generator_ptr const& rnd, bool surface_flag, float radius)
{
  vec3 r;
  while (true) {
    const x = rnd->generate_float() * 2.0f - 1.0f;
    const y = rnd->generate_float() * 2.0f - 1.0f;
    const z = rnd->generate_float() * 2.0f - 1.0f;
    const d = x * x + y * y + z * z;
    if (d > 1.0f) {
      continue;
    }
    if (surface_flag) {
      if (d < 0.001f) {
	continue;
      }
      const m = radius / sqrt(d);
      r = make_vec3(x * m, y * m, z * m);
    } else {
      r = make_vec3(x * radius, y * radius, z * radius);
    }
    break;
  }
  return r;
}

private threaded function quat generate_rand_quat(rand_generator_ptr const& rnd)
{
  const x = rnd->generate_float();
  const y = rnd->generate_float();
  const z = rnd->generate_float();
  const pi2 = pi_float() * 2.0f;
  const xq0 = sqrt(1.0f - x);
  const xq1 = sqrt(x);
  return make_quat_wxyz(
    xq0 * sin(y * pi2),
    xq0 * cos(y * pi2),
    xq1 * sin(z * pi2),
    xq1 * cos(z * pi2));
}

private threaded function void gf_rand_sphere(float radius, size_t n,
  bool surface_flag, bool rotate_flag, rand_generator_ptr const& rnd,
  gf_poly const& c0, poly_t const& poly, mesh_index const& mp)
{
  /* poly is ignored */
  farray{vertex_attr, 1} arr;
  size_t i;
  while (i < n) {
    arr[0].pos = generate_rand_sphere(rnd, surface_flag, radius);
    if (rotate_flag) {
      const m = generate_rand_quat(rnd).to_mat3();
      arr[0].nor = m * make_vec3(1.0, 0.0, 0.0);
      arr[0].tan = m * make_vec3(0.0, 1.0, 0.0);
    }
    c0(arr, mesh_index());
    ++i;
  }
}

private threaded function {tattr} void
gf_fill_internal(ptr{vertices} const& vptr, bool flat_flag,
  poly_t const& poly, mesh_index const& mp)
{
  const sz = poly.size();
  if (sz < 3) { return; }
  vec3 mutable nor;
  vec3 mutable tang;
  if (flat_flag) {
    nor = normal_from_poly(poly);
    tang = (poly[1].pos - poly[0].pos).normalize();
  }
  mutable vtxs = darrayst{tattr}(sz, tattr());
  for (const i: 0 .. sz) {
    mutable& v = vtxs[i];
    v.position = poly[i].pos;
    if (flat_flag) {
      v.normal = nor;
      v.tangent = make_vec3(tang.x, tang.y, tang.z);
    } else {
      v.normal = poly[i].nor;
      v.tangent = poly[i].tan;
    }
    v.uvw = vec3();
    /* sdllog("fill", v); */
  }
  if (sz == 4) {
    const c0 = (poly[0].pos + poly[1].pos);
    const c1 = (poly[1].pos + poly[2].pos);
    const c2 = (poly[2].pos + poly[3].pos);
    const c3 = (poly[3].pos + poly[0].pos);
    const c02 = c2 - c0;
    const c13 = c3 - c1;
    if (fabs(dot(c02, c13)) < length(c02) * length(c13) * 0.05)
    {
      /* 01, 23 */
      const v01 = poly[1].pos - poly[0].pos;
      const v23 = poly[3].pos - poly[2].pos;
      const dotv0123 = dot(v01, -v23);
      const lenv01 = length(v01);
      const lenv23 = length(v23);
      const cosv0123 = dotv0123 / (lenv01 * lenv23);
      const ratv2301 = lenv23 / lenv01;
      /* 12, 30 */
      const v12 = poly[2].pos - poly[1].pos;
      const v30 = poly[0].pos - poly[3].pos;
      const dotv1230 = dot(v12, -v30);
      const lenv12 = length(v12);
      const lenv30 = length(v30);
      const cosv1230 = dotv1230 / (lenv12 * lenv30);
      const ratv3012 = lenv30 / lenv12;
      /* */
      const lenv0123 = lenv01 + lenv23;
      const lenv1230 = lenv12 + lenv30;
      mutable co = make_vec2(32.0f, 32.0f);
      co.x = max(4.0f, min(128.0f, floor(lenv0123)));
      co.y = max(4.0f, min(128.0f, floor(lenv1230)));
      /*
      if (lenv0123 > lenv1230) {
	co.y = min(floor(lenv0123 * 4.0f / lenv1230), 128.0f);
      } else {
	co.x = min(floor(lenv1230 * 4.0f / lenv0123), 128.0f);
      }
      */
      if (cosv0123 > cosv1230) {
	if (ratv2301 > 0.25 && ratv2301 < 4.0 && cosv0123 > 0.95f) {
	  vtxs[0].uvw = make_vec3(0.0f, 0.0f, 1.0f);
	  vtxs[1].uvw = make_vec3(co.x, 0.0f, 1.0f);
	  vtxs[2].uvw = make_vec3(co.x, co.y, 1.0f);
	  vtxs[3].uvw = make_vec3(0.0f, co.y, 1.0f);
	  if (ratv2301 > 1.0f) {
	    vtxs[2].uvw *= ratv2301;
	    vtxs[3].uvw *= ratv2301;
	  } else if (ratv2301 < 1.0f) {
	    vtxs[0].uvw /= ratv2301;
	    vtxs[1].uvw /= ratv2301;
	  }
	}
      } else {
	if (ratv3012 > 0.25 && ratv3012 < 4.0 && cosv1230 > 0.95f) {
	  vtxs[0].uvw = make_vec3(0.0f, 0.0f, 1.0f);
	  vtxs[1].uvw = make_vec3(co.x, 0.0f, 1.0f);
	  vtxs[2].uvw = make_vec3(co.x, co.y, 1.0f);
	  vtxs[3].uvw = make_vec3(0.0f, co.y, 1.0f);
	  if (ratv3012 > 1.0f) {
	    vtxs[3].uvw *= ratv3012;
	    vtxs[0].uvw *= ratv3012;
	  } else if (ratv3012 < 1.0f) {
	    vtxs[1].uvw /= ratv3012;
	    vtxs[2].uvw /= ratv3012;
	  }
	}
      }
    }
  }
  vptr->push_polygon_distinct{tattr, 1}(vtxs);
}

private threaded function {tattr} void
gf_fill(ptr{vertices} const& vptr, poly_t const& poly,
  mesh_index const& mp)
{
  gf_fill_internal{tattr}(vptr, true, poly, mp);
}

private threaded function {tattr} void
gf_fill_smooth(ptr{vertices} const& vptr, poly_t const& poly,
  mesh_index const& mp)
{
  gf_fill_internal{tattr}(vptr, false, poly, mp);
}

private threaded function void gf_lid(gf_poly const& c0, gf_poly const& c1,
  poly_t const& poly, mesh_index const& mp)
{
  darrayst{vertex_attr} arr = poly;
  c0(arr, mesh_index());
  reverse(arr.range());
  c1(arr, mesh_index());
}

private threaded function void gf_hole(poly_t const& poly,
  mesh_index const& mp)
{
}

private threaded function void gf_sphere(size_t split, gf_poly const& c0,
  poly_t const& poly, mesh_index const& mp)
{
  const poly_sz = poly.size();
  if (poly_sz < 3) { return; }
  if (split == 0) { c0(poly, mesh_index()); }
  const pcenter = polygon_center(poly);
  const nor = normal_from_poly(poly);
  const radius = polygon_radius(poly);
  darrayst{vertex_attr} sp = poly;
  mesh_index mp1;
  for (size_t i: 1 .. split) {
    mp1.x = i;
    const a1 = pi_float() * cast_float(i) / cast_float(split * 2);
    darrayst{vertex_attr} p = poly;
    for (size_t j, mutable& x: p) {
      x.pos += nor * radius * sin(a1);
    }
    polygon_scale(p, cos(a1));
    for (const j: 0 .. poly_sz) {
      const j1 = j + 1 != poly_sz ? j + 1 : 0;
      mutable side = make_farray{vertex_attr}(sp[j], sp[j1], p[j1], p[j]);
      for (size_t i, mutable& p: side) {
	p.nor = (p.pos - pcenter).normalize();
      }
      mp1.y = j;
      c0(side, mp1);
    }
    for (const j: 0 .. poly_sz) {
      sp[j] = p[j];
    }
  }
  const top_pos = pcenter + nor * radius;
  for (const j: 0 .. poly_sz) {
    const j1 = j + 1 != poly_sz ? j + 1 : 0;
    mutable side = make_farray{vertex_attr}(top_pos, sp[j], sp[j1]);
    for (size_t i, mutable& p: side) {
      p.nor = (p.pos - pcenter).normalize();
    }
    c0(side, mesh_index());
  }
}

private threaded function void gf_import_wfobj(wfobject const& wfo,
  wfgroup const& wfgrp, gf_poly const& c0, poly_t const& poly,
  mesh_index const& mp)
{
  mesh_index midx;
  varray{vertex_attr} arr;
  //debug_log("import f", wfgrp.f);
  for (const i, const& p: wfgrp.f) {
    //debug_log("import p", p);
    if (arr.size() != p.size()) {
      arr.resize(p.size(), vertex_attr());
    }
    mutable& sli = arr;
    for (const j, const& v: p) {
      // mutable& ae = sli[arr.size() - j - 1];
      mutable& ae = sli[j];
      const vid = v.vertex;
      //debug_log("vid", vid);
      if (vid > 0 && wfo.v.size() >= vid) {
	ae.pos = wfo.v[vid - 1];
	// debug_log("vertex", ae.pos);
      }
      const nid = v.normal;
      if (nid > 0 && wfo.vn.size() >= nid) {
	ae.nor = wfo.vn[nid - 1];
      }
      const cid = v.texcoord;
      if (cid > 0 && wfo.vt.size() >= cid) {
	const coord = wfo.vt[cid - 1];
	ae.uvw = make_vec3(coord.x, coord.y, 0.0f);
      }
    }
    midx.x = i;
    // if (arr.size() >= 5) { debug_log("polygon", p, arr); }
    c0(arr, midx);
  }
}

private threaded function void gf_rectangle_split(size_t split_x,
  size_t split_y, gf_poly const& c0, poly_t const& poly, mesh_index const& mp)
{
  if (poly.size() != 4) { return; }
  threaded function vec3 pos(vec3 const& vec, size_t i, size_t imax)
  {
    return vec * (cast_float(i) / cast_float(imax));
  }
  mesh_index mp1;
  for (const i: 0 .. split_x) {
    mp1.x = i;
    const s0 = poly[0].pos + pos(poly[1].pos - poly[0].pos, i, split_x);
    const s1 = poly[0].pos + pos(poly[1].pos - poly[0].pos, i + 1, split_x);
    const s2 = poly[3].pos + pos(poly[2].pos - poly[3].pos, i + 1, split_x);
    const s3 = poly[3].pos + pos(poly[2].pos - poly[3].pos, i , split_x);
    for (const j: 0 .. split_y) {
      mp1.y = j;
      const t0 = s0 + pos(s3 - s0, j, split_y);
      const t1 = s1 + pos(s2 - s1, j, split_y);
      const t2 = s1 + pos(s2 - s1, j + 1, split_y);
      const t3 = s0 + pos(s3 - s0, j + 1, split_y);
      c0(make_farray{vertex_attr}(t0, t1, t2, t3), mp1);
    }
  }
}

private threaded function void gf_rotate_local(quat const& q,
  gf_poly const& c0, poly_t const& poly, mesh_index const& mp)
{
  const trans = poly_trans(poly);
  const trans_inv = trans.inverse();
  const m = trans_inv * q.to_mat4() * trans;
  darrayst{vertex_attr} p = poly;
  for (const i, mutable& v: p) {
    const v1 = m * make_vec4(v.pos.x, v.pos.y, v.pos.z, 1.0);
    v.pos = make_vec3(v1.x, v1.y, v1.z);
  }
  c0(p, mp);
}

private threaded function void gf_bump_apply(mat4 const& m,
  bool split_reverse, gf_poly const& c0, gf_poly const& c1, poly_t const& poly,
  mesh_index const& mp)
{
  const trans = poly_trans(poly);
  const trans_inv = trans.inverse();
  const m1 = trans_inv * m * trans;
  darrayst{vertex_attr} front = poly;
  for (const i, mutable& v: front) {
    const v1 = m1 * make_vec4(v.pos.x, v.pos.y, v.pos.z, 1.0);
    v.pos = make_vec3(v1.x / v1.w, v1.y / v1.w, v1.z / v1.w);
  }
  /* front */
  c1(front, mp);
  /* side */
  const sz = poly.size();
  for (const i: 0 .. sz) {
    const i1 = i + 1 != sz ? i + 1 : 0;
    if (split_reverse) {
      const s0 = make_farray{vertex_attr}(poly[i], poly[i1], front[i1]);
      const s1 = make_farray{vertex_attr}(front[i1], front[i], poly[i]);
      c0(s0, mesh_index());
      c0(s1, mesh_index());
    } else {
      const s0 = make_farray{vertex_attr}(poly[i], poly[i1], front[i]);
      const s1 = make_farray{vertex_attr}(front[i], poly[i1], front[i1]);
      c0(s0, mesh_index());
      c0(s1, mesh_index());
    }
  }
}

