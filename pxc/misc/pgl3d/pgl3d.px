public namespace pgl3d "use-unsafe";
public import common -;
public import pointer::raw -;
public import numeric::fpmath -;
public import glm;
public import io::time -;
public import io::environ -;
public import exception -;
public import meta m;
public import text::string::positional -;
public import glgeometry -;
public import glnode -;
public import pglscene -;
public import pglbase -;
public import pglcommon -;
public import pglapi -;
public import wfobj -;

private import GL::compat -;
private import glresource -;
private import glshader -;
private import glbuffer -;
private import pglshader -;


public function void main(pgl3d_application mutable& app)
{
  GL::base::set_check_error_enabled(1);
  try {
    main_loop(app);
  } catch (exception::c_exception ex) {
    sdllog("uncaught exception", ex);
  }
}

public function string sdl_read_file(string mutable& fn)
{
  string r;
  scoped_nullable{SDL_RWclose} rwop;
  rwop.reset(SDL_RWFromFile(fn.c_str(), "rb"));
  if (rwop.get() == rawptr{SDL_RWops}()) {
    throw runtime_error_template{"sdl_read_file"}(fn);
  }
  farray{uchar, 16384} buf;
  while (true) {
    const n = SDL_RWread(rwop, buf.range().to_rawptr().to_voidptr(), 1, 16384);
    if (n == 0) {
      break;
    }
    r.append(buf[0 .. n]);
  }
  return r;
}

struct
frame_statistics()
{
  public metafunction ticks_t farray{uint, 8};
  public uint tprevsec = 0;
  public uint frames = 0;
  public float mutable fps = 0.0;
  public ticks_t ticks;
  public ticks_t ticks_sum;
  public ticks_t ticks_sum_saved;
  init();
  function void init() {
    const t = SDL_GetTicks();
    for (const i, mutable& e : ticks) {
      e = t;
    }
  }
  public function void save_ticks(size_t idx, uint v) {
    const prev_tick = ticks[idx == 0 ? ticks.size() - 1 : idx - 1];
    mutable& cur_tick = ticks[idx];
    cur_tick = v;
    ticks_sum[idx] += cur_tick - prev_tick;
  }
  public function void measure()
  {
    ++frames;
    uint t = SDL_GetTicks();
    if (t - tprevsec >= 1000) {
      const seconds = cast_float(t - tprevsec) / 1000.0;
      fps = cast_float(frames) / seconds;
      ticks_sum_saved = ticks_sum;
      ticks_sum = ticks_t();
      tprevsec = t;
      frames = 0;
    }
  }
}

private function int set_swap_interval(int vsync)
{
  return SDL_GL_SetSwapInterval(vsync);
}

struct
framerate_control(int vsync0)
{
  public int const vsync = vsync0;
  public int const swap_interval = set_swap_interval(vsync0);
  public double time_before_swapwindow = io::system.gettimeofday_double();
  public farray{double, 2} frame_intervals;
  public double sleep_carry = 0.0;
  public double max_fps = 60.0;
  public double target_interval = 1.0 / max_fps;
  public float frame_speed_mul = 1.0;
  public function void start()
  {
    target_interval = 1.0 / max_fps;
    for (const i, mutable& v: frame_intervals) {
      v = target_interval;
    }
    time_before_swapwindow = io::system.gettimeofday_double();
  }
  public function void control()
  {
    const now = io::system.gettimeofday_double();
    const cur_interval = max(now - time_before_swapwindow, 0.0);
    double sum_interval = cur_interval;
    for (const i: 0 .. frame_intervals.size() - 1) {
      const v = frame_intervals[i + 1];
      frame_intervals[i] = v;
      sum_interval += v;
    }
    if (frame_intervals.size() > 1) {
      frame_intervals[frame_intervals.size() - 1] = cur_interval;
    }
    const avg_interval = sum_interval
      / static_cast{double}(frame_intervals.size());
    if (target_interval > avg_interval) {
      mutable tfr = 1.0 / target_interval;
      //if (target_interval > 0.1) {
//	tfr = 1.0 / cur_interval;
//      } else
      {
	// tfr += max(0.1, target_interval * 3.0f);
	// tfr += target_interval * 10.0f;
	tfr += 0.1f;
      }
      tfr = max(min(tfr, max_fps), 1.0);
      target_interval = 1.0 / tfr;
    } else {
      target_interval = avg_interval;
    }
    const sleep_sec = target_interval - cur_interval + sleep_carry;
//sdllog("target", target_interval, "cur", cur_interval, "sleep", sleep_sec);
    if (sleep_sec > 0.001) {
      const ss = min(sleep_sec, 0.1);
      io::system.usleep(static_cast{uint}((ss - 0.001) * 1000000.0));
    }
    time_before_swapwindow = io::system.gettimeofday_double();
    const slept = time_before_swapwindow - now;
    sleep_carry = max(min(sleep_sec - slept, 0.1), -0.1);
    frame_speed_mul = static_cast{float}(target_interval * 60.0);
  }
}

private function void main_loop(pgl3d_application mutable& app)
{
  sdllog("PGL3D main");

  sdlcontext sdlc;

  SDL_EventState(SDL_KEYDOWN, 0);
  SDL_EventState(SDL_KEYUP, 0);
  SDL_EventState(SDL_TEXTEDITING, 0);
  SDL_EventState(SDL_TEXTINPUT, 0);
  if (m::or{is_android, is_ios}) {
    SDL_EventState(SDL_MOUSEBUTTONDOWN, 0);
    SDL_EventState(SDL_MOUSEBUTTONUP, 0);
    SDL_EventState(SDL_MOUSEMOTION, 0);
  }

  sdllog("PGL3D init0");

  pglshader pgs = pglshader(sdlc.gles_flag, sdlc.glmajor, sdlc.glminor,
    sdlc.enable_msaa, sdlc.init_w, sdlc.init_h);
  app.on_build_vertices(pgs);
  varray{instances_type} local_bo_instances;
  pgs.prepare_vertex_buffers();
  pgs.prepare_bo_instances(local_bo_instances);
  node_factory nfac;
  pgs.prepare_node_factory(nfac);

  /* spawn motion thread */
  motion_thread_object mto = motion_thread_object(nfac, local_bo_instances,
    app.get_scene_shared());

  size_t saved_stat_num_objects;

  const test_scroll_mode = false;

  projection_info cam_drawing_frame;

  frame_statistics mutable fr;
  framerate_control mutable frctl = framerate_control(sdlc.vsync);

  bool done = false;
  bool paused = false;
  while (!done) {
    bool scene_next_flag = false;
    SDL_Event ev;
    while (SDL_PollEvent(address(ev)) != 0) {
      const etype = ev.type;
      /*
       sdllog("event", cast_int(ev.type));
       */
      if (etype == SDL_WINDOWEVENT) {
	if (ev.window.event == SDL_WINDOWEVENT_RESIZED) {
	  int w;
	  int h;
	  SDL_GL_GetDrawableSize(sdlc.sdl_window, address(w), address(h));
	  pgs.resize_screen(w, h);
	  frctl.start();
	  sdllog("resized w=", w, " h=", h);
	} else if (ev.window.event == SDL_WINDOWEVENT_HIDDEN) {
	  sdllog("hidden");
	} else if (ev.window.event == SDL_WINDOWEVENT_MINIMIZED ||
	    ev.window.event == SDL_WINDOWEVENT_FOCUS_LOST) {
	  paused = true;
	  sdllog("paused");
	} else if (ev.window.event == SDL_WINDOWEVENT_RESTORED ||
	    ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) {
	  paused = false;
	  frctl.start();
	  sdllog("restored");
	} else {
	  /*
	  sdllog("window event ", cast_int(ev.window.event));
	  */
	}
      } else if (etype == SDL_QUIT) {
	done = true;
	break;
      }
      /* invoke event handler */
      app.on_event(ev, frctl.frame_speed_mul, pgs.cam);
    }
    {
      int numkeys;
      const ksp = SDL_GetKeyboardState(address(numkeys));
      const ks = ksp.to_cslice(static_cast{size_t}(numkeys));
      /* invoke key handler */
      app.on_scankeys(ks, frctl.frame_speed_mul, pgs.cam);
    }
    fr.save_ticks(0, SDL_GetTicks());
    if (paused) {
      SDL_Delay(100);
      fr.tprevsec = SDL_GetTicks();
      continue;
    }
    /* motion and prepare instance data */
    {
      const mess = string_join{" "}(fr.fps, frctl.frame_speed_mul,
	fr.ticks_sum_saved,
	saved_stat_num_objects,
	pgs.cam.camera.angle, pgs.cam.camera.position);
      mto.wait_and_exec{swap_data_cl}();
      function void swap_data_cl(motion_thread_shared mutable& mts) {
	// fr.save_ticks(1, SDL_GetTicks());
	cam_drawing_frame = mts.cam;
	mts.cam = pgs.cam;
	mts.frame_speed_mul = frctl.frame_speed_mul;
	mts.message = mess;
	local_bo_instances.swap(mts.bo_instances);
	saved_stat_num_objects = mts.stat_num_objects;
      }
    }
    fr.save_ticks(1, SDL_GetTicks());
    {
      /* draw frame */
      varray{uint} tick_draw;
      tick_draw = draw_frame(pgs, local_bo_instances, cam_drawing_frame);
      if (tick_draw.size() > 2) {
	fr.save_ticks(2, tick_draw[0]);
	fr.save_ticks(3, tick_draw[1]);
      } else {
	fr.save_ticks(2, SDL_GetTicks());
	fr.save_ticks(3, SDL_GetTicks());
      }
      fr.save_ticks(4, SDL_GetTicks());
      fr.measure();
    }
    fr.save_ticks(5, SDL_GetTicks());
    frctl.control();
    fr.save_ticks(6, SDL_GetTicks());
    SDL_GL_SwapWindow(sdlc.sdl_window);
    fr.save_ticks(7, SDL_GetTicks());
    if (scene_next_flag) {
      frctl.start();
    }
  }
}

