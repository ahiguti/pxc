public namespace pgl3d "export-unsafe";
public import common -;
public import pointer::raw -;
public import numeric::fpmath -;
public import SDL2 -;
public import GL::glm glm;
public import GL::compat -;
public import io::time -;
public import io::environ -;
public import exception -;
public import meta m;
public import text::string::positional -;

public import glresource -;
public import glshader -;
public import glgeometry -;
public import glbuffer -;
public import glnode -;
public import pglshader -;

function void build_vertices(pglshader mutable& pgs,
  cslice{ptr{vertex_buffer}} const& bos)
{
  metafunction tattr main_vertex_attributes;
  metafunction fill_v fill{tattr};
  metafunction joint_v joint{tattr};
  /* vtx0 */
  {
    const vtxs = bos[0]->get("saucer")->vtxs;
    const fsmooth = fill_smooth{tattr}(vtxs);
    const t = fill_v(vtxs);
    regular_polygon(3.0, 40,
      bump_rec(0.2, 0.5, 1, t, t),
      bump_rec(0.01, 0.9, 5,
	t,
	sphere(10, fsmooth)))
      (poly_t(), mesh_pos());
  }
  /* vtx2 */
  {
    const vtx2 = bos[0]->get("saucer-multi")->vtxs;
    const t2 = fill_v(vtx2);
    regular_polygon(50.0, 50,
      bump_rec(1.0, 1.0, 1, joint_v(vtx2, "saucer", hole()), hole()),
      hole())
      (poly_t(), mesh_pos());
  }
  /* vtx8 */
  {
    const vtx = bos[0]->get("block-multi")->vtxs;
    const t = fill_v(vtx);
    regular_polygon(600.0, 4,
      rectangle_split(9, 8, joint_v(vtx, "block", hole())),
      hole())
      (poly_t(), mesh_pos());
  }
  /* vtx9 */
  {
    const vtx = bos[0]->get("block")->vtxs;
    const t = fill_v(vtx);
    const rnd = make_rand_generator(1U);
    regular_polygon(50.0, 4,
      rotate_local(glm::make_quat_angle_axis(45.0, 0.0, 0.0, 1.0),
	rectangle_split(30, 30,
	  rand_bump(1, 0.8, 0.2, 0.8, 0.2, 0.8, 1.0, 4.0, rnd,
	    t, t, t))),
      rotate_local(glm::make_quat_angle_axis(-45.0, 0.0, 0.0, 1.0),
	bump_rec(0.2, 1.0, 1, t, t)))
      (poly_t(), mesh_pos());
  }
  /* vtx10 */
  {
    const vtx = bos[0]->get("bullet")->vtxs;
    const t = fill_v(vtx);
    mutable m = glm::mat4()
      .translate(glm::make_vec3(0.0, 0.0, 1.0))
      .rotate(10.0, glm::make_vec3(0.0, 0.0, 1.0));
    regular_polygon(1.0, 6,
      bump_apply(m, false, t, t),
      bump_apply(m, false, t, t))
      (poly_t(), mesh_pos());
  }
  {
    /* 60fps, macosx/linux mbp gt750m */
    const vtx = bos[0]->get("bullet-multi")->vtxs;
    const t = fill_v(vtx);
    regular_polygon(600.0, 4,
      rectangle_split(170, 170, joint_v(vtx, "bullet", hole())),
      hole())
      (poly_t(), mesh_pos());
  }
  {
    const vtx = bos[0]->get("bullet2")->vtxs;
    const t = fill_v(vtx);
    mutable m = glm::mat4()
      .translate(glm::make_vec3(0.0, 0.0, 1.0))
      .rotate(10.0, glm::make_vec3(0.0, 0.0, 1.0));
    regular_polygon(1.0, 5,
      bump_rec(0.8, 0.8, 1, t, t),
      bump_rec(0.8, 0.8, 1, t, t))
      (poly_t(), mesh_pos());
  }
  {
    /* 60fbp mbp intel gpu */
    const vtx = bos[0]->get("bullet2-multi")->vtxs;
    const t = fill_v(vtx);
    const rnd = make_rand_generator(991U);
    rand_sphere(200.0, 40000, false, rnd,
      joint_v(vtx, "bullet2", hole()))
      (poly_t(), mesh_pos());
  }
  {
    const vtx = bos[0]->get("bullet2-multi2")->vtxs;
    const t = fill_v(vtx);
    const rnd = make_rand_generator(991U);
    rand_sphere(200.0, 20000, false, rnd,
      joint_v(vtx, "bullet2", hole()))
      (poly_t(), mesh_pos());
  }
  {
    const vtx = bos[0]->get("bullet2-multi3")->vtxs;
    const t = fill_v(vtx);
    const rnd = make_rand_generator(991U);
    rand_sphere(200.0, 2000, false, rnd,
      joint_v(vtx, "bullet2", hole()))
      (poly_t(), mesh_pos());
  }
  {
    const vtx = bos[0]->get("bullet-multi-2")->vtxs;
    const t = fill_v(vtx);
    regular_polygon(600.0, 4,
      rectangle_split(80, 80, joint_v(vtx, "bullet", hole())),
      hole())
      (poly_t(), mesh_pos());
  }
  {
    /* particle */
    const vtx = bos[1]->get("particle")->vtxs;
    const p = particle(vtx);
    const rnd = make_rand_generator(1U);
    rand_sphere(1.0, 100, true, rnd, p)
    //rand_sphere(1.0, 250, true, rnd, p)
      (poly_t(), mesh_pos());
  }
  {
    /* particle multi */
    const vtx = bos[1]->get("particle-multi")->vtxs;
    /*
    regular_polygon(600.0, 4,
      // rectangle_split(200, 200, joint_v(vtx, "particle", hole())),
      rectangle_split(100, 100, joint_v(vtx, "particle", hole())),
      hole())
      (poly_t(), mesh_pos());
    const vtx = bos[2]->get("particle-bb-multi")->vtxs;
    */
    const rnd = make_rand_generator(991U);
    rand_sphere(60.0, 10000, true, rnd,
      joint_v(vtx, "particle", hole()))
      (poly_t(), mesh_pos());
  }
  {
    /* particle-bb */
    const vtx = bos[2]->get("particle-bb")->vtxs;
    const p = particle_bb(vtx);
    const rnd = make_rand_generator(1U);
    rand_sphere(1.0, 100, true, rnd, p)
      (poly_t(), mesh_pos());
  }
  {
    /* particle-bb multi */
    const vtx = bos[2]->get("particle-bb-multi")->vtxs;
    const rnd = make_rand_generator(991U);
    rand_sphere(60.0, 10000, true, rnd,
      joint_v(vtx, "particle-bb", hole()))
      (poly_t(), mesh_pos());
  }
  {
    const vtx = bos[2]->get("mixed")->vtxs;
    regular_polygon(1.0, 5,
      bump_rec(1.0, 10.0, 1, hole(), joint_v(vtx, "saucer", hole())),
      // joint_v(vtx, "bullet2", hole()),
      // joint_v(vtx, "particle", hole()),
      joint_v(vtx, "particle-bb", hole()))
      (poly_t(), mesh_pos());
  }
  /*
  */
  {
    /* for font2 shader */
    const vtx = bos[3]->get("default_font")->vtxs;
    const char_w = static_cast{float}(pgs.fti.char_w);
    const char_h = static_cast{float}(pgs.fti.char_h);
    const point_size = static_cast{float}(max(pgs.fti.char_w, pgs.fti.char_h));
    const char_size_px = glm::make_vec2(char_w, char_h);
    const texture_size_px = glm::make_vec2(
      static_cast{float}(pgs.fti.surface_w),
      static_cast{float}(pgs.fti.surface_h));
    const char_h_tex = char_h / static_cast{float}(pgs.fti.surface_h);
    const char_w_tex = char_w / static_cast{float}(pgs.fti.surface_w);
    const clamp_x = char_w / point_size;
    const clamp_y = char_h / point_size;
    font2_vertex_attributes v;
    v.char_size_px = char_size_px;
    v.texture_size_px = texture_size_px;
    v.texture_origin_px = glm::make_vec2(0.0, 0.0);
    v.char_uv = glm::make_vec2(0.0, 0.0);
    v.char_uv_delta = glm::make_vec2(char_w_tex, char_h_tex);
    v.coord_clamp = glm::make_vec2(clamp_x, clamp_y);
    v.char_px = static_cast{float}(pgs.fti.char_w);
    v.char_point_size = point_size;
    for (const i: 0 .. 14U) {
      v.text_index = static_cast{float}(i);
//debug_log("point size", v.char_point_size);
//debug_log("text_index", v.text_index);
println("font2_vertex_attributes", v);
      vtx->push_point{font2_vertex_attributes}(v);
    }
//println("vertex_values", vtx->vertex_values);
  }
}

public threaded struct node_data
{
  public glm::mat4 trans_ini;
  public glm::mat4 trans_cur;
}

public threaded function void
make_node(scene_node{node_data} mutable& sn)
{
  sn.data.trans_ini = sn.trans;
  sn.data.trans_cur = sn.trans;
}

struct
frame_control()
{
  public metafunction ticks_t farray{uint, 7};
  public uint tprevsec = 0;
  public uint tprev = SDL_GetTicks();
  public uint frames = 0;
  public float mutable fps = 0.0;
  public farray{uint, 2} mutable frame_tdiffs;
  public float frame_speed_mul = 1.0f;
  public ticks_t ticks;
  public ticks_t ticks_sum;
  public ticks_t ticks_sum_prev;
  init();
  function void init() {
    for (const i, mutable& e: frame_tdiffs) {
      e = 1000U / cast_uint(frame_tdiffs.size());
    }
    for (const i, mutable& e : ticks) {
      e = tprev;
    }
  }
  public function void save_ticks(size_t idx, uint v) {
    const prev_tick = ticks[idx == 0 ? ticks.size() - 1 : idx - 1];
    mutable& cur_tick = ticks[idx];
    cur_tick = v;
    ticks_sum[idx] += cur_tick - prev_tick;
  }
  public function void measure()
  {
    ++frames;
    uint t = SDL_GetTicks();
    if (t - tprevsec >= 1000) {
      const seconds = cast_float(t - tprevsec) / 1000.0;
      fps = cast_float(frames) / seconds;
      /*
      sdllog(string_join{" "}(frames, "frames in", seconds, "seconds =",
	  fps, "fps"));
      sdllog(string_join{" "}("ticks: ", ticks_sum));
      */
      ticks_sum_prev = ticks_sum;
      ticks_sum = ticks_t();
      tprevsec = t;
      frames = 0;
    }
    mutable tdiff = cast_int(t - tprev);
    tprev = t;

    uint tdiff_frame_sum = cast_uint(tdiff);
    for (const i: 1 .. frame_tdiffs.size()) {
      tdiff_frame_sum += frame_tdiffs[i];
      frame_tdiffs[i - 1] = frame_tdiffs[i];
    }
    frame_tdiffs[frame_tdiffs.size() - 1] = cast_uint(tdiff);
  }
}

struct
input_control()
{
  public varray{SDL_FingerID} fingerids;
  public farray{bool, 2} fingdown;
  public farray{size_t, 2} fingerdown_time;
  public farray{glm::vec2, 2} start_pos;
  public farray{glm::vec2, 2} cur_pos;
  public glm::vec2 finger_xyrotate_delta;
  public float finger_zmove_delta;
  public int finger_zmove_mode = 0;
  public function void finger_motion(float x, float y, float dx, float dy,
    SDL_FingerID fng)
  {
    size_t fid = 2;
    if (fingerids.size() > 0 && fingerids[0] == fng) {
      fid = 0;
    } else if (fingerids.size() > 1 && fingerids[1] == fng) {
      fid = 1;
    }
    if (fid < 2) {
      cur_pos[fid] = glm::make_vec2(x, y);
      /*
      sdllog(string_join{" "}("finger_motion", x, y, fid, fng));
      */
    } else {
      /*
      sdllog(string_join{" "}("finger_motion(ignored)", x, y, fng,
	"fingerids:", fingerids));
      */
    }
  }
  public function void finger_down(float x, float y, SDL_FingerID fng) {
    size_t fid = 2;
    if (fingerids.size() > 0 && fingerids[0] == fng) {
      fid = 0;
    } else if (fingerids.size() > 1 && fingerids[1] == fng) {
      fid = 1;
    } else if (fingerids.size() < 2) {
      fid = fingerids.size();
      fingerids.push_back(fng);
    }
    if (fid < 2) {
      fingdown[fid] = true;
      start_pos[fid] = glm::make_vec2(x, y);
      cur_pos[fid] = start_pos[fid];
      /*
      sdllog(string_join{" "}("finger_down", x, y, fid));
      */
      fingerdown_time[0] = 0;
      fingerdown_time[1] = 0;
      finger_zmove_mode = 0;
    }
    /*
    sdllog(string_join{" "}("finger_down_post", fingerids));
    */
  }
  public function void finger_up(SDL_FingerID fng) {
    size_t fid = 2;
    if (fingerids.size() > 0 && fingerids[0] == fng) {
      fid = 0;
    } else if (fingerids.size() > 1 && fingerids[1] == fng) {
      fid = 1;
    }
    if (fid < 2) {
      fingdown[fid] = false;
      /*
      sdllog(string_join{" "}("finger_up", fid));
      */
      if (fid == 1) {
	start_pos[0] = cur_pos[0];
	fingerids.resize(1, 0);
	fingdown[1] = false;
      } else {
	fingerids.erase(0, 1);
	if (fingerids.empty()) {
	  fingdown[0] = false;
	} else {
	  cur_pos[0] = cur_pos[1];
	  start_pos[0] = cur_pos[1];
	  fingdown[0] = fingdown[1];
	  fingdown[1] = false;
	}
      }
      fingerdown_time[0] = 0;
      fingerdown_time[1] = 0;
      finger_zmove_mode = 0;
    }
    /*
    sdllog(string_join{" "}("finger_up_post", fingerids));
    */
  }
  public function void finger_action_one_finger(position_angle mutable& target,
      frame_control const& frctl, size_t fid)
  {
    mutable dx = (cur_pos[fid].x - start_pos[fid].x);
    mutable dy = (cur_pos[fid].y - start_pos[fid].y);
    const d = glm::distance(start_pos[fid], cur_pos[fid]);
    if (d > 3.0) {
      dx /= d / 3.0;
      dy /= d / 3.0;
    }
    /*
    sdllog(string_join{" "}("onefinger", dx, dy));
    */
    target.rotate_angle_axis(-dy * 2.0 * frctl.frame_speed_mul, 1.0, 0.0, 0.0);
    target.rotate_angle_axis(-dx * 2.0 * frctl.frame_speed_mul, 0.0, 1.0, 0.0);
    finger_xyrotate_delta.x = dx;
    finger_xyrotate_delta.y = dy;
  }
  public function void finger_action_two_fingers(position_angle mutable& target,
      frame_control const& frctl)
  {
    const d0 = cur_pos[0] - start_pos[0];
    const d1 = cur_pos[1] - start_pos[1];
    if (glm::dot(d0, d1) < 0.0f) {
      /* z move */
      if (finger_zmove_mode != 2) {
	const distance_start = glm::distance(start_pos[0], start_pos[1]);
	mutable distance_cur = glm::distance(cur_pos[0], cur_pos[1]);
	if (distance_cur <= 0.0001f) {
	  distance_cur = 0.0001f;
	}
	const rat = distance_start / distance_cur;
	const prev = finger_zmove_delta;
	if (rat > 1.2) {
	  finger_zmove_delta += 0.001f * frctl.frame_speed_mul;
	  if (finger_zmove_delta >= 1.0) {
	    finger_zmove_delta = 1.0;
	  }
	  finger_zmove_mode = 1;
	} else if (rat < 0.8) {
	  finger_zmove_delta -= 0.001f * frctl.frame_speed_mul;
	  if (finger_zmove_delta <= -1.0) {
	    finger_zmove_delta = -1.0;
	  }
	  finger_zmove_mode = 1;
	}
	if ((prev < 0.0f && finger_zmove_delta > 0.0f) ||
	  (prev > 0.0f && finger_zmove_delta < 0.0f)) {
	  /* stop */
	  finger_zmove_delta = 0.0f;
	  finger_zmove_mode = 2;
	}
      }
    } else {
      /* xy move */
      const d0 = cur_pos[0] - start_pos[0];
      const d1 = cur_pos[1] - start_pos[1];
      mutable avg = (d0 + d1) / 2.0f;
      const d = (glm::distance(start_pos[0], cur_pos[0]),
	glm::distance(start_pos[1], cur_pos[0])) / 2.0f;
      if (d > 3.0) {
	avg /= d / 3.0;
      }
      avg /= 32.0f;
      target.translate_relative(
	  glm::make_vec3(avg.x, -avg.y, 0.0) * frctl.frame_speed_mul);
    }
  }
  public function void finger_action_step(position_angle mutable& target,
      frame_control const& frctl)
  {
    /*
    sdllog(string_join{" "}("finger_action_step", fingdown[0], fingdown[1]));
    */
    if (fingdown[0] && !fingdown[1]) {
      if (fingerdown_time[0] >= 2) {
	finger_action_one_finger(target, frctl, 0);
      } else {
	start_pos[0] = (start_pos[0] + cur_pos[0]) / 2.0f;
	fingerdown_time[0] += 1;
      }
      if (fingerids[0] == 0) {
	/* mouse button */
	/*
	finger_zmove_delta -= 0.0001;
	if (finger_zmove_delta <= -0.01) {
	  finger_zmove_delta = -0.01;
	}
	*/
      }
    } else if (!fingdown[0] && fingdown[1]) {
      if (fingerdown_time[1] >= 2) {
	finger_action_one_finger(target, frctl, 0);
      } else {
	start_pos[1] = (start_pos[1] + cur_pos[1]) / 2.0f;
	fingerdown_time[1] += 1;
      }
    } else if (fingdown[0] && fingdown[1]) {
      if (fingerdown_time[0] >= 2 && fingerdown_time[1] >= 2) {
	finger_action_two_fingers(target, frctl);
      } else {
	start_pos[0] = (start_pos[0] + cur_pos[0]) / 2.0f;
	fingerdown_time[0] += 1;
	start_pos[1] = (start_pos[1] + cur_pos[1]) / 2.0f;
	fingerdown_time[1] += 1;
      }
    } else {
      const len = glm::length(finger_xyrotate_delta);
      target.rotate_angle_axis(
	  -finger_xyrotate_delta.y * 2.0 * frctl.frame_speed_mul,
	  1.0, 0.0, 0.0);
      target.rotate_angle_axis(
	  -finger_xyrotate_delta.x * 2.0 * frctl.frame_speed_mul,
	  0.0, 1.0, 0.0);
      const decay = 0.03f * frctl.frame_speed_mul;
      if (len < decay) {
	finger_xyrotate_delta = glm::make_vec2(0.0f, 0.0f);
      } else {
	finger_xyrotate_delta -= finger_xyrotate_delta * decay / len;
      }
    }
    target.translate_relative(glm::make_vec3(0.0, 0.0, finger_zmove_delta)
	* frctl.frame_speed_mul);
  }
  public function void add_zdelta(float zaccel, frame_control const& frctl)
  {
    finger_zmove_delta += zaccel * frctl.frame_speed_mul;
    if (finger_zmove_delta <= -1.0) {
      finger_zmove_delta = -1.0;
    }
    if (finger_zmove_delta >= 1.0) {
      finger_zmove_delta = 1.0;
    }
    finger_zmove_mode = 1;
  }
}

struct
framerate_control(int vsync0)
{
  public int const vsync = vsync0;
  public int const swap_interval = SDL_GL_SetSwapInterval(vsync0);
  public double time_before_swapwindow = io::system.gettimeofday_double();
  public farray{int, 64} delay_usec;
  public int fixed_fps = 1;
  public function void delay()
  {
    double latency_target = 1.0 / static_cast{float}(60 / fixed_fps);
    if (true) {
      const now = io::system.gettimeofday_double();
      const td = max(now - time_before_swapwindow, 0.0);
      const sleep_sec = latency_target - td;
      if (sleep_sec > 0.0) {
	if (fixed_fps > 1 || swap_interval > 1) {
	  io::system.usleep(static_cast{uint}(sleep_sec * 1000000.0));
	}
	time_before_swapwindow += latency_target;
	if (now - time_before_swapwindow < -1.0) {
	  time_before_swapwindow = now + 1.0;
	}
      } else {
	time_before_swapwindow = io::system.gettimeofday_double();
      }
      const sleep_usec = static_cast{int}(sleep_sec * 1000000.0);
      int s_sum = sleep_usec;
      int neg_cnt = 0;
      for (const i: 0 .. delay_usec.size() - 1) {
	const v = delay_usec[i];
	s_sum += v;
	delay_usec[i] = delay_usec[i + 1];
	// println("delay_usec[i]", i, v);
	if (v < 0) {
	  // println("neg", v);
	  ++neg_cnt;
	}
      }
      delay_usec[delay_usec.size() - 1] = sleep_usec;
      const s_avg = static_cast{double}(s_sum)
	/ static_cast{double}(delay_usec.size());
      /*
      println(fixed_fps, now - time_before_swapwindow, sleep_sec, s_avg,
	neg_cnt);
      */
      /*
      if (fixed_fps < 6) {
	if (neg_cnt > static_cast{int}(delay_usec.size() / 4)) {
	  println("increment delay");
	  ++fixed_fps;
	  for (const i, mutable& v: delay_usec) {
	    v = 0;
	  }
	}
      }
      */
      /*
      */
      /*
      if (neg_cnt > delay_usec.size() - 1 && fixed_fps < 6) {
	++fixed_fps;
	for (const i, mutable& v: delay_usec) {
	  v = 0;
	}
	time_before_swapwindow = io::system.gettimeofday_double();
      } else if (pos_cnt == delay_usec.size() - 1 && fixed_fps > 1) {
	--fixed_fps;
	for (const i, mutable& v: delay_usec) {
	  v = 0;
	}
	time_before_swapwindow = io::system.gettimeofday_double();
      }
      */
    }
  }
}

valuetype struct
player_info()
{
  public position_angle posang;
}

function void main_loop()
{
  sdllog("PGC main");

  sdlcontext sdlc  = sdlcontext();

  SDL_EventState(SDL_KEYDOWN, 0);
  SDL_EventState(SDL_KEYUP, 0);
  SDL_EventState(SDL_TEXTEDITING, 0);
  SDL_EventState(SDL_TEXTINPUT, 0);
  if (m::or{is_android, is_ios}) {
    SDL_EventState(SDL_MOUSEBUTTONDOWN, 0);
    SDL_EventState(SDL_MOUSEBUTTONUP, 0);
    SDL_EventState(SDL_MOUSEMOTION, 0);
  }

  sdllog("PXC-SDL2 init0");

  pglshader pgs = pglshader(sdlc.gles_flag, sdlc.glmajor, sdlc.glminor,
    sdlc.enable_msaa, sdlc.init_w, sdlc.init_h);

  varray{ptr{vertex_buffer}} bos;
  bos.push_back(make_ptr{vertex_buffer}
    (static_cast{size_t}(num_float_struct{main_vertex_attributes}), false));
  bos.push_back(make_ptr{vertex_buffer}
    (static_cast{size_t}(num_float_struct{particle_vertex_attr}), true));
  bos.push_back(make_ptr{vertex_buffer}
    (static_cast{size_t}(num_float_struct{particle_bb_vertex_attr}), false));
  bos.push_back(make_ptr{vertex_buffer}
    (static_cast{size_t}(num_float_struct{font2_vertex_attributes}), true));
  {
    const t0 = system.gettimeofday_double();
    build_vertices(pgs, bos);
    const t1 = system.gettimeofday_double();
    bos[0]->create_vbo();
    bos[1]->create_vbo();
    bos[2]->create_vbo();
    bos[3]->create_vbo();
println("bos[3] vbo_values", bos[3]->vbo_values.get());
    const t2 = system.gettimeofday_double();
    sdllog(string_join{" "}("build vertex", t1 - t0, t2 - t1));
  }

  joint_id_type scene_id;
  scene_id.bo_id = 3;
  scene_id.vs_id = 0; // static_cast{int}(bos[2]->num_vs_ids() - 1);
  const test_scroll_mode = false;
  if (test_scroll_mode) {
    scene_id.bo_id = 0;
    scene_id.vs_id = 8;
  }
  mutable snode = instantiate_scene{node_data, make_node}(
    bos, scene_id, glm::mat4());
  input_control ictl;
  int motion_count = 0;
  function void scene_next()
  {
    ++scene_id.vs_id;
    if (scene_id.vs_id >= static_cast{int}(bos[scene_id.bo_id]->num_vs_ids())) {
      scene_id.vs_id = 0;
      ++scene_id.bo_id;
      if (scene_id.bo_id > 2) {
	scene_id.bo_id = 0;
      }
    }
    snode = instantiate_scene{node_data, make_node}(
      bos, scene_id, glm::mat4());
    rctl.fixed_fps = 1;
  }

  frame_control mutable frctl;
  framerate_control mutable rctl = framerate_control(sdlc.vsync);

  player_info player;
  player.posang.angle = glm::make_quat_wxyz(1.0, 0.0, 0.0, 0.0);
  player.posang.position = glm::make_vec3(0.0, 0.0, 10.0);

  bool done = false;
  bool paused = false;
  while (!done) {
    frctl.save_ticks(0, SDL_GetTicks());
    SDL_Event ev;
    while (SDL_PollEvent(ev)) {
      const etype = ev.type;
      /*
       sdllog(string_join{" "}("event", cast_int(ev.type)));
       */
      if (etype == SDL_WINDOWEVENT) {
	if (ev.window.event == SDL_WINDOWEVENT_RESIZED) {
	  int w;
	  int h;
	  SDL_GL_GetDrawableSize(sdlc.sdl_window.some, w, h);
	  pgs.reshape(w, h);
	  sdllog(string_join{""}("resized w=", w, " h=", h));
	} else if (ev.window.event == SDL_WINDOWEVENT_HIDDEN) {
	  /* sdllog("hidden"); */
	} else if (ev.window.event == SDL_WINDOWEVENT_MINIMIZED ||
	    ev.window.event == SDL_WINDOWEVENT_FOCUS_LOST) {
	  // paused = true; // FIXME
	  sdllog("paused");
	} else if (ev.window.event == SDL_WINDOWEVENT_RESTORED ||
	    ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) {
	  paused = false;
	  sdllog("restored");
	} else {
	  /*
	  sdllog(string_join{" "}("window event ",
		cast_int(ev.window.event)));
	  */
	}
      } else if (etype == SDL_MOUSEBUTTONDOWN) {
	const bx = cast_float(ev.button.x) / cast_float(pgs.cam.screen_width);
	const by = cast_float(ev.button.y) / cast_float(pgs.cam.screen_height);
	if (bx < 0.1 && by < 0.1) {
	  scene_next();
	}
	if (bx > 0.9 && by < 0.1) {
	  rctl.fixed_fps = rctl.fixed_fps != 6 ? rctl.fixed_fps + 1 : 1;
	}
	if (bx > 0.9 && by > 0.9) {
	  pgs.cam.light_on = pgs.cam.light_on > 0.5f ? 0.0f : 1.0f;
	}
	sdllog(string_join{" "}("mousedown", ev.button.x, ev.button.y,
	  ev.button.button));
	ictl.finger_down(
	  cast_float(ev.button.x) / cast_float(pgs.cam.screen_width),
	  cast_float(ev.button.y) / cast_float(pgs.cam.screen_height),
	  0);
	/*
	*/
      } else if (etype == SDL_MOUSEBUTTONUP) {
	/*
	sdllog(string_join{" "}("mouseup", ev.button.button));
	ictl.finger_up(0);
	 */
      } else if (etype == SDL_MOUSEMOTION) {
	/*
	sdllog(string_join{" "}("mousemotion", ev.button.x, ev.button.y,
	  ev.button.button));
	 */
      } else if (etype == SDL_FINGERDOWN) {
	/*
	sdllog(string_join{" "}("fingerdown", ev.tfinger.x, ev.tfinger.y,
	  ev.tfinger.fingerId));
	*/
	ictl.finger_down(ev.tfinger.x, ev.tfinger.y, ev.tfinger.fingerId);
	if (ev.tfinger.x < 0.1 && ev.tfinger.y < 0.1) {
	  scene_next();
	}
	if (ev.tfinger.x > 0.9 && ev.tfinger.y < 0.1) {
	  rctl.fixed_fps = rctl.fixed_fps != 6 ? rctl.fixed_fps + 1 : 1;
	}
	if (ev.tfinger.x > 0.9 && ev.tfinger.y > 0.9) {
	  pgs.cam.light_on = pgs.cam.light_on > 0.5f ? 0.0f : 1.0f;
	}
      } else if (etype == SDL_FINGERUP) {
	/*
	sdllog(string_join{" "}("fingerup", ev.tfinger.fingerId));
	*/
	ictl.finger_up(ev.tfinger.fingerId);
      } else if (etype == SDL_FINGERMOTION) {
	if (m::or{is_android, is_ios}) {
	  ictl.finger_motion(ev.tfinger.x, ev.tfinger.y,
	      ev.tfinger.dx, ev.tfinger.dy, ev.tfinger.fingerId);
	  /*
	  sdllog(string_join{" "}("fingermotion", ev.tfinger.x, ev.tfinger.y,
	    ev.tfinger.dx, ev.tfinger.dy, ev.tfinger.fingerId));
	  */
	}
      } else if (etype == SDL_APP_WILLENTERBACKGROUND) {
	sdllog(string_join{""}("paused"));
	paused = true;
      } else if (etype == SDL_APP_DIDENTERFOREGROUND) {
	sdllog(string_join{""}("resumed"));
	paused = false;
	int w;
	int h;
	SDL_GL_GetDrawableSize(sdlc.sdl_window.some, w, h);
	pgs.reshape(w, h);
      } else if (etype == SDL_QUIT) {
	done = true;
	break;
      } else if (etype == SDL_MULTIGESTURE) {
      } else if (etype == SDL_KEYDOWN) {
	// println("KEYDOWN event");
	if (ev.key.keysym.scancode == SDL_SCANCODE_TAB) {
	  scene_next();
	}
	if (ev.key.keysym.scancode == SDL_SCANCODE_F) {
	  rctl.fixed_fps = rctl.fixed_fps != 6 ? rctl.fixed_fps + 1 : 1;
	}
      } else {
	string s;
	integral_to_hexadecimal{int}(cast_int(ev.type), s);
	sdllog(string_join{" "}("unknown event", s));
	/* */
      }
    }
    if (paused) {
      SDL_Delay(100);
      frctl.tprev = SDL_GetTicks();
      frctl.tprevsec = frctl.tprev;
      continue;
    } else {
      function void motion_rec(scene_node{node_data} mutable& sn, size_t i,
	size_t n)
      {
	const num = sn.children.size();
	if (num > 0) {
	  const rnd = make_rand_generator(1U);
	  for (const ci, const& c: sn.children) {
	    const ui = rnd->generate() / 65536;
	    motion_rec(*c, ui, 65536);
	  }
	} else if (sn.joint_id.bo_id != 3) {
	  const t = static_cast{float}(i) / static_cast{float}(n) * pi_float()
	    * 2.0;
	  const x = sin(t);
	  const y = cos(t);
	  const ang = glm::make_quat_angle_axis(
	    static_cast{float}(motion_count), x, y, 0.0);
	  sn.trans = sn.data.trans_ini * ang.to_mat4();
	} else {
	  /* bo_id == 3 */
	  /* text object */
	  const s = "ABC012345abcde";
	  glm::mat4 str;
	  slice{float} strs = str.slice();
	  for (const i: 0 .. 14U) {
	    strs[i] = static_cast{float}(s[i] - 0x20);
	  }
	  strs[14] = 0.0f;
	  strs[15] = 0.0f;
	  sn.trans = str;
//println("text object", str.slice());
	}
      }
      motion_rec(*snode, 0, 1);
      motion_count += 1 * static_cast{int}(frctl.frame_speed_mul);
      if (motion_count >= 360) {
	motion_count -= 360;
      }
    }
    frctl.save_ticks(1, SDL_GetTicks());
    {
      /* draw frame */
      pgs.cam.camera = player.posang;
      pgs.cam.light.position = pgs.cam.camera.position +
	pgs.cam.camera.angle.to_mat3() * glm::make_vec3(3.0, 3.0, 5.0);
      pgs.cam.light.angle = pgs.cam.camera.angle;
      const mess = string_join{" "}(frctl.fps, frctl.frame_speed_mul,
	frctl.ticks_sum_prev, ictl.finger_zmove_delta, pgs.cam.camera.angle);
      uint tick1;
      if (!paused) {
	tick1 = draw_frame(pgs, bos, *snode, mess);
      } else {
	tick1 = SDL_GetTicks();
      }
      frctl.save_ticks(2, tick1);
      frctl.save_ticks(3, SDL_GetTicks());
      frctl.measure();
      frctl.frame_speed_mul = static_cast{float}(rctl.fixed_fps);
    }
    {
      SDL_KeyboardState const ks;
      if (ks.Key(SDL_SCANCODE_ESCAPE) != 0) {
	done = true;
      }
      if (test_scroll_mode) {
	player.posang.rotate_angle_axis(1.0f * frctl.frame_speed_mul,
	    1.0, 0.0, 0.0);
      }
      if (ks.Key(SDL_SCANCODE_UP) != 0) {
	player.posang.rotate_angle_axis(1.0f * frctl.frame_speed_mul,
	    1.0, 0.0, 0.0);
      }
      if (ks.Key(SDL_SCANCODE_DOWN) != 0) {
	player.posang.rotate_angle_axis(-1.0f * frctl.frame_speed_mul,
	    1.0, 0.0, 0.0);
      }
      if (ks.Key(SDL_SCANCODE_LEFT) != 0) {
	player.posang.rotate_angle_axis(1.0f * frctl.frame_speed_mul,
	    0.0, 1.0, 0.0);
      }
      if (ks.Key(SDL_SCANCODE_RIGHT) != 0) {
	player.posang.rotate_angle_axis(-1.0f * frctl.frame_speed_mul,
	    0.0, 1.0, 0.0);
      }
      if (ks.Key(SDL_SCANCODE_SPACE) != 0) {
	ictl.add_zdelta(-0.001f, frctl);
      }
      if (ks.Key(SDL_SCANCODE_LSHIFT) != 0) {
	ictl.add_zdelta(0.001f, frctl);
      }
      if (ks.Key(SDL_SCANCODE_A) != 0) {
	player.posang.translate_relative(
	    glm::make_vec3(-0.05, 0.0, 0.0) * frctl.frame_speed_mul);
      }
      if (ks.Key(SDL_SCANCODE_D) != 0) {
	player.posang.translate_relative(
	    glm::make_vec3(0.05, 0.0, 0.0) * frctl.frame_speed_mul);
      }
      if (ks.Key(SDL_SCANCODE_S) != 0) {
	player.posang.translate_relative(
	    glm::make_vec3(0.0, -0.05, 0.0) * frctl.frame_speed_mul);
      }
      if (ks.Key(SDL_SCANCODE_W) != 0) {
	player.posang.translate_relative(
	    glm::make_vec3(0.0, 0.05, 0.0) * frctl.frame_speed_mul);
      }
      if (ks.Key(SDL_SCANCODE_Z) != 0) {
	player.posang.rotate_angle_axis(
	    1.0f * frctl.frame_speed_mul, 0.0, 0.0, 1.0);
      }
      if (ks.Key(SDL_SCANCODE_X) != 0) {
	player.posang.rotate_angle_axis(
	    -1.0f * frctl.frame_speed_mul, 0.0, 0.0, 1.0);
      }
      if (ks.Key(SDL_SCANCODE_RETURN) != 0) {
	ictl.finger_zmove_delta = 0.0;
	ictl.finger_zmove_mode = 1;
      }
      ictl.finger_action_step(player.posang, frctl);
    }
    frctl.save_ticks(4, SDL_GetTicks());
    rctl.delay();
    frctl.save_ticks(5, SDL_GetTicks());
    SDL_GL_SwapWindow(sdlc.sdl_window.some);
    frctl.save_ticks(6, SDL_GetTicks());
  }
}

{
  GL::base::set_check_error_enabled(1);
  try {
    main_loop();
  } catch (exception::c_exception ex) {
    sdllog(string_join{" "}("uncaught exception", ex));
  }
}

