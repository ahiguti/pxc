
セルフコンパイル
g++ -I/usr/include/bullet HelloWorld.cpp -lBulletCollision -lBulletDynamics -lLinearMath

iOSビルド
build/ios_build.sh

// collision configuration contains default setup for memory, collision setup. 
btDefaultCollisionConfiguration* collisionConfiguration =
  new btDefaultCollisionConfiguration();

// use the default collision dispatcher. For parallel processing you can
// use a diffent dispatcher (see Extras/BulletMultiThreaded)
btCollisionDispatcher* dispatcher =
  new btCollisionDispatcher(collisionConfiguration);
// btDbvtBroadphase is a good general purpose broadphase. You can also try
// out btAxis3Sweep.
btBroadphaseInterface* overlappingPairCache = new btDbvtBroadphase();

// the default constraint solver. For parallel processing you can use a
// different solver (see Extras/BulletMultiThreaded)
btSequentialImpulseConstraintSolver* solver =
  new btSequentialImpulseConstraintSolver;

btDiscreteDynamicsWorld* dynamicsWorld =
  new btDiscreteDynamicsWorld(dispatcher,overlappingPairCache,solver,
    collisionConfiguration);
dynamicsWorld->setGravity(btVector3(0,-10,0));

// create a few basic rigid bodies
btCollisionShape* groundShape = new
  btBoxShape(btVector3(btScalar(50.),btScalar(50.),btScalar(50.)));

// keep track of the shapes, we release memory at exit.
// make sure to re-use collision shapes among rigid bodies whenever possible!
btAlignedObjectArray<btCollisionShape*> collisionShapes;

collisionShapes.push_back(groundShape);

btTransform groundTransform;
groundTransform.setIdentity();
groundTransform.setOrigin(btVector3(0,-56,0));

{
  // static rigidbody
  btScalar mass(0.);

  // rigidbody is dynamic if and only if mass is non zero, otherwise static
  bool isDynamic = (mass != 0.f);
  btVector3 localInertia(0,0,0);
  if (isDynamic)
    groundShape->calculateLocalInertia(mass,localInertia);

  // using motionstate is recommended, it provides interpolation capabilities,
  //  and only synchronizes 'active' objects
  btDefaultMotionState* myMotionState = new
    btDefaultMotionState(groundTransform);
  btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,
    groundShape,localInertia);
  btRigidBody* body = new btRigidBody(rbInfo);

  // add the body to the dynamics world
  dynamicsWorld->addRigidBody(body);
}

{
  // dynamic rigidbody
  btCollisionShape* colShape = new btSphereShape(btScalar(1.));
  collisionShapes.push_back(colShape);

  btTransform startTransform;
  startTransform.setIdentity();

  btScalar        mass(1.f);

  bool isDynamic = (mass != 0.f);

  btVector3 localInertia(0,0,0);
  if (isDynamic)
    colShape->calculateLocalInertia(mass,localInertia);

  startTransform.setOrigin(btVector3(2,10,0));
                
  btDefaultMotionState* myMotionState = new
    btDefaultMotionState(startTransform);
  btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,colShape,
    localInertia);
  btRigidBody* body = new btRigidBody(rbInfo);

  dynamicsWorld->addRigidBody(body);
}

for (i=0;i<100;i++)
{
  dynamicsWorld->stepSimulation(1.f/60.f,10);
  for (int j=dynamicsWorld->getNumCollisionObjects()-1; j>=0 ;j--)
  {
    btCollisionObject* obj = dynamicsWorld->getCollisionObjectArray()[j];
    btRigidBody* body = btRigidBody::upcast(obj);
    if (body && body->getMotionState())
    {
      btTransform trans;
      body->getMotionState()->getWorldTransform(trans);
      printf("step %d obj %d world pos = %f,%f,%f\n",i, j,
        float(trans.getOrigin().getX()),float(trans.getOrigin().getY()),
        float(trans.getOrigin().getZ()));
    }
  }
}

btMotionState は {get/set}WorldTransform() だけを持つインタフェース
btDefaultMotionState は btMotionState を実装する。
  btTransform m_graphicsWorldTrans;
  btTransform m_centerOfMassOffset;
  btTransform m_startWorldTrans;
  void *m_userPointer;

btCollisionShape は 形状を表すインタフェース
- なるべくbtCollisionShapeは共有するべし
- BulletCollision/CollisionShapes/の下に様々な形状のクラス
- btSphereShape たぶん一番軽い
- btBvhTriangleMeshShape 動かない物体にのみ使える三角形メッシュ構成
- btConvexHullShape 点集合の凸包 動く物体でも使える
- 凸じゃない動く物体は凸に分割(ConvecDecompositionDemo)
- btCompoundShape 複数のshapeからなるshape

btRigidBody は btCollisionObject を実装
There are 3 types of rigid bodies: 
A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid
   body dynamics.
B) Fixed objects with zero mass. They are not moving (basically collision
   objects)
C) Kinematic objects, which are objects without mass, but the user can move
   them. There is on-way interaction, and Bullet calculates a velocity based
   on the timestep and previous and current world transform.

----------------------------------------------------------------------------

struct btScalar { }
	LinearMath/btScalar.h
struct btVector3 { }
	LinearMath/btVector3.h
struct btTransform { }
	LinearMath/btTransform.h
struct {t} btAlignedObjectArray { }
	LinearMath/btAlignedObjectArray.h
struct btDefaultCollisionConfiguration { };
	BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h
  dynamicsworldに渡す。
struct btCollisionDispatcher { }
	BulletCollision/CollisionDispatch/btCollisionDispatcher.h
  dynamicsworldに渡す。
interface btBroadphaseInterface { }
	BulletCollision/BroadphaseCollision/btBroadphaseInterface.h
struct btDbvtBroadphase <btBroadphaseInterface> { }
	BulletCollision/BroadphaseCollision/btDbvtBroadphase.h
  dynamicsworldに渡す。
struct btSequentialImpulseConstraintSolver { }
	BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h
  dynamicsworldに渡す。
struct btDiscreteDynamicsWorld { }
  空間
interface btCollisionShape { }
	BulletCollision/CollisionShapes/btCollisionShape.h
  オブジェクトの形状をあらわすインタフェース
struct btBoxShape <btCollisionShape> { }
	BulletCollision/CollisionShapes/btBoxShape.h
  立方体形状
struct btDefaultMotionState { }
	LinearMath/btDefaultMotionState.h
  オブジェクトの運動をあらわすクラス btRigidConstructionInfoに渡す
struct btRigidBody::btRigidBodyConstructionInfo { }
	BulletDynamics/Dynamics/btRigidBody.h
  btRigidBodyの構築の引数
struct btRigidBody { }
	BulletDynamics/Dynamics/btRigidBody.h
  dynamicsworldに追加する dynamicsWorld->addRigidBody()


