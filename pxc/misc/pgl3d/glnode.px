public namespace glnode "export-unsafe";
public import common -;
public import pointer::raw -;
public import numeric::fpmath -;
public import GL::glm glm;
public import GL::compat -;
public import meta m;
public import exception -;
public import glresource -;
public import glshader -;
public import glbuffer -;

public tsvaluetype struct
joint_id_type()
{
  public size_t bo_id = 0;
  public int vs_id = -1;
}

private threaded struct node_info
{
  public tree_set{joint_id_type} joint_ids;
  public tree_set{size_t} bo_ids;
}

public threaded struct {t}
scene_node(joint_id_type const& joint_id0, glm::mat4 const& trans0)
{
  public t data;
  public joint_id_type const joint_id = joint_id0;
  public glm::mat4 const trans = trans0;
  public varray{ptr{scene_node{t}}} children;
}

public function {t, finst} ptr{scene_node{t}}
instantiate_scene_by_name(cslice{ptr{vertex_buffer}} const& bos,
  cstrref const& name, glm::mat4 const& tr)
{
  for (size_t bo_id, const& bop: bos) {
    const& bo = *bop;
    if (bo.has_name(name)) {
      joint_id_type joint_id;
      joint_id.bo_id = bo_id;
      joint_id.vs_id = static_cast{int}(bo.get_id_by_name(name));
      return instantiate_scene{t, finst}(bos, joint_id, tr);
    }
  }
  throw runtime_error_template{"instantiate_scene_by_name"}(name);
}

public function {t, finst} ptr{scene_node{t}}
instantiate_scene(cslice{ptr{vertex_buffer}} const& bos,
  joint_id_type const& joint_id, glm::mat4 const& tr)
{
  const sn = make_ptr{scene_node{t}}(joint_id, tr);
  if (joint_id.vs_id >= 0) {
    const& vs = *bos[joint_id.bo_id]->get_by_id(static_cast{size_t}(
      joint_id.vs_id));
    for (size_t i, const& e: vs.vtxs->joints) {
      const csn = instantiate_scene_by_name{t, finst}(
	bos, e.joint_name, e.trans);
      sn->children.push_back(csn);
    }
  }
  finst(*sn);
  return sn;
}

public function {t} void
buffer_append(varray{float} mutable& arr, t const& v)
{
  if (m::eq{t, float}) {
    arr.push_back(v);
  } else if (m::or{
    m::eq{t, glm::vec2},
    m::eq{t, glm::vec3},
    m::eq{t, glm::vec4},
    m::eq{t, glm::mat2},
    m::eq{t, glm::mat3},
    m::eq{t, glm::mat4}}) {
    arr.append(v.cslice());
  } else {
    expand (sym: m::field_names{t})
    {
      buffer_append(arr, v.sym);
    }
  }
}

public function {t} void
scene_node_send_instance_data(scene_node{t} const& sn,
  cslice{ptr{vertex_buffer}} const& bos, instance_buffer_type mutable& gibuf,
  bool enable_instanced, bool enable_uniform_instancing)
{
  if (enable_instanced && !enable_uniform_instancing) {
    size_t offset_float = 0;
    for (const bo_id, const& bo: bos) {
      for (const vs_id, const& vs: bo->instances) {
	for (const i, const& instp: vs) {
	  mutable& inst = *instp;
	  mutable& arr = inst.instance_buffer;
	  /*
	  glBindBuffer(GL_ARRAY_BUFFER, inst.vbo_inst.get());
	  glBufferData(GL_ARRAY_BUFFER,
	    static_cast{GLsizeiptr}(arr.size()) * 4,
	    size_t_to_crawptr{void}(0), GL_STREAM_DRAW);
	  */
	  /*
	  glBufferData(GL_ARRAY_BUFFER,
	    static_cast{GLsizeiptr}(arr.size()) * 4,
	    arr.crawptr().void(), GL_STREAM_DRAW); // FIXME: SINGLEBUFFER
	  glBindBuffer(GL_ARRAY_BUFFER, 0);
	  */
	  /*
	  // FIXME: don't use gibuf.instance_buffer
	  inst.glbuffer_offset_float = gibuf.instance_buffer.size();
	  gibuf.instance_buffer.append(arr);
	  */
	  // FIXME: TEST
	  inst.glbuffer_offset_float = offset_float;
//debug_log("offset_float", offset_float, "sz", arr.size(), "bo", bo_id, "vs", vs_id, "i", i);
	  offset_float += arr.size();
	  /*
	  */
	}
      }
    }
    mutable& cur_buf = *gibuf.get_current();
    const size_t total_size_float = offset_float;
    offset_float = 0;
    cur_buf.client_wait_sync(1000000000U * 10U);
    cur_buf.map_buffer(total_size_float * 4U);
    const rawptr{float} mapped_ptr = cur_buf.mapped_ptr;
//debug_log("mapped_ptr", mapped_ptr, total_size_float * 4U);
    for (const bo_id, const& bo: bos) {
      for (const vs_id, const& vs: bo->instances) {
	for (const i, const& instp: vs) {
	  mutable& inst = *instp;
	  mutable& arr = inst.instance_buffer;
	  const size_t sz = arr.size();
	  const sli = rawptr_to_slice{float}(mapped_ptr + offset_float, sz);
	  for (const j: 0 .. sz) {
	    sli[j] = arr[j];
	  }
	  offset_float += sz;
	}
      }
    }
    cur_buf.unmap_buffer();
    /*
    glBindBuffer(GL_ARRAY_BUFFER, cur_buf.vbo.get());
debug_log("bufferdata", gibuf.instance_buffer.size(), gibuf.async_buffer_current, cur_buf.vbo.get());
    glBufferData(GL_ARRAY_BUFFER,
      static_cast{GLsizeiptr}(gibuf.instance_buffer.size()) * 4,
      gibuf.instance_buffer.crawptr().void(), GL_STREAM_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    gibuf.instance_buffer.clear();
    */
  }
}

public function {t} void
scene_node_finished_using_instance_data(scene_node{t} const& sn,
  cslice{ptr{vertex_buffer}} const& bos, instance_buffer_type mutable& gibuf,
  bool enable_instanced, bool enable_uniform_instancing)
{
  if (enable_instanced && !enable_uniform_instancing) {
    gibuf.get_current()->fence_sync();
    gibuf.switch_buffer();
  }
}

public function {t} void
scene_node_draw_instanced(scene_node{t} const& sn,
  shader_i mutable& sdr, vertex_buffer const& bo,
  instance_buffer_type mutable& gibuf, size_t bo_id,
  size_t ibuf_id, bool enable_instanced, bool enable_uniform_instancing)
{
//println("draw_instanced", bo_id);
  bo.draw_pre(sdr);
  if (enable_instanced && !enable_uniform_instancing) {
    sdr.enable_instance_attrib_array(true);
    // glBindBuffer(GL_ARRAY_BUFFER, gibuf.vbo_inst.get());
    glBindBuffer(GL_ARRAY_BUFFER, gibuf.get_current()->vbo.get());
  }
  for (const vs_id: 0 .. bo.num_vs()) {
    mutable& instance = *bo.instances[static_cast{size_t}(vs_id)][ibuf_id];
    mutable& arr = instance.instance_buffer;
    // println("draw_elems", ji.bo_id, ji.vs_id, "model=", arr.size());
    if (enable_instanced && !enable_uniform_instancing) {
      if (m::ne{is_gl3_or_gles3, 0}) {
	// println("vattr instancing");
	/*
	glBindBuffer(GL_ARRAY_BUFFER, instance.vbo_inst.get());
	*/
	sdr.instance_attrib_pointer(instance.glbuffer_offset_float);
//debug_log("draw_elems_instanced", vs_id, gibuf.async_buffer_current, gibuf.get_current()->vbo.get());
	bo.draw_elems_instanced(static_cast{size_t}(vs_id),
	  arr.size() / sdr.instance_attrib_num_float());
	/*
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	*/
      }
    } else if (enable_uniform_instancing) {
      size_t const iattr_num_float = sdr.instance_attrib_num_float();
      size_t j;
      size_t const jmax = arr.size();
//println("bo", bo_id, "iattr_num_float", iattr_num_float, jmax);
      for (j = 0; j < jmax; j += iattr_num_float * uniform_instancing_mul) {
	size_t k = min((jmax - j) / iattr_num_float, uniform_instancing_mul);
	sdr.instance_attrib_set_uniform(arr, j, k);
	bo.draw_elems_instanced(static_cast{size_t}(vs_id), k);
      }
    } else {
      size_t const iattr_num_float = sdr.instance_attrib_num_float();
      size_t j;
      size_t const jmax = arr.size();
      const& be = *bo.get_by_id(static_cast{size_t}(vs_id));
      const inst_mul = be.vtxs->num_copies;
//println("bo", bo_id, "iattr_num_float", iattr_num_float, jmax);
      for (j = 0; j < jmax; j += iattr_num_float * inst_mul) {
	size_t k = min((jmax - j) / iattr_num_float, inst_mul);
	sdr.instance_attrib_set_uniform(arr, j, k);
	bo.draw_elems(static_cast{size_t}(vs_id), k);
      }
      /*
      for (j = 0; j < jmax; j += iattr_num_float) {
	sdr.instance_attrib_set_uniform(arr, j, 1);
	bo.draw_elems(static_cast{size_t}(vs_id), 1);
      }
      */
    }
  }
  if (enable_instanced && !enable_uniform_instancing) {
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    sdr.enable_instance_attrib_array(false);
  }
  bo.draw_post(sdr);
}

