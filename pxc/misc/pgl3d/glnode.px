public namespace glnode "export-unsafe";
public import common -;
public import numeric::fpmath -;
public import GL::glm glm;
public import meta m;
public import exception -;

public import pointer::raw -;
public import GL::compat -;
public import glresource -;
public import glshader -;
public import glbuffer -;

public tsvaluetype struct
joint_id_type()
{
  public size_t bo_id = 0;
  public int vs_id = -1;
}

private threaded struct node_info
{
  public tree_set{joint_id_type} joint_ids;
  public tree_set{size_t} bo_ids;
}

public threaded struct {t}
scene_node(joint_id_type const& joint_id0, glm::mat4 const& trans0)
{
  public t data;
  public joint_id_type const joint_id = joint_id0;
  public glm::mat4 const trans = trans0;
  public varray{ptr{scene_node{t}}} children;
}

public mtvaluetype struct
node_factory
{
  public varray{node_buffer_info} binfo;
  public tree_map{string, joint_id_type} name_to_id;
  public function void prepare(cslice{ptr{vertex_buffer}} const& bos)
  {
    for (size_t bo_id, const& bop: bos) {
      for (const& n, const id: bop->vs_names) {
	joint_id_type jid;
	jid.bo_id = bo_id;
	jid.vs_id = static_cast{int}(id);
	name_to_id[n] = jid;
      }
      binfo.push_back(node_buffer_info());
      node_buffer_info mutable& nbi = binfo[binfo.size() - 1];
      for (const i, const& vsp: bop->vs_arr) {
	nbi.vs_arr.push_back(node_vs_info());
	node_vs_info mutable& nvi = nbi.vs_arr[nbi.vs_arr.size() - 1];
	for (const j, const& nj: vsp->vtxs->joints) {
	  node_joint_info nji;
	  nji.joint_id = bos_name_to_id(bos, nj.joint_name);
	  nji.trans = nj.trans;
	  nvi.joints.push_back(nji);
	}
      }
    }
  }
  public function {tnodedata, tinit} ptr{scene_node{tnodedata}}
  make_node_by_id(joint_id_type const& joint_id, glm::mat4 const& trans) const
  {
    const sn = make_ptr{scene_node{tnodedata}}(joint_id, trans);
    if (joint_id.vs_id >= 0) {
      const& nbi = binfo[joint_id.bo_id];
      const& nvi = nbi.vs_arr[static_cast{size_t}(joint_id.vs_id)];
      for (const i, const& nji: nvi.joints) {
	const csn = make_node_by_id{tnodedata, tinit}(nji.joint_id, nji.trans);
	sn->children.push_back(csn);
      }
    }
    tinit(*sn);
    return sn;
  }
  public function {tnodedata, tinit} ptr{scene_node{tnodedata}}
  make_node_by_name(cstrref const& name, glm::mat4 const& trans) const
  {
    const rng = name_to_id.equal_crange(name);
    return make_node_by_id{tnodedata, tinit}(*rng, trans);
  }
  public function joint_id_type get_joint_id_by_name(cstrref const& name) const
  {
    const rng = name_to_id.equal_crange(name);
    return *rng;
  }
}

private threaded function joint_id_type
bos_name_to_id(cslice{ptr{vertex_buffer}} const& bos, cstrref const& name)
{
  joint_id_type jid;
  for (const i, const& bo: bos) {
    if (bo->has_name(name)) {
      jid.bo_id = i;
      jid.vs_id = static_cast{int}(bo->get_id_by_name(name));
      break;
    }
  }
  return jid;
}

public mtvaluetype struct
node_buffer_info
{
  public varray{node_vs_info} vs_arr;
}

public mtvaluetype struct
node_vs_info
{
  public varray{node_joint_info} joints;
}

public tsvaluetype struct
node_joint_info
{
  public joint_id_type joint_id;
  public glm::mat4 trans;
}

public threaded struct node_data
{
  public glm::mat4 trans_initial;
  public glm::mat4 trans_cur;
}

public threaded function void
node_init(scene_node{node_data} mutable& sn)
{
  sn.data.trans_initial = sn.trans;
  sn.data.trans_cur = sn.trans;
}

