public namespace glnode "export-unsafe";
public import common -;
public import pointer::raw -;
public import numeric::fpmath -;
public import GL::glm glm;
public import GL::compat -;
public import meta m;
public import exception -;
public import glresource -;
public import glshader -;
public import glbuffer -;

public tsvaluetype struct joint_id_type()
{
  public size_t bo_id;
  public int vs_id = -1;
}

public threaded struct scene_node()
{
  public joint_id_type joint_id;
  public glm::mat4 trans;
  public glm::mat4 trans_initial;
  public varray{ptr{scene_node}} children;
  public tree_set{joint_id_type} joint_ids;
    /* possible joint ids incl children */
  public tree_set{size_t} bo_ids; /* possible buffer ids incl children */
}

public function ptr{scene_node}
instantiate_scene_by_name(cslice{ptr{buffer_object}} const& bos,
  cstrref const& name)
{
  for (size_t bo_id, const& bop: bos) {
    const& bo = *bop;
    if (bo.has_name(name)) {
      joint_id_type joint_id;
      joint_id.bo_id = bo_id;
      joint_id.vs_id = static_cast{int}(bo.get_id_by_name(name));
      return instantiate_scene(bos, joint_id);
    }
  }
  throw runtime_error_template{"instantiate_scene_by_name"}(name);
}

public function ptr{scene_node}
instantiate_scene(cslice{ptr{buffer_object}} const& bos,
  joint_id_type const& joint_id)
{
  const r = make_ptr{scene_node}();
  r->joint_id = joint_id;
  if (joint_id.vs_id >= 0) {
    r->joint_ids[joint_id] = unit();
    r->bo_ids[joint_id.bo_id] = unit();
    const& vs = *bos[joint_id.bo_id]->get_by_id(static_cast{size_t}(
      joint_id.vs_id));
    for (size_t i, const& e: vs.vtxs->joints) {
      const p = instantiate_scene_by_name(bos, e.joint_name);
      p->trans = e.trans;
      p->trans_initial = e.trans;
      r->children.push_back(p);
      for (const i, const x: p->joint_ids) {
	r->joint_ids[i] = unit();
      }
      for (const i, const x: p->bo_ids) {
	r->bo_ids[i] = unit();
      }
    }
  }
  return r;
}

private function {t} void
buffer_append(varray{float} mutable& arr, t const& v)
{
  if (m::eq{t, float}) {
    arr.push_back(v);
  } else if (m::or{
    m::eq{t, glm::vec2},
    m::eq{t, glm::vec3},
    m::eq{t, glm::vec4},
    m::eq{t, glm::mat2},
    m::eq{t, glm::mat3},
    m::eq{t, glm::mat4}}) {
    arr.append(v.cslice());
  } else {
    expand (sym: m::field_names{t})
    {
      buffer_append(arr, v.sym);
    }
  }
}

private function {tinst} void
scene_node_push_instance_rec(scene_node const& sn, tinst const& iattr,
  cslice{ptr{buffer_object}} const& bos, size_t bo_id)
{
  if (!sn.bo_ids.exists(bo_id)) {
    return;
  }
  const ia = iattr.apply(sn);
  const& bo = bos[sn.joint_id.bo_id];
  mutable& instance = *bo->instances[static_cast{size_t}(sn.joint_id.vs_id)];
  mutable& arr = instance.client_buffer;
  if (sn.joint_id.bo_id == bo_id) {
    buffer_append(arr, ia);
  }
  for (const i, const& snp: sn.children) {
    scene_node_push_instance_rec(*snp, ia, bos, bo_id);
  }
}

public function {tinst} void
scene_node_instances_set_data(scene_node const& sn,
  cslice{ptr{buffer_object}} const& bos, size_t bo_id,
  tinst const& iattr, bool enable_instanced)
{
  for (const ji, const x: sn.joint_ids) {
    if (ji.bo_id != bo_id) {
      continue;
    }
    const& bo = bos[ji.bo_id];
    mutable& instance = *bo->instances[static_cast{size_t}(ji.vs_id)];
    mutable& arr = instance.client_buffer;
    arr.clear();
  }
  /* prepare client_buffer */
  scene_node_push_instance_rec(sn, iattr, bos, bo_id);
  if (enable_instanced) {
    /* copy client_buffer to vbo_inst */
    for (const ji, const x: sn.joint_ids) {
      if (ji.bo_id != bo_id) {
	continue;
      }
      const& bo = bos[ji.bo_id];
      mutable& instance = *bo->instances[static_cast{size_t}(ji.vs_id)];
      mutable& arr = instance.client_buffer;
      glBindBuffer(GL_ARRAY_BUFFER, instance.vbo_inst.get());
      glBufferData(GL_ARRAY_BUFFER, static_cast{GLsizeiptr}(arr.size()) * 4,
	arr.crawptr().void(), GL_STREAM_DRAW);
      glBindBuffer(GL_ARRAY_BUFFER, 0);
    }
  }
}

public function {tshaders} void
scene_node_draw_instanced(scene_node const& sn,
  tshaders const& sdrs, cslice{ptr{buffer_object}} const& bos,
  bool enable_instanced)
{
  expand (sym, i: m::field_names{tshaders}) {
    if (m::ne{m::at{m::field_types{tshaders}, i}, unit}) {
      scene_node_draw_instanced_internal(sn, *sdrs.sym, *bos[i], i,
	enable_instanced);
    }
  }
}

private function void
scene_node_draw_instanced_internal(scene_node const& sn,
  shader_i mutable& sdr, buffer_object const& bo, size_t bo_id,
  bool enable_instanced)
{
  bo.draw_pre(sdr);
  if (enable_instanced) {
    sdr.enable_instance_attrib_array(true);
  }
  for (const ji, const x: sn.joint_ids) {
    if (ji.bo_id != bo_id) {
      continue;
    }
    mutable& instance = *bo.instances[static_cast{size_t}(ji.vs_id)];
    mutable& arr = instance.client_buffer;
    // println("draw_elems", ji.bo_id, ji.vs_id, "model=", arr.size());
    if (enable_instanced) {
      if (m::ne{is_gl3, 0}) {
	glBindBuffer(GL_ARRAY_BUFFER, instance.vbo_inst.get());
	sdr.instance_attrib_pointer();
	bo.draw_elems_instanced(static_cast{size_t}(ji.vs_id),
	  arr.size() / 16);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
      }
    } else {
      size_t const iattr_num_float = sdr.instance_attrib_num_float();
      size_t j;
      size_t const jmax = arr.size();
      // println("iattr_num_float", iattr_num_float, jmax);
      for (j = 0; j < jmax; j += iattr_num_float) {
	sdr.instance_attrib_set_uniform(arr, j);
	bo.draw_elems(static_cast{size_t}(ji.vs_id));
      }
    }
  }
  if (enable_instanced) {
    sdr.enable_instance_attrib_array(false);
  }
  bo.draw_post(sdr);
}

