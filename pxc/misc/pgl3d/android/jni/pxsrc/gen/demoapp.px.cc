#define PXC_PROFILE_incdir "/usr/local/share/pxc/pxc_core:/usr/share/pxc/pxc_core:/usr/local/share/pxc/pxc_ext:/usr/share/pxc/pxc_ext:."
#define PXC_PROFILE_platform "android"
#define PXC_PROFILE_safe_mode "0"
#define PXC_PROFILE_show_warnings ""
/* type definitions */
/* inline */

#if PXC_PROFILE_noexceptions
#define PXC_NOEXCEPTIONS 1
#define PXC_THROW(x) ::abort();
#define PXC_TRY
#define PXC_CATCH(x) if(0)
#define PXC_NOTHROW throw()
#define PXC_RETHROW
#define BOOST_NO_EXCEPTIONS
#else
#define PXC_THROW(x) throw x;
#define PXC_TRY try
#define PXC_CATCH(x) catch(x)
#define PXC_NOTHROW throw()
#define PXC_RETHROW throw
#endif

#if defined(_MSC_VER)
#define PXC_MSVC
#define PXC_WINDOWS
#else
#define PXC_POSIX
#endif

#if defined(PXC_MSVC)
#pragma warning(disable: 4521 4522 4146)
#define SSIZE_MAX _I64_MAX
#include <windows.h>
#include <malloc.h>
#undef min
#undef max
#define alloca _alloca
#if _MSC_VER < 1900
#define snprintf _snprintf
#endif
#endif

#include <stdint.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <climits>
#include <stdexcept>
#include <atomic>

#ifdef PXC_POSIX
#include <alloca.h>
#endif

#if defined(PXC_MSVC)
#define __attribute__(x)
#define PXC_NO_INLINE __declspec(noinline)
#define PXC_FORCE_INLINE __forceinline
#else
#define PXC_NO_INLINE __attribute__((noinline))
#define PXC_FORCE_INLINE inline
#endif

#ifdef BOOST_NO_EXCEPTIONS
namespace boost {
template <typename T> void throw_exception(T const& x) { ::abort(); }
};
#endif

#include <boost/type_traits/is_pod.hpp>
#include <boost/static_assert.hpp>

namespace pxcrt {

struct bt_unit { };
extern bt_unit unit_value; /* used when a reference is required */
extern char **process_argv; /* set by int main(int argc, char **argv) */
typedef bool bt_bool;
typedef unsigned char bt_uchar;
typedef char bt_char;
typedef signed char bt_schar;
typedef unsigned short bt_ushort;
typedef short bt_short;
typedef unsigned int bt_uint;
typedef int bt_int;
typedef unsigned long bt_ulong;
typedef long bt_long;
typedef unsigned long long bt_ulonglong;
typedef long long bt_longlong;
typedef ::size_t bt_size_t;
#if defined(PXC_MSVC)
#include <BaseTsd.h>
typedef SSIZE_T bt_ssize_t;
#else
typedef ::ssize_t bt_ssize_t;
#endif
typedef float bt_float;
typedef double bt_double;
struct bt_tpdummy;

struct mtcount { /* reference counter for multi-threaded shared objects */
#if defined(PXC_MSVC)
  mtcount(long x = 1) { std::atomic_init(&count$z, 1); }
  mtcount(const mtcount& x) { std::atomic_init(&count$z, 1); }
#else
  mtcount(long x = 1) : count$z(1) { }
  mtcount(const mtcount& x) : count$z(1) { }
#endif
  mtcount& operator =(const mtcount& x) { return *this; }
  void incref$z() {
    std::atomic_fetch_add_explicit(&count$z, 1L, std::memory_order_relaxed);
  }
  bool decref$z() {
    if (std::atomic_fetch_sub_explicit(&count$z, 1L, std::memory_order_release)
      == 1) {
      std::atomic_thread_fence(std::memory_order_acquire);
      return true;
    }
    return false;
  }
  long refcnt$z() const { return count$z.load(std::memory_order_seq_cst); }
private:
  std::atomic_long count$z;
};

struct stcount { /* reference counter for single-threaded shared objects */
  stcount(long x = 1) : count$z(1) { }
  stcount(const stcount& x) : count$z(1) { }
  stcount& operator =(const stcount& x) { return *this; }
  void incref$z() { ++count$z; }
  bool decref$z() { return (--count$z == 0); }
  long refcnt$z() const { return count$z; }
private:
  long count$z;
};

}; // namespace pxcrt
// extern "types" inline
;
/* inline */

/* workaround for boost/cstdint.hpp:52 */
#ifndef __GLIBC_PREREQ
#define __GLIBC_PREREQ(x, y) 0
#endif
#include <boost/cast.hpp>

namespace numeric {
template <typename Tto, typename Tfrom> struct numeric_cast_impl {
  Tto convert(Tfrom const& x) const {
    return boost::numeric_cast<Tto>(x);
  }
};
template <typename Tto, typename Tfrom> struct static_cast_impl {
  Tto convert(Tfrom const& x) const {
    return static_cast<Tto>(x);
  }
};
}; // namespace numeric
;
/* inline */

#ifdef PXCRT_DBG_POOL
#define DBG_POOL(x) x
#else
#define DBG_POOL(x)
#endif

#if defined(__APPLE__) && !defined(PXCRT_NO_LOCAL_POOL)
#define PXCRT_NO_LOCAL_POOL
#endif
#if defined(PXC_WINDOWS) && !defined(PXCRT_NO_LOCAL_POOL)
#define PXCRT_NO_LOCAL_POOL
#endif
#if defined(ANDROID) && !defined(PXCRT_NO_LOCAL_POOL)
#define PXCRT_NO_LOCAL_POOL
#endif

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <stdexcept>
#include <memory>

namespace pxcrt {

static inline void *global_allocate_n(size_t sz)
{
  void *const p = malloc(sz);
  if (p == 0) {
    throw std::bad_alloc();
  }
  return p;
}

static inline void *global_reallocate_n(void *optr, size_t osz, size_t nsz)
{
  void *const p = realloc(optr, nsz);
  if (p == 0) {
    throw std::bad_alloc();
  }
  return p;
}

static inline void global_deallocate_n(void *ptr, size_t sz)
{
  free(ptr);
}

void clear_local_pool();

#ifndef PXCRT_NO_LOCAL_POOL

/* thread-local allocator */

extern thread_local void *local_pool_blocks;

enum {
  local_pool_block_size = 2000,
  local_pool_block_alloc_size = local_pool_block_size + sizeof(void *)
};

template <size_t sz> struct local_pool
{
  static void *allocate() {
    if (free_list != 0) {
      void *r = free_list;
      free_list = *(void **)free_list;
      DBG_POOL(fprintf(stderr, "a %zu %p\n", sz, r));
      return r;
    }
    extend();
    void *r = free_list;
    free_list = *(void **)free_list;
    DBG_POOL(fprintf(stderr, "A %zu %p\n", sz, r));
    return r;
  }
  static void deallocate(void *p) {
    DBG_POOL(fprintf(stderr, "d %zu %p\n", sz, p));
    append_free_list(p);
  }
  static void append_free_list(void *p) {
    *(void **)p = free_list;
    free_list = p;
  }
private:
  static void extend() {
    DBG_POOL(fprintf(stderr, "X %zu\n", sz));
    char *b = (char *)global_allocate_n(local_pool_block_alloc_size);
    *(void **)(b) = local_pool_blocks;
    local_pool_blocks = b;
    b += sizeof(void *);
    size_t const bsz = local_pool_block_size / sz;
    for (size_t i = 0; i < bsz; ++i) {
      append_free_list(b + i * sz);
    }
  }
private:
  static thread_local void *free_list;
};

template <size_t sz> thread_local void *local_pool<sz>::free_list = 0;

template <bool is_small> struct local_pool_allocator;

template <size_t sz, size_t seg, bool fit> struct local_pool_segment_size;

template <size_t sz, size_t seg>
struct local_pool_segment_size<sz, seg, true> {
  enum { value = seg };
};

template <size_t sz, size_t seg>
struct local_pool_segment_size<sz, seg, false> {
  enum { nfit = (sz <= seg * 2) };
  enum { value = local_pool_segment_size<sz, seg * 2, nfit>::value };
};

template <> struct local_pool_allocator<true>
{
  template <size_t sz> static void *allocate() {
    /* 8, 16, 32, 64, ... */
    enum { pool_block_sz = local_pool_segment_size<sz, 4, false>::value };
    return local_pool<pool_block_sz>::allocate();
  }
  template <size_t sz> static void deallocate(void *ptr) {
    enum { pool_block_sz = local_pool_segment_size<sz, 4, false>::value };
    return local_pool<pool_block_sz>::deallocate(ptr);
  }
};

template <> struct local_pool_allocator<false>
{
  template <size_t sz> static void *allocate() {
    return global_allocate_n(sz);
  }
  template <size_t sz> static void deallocate(void *ptr) {
    global_deallocate_n(ptr, sz);
  }
};

template <typename T> static inline T *local_allocate()
{
  enum { is_small = sizeof(T) <= 64 ? true : false };
  return static_cast<T *>(
    local_pool_allocator<is_small>::template allocate<sizeof(T)>());
}

template <typename T> static inline void local_deallocate(const T *ptr)
{
  enum { is_small = sizeof(T) <= 64 ? true : false };
  local_pool_allocator<is_small>::template deallocate<sizeof(T)>(
    const_cast<T *>(ptr));
}

enum { use_local_threshold = 64 };

static inline void *local_allocate_n(size_t sz)
{
  if (sz <= use_local_threshold) {
    return local_pool_allocator<true>::allocate<use_local_threshold>();
  } else {
    return global_allocate_n(sz);
  }
}

static inline void *local_reallocate_n(void *optr, size_t osz, size_t nsz)
{
  if (osz <= use_local_threshold) {
    if (nsz <= use_local_threshold) {
      return optr;
    } else {
      void *nptr = global_allocate_n(nsz);
      memcpy(nptr, optr, osz);
      local_pool_allocator<true>::deallocate<use_local_threshold>(optr);
      return nptr;
    }
  } else {
    if (nsz <= use_local_threshold) {
      void *nptr = local_pool_allocator<true>::allocate<use_local_threshold>();
      memcpy(nptr, optr, nsz);
      global_deallocate_n(optr, osz);
      return nptr;
    } else {
      return global_reallocate_n(optr, osz, nsz);
    }
  }
}

static inline void local_deallocate_n(void *ptr, size_t sz)
{
  if (sz <= use_local_threshold) {
    local_pool_allocator<true>::deallocate<use_local_threshold>(ptr);
  } else {
    global_deallocate_n(ptr, sz);
  }
}

#else

template <typename T> static inline T *local_allocate()
{
  return static_cast<T *>(global_allocate_n(sizeof(T)));
}

template <typename T> static inline void local_deallocate(const T *ptr)
{
  return global_deallocate_n(const_cast<T *>(ptr), sizeof(T));
}

static inline void *local_allocate_n(size_t sz)
{
  return global_allocate_n(sz);
}

static inline void *local_reallocate_n(void *optr, size_t osz, size_t nsz)
{
  return global_reallocate_n(optr, osz, nsz);
}

static inline void local_deallocate_n(void *ptr, size_t sz)
{
  global_deallocate_n(ptr, sz);
}

#endif

template <typename T> static inline T *allocate_single()
{
  return reinterpret_cast<T *>(global_allocate_n(sizeof(T)));
}

template <typename T> static inline void deallocate_single(const T *ptr)
{
  global_deallocate_n(const_cast<T *>(ptr), sizeof(T));
}

}; // namespace pxcrt
;
/* inline */

#if 0
#define PXC_NO_BOUNDS_CHECKING 1
#else
#undef PXC_NO_BOUNDS_CHECKING
#endif

#include <algorithm>
#include <type_traits>

namespace pxcrt {

void throw_bad_alloc();
void throw_would_invalidate();
void throw_invalid_index();

/* alternative to uninitialized_* functions. optimized for pod types. */

template <typename T> struct is_trivially_copyable {
  enum { value = boost::is_pod<T>::value };
  // enum { value = std::is_trivially_copyable<T>::value };
};

template <typename T, bool copy_flag> struct placement_new;
template <typename T> struct placement_new<T, true>
{ void operator ()(T *dest, const T& src) { new (dest) T(src); }; };
template <typename T> struct placement_new<T, false>
{ void operator ()(T *dest, T& src) { new (dest) T(std::move(src)); }; };

template <typename T, bool copy_flag> struct copy_or_move;
template <typename T> struct copy_or_move<T, true>
{ void operator ()(T& dest, const T& src) { dest = src; }; };
template <typename T> struct copy_or_move<T, false>
{ void operator ()(T& dest, T& src) { dest = src; }; };

/*
template <typename T, bool copyable> struct add_const_if_not;
template <typename T> struct add_const_if_not<T, false>
{ typedef const T type; };
template <typename T> struct add_const_if_not<T, true>
{ typedef T type; };
*/

template <typename T> PXC_FORCE_INLINE void
deallocate_uninitialized(T *ptr, size_t len)
{
  global_deallocate_n(ptr, len * sizeof(T));
}

template <typename T> PXC_FORCE_INLINE T *
allocate_uninitialized(size_t len)
{
  void *p = global_allocate_n(len * sizeof(T));
  return static_cast<T *>(p);
}

template <typename T> PXC_FORCE_INLINE void
deinitialize_n(T *ptr, size_t len)
{
  if (!is_trivially_copyable<T>::value) {
    for (T *p = ptr + len; p != ptr; --p) {
      (p - 1)->T::~T();
    }
  }
}

template <typename T> PXC_FORCE_INLINE void
deinitialize_1(T *ptr)
{
  if (!is_trivially_copyable<T>::value) {
    ptr->T::~T();
  }
}

template <typename T, typename Tsrc> PXC_FORCE_INLINE void
initialize_fill_n(T *ptr, size_t len, Tsrc& x)
{
  if (is_trivially_copyable<T>::value) {
    for (size_t i = 0; i < len; ++i) {
      ptr[i] = x;
    }
  } else {
    size_t i = 0;
    PXC_TRY {
      for (; i < len; ++i) {
	/* new (ptr + i) T(x); */
	placement_new<T, std::is_const<Tsrc>::value>()(ptr + i, x);
      }
    } PXC_CATCH(...) {
      deinitialize_n(ptr, i);
      PXC_RETHROW;
    }
  }
}

template <typename T, typename Tsrc> PXC_FORCE_INLINE void
initialize_copymove_n(T *ptr, size_t len, Tsrc *src)
{
  if (is_trivially_copyable<T>::value) {
    memcpy(ptr, src, len * sizeof(T));
  } else {
    size_t i = 0;
    PXC_TRY {
      for (; i < len; ++i) {
	/* new (ptr + i) T(src[i]); */
	placement_new<T, std::is_const<Tsrc>::value>()(ptr + i, src[i]);
      }
    } PXC_CATCH(...) {
      deinitialize_n(ptr, i);
      PXC_RETHROW;
    }
  }
}

template <typename T, typename Tsrc> PXC_FORCE_INLINE void
initialize_1(T *ptr, Tsrc& x)
{
  if (is_trivially_copyable<T>::value) {
    *ptr = x;
  } else {
    /* new (ptr) T(x); */
    placement_new<T, std::is_const<Tsrc>::value>()(ptr, x);
  }
}

template <typename T> PXC_FORCE_INLINE T *
reserve_n(T *ptr, size_t vlen, size_t alloc_olen, size_t alloc_nlen)
{
  if (is_trivially_copyable<T>::value) {
    void *p = global_reallocate_n(ptr, alloc_olen * sizeof(T),
      alloc_nlen * sizeof(T));
    return static_cast<T *>(p);
  } else {
    T *p = allocate_uninitialized<T>(alloc_nlen);
    PXC_TRY {
      /* Tsrc is const if T is not move-constructible */
      /*
      typedef typename
	add_const_if_not<T, std::is_move_constructible<T>::value>::type Tsrc;
      initialize_copymove_n<T, Tsrc>(p, vlen, ptr);
      */
      initialize_copymove_n<T, T>(p, vlen, ptr);
    } PXC_CATCH(...) {
      deallocate_uninitialized<T>(p, alloc_nlen);
      PXC_RETHROW;
    }
    deinitialize_n(ptr, vlen);
    deallocate_uninitialized<T>(ptr, vlen);
    return p;
  }
}

template <typename T, typename Tsrc> PXC_FORCE_INLINE void
copymove_n(T *ptr, size_t len, Tsrc *src)
{
  if (is_trivially_copyable<T>::value) {
    memmove(ptr, src, len * sizeof(T));
  } else {
    for (size_t i = 0; i < len; ++i) {
      /* ptr[i] = src[i]; */
      copy_or_move<T, std::is_const<Tsrc>::value>()(ptr[i], src[i]);
    }
  }
}

template <typename T, typename Tsrc> PXC_FORCE_INLINE void
copymove_backward_n(T *ptr, size_t len, Tsrc *src)
{
  if (is_trivially_copyable<T>::value) {
    memmove(ptr, src, len * sizeof(T));
  } else {
    for (size_t i = len; i > 0; --i) {
      copy_or_move<T, std::is_const<Tsrc>::value>()(ptr[i - 1], src[i - 1]);
    }
  }
}

template <typename T, typename Tsrc> PXC_FORCE_INLINE void
insert_n(T *x, size_t& xlen, Tsrc *y, size_t ylen, size_t xpos)
  /* xlen is modified so that it is always the size of initialized range */
{
  /* x[0 .. xlen] must be initialized, and x[xlen .. xlen + ylen]
   * uninitialized */
  const size_t olen = xlen;
  const size_t nlen = olen + ylen;
  if (olen - xpos >= ylen) {
    /* moving size >= ylen */
    /* append from x */
    initialize_copymove_n<T, Tsrc>(x + xlen, ylen, x + olen - ylen);
    xlen = nlen;
    /* move */
    copymove_backward_n<T, Tsrc>(x + xpos + ylen, olen - ylen - xpos, x + xpos);
    /* copy from y */
    copymove_n(x + xpos, ylen, y);
  } else {
    /* moving size < ylen */
    /* append from y */
    initialize_copymove_n(x + xlen, ylen - (olen - xpos), y + (olen - xpos));
    xlen = xpos + ylen;
    /* append from x */
    initialize_copymove_n<T, Tsrc>(x + xlen, olen - xpos, x + xpos);
    xlen = nlen;
    /* copy from y */
    copymove_n(x + xpos, olen - xpos, y);
  }
}

/* utility functions for array types */

template <typename T> static PXC_FORCE_INLINE bt_size_t
array_find(const T *arr, bt_size_t len, bt_size_t offset, T const& value)
{
  if (offset >= len) {
    return len;
  }
  if (sizeof(T) == 1) {
    const T *const p = static_cast<const T *>(
      ::memchr(arr + offset, value, len - offset));
    return p != 0 ? (p - arr) : len;
  } else {
    bt_size_t i = offset;
    for (; i < len && arr[i] != value; ++i) { }
    return i;
  }
}

template <typename T> static PXC_FORCE_INLINE bt_size_t
find_mapped_memchr(const T& c, bt_size_t offset, typename T::mapped_type v)
{
  return array_find(c.rawarr(), c.size(), offset, v);
}

template <typename T> static PXC_FORCE_INLINE typename T::mapped_type
get_elem_value(const T& c, bt_size_t offset)
{
  return c[offset];
}

template <typename T> static PXC_FORCE_INLINE typename T::mapped_type
get_elem_value_nochek(const T& c, bt_size_t offset)
{
  return c.rawarr()[offset];
}

template <typename Tx, typename Ty> PXC_FORCE_INLINE int
compare_memcmp(const Tx& x, const Ty& y)
{
  BOOST_STATIC_ASSERT((
    sizeof(typename Tx::mapped_type) == sizeof(typename Ty::mapped_type)));
  const size_t xlen = x.size();
  const size_t ylen = y.size();
  const size_t clen = std::min(xlen, ylen);
  const int c = memcmp(x.rawarr(), y.rawarr(),
    clen * sizeof(typename Tx::mapped_type));
  if (c < 0) {
    return -1;
  } else if (c > 0) {
    return 1;
  }
  if (xlen < ylen) {
    return -1;
  } else if (xlen > ylen) {
    return 1;
  }
  return 0;
}

template <typename Tx, typename Ty> PXC_FORCE_INLINE bool
eq_memcmp(const Tx& x, const Ty& y)
{
  BOOST_STATIC_ASSERT((
    sizeof(typename Tx::mapped_type) == sizeof(typename Ty::mapped_type)));
  return x.size() == y.size() &&
    memcmp(x.rawarr(), y.rawarr(),
      x.size() * sizeof(typename Tx::mapped_type)) == 0;
}

template <typename Tx, typename Ty> PXC_FORCE_INLINE bool
lt_memcmp(const Tx& x, const Ty& y)
{
  BOOST_STATIC_ASSERT((
    sizeof(typename Tx::mapped_type) == sizeof(typename Ty::mapped_type)));
  const size_t xlen = x.size();
  const size_t ylen = y.size();
  const size_t clen = std::min(xlen, ylen);
  const int c = memcmp(x.rawarr(), y.rawarr(),
    clen * sizeof(typename Tx::mapped_type));
  if (c < 0) {
    return true;
  } else if (c == 0 && xlen < ylen) {
    return true;
  } else {
    return false;
  }
}

template <typename Tx, typename Ty> PXC_FORCE_INLINE bool
ne_memcmp(const Tx& x, const Ty& y) { return !eq_memcmp(x, y); }
template <typename Tx, typename Ty> PXC_FORCE_INLINE bool
gt_memcmp(const Tx& x, const Ty& y) { return lt_memcmp(y, x); }
template <typename Tx, typename Ty> PXC_FORCE_INLINE bool
le_memcmp(const Tx& x, const Ty& y) { return !lt_memcmp(y, x); }
template <typename Tx, typename Ty> PXC_FORCE_INLINE bool
ge_memcmp(const Tx& x, const Ty& y) { return !lt_memcmp(x, y); }

template <typename T> PXC_FORCE_INLINE size_t
hash_podarr(const T& x)
{
  typedef typename T::mapped_type mt;
  mt const* const p = x.rawarr();
  size_t n = x.size();
  size_t r = 0;
  for (size_t i = 0; i < n; ++i) {
    r ^= p[i] + 0x9e3779b9 + (r << 6) + (r >> 2);
  }
  return r;
}

template <typename Tx, typename Ty> PXC_FORCE_INLINE void
copy_memmove(const Tx& x, Ty& y)
{
  BOOST_STATIC_ASSERT((
    sizeof(typename Tx::mapped_type) == sizeof(typename Ty::mapped_type)));
  const size_t xlen = x.size();
  const size_t ylen = y.size();
  const size_t clen = std::min(xlen, ylen);
  memmove(y.rawarr(), x.rawarr(), clen * sizeof(typename Tx::mapped_type));
}

template <typename Tx, typename Tv> static PXC_FORCE_INLINE void
array_push_back(Tx& x, Tv const& v)
{ x.push_back(v); }

template <typename Tx, typename Tv> static PXC_FORCE_INLINE void
array_push_back_move(Tx& x, Tv& v)
{ x.push_back(std::move(v)); }

template <typename Tx> static PXC_FORCE_INLINE typename Tx::mapped_type
array_pop_back(Tx& x)
{ return x.pop_back(); }

template <typename Tx, typename Tv> static PXC_FORCE_INLINE void
array_push_front(Tx& x, Tv const& v)
{ x.push_front(v); }

template <typename Tx, typename Tv> static PXC_FORCE_INLINE void
array_push_front_move(Tx& x, Tv& v)
{ x.push_front(std::move(v)); }

template <typename Tx> static PXC_FORCE_INLINE typename Tx::mapped_type
array_pop_front(Tx& x)
{ return x.pop_front(); }

template <typename Tx, typename Tv> static PXC_FORCE_INLINE void
array_append(Tx& x, Tv const& v)
{ x.append(v); }

template <typename Tx, typename Tv> static PXC_FORCE_INLINE void
array_insert(Tx& x, bt_size_t i, Tv const& v)
{ x.insert(i, v); }

template <typename Tx> static PXC_FORCE_INLINE void
array_erase(Tx& x, bt_size_t i0, bt_size_t i1)
{ x.erase(i0, i1); }

}; // namespace pxcrt

;
/* inline */
namespace pxcrt {

struct refguard_base {
  refguard_base()
  #if ! 0
    : refguard_count(0)
  #endif
  { }
  template <typename Tc> struct guard_ref {
    guard_ref(Tc& x) : v(x) { v.inc_refguard(); }
    ~guard_ref() { v.dec_refguard(); }
    Tc& get() { return v; }
    typename Tc::range_type get_range()
      { return typename Tc::range_type(v); }
    typename Tc::crange_type get_crange()
      { return typename Tc::crange_type(v); }
  private:
    Tc& v;
    guard_ref(const guard_ref&);
    guard_ref& operator =(const guard_ref&);
  };
  template <typename Tc> struct guard_val {
    guard_val(const Tc& x) : v(x) { v.inc_refguard(); }
    ~guard_val() { v.dec_refguard(); }
    Tc& get() { return v; }
    typename Tc::range_type get_range()
      { return typename Tc::range_type(v); }
    typename Tc::crange_type get_crange()
      { return typename Tc::crange_type(v); }
  private:
    Tc v;
    guard_val(const guard_val&);
    guard_val& operator =(const guard_val&);
  };
  #if 0
  bool refguard_is_zero() const { return true; }
  void inc_refguard() const { }
  void dec_refguard() const { }
  void check_resize() { }
  #else
  bool refguard_is_zero() const { return refguard_count == 0; }
  void inc_refguard() const { ++refguard_count; }
  void dec_refguard() const { --refguard_count; }
  void check_resize() {
    if (refguard_count != 0) { pxcrt::throw_would_invalidate(); }
  }
  mutable size_t refguard_count;
  #endif
};

}; // namespace pxcrt
;
/* inline */
#include <limits>
#include <boost/type_traits.hpp>
namespace pxcrt {

template <typename T>
struct bt_cslice {
  typedef T mapped_type;
  bt_cslice() : v(0), len(0) { }
  bt_cslice(const T *ptr, bt_size_t o) : v(ptr), len(o) { }
  template <typename Tc> bt_cslice(const Tc& c)
    : v(c.rawarr()), len(c.size()) { }
  template <typename Tc> bt_cslice(const Tc& c, bt_size_t o1, bt_size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  bt_bool empty() const { return len == 0; }
  bt_size_t size() const { return len; }
  bt_size_t find(bt_size_t offset, T const& value) const {
    return array_find(v, len, offset, value);
  }
  void increment_front(size_t i) {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len < i) { pxcrt::throw_invalid_index(); }
    #endif
    v += i;
    len -= i;
  }
  void decrement_back(size_t i) {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len < i) { pxcrt::throw_invalid_index(); }
    #endif
    len -= i;
  }
  bt_cslice<T> next_token(T const& delim) {
    bt_size_t const offset = array_find(v, len, 0, delim);
    bt_cslice<T> r(v, offset);
    if (offset < len) {
      v += offset + 1;
      len -= offset + 1;
    } else {
      v += len;
      len = 0;
    }
    return r;
  }
  bt_cslice<T> range() const {
    return bt_cslice<T>(*this);
  }
  bt_cslice<T> crange() const {
    return bt_cslice<T>(*this);
  }
  const T& operator [](bt_size_t idx) const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    #endif
    return v[idx];
  }
  const T& operator *() const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len == 0) { pxcrt::throw_invalid_index(); }
    #endif
    return *v;
  }
  T value_at(bt_size_t idx) const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    #endif
    return v[idx];
  }
  T deref_value() const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len == 0) { pxcrt::throw_invalid_index(); }
    #endif
    return *v;
  }
  const T *begin() const { return v; }
  const T *end() const { return v + len; }
  const T *rawarr() const { return v; }
//private:
//  bt_cslice& operator =(const bt_cslice&); /* not allowed */
protected:
  const T *v;
  bt_size_t len;
};

template <typename T>
struct bt_slice {
  typedef T mapped_type;
  bt_slice() : v(0), len(0) { }
  bt_slice(T *ptr, bt_size_t o) : v(ptr), len(o) { }
  template <typename Tc> bt_slice(Tc& c) : v(c.rawarr()), len(c.size()) { }
  template <typename Tc> bt_slice(Tc& c, bt_size_t o1, bt_size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  bt_bool empty() const { return len == 0; }
  bt_size_t size() const { return len; }
  void set(bt_size_t i, T const& value) const { if (i < len) v[i] = value; }
  bt_size_t find(bt_size_t offset, T const& value) const {
    return array_find(v, len, offset, value);
  }
  void next() {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len == 0) { pxcrt::throw_invalid_index(); }
    #endif
    ++v;
    --len;
  }
  void increment_front(size_t i) {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len < i) { pxcrt::throw_invalid_index(); }
    #endif
    v += i;
    len -= i;
  }
  void decrement_back(size_t i) {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len < i) { pxcrt::throw_invalid_index(); }
    #endif
    len -= i;
  }
  bt_slice<T> next_token(T const& delim) {
    bt_size_t const offset = array_find(v, len, 0, delim);
    bt_slice<T> r(v, offset);
    if (offset < len) {
      v += offset + 1;
      len -= offset + 1;
    } else {
      v += len;
      len = 0;
    }
    return r;
  }
  bt_slice<T> range() const {
    return bt_slice<T>(*this);
  }
  bt_cslice<T> crange() const {
    return bt_cslice<T>(*this);
  }
  T& operator [](bt_size_t idx) const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    #endif
    return v[idx];
  }
  T& operator *() const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len == 0) { pxcrt::throw_invalid_index(); }
    #endif
    return *v;
  }
  T value_at(bt_size_t idx) const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    #endif
    return v[idx];
  }
  T deref_value() const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (len == 0) { pxcrt::throw_invalid_index(); }
    #endif
    return *v;
  }
  T *begin() const { return v; }
  T *end() const { return v + len; }
  T *rawarr() const { return v; }
//private:
//  bt_slice& operator =(const bt_slice&); /* not allowed */
protected:
  T *v;
  bt_size_t len;
};

struct bt_strlit : public bt_cslice<bt_uchar> {
  typedef bt_uchar mapped_type;
  typedef bt_uchar char_type;
  typedef size_t size_type;
  typedef const char_type *iterator;
  typedef const char_type *const_iterator;
  typedef bt_cslice<char_type> range_type;
  typedef bt_cslice<char_type> crange_type;
  bt_strlit() { }
  template <size_type n> bt_strlit(const char (& ptr)[n])
    : bt_cslice<bt_uchar>(reinterpret_cast<const char_type *>(ptr), n - 1) { }
  bt_size_t find(bt_size_t offset, char_type const& value) const {
    return array_find(v, len, offset, value);
  }
  bt_strlit& operator =(const bt_strlit& x) { /* allowed */
    v = x.v;
    len = x.len;
    return *this;
  }
  range_type range() {
    return range_type(*this);
  }
  crange_type crange() const {
    return crange_type(*this);
  }
};

template <typename T>
struct pxcvarray : public refguard_base {
  typedef T mapped_type;
  typedef pxcrt::bt_size_t size_type;
  typedef T *iterator;
  typedef const T *const_iterator;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  pxcvarray() : start(0), valid_len(0), alloc_len(0) { }
  ~pxcvarray() {
    deinitialize_n(start, valid_len);
    deallocate_uninitialized(start, alloc_len);
  }
  pxcvarray(const pxcvarray& x)
    { construct_internal(x.start, x.valid_len); }
  pxcvarray(pxcvarray&& x)
    { move_construct_internal(x); }
  pxcvarray(pxcvarray& x) {
    if (std::is_copy_constructible<T>::value) {
      construct_internal(x.start, x.valid_len);
    } else {
      move_construct_internal(x);
    }
  }
  pxcvarray(const crange_type& x)
    { construct_internal(x.rawarr(), x.size()); }
  pxcvarray(const range_type& x)
    { construct_internal(x.rawarr(), x.size()); }
  pxcvarray(const T *ptr, size_type len)
    { construct_internal(ptr, len); }
  pxcvarray& operator =(const pxcvarray& x) {
    check_resize();
    if (&x != this) {
      clear_internal();
      append_internal(x.start, x.valid_len);
    }
    return *this;
  }
  pxcvarray& operator =(pxcvarray&& x) {
    this->swap(x);
    return *this;
  }
  pxcvarray& operator =(pxcvarray& x) {
    if (std::is_copy_assignable<T>::value) {
      return *this = const_cast<const pxcvarray&>(x);
    } else {
      return *this = const_cast<pxcvarray&&>(x);
    }
  }
  bt_bool empty() const { return valid_len == 0; }
  size_type size() const { return valid_len; }
  bt_size_t find(bt_size_t offset, T const& value) const {
    return array_find(start, valid_len, offset, value);
  }
  T& operator [](size_type idx) {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    #endif
    return start[idx];
  }
  const T& operator [](size_type idx) const {
    #ifndef PXC_NO_BOUNDS_CHECKING
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    #endif
    return start[idx];
  }
  void resize(size_type sz, T const& x) {
    check_resize();
    if (sz > valid_len) {
      reserve_internal(sz);
      initialize_fill_n(start + valid_len, sz - valid_len, x);
    } else {
      deinitialize_n(start + sz, valid_len - sz);
    }
    valid_len = sz;
  }
  void clear() {
    check_resize();
    clear_internal();
  }
  template <typename Tc> friend Tc&
  pxcvarray_push_back_uninitialized(pxcvarray<Tc>& v);
  template <typename Tc> friend void
  pxcvarray_rawarr_set_valid_len(pxcvarray<Tc>& v,
    typename pxcvarray<Tc>::size_type len);
  void push_back(T const& x) {
    push_back_internal(x);
  }
  void push_back(T&& x) {
    push_back_internal(x);
  }
  T pop_back() {
    check_resize();
    if (empty()) { pxcrt::throw_invalid_index(); }
    const T r = start[valid_len - 1];
    deinitialize_1(start + valid_len - 1);
    --valid_len;
    return r;
  }
  void reserve(size_type sz) {
    check_resize();
    reserve_internal(sz);
  }
  void append(const crange_type& x) {
    check_resize();
    append_internal(x.rawarr(), x.size());
  }
  void append(const T *ptr, size_type len) {
    check_resize();
    append_internal(ptr, len);
  }
  void insert(size_type pos, const crange_type& x) {
    check_resize();
    insert_internal(pos, x.rawarr(), x.size());
  }
  void erase(size_type first, size_type last) {
    check_resize();
    erase_internal(first, last);
  }
  void swap(pxcvarray& x) {
    check_resize();
    x.check_resize();
    std::swap(start, x.start);
    std::swap(valid_len, x.valid_len);
    std::swap(alloc_len, x.alloc_len);
  }
  bt_slice<T> range() {
    return bt_slice<T>(start, valid_len);
  }
  bt_cslice<T> crange() const {
    return bt_cslice<T>(start, valid_len);
  }
  iterator begin() { return start; }
  const_iterator begin() const { return start; }
  iterator end() { return start + valid_len; }
  const_iterator end() const { return start + valid_len; }
  T *rawarr() { return start; }
  const T *rawarr() const { return start; }
  template <size_t mul> T *reserve_back(size_type len) {
    check_resize();
    if (len >= ::std::numeric_limits<size_type>::max() / mul) {
      pxcrt::throw_bad_alloc(); /* overflow */
    }
    const size_type osz = valid_len;
    const size_type nsz = osz + len * mul;
    if (nsz < osz) {
      pxcrt::throw_bad_alloc(); /* overflow */
    }
    reserve_internal(nsz);
    return start + osz;
  }
  void rawarr_set_valid_len(size_type len) {
    valid_len = len;
  }
private:
  void construct_internal(const T *ptr, size_type len) {
    alloc_len = valid_len = len;
    start = allocate_uninitialized<T>(alloc_len);
    if (is_trivially_copyable<T>::value) {
      initialize_copymove_n(start, valid_len, ptr);
    } else {
      PXC_TRY {
	initialize_copymove_n(start, valid_len, ptr);
      } PXC_CATCH(...) {
	deallocate_uninitialized(start, alloc_len);
	PXC_RETHROW;
      }
    }
  }
  void move_construct_internal(pxcvarray& x) {
    x.check_resize();
    start = x.start;
    valid_len = x.valid_len;
    alloc_len = x.alloc_len;
    x.start = 0;
    x.valid_len = 0;
    x.alloc_len = 0;
  }
  void clear_internal() {
    deinitialize_n(start, valid_len);
    valid_len = 0;
  }
  template <typename Tx> void push_back_internal(Tx& x) {
    /* re-ordered for speed */
    if (refguard_is_zero()) {
      /* valid_len + 1 never overflows */
      if (valid_len + 1 < alloc_len) {
	/* fast path */
	initialize_1(start + valid_len, x);
	valid_len++;
	return;
      } else {
	/* slow path */
	reserve_internal(valid_len + 1);
	initialize_1(start + valid_len, x);
	valid_len++;
	return;
      }
    } else {
      pxcrt::throw_would_invalidate();
    }
  }
  void append_internal(const T *p, size_type len) {
    size_type nlen = valid_len + len;
    if (nlen < valid_len) {
      pxcrt::throw_bad_alloc(); /* overflow */
    }
    reserve_internal(nlen);
    initialize_copymove_n(start + valid_len, len, p);
    valid_len = nlen;
  }
  void insert_internal(size_type pos, const T *p, size_type plen) {
    if (plen == 0) {
      return;
    }
    if (pos > valid_len) {
      pxcrt::throw_invalid_index();
    }
    const size_type vlen = valid_len;
    const size_type nlen = vlen + plen;
    if (nlen < vlen) {
      pxcrt::throw_bad_alloc(); /* overflow */
    }
    reserve_internal(nlen);
    insert_n(start, valid_len /* modified */, p, plen, pos);
  }
  void erase_internal(size_type first, size_type last) {
    if (last > valid_len || first > last) {
      pxcrt::throw_invalid_index();
    }
    if (first >= last) {
      return;
    }
    const size_type elen = last - first;
    copymove_n(start + first, valid_len - last, start + last);
    deinitialize_n(start + valid_len - elen, elen);
    valid_len -= elen;
  }
  void reserve_internal(size_type len) {
    if (len <= alloc_len) {
      return;
    }
    size_type nl = alloc_len;
    do {
      const size_type nl_n = (nl >= 1) ? (nl * 2) : 1;
      const size_type max_len = ((size_t)-1) / sizeof(T);
      if (nl_n <= nl || nl_n > max_len) {
        PXC_THROW(std::bad_alloc()); /* overflow */
      }
      nl = nl_n;
    } while (nl < len);
    start = reserve_n(start, valid_len, alloc_len, nl);
    alloc_len = nl;
  }
private:
  T *start;
  size_type valid_len;
  size_type alloc_len;
};

template <typename T> static inline void
pxcvarray_swap(pxcvarray<T>& x, pxcvarray<T>& y)
{
  x.swap(y);
}

template <typename T> static inline T&
pxcvarray_push_back_uninitialized(pxcvarray<T>& v)
{
  /* re-ordered for speed */
  if (v.refguard_count == 0) {
    /* valid_len + 1 never overflows */
    if (v.valid_len + 1 < v.alloc_len) {
      /* fast path */
      return v.start[v.valid_len];
    } else {
      /* slow path */
      v.reserve_internal(v.valid_len + 1);
      return v.start[v.valid_len];
    }
  } else {
    pxcrt::throw_would_invalidate();
  }
}

template <typename T> static inline void
pxcvarray_rawarr_set_valid_len(pxcvarray<T>& v,
  typename pxcvarray<T>::size_type len)
{
  v.valid_len = len;
}

typedef pxcvarray<bt_uchar> bt_string;
typedef bt_slice<bt_uchar> strref;
typedef bt_cslice<bt_uchar> cstrref;

template <typename Tx, typename Ty> static inline bt_bool
pod_array_eq(Tx const& x, Ty const& y)
{ return eq_memcmp(x, y); }
template <typename Tx, typename Ty> static inline bt_int
pod_array_compare(Tx const& x, Ty const& y)
{ return compare_memcmp(x, y); }
template <typename T> static inline bt_size_t
pod_array_hash(T const& x)
{ return hash_podarr(x); }
template <typename Tx, typename Ty> static inline void
pod_array_copy(Tx const& x, Ty const& y)
{ return copy_memmove(x, y); }

static inline bt_string cstr_to_string(const char *cstr)
{
  return bt_string(
    reinterpret_cast<const unsigned char *>(cstr),
    strlen(cstr));
}

template <typename Tarr, typename Tv> static inline void
array_resize(Tarr& arr, bt_size_t i, Tv const& v)
{
  arr.resize(i, v);
}

}; // namespace pxcrt
;
/* inline */

#include <algorithm>
#include <limits>

#define PXCRT_DBG_SVECTOR1(x)
#define PXCRT_DBG_SVECTOR2(x)

namespace pxcrt {

struct svarray_rep {
  /* must be a pod so that empty_rep is initialized wo constructor call */
  size_t refcnt;
  size_t valid_len;
  size_t alloc_len;
};

extern svarray_rep empty_rep; /* for empty value */

template <typename T>
struct svarray {
  typedef T mapped_type;
  typedef pxcrt::bt_size_t size_type;
  typedef T *iterator;
  typedef const T *const_iterator;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  svarray() : rep(&empty_rep) { }
  svarray(const svarray& x) : rep(x.rep) { rep_incref(rep); }
  svarray(const crange_type& x) {
    rep_init(x.begin(), x.size(), x.size());
    rep_zerofill();
  }
  svarray(const range_type& x) {
    rep_init(x.begin(), x.size(), x.size());
    rep_zerofill();
  }
  svarray(const T *start, size_type sz, size_type asz) {
    rep_init(start, sz, asz);
    rep_zerofill();
  }
  void operator =(const svarray& x) {
    if (&x != this) {
      rep_incref(x.rep);
      rep_decref(rep);
      rep = x.rep;
    }
  }
  ~svarray() { rep_decref(rep); }
  bt_bool empty() const { return size() == 0; }
  size_type size() const { return rep->valid_len; }
  size_type find(bt_size_t offset, T const& value) const {
    return array_find(begin(), size(), offset, value);
  }
  T& operator [](size_type idx) {
    if (idx >= size()) { pxcrt::throw_invalid_index(); }
    return begin()[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= size()) { pxcrt::throw_invalid_index(); }
    return begin()[idx];
  }
  void resize(size_type sz, T const& x) {
    if (sz == 0) {
      clear();
      return;
    }
    size_type const olen = size();
    rep_make_unique(sz);
    if (sz > olen) {
      initialize_fill_n(end(), sz - olen, x);
      rep->valid_len = sz;
      rep_zerofill();
    }
  }
  void clear() {
    rep_decref(rep);
    rep = &empty_rep;
  }
  void swap(svarray& x) {
    svarray_rep *orep = rep;
    rep = x.rep;
    x.rep = orep;
  }
  void push_back(T const& x) {
    if (rep->refcnt == 1 && rep->valid_len < rep->alloc_len) {
      /* fast path */
      PXCRT_DBG_SVECTOR2(fprintf(stderr, "fastpath\n"));
      initialize_1(end(), x);
      rep->valid_len += 1;
      rep_zerofill();
      return;
    } else {
      /* slow path */
      PXCRT_DBG_SVECTOR2(fprintf(stderr, "slowpath %zu %zu %zu\n", rep->refcnt,
	rep->valid_len, rep->alloc_len));
      rep_make_unique(size() + 1);
      initialize_1(end(), x);
      rep->valid_len += 1;
      rep_zerofill();
    }
  }
  T pop_back() {
    if (empty()) { pxcrt::throw_invalid_index(); }
    const T r = end()[-1];
    size_type nlen = size() - 1;
    if (nlen == 0) {
      clear();
      return r;
    }
    const bool is_uniq = rep->refcnt == 1;
    rep_make_unique(nlen);
    if (is_trivially_copyable<T>::value && sizeof(T) == 1) {
      if (is_uniq) {
	assert(rep->valid_len < rep->alloc_len);
	*end() = T(); /* FIXME: requires defcon */
      } else {
	/* new copy */
	rep_zerofill();
      }
    }
    return r;
  }
  void reserve(size_type sz) {
    rep_make_unique(std::max(size(), sz));
    rep_zerofill();
  }
  void append(const crange_type& x) {
    append(x.begin(), x.size());
  }
  void append(const T *ptr, size_type len) {
    size_type const olen = size();
    size_type const nlen = olen + len;
    if (nlen < olen) { pxcrt::throw_bad_alloc(); } /* overflow */
    rep_make_unique(nlen);
    initialize_copymove_n(begin() + olen, len, ptr);
    rep->valid_len = nlen;
    rep_zerofill();
  }
  void insert(size_type pos, const crange_type& x) {
    size_type const olen = size();
    size_type const plen = x.size();
    size_type const nlen = olen + plen;
    if (pos > olen) { pxcrt::throw_invalid_index(); }
    if (nlen < olen) { pxcrt::throw_bad_alloc(); } /* overflow */
    rep_make_unique(nlen);
    if (plen == 0) { return; }
    insert_n(begin(), rep->valid_len /* modified */, x.begin(), plen, pos);
    rep_zerofill();
  }
  void erase(size_type first, size_type last) {
    size_type const olen = size();
    if (last > olen || first > last) { pxcrt::throw_invalid_index(); }
    if (first >= last) { return; }
    size_type const elen = last - first;
    if (rep->refcnt == 1) {
      /* already unique. erase in-place */
      T *const start = begin();
      copymove_n(start + first, olen - last, start + last);
      deinitialize_n(start + olen - elen, elen);
      rep->valid_len -= elen;
    } else {
      /* create a copy */
      svarray x(begin(), first, olen - elen);
      x.append(begin() + last, olen - last);
      this->swap(x);
    }
    rep_zerofill();
  }
  bt_slice<T> range() {
    return bt_slice<T>(begin(), size());
  }
  bt_cslice<T> crange() const {
    return bt_cslice<T>(begin(), size());
  }
  const_iterator begin() const {
    return reinterpret_cast<const T *>(
      reinterpret_cast<const char *>(rep) + sizeof(svarray_rep));
  }
  const_iterator end() const {
    return begin() + size();
  }
  iterator begin() {
    return reinterpret_cast<T *>(
      reinterpret_cast<char *>(rep) + sizeof(svarray_rep));
  }
  iterator end() {
    return begin() + size();
  }
  T *rawarr() { return begin(); }
  const T *rawarr() const { return begin(); }
  template <size_t mul> T *reserve_back(size_type len) {
    if (len >= ((size_t)-1) / mul) {
      pxcrt::throw_bad_alloc(); /* overflow */
    }
    const size_type osz = size();
    const size_type nsz = osz + len * mul;
    if (nsz < osz) {
      pxcrt::throw_bad_alloc(); /* overflow */
    }
    rep_make_unique(nsz);
    rep_zerofill();
    return begin() + osz;
  }
  void rawarr_set_valid_len(size_type len) {
    assert(rep->refcnt == 1);
    rep->valid_len = len;
    rep_zerofill();
  }
  template <typename Tc> struct guard_ref {
    guard_ref(Tc& x) : v(x) { }
    Tc& get() { return v; }
    typename Tc::range_type get_range()
      { return typename Tc::range_type(v); }
    typename Tc::crange_type get_crange()
      { return typename Tc::crange_type(v); }
  private:
    Tc v; /* shares rep */
    guard_ref(const guard_ref&);
    guard_ref& operator =(const guard_ref&);
  };
  template <typename Tc> struct guard_val {
    guard_val(const Tc& x) : v(x) { }
    Tc& get() { return v; }
    typename Tc::range_type get_range()
      { return typename Tc::range_type(v); }
    typename Tc::crange_type get_crange()
      { return typename Tc::crange_type(v); }
  private:
    Tc v;
    guard_val(const guard_val&);
    guard_val& operator =(const guard_val&);
  };
private:
  svarray_rep *rep;
private:
  static inline void rep_incref(svarray_rep *rep) {
    if (rep->refcnt != 0) {
      PXCRT_DBG_SVECTOR1(fprintf(stderr, "rep_decref incref %p %zu\n", rep,
	rep->refcnt + 1));
      ++rep->refcnt;
    }
  }
  static inline void rep_decref(svarray_rep *rep) {
    if (rep->refcnt != 0) {
      PXCRT_DBG_SVECTOR1(fprintf(stderr, "rep_decref decref %p %zu\n", rep,
	rep->refcnt - 1));
      if (--rep->refcnt == 0) {
	T *const p = reinterpret_cast<T *>(
	  reinterpret_cast<char *>(rep) + sizeof(svarray_rep));
	deinitialize_n(p, rep->valid_len);
	PXCRT_DBG_SVECTOR1(fprintf(stderr, "rep_decref dealloc %p\n", rep));
	global_deallocate_n(rep,
	  sizeof(svarray_rep) + sizeof(T) * rep->alloc_len);
      }
    }
  }
  void rep_zerofill() {
    if (is_trivially_copyable<T>::value && sizeof(T) == 1) {
      char *p = reinterpret_cast<char *>(begin());
      size_t pos = rep->valid_len;
      const size_t mask = sizeof(size_t) - 1;
      const size_t epos = (pos + mask) & ~mask;
      assert(epos <= rep->alloc_len);
      if (epos != pos) {
	memset(p + pos, 0, epos - pos);
      }
    }
  }
  void rep_init(const T *ptr, size_t sz, size_t asz) {
    rep = &empty_rep;
    assert(rep->refcnt == 0 && rep->valid_len == 0 && rep->alloc_len == 0);
    if (asz != 0) {
      const size_type max_len =
	(- sizeof(svarray_rep) - sizeof(size_t)) / sizeof(T);
      if (asz >= max_len) { pxcrt::throw_bad_alloc(); }
      if (is_trivially_copyable<T>::value && sizeof(T) == 1) {
	const size_t mask = sizeof(size_t) - 1;
//fprintf(stderr, "asz pre=%zu\n", asz);
	asz = (asz + mask) & ~mask; /* align for 0-filling */
//fprintf(stderr, "asz post=%zu\n", asz);
      }
      const size_type aszt = asz * sizeof(T) + sizeof(svarray_rep);
      void *const vrep = global_allocate_n(aszt);
      svarray_rep *const nrep = reinterpret_cast<svarray_rep *>(vrep);
      PXCRT_DBG_SVECTOR1(fprintf(stderr, "rep_init alloc %p\n", nrep));
      nrep->refcnt = 1;
      nrep->valid_len = 0;
      nrep->alloc_len = asz;
      T *const start = reinterpret_cast<T *>(
	reinterpret_cast<char *>(nrep) + sizeof(svarray_rep));
      if (is_trivially_copyable<T>::value) {
	initialize_copymove_n(start, sz, ptr);
	#if 0
	if (sizeof(T) == 1) {
	  /* 0-filling */
	  memset(start + sz, 0, asz - sz);
	}
	#endif
      } else {
	PXC_TRY {
	  initialize_copymove_n(start, sz, ptr);
	} PXC_CATCH(...) {
	  PXCRT_DBG_SVECTOR1(fprintf(stderr, "rep_init dealloc %p\n", rep));
	  global_deallocate_n(rep,
	    sizeof(svarray_rep) + sizeof(T) * rep->alloc_len);
	  PXC_RETHROW;
	}
      }
      nrep->valid_len = sz;
      rep = nrep;
    }
  }
  void rep_make_unique(size_type asz) {
    if (rep->refcnt != 1) {
      /* need to create a unique rep */
      rep_make_unique_resize(asz);
    } else {
      /* already unique */
      if (asz > rep->alloc_len) {
	/* extend alloc_len */
	size_type nl = rep->alloc_len;
	do {
	  const size_type nl_n = (nl >= 1) ? (nl * 2) : 1;
	  const size_type max_len =
	    (-(sizeof(svarray_rep) + sizeof(T))) / sizeof(T) - 8;
	  if (nl_n <= nl || nl_n > max_len) { pxcrt::throw_bad_alloc(); }
	  nl = nl_n;
	} while (nl < asz);
	rep_make_unique_resize(nl);
      } else if (asz < rep->valid_len) {
	/* shrink valid_len */
	deinitialize_n(begin() + asz, rep->valid_len - asz);
	rep->valid_len = asz;
      } else {
	/* nothing to do */
      }
    }
    assert(rep->refcnt == 1);
  }
  void rep_make_unique_resize(size_type asz) {
    if (is_trivially_copyable<T>::value) {
      if (rep->refcnt != 1) {
	svarray_rep *const orep = rep;
	asz = std::max(asz, size_type(1));
	  /* set asz nonzero so that rep_init allocate a unique buffer */
	PXCRT_DBG_SVECTOR1(fprintf(stderr, "rep_make_unique_resize init1 %p\n",
	  rep));
	rep_init(begin(), std::min(size(), asz), asz);
	rep_decref(orep);
      } else {
	PXCRT_DBG_SVECTOR1(fprintf(stderr, "rep_make_unique_resize pre %p\n",
	  rep));
	if (sizeof(T) == 1) {
	  const size_t mask = sizeof(size_t) - 1;
//fprintf(stderr, "asztr pre=%zu\n", asz);
	  asz = (asz + mask) & ~mask; /* align for 0-filling */
//fprintf(stderr, "asztr post=%zu\n", asz);
	}
	rep = (svarray_rep *)global_reallocate_n(rep,
	    sizeof(svarray_rep) + sizeof(T) * rep->alloc_len,
	    sizeof(svarray_rep) + sizeof(T) * asz);
	PXCRT_DBG_SVECTOR1(fprintf(stderr, "rep_make_unique_resize post %p\n",
	  rep));
	rep->alloc_len = asz;
	#if 0
	if (sizeof(T) == 1) {
	  /* 0-filling */
	  memset(end(), 0, asz - rep->valid_len);
	}
	#endif
      }
    } else {
      svarray_rep *const orep = rep;
      PXC_TRY {
	asz = std::max(asz, size_type(1));
	  /* set asz nonzero so that rep_init allocate a unique buffer */
	rep_init(begin(), std::min(size(), asz), asz);
      } PXC_CATCH(...) {
	rep_decref(orep);
	PXC_RETHROW;
      } 
      rep_decref(orep);
    }
  }
};

template <typename T> struct msvarray : public svarray<T> {
  typedef pxcrt::bt_size_t size_type;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  msvarray() { }
  msvarray(const msvarray& x) : svarray<T>(x) { }
  msvarray(const crange_type& x) : svarray<T>(x) { }
  msvarray(const range_type& x) : svarray<T>(x) { }
  msvarray(const T *start, size_type sz, size_type asz)
    : svarray<T>(start, sz, asz) { }
};

template <typename T> struct csvarray : public svarray<T> {
  typedef pxcrt::bt_size_t size_type;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  csvarray() { }
  csvarray(const csvarray& x) : svarray<T>(x) { }
  csvarray(const crange_type& x) : svarray<T>(x) { }
  csvarray(const range_type& x) : svarray<T>(x) { }
  csvarray(const T *start, size_type sz, size_type asz)
    : svarray<T>(start, sz, asz) { }
};

template <typename Tx, typename Ty, bool is_sstr> struct
pod_sarray_eq_impl;

template <typename Tx, typename Ty> struct
pod_sarray_eq_impl<Tx, Ty, true>
{
  bt_bool operator ()(Tx const& x, Ty const& y) const
  {
    const size_t xs0 = x.size();
    const size_t ys0 = y.size();
    if (xs0 != ys0) {
      return false;
    }
    const size_t sz = (xs0 + (sizeof(size_t)-1)) / sizeof(size_t);
    const bt_ulong *const xp = reinterpret_cast<const bt_ulong *>(x.begin());
    const bt_ulong *const yp = reinterpret_cast<const bt_ulong *>(y.begin());
    for (size_t i = 0; i < sz; ++i) {
      if (xp[i] != yp[i]) {
	return false;
      }
    }
    return true;
  }
};

template <typename Tx, typename Ty> struct
pod_sarray_eq_impl<Tx, Ty, false>
{
  bt_bool operator ()(Tx const& x, Ty const& y) const
  {
    return eq_memcmp(x, y);
  }
};

template <typename Tx, typename Ty, bool is_sstr> struct
pod_sarray_compare_impl;

template <typename Tx, typename Ty> struct
pod_sarray_compare_impl<Tx, Ty, true>
{
  bt_int operator ()(Tx const& x, Ty const& y) const
  {
    const bt_ulong *const xp = reinterpret_cast<const bt_ulong *>(x.begin());
    const bt_ulong *const yp = reinterpret_cast<const bt_ulong *>(y.begin());
    const size_t xs0 = x.size();
    const size_t ys0 = y.size();
    const size_t xsz = (xs0 + (sizeof(size_t)-1)) / sizeof(size_t);
    const size_t ysz = (ys0 + (sizeof(size_t)-1)) / sizeof(size_t);
    const size_t sz = xsz < ysz ? xsz : ysz; 
    for (size_t i = 0; i < sz; ++i) {
      if (xp[i] < yp[i]) {
	return -1;
      }
      if (xp[i] > yp[i]) {
	return 1;
      }
    }
    if (xs0 > ys0) {
      return 1;
    }
    if (xs0 < ys0) {
      return -1;
    }
    return 0;
  }
};

template <typename Tx, typename Ty> struct
pod_sarray_compare_impl<Tx, Ty, false>
{
  bt_int operator ()(Tx const& x, Ty const& y) const
  {
    return compare_memcmp(x, y);
  }
};

template <typename T, bool is_sstr> struct
pod_sarray_hash_impl;

template <typename T> struct
pod_sarray_hash_impl<T, true>
{
  bt_size_t operator ()(T const& x)
  {
    const bt_ulong *const xp = reinterpret_cast<const bt_ulong *>(x.begin());
    const size_t xs0 = x.size();
    const size_t xsz = (xs0 + (sizeof(size_t)-1)) / sizeof(size_t);
    size_t r = 0;
    for (size_t i = 0; i < xsz; ++i) {
      r ^= size_t(xp[i]) + 0x9e3779b9 + (r << 6) + (r >> 2);
    }
    return r;
  }
};

template <typename T> struct
pod_sarray_hash_impl<T, false>
{
  bt_size_t operator ()(T const& x)
  {
    return hash_podarr(x);
  }
};

template <typename Tx, typename Ty> struct is_sstring_pair {
  typedef typename Tx::mapped_type mtx;
  typedef typename Ty::mapped_type mty;
  enum {
    value = (
      is_trivially_copyable<mtx>::value &&
      is_trivially_copyable<mty>::value &&
      sizeof(mtx) == 1 &&
      sizeof(mty) == 1) };
};

template <typename Tx, typename Ty> static inline bt_bool
pod_sarray_eq(Tx const& x, Ty const& y)
{
  return pod_sarray_eq_impl<Tx, Ty, is_sstring_pair<Tx, Ty>::value>()(x, y);
}

template <typename Tx, typename Ty> static inline bt_int
pod_sarray_compare(Tx const& x, Ty const& y)
{
  return pod_sarray_compare_impl<Tx, Ty, is_sstring_pair<Tx, Ty>::value>()
    (x, y);
}

template <typename T> static inline bt_size_t
pod_sarray_hash(T const& x)
{
  return pod_sarray_hash_impl<T, is_sstring_pair<T, T>::value>()(x);
}

}; // namespace pxcrt

#undef PXCRT_DBG_SVECTOR1
#undef PXCRT_DBG_SVECTOR2

;
/* inline */
namespace pxcrt {
template <typename T, size_t len>
struct farray {
  typedef T mapped_type;
  typedef size_t size_type;
  typedef T *iterator;
  typedef const T *const_iterator;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  farray() : v() { }
  bool empty() const { return len == 0; }
  size_t size() const { return len; }
  T& operator [](size_type idx) {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    #endif
    return v[idx];
  }
  const T& operator [](size_type idx) const {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    #endif
    return v[idx];
  }
  T value_at(size_type idx) const {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    #endif
    return v[idx];
  }
  bt_slice<T> range() {
    return bt_slice<T>(v, len);
  }
  bt_cslice<T> crange() const {
    return bt_cslice<T>(v, len);
  }
  iterator begin() { return v; }
  const_iterator begin() const { return v; }
  iterator end() { return v + len; }
  const_iterator end() const { return v + len; }
  T *rawarr() { return v; }
  const T *rawarr() const { return v; }
private:
  T v[len];
};

}; // namespace pxcrt 
;
/* inline */
namespace pxcrt {

template <typename T>
struct darray {
  typedef T mapped_type;
  typedef pxcrt::bt_size_t size_type;
  typedef T *iterator;
  typedef const T *const_iterator;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  ~darray() {
    deinitialize_n(start, valid_len);
    deallocate_uninitialized(start, valid_len);
  }
  darray(size_type len, const T& val) {
    construct_fill(len, val);
  }
  darray(const darray& x) {
    construct_copy(x.start, x.valid_len);
  }
  darray(const range_type& x) {
    construct_copy(x.rawarr(), x.size());
  }
  darray(const crange_type& x) {
    construct_copy(x.rawarr(), x.size());
  }
  bool empty() const { return valid_len == 0; }
  size_type size() const { return valid_len; }
  T& operator [](size_type idx) {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    #endif
    return start[idx];
  }
  const T& operator [](size_type idx) const {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    #endif
    return start[idx];
  }
  T value_at(size_type idx) const {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    #endif
    return start[idx];
  }
  bt_slice<T> range() {
    return bt_slice<T>(start, valid_len);
  }
  bt_cslice<T> crange() const {
    return bt_cslice<T>(start, valid_len);
  }
  iterator begin() { return start; }
  const_iterator begin() const { return start; }
  iterator end() { return start + valid_len; }
  const_iterator end() const { return start + valid_len; }
  T *rawarr() { return start; }
  const T *rawarr() const { return start; }
private:
  void construct_fill(size_type len, const T& val) {
    valid_len = len;
    start = allocate_uninitialized<T>(valid_len);
    if (is_trivially_copyable<T>::value) {
      initialize_fill_n(start, valid_len, val);
    } else {
      PXC_TRY {
	initialize_fill_n(start, valid_len, val);
      } PXC_CATCH(...) {
	deallocate_uninitialized(start, valid_len);
	PXC_RETHROW;
      }
    }
  }
  void construct_copy(const T *arr, size_type len) {
    valid_len = len;
    start = allocate_uninitialized<T>(valid_len);
    if (is_trivially_copyable<T>::value) {
      initialize_copymove_n(start, valid_len, arr);
    } else {
      PXC_TRY {
       initialize_copymove_n(start, valid_len, arr);
      } PXC_CATCH(...) {
	deallocate_uninitialized(start, valid_len);
        PXC_RETHROW;
      }
    }
  }
private:
  T *start;
  size_type valid_len;
private:
  darray(); /* not allowed */
  darray& operator =(const darray& x); /* not allowed */
};

template <typename T>
struct darrayst {
  typedef T mapped_type;
  typedef pxcrt::bt_size_t size_type;
  typedef T *iterator;
  typedef const T *const_iterator;
  typedef pxcrt::bt_slice<T> range_type;
  typedef pxcrt::bt_cslice<T> crange_type;
  ~darrayst() {
    deinitialize_n(start, valid_len);
    if (is_heap) {
      deallocate_uninitialized(start, valid_len);
    }
  }
  darrayst(size_type len, const T& val, void *preal_ptr = 0) {
    construct_fill(len, val, preal_ptr);
  }
  darrayst(const range_type& x) {
    construct_copy(x.rawarr(), x.size(), 0);
  }
  darrayst(const crange_type& x) {
    construct_copy(x.rawarr(), x.size(), 0);
  }
  darrayst(const darrayst& x) {
    construct_copy(x.rawarr(), x.size(), 0);
  }
  bool empty() const { return valid_len == 0; }
  size_type size() const { return valid_len; }
  T& operator [](size_type idx) {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    #endif
    return start[idx];
  }
  const T& operator [](size_type idx) const {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    #endif
    return start[idx];
  }
  T value_at(size_type idx) const {
    #ifdef PXC_NO_BOUNDS_CHECKING
    if (idx >= valid_len) { pxcrt::throw_invalid_index(); }
    #endif
    return start[idx];
  }
  bt_slice<T> range() {
    return bt_slice<T>(start, valid_len);
  }
  bt_cslice<T> crange() const {
    return bt_cslice<T>(start, valid_len);
  }
  iterator begin() { return start; }
  const_iterator begin() const { return start; }
  iterator end() { return start + valid_len; }
  const_iterator end() const { return start + valid_len; }
  T *rawarr() { return start; }
  const T *rawarr() const { return start; }
  void construct_fill(size_type len, const T& val, void *preal_ptr) {
    valid_len = len;
    if (preal_ptr != 0) {
      start = static_cast<T *>(preal_ptr);
      is_heap = false;
    } else {
      start = allocate_uninitialized<T>(valid_len);
      is_heap = true;
    }
    if (is_trivially_copyable<T>::value) {
      initialize_fill_n(start, valid_len, val);
    } else {
      PXC_TRY {
	initialize_fill_n(start, valid_len, val);
      } PXC_CATCH(...) {
	deallocate_uninitialized(start, valid_len);
	PXC_RETHROW;
      }
    }
  }
  void construct_copy(const T *arr, size_type len, void *preal_ptr) {
    valid_len = len;
    if (preal_ptr != 0) {
      start = static_cast<T *>(preal_ptr);
      is_heap = false;
    } else {
      start = allocate_uninitialized<T>(valid_len);
      is_heap = true;
    }
    if (is_trivially_copyable<T>::value) {
      initialize_copymove_n(start, valid_len, arr);
    } else {
      PXC_TRY {
       initialize_copymove_n(start, valid_len, arr);
      } PXC_CATCH(...) {
	deallocate_uninitialized(start, valid_len);
        PXC_RETHROW;
      }
    }
  }
  T *start;
  size_type valid_len;
  bool is_heap;
private:
  darrayst(); /* not allowed */
  darrayst& operator =(const darrayst& x); /* not allowed */
};

}; // namespace pxcrt
;
/* inline */
#include <limits>
#include <boost/container/deque.hpp>
  /* boost::container::deque<T> allows T to be incomplete */
namespace pxcrt {

template <typename T>
struct deque_cslice {
  typedef T mapped_type;
  typedef typename boost::container::deque<T>::const_iterator iterator;
  typedef typename boost::container::deque<T>::const_iterator const_iterator;
  deque_cslice() : v() { }
  template <typename Tc> deque_cslice(const Tc& c)
    : v(c.begin(), c.end()) { }
  template <typename Tc> deque_cslice(const Tc& c, bt_size_t o1,
    bt_size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v.first = c.begin() + o1;
    v.second = v.first + (o2 - o1);
  }
  iterator begin() const { return v.first; } 
  iterator end() const { return v.second; } 
  bt_bool empty() const { return v.first == v.second; }
  bt_size_t size() const { return v.second - v.first; }
  bt_size_t find(bt_size_t offset, T const& value) const {
    bt_size_t p = std::min(offset, size());
    for (iterator i = v.first + p; i < v.second; ++i, ++offset) {
      if (*i == value) {
	break;
      }
    }
    return offset;
  }
  void increment_front(size_t i) {
    if (size() < i) { pxcrt::throw_invalid_index(); }
    v.first += i;
  }
  void decrement_back(size_t i) {
    if (size() < i) { pxcrt::throw_invalid_index(); }
    v.second -= i;
  }
  const T& operator [](bt_size_t idx) const {
    if (idx >= size()) { pxcrt::throw_invalid_index(); }
    return v.first[idx];
  }
  const T& operator *() const {
    if (empty()) { pxcrt::throw_invalid_index(); }
    return *v;
  }
  T value_at(bt_size_t idx) const {
    if (idx >= size()) { pxcrt::throw_invalid_index(); }
    return v.first[idx];
  }
  T deref_value() const {
    if (empty()) { pxcrt::throw_invalid_index(); }
    return v.first[0];
  }
  iterator rawarr() const { return v.first; }
private:
  deque_cslice& operator =(const deque_cslice&); /* not allowed */
protected:
  std::pair<iterator, iterator> v;
};

template <typename T>
struct deque_slice {
  typedef T mapped_type;
  typedef typename boost::container::deque<T>::iterator iterator;
  typedef typename boost::container::deque<T>::const_iterator const_iterator;
  deque_slice() : v() { }
  template <typename Tc> deque_slice(Tc& c)
    : v(c.begin(), c.end()) { }
  template <typename Tc> deque_slice(Tc& c, bt_size_t o1, bt_size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v.first = c.begin() + o1;
    v.second = v.first + (o2 - o1);
  }
  iterator begin() const { return v.first; } 
  iterator end() const { return v.second; } 
  bt_bool empty() const { return v.first == v.second; }
  bt_size_t size() const { return v.second - v.first; }
  bt_size_t find(bt_size_t offset, T const& value) const {
    bt_size_t p = std::min(offset, size());
    for (iterator i = v.first + p; i < v.second; ++i, ++offset) {
      if (*i == value) {
	break;
      }
    }
    return offset;
  }
  void increment_front(size_t i) {
    if (size() < i) { pxcrt::throw_invalid_index(); }
    v.first += i;
  }
  void decrement_back(size_t i) {
    if (size() < i) { pxcrt::throw_invalid_index(); }
    v.second -= i;
  }
  T& operator [](bt_size_t idx) const {
    if (idx >= size()) { pxcrt::throw_invalid_index(); }
    return v.first[idx];
  }
  T& operator *() const {
    if (empty()) { pxcrt::throw_invalid_index(); }
    return *v;
  }
  T value_at(bt_size_t idx) const {
    if (idx >= size()) { pxcrt::throw_invalid_index(); }
    return v.first[idx];
  }
  T deref_value() const {
    if (empty()) { pxcrt::throw_invalid_index(); }
    return v.first[0];
  }
  iterator rawarr() const { return v.first; }
private:
  deque_slice& operator =(const deque_slice&); /* not allowed */
protected:
  std::pair<iterator, iterator> v;
};

template <typename T>
struct pxcdeque : public refguard_base {
  typedef T mapped_type;
  typedef pxcrt::bt_size_t size_type;
  typedef boost::container::deque<T> base_deque;
  typedef typename base_deque::iterator iterator;
  typedef typename base_deque::const_iterator const_iterator;
  typedef deque_slice<T> range_type;
  typedef deque_cslice<T> crange_type;
  pxcdeque() { }
  pxcdeque(const crange_type& x) : value(x.begin(), x.end()) { }
  pxcdeque(const range_type& x) : value(x.begin(), x.end()) { }
  bt_bool empty() const { return value.empty(); }
  size_type size() const { return value.size(); }
  bt_size_t find(bt_size_t offset, T const& v) const {
    bt_size_t i = 0, n = size();
    for (; i < n; ++i) {
      if (value[i] == v) {
	break;
      }
    }
    return i;
  }
  T& operator [](size_type idx) {
    if (idx >= size()) { pxcrt::throw_invalid_index(); }
    return value[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= size()) { pxcrt::throw_invalid_index(); }
    return value[idx];
  }
  void resize(size_type sz, T const& x) {
    check_resize();
    value.resize(sz, x);
  }
  void clear() {
    check_resize();
    value.clear();
  }
  void push_back(T const& x) {
    check_resize();
    value.push_back(x);
  }
  T pop_back() {
    check_resize();
    if (empty()) { pxcrt::throw_invalid_index(); }
    T r = value[size() - 1];
    value.pop_back();
    return r;
  }
  void push_front(T const& x) {
    check_resize();
    value.push_front(x);
  }
  T pop_front() {
    check_resize();
    if (empty()) { pxcrt::throw_invalid_index(); }
    T r = value[0];
    value.pop_front();
    return r;
  }
  void insert(size_type pos, const crange_type& x) {
    check_resize();
    if (pos > size()) { pxcrt::throw_invalid_index(); }
    value.insert(value.begin() + pos, x.begin(), x.end());
  }
  void erase(size_type first, size_type last) {
    if (last > size() || first > last) { pxcrt::throw_invalid_index(); }
    if (first >= last) {
      return;
    }
    iterator const ifirst = value.begin() + first;
    iterator const ilast = ifirst + (last - first);
    value.erase(ifirst, ilast);
  }
  iterator begin() { return value.begin(); }
  iterator end() { return value.end(); }
  const_iterator begin() const { return value.begin(); }
  const_iterator end() const { return value.end(); }
private:
  base_deque value;
};

}; // namespace pxcrt
;
/* inline */

#define PXCRT_ALLOCA_LIMIT 200
#define PXCRT_ALLOCA_NTSTRING(tobj, s) \
  pxcrt::alloca_ntstring tobj(s, \
    (s.size() > 0 && s.rawarr()[s.size() - 1] == '\0') ? 0 : \
    (s.size() < PXCRT_ALLOCA_LIMIT) ? alloca(s.size() + 1) : 0)

namespace pxcrt {

struct alloca_ntstring {
  alloca_ntstring(bt_cslice<bt_uchar> const& s, void *extbuf)
    : need_free(false) {
    const unsigned char *const p = s.rawarr();
    const size_t len = s.size();
    if (len == 0) {
      buffer = "";
      return;
    }
    if (p[len - 1] == '\0') {
      buffer = reinterpret_cast<const char *>(p);
      return;
    }
    char *mbuf = 0;
    if (extbuf != 0) {
      mbuf = static_cast<char *>(extbuf);
    } else {
      if (len + 1 == 0) {
	PXC_THROW(std::bad_alloc());
      }
      mbuf = static_cast<char *>(malloc(len + 1));
      if (mbuf == 0) {
	PXC_THROW(std::bad_alloc());
      }
      need_free = true;
    }
    memcpy(mbuf, p, len);
    mbuf[len] = '\0';
    buffer = mbuf;
  }
  ~alloca_ntstring() {
    if (need_free) {
      free(const_cast<char *>(buffer));
    }
  }
  const char *get() const { return buffer; }
private:
  alloca_ntstring();
  alloca_ntstring(const alloca_ntstring&);
  alloca_ntstring& operator =(const alloca_ntstring&);
  const char *buffer;
  bool need_free;
};

}; // namespace pxcrt
;
/* inline */
#include <cmath>
#include <cfloat>
namespace numeric {
}; // namespace numeric
;
/* inline */
#include <boost/type_traits.hpp>
#include <boost/numeric/conversion/bounds.hpp>
#include <boost/limits.hpp>
namespace numeric {
template <typename T, bool arith> struct limit_impl_arithmetic;
template <typename T> struct limit_impl_arithmetic <T, true> {
  static T lowest() { return ::boost::numeric::bounds<T>::lowest(); }
  static T highest() { return ::boost::numeric::bounds<T>::highest(); }
  static T smallest() { return ::boost::numeric::bounds<T>::smallest(); }
};
template <typename T> struct limit_impl_arithmetic <T, false> {
  static T lowest() { return T(); }
  static T highest() { return T(); }
  static T smallest() { return T(); }
};
template <typename T> struct limit_impl
  : public limit_impl_arithmetic<T, ::boost::is_arithmetic<T>::value > { };
}; // namespace numeric
;
/* inline */

namespace pxcrt {

template <typename Tf>
struct compare_less {
  Tf f;
  template <typename Tk>
  inline bool operator () (const Tk& x, const Tk& y) const {
    return f.call$f(x, y) < 0;
  }
};

};

;
/* inline */
#include <map>
#include <set>
namespace pxcrt {

template <typename Tk, typename Tm, typename Tcmp>
struct map_conf {
  typedef std::map<Tk, Tm, compare_less<Tcmp> > base_map;
  typedef typename base_map::key_type key_type;
  typedef typename base_map::mapped_type mapped_type;
  typedef typename base_map::iterator iterator;
  typedef typename base_map::const_iterator const_iterator;
  static inline key_type const& get_key(iterator const& iter)
    { return iter->first; }
  static inline key_type const& get_ckey(const_iterator const& iter)
    { return iter->first; }
  static inline mapped_type& get_mapped(iterator const& iter)
    { return iter->second; }
  static inline mapped_type const& get_cmapped(const_iterator const& iter)
    { return iter->second; }
  static inline mapped_type& get_mapped(base_map& m, key_type const& k)
    { return m[k]; }
  static inline bool insert(base_map& m, key_type const& k,
    mapped_type const& v)
    { return m.insert(typename base_map::value_type(k, v)).second; }
  static inline bool erase(base_map& m, key_type const& k)
    { return m.erase(k); }
};

template <typename Tk, typename Tcmp>
struct set_conf {
  typedef std::set<Tk, compare_less<Tcmp> > base_map;
  typedef typename base_map::key_type key_type;
  typedef pxcrt::bt_unit mapped_type;
  typedef typename base_map::const_iterator iterator; /* always const */
  typedef typename base_map::const_iterator const_iterator;
  static inline key_type const& get_key(iterator const& iter)
    { return *iter; }
  static inline key_type const& get_ckey(const_iterator const& iter)
    { return *iter; }
  static inline mapped_type& get_mapped(iterator const& iter)
    { return pxcrt::unit_value; }
  static inline mapped_type const& get_cmapped(const_iterator const& iter)
    { return pxcrt::unit_value; }
  static inline mapped_type& get_mapped(base_map& m, key_type const& k)
    { m.insert(k); return pxcrt::unit_value; }
  static inline bool insert(base_map& m, key_type const& key,
    mapped_type const& val)
    { return m.insert(key).second; }
  static inline bool erase(base_map& m, key_type const& k)
    { return m.erase(k); }
};

template <typename Tk, typename Tm, typename Tcmp>
struct multimap_conf {
  typedef std::multimap<Tk, Tm, compare_less<Tcmp> > base_map;
  typedef typename base_map::key_type key_type;
  typedef typename base_map::mapped_type mapped_type;
  typedef typename base_map::value_type value_type;
  typedef typename base_map::iterator iterator;
  typedef typename base_map::const_iterator const_iterator;
  static inline key_type const& get_key(iterator const& iter)
    { return iter->first; }
  static inline key_type const& get_ckey(const_iterator const& iter)
    { return iter->first; }
  static inline mapped_type& get_mapped(iterator const& iter)
    { return iter->second; }
  static inline mapped_type const& get_cmapped(const_iterator const& iter)
    { return iter->second; }
  static inline mapped_type& get_mapped(base_map& m, key_type const& k) {
    iterator i = m.find(k);
    if (i == m.end()) {
      i = m.insert(value_type(k, mapped_type()));
    }
    return i->second;
  }
  static inline bool insert(base_map& m, key_type const& key,
    mapped_type const& val)
    { m.insert(value_type(key, val)); return true; }
  static inline bool erase(base_map& m, key_type const& k)
    { return m.erase(k); }
};

template <typename Tcnf> struct with_guard;

template <typename Tcnf, bool is_const> struct range_conf;

template <typename Tcnf> struct range_conf<Tcnf, false> {
  typedef typename Tcnf::iterator iterator;
  typedef typename Tcnf::mapped_type mapped_type;
  typedef with_guard<Tcnf> map_type;
};

template <typename Tcnf> struct range_conf<Tcnf, true> {
  typedef typename Tcnf::const_iterator iterator;
  typedef typename Tcnf::mapped_type const mapped_type;
  typedef with_guard<Tcnf> const map_type;
};

template <typename Tcnf, bool is_const> struct range_base {
  typedef typename Tcnf::base_map base_map;
  typedef typename base_map::key_type key_type;
  typedef typename range_conf<Tcnf, is_const>::mapped_type mapped_type;
  typedef typename range_conf<Tcnf, is_const>::iterator iterator;
  typedef typename base_map::const_iterator const_iterator;
  typedef typename base_map::key_compare key_compare;
  typedef typename range_conf<Tcnf, is_const>::map_type map_type;
  range_base() : start(), finish() { }
  range_base(const iterator& i0, const iterator& i1)
    : start(i0), finish(i1) { }
  range_base(map_type& c, const key_type& k0, const key_type& k1)
    : start(), finish() {
    key_compare cmp;
    if (cmp(k0, k1)) {
      start = c.lower_bound(k0);
      finish = c.upper_bound(k1);
    }
  }
  template <typename Tc> range_base(Tc& c)
    : start(c.begin()), finish(c.end()) { }
  bt_bool empty() const { return start == finish; }
  mapped_type& deref() const {
    if (empty()) { pxcrt::throw_invalid_index(); }
    return Tcnf::get_mapped(start);
  }
  mapped_type const& cderef() const {
    if (empty()) { pxcrt::throw_invalid_index(); }
    return Tcnf::get_cmapped(start);
  }
  static inline key_type const& get_key(const iterator& iter) {
    return Tcnf::get_key(iter);
  }
  static inline key_type const& get_ckey(const const_iterator& iter) {
    return Tcnf::get_ckey(iter);
  }
  static inline mapped_type& get_mapped(const iterator& iter) {
    return Tcnf::get_mapped(iter);
  }
  static inline const mapped_type& get_cmapped(const const_iterator& iter) {
    return Tcnf::get_cmapped(iter);
  }
  void increment_front(size_t i) {
    while (i > 0) {
      if (empty()) { pxcrt::throw_invalid_index(); }
      ++start;
      --i;
    }
  }
  range_base<Tcnf, is_const> range() const {
    return range_base<Tcnf, is_const>(start, finish);
  }
  range_base<Tcnf, true> crange() const {
    return range_base<Tcnf, true>(start, finish);
  }
  iterator begin() const { return start; }
  iterator end() const { return finish; }
public:
  iterator start;
  iterator finish;
};

template <typename Tcnf>
struct with_guard : public refguard_base {
  typedef Tcnf conf_type;
  typedef typename Tcnf::base_map base_map;
  typedef range_base<Tcnf, false> range_type;
  typedef range_base<Tcnf, true> crange_type;
  typedef typename base_map::key_type key_type;
  typedef typename Tcnf::mapped_type mapped_type;
  typedef typename base_map::size_type size_type;
  typedef typename base_map::iterator iterator;
  typedef typename base_map::const_iterator const_iterator;
  typedef typename base_map::iterator find_type;
  typedef typename base_map::const_iterator cfind_type;
  with_guard() { }
  with_guard(const with_guard& x)
    : v(x.v) { }
  with_guard(with_guard&& x)
    : v(x.v) { }
  with_guard(const range_type& x)
    : v(x.start, x.finish) { }
  with_guard(const crange_type& x)
    : v(x.start, x.finish) { }
  with_guard& operator =(const with_guard& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  with_guard& operator =(with_guard&& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  mapped_type& operator [](const key_type& k) {
    /* no need to call check_resize() because v[k] never invalidate any
     * iterators */
    return Tcnf::get_mapped(v, k);
  }
  mapped_type value_at(const key_type& k) { return Tcnf::get_mapped(v, k); }
  static inline key_type const& get_key(const iterator& iter) {
    return Tcnf::get_key(iter);
  }
  static inline key_type const& get_ckey(const const_iterator& iter) {
    return Tcnf::get_ckey(iter);
  }
  static inline mapped_type& get_mapped(const iterator& iter) {
    return Tcnf::get_mapped(iter);
  }
  static inline const mapped_type& get_cmapped(const const_iterator& iter) {
    return Tcnf::get_cmapped(iter);
  }
  bool exists(const key_type& k) const { return v.find(k) != v.end(); }
  iterator find(const key_type& k) { return v.find(k); }
  const_iterator find(const key_type& k) const { return v.find(k); }
  iterator notfound() { return end(); }
  const_iterator notfound() const { return end(); }
  iterator lower_bound(const key_type& k) { return v.lower_bound(k); }
  const_iterator lower_bound(const key_type& k) const {
    return v.lower_bound(k);
  }
  iterator upper_bound(const key_type& k) { return v.upper_bound(k); }
  const_iterator upper_bound(const key_type& k) const {
    return v.upper_bound(k);
  }
  bt_bool empty() const { return v.empty(); }
  size_type size() const { return v.size(); }
  bool insert(const key_type& k, const mapped_type& m) {
    /* insert() does not invalidate iterators */
    return Tcnf::insert(v, k, m);
  }
  size_type erase(const key_type& k) {
    check_resize();
    return v.erase(k);
  }
  void clear() {
    check_resize();
    v.clear();
  }
  void swap(with_guard& x) {
    check_resize();
    x.check_resize();
    v.swap(x.v);
  }
  range_type range() {
    return range_type(v.begin(), v.end());
  }
  crange_type crange() const {
    return crange_type(v.begin(), v.end());
  }
  range_type equal_range(const key_type& k) {
    const std::pair<iterator, iterator> r = v.equal_range(k);
    return range_type(r.first, r.second);
  }
  crange_type equal_crange(const key_type& k) const {
    const std::pair<const_iterator, const_iterator> r = v.equal_range(k);
    return crange_type(r.first, r.second);
  }
  iterator begin() { return v.begin(); }
  const_iterator begin() const { return v.begin(); }
  iterator end() { return v.end(); }
  const_iterator end() const { return v.end(); }
private:
  base_map v;
};

template <typename T> static inline void memfunc_swap(T& x, T& y)
{
  x.swap(y);
}

}; // namespace pxcrt
;
/* inline */

#include <stdexcept>
#include <vector>

namespace pxcrt {

void throw_invalid_index() __attribute__((noreturn));
void throw_null_dereference() __attribute__((noreturn));
void throw_invalid_field() __attribute__((noreturn));
void throw_would_invalidate() __attribute__((noreturn));
void throw_bad_alloc() __attribute__((noreturn));
void set_stack_trace_limit(size_t sz);

struct exception {
  exception();
  virtual ~exception() PXC_NOTHROW { }
  virtual bt_string message() const = 0;
  std::vector<void *> trace;
};

struct logic_error : virtual exception, std::logic_error {
  logic_error();
  virtual bt_string message() const;
};

struct runtime_error : virtual exception, std::runtime_error {
  runtime_error();
  virtual bt_string message() const;
};

struct bad_alloc : virtual exception, std::bad_alloc {
  bad_alloc();
  virtual bt_string message() const;
};

struct invalid_index : logic_error {
  virtual bt_string message() const;
};

struct invalid_field : logic_error {
  virtual bt_string message() const;
};

struct would_invalidate : logic_error {
  virtual bt_string message() const;
};

int main_nothrow(void (*main_f)(void));

}; // namespace pxcrt
;
/* inline */

#include <algorithm>

#define PXCRT_DBG_HASH(x)

namespace pxcrt {

struct denom_info {
  size_t num;
  size_t (*func)(size_t);
};

struct compare_denom_info {
  bool operator ()(const denom_info& x, const denom_info& y) const {
    return x.num < y.num;
  }
};

extern const denom_info denom_list[38];

template <size_t N> size_t modulo_fixed(size_t x)
{
  return x % N;
}

template <typename Tk, typename Tm>
struct hmap_entry {
  Tk first;
  Tm second;
  hmap_entry(const Tk& k, const Tm& m) : first(k), second(m) { }
};

template <typename Tk, typename Tm>
struct hmap_node {
  typedef hmap_entry<Tk, Tm> entry_type;
  typedef Tk key_type;
  typedef Tm mapped_type;
  hmap_node *next;
  entry_type entry;
  hmap_node(hmap_node *n, const Tk& k, const Tm& m)
    : next(n), entry(k, m) { }
};

template <typename Tnode, bool is_const> struct hmap_iterator;

template <typename Tnode> struct hmap_iterator<Tnode, false> {
  typedef typename Tnode::key_type key_type;
  typedef typename Tnode::mapped_type mapped_type;
  typedef Tnode node_type;
  node_type *pnode;
  node_type **pbucket;
};

template <typename Tnode> struct hmap_iterator<Tnode, true> {
  typedef const typename Tnode::key_type key_type;
  typedef const typename Tnode::mapped_type mapped_type;
  typedef const Tnode node_type;
  node_type *pnode;
  node_type **pbucket;
};

template <typename Tnode, bool is_const>
struct hmap_range {
  typedef hmap_iterator<Tnode, is_const> iterator;
  typedef hmap_iterator<Tnode, true> const_iterator;
  typedef typename iterator::key_type key_type;
  typedef typename iterator::mapped_type mapped_type;
  typedef typename iterator::node_type node_type;
  hmap_range() { start.pnode = 0; start.pbucket = 0; pbucket_end = 0; }
  template <typename Tc> hmap_range(Tc& c) {
    node_type **b = c.get_buckets();
    node_type **b_end = b + c.hdr.num_buckets;
    start.pnode = 0;
    for (; b != b_end; ++b) {
      if (*b != 0) {
	start.pnode = *b;
	break;
      }
    }
    start.pbucket = b;
    pbucket_end = b_end;
  }
  bool empty() const { return start.pbucket == pbucket_end; }
  void increment_front(size_t n) {
    for (size_t i = 0; i < n; ++i) {
      increment_front_one();
    }
  }
private:
  void increment_front_one() {
    if (empty()) { pxcrt::throw_invalid_index(); }
    node_type *p = start.pnode->next;
    if (p != 0) {
      start.pnode = p;
      return;
    }
    node_type **b = start.pbucket + 1;
    for (node_type *b = start.pbucket + 1; b != pbucket_end; ++b) {
      if (*b != 0) {
	start.pnode = *b;
	start.pbucket = b;
	return;
      }
    }
    start.pnode = 0;
    start.pbucket = pbucket_end;
  }
  mapped_type& deref() const {
    if (empty()) { pxcrt::throw_invalid_index(); }
    return start.pnode->entry.second;
  }
  mapped_type const& cderef() const {
    if (empty()) { pxcrt::throw_invalid_index(); }
    return start.pnode->entry.second;
  }
  static inline key_type const& get_key(const iterator& iter) {
    return iter.pnode->first;
  }
  static inline key_type const& get_ckey(const const_iterator& iter) {
    return iter.pnode->first;
  }
  static inline mapped_type& get_mapped(const iterator& iter) {
    return iter.pnode->second;
  }
  static inline mapped_type const& get_cmapped(const const_iterator& iter) {
    return iter.pnode->second;
  }
  iterator begin() const { return start; }
  iterator end() const {
    iterator i;
    i.pnode = 0;
    i.pbucket = pbucket_end;
    return i;
  }
private:
  iterator start;
  node_type **pbucket_end;
};

struct hmbuckets_hdr {
  size_t num_buckets;
  size_t (*buckets_modf)(size_t);
  size_t num_entries;
  size_t denom_ent;
};

template <typename Tk, typename Tm, typename Thash, typename Teq>
struct hash_map : public refguard_base {
  typedef Tk key_type;
  typedef Tm mapped_type;
  typedef Tm *find_type;
  typedef Tm const *cfind_type;
  typedef hmap_node<Tk, Tm> node_type;
  typedef hmap_entry<Tk, Tm> entry_type;
  typedef hmap_range<node_type, false> range_type;
  typedef hmap_range<node_type, true> crange_type;
  typedef hmap_iterator<node_type, false> iterator;
  typedef hmap_iterator<node_type, true> const_iterator;
  typedef size_t size_type;
  hash_map(size_t initial_size) {
    const size_t n = 38;
    const denom_info e = { initial_size, 0 };
    const denom_info *p = std::lower_bound(denom_list, denom_list + n, e,
      compare_denom_info());
    if (p == denom_list + n) {
      --p;
    }
    const size_t sz = p->num;
    const size_t max_len = (-sizeof(hmbuckets_hdr)) / sizeof(node_type *) - 1;
    if (sz >= max_len) { pxcrt::throw_bad_alloc(); }
    hdr = static_cast<hmbuckets_hdr *>(global_allocate_n(
      sizeof(hmbuckets_hdr) + sz * sizeof(node_type *)));
    hmbuckets_hdr& h = *hdr;
    node_type **const buckets = get_buckets();
    h.num_buckets = sz;
    h.buckets_modf = p->func;
    h.num_entries = 0;
    h.denom_ent = p - denom_list;
    for (size_type i = 0; i < h.num_buckets; ++i) {
      buckets[i] = 0;
    }
  }
  ~hash_map() {
    hmbuckets_hdr& h = *hdr;
    node_type **const buckets = get_buckets();
    for (size_type i = 0; i < h.num_buckets; ++i) {
      node_type *p = buckets[i];
      while (p != 0) {
	node_type *np = p->next;
	delete p;
	p = np;
      }
    }
    global_deallocate_n(hdr,
      sizeof(hmbuckets_hdr) + hdr->num_buckets * sizeof(node_type *));
  }
  Tm& operator [](const Tk& k) {
    rehash_if();
    hmbuckets_hdr& h = *hdr;
    size_t const hashval = hash.__call$f(k);
    size_t const bkt = h.buckets_modf(hashval);
    node_type **const buckets = get_buckets();
    assert(bkt < h.num_buckets);
    node_type *cur = buckets[bkt];
    for (node_type *p = cur; p != 0; p = p->next) {
      entry_type& pe = p->entry;
      if (eq.__call$f(pe.first, k)) {
	return pe.second;
      }
    }
    node_type *const nn = new node_type(cur, k, Tm());
    buckets[bkt] = nn;
    ++h.num_entries;
    return nn->entry.second;
  }
  bool insert(const Tk& k, const Tm& m, size_type hashval) {
    rehash_if();
    hmbuckets_hdr& h = *hdr;
    size_t const bkt = h.buckets_modf(hashval);
    node_type **const buckets = get_buckets();
    assert(bkt < h.num_buckets);
    node_type *cur = buckets[bkt];
    for (node_type *p = cur; p != 0; p = p->next) {
      entry_type& pe = p->entry;
      if (eq.__call$f(pe.first, k)) {
	pe.second = m;
	return false; /* not created */
      }
    }
    node_type *const nn = new node_type(cur, k, m);
    buckets[bkt] = nn;
    ++h.num_entries;
    return true; /* created */
  }
  bool insert(const Tk& k, const Tm& m) {
    return insert(k, m, hash.__call$f(k));
  }
  const Tm *find(const Tk& k, size_type hashval) const {
    size_t const bkt = hdr->buckets_modf(hashval);
    return find_internal(k, bkt);
  }
  Tm *find(const Tk& k, size_type hashval) {
    size_t const bkt = hdr->buckets_modf(hashval);
    return find_internal(k, bkt);
  }
  const Tm *find(const Tk& k) const {
    return find(k, hash.__call$f(k));
  }
  Tm *find(const Tk& k) {
    return find(k, hash.__call$f(k));
  }
  const Tm *notfound() const { return 0; }
  Tm *notfound() { return 0; }
  static inline Tm& get_mapped(Tm *ptr) { return *ptr; }
  static inline const Tm& get_cmapped(const Tm *ptr) { return *ptr; }
  void rehash_if() {
    if (!refguard_is_zero()) {
      return;
    }
    size_t const n = hdr->denom_ent;
    const denom_info& di = denom_list[n];
    if (hdr->num_entries > di.num && n < 38 - 1) {
      rehash_internal(hdr->num_entries);
    }
  }
  void rehash(size_type nsz) {
    if (!refguard_is_zero()) {
      return;
    }
    rehash_internal(nsz);
  }
  size_t size() const { return hdr->num_entries; }
  size_t bucket_count() const { return hdr->num_buckets; }
  size_t bucket_size(size_t bkt) const {
    if (bkt >= hdr->num_buckets) { return 0; }
    node_type *p = get_buckets()[bkt];
    size_t r = 0;
    for (p = get_buckets()[bkt]; p != 0; p = p->next, ++r) { }
    return r;
  }
private:
  void swap_internal(hash_map& x) {
    hmbuckets_hdr *hdr_x = x.hdr;
    x.hdr = hdr;
    hdr = hdr_x;
  }
  void rehash_internal(size_type nsz) {
    PXCRT_DBG_HASH(fprintf(stderr, "rehash %zu\n", nsz));
    hash_map x(nsz);
    node_type **const buckets = get_buckets();
    node_type **const x_buckets = x.get_buckets();
    hmbuckets_hdr& h= *hdr;
    hmbuckets_hdr& x_h = *x.hdr;
    for (node_type **b = buckets; b != buckets + h.num_buckets; ++b) {
      while (*b != 0) {
	node_type *p = *b;
	node_type *p_next = p->next;
	size_t const x_hashval = x.hash.__call$f(p->entry.first);
	size_t const x_bkt = x_h.buckets_modf(x_hashval);
	p->next = x_buckets[x_bkt];
	x_buckets[x_bkt] = p;
	*b = p_next;
	++x_h.num_entries;
	--h.num_entries;
      }
    }
    swap_internal(x);
  }
  Tm *find_internal(const Tk& k, size_type bkt) const {
    node_type **const buckets = get_buckets();
    assert(bkt < hdr->num_buckets);
    for (node_type *p = buckets[bkt]; p != 0; p = p->next) {
      entry_type& pe = p->entry;
      if (eq.__call$f(pe.first, k)) {
	return &pe.second;
      }
    }
    return 0;
  }
  node_type **get_buckets() const {
    return reinterpret_cast<node_type **>(
      reinterpret_cast<char *>(hdr) + sizeof(hmbuckets_hdr));
  }
private:
  hash_map(const hash_map& x);
  hash_map& operator =(const hash_map& x);
private:
  hmbuckets_hdr *hdr;
  Thash hash;
  Teq eq;
};

}; // namespace pxcrt

#undef PXCRT_DBG_HASH

;
/* inline */

#include <string>
#include <errno.h>

#ifdef PXCRT_DBG_RC
#define DBG_RC(x) x
#else
#define DBG_RC(x)
#endif
#ifdef PXCRT_DBG_MTX
#define DBG_MTX(x) x
#else
#define DBG_MTX(x)
#endif
#ifdef PXCRT_DBG_COND
#define DBG_COND(x) x
#else
#define DBG_COND(x)
#endif

#include <cstdlib>
#include <mutex>
#include <condition_variable>
#include <atomic>

namespace pxcrt {

typedef std::recursive_mutex mutex;
typedef std::condition_variable_any condition_variable;

struct monitor {
  monitor() { }
  monitor(monitor const& x) { }
  monitor& operator =(monitor const& x) {
    return *this;
  }
  mutex mtx;
  condition_variable cond;
};

template <typename T>
struct rcval {
  /* rcval: single threaded, mutable or immutable */
  typedef T value_type;
  rcval() : value() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit rcval(const T& v) : value(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  rcval(const T0& a0) : value(a0) { }
  template <typename T0, typename T1>
  rcval(const T0& a0, const T1& a1) : value(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  rcval(const T0& a0, const T1& a1, const T2& a2) : value(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, refcnt$z()));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, refcnt$z()));
    if (count$z.decref$z()) {
      this->~rcval<T>();
      this->deallocate(this);
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  size_t refcnt$z() const { return count$z.refcnt$z(); }
  /* void lock$z() const { } */
  /* void unlock$z() const { } */
  /* void wait$z() const { } */
  /* void notify_one$z() const { } */
  /* void notify_all$z() const { } */
  static rcval<T> *allocate() {
    return local_allocate< rcval<T> >();
  }
  static void deallocate(const rcval<T> *ptr) {
    local_deallocate< rcval<T> >(ptr);
  }
public:
  mutable stcount count$z;
  T value;
private:
  rcval(const rcval&);
  rcval& operator =(const rcval&);
};

template <typename T>
struct trcval {
  /* trcval: multithreaded, mutable */
  typedef T value_type;
  trcval() : value() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit trcval(const T& v) : value(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  trcval(const T0& a0) : value(a0) { }
  template <typename T0, typename T1>
  trcval(const T0& a0, const T1& a1) : value(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  trcval(const T0& a0, const T1& a1, const T2& a2) : value(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "ir %p %ld +1\n", this, refcnt$z()));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "dr %p %ld -1\n", this, refcnt$z()));
    if (count$z.decref$z()) {
      this->~trcval<T>();
      this->deallocate(this);
      DBG_RC(fprintf(stdout, "de %p\n", this));
    }
  }
  size_t refcnt$z() const { return count$z.refcnt$z(); }
  void lock$z() const { monitor$z.mtx.lock(); }
  void unlock$z() const { monitor$z.mtx.unlock(); }
  void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
  void notify_one$z() const { monitor$z.cond.notify_one(); }
  void notify_all$z() const { monitor$z.cond.notify_all(); }
  static trcval<T> *allocate() {
    return allocate_single< trcval<T> >();
  }
  static void deallocate(const trcval<T> *ptr) {
    deallocate_single< trcval<T> >(ptr);
  }
public:
  mutable mtcount count$z;
  mutable monitor monitor$z;
  T value;
private:
  trcval(const trcval&);
  trcval& operator =(const trcval&);
};

template <typename T>
struct tircval {
  /* tircval: multithreded, immutable */
  typedef T value_type;
  tircval() : value() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit tircval(const T& v) : value(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0> explicit
  tircval(const T0& a0) : value(a0) { }
  template <typename T0, typename T1>
  tircval(const T0& a0, const T1& a1) : value(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  tircval(const T0& a0, const T1& a1, const T2& a2) : value(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "ir %p %ld +1\n", this, refcnt$z()));
    count$z.incref$z();
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "dr %p %ld -1\n", this, refcnt$z()));
    if (count$z.decref$z()) {
      this->~tircval<T>();
      this->deallocate(this);
      DBG_RC(fprintf(stdout, "de %p\n", this));
    }
  }
  size_t refcnt$z() const { return count$z.refcnt$z(); }
  /* void lock$z() const { } */
  /* void unlock$z() const { } */
  /* void wait$z() const { } */
  static tircval<T> *allocate() {
    return allocate_single< tircval<T> >();
  }
  static void deallocate(const tircval<T> *ptr) {
    deallocate_single< tircval<T> >(ptr);
  }
public:
  mutable mtcount count$z;
  T value;
private:
  tircval(const tircval&);
  tircval& operator =(const tircval&);
};

template <typename T>
struct rcptr { /* T must have an intrusive count */
  typedef T target_type;
  typedef void range_type; /* guard object requires this */
  typedef void crange_type; /* guard object requires this */
  template <typename Tx> friend struct rcptr;
  rcptr(T *rawptr) : ptr(rawptr) { } /* for fast boxing constr */
  rcptr(const rcptr& x) : ptr(x.ptr) { ptr->incref$z(); }
  /* ptr{foo} to ptr{ifoo} */
  template <typename Tx> rcptr(const rcptr<Tx>& x) : ptr(x.get()) {
    ptr->incref$z();
  }
  /* boxing foo to ptr{ifoo} */
  template <typename Tx> explicit rcptr(const Tx& x)
    : ptr(make_rawptr(x)) { }
  ~rcptr() { ptr->decref$z(); }
  rcptr& operator =(T *x) { return set(x); }
  template <typename Tx> rcptr& operator =(Tx *x) { return set(x); }
  rcptr& operator =(const rcptr& x) { return set(x.ptr); }
  template <typename Tx> rcptr& operator =(const rcptr<Tx>& x) {
    return set(x.ptr);
  }
  T *get() const { return ptr; }
  T& operator *() const { return *ptr; }
  T *operator ->() const { return ptr; }
  void inc_refguard() const { ptr->lock$z(); }
  void dec_refguard() const { ptr->unlock$z(); }
  template <typename Tx> static inline T *make_rawptr(const Tx& x) {
    T *p = T::allocate();
    PXC_TRY {
      new (p) T(x);
    } PXC_CATCH(...) {
      T::deallocate(p);
      PXC_RETHROW;
    }
    return p;
  }
  static inline T *make_rawptr() {
    T *p = T::allocate();
    PXC_TRY {
      new (p) T();
    } PXC_CATCH(...) {
      T::deallocate(p);
      PXC_RETHROW;
    }
    return p;
  }
  template <typename Tc> struct guard_ref {
    guard_ref(Tc& x) : v(x) { v.inc_refguard(); }
    ~guard_ref() { v.dec_refguard(); }
    Tc& get() { return v; }
    typename Tc::range_type get_range() 
      { return typename Tc::range_type(v); }
    typename Tc::crange_type get_crange() 
      { return typename Tc::crange_type(v); }
  private:
    Tc& v;
    guard_ref(const guard_ref&);
    guard_ref& operator =(const guard_ref&);
  };
  template <typename Tc> struct guard_val {
    guard_val(const Tc& x) : v(x) { v.inc_refguard(); }
    ~guard_val() { v.dec_refguard(); }
    Tc& get() { return v; }
    typename Tc::range_type get_range() 
      { return typename Tc::range_type(v); }
    typename Tc::crange_type get_crange() 
      { return typename Tc::crange_type(v); }
  private:
    Tc v;
    guard_val(const guard_val&);
    guard_val& operator =(const guard_val&);
  };
private:
  T *ptr; /* not nullable */
private:
  rcptr& set(T *x) {
    x->incref$z();
    ptr->decref$z();
    ptr = x;
    return *this;
  }
};

template <typename T> struct lock_guard
{
  lock_guard(const rcptr<T>& p) : ptr(p), objref(*p) { objref.lock$z(); }
  ~lock_guard() { objref.unlock$z(); }
  T *get() const { return &objref; }
  T& operator *() const { return objref; }
  T *operator ->() const { return &objref; }
  void wait() { objref.wait$z(); }
  void notify_one() { objref.notify_one$z(); }
  void notify_all() { objref.notify_all$z(); }
private:
  lock_guard(const lock_guard&);
  lock_guard& operator =(const lock_guard&);
private:
  rcptr<T> ptr;
  T& objref;
};

template <typename T> struct lock_cguard
{
  lock_cguard(const rcptr<const T>& p) : ptr(p), objref(*p)
    { objref.lock$z(); }
  ~lock_cguard() { objref.unlock$z(); }
  const T *get() const { return &objref; }
  const T& operator *() const { return objref; }
  const T *operator ->() const { return &objref; }
  void wait() { objref.wait$z(); }
  void notify_one() { objref.notify_one$z(); }
  void notify_all() { objref.notify_all$z(); }
private:
  lock_cguard(const lock_cguard&);
  lock_cguard& operator =(const lock_cguard&);
private:
  rcptr<const T> ptr;
  const T& objref;
};

template <typename T> typename T::value_type deref_value(const rcptr<T>& p)
{
  return p->value;
}

template <typename T> T deref(const rcptr<T>& p)
{
  return *p;
}

template <typename Tto, typename Tfrom> Tto const&
downcast_const(Tfrom const& from) {
  return dynamic_cast<Tto const&>(from);
}

template <typename Tto, typename Tfrom> Tto&
downcast_mutable(Tfrom& from) {
  return dynamic_cast<Tto&>(from);
}

template <typename T, typename Tobj> bool
instanceof(Tobj const& x) {
  return dynamic_cast<T const *>(&x) != 0;
}

template <typename Tto, typename Tfrom> Tto
pointer_downcast(Tfrom const& from) {
  typename Tto::target_type& ref = dynamic_cast<typename Tto::target_type&>(
    *(from.get()));
  ref.incref$z();
  return Tto(&ref);
}

}; // namespace pxcrt
;
/* inline */
namespace pxcrt {

template <typename T> struct rawptr { typedef T *type; };
template <typename T> struct crawptr { typedef const T *type; };

template <typename T> struct rawref { typedef T& type; };
template <typename T> struct crawref { typedef const T& type; };

typedef char *charptr;
typedef char const *ccharptr;

template <typename T> struct nomove
{
  nomove(T const& v) : value(v) { }
  T value;
private:
  nomove(nomove const&);
  nomove& operator =(nomove const&);
};

template <typename T> static inline T *
address(T& x) { return &x; }
template <typename T> static inline T const *
caddress(T const& x) { return &x; }

template <typename T> static inline typename T::mapped_type *
array_to_rawptr(T& x) { return x.rawarr(); }
template <typename T> static inline typename T::mapped_type const *
array_to_crawptr(T const& x) { return x.rawarr(); }

template <typename T> static inline T *
slice_to_rawptr(bt_slice<T> const& x) { return x.rawarr(); }
template <typename T> static inline T const *
slice_to_crawptr(bt_cslice<T> const& x) { return x.rawarr(); }
template <typename T> static inline T const *
cslice_to_crawptr(bt_cslice<T> const& x) { return x.rawarr(); }

static inline bt_uchar const *
strlit_to_crawptr(bt_strlit const& x) { return x.rawarr(); }

template <typename T> static inline void *
rawptr_to_voidptr(T *x) { return x; }
template <typename T> static inline void const *
crawptr_to_cvoidptr(T const *x) { return x; }
template <typename T> static inline char *
rawptr_to_charptr(T *x) { return reinterpret_cast<char *>(x); }
template <typename T> static inline char const *
crawptr_to_ccharptr(T const *x) { return reinterpret_cast<const char *>(x); }

template <typename Tto, typename Tfrom> static inline Tto *
rawptr_cast(Tfrom *x) { return reinterpret_cast<Tto *>(x); }
template <typename Tto, typename Tfrom> static inline Tto const *
crawptr_cast(Tfrom const *x) { return reinterpret_cast<Tto const *>(x); }

template <typename T> static inline T *
size_t_to_rawptr(size_t x) { return reinterpret_cast<T *>(x); }
template <typename T> static inline T const *
size_t_to_crawptr(size_t x) { return reinterpret_cast<T const *>(x); }

template <typename T> static inline bt_size_t
rawptr_to_size_t(T *x) { return reinterpret_cast<bt_size_t>(x); }
template <typename T> static inline bt_size_t
crawptr_to_size_t(T const *x) { return reinterpret_cast<bt_size_t>(x); }

template <typename Tx, typename Ty> static inline bt_bool
rawptr_eq(Tx x, Tx /* not Ty */ y) { return x == y; }
template <typename Tx, typename Ty> static inline bt_bool
rawptr_ne(Tx x, Tx /* not Ty */ y) { return x != y; }
template <typename Tx, typename Ty> static inline Tx
rawptr_add(Tx x, size_t y) { return x + y; }
template <typename Tx, typename Ty> static inline Tx
rawptr_sub(Tx x, size_t y) { return x - y; }

template <typename Tto, typename Tfrom> static inline Tto
rawptr_upcast(Tfrom x)
{
  return x;
}

};
;
/* inline */
namespace pxcrt {
template <typename Tbase, typename Tid>
struct distinct { typedef Tbase type; };
};
;
/* inline */
namespace pxcrt {
struct io {
  io(int const dummy) { } /* disable default constructor */
};
};
;
/* inline */
namespace pxcrt {
#ifdef PXC_POSIX
typedef ::suseconds_t suseconds_t;
#else
typedef long suseconds_t;
#endif
};
;
/* inline */
#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>
#ifdef PXC_POSIX
#include <unistd.h>
#else
#include <io.h>
#endif
namespace pxcrt {
using namespace pxcrt;

#ifdef PXC_POSIX
typedef struct ::stat statbuf;
typedef ::off_t off_t;
typedef ::dev_t dev_t;
typedef ::ino_t ino_t;
typedef ::mode_t mode_t;
typedef ::nlink_t nlink_t;
typedef ::uid_t uid_t;
typedef ::gid_t gid_t;
typedef ::blksize_t blksize_t;
typedef ::blkcnt_t blkcnt_t;
#else
typedef struct ::_stat statbuf;
typedef __int64 off_t;
typedef unsigned __int64 dev_t;
typedef unsigned __int64 ino_t;
typedef unsigned mode_t;
typedef unsigned nlink_t;
typedef unsigned uid_t;
typedef unsigned gid_t;
typedef unsigned __int64 blksize_t;
typedef unsigned __int64 blkcnt_t;
#define S_ISUID   _S_ISUID
#define S_ISGID   _S_ISGID
#define S_ISVTX   _S_ISVTX
#define S_IREAD   _S_IREAD
#define S_IWRITE  _S_IWRITE
#define S_IEXEC   _S_IEXEC
#define S_IRUSR   _S_IREAD
#define S_IWUSR   _S_IWRITE
#define S_IXUSR   _S_IEXEC
#define S_IRWXU   (_S_IREAD|_S_IWRITE|_S_IEXEC)
#define S_IRGRP   _S_IREAD
#define S_IWGRP   _S_IWRITE
#define S_IXGRP   _S_IEXEC
#define S_IRWXG   (_S_IREAD|_S_IWRITE|_S_IEXEC)
#define S_IROTH   _S_IREAD
#define S_IWOTH   _S_IWRITE
#define S_IXOTH   _S_IEXEC
#define S_IRWXO   (_S_IREAD|_S_IWRITE|_S_IEXEC)
#endif

struct file_st;

int file_st_close(file_st& f);

struct file_st_rep {
  file_st_rep(int fd) : fd(fd) { }
  ~file_st_rep() {
    /* don't close stdin/out/err */
    if (fd > 2) {
#ifdef PXC_POSIX
      ::close(fd);
#else
      ::_close(fd);
#endif
    }
  }
  int get() const { return fd; }
  friend int file_st_close(file_st& f);
private:
  int fd;
  file_st_rep(const file_st_rep&);
  file_st_rep& operator =(const file_st_rep&);
};

struct file_mt_rep {
  file_mt_rep(int fd) : fd(fd) { }
  ~file_mt_rep() {
    /* don't close stdin/out/err */
    if (fd > 2) {
#ifdef PXC_POSIX
      ::close(fd);
#else
      ::_close(fd);
#endif
    }
  }
  int get() const { return fd; }
private:
  const int fd;
  file_mt_rep(const file_mt_rep&);
  file_mt_rep& operator =(const file_mt_rep&);
};

struct file {
  virtual int get() const = 0;
  virtual void incref$z() const = 0;
  virtual void decref$z() const = 0;
  virtual size_t refcnt$z() const = 0;
};

struct file_st : public file {
  typedef ::pxcrt::rcptr< pxcrt::rcval<file_st_rep> > ptr_type;
  ptr_type ptr;
  file_st(int fd) : ptr(ptr_type::make_rawptr(fd)) { }
  virtual int get() const { return ptr->value.get(); }
  size_t refcnt$z() const { return count.refcnt$z(); }
  void incref$z() const { count.incref$z(); }
  void decref$z() const {
    if (count.decref$z()) {
      this->~file_st();
      this->deallocate(this);
    }
  }
  static file_st *allocate() {
    return pxcrt::allocate_single<file_st>();
  }
  static void deallocate(file_st const *ptr) {
    pxcrt::deallocate_single<file_st>(ptr);
  }
  mutable pxcrt::stcount count;
};

struct file_mt : public file {
  typedef ::pxcrt::rcptr< pxcrt::tircval<file_mt_rep> > ptr_type;
  ptr_type ptr;
  file_mt(int fd) : ptr(ptr_type::make_rawptr(fd)) { }
  virtual int get() const { return ptr->value.get(); }
  size_t refcnt$z() const { return count.refcnt$z(); }
  void incref$z() const { count.incref$z(); }
  void decref$z() const {
    if (count.decref$z()) {
      this->~file_mt();
      this->deallocate(this);
    }
  }
  /* lock/unlock are no-op */
  void lock$z() const { }
  void unlock$z() const { }
  /* does not implement wait/notify */
  static file_mt *allocate() {
    return pxcrt::allocate_single<file_mt>();
  }
  static void deallocate(file_mt const *ptr) {
    pxcrt::deallocate_single<file_mt>(ptr);
  }
  mutable pxcrt::mtcount count;
};

};
;
/* inline */
#include <csignal>
namespace pxcrt {
typedef void (*sighandler_t)(int);
};
;
/* inline */
#ifdef PXC_POSIX
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#endif

namespace pxcrt {
#ifdef PXC_POSIX
typedef ::pid_t pid_t;
#else
typedef int pid_t; /* dummy */
#endif
};
;
/* inline */

#include <thread>
#include <system_error>

namespace pxcrt {

typedef std::thread *thread_ptr;

};

;
/* inline */
namespace pxcrt {
template <typename T> struct aligned_16 {
  aligned_16(T const& value0) : value(value0) { }
  T value alignas(16);
};
};
;
/* inline */

#ifdef _MSC_VER
#define GLM_FORCE_INLINE
#endif
#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtx/dual_quaternion.hpp>

#undef PXC_GLM_ENABLE_DUALQUAT

namespace pxcrt { namespace glmpx {

template <typename T> struct tvec2 { typedef glm::vec2 type; };
template <typename T> struct tvec3 { typedef glm::vec3 type; };
template <typename T> struct tvec4 { typedef glm::vec4 type; };
template <typename T> struct tquat { typedef glm::quat type; };
#ifdef PXC_GLM_ENABLE_DUALQUAT
template <typename T> struct tdualquat {
  typedef glm::tdualquat<T, glm::highp> type; };
#endif
template <typename T> struct tmat2 { typedef glm::mat2 type; };
template <typename T> struct tmat3 { typedef glm::mat3 type; };
template <typename T> struct tmat4 { typedef glm::mat4 type; };
template <typename T> struct tmat2x3 { typedef glm::mat2x3 type; };
template <typename T> struct tmat3x2 { typedef glm::mat3x2 type; };
template <typename T> struct tmat2x4 { typedef glm::mat2x4 type; };
template <typename T> struct tmat4x2 { typedef glm::mat4x2 type; };
template <typename T> struct tmat3x4 { typedef glm::mat3x4 type; };
template <typename T> struct tmat4x3 { typedef glm::mat4x3 type; };

}; };

;
/* inline */
namespace pxcrt {

template <typename T> static inline T&
rawptr___deref(T *x) { return *x; }
template <typename T> static inline T const&
crawptr___deref(T const *x) { return *x; }

template <typename T> static inline bt_slice<T>
rawptr_to_slice(T *x, bt_size_t xlen) { return bt_slice<T>(x, xlen); }
template <typename T> static inline bt_cslice<T>
crawptr_to_cslice(T const *x, bt_size_t xlen) { return bt_cslice<T>(x, xlen); }

template <typename T> static inline void
delete_impl(T x) { delete x; }

}
;
/* inline */
#include <SDL.h>
#include <SDL_shape.h>
#include <SDL_syswm.h>
#include <SDL_ttf.h>
#include <SDL_image.h>
;
/* inline */

namespace pxcrt {

template <typename T, size_t len>
struct rawarray {
  typedef T type[len];
};

template <typename T, size_t len>
static inline T
rawarray___getelem(typename rawarray<T, len>::type const& x, size_t idx)
{
  #ifdef PXC_NO_BOUNDS_CHECKING
  if (idx >= len) { pxcrt::throw_invalid_index(); }
  #endif
  return x[idx];
}

template <typename T, size_t len>
static inline void
rawarray___setelem(typename rawarray<T, len>::type & x, size_t idx, T const& v)
{
  #ifdef PXC_NO_BOUNDS_CHECKING
  if (idx >= len) { pxcrt::throw_invalid_index(); }
  #endif
  x[idx] = v;
}

template <typename T, size_t len>
static inline bt_slice<T>
rawarray_to_slice(typename rawarray<T, len>::type & x)
{
  return bt_slice<T>(x, len);
}

template <typename T, size_t len>
static inline bt_cslice<T>
rawarray_to_cslice(typename rawarray<T, len>::type const& x)
{
  return bt_cslice<T>(x, len);
}

};

;
/* inline */
namespace pxcrt {

template <typename T>
struct cxxref {
  typedef T& type;
};

template <typename T>
struct cxxconst {
  typedef T const type;
};

template <typename Tr>
struct tfuncptr0 {
  typedef Tr (*type)();
};

template <typename Tr, typename T0>
struct tfuncptr1 {
  typedef Tr (*type)(T0);
};

template <typename Tr, typename T0, typename T1>
struct tfuncptr2 {
  typedef Tr (*type)(T0, T1);
};

template <typename Tr, typename T0, typename T1, typename T2>
struct tfuncptr3 {
  typedef Tr (*type)(T0, T1, T2);
};

template <typename Tr, typename T0, typename T1, typename T2, typename T3>
struct tfuncptr4 {
  typedef Tr (*type)(T0, T1, T2, T3);
};

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4>
struct tfuncptr5 {
  typedef Tr (*type)(T0, T1, T2, T3, T4);
};

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5>
struct tfuncptr6 {
  typedef Tr (*type)(T0, T1, T2, T3, T4, T5);
};

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename T6>
struct tfuncptr7 {
  typedef Tr (*type)(T0, T1, T2, T3, T4, T5, T6);
};

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename T6, typename T7>
struct tfuncptr8 {
  typedef Tr (*type)(T0, T1, T2, T3, T4, T5, T6, T7);
};

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename T6, typename T7, typename T8>
struct tfuncptr9 {
  typedef Tr (*type)(T0, T1, T2, T3, T4, T5, T6, T7, T8);
};

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
struct tfuncptr10 {
  typedef Tr (*type)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9);
};

};
;
/* inline */

#ifndef GL_GLEXT_PROTOTYPES
#define GL_GLEXT_PROTOTYPES
#endif

#ifdef __APPLE__
#include <TargetConditionals.h>
#if TARGET_OS_IPHONE
/* ios */
#include <OpenGLES/ES3/gl.h>
#include <OpenGLES/ES3/glext.h>
#include <OpenGLES/ES2/gl.h>
#include <OpenGLES/ES2/glext.h>
#include <OpenGLES/ES1/gl.h>
#include <OpenGLES/ES1/glext.h>
#else
/* macos */
#include <OpenGL/gl3.h>
#include <OpenGL/gl3ext.h>
#include <OpenGL/gl.h>
#include <OpenGL/glext.h>
#endif
#elif defined ANDROID
/* android */
#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>
#include <GLES/gl.h>
#include <GLES/glext.h>
#elif defined _MSC_VER
/* windows */
#include <GL/glew.h>
#include <GL/wglew.h>
#else
/* linux */
#include <GL/gl.h>
#include <GL/glext.h>
#endif

;
/* inline */
namespace pgl3d$n {
namespace glresource$n {
template <typename T> struct handle
{
  handle(T const& v) : value(v) { }
  T value;
private:
  handle(handle const&);
  handle& operator =(handle const&);
};
};
};
;
/* inline */
#ifdef _MSC_VER
#include <ShellScalingAPI.h>
#endif
;
/* inline */

#undef PXC_HAS_DEVICE_MOTION
#ifdef __APPLE__
#include <TargetConditionals.h>
#if TARGET_OS_IPHONE
#include "pgl3d_device_motion.h"
#define PXC_HAS_DEVICE_MOTION
#endif
#endif

#ifndef PXC_HAS_DEVICE_MOTION

namespace pxcrt { namespace ext {

struct device_motion
{
  device_motion(io const& iop, double interval) {
    value_xyzw[0] = 0;
    value_xyzw[1] = 0;
    value_xyzw[2] = 0;
    value_xyzw[3] = 1;
  }
  float value_xyzw[4];
  void update() { }
};

}; };

#endif

;
/* inline */
#include "btBulletDynamicsCommon.h"
;
namespace $n {
}; /* namespace */
namespace exception$n { 
struct exception;
struct logic_error;
struct runtime_error;
struct bad_alloc;
struct exception;
struct logic_error;
struct runtime_error;
struct bad_alloc;
}; /* namespace exception */
namespace io$n { namespace file$n { 
struct file;
};}; /* namespace io::file */
namespace pgl3d$n { namespace glgeometry$n { 
struct build_context_i$i;
};}; /* namespace pgl3d::glgeometry */
namespace pgl3d$n { namespace pglbase$n { 
struct make_vertices_i$i;
struct pgldrawer_export_i$i;
};}; /* namespace pgl3d::pglbase */
namespace pgl3d$n { namespace glshader$n { 
struct glshader_i$i;
};}; /* namespace pgl3d::glshader */
namespace pgl3d$n { namespace drawer$n { 
struct pgldrawer_i$i;
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace application$n { 
struct pgl3d_application$i;
struct pgl3d_scene_shared$i;
struct pgl3d_scene$i;
};}; /* namespace pgl3d::application */
namespace pgl3d$n { namespace dynamics_world$n { 
struct pgl3dCollisionShape_i$i;
};}; /* namespace pgl3d::dynamics_world */
namespace callable$n { 
struct tcallable$i$p$meta$n$$void$t$q$m$ll$r$;
struct callable$i$p$meta$n$$void$t$q$m$ll$r$;
struct callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$;
struct callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$;
}; /* namespace callable */
namespace text$n { namespace string$n { namespace serialize$n { 
struct ser_default$s;
};};}; /* namespace text::string::serialize */
namespace io$n { namespace process$n { 
struct pipe_process$s;
struct wait_t$s;
};}; /* namespace io::process */
namespace thread$n { namespace queue$n { 
struct task_queue$s;
struct task_queue_shared$s;
};}; /* namespace thread::queue */
namespace pgl3d$n { namespace scene_node$n { 
struct joint_id_type$s;
struct scene_node$s;
};}; /* namespace pgl3d::scene_node */
namespace container$n { namespace tree_map$n { 
struct cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$;
};}; /* namespace container::tree_map */
namespace pgl3d$n { namespace scene_node$n { 
struct node_factory$s;
struct node_buffer_info$s;
struct node_vs_info$s;
struct node_joint_info$s;
};}; /* namespace pgl3d::scene_node */
namespace pgl3d$n { namespace glvertex$n { 
struct node_joint$s;
struct vertices$s;
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace wfobj$n { 
struct wfobject$s;
struct wfgroup$s;
struct wfelement$s;
};}; /* namespace pgl3d::wfobj */
namespace pgl3d$n { namespace glgeometry$n { 
struct vertex_attr$s;
struct rand_generator$s;
struct mesh_index$s;
};}; /* namespace pgl3d::glgeometry */
namespace pgl3d$n { namespace pglbase$n { 
struct instance_data$s;
struct position_angle$s;
struct projection_info$s;
struct vertex_buffer_pool_key$s;
struct texture_info$s;
struct node_common_data$s;
};}; /* namespace pgl3d::pglbase */
namespace pgl3d$n { namespace shader_config$n { 
struct shader_config$s;
};}; /* namespace pgl3d::shader_config */
namespace pgl3d$n { namespace glbuffer$n { 
struct vertex_set$s;
};}; /* namespace pgl3d::glbuffer */
namespace pgl3d$n { namespace glresource$n { 
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$;
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace glbuffer$n { 
struct async_buffer$s;
struct vertex_buffer$s;
};}; /* namespace pgl3d::glbuffer */
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
struct aggregated_ibuffer$s;
};}; /* namespace pgl3d::aggregated_ibuffer */
namespace pgl3d$n { namespace drawer$n { 
struct triangles_uniforms$s;
struct triangles_vertex_attributes$s;
struct triangles2_vertex_attributes$s;
struct zprepass_vertex_attributes$s;
struct zprepass2_vertex_attributes$s;
struct shadowmap_vertex_attributes$s;
struct shadowmap2_vertex_attributes$s;
struct triangles_instance_attributes$s;
struct zprepass_uniforms$s;
struct shadowmap_uniforms$s;
struct font_uniforms$s;
struct font2_uniforms$s;
struct font2_instance_attributes$s;
struct font2_vertex_attributes$s;
struct rect2d_vertex_attributes$s;
struct rect2d_instance_attributes$s;
struct rect2d_uniforms$s;
struct particle_uniforms$s;
struct particle_instance_attributes$s;
struct particle_vertex_attributes$s;
struct particle_bb_uniforms$s;
struct particle_bb_vertex_attributes$s;
struct lineparticle_uniforms$s;
struct lineparticle_vertex_attributes$s;
struct lineparticle_instance_attributes$s;
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glresource$n { 
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$;
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace drawer$n { 
struct texture_data$s;
struct drawer_triangles$s;
struct drawer_triangles2$s;
struct drawer_lineparticle$s;
struct drawer_particle$s;
struct drawer_particle_bb$s;
struct drawer_font2$s;
struct drawer_rect2d$s;
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace pglmotion$n { 
struct motion_thread_shared$s;
};}; /* namespace pgl3d::pglmotion */
namespace callable$n { 
struct callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$;
}; /* namespace callable */
namespace pgl3d$n { namespace pglmotion$n { 
struct motion_thread_object$s;
};}; /* namespace pgl3d::pglmotion */
namespace pgl3d$n { namespace glresource$n { 
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$;
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$;
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace pglshader$n { 
struct shadowmap_fbo$s;
};}; /* namespace pgl3d::pglshader */
namespace pgl3d$n { namespace glresource$n { 
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$;
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace intern_pool$n { 
struct intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$;
};}; /* namespace pgl3d::intern_pool */
namespace pgl3d$n { namespace pglshader$n { 
struct pglshader$s;
struct build_context_impl$s;
};}; /* namespace pgl3d::pglshader */
namespace pointer$n { namespace raw$n { 
struct scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$;
struct scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$;
};}; /* namespace pointer::raw */
namespace pgl3d$n { namespace sdlcontext$n { 
struct sdlcontext$s;
};}; /* namespace pgl3d::sdlcontext */
namespace pgl3d$n { namespace mainloop$n { 
struct frame_statistics$s;
struct framerate_control$s;
};}; /* namespace pgl3d::mainloop */
namespace pgl3d$n { namespace dynamics_world$n { 
struct pgl3dRigidBody$s;
struct pgl3dDynamicsWorld$s;
};}; /* namespace pgl3d::dynamics_world */
namespace demoapp$n { 
struct player_info$s;
struct input_control$s;
struct app_impl$s;
struct demoapp_application$s;
struct demoapp_scene_shared$s;
struct scene_control$s;
struct demoapp_scene$s;
struct lpbullet_data$s;
}; /* namespace demoapp */
namespace exception$n { 
struct unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$;
}; /* namespace exception */
namespace io$n { namespace errno$n { 
struct errno_or_value$v$p$io$$file$n$$file_st$s$r$;
struct errno_or_value$v$p$io$$file$n$$file_mt$s$r$;
struct errno_or_value$v$p$meta$n$$size_t$t$r$;
struct errno_or_value$v$p$io$$file$n$$off_t$s$r$;
};}; /* namespace io::errno */
namespace exception$n { 
struct unexpected_value_template$s$p$errno__t$ls$r$;
}; /* namespace exception */
namespace io$n { namespace errno$n { 
struct errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$;
};}; /* namespace io::errno */
namespace algebraic$n { 
struct pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$;
}; /* namespace algebraic */
namespace io$n { namespace errno$n { 
struct errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$;
};}; /* namespace io::errno */
namespace algebraic$n { 
struct option$v$p$io$$file$n$$file_st$s$r$;
}; /* namespace algebraic */
namespace io$n { namespace errno$n { 
struct errno_or_value$v$p$io$$process$n$$pid_t$s$r$;
struct errno_or_value$v$p$io$$process$n$$pipe_process$s$r$;
struct errno_or_value$v$p$io$$process$n$$wait_t$s$r$;
struct errno_or_value$v$p$io$$process$n$$status_t$s$r$;
};}; /* namespace io::errno */
namespace callable$n { 
struct tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace thread$n { 
struct thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$;
struct thread$s$p$thread$$queue$n$$queue_thread_main$f$r$;
}; /* namespace thread */
namespace exception$n { 
struct runtime_error_template$s$p$thread__create$ls$r$;
struct runtime_error_template$s$p$thread__join$ls$r$;
}; /* namespace exception */
namespace algebraic$n { 
struct option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$;
}; /* namespace algebraic */
namespace exception$n { 
struct unexpected_value_template$s$p$unit$ls$r$;
}; /* namespace exception */
namespace callable$n { 
struct callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$;
}; /* namespace callable */
namespace exception$n { 
struct runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$;
struct runtime_error_template$s$p$opengl__error$ls$r$;
struct runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$;
struct runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$;
struct runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$;
}; /* namespace exception */
namespace callable$n { 
struct callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$;
}; /* namespace callable */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$;
};}; /* namespace pgl3d::glshader */
namespace exception$n { 
struct runtime_error_template$s$p$create__program$ls$r$;
struct runtime_error_template$s$p$enable__instance__attrib__array$ls$r$;
struct runtime_error_template$s$p$instance__attrib__pointer$ls$r$;
}; /* namespace exception */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$;
struct glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$;
};}; /* namespace pgl3d::glshader */
namespace exception$n { 
struct runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$;
}; /* namespace exception */
namespace operator$n { 
struct tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$;
}; /* namespace callable */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$;
struct glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$;
struct glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$;
};}; /* namespace pgl3d::glshader */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$;
}; /* namespace callable */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$;
struct glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$;
struct glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$;
struct glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$;
};}; /* namespace pgl3d::glshader */
namespace exception$n { 
struct runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$;
}; /* namespace exception */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$;
};}; /* namespace pgl3d::glshader */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$;
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$;
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$;
}; /* namespace callable */
namespace exception$n { 
struct runtime_error_template$s$p$unknown_20byteorder$ls$r$;
}; /* namespace exception */
namespace pointer$n { namespace raw$n { 
struct scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$;
};}; /* namespace pointer::raw */
namespace exception$n { 
struct runtime_error_template$s$p$load_20font$ls$r$;
}; /* namespace exception */
namespace pointer$n { namespace raw$n { 
struct scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$;
};}; /* namespace pointer::raw */
namespace exception$n { 
struct runtime_error_template$s$p$img__load$ls$r$;
}; /* namespace exception */
namespace operator$n { 
struct tuple$s$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$pgl3d$$scene_node$n$$node_factory$s$r$$q$m$ll$r$;
}; /* namespace operator */
namespace thread$n { 
struct thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$;
struct thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$;
}; /* namespace thread */
namespace pointer$n { namespace raw$n { 
struct scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$;
};}; /* namespace pointer::raw */
namespace exception$n { 
struct runtime_error_template$s$p$sdl__read__file$ls$r$;
}; /* namespace exception */
namespace pgl3d$n { namespace sdlutil$n { 
struct sdl_file$s$p$0$li$r$;
};}; /* namespace pgl3d::sdlutil */
namespace operator$n { 
struct tuple$s$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$pgl3d$$wfobj$n$$wfgroup$s$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$size_t$t$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$meta$n$$bool$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$int$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$;
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$;
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$meta$n$$bool$t$q$meta$n$$bool$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$;
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$;
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$;
}; /* namespace callable */
namespace pgl3d$n { namespace dynamics_world$n { 
struct pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$;
struct pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$;
};}; /* namespace pgl3d::dynamics_world */
namespace pgl3d$n { namespace glgeometry$n { 
struct build_context_i$i {
 virtual ~build_context_i$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void fill$f(pxcrt::bt_bool flat_flat$, pxcrt::bt_bool polyjoint$, pxcrt::bt_size_t n$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) const = 0;
};
};}; /* namespace pgl3d::glgeometry */
namespace pgl3d$n { namespace pglbase$n { 
struct make_vertices_i$i {
 virtual ~make_vertices_i$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void make_vertex_set$f(const ::pxcrt::bt_cslice< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& bo_name$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& expr$) = 0;
 virtual pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > get_vertices$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const = 0;
 virtual ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const = 0;
 virtual ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type to_vbid$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const = 0;
};
struct pgldrawer_export_i$i {
 virtual ~pgldrawer_export_i$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
};
};}; /* namespace pgl3d::pglbase */
namespace pgl3d$n { namespace glshader$n { 
struct glshader_i$i {
 virtual ~glshader_i$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) = 0;
 virtual void disable_vertex_attrib_array$f() = 0;
 virtual void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) = 0;
 virtual void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) = 0;
 virtual pxcrt::bt_size_t instance_attrib_num_float$f() const = 0;
 virtual void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& value$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) = 0;
};
};}; /* namespace pgl3d::glshader */
namespace pgl3d$n { namespace drawer$n { 
struct pgldrawer_i$i : virtual ::pgl3d$n::pglbase$n::pgldrawer_export_i$i {
 virtual ~pgldrawer_i$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_vbid_name$f() const = 0;
 virtual ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_main_vbid_name$f() const = 0;
 virtual pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type get_prepare_instance_data_funcptr$f() const = 0;
 virtual pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_vertex_buffer$f() const = 0;
 virtual ::pxcrt::pxcvarray< pxcrt::bt_uchar > builtin_vertex_set_name$f() const = 0;
 virtual void make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const = 0;
 virtual ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const = 0;
 virtual ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const = 0;
 virtual void draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) = 0;
};
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace application$n { 
struct pgl3d_application$i {
 virtual ~pgl3d_application$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i > get_scene_shared$f() = 0;
 virtual pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > on_init_drawers$f(const ::pgl3d$n::shader_config$n::shader_config$s& sconf$) = 0;
 virtual void on_build_vertices$f(::pgl3d$n::pglbase$n::make_vertices_i$i& mvx$) = 0;
 virtual void on_event$f(const SDL_Event& ev$, pxcrt::bt_float speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$) = 0;
 virtual void on_scankeys$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& keys$, pxcrt::bt_float speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$) = 0;
};
struct pgl3d_scene_shared$i {
 virtual ~pgl3d_scene_shared$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void lock$z() const = 0;
 virtual void unlock$z() const = 0;
 virtual void wait$z() const = 0;
 virtual void notify_one$z() const = 0;
 virtual void notify_all$z() const = 0;
 virtual pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene$i > make_scene$f(const ::pgl3d$n::scene_node$n::node_factory$s& nodefac$) = 0;
};
struct pgl3d_scene$i {
 virtual ~pgl3d_scene$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void on_motion_step$f(pxcrt::bt_float frame_speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& status_message$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, ::pgl3d$n::application$n::pgl3d_scene_shared$i& ss$, ::pgl3d$n::pglbase$n::position_angle$s& camera_r$, ::pgl3d$n::pglbase$n::position_angle$s& light_r$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$) = 0;
};
};}; /* namespace pgl3d::application */
namespace pgl3d$n { namespace dynamics_world$n { 
struct pgl3dCollisionShape_i$i {
 virtual ~pgl3dCollisionShape_i$i() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual pxcrt::rawptr< ::btCollisionShape >::type get$f() = 0;
};
};}; /* namespace pgl3d::dynamics_world */
namespace callable$n { 
struct tcallable$i$p$meta$n$$void$t$q$m$ll$r$ {
 virtual ~tcallable$i$p$meta$n$$void$t$q$m$ll$r$() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void lock$z() const = 0;
 virtual void unlock$z() const = 0;
 virtual void wait$z() const = 0;
 virtual void notify_one$z() const = 0;
 virtual void notify_all$z() const = 0;
 virtual void __call$f() = 0;
};
struct callable$i$p$meta$n$$void$t$q$m$ll$r$ {
 virtual ~callable$i$p$meta$n$$void$t$q$m$ll$r$() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void __call$f() = 0;
};
struct callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 virtual ~callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& a0$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& a1$, const ::pgl3d$n::glgeometry$n::mesh_index$s& a2$) = 0;
};
struct callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 virtual ~callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$() PXC_NOTHROW { }
 virtual size_t refcnt$z() const = 0;
 virtual void incref$z() const = 0;
 virtual void decref$z() const = 0;
 virtual void __call$f(const pxcrt::bt_bool& a0$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& a1$, const ::pgl3d$n::glgeometry$n::mesh_index$s& a2$) = 0;
};
}; /* namespace callable */
namespace text$n { namespace string$n { namespace serialize$n { 
struct ser_default$s {
 inline ser_default$s();
};
};};}; /* namespace text::string::serialize */
namespace io$n { namespace process$n { 
struct pipe_process$s {
 pxcrt::pid_t pid$; // localdecl
 pxcrt::file_mt file$; // localdecl
 inline pipe_process$s(pxcrt::pid_t pid0$, const pxcrt::file_mt& file0$);
};
struct wait_t$s {
 pxcrt::pid_t pid$; // localdecl
 int status$; // localdecl
 inline wait_t$s();
 inline wait_t$s(pxcrt::pid_t pid$, int status$);
};
};}; /* namespace io::process */
namespace thread$n { namespace queue$n { 
struct task_queue$s {
 pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > shared$; // localdecl
 ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ > thrs$; // localdecl
 void push$f(const ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$& e$);
 ~task_queue$s() PXC_NOTHROW;
 void construct$f(pxcrt::bt_size_t num_thrs$);
 inline task_queue$s(pxcrt::bt_size_t num_thrs$);
};
struct task_queue_shared$s {
 ::pxcrt::pxcdeque< ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ > queue$; // localdecl
 pxcrt::bt_int stop_thread$; // localdecl
 inline task_queue_shared$s();
};
};}; /* namespace thread::queue */
namespace pgl3d$n { namespace scene_node$n { 
struct joint_id_type$s {
 pxcrt::bt_uint bo_id$; // localdecl
 pxcrt::bt_int vs_id$; // localdecl
 inline joint_id_type$s();
};
struct scene_node$s {
 ::pxcrt::aligned_16< pxcrt::glmpx::tmat4< pxcrt::bt_float >::type > trans$; // localdecl
 ::pgl3d$n::scene_node$n::joint_id_type$s joint_id$; // localdecl
 ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > children$; // localdecl
 inline scene_node$s(const ::pgl3d$n::scene_node$n::joint_id_type$s& joint_id0$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& trans0$);
};
};}; /* namespace pgl3d::scene_node */
namespace container$n { namespace tree_map$n { 
struct cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ {
 inline pxcrt::bt_int call$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) const;
 inline cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$();
};
};}; /* namespace container::tree_map */
namespace pgl3d$n { namespace scene_node$n { 
struct node_factory$s {
 ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_buffer_info$s > binfo$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > name_to_id$; // localdecl
 ::pgl3d$n::scene_node$n::scene_node$s make_node_by_id$f(const ::pgl3d$n::scene_node$n::joint_id_type$s& joint_id$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& trans$) const;
 ::pgl3d$n::scene_node$n::scene_node$s make_node_by_name$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& trans$) const;
 ::pgl3d$n::scene_node$n::joint_id_type$s get_joint_id_by_name$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 inline node_factory$s();
 inline node_factory$s(::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_buffer_info$s > binfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > name_to_id$);
};
struct node_buffer_info$s {
 ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_vs_info$s > vs_arr$; // localdecl
 inline node_buffer_info$s();
 inline node_buffer_info$s(::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_vs_info$s > vs_arr$);
};
struct node_vs_info$s {
 ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_joint_info$s > joints$; // localdecl
 inline node_vs_info$s();
 inline node_vs_info$s(::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_joint_info$s > joints$);
};
struct node_joint_info$s {
 ::pgl3d$n::scene_node$n::joint_id_type$s joint_id$; // localdecl
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans$; // localdecl
 inline node_joint_info$s();
 inline node_joint_info$s(::pgl3d$n::scene_node$n::joint_id_type$s joint_id$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans$);
};
};}; /* namespace pgl3d::scene_node */
namespace pgl3d$n { namespace glvertex$n { 
struct node_joint$s {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > joint_name$; // localdecl
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans$; // localdecl
 inline node_joint$s();
 inline node_joint$s(::pxcrt::pxcvarray< pxcrt::bt_uchar > joint_name$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans$);
};
struct vertices$s {
 pxcrt::bt_size_t num_float_per_vertex$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_float > vertex_values$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uint > elements$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_float > positions$; // localdecl
 ::pxcrt::pxcvarray< ::pgl3d$n::glvertex$n::node_joint$s > joints$; // localdecl
 pxcrt::bt_size_t num_copies_hint$; // localdecl
 pxcrt::bt_bool has_instance_id$; // localdecl
 pxcrt::bt_size_t num_copies$; // localdecl
 pxcrt::bt_size_t vertex_values_size_per_copy$; // localdecl
 pxcrt::bt_size_t elements_size_per_copy$; // localdecl
 void prepare_multiple_copies$f(pxcrt::bt_bool enable_copying_instancing$);
 inline void push_polygon_distinct$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$q$0$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s >& vals$19);
 inline void push_polygon_distinct$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$q$0$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s >& vals$19);
 inline void push_polygon_distinct$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$q$0$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s >& vals$19);
 inline void push_polygon_distinct$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& vals$19);
 inline void push_polygon_distinct$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& vals$19);
 inline void push_point$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(const ::pgl3d$n::drawer$n::font2_vertex_attributes$s& val$);
 inline void push_point$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(const ::pgl3d$n::drawer$n::particle_vertex_attributes$s& val$);
 void push_joint$f(const ::pgl3d$n::glvertex$n::node_joint$s& e$);
 inline vertices$s(pxcrt::bt_size_t num_float_per_vertex0$);
};
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace wfobj$n { 
struct wfobject$s {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > mtllib$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type > v$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type > vn$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type > vt$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > groups$; // localdecl
 inline wfobject$s();
 inline wfobject$s(::pxcrt::pxcvarray< pxcrt::bt_uchar > mtllib$, ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type > v$, ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type > vn$, ::pxcrt::pxcvarray< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type > vt$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > groups$);
};
struct wfgroup$s {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > usemtl$; // localdecl
 ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > > f$; // localdecl
 inline wfgroup$s();
 inline wfgroup$s(::pxcrt::pxcvarray< pxcrt::bt_uchar > usemtl$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > > f$);
};
struct wfelement$s {
 pxcrt::bt_uint vertex$; // localdecl
 pxcrt::bt_uint normal$; // localdecl
 pxcrt::bt_uint texcoord$; // localdecl
 inline wfelement$s();
 inline wfelement$s(pxcrt::bt_uint vertex$, pxcrt::bt_uint normal$, pxcrt::bt_uint texcoord$);
};
};}; /* namespace pgl3d::wfobj */
namespace pgl3d$n { namespace glgeometry$n { 
struct vertex_attr$s {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type pos$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type nor$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tan$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$; // localdecl
 inline vertex_attr$s();
};
struct rand_generator$s {
 pxcrt::bt_uint seed$; // localdecl
 pxcrt::bt_uint generate$f();
 pxcrt::bt_float generate_float$f();
 inline rand_generator$s(pxcrt::bt_uint seed0$);
};
struct mesh_index$s {
 pxcrt::bt_size_t x$; // localdecl
 pxcrt::bt_size_t y$; // localdecl
 pxcrt::bt_size_t z$; // localdecl
 pxcrt::bt_size_t w$; // localdecl
 inline mesh_index$s();
 inline mesh_index$s(pxcrt::bt_size_t x$, pxcrt::bt_size_t y$, pxcrt::bt_size_t z$, pxcrt::bt_size_t w$);
};
};}; /* namespace pgl3d::glgeometry */
namespace pgl3d$n { namespace pglbase$n { 
struct instance_data$s {
 ::pxcrt::pxcvarray< pxcrt::bt_float > instance_buffer$; // localdecl
 pxcrt::bt_size_t glbuffer_offset_float$; // localdecl
 inline instance_data$s();
 inline instance_data$s(::pxcrt::pxcvarray< pxcrt::bt_float > instance_buffer$, pxcrt::bt_size_t glbuffer_offset_float$);
};
struct position_angle$s {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tquat< pxcrt::bt_float >::type angle$; // localdecl
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type to_mat4$f() const;
 void translate_relative$f(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& v$);
 void rotate_angle_axis$f(pxcrt::bt_float a$, pxcrt::bt_float x$, pxcrt::bt_float y$, pxcrt::bt_float z$);
 void normalize$f();
 inline position_angle$s();
 inline position_angle$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tquat< pxcrt::bt_float >::type angle$);
};
struct projection_info$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type projection$; // localdecl
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_projection$; // localdecl
 ::pgl3d$n::pglbase$n::position_angle$s camera$; // localdecl
 ::pgl3d$n::pglbase$n::position_angle$s light$; // localdecl
 pxcrt::bt_int screen_width$; // localdecl
 pxcrt::bt_int screen_height$; // localdecl
 inline projection_info$s();
};
struct vertex_buffer_pool_key$s {
 inline vertex_buffer_pool_key$s();
};
struct texture_info$s {
 pxcrt::bt_uint surface_w$; // localdecl
 pxcrt::bt_uint surface_h$; // localdecl
 pxcrt::bt_uint char_w$; // localdecl
 pxcrt::bt_uint char_h$; // localdecl
 inline texture_info$s();
};
struct node_common_data$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmapping_vp$; // localdecl
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$; // localdecl
 pxcrt::bt_size_t stat_num_objects$; // localdecl
 inline node_common_data$s();
 inline node_common_data$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmapping_vp$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$, pxcrt::bt_size_t stat_num_objects$);
};
};}; /* namespace pgl3d::pglbase */
namespace pgl3d$n { namespace shader_config$n { 
struct shader_config$s {
 pxcrt::bt_bool is_gles$; // localdecl
 pxcrt::bt_int major$; // localdecl
 pxcrt::bt_int minor$; // localdecl
 pxcrt::bt_bool enable_shadowmapping$; // localdecl
 pxcrt::bt_bool enable_shadowmapping_multisample$; // localdecl
 pxcrt::bt_bool enable_normalmapping$; // localdecl
 pxcrt::bt_bool enable_zprepass$; // localdecl
 pxcrt::bt_bool enable_msaa$; // localdecl
 pxcrt::bt_bool enable_instanced$; // localdecl
 pxcrt::bt_bool enable_uniform_instancing$; // localdecl
 pxcrt::bt_bool enable_depth_texture$; // localdecl
 pxcrt::bt_bool enable_sampler2dshadow$; // localdecl
 pxcrt::bt_bool is_gl3_or_gles3$f() const;
 pxcrt::bt_bool is_gl33_or_gles3$f() const;
 ::pxcrt::bt_strlit prepend$f() const;
 ::pxcrt::bt_strlit vert_in$f() const;
 ::pxcrt::bt_strlit vert_out$f() const;
 ::pxcrt::bt_strlit frag_in$f() const;
 ::pxcrt::bt_strlit texture2d$f() const;
 ::pxcrt::bt_strlit shadow2d$f() const;
 ::pxcrt::bt_strlit fragcolor$f() const;
 ::pxcrt::bt_strlit decl_fragcolor$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > decl_instance_id$f(pxcrt::bt_bool shader_has_iid$) const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > decl_instance_attr$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& t$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& n$, pxcrt::bt_bool shader_support_instancing$, pxcrt::bt_bool shader_has_iid$) const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > instance_attr$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& n$, pxcrt::bt_bool shader_support_instancing$, pxcrt::bt_bool shader_has_iid$) const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > empty_shader_vert$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > empty_shader_frag$f() const;
 inline shader_config$s(pxcrt::bt_bool is_gles0$, pxcrt::bt_int major0$, pxcrt::bt_int minor0$, pxcrt::bt_bool msaa0$);
};
};}; /* namespace pgl3d::shader_config */
namespace pgl3d$n { namespace glbuffer$n { 
struct vertex_set$s {
 pxcrt::bt_size_t vs_id$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > vs_name$; // localdecl
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > vtxs$; // localdecl
 pxcrt::bt_size_t vertex_values_offset$; // localdecl
 pxcrt::bt_size_t elements_offset$; // localdecl
 inline vertex_set$s(pxcrt::bt_size_t num_float_per_vertex0$);
};
};}; /* namespace pgl3d::glbuffer */
namespace pgl3d$n { namespace glresource$n { 
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$ {
 pgl3d$n::glresource$n::handle< pxcrt::bt_uint > hnd$; // localdecl
 inline pxcrt::bt_uint get$f() const;
 inline void generate$f();
 inline void reset$f();
 inline ~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$() PXC_NOTHROW;
 inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$();
};
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace glbuffer$n { 
struct async_buffer$s {
 ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$ vbo$; // localdecl
 pxcrt::rawptr< pxcrt::bt_float >::type mapped_ptr$; // localdecl
 pxcrt::bt_unit fence$; // localdecl
 pxcrt::bt_size_t size_bytes$; // localdecl
 void map_buffer$f(pxcrt::bt_size_t sz_bytes$);
 void unmap_buffer$f();
 GLenum client_wait_sync$f(pxcrt::bt_long timeout$);
 void init$f();
 void fence_sync$f();
 void delete_sync$f();
 ~async_buffer$s() PXC_NOTHROW;
 inline async_buffer$s();
};
struct vertex_buffer$s {
 pxcrt::bt_bool draw_mode_points$; // localdecl
 pxcrt::bt_bool is_sub_drawer$; // localdecl
 pxcrt::bt_size_t num_float_per_vertex$; // localdecl
 ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$ vbo_values$; // localdecl
 ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$ vbo_elems$; // localdecl
 pxcrt::bt_size_t num_vertex_values$; // localdecl
 pxcrt::bt_size_t num_elements$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > vs_names$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > > vs_arr$; // localdecl
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > make_if$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& name$);
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > get_vertices$f(pxcrt::bt_size_t vs_id$) const;
 pxcrt::bt_size_t num_vs$f() const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > get_by_id$f(pxcrt::bt_size_t vs_id$) const;
 pxcrt::bt_bool exists$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& name$) const;
 pxcrt::bt_bool has_name$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& name$) const;
 pxcrt::bt_size_t get_id_by_name$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& name$) const;
 pxcrt::bt_size_t num_vs_ids$f() const;
 pxcrt::bt_bool create_vbo$f(pxcrt::bt_bool enable_copying_instancing$);
 inline vertex_buffer$s(pxcrt::bt_size_t num_float_per_vertex0$, pxcrt::bt_bool draw_mode_points0$, pxcrt::bt_bool is_sub_drawer0$);
};
};}; /* namespace pgl3d::glbuffer */
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
struct aggregated_ibuffer$s {
 ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > > buffers$; // localdecl
 pxcrt::bt_size_t buffer_current$; // localdecl
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > get_current$f() const;
 void switch_buffer$f();
 void init$f();
 inline aggregated_ibuffer$s();
};
};}; /* namespace pgl3d::aggregated_ibuffer */
namespace pgl3d$n { namespace drawer$n { 
struct triangles_uniforms$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$; // localdecl
 pxcrt::bt_int sampler$; // localdecl
 pxcrt::bt_int sampler_tilemap$; // localdecl
 pxcrt::bt_int sampler_sm$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type camera_pos$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type light_pos$; // localdecl
 pxcrt::bt_float light_on$; // localdecl
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmap_vp$; // localdecl
 inline triangles_uniforms$s();
 inline triangles_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$, pxcrt::bt_int sampler$, pxcrt::bt_int sampler_tilemap$, pxcrt::bt_int sampler_sm$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type camera_pos$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type light_pos$, pxcrt::bt_float light_on$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmap_vp$);
};
struct triangles_vertex_attributes$s {
 pxcrt::bt_float instance_id$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$; // localdecl
 inline triangles_vertex_attributes$s();
 inline triangles_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$);
};
struct triangles2_vertex_attributes$s {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$; // localdecl
 inline triangles2_vertex_attributes$s();
 inline triangles2_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$);
};
struct zprepass_vertex_attributes$s {
 pxcrt::bt_float instance_id$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$; // localdecl
 inline zprepass_vertex_attributes$s();
 inline zprepass_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$);
};
struct zprepass2_vertex_attributes$s {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$; // localdecl
 inline zprepass2_vertex_attributes$s();
 inline zprepass2_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$);
};
struct shadowmap_vertex_attributes$s {
 pxcrt::bt_float instance_id$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$; // localdecl
 inline shadowmap_vertex_attributes$s();
 inline shadowmap_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$);
};
struct shadowmap2_vertex_attributes$s {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$; // localdecl
 inline shadowmap2_vertex_attributes$s();
 inline shadowmap2_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$);
};
struct triangles_instance_attributes$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type model_matrix$; // localdecl
 inline triangles_instance_attributes$s();
 inline triangles_instance_attributes$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type model_matrix$);
};
struct zprepass_uniforms$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$; // localdecl
 inline zprepass_uniforms$s();
 inline zprepass_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$);
};
struct shadowmap_uniforms$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmap_vp$; // localdecl
 inline shadowmap_uniforms$s();
 inline shadowmap_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmap_vp$);
};
struct font_uniforms$s {
 pxcrt::bt_int sampler$; // localdecl
 inline font_uniforms$s();
 inline font_uniforms$s(pxcrt::bt_int sampler$);
};
struct font2_uniforms$s {
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type screen_size_px$; // localdecl
 pxcrt::bt_int sampler$; // localdecl
 inline font2_uniforms$s();
 inline font2_uniforms$s(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type screen_size_px$, pxcrt::bt_int sampler$);
};
struct font2_instance_attributes$s {
 pxcrt::glmpx::tvec4< pxcrt::bt_float >::type idata$; // localdecl
 inline font2_instance_attributes$s();
 inline font2_instance_attributes$s(pxcrt::glmpx::tvec4< pxcrt::bt_float >::type idata$);
};
struct font2_vertex_attributes$s {
 pxcrt::bt_float instance_id$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type texture_size_px$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type texture_origin_px$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type char_size_px$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type coord_clamp$; // localdecl
 pxcrt::bt_float char_px$; // localdecl
 pxcrt::bt_float char_point_size$; // localdecl
 inline font2_vertex_attributes$s();
 inline font2_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type texture_size_px$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type texture_origin_px$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type char_size_px$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type coord_clamp$, pxcrt::bt_float char_px$, pxcrt::bt_float char_point_size$);
};
struct rect2d_vertex_attributes$s {
 pxcrt::bt_float instance_id$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type vert$; // localdecl
 inline rect2d_vertex_attributes$s();
 inline rect2d_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type vert$);
};
struct rect2d_instance_attributes$s {
 pxcrt::glmpx::tvec4< pxcrt::bt_float >::type idata$; // localdecl
 inline rect2d_instance_attributes$s();
 inline rect2d_instance_attributes$s(pxcrt::glmpx::tvec4< pxcrt::bt_float >::type idata$);
};
struct rect2d_uniforms$s {
 inline rect2d_uniforms$s();
};
struct particle_uniforms$s {
 pxcrt::bt_float point_size_base$; // localdecl
 inline particle_uniforms$s();
 inline particle_uniforms$s(pxcrt::bt_float point_size_base$);
};
struct particle_instance_attributes$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type model_matrix$; // localdecl
 inline particle_instance_attributes$s();
 inline particle_instance_attributes$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type model_matrix$);
};
struct particle_vertex_attributes$s {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 inline particle_vertex_attributes$s();
 inline particle_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$);
};
struct particle_bb_uniforms$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$; // localdecl
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type camera_matrix$; // localdecl
 pxcrt::bt_float point_size_base$; // localdecl
 inline particle_bb_uniforms$s();
 inline particle_bb_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type camera_matrix$, pxcrt::bt_float point_size_base$);
};
struct particle_bb_vertex_attributes$s {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type local_position$; // localdecl
 inline particle_bb_vertex_attributes$s();
 inline particle_bb_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type local_position$);
};
struct lineparticle_uniforms$s {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type screen_size_px$; // localdecl
 pxcrt::bt_float screen_size_base$; // localdecl
 inline lineparticle_uniforms$s();
 inline lineparticle_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type screen_size_px$, pxcrt::bt_float screen_size_base$);
};
struct lineparticle_vertex_attributes$s {
 pxcrt::bt_float instance_id$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type vert$; // localdecl
 inline lineparticle_vertex_attributes$s();
 inline lineparticle_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type vert$);
};
struct lineparticle_instance_attributes$s {
 pxcrt::glmpx::tmat3< pxcrt::bt_float >::type idata$; // localdecl
 inline lineparticle_instance_attributes$s();
 inline lineparticle_instance_attributes$s(pxcrt::glmpx::tmat3< pxcrt::bt_float >::type idata$);
};
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glresource$n { 
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$ {
 pgl3d$n::glresource$n::handle< pxcrt::bt_uint > hnd$; // localdecl
 inline pxcrt::bt_uint get$f() const;
 inline void generate$f();
 inline void reset$f();
 inline ~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$() PXC_NOTHROW;
 inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$();
};
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace drawer$n { 
struct texture_data$s {
 pxcrt::bt_uint surface_w$; // localdecl
 pxcrt::bt_uint surface_h$; // localdecl
 pxcrt::bt_uint char_w$; // localdecl
 pxcrt::bt_uint char_h$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uint > char_x$; // localdecl
 ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$ texture_id$; // localdecl
 inline texture_data$s();
 inline texture_data$s(pxcrt::bt_uint surface_w$, pxcrt::bt_uint surface_h$, pxcrt::bt_uint char_w$, pxcrt::bt_uint char_h$, ::pxcrt::pxcvarray< pxcrt::bt_uint > char_x$, ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$ texture_id$);
};
struct drawer_triangles$s : ::pgl3d$n::drawer$n::pgldrawer_i$i {
 ~drawer_triangles$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~drawer_triangles$s(); this->deallocate(this); } }
 static drawer_triangles$s *allocate() { return pxcrt::allocate_single< drawer_triangles$s >(); }
 static void deallocate(drawer_triangles$s const *ptr) { pxcrt::deallocate_single< drawer_triangles$s >(ptr); }
 mutable long count$z;
 pxcrt::bt_int opt$; // localdecl
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > sdr_solid$; // localdecl
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > sdr_zp$; // localdecl
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > sdr_shadow$; // localdecl
 ::pgl3d$n::drawer$n::texture_data$s texture_dpat$; // localdecl
 ::pgl3d$n::drawer$n::texture_data$s texture_tilemap$; // localdecl
 void init$f();
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_vbid_name$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_main_vbid_name$f() const;
 pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type get_prepare_instance_data_funcptr$f() const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_vertex_buffer$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > builtin_vertex_set_name$f() const;
 void make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 void draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$);
 inline drawer_triangles$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$, pxcrt::bt_int opt0$);
};
struct drawer_triangles2$s : ::pgl3d$n::drawer$n::pgldrawer_i$i {
 ~drawer_triangles2$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~drawer_triangles2$s(); this->deallocate(this); } }
 static drawer_triangles2$s *allocate() { return pxcrt::allocate_single< drawer_triangles2$s >(); }
 static void deallocate(drawer_triangles2$s const *ptr) { pxcrt::deallocate_single< drawer_triangles2$s >(ptr); }
 mutable long count$z;
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > sdr_solid$; // localdecl
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > sdr_zp$; // localdecl
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > sdr_shadow$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_vbid_name$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_main_vbid_name$f() const;
 pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type get_prepare_instance_data_funcptr$f() const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_vertex_buffer$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > builtin_vertex_set_name$f() const;
 void make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 void draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$);
 inline drawer_triangles2$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
};
struct drawer_lineparticle$s : ::pgl3d$n::drawer$n::pgldrawer_i$i {
 ~drawer_lineparticle$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~drawer_lineparticle$s(); this->deallocate(this); } }
 static drawer_lineparticle$s *allocate() { return pxcrt::allocate_single< drawer_lineparticle$s >(); }
 static void deallocate(drawer_lineparticle$s const *ptr) { pxcrt::deallocate_single< drawer_lineparticle$s >(ptr); }
 mutable long count$z;
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > sdr_lp$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_vbid_name$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_main_vbid_name$f() const;
 pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type get_prepare_instance_data_funcptr$f() const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_vertex_buffer$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > builtin_vertex_set_name$f() const;
 void make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 void draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$);
 inline drawer_lineparticle$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
};
struct drawer_particle$s : ::pgl3d$n::drawer$n::pgldrawer_i$i {
 ~drawer_particle$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~drawer_particle$s(); this->deallocate(this); } }
 static drawer_particle$s *allocate() { return pxcrt::allocate_single< drawer_particle$s >(); }
 static void deallocate(drawer_particle$s const *ptr) { pxcrt::deallocate_single< drawer_particle$s >(ptr); }
 mutable long count$z;
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > sdr_sp$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_vbid_name$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_main_vbid_name$f() const;
 pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type get_prepare_instance_data_funcptr$f() const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_vertex_buffer$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > builtin_vertex_set_name$f() const;
 void make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 void draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$);
 inline drawer_particle$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
};
struct drawer_particle_bb$s : ::pgl3d$n::drawer$n::pgldrawer_i$i {
 ~drawer_particle_bb$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~drawer_particle_bb$s(); this->deallocate(this); } }
 static drawer_particle_bb$s *allocate() { return pxcrt::allocate_single< drawer_particle_bb$s >(); }
 static void deallocate(drawer_particle_bb$s const *ptr) { pxcrt::deallocate_single< drawer_particle_bb$s >(ptr); }
 mutable long count$z;
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > sdr_pb$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_vbid_name$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_main_vbid_name$f() const;
 pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type get_prepare_instance_data_funcptr$f() const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_vertex_buffer$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > builtin_vertex_set_name$f() const;
 void make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 void draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$);
 inline drawer_particle_bb$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
};
struct drawer_font2$s : ::pgl3d$n::drawer$n::pgldrawer_i$i {
 ~drawer_font2$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~drawer_font2$s(); this->deallocate(this); } }
 static drawer_font2$s *allocate() { return pxcrt::allocate_single< drawer_font2$s >(); }
 static void deallocate(drawer_font2$s const *ptr) { pxcrt::deallocate_single< drawer_font2$s >(ptr); }
 mutable long count$z;
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > sdr_fn$; // localdecl
 ::pgl3d$n::drawer$n::texture_data$s texture_font$; // localdecl
 void init$f();
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_vbid_name$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_main_vbid_name$f() const;
 pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type get_prepare_instance_data_funcptr$f() const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_vertex_buffer$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > builtin_vertex_set_name$f() const;
 void make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 void draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$);
 inline drawer_font2$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
};
struct drawer_rect2d$s : ::pgl3d$n::drawer$n::pgldrawer_i$i {
 ~drawer_rect2d$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~drawer_rect2d$s(); this->deallocate(this); } }
 static drawer_rect2d$s *allocate() { return pxcrt::allocate_single< drawer_rect2d$s >(); }
 static void deallocate(drawer_rect2d$s const *ptr) { pxcrt::deallocate_single< drawer_rect2d$s >(ptr); }
 mutable long count$z;
 pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > sdr_re$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_vbid_name$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > get_main_vbid_name$f() const;
 pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type get_prepare_instance_data_funcptr$f() const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_vertex_buffer$f() const;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > builtin_vertex_set_name$f() const;
 void make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const;
 ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 void draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$);
 inline drawer_rect2d$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
};
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace pglmotion$n { 
struct motion_thread_shared$s {
 ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > whole_instances$; // localdecl
 pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i > pss$; // localdecl
 pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > pidft$; // localdecl
 pxcrt::bt_bool modifying$; // localdecl
 pxcrt::bt_bool terminate_motion_thread$; // localdecl
 pxcrt::bt_float frame_speed_mul$; // localdecl
 ::pgl3d$n::pglbase$n::projection_info$s cam$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > message$; // localdecl
 pxcrt::bt_size_t stat_num_objects$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > commands$; // localdecl
 inline motion_thread_shared$s(const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances0$, const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >& pss0$, const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >& pidft0$);
};
};}; /* namespace pgl3d::pglmotion */
namespace callable$n { 
struct callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ {
 pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$r$ > p$; // localdecl
 inline void __call$f() const;
 inline callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$(const pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$r$ >& p0$);
};
}; /* namespace callable */
namespace pgl3d$n { namespace pglmotion$n { 
struct motion_thread_object$s {
 pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > sharedp$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ thr$; // localdecl
 ~motion_thread_object$s() PXC_NOTHROW;
 inline void wait_and_exec$f$p$pgl3d$$mainloop$n$$swap_data_cl$f42$r$(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& _0$up, ::pgl3d$n::pglshader$n::pglshader$s& _1$up, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& _2$up, ::pgl3d$n::mainloop$n::framerate_control$s& _3$up, pxcrt::bt_size_t& _4$up, ::pgl3d$n::pglbase$n::projection_info$s& _5$up, ::pxcrt::pxcvarray< pxcrt::bt_uchar > const& _6$up);
 inline motion_thread_object$s(const ::pgl3d$n::scene_node$n::node_factory$s& nfac$, const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >& pss$, const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >& pidft$);
};
};}; /* namespace pgl3d::pglmotion */
namespace pgl3d$n { namespace glresource$n { 
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$ {
 pgl3d$n::glresource$n::handle< pxcrt::bt_uint > hnd$; // localdecl
 inline pxcrt::bt_uint get$f() const;
 inline void generate$f();
 inline void reset$f();
 inline ~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$() PXC_NOTHROW;
 inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$();
};
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$ {
 pgl3d$n::glresource$n::handle< pxcrt::bt_uint > hnd$; // localdecl
 inline pxcrt::bt_uint get$f() const;
 inline void generate$f();
 inline void reset$f();
 inline ~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$() PXC_NOTHROW;
 inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$();
};
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace pglshader$n { 
struct shadowmap_fbo$s {
 ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$ fbo$; // localdecl
 ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$ sm_texture$; // localdecl
 pxcrt::bt_int sm_width$; // localdecl
 pxcrt::bt_int sm_height$; // localdecl
 ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$ depthbuf$; // localdecl
 inline shadowmap_fbo$s();
 inline shadowmap_fbo$s(::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$ fbo$, ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$ sm_texture$, pxcrt::bt_int sm_width$, pxcrt::bt_int sm_height$, ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$ depthbuf$);
};
};}; /* namespace pgl3d::pglshader */
namespace pgl3d$n { namespace glresource$n { 
struct auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$ {
 pgl3d$n::glresource$n::handle< pxcrt::bt_uint > hnd$; // localdecl
 inline pxcrt::bt_uint get$f() const;
 inline void generate$f();
 inline void reset$f();
 inline ~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$() PXC_NOTHROW;
 inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$();
};
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace intern_pool$n { 
struct intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ {
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > string_to_id$; // localdecl
 ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > id_to_string$; // localdecl
 inline ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type intern$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
 inline ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type to_id$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) const;
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > to_string$f(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type id$) const;
 inline ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type size$f() const;
 inline intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$();
 inline intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > string_to_id$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > id_to_string$);
};
};}; /* namespace pgl3d::intern_pool */
namespace pgl3d$n { namespace pglshader$n { 
struct pglshader$s : ::pgl3d$n::pglbase$n::make_vertices_i$i {
 ~pglshader$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~pglshader$s(); this->deallocate(this); } }
 static pglshader$s *allocate() { return pxcrt::allocate_single< pglshader$s >(); }
 static void deallocate(pglshader$s const *ptr) { pxcrt::deallocate_single< pglshader$s >(ptr); }
 mutable long count$z;
 ::pgl3d$n::shader_config$n::shader_config$s glc$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > drawer_names$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > drawers$; // localdecl
 ::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type > drawer_vbids$; // localdecl
 ::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type > drawer_main_vbids$; // localdecl
 ::pgl3d$n::pglshader$n::shadowmap_fbo$s sfbo$; // localdecl
 ::pgl3d$n::pglbase$n::projection_info$s cam$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > vertex_buffers$; // localdecl
 ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s agg_ibuffer$; // localdecl
 pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > pidft$; // localdecl
 ::pgl3d$n::glresource$n::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$ vtxarr$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > vertex_buffer_id_map$; // localdecl
 ::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ vbid_pool$; // localdecl
 ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type to_vbid$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type intern_vbid$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$);
 void set_vertex_buffer$f(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type vbid$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >& p$);
 void init$f();
 void prepare$f(::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances_r$, ::pgl3d$n::scene_node$n::node_factory$s& nfac_r$);
 void prepare_builtin_vertex_sets$f();
 void prepare_vertex_buffers$f();
 void prepare_whole_instances$f(::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$) const;
 void prepare_node_factory$f(::pgl3d$n::scene_node$n::node_factory$s& nf$) const;
 ::pgl3d$n::scene_node$n::joint_id_type$s find_joint_id_by_name$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > get_vertices$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > make_vertices$f(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$);
 void make_vertex_set$f(const ::pxcrt::bt_cslice< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& dr_names$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& expr$);
 ::pgl3d$n::pglbase$n::texture_info$s get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const;
 void resize_screen$f(pxcrt::bt_int width$, pxcrt::bt_int height$);
 inline pglshader$s(const ::pgl3d$n::shader_config$n::shader_config$s& sconf0$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& drawers0$, pxcrt::bt_int width0$, pxcrt::bt_int height0$);
};
struct build_context_impl$s : ::pgl3d$n::glgeometry$n::build_context_i$i {
 ~build_context_impl$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~build_context_impl$s(); this->deallocate(this); } }
 static build_context_impl$s *allocate() { return pxcrt::allocate_single< build_context_impl$s >(); }
 static void deallocate(build_context_impl$s const *ptr) { pxcrt::deallocate_single< build_context_impl$s >(ptr); }
 mutable long count$z;
 ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > > vptrs$; // localdecl
 ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ > fillers$; // localdecl
 void fill$f(pxcrt::bt_bool flat_flag$, pxcrt::bt_bool polyjoint$, pxcrt::bt_size_t n$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) const;
 inline build_context_impl$s(::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >& vptrs0$, ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& fillers0$);
};
};}; /* namespace pgl3d::pglshader */
namespace pointer$n { namespace raw$n { 
struct scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$ {
 pxcrt::nomove< pxcrt::rawptr< SDL_Window >::type > hnd$; // localdecl
 inline void reset$f(const pxcrt::rawptr< SDL_Window >::type& v$);
 inline pxcrt::rawptr< SDL_Window >::type get$f() const;
 inline pxcrt::rawptr< SDL_Window >::type __to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$r$() const;
 inline ~scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$() PXC_NOTHROW;
 inline scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$();
};
struct scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$ {
 pxcrt::nomove< SDL_GLContext > hnd$; // localdecl
 inline void reset$f(const SDL_GLContext& v$);
 inline SDL_GLContext get$f() const;
 inline ~scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$() PXC_NOTHROW;
 inline scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$();
};
};}; /* namespace pointer::raw */
namespace pgl3d$n { namespace sdlcontext$n { 
struct sdlcontext$s {
 pxcrt::bt_int init_w$; // localdecl
 pxcrt::bt_int init_h$; // localdecl
 pxcrt::bt_bool enable_msaa$; // localdecl
 pxcrt::bt_bool gles_flag$; // localdecl
 pxcrt::bt_int glmajor$; // localdecl
 pxcrt::bt_int glminor$; // localdecl
 pxcrt::bt_int vsync$; // localdecl
 ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$ sdl_window$; // localdecl
 ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$ sdl_glcontext$; // localdecl
 void init$f();
 inline sdlcontext$s();
};
};}; /* namespace pgl3d::sdlcontext */
namespace pgl3d$n { namespace mainloop$n { 
struct frame_statistics$s {
 pxcrt::bt_uint tprevsec$; // localdecl
 pxcrt::bt_uint frames$; // localdecl
 pxcrt::bt_float fps$; // localdecl
 ::pxcrt::farray< pxcrt::bt_uint,8LL > ticks$; // localdecl
 ::pxcrt::farray< pxcrt::bt_uint,8LL > ticks_sum$; // localdecl
 ::pxcrt::farray< pxcrt::bt_uint,8LL > ticks_sum_saved$; // localdecl
 void init$f();
 void save_ticks$f(pxcrt::bt_size_t idx$, pxcrt::bt_uint v$);
 void measure$f();
 inline frame_statistics$s();
};
struct framerate_control$s {
 pxcrt::bt_int vsync$; // localdecl
 pxcrt::bt_int swap_interval$; // localdecl
 ::pxcrt::bt_ulonglong timer_res$; // localdecl
 pxcrt::bt_double timer_res_inv$; // localdecl
 ::pxcrt::farray< ::pxcrt::bt_ulonglong,12LL > values$; // localdecl
 pxcrt::bt_size_t cur$; // localdecl
 pxcrt::bt_float frame_speed_mul$; // localdecl
 pxcrt::bt_float target_frame_speed_mul$; // localdecl
 void toggle_vsync$f();
 void start$f();
 void control$f();
 inline framerate_control$s(pxcrt::bt_int vsync0$);
};
};}; /* namespace pgl3d::mainloop */
namespace pgl3d$n { namespace dynamics_world$n { 
struct pgl3dRigidBody$s {
 pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i > collisionShape$; // localdecl
 ::btDefaultMotionState motionState$; // localdecl
 ::btRigidBody rigidBody$; // localdecl
 inline pgl3dRigidBody$s(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i >& collisionShape0$, pxcrt::bt_float mass$, const ::btTransform& tr0$);
};
struct pgl3dDynamicsWorld$s {
 ::btDefaultCollisionConfiguration collisionConfiguration$; // localdecl
 ::btCollisionDispatcher dispatcher$; // localdecl
 ::btDbvtBroadphase broadphase$; // localdecl
 ::btSequentialImpulseConstraintSolver solver$; // localdecl
 ::btDiscreteDynamicsWorld dynamicsWorld$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > > rigidBodies$; // localdecl
 ~pgl3dDynamicsWorld$s() PXC_NOTHROW;
 void clear$f();
 void addRigidBody$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >& rigidBody$);
 inline pgl3dDynamicsWorld$s();
};
};}; /* namespace pgl3d::dynamics_world */
namespace demoapp$n { 
struct player_info$s {
 pxcrt::glmpx::tquat< pxcrt::bt_float >::type device_rot_prev$; // localdecl
 pxcrt::glmpx::tquat< pxcrt::bt_float >::type angle$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$; // localdecl
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type pos_delta$; // localdecl
 pxcrt::bt_bool accel$; // localdecl
 pxcrt::bt_float accel_ratio$; // localdecl
 inline player_info$s();
};
struct input_control$s {
 ::pxcrt::ext::device_motion dmotion$; // localdecl
 ::pxcrt::pxcvarray< SDL_FingerID > fingerids$; // localdecl
 ::pxcrt::farray< pxcrt::bt_bool,2LL > fingdown$; // localdecl
 ::pxcrt::farray< pxcrt::bt_size_t,2LL > fingerdown_time$; // localdecl
 ::pxcrt::farray< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type,2LL > start_pos$; // localdecl
 ::pxcrt::farray< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type,2LL > cur_pos$; // localdecl
 ::pxcrt::farray< pxcrt::bt_float,2LL > pos_distance_max$; // localdecl
 pxcrt::glmpx::tvec2< pxcrt::bt_float >::type finger_xyrotate_delta$; // localdecl
 pxcrt::bt_float finger_zmove_delta$; // localdecl
 pxcrt::bt_int finger_zmove_mode$; // localdecl
 void finger_motion$f(pxcrt::bt_float x$, pxcrt::bt_float y$, pxcrt::bt_float dx$, pxcrt::bt_float dy$, SDL_FingerID fng$);
 void finger_down$f(pxcrt::bt_float x$, pxcrt::bt_float y$, SDL_FingerID fng$);
 pxcrt::bt_int finger_up$f(SDL_FingerID fng$);
 void finger_action_one_finger$f(pxcrt::glmpx::tquat< pxcrt::bt_float >::type& rot$, pxcrt::bt_float frame_speed$, pxcrt::bt_size_t fid$);
 void finger_action_two_fingers$f(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& angle$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& pos$, pxcrt::bt_float frame_speed$);
 void finger_action_step$f(::demoapp$n::player_info$s& pl$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& pos_delta$, pxcrt::bt_float frame_speed$);
 void add_zdelta$f(pxcrt::bt_float zaccel$, pxcrt::bt_float frame_speed$);
 inline input_control$s(const pxcrt::io& iop$);
};
struct app_impl$s {
 pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > scene_shared$; // localdecl
 ::demoapp$n::player_info$s player$; // localdecl
 ::demoapp$n::input_control$s ictl$; // localdecl
 pxcrt::bt_bool scene_next_flag$; // localdecl
 pxcrt::bt_float light_on$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > app_commands$; // localdecl
 void init$f();
 inline app_impl$s();
};
struct demoapp_application$s : ::pgl3d$n::application$n::pgl3d_application$i {
 ~demoapp_application$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~demoapp_application$s(); this->deallocate(this); } }
 static demoapp_application$s *allocate() { return pxcrt::allocate_single< demoapp_application$s >(); }
 static void deallocate(demoapp_application$s const *ptr) { pxcrt::deallocate_single< demoapp_application$s >(ptr); }
 mutable long count$z;
 ::demoapp$n::app_impl$s app$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > on_init_drawers$f(const ::pgl3d$n::shader_config$n::shader_config$s& conf$);
 void on_build_vertices$f(::pgl3d$n::pglbase$n::make_vertices_i$i& mvx$);
 void on_event$f(const SDL_Event& ev$, pxcrt::bt_float speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$);
 void on_scankeys$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& keys$, pxcrt::bt_float speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$);
 pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i > get_scene_shared$f();
 inline demoapp_application$s();
};
struct demoapp_scene_shared$s : ::pgl3d$n::application$n::pgl3d_scene_shared$i {
 ~demoapp_scene_shared$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~demoapp_scene_shared$s(); this->deallocate(this); } }
 static demoapp_scene_shared$s *allocate() { return pxcrt::allocate_single< demoapp_scene_shared$s >(); }
 static void deallocate(demoapp_scene_shared$s const *ptr) { pxcrt::deallocate_single< demoapp_scene_shared$s >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pgl3d$n::pglbase$n::position_angle$s posang$; // localdecl
 pxcrt::bt_bool scene_next_flag$; // localdecl
 pxcrt::bt_float light_on$; // localdecl
 ::pgl3d$n::pglbase$n::texture_info$s default_font_texture_info$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > app_commands$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > shapes$; // localdecl
 pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene$i > make_scene$f(const ::pgl3d$n::scene_node$n::node_factory$s& nodefac$);
 inline demoapp_scene_shared$s();
};
struct scene_control$s {
 ::pgl3d$n::scene_node$n::node_factory$s nodefac$; // localdecl
 pxcrt::bt_float prev_spawn$; // localdecl
 pxcrt::bt_float motion_count$; // localdecl
 ::pgl3d$n::scene_node$n::joint_id_type$s joint_id_lp$; // localdecl
 ::pgl3d$n::scene_node$n::joint_id_type$s joint_id_font$; // localdecl
 ::pgl3d$n::scene_node$n::joint_id_type$s joint_id_rect2d$; // localdecl
 pxcrt::bt_size_t cur_scene$; // localdecl
 ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s > lpbullet$; // localdecl
 ::pgl3d$n::scene_node$n::scene_node$s node_scene$; // localdecl
 ::pgl3d$n::scene_node$n::scene_node$s node_status_message$; // localdecl
 ::pgl3d$n::scene_node$n::scene_node$s node_buttons$; // localdecl
 ::pgl3d$n::dynamics_world$n::pgl3dDynamicsWorld$s dynamics_world$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > > boxes$; // localdecl
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > shapes$; // localdecl
 ::pxcrt::darray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > scene_names$; // localdecl
 void init$f();
 ::pgl3d$n::scene_node$n::scene_node$s instantiate_cur_scene$f();
 void scene_next$f();
 inline scene_control$s(const ::pgl3d$n::scene_node$n::node_factory$s& nfac$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& shapes0$);
};
struct demoapp_scene$s : ::pgl3d$n::application$n::pgl3d_scene$i {
 ~demoapp_scene$s() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~demoapp_scene$s(); this->deallocate(this); } }
 static demoapp_scene$s *allocate() { return pxcrt::allocate_single< demoapp_scene$s >(); }
 static void deallocate(demoapp_scene$s const *ptr) { pxcrt::deallocate_single< demoapp_scene$s >(ptr); }
 mutable long count$z;
 ::demoapp$n::scene_control$s sctl$; // localdecl
 void on_motion_step$f(pxcrt::bt_float frame_speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& status_message$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, ::pgl3d$n::application$n::pgl3d_scene_shared$i& ss$, ::pgl3d$n::pglbase$n::position_angle$s& camera_r$, ::pgl3d$n::pglbase$n::position_angle$s& light_r$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$);
 pxcrt::bt_size_t prepare_instance_data_ft_rec$f(::pgl3d$n::pglbase$n::node_common_data$s& ncd$, const ::pgl3d$n::scene_node$n::scene_node$s& sn$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$);
 pxcrt::bt_size_t prepare_instance_data_lp$f(::pgl3d$n::pglbase$n::node_common_data$s& ncd$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$);
 inline demoapp_scene$s(const ::pgl3d$n::scene_node$n::node_factory$s& nodefac0$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& shapes$);
};
struct lpbullet_data$s {
 ::pxcrt::farray< pxcrt::bt_float,9LL > value$; // localdecl
 inline lpbullet_data$s();
 inline lpbullet_data$s(::pxcrt::farray< pxcrt::bt_float,9LL > value$);
};
}; /* namespace demoapp */
namespace exception$n { 
struct unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$ : pxcrt::runtime_error {
 ~unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$(); this->deallocate(this); } }
 static unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$ *allocate() { return pxcrt::allocate_single< unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$ >(); }
 static void deallocate(unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$ const *ptr) { pxcrt::deallocate_single< unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace io$n { namespace errno$n { 
struct errno_or_value$v$p$io$$file$n$$file_st$s$r$ {
 typedef int errno$$ut;
 typedef pxcrt::file_st value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$io$$file$n$$file_st$s$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$io$$file$n$$file_st$s$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$io$$file$n$$file_st$s$r$(const errno_or_value$v$p$io$$file$n$$file_st$s$r$& x) { init$(x); }
 errno_or_value$v$p$io$$file$n$$file_st$s$r$& operator =(const errno_or_value$v$p$io$$file$n$$file_st$s$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$io$$file$n$$file_st$s$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline pxcrt::file_st value$$r() const;
 inline int errno$$l(int x);
 inline pxcrt::file_st value$$l(pxcrt::file_st x);
};
struct errno_or_value$v$p$io$$file$n$$file_mt$s$r$ {
 typedef int errno$$ut;
 typedef pxcrt::file_mt value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$io$$file$n$$file_mt$s$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$io$$file$n$$file_mt$s$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$io$$file$n$$file_mt$s$r$(const errno_or_value$v$p$io$$file$n$$file_mt$s$r$& x) { init$(x); }
 errno_or_value$v$p$io$$file$n$$file_mt$s$r$& operator =(const errno_or_value$v$p$io$$file$n$$file_mt$s$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$io$$file$n$$file_mt$s$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline pxcrt::file_mt value$$r() const;
 inline int errno$$l(int x);
 inline pxcrt::file_mt value$$l(pxcrt::file_mt x);
};
struct errno_or_value$v$p$meta$n$$size_t$t$r$ {
 typedef int errno$$ut;
 typedef pxcrt::bt_size_t value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$meta$n$$size_t$t$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$meta$n$$size_t$t$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$meta$n$$size_t$t$r$(const errno_or_value$v$p$meta$n$$size_t$t$r$& x) { init$(x); }
 errno_or_value$v$p$meta$n$$size_t$t$r$& operator =(const errno_or_value$v$p$meta$n$$size_t$t$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$meta$n$$size_t$t$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline pxcrt::bt_size_t value$$r() const;
 inline int errno$$l(int x);
 inline pxcrt::bt_size_t value$$l(pxcrt::bt_size_t x);
};
struct errno_or_value$v$p$io$$file$n$$off_t$s$r$ {
 typedef int errno$$ut;
 typedef pxcrt::off_t value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$io$$file$n$$off_t$s$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$io$$file$n$$off_t$s$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$io$$file$n$$off_t$s$r$(const errno_or_value$v$p$io$$file$n$$off_t$s$r$& x) { init$(x); }
 errno_or_value$v$p$io$$file$n$$off_t$s$r$& operator =(const errno_or_value$v$p$io$$file$n$$off_t$s$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$io$$file$n$$off_t$s$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline pxcrt::off_t value$$r() const;
 inline int errno$$l(int x);
 inline pxcrt::off_t value$$l(pxcrt::off_t x);
};
};}; /* namespace io::errno */
namespace exception$n { 
struct unexpected_value_template$s$p$errno__t$ls$r$ : pxcrt::runtime_error {
 ~unexpected_value_template$s$p$errno__t$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~unexpected_value_template$s$p$errno__t$ls$r$(); this->deallocate(this); } }
 static unexpected_value_template$s$p$errno__t$ls$r$ *allocate() { return pxcrt::allocate_single< unexpected_value_template$s$p$errno__t$ls$r$ >(); }
 static void deallocate(unexpected_value_template$s$p$errno__t$ls$r$ const *ptr) { pxcrt::deallocate_single< unexpected_value_template$s$p$errno__t$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline unexpected_value_template$s$p$errno__t$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace io$n { namespace errno$n { 
struct errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$ {
 typedef int errno$$ut;
 typedef pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$(const errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$& x) { init$(x); }
 errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$& operator =(const errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > value$$r() const;
 inline int errno$$l(int x);
 inline pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > value$$l(pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > x);
};
};}; /* namespace io::errno */
namespace algebraic$n { 
struct pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ {
 pxcrt::file_mt first$; // localdecl
 pxcrt::file_mt second$; // localdecl
 inline pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$(const pxcrt::file_mt& a0$, const pxcrt::file_mt& a1$);
};
}; /* namespace algebraic */
namespace io$n { namespace errno$n { 
struct errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$ {
 typedef int errno$$ut;
 typedef ::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$(const errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$& x) { init$(x); }
 errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$& operator =(const errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline ::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ value$$r() const;
 inline int errno$$l(int x);
 inline ::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ value$$l(::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ x);
};
};}; /* namespace io::errno */
namespace algebraic$n { 
struct option$v$p$io$$file$n$$file_st$s$r$ {
 typedef pxcrt::file_st some$$ut;
 union {
  char some$$u[sizeof(some$$ut)] __attribute__((__aligned__(__alignof__(some$$ut))));
 } _$u;
 some$$ut const *some$$p() const { return (some$$ut const *)_$u.some$$u; }
 some$$ut *some$$p() { return (some$$ut *)_$u.some$$u; }
 typedef enum {none$$e, some$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 option$v$p$io$$file$n$$file_st$s$r$() {
  _$e = none$$e;
  /* unit */;
 };
 ~option$v$p$io$$file$n$$file_st$s$r$() PXC_NOTHROW { deinit$(); }
 option$v$p$io$$file$n$$file_st$s$r$(const option$v$p$io$$file$n$$file_st$s$r$& x) { init$(x); }
 option$v$p$io$$file$n$$file_st$s$r$& operator =(const option$v$p$io$$file$n$$file_st$s$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const option$v$p$io$$file$n$$file_st$s$r$ & x); inline void deinit$();
 inline pxcrt::bt_unit none$$r() const;
 inline pxcrt::file_st some$$r() const;
 inline pxcrt::bt_unit none$$l(pxcrt::bt_unit x);
 inline pxcrt::file_st some$$l(pxcrt::file_st x);
};
}; /* namespace algebraic */
namespace io$n { namespace errno$n { 
struct errno_or_value$v$p$io$$process$n$$pid_t$s$r$ {
 typedef int errno$$ut;
 typedef pxcrt::pid_t value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$io$$process$n$$pid_t$s$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$io$$process$n$$pid_t$s$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$io$$process$n$$pid_t$s$r$(const errno_or_value$v$p$io$$process$n$$pid_t$s$r$& x) { init$(x); }
 errno_or_value$v$p$io$$process$n$$pid_t$s$r$& operator =(const errno_or_value$v$p$io$$process$n$$pid_t$s$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$io$$process$n$$pid_t$s$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline pxcrt::pid_t value$$r() const;
 inline int errno$$l(int x);
 inline pxcrt::pid_t value$$l(pxcrt::pid_t x);
};
struct errno_or_value$v$p$io$$process$n$$pipe_process$s$r$ {
 typedef int errno$$ut;
 typedef ::io$n::process$n::pipe_process$s value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$io$$process$n$$pipe_process$s$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$io$$process$n$$pipe_process$s$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$io$$process$n$$pipe_process$s$r$(const errno_or_value$v$p$io$$process$n$$pipe_process$s$r$& x) { init$(x); }
 errno_or_value$v$p$io$$process$n$$pipe_process$s$r$& operator =(const errno_or_value$v$p$io$$process$n$$pipe_process$s$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$io$$process$n$$pipe_process$s$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline ::io$n::process$n::pipe_process$s value$$r() const;
 inline int errno$$l(int x);
 inline ::io$n::process$n::pipe_process$s value$$l(::io$n::process$n::pipe_process$s x);
};
struct errno_or_value$v$p$io$$process$n$$wait_t$s$r$ {
 typedef int errno$$ut;
 typedef ::io$n::process$n::wait_t$s value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$io$$process$n$$wait_t$s$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$io$$process$n$$wait_t$s$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$io$$process$n$$wait_t$s$r$(const errno_or_value$v$p$io$$process$n$$wait_t$s$r$& x) { init$(x); }
 errno_or_value$v$p$io$$process$n$$wait_t$s$r$& operator =(const errno_or_value$v$p$io$$process$n$$wait_t$s$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$io$$process$n$$wait_t$s$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline ::io$n::process$n::wait_t$s value$$r() const;
 inline int errno$$l(int x);
 inline ::io$n::process$n::wait_t$s value$$l(::io$n::process$n::wait_t$s x);
};
struct errno_or_value$v$p$io$$process$n$$status_t$s$r$ {
 typedef int errno$$ut;
 typedef int value$$ut;
 union {
  char errno$$u[sizeof(errno$$ut)] __attribute__((__aligned__(__alignof__(errno$$ut))));
  char value$$u[sizeof(value$$ut)] __attribute__((__aligned__(__alignof__(value$$ut))));
 } _$u;
 errno$$ut const *errno$$p() const { return (errno$$ut const *)_$u.errno$$u; }
 errno$$ut *errno$$p() { return (errno$$ut *)_$u.errno$$u; }
 value$$ut const *value$$p() const { return (value$$ut const *)_$u.value$$u; }
 value$$ut *value$$p() { return (value$$ut *)_$u.value$$u; }
 typedef enum {errno$$e, value$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 errno_or_value$v$p$io$$process$n$$status_t$s$r$() {
  _$e = errno$$e;
  *(errno$$p()) = int();
 };
 ~errno_or_value$v$p$io$$process$n$$status_t$s$r$() PXC_NOTHROW { deinit$(); }
 errno_or_value$v$p$io$$process$n$$status_t$s$r$(const errno_or_value$v$p$io$$process$n$$status_t$s$r$& x) { init$(x); }
 errno_or_value$v$p$io$$process$n$$status_t$s$r$& operator =(const errno_or_value$v$p$io$$process$n$$status_t$s$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const errno_or_value$v$p$io$$process$n$$status_t$s$r$ & x); inline void deinit$();
 inline int errno$$r() const;
 inline int value$$r() const;
 inline int errno$$l(int x);
 inline int value$$l(int x);
};
};}; /* namespace io::errno */
namespace callable$n { 
struct tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ {
 pxcrt::rcptr< ::callable$n::tcallable$i$p$meta$n$$void$t$q$m$ll$r$ > p$; // localdecl
 inline void __call$f() const;
 inline tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$(const pxcrt::rcptr< ::callable$n::tcallable$i$p$meta$n$$void$t$q$m$ll$r$ >& p0$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$r$$q$m$ll$r$ {
 pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > _0$; // localdecl
 inline tuple$s$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$r$$q$m$ll$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& a0$);
};
}; /* namespace operator */
namespace thread$n { 
struct thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$ {
 ::operator$n::tuple$s$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$r$$q$m$ll$r$ fld$; // localdecl
 pxcrt::bt_unit ret$; // localdecl
 inline void __call$f();
 inline thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$);
};
struct thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$r$ {
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~thread$s$p$thread$$queue$n$$queue_thread_main$f$r$(); this->deallocate(this); } }
 static thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ *allocate() { return pxcrt::allocate_single< thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ >(); }
 static void deallocate(thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ const *ptr) { pxcrt::deallocate_single< thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ >(ptr); }
 mutable long count$z;
 ::thread$n::thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$ fobj$; // localdecl
 pxcrt::bt_bool need_join$; // localdecl
 pxcrt::thread_ptr thd$; // localdecl
 inline void init$f();
 inline ~thread$s$p$thread$$queue$n$$queue_thread_main$f$r$() PXC_NOTHROW;
 inline void __call$f();
 inline thread$s$p$thread$$queue$n$$queue_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$);
};
}; /* namespace thread */
namespace exception$n { 
struct runtime_error_template$s$p$thread__create$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$thread__create$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$thread__create$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$thread__create$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$thread__create$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$thread__create$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$thread__create$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$thread__create$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
struct runtime_error_template$s$p$thread__join$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$thread__join$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$thread__join$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$thread__join$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$thread__join$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$thread__join$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$thread__join$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$thread__join$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace algebraic$n { 
struct option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$ {
 typedef ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ some$$ut;
 union {
  char some$$u[sizeof(some$$ut)] __attribute__((__aligned__(__alignof__(some$$ut))));
 } _$u;
 some$$ut const *some$$p() const { return (some$$ut const *)_$u.some$$u; }
 some$$ut *some$$p() { return (some$$ut *)_$u.some$$u; }
 typedef enum {none$$e, some$$e} type_$e; type_$e _$e;
 inline type_$e get_$e() const { return _$e; }
 option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$() {
  _$e = none$$e;
  /* unit */;
 };
 ~option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$() PXC_NOTHROW { deinit$(); }
 option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$(const option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$& x) { init$(x); }
 option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$& operator =(const option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$& x) { if (this != &x) { deinit$(); init$(x); } return *this; }
 inline void init$(const option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$ & x); inline void deinit$();
 inline pxcrt::bt_unit none$$r() const;
 inline ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ some$$r() const;
 inline pxcrt::bt_unit none$$l(pxcrt::bt_unit x);
 inline ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ some$$l(::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ x);
};
}; /* namespace algebraic */
namespace exception$n { 
struct unexpected_value_template$s$p$unit$ls$r$ : pxcrt::runtime_error {
 ~unexpected_value_template$s$p$unit$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~unexpected_value_template$s$p$unit$ls$r$(); this->deallocate(this); } }
 static unexpected_value_template$s$p$unit$ls$r$ *allocate() { return pxcrt::allocate_single< unexpected_value_template$s$p$unit$ls$r$ >(); }
 static void deallocate(unexpected_value_template$s$p$unit$ls$r$ const *ptr) { pxcrt::deallocate_single< unexpected_value_template$s$p$unit$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline unexpected_value_template$s$p$unit$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace callable$n { 
struct callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ > p$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& a0$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& a1$, const ::pgl3d$n::glgeometry$n::mesh_index$s& a2$) const;
 inline callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(const pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& p0$);
};
}; /* namespace callable */
namespace exception$n { 
struct runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
struct runtime_error_template$s$p$opengl__error$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$opengl__error$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$opengl__error$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$opengl__error$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$opengl__error$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$opengl__error$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$opengl__error$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$opengl__error$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
struct runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
struct runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
struct runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace callable$n { 
struct callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ > p$; // localdecl
 inline void __call$f(const pxcrt::bt_bool& a0$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& a1$, const ::pgl3d$n::glgeometry$n::mesh_index$s& a2$) const;
 inline callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(const pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& p0$);
};
}; /* namespace callable */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_view_projection_matrix$; // localdecl
 pxcrt::bt_int u_sampler$; // localdecl
 pxcrt::bt_int u_sampler_tilemap$; // localdecl
 pxcrt::bt_int u_sampler_sm$; // localdecl
 pxcrt::bt_int u_camera_pos$; // localdecl
 pxcrt::bt_int u_light_pos$; // localdecl
 pxcrt::bt_int u_light_on$; // localdecl
 pxcrt::bt_int u_shadowmap_vp$; // localdecl
 pxcrt::bt_int i_model_matrix$; // localdecl
 pxcrt::bt_int v_instance_id$; // localdecl
 pxcrt::bt_int v_position$; // localdecl
 pxcrt::bt_int v_normal$; // localdecl
 pxcrt::bt_int v_tangent$; // localdecl
 pxcrt::bt_int v_uvw$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
};}; /* namespace pgl3d::glshader */
namespace exception$n { 
struct runtime_error_template$s$p$create__program$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$create__program$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$create__program$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$create__program$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$create__program$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$create__program$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$create__program$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$create__program$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
struct runtime_error_template$s$p$enable__instance__attrib__array$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$enable__instance__attrib__array$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$enable__instance__attrib__array$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$enable__instance__attrib__array$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$enable__instance__attrib__array$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$enable__instance__attrib__array$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
struct runtime_error_template$s$p$instance__attrib__pointer$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$instance__attrib__pointer$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$instance__attrib__pointer$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$instance__attrib__pointer$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$instance__attrib__pointer$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$instance__attrib__pointer$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$instance__attrib__pointer$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$instance__attrib__pointer$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_view_projection_matrix$; // localdecl
 pxcrt::bt_int i_model_matrix$; // localdecl
 pxcrt::bt_int v_instance_id$; // localdecl
 pxcrt::bt_int v_position$; // localdecl
 pxcrt::bt_int v_normal$; // localdecl
 pxcrt::bt_int v_tangent$; // localdecl
 pxcrt::bt_int v_uvw$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
struct glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_shadowmap_vp$; // localdecl
 pxcrt::bt_int i_model_matrix$; // localdecl
 pxcrt::bt_int v_instance_id$; // localdecl
 pxcrt::bt_int v_position$; // localdecl
 pxcrt::bt_int v_normal$; // localdecl
 pxcrt::bt_int v_tangent$; // localdecl
 pxcrt::bt_int v_uvw$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
};}; /* namespace pgl3d::glshader */
namespace exception$n { 
struct runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace operator$n { 
struct tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$ {
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > _0$; // localdecl
 inline tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
};
}; /* namespace callable */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_view_projection_matrix$; // localdecl
 pxcrt::bt_int u_sampler$; // localdecl
 pxcrt::bt_int u_sampler_tilemap$; // localdecl
 pxcrt::bt_int u_sampler_sm$; // localdecl
 pxcrt::bt_int u_camera_pos$; // localdecl
 pxcrt::bt_int u_light_pos$; // localdecl
 pxcrt::bt_int u_light_on$; // localdecl
 pxcrt::bt_int u_shadowmap_vp$; // localdecl
 pxcrt::bt_int i_model_matrix$; // localdecl
 pxcrt::bt_int v_position$; // localdecl
 pxcrt::bt_int v_normal$; // localdecl
 pxcrt::bt_int v_tangent$; // localdecl
 pxcrt::bt_int v_uvw$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
struct glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_view_projection_matrix$; // localdecl
 pxcrt::bt_int i_model_matrix$; // localdecl
 pxcrt::bt_int v_position$; // localdecl
 pxcrt::bt_int v_normal$; // localdecl
 pxcrt::bt_int v_tangent$; // localdecl
 pxcrt::bt_int v_uvw$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
struct glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_shadowmap_vp$; // localdecl
 pxcrt::bt_int i_model_matrix$; // localdecl
 pxcrt::bt_int v_position$; // localdecl
 pxcrt::bt_int v_normal$; // localdecl
 pxcrt::bt_int v_tangent$; // localdecl
 pxcrt::bt_int v_uvw$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
};}; /* namespace pgl3d::glshader */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
};
}; /* namespace callable */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_view_projection_matrix$; // localdecl
 pxcrt::bt_int u_screen_size_px$; // localdecl
 pxcrt::bt_int u_screen_size_base$; // localdecl
 pxcrt::bt_int i_idata$; // localdecl
 pxcrt::bt_int v_instance_id$; // localdecl
 pxcrt::bt_int v_vert$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::lineparticle_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
struct glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_point_size_base$; // localdecl
 pxcrt::bt_int i_model_matrix$; // localdecl
 pxcrt::bt_int v_position$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::particle_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
struct glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_view_projection_matrix$; // localdecl
 pxcrt::bt_int u_camera_matrix$; // localdecl
 pxcrt::bt_int u_point_size_base$; // localdecl
 pxcrt::bt_int i_model_matrix$; // localdecl
 pxcrt::bt_int v_position$; // localdecl
 pxcrt::bt_int v_local_position$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::particle_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
struct glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int u_screen_size_px$; // localdecl
 pxcrt::bt_int u_sampler$; // localdecl
 pxcrt::bt_int i_idata$; // localdecl
 pxcrt::bt_int v_instance_id$; // localdecl
 pxcrt::bt_int v_texture_size_px$; // localdecl
 pxcrt::bt_int v_texture_origin_px$; // localdecl
 pxcrt::bt_int v_char_size_px$; // localdecl
 pxcrt::bt_int v_coord_clamp$; // localdecl
 pxcrt::bt_int v_char_px$; // localdecl
 pxcrt::bt_int v_char_point_size$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::font2_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
};}; /* namespace pgl3d::glshader */
namespace exception$n { 
struct runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace pgl3d$n { namespace glshader$n { 
struct glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ : ::pgl3d$n::glshader$n::glshader_i$i {
 ~glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(); this->deallocate(this); } }
 static glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ *allocate() { return pxcrt::allocate_single< glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ >(); }
 static void deallocate(glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ const *ptr) { pxcrt::deallocate_single< glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ >(ptr); }
 mutable long count$z;
 pxcrt::bt_uint program$; // localdecl
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > error$; // localdecl
 pxcrt::bt_int i_idata$; // localdecl
 pxcrt::bt_int v_instance_id$; // localdecl
 pxcrt::bt_int v_vert$; // localdecl
 inline void init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
 inline void instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::rect2d_instance_attributes$s& v$);
 inline void enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$);
 inline void instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$);
 inline pxcrt::bt_size_t instance_attrib_num_float$f() const;
 inline void instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$);
 inline void enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$);
 inline void disable_vertex_attrib_array$f();
 inline glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};
};}; /* namespace pgl3d::glshader */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
};
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
};
struct callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
};
}; /* namespace callable */
namespace exception$n { 
struct runtime_error_template$s$p$unknown_20byteorder$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$unknown_20byteorder$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$unknown_20byteorder$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$unknown_20byteorder$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$unknown_20byteorder$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$unknown_20byteorder$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$unknown_20byteorder$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$unknown_20byteorder$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace pointer$n { namespace raw$n { 
struct scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$ {
 pxcrt::nomove< pxcrt::rawptr< TTF_Font >::type > hnd$; // localdecl
 inline void reset$f(const pxcrt::rawptr< TTF_Font >::type& v$);
 inline pxcrt::rawptr< TTF_Font >::type get$f() const;
 inline pxcrt::rawptr< TTF_Font >::type __to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$() const;
 inline ~scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$() PXC_NOTHROW;
 inline scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$();
};
};}; /* namespace pointer::raw */
namespace exception$n { 
struct runtime_error_template$s$p$load_20font$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$load_20font$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$load_20font$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$load_20font$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$load_20font$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$load_20font$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$load_20font$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$load_20font$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace pointer$n { namespace raw$n { 
struct scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ {
 pxcrt::nomove< pxcrt::rawptr< SDL_Surface >::type > hnd$; // localdecl
 inline void reset$f(const pxcrt::rawptr< SDL_Surface >::type& v$);
 inline pxcrt::rawptr< SDL_Surface >::type get$f() const;
 inline pxcrt::rawptr< SDL_Surface >::type __to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$r$() const;
 inline ~scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$() PXC_NOTHROW;
 inline scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$();
};
};}; /* namespace pointer::raw */
namespace exception$n { 
struct runtime_error_template$s$p$img__load$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$img__load$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$img__load$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$img__load$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$img__load$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$img__load$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$img__load$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$img__load$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace operator$n { 
struct tuple$s$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$pgl3d$$scene_node$n$$node_factory$s$r$$q$m$ll$r$ {
 pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > _0$; // localdecl
 ::pgl3d$n::scene_node$n::node_factory$s _1$; // localdecl
 inline tuple$s$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$pgl3d$$scene_node$n$$node_factory$s$r$$q$m$ll$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& a0$, const ::pgl3d$n::scene_node$n::node_factory$s& a1$);
};
}; /* namespace operator */
namespace thread$n { 
struct thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ {
 ::operator$n::tuple$s$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$pgl3d$$scene_node$n$$node_factory$s$r$$q$m$ll$r$ fld$; // localdecl
 pxcrt::bt_unit ret$; // localdecl
 inline void __call$f();
 inline thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& sptr$, const ::pgl3d$n::scene_node$n::node_factory$s& nfac0$);
};
struct thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$r$ {
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(); this->deallocate(this); } }
 static thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ *allocate() { return pxcrt::allocate_single< thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ >(); }
 static void deallocate(thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ const *ptr) { pxcrt::deallocate_single< thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ >(ptr); }
 mutable long count$z;
 ::thread$n::thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ fobj$; // localdecl
 pxcrt::bt_bool need_join$; // localdecl
 pxcrt::thread_ptr thd$; // localdecl
 inline void init$f();
 inline ~thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$() PXC_NOTHROW;
 inline void __call$f();
 inline thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& sptr$, const ::pgl3d$n::scene_node$n::node_factory$s& nfac0$);
};
}; /* namespace thread */
namespace pointer$n { namespace raw$n { 
struct scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$ {
 pxcrt::nomove< pxcrt::rawptr< SDL_RWops >::type > hnd$; // localdecl
 inline void reset$f(const pxcrt::rawptr< SDL_RWops >::type& v$);
 inline pxcrt::rawptr< SDL_RWops >::type get$f() const;
 inline pxcrt::rawptr< SDL_RWops >::type __to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$() const;
 inline ~scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$() PXC_NOTHROW;
 inline scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$();
};
};}; /* namespace pointer::raw */
namespace exception$n { 
struct runtime_error_template$s$p$sdl__read__file$ls$r$ : pxcrt::runtime_error {
 ~runtime_error_template$s$p$sdl__read__file$ls$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z.refcnt$z(); }
 void incref$z() const { count$z.incref$z(); }
 void decref$z() const { if (count$z.decref$z()) { this->~runtime_error_template$s$p$sdl__read__file$ls$r$(); this->deallocate(this); } }
 static runtime_error_template$s$p$sdl__read__file$ls$r$ *allocate() { return pxcrt::allocate_single< runtime_error_template$s$p$sdl__read__file$ls$r$ >(); }
 static void deallocate(runtime_error_template$s$p$sdl__read__file$ls$r$ const *ptr) { pxcrt::deallocate_single< runtime_error_template$s$p$sdl__read__file$ls$r$ >(ptr); }
 void lock$z() const { monitor$z.mtx.lock(); }
 void unlock$z() const { monitor$z.mtx.unlock(); }
 void wait$z() const { monitor$z.cond.wait(monitor$z.mtx); }
 void notify_one$z() const { monitor$z.cond.notify_one(); }
 void notify_all$z() const { monitor$z.cond.notify_all(); }
 mutable pxcrt::monitor monitor$z;
 mutable pxcrt::mtcount count$z;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > msg$; // localdecl
 inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > message() const;
 inline runtime_error_template$s$p$sdl__read__file$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$);
};
}; /* namespace exception */
namespace pgl3d$n { namespace sdlutil$n { 
struct sdl_file$s$p$0$li$r$ {
 pxcrt::nomove< pxcrt::rawptr< SDL_RWops >::type > ptr$; // localdecl
 inline pxcrt::bt_bool is_null$f() const;
 inline pxcrt::rawptr< SDL_RWops >::type get$f() const;
 inline void reset$f(pxcrt::rawptr< SDL_RWops >::type p$);
 inline ~sdl_file$s$p$0$li$r$() PXC_NOTHROW;
 inline sdl_file$s$p$0$li$r$();
};
};}; /* namespace pgl3d::sdlutil */
namespace operator$n { 
struct tuple$s$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$pgl3d$$wfobj$n$$wfgroup$s$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 ::pgl3d$n::wfobj$n::wfobject$s _0$; // localdecl
 ::pgl3d$n::wfobj$n::wfgroup$s _1$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _2$; // localdecl
 inline tuple$s$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$pgl3d$$wfobj$n$$wfgroup$s$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const ::pgl3d$n::wfobj$n::wfobject$s& a0$, const ::pgl3d$n::wfobj$n::wfgroup$s& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$pgl3d$$wfobj$n$$wfgroup$s$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$(const ::pgl3d$n::wfobj$n::wfobject$s& wfo$, const ::pgl3d$n::wfobj$n::wfgroup$s& wfgrp$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$size_t$t$r$$q$m$ll$r$ {
 pxcrt::bt_size_t _0$; // localdecl
 inline tuple$s$p$m$ll$p$meta$n$$size_t$t$r$$q$m$ll$r$(const pxcrt::bt_size_t& a0$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$meta$n$$size_t$t$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t n$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::bt_float _0$; // localdecl
 pxcrt::bt_size_t _1$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _2$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _3$; // localdecl
 inline tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type _0$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _1$; // localdecl
 inline tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$meta$n$$bool$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type _0$; // localdecl
 pxcrt::bt_bool _1$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _2$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _3$; // localdecl
 inline tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$meta$n$$bool$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, const pxcrt::bt_bool& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$meta$n$$bool$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, pxcrt::bt_bool split_reverse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$int$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::bt_float _0$; // localdecl
 pxcrt::bt_float _1$; // localdecl
 pxcrt::bt_int _2$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _3$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _4$; // localdecl
 inline tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$int$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_int& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a4$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$int$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float z$, pxcrt::bt_float scale$, pxcrt::bt_int recurse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::bt_size_t _0$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _1$; // localdecl
 inline tuple$s$p$m$ll$p$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_size_t& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$(pxcrt::bt_size_t split$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
};
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$meta$n$$size_t$t$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$(pxcrt::bt_size_t n$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$ {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > _0$; // localdecl
 inline tuple$s$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$q$m$ll$r$ {
 inline tuple$s$p$m$ll$q$m$ll$r$();
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$();
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::bt_size_t _0$; // localdecl
 pxcrt::bt_size_t _1$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _2$; // localdecl
 inline tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_size_t& a0$, const pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t split_x$, pxcrt::bt_size_t split_y$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::glmpx::tquat< pxcrt::bt_float >::type _0$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _1$; // localdecl
 inline tuple$s$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& q$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::bt_size_t _0$; // localdecl
 pxcrt::bt_float _1$; // localdecl
 pxcrt::bt_float _2$; // localdecl
 pxcrt::bt_float _3$; // localdecl
 pxcrt::bt_float _4$; // localdecl
 pxcrt::bt_float _5$; // localdecl
 pxcrt::bt_float _6$; // localdecl
 pxcrt::bt_float _7$; // localdecl
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > _8$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _9$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _10$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _11$; // localdecl
 inline tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_size_t& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_float& a2$, const pxcrt::bt_float& a3$, const pxcrt::bt_float& a4$, const pxcrt::bt_float& a5$, const pxcrt::bt_float& a6$, const pxcrt::bt_float& a7$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a8$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a9$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a10$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a11$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$(pxcrt::bt_size_t num$, pxcrt::bt_float scale$, pxcrt::bt_float xmin$, pxcrt::bt_float xmax$, pxcrt::bt_float ymin$, pxcrt::bt_float ymax$, pxcrt::bt_float zmin$, pxcrt::bt_float zmax$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c2$);
};
}; /* namespace callable */
namespace operator$n { 
struct tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$meta$n$$bool$t$q$meta$n$$bool$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ {
 pxcrt::bt_float _0$; // localdecl
 pxcrt::bt_size_t _1$; // localdecl
 pxcrt::bt_bool _2$; // localdecl
 pxcrt::bt_bool _3$; // localdecl
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > _4$; // localdecl
 ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ _5$; // localdecl
 inline tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$meta$n$$bool$t$q$meta$n$$bool$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_bool& a2$, const pxcrt::bt_bool& a3$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a4$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a5$);
};
}; /* namespace operator */
namespace callable$n { 
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$meta$n$$bool$t$q$meta$n$$bool$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, pxcrt::bt_bool surface_flag$, pxcrt::bt_bool rotate_flag$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
};
struct callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ : ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ {
 ~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(); this->deallocate(this); } }
 static callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ *allocate() { return pxcrt::allocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ >(); }
 static void deallocate(callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ const *ptr) { pxcrt::deallocate_single< callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ >(ptr); }
 mutable long count$z;
 ::operator$n::tuple$s$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$ fld$; // localdecl
 inline void __call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
 inline callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$);
};
}; /* namespace callable */
namespace pgl3d$n { namespace dynamics_world$n { 
struct pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ : ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i {
 ~pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$(); this->deallocate(this); } }
 static pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ *allocate() { return pxcrt::allocate_single< pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ >(); }
 static void deallocate(pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ const *ptr) { pxcrt::deallocate_single< pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ >(ptr); }
 mutable long count$z;
 ::btBoxShape value$; // localdecl
 inline pxcrt::rawptr< ::btCollisionShape >::type get$f();
 inline pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$(const ::btVector3& boxHalfExtents_0$);
};
struct pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ : ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i {
 ~pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$() PXC_NOTHROW { }
 size_t refcnt$z() const { return count$z; }
 void incref$z() const { ++count$z; }
 void decref$z() const { if (--count$z == 0) { this->~pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$(); this->deallocate(this); } }
 static pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ *allocate() { return pxcrt::allocate_single< pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ >(); }
 static void deallocate(pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ const *ptr) { pxcrt::deallocate_single< pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ >(ptr); }
 mutable long count$z;
 ::btConvexHullShape value$; // localdecl
 inline pxcrt::rawptr< ::btCollisionShape >::type get$f();
 inline pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$(pxcrt::crawptr< pxcrt::bt_float >::type points_0$, pxcrt::bt_int numPoints_1$, pxcrt::bt_int stride_2$);
};
};}; /* namespace pgl3d::dynamics_world */
/* inline c hdr */
/* inline */
#include <boost/static_assert.hpp>
namespace numeric {
BOOST_STATIC_ASSERT((FLT_RADIX == 2));
using namespace pxcrt;
static inline bt_int fpclassify_double(bt_double x)
{ return std::fpclassify(x); }
static inline bt_int fpclassify_float(bt_float x)
{ return std::fpclassify(x); }
static inline bt_bool signbit_double(bt_double x)
{ return std::signbit(x) != 0; }
static inline bt_bool signbit_float(bt_float x)
{ return std::signbit(x) != 0; }
static inline bt_double frexp_double(bt_double x, bt_int& exp)
{ return std::frexp(x, &exp); }
static inline bt_float frexp_float(bt_float x, bt_int& exp)
{ return std::frexp(x, &exp); }
static inline bt_double ldexp_double(bt_double x, bt_int exp)
{ return std::ldexp(x, exp); }
static inline bt_float ldexp_float(bt_float x, bt_int exp)
{ return std::ldexp(x, exp); }
static inline bt_double modf_double(bt_double x, bt_double& ir)
{ return std::modf(x, &ir); }
static inline bt_float modf_float(bt_float x, bt_float& ir)
{ return std::modf(x, &ir); }
template <typename T> static inline T sin(T x) { return std::sin(x); }
template <typename T> static inline T cos(T x) { return std::cos(x); }
template <typename T> static inline T tan(T x) { return std::tan(x); }
template <typename T> static inline T asin(T x) { return std::asin(x); }
template <typename T> static inline T acos(T x) { return std::acos(x); }
template <typename T> static inline T atan(T x) { return std::atan(x); }
template <typename T> static inline T sinh(T x) { return std::sinh(x); }
template <typename T> static inline T cosh(T x) { return std::cosh(x); }
template <typename T> static inline T tanh(T x) { return std::tanh(x); }
template <typename T> static inline T exp(T x) { return std::exp(x); }
template <typename T> static inline T log(T x) { return std::log(x); }
template <typename T> static inline T log10(T x) { return std::log10(x); }
template <typename T> static inline T sqrt(T x) { return std::sqrt(x); }
template <typename T> static inline T ceil(T x) { return std::ceil(x); }
template <typename T> static inline T floor(T x) { return std::floor(x); }
template <typename T> static inline T fabs(T x) { return std::fabs(x); }
template <typename T> static inline T pow(T x, T y) { return std::pow(x, y); }
template <typename T> static inline T fmod(T x, T y) { return std::fmod(x, y); }
template <typename T> static inline T atan2(T x, T y) { return std::atan2(x, y); }
template <typename T> static inline bool isfinite(T x) { return std::isfinite(x); }
template <typename T> static inline bool isnormal(T x) { return std::isnormal(x); }
template <typename T> static inline bool isnan(T x) { return std::isnan(x); }
template <typename T> static inline bool isinf(T x) { return std::isinf(x); }

}; // namespace numeric
;
/* inline */
namespace pxcrt {
template <typename T> unsigned int union_tag_impl(const T& x)
{
  return x.get_$e();
}
};
;
/* inline */

#include <algorithm>

namespace pxcrt {

template <typename T, typename Tcmp> inline
void sort_compare(bt_slice<T> const& x)
{
  std::sort(x.rawarr(), x.rawarr() + x.size(), compare_less<Tcmp>());
}

template <typename T, typename Tcmp> inline
void stable_sort_lt(bt_slice<T> const& x)
{
  std::stable_sort(x.rawarr(), x.rawarr() + x.size(), compare_less<Tcmp>());
}

};
;
/* inline */

namespace pxcrt {

bt_string c_exception_message(std::exception const& ex);
bt_string c_exception_stack_trace(std::exception const& ex);
std::string c_exception_to_stdstring(const std::exception& ex);
void c_exception_log_stderr(const std::exception& ex);

}; // namespace pxcrt
;
/* inline */

#include <boost/functional/hash.hpp>

namespace pxcrt {

template <typename T> static inline size_t hash_c(T const& x)
{
  ::boost::hash<T> fobj;
  return fobj(x);
};

}; // namespace pxcrt

;
/* inline */
namespace pxcrt {

extern io io_system;

};
;
/* inline */
#ifdef PXC_WINDOWS
#define EDQUOT -1
#define EMULTIHOP -1
#define ESTALE -1
#endif
;
/* inline */
#include <ctime>
#ifdef PXC_POSIX
#include <sys/time.h>
#endif
;
/* inline */
namespace pxcrt {

static inline bt_int file_fileno(file const& f)
{
  return f.get();
}

file_st make_file_st(int fd); /* can be called from other io::* namespaces */
file_mt make_file_mt(int fd); /* can be called from other io::* namespaces */

};
;
/* inline */
namespace pxcrt {

void sighandler_set_signaled(int sig);

};
;
/* inline */

namespace pxcrt {

template <typename Tfuncobj> static inline void *
funcobj_wrap(void *arg)
{
  Tfuncobj *const a = static_cast<Tfuncobj *>(arg);
  a->__call$f();
  return 0;
}

template <typename Tfuncobj> int
thread_create(thread_ptr& thd, Tfuncobj& funcobj)
{
  try {
    thd = new std::thread(&funcobj_wrap<Tfuncobj>, &funcobj);
  } catch (std::system_error const& ex) {
    return ex.code().value();
  } catch (std::exception const& ex) {
    return 1;
  }
  return 0;
}

template <typename Tfuncobj> int
thread_join(thread_ptr& thd)
{
  if (thd) {
    thd->join();
  }
  return 0;
}

};

;
/* inline */

namespace pxcrt { namespace glmpx {

template <typename T> static inline typename tvec2<T>::type
make_tvec2(T x, T y)
{ return typename tvec2<T>::type(x, y); }
template <typename T> static inline typename tvec3<T>::type
make_tvec3(T x, T y, T z)
{ return typename tvec3<T>::type(x, y, z); }
template <typename T> static inline typename tvec4<T>::type
make_tvec4(T x, T y, T z, T w)
{ return typename tvec4<T>::type(x, y, z, w); }
template <typename T> static inline typename tmat2<T>::type
make_tmat2(T a00, T a01, T a10, T a11)
{ return typename tmat2<T>::type(a00, a01, a10, a11); }
template <typename T> static inline typename tmat3<T>::type
make_tmat3(T a00, T a01, T a02, T a10, T a11, T a12, T a20, T a21, T a22)
{ return typename tmat3<T>::type(a00, a01, a02, a10, a11, a12, a20, a21,
  a22); }
template <typename T> static inline typename tmat4<T>::type
make_tmat4(T a00, T a01, T a02, T a03, T a10, T a11, T a12, T a13, T a20,
  T a21, T a22, T a23, T a30, T a31, T a32, T a33)
{ return typename tmat4<T>::type(a00, a01, a02, a03, a10, a11, a12, a13,
  a20, a21, a22, a23, a30, a31, a32, a33); }
template <typename T> static inline typename tquat<T>::type
make_tquat_wxyz(T w, T x, T y, T z)
{ return typename tquat<T>::type(w, x, y, z); }
template <typename T> static inline typename tquat<T>::type
make_tquat_angle_axis(T angle_degrees, T x, T y, T z)
{ return glm::angleAxis(angle_degrees, typename tvec3<T>::type(x, y, z)); }
#ifdef PXC_GLM_ENABLE_DUALQUAT
template <typename T> static inline typename tdualquat<T>::type
make_tdualquat(typename tquat<T>::type const& re,
  typename tquat<T>::type const& du)
{ return typename tdualquat<T>::type(re, du); }
template <typename T> static inline typename tdualquat<T>::type
make_tdualquat_ori_tr(typename tquat<T>::type const& ori,
  typename tvec3<T>::type const& tr)
{ return typename tdualquat<T>::type(ori, tr); }
#endif

template <typename T> static inline pxcrt::bt_cslice<T>
tvec2_to_cslice(typename tvec2<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 2); }
template <typename T> static inline pxcrt::bt_cslice<T>
tvec3_to_cslice(typename tvec3<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 3); }
template <typename T> static inline pxcrt::bt_cslice<T>
tvec4_to_cslice(typename tvec4<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat2_to_cslice(typename tmat2<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat3_to_cslice(typename tmat3<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 9); }
template <typename T> static inline pxcrt::bt_cslice<T>
tmat4_to_cslice(typename tmat4<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 16); }
template <typename T> static inline pxcrt::bt_cslice<T>
tquat_to_cslice(typename tquat<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }
#ifdef PXC_GLM_ENABLE_DUALQUAT
template <typename T> static inline pxcrt::bt_cslice<T>
tdualquat_to_cslice(typename tdualquat<T>::type const& x)
{ return pxcrt::bt_cslice<T>(glm::value_ptr(x), 4); }
#endif

template <typename T> static inline pxcrt::bt_slice<T>
tvec2_to_slice(typename tvec2<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 2); }
template <typename T> static inline pxcrt::bt_slice<T>
tvec3_to_slice(typename tvec3<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 3); }
template <typename T> static inline pxcrt::bt_slice<T>
tvec4_to_slice(typename tvec4<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat2_to_slice(typename tmat2<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat3_to_slice(typename tmat3<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 9); }
template <typename T> static inline pxcrt::bt_slice<T>
tmat4_to_slice(typename tmat4<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 16); }
template <typename T> static inline pxcrt::bt_slice<T>
tquat_to_slice(typename tquat<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }
#ifdef PXC_GLM_ENABLE_DUALQUAT
template <typename T> static inline pxcrt::bt_slice<T>
tdualquat_to_slice(typename tdualquat<T>::type& x)
{ return pxcrt::bt_slice<T>(glm::value_ptr(x), 4); }
#endif

template <typename T> static inline T const *
tvec2_to_crawptr(typename tvec2<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tvec3_to_crawptr(typename tvec3<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tvec4_to_crawptr(typename tvec4<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat2_to_crawptr(typename tmat2<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat3_to_crawptr(typename tmat3<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tmat4_to_crawptr(typename tmat4<T>::type const& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T const *
tquat_to_crawptr(typename tquat<T>::type const& x)
{ return glm::value_ptr(x); }
#ifdef PXC_GLM_ENABLE_DUALQUAT
template <typename T> static inline T const *
tdualquat_to_crawptr(typename tdualquat<T>::type const& x)
{ return glm::value_ptr(x); }
#endif

template <typename T> static inline T *
tvec2_to_rawptr(typename tvec2<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tvec3_to_rawptr(typename tvec3<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tvec4_to_rawptr(typename tvec4<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat2_to_rawptr(typename tmat2<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat3_to_rawptr(typename tmat3<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tmat4_to_rawptr(typename tmat4<T>::type& x)
{ return glm::value_ptr(x); }
template <typename T> static inline T *
tquat_to_rawptr(typename tquat<T>::type& x)
{ return glm::value_ptr(x); }
#ifdef PXC_GLM_ENABLE_DUALQUAT
template <typename T> static inline T *
tdualquat_to_rawptr(typename tdualquat<T>::type& x)
{ return glm::value_ptr(x); }
#endif

template <typename T> static inline pxcrt::farray<T, 2>
tvec2_to_farray(typename tvec2<T>::type const& x)
{
  pxcrt::farray<T, 2> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 2 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 3>
tvec3_to_farray(typename tvec3<T>::type const& x)
{
  pxcrt::farray<T, 3> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 3 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 4>
tvec4_to_farray(typename tvec4<T>::type const& x)
{
  pxcrt::farray<T, 4> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 4 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 4>
tmat2_to_farray(typename tmat2<T>::type const& x)
{
  pxcrt::farray<T, 4> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 4 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 9>
tmat3_to_farray(typename tmat3<T>::type const& x)
{
  pxcrt::farray<T, 9> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 9 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 16>
tmat4_to_farray(typename tmat4<T>::type const& x)
{
  pxcrt::farray<T, 16> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 16 * sizeof(T));
  return r;
}
template <typename T> static inline pxcrt::farray<T, 4>
tquat_to_farray(typename tquat<T>::type const& x)
{
  pxcrt::farray<T, 4> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 4 * sizeof(T));
  return r;
}
#ifdef PXC_GLM_ENABLE_DUALQUAT
template <typename T> static inline pxcrt::farray<T, 8>
tdualquat_to_farray(typename tquat<T>::type const& x)
{
  pxcrt::farray<T, 8> r;
  std::memcpy(r.rawarr(), glm::value_ptr(x), 8 * sizeof(T));
  return r;
}
#endif

template <typename T> static inline typename tmat3<T>::type
tmat2_to_3(typename tmat2<T>::type const& x)
{ return typename tmat3<T>::type(x); }

template <typename T> static inline typename tmat2<T>::type
tmat3_to_2(typename tmat3<T>::type const& x)
{ return typename tmat2<T>::type(x); }

template <typename T> static inline typename tmat4<T>::type
tmat3_to_4(typename tmat3<T>::type const& x)
{ return typename tmat4<T>::type(x); }

template <typename T> static inline typename tmat3<T>::type
tmat4_to_3(typename tmat4<T>::type const& x)
{ return typename tmat3<T>::type(x); }

template <typename T> static inline T op_add(T const& x, T const& y)
{ return x + y; }

template <typename T> static inline T op_sub(T const& x, T const& y)
{ return x - y; }

template <typename T> static inline void op_adda(T& x, T const& y)
{ x += y; }

template <typename T> static inline void op_suba(T& x, T const& y)
{ x -= y; }

template <typename T> static inline bool op_eq(T const& x, T const& y)
{ return x == y; }

template <typename T> static inline bool op_ne(T const& x, T const& y)
{ return x != y; }

template <typename T> static inline T op_minus(T const& x)
{ return -x; }

template <typename Tx, typename Ty, typename Tr> static inline Tr
op_mul(Tx const& x, Ty const& y)
{ return x * y; }

template <typename Tx, typename Ty> static inline Tx
op_div(Tx const& x, Ty const& y)
{ return x / y; }

template <typename T> static inline typename T::value_type
length(T const& x) { return glm::length(x); }

template <typename T> static inline typename T::value_type
distance(T const& x, T const& y) { return glm::distance(x, y); }

template <typename T> static inline typename T::value_type
dot(T const& x, T const& y) { return glm::dot(x, y); }

}; };

;
/* inline */
namespace SDL2 {
using namespace pxcrt;

static inline bt_long RWsize(SDL_RWops *ctx)
{ return SDL_RWsize(ctx); }
static inline bt_long RWseek(SDL_RWops *ctx, bt_long offset, bt_int whence)
{ return SDL_RWseek(ctx, offset, whence); }
static inline bt_size_t RWread(SDL_RWops *ctx, void *p, bt_size_t sz,
  bt_size_t maxnum)
{ return SDL_RWread(ctx, p, sz, maxnum); }
static inline bt_size_t RWwrite(SDL_RWops *ctx, void *p, bt_size_t sz,
  bt_size_t num)
{ return SDL_RWwrite(ctx, p, sz, num); }
static inline int RWclose(SDL_RWops *ctx)
{ return SDL_RWclose(ctx); }

};
;
/* inline */
namespace pxcrt {

template <typename T> static inline T tfuncptr_null() { return T(); }

template <typename Tr>
static inline Tr
tfuncptr0___call(
  typename tfuncptr0<Tr>::type f)
{
  return f();
}

template <typename Tr, typename T0, typename Ta0>
static inline Tr
tfuncptr1___call(
  typename tfuncptr1<Tr, T0>::type f,
  T0 a0)
{
  return f(a0);
}

template <typename Tr, typename T0, typename T1, typename Ta0, typename Ta1>
static inline Tr
tfuncptr2___call(
  typename tfuncptr2<Tr, T0, T1>::type f,
  T0 a0, T1 a1)
{
  return f(a0, a1);
}

template <typename Tr, typename T0, typename T1, typename T2, typename Ta0,
  typename Ta1, typename Ta2>
static inline Tr
tfuncptr3___call(
  typename tfuncptr3<Tr, T0, T1, T2>::type f,
  T0 a0, T1 a1, T2 a2)
{
  return f(a0, a1, a2);
}

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename Ta0, typename Ta1, typename Ta2, typename Ta3>
static inline Tr
tfuncptr4___call(
  typename tfuncptr4<Tr, T0, T1, T2, T3>::type f,
  T0 a0, T1 a1, T2 a2, T3 a3)
{
  return f(a0, a1, a2, a3);
}

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename Ta0, typename Ta1, typename Ta2, typename Ta3,
  typename Ta4>
static inline Tr
tfuncptr5___call(
  typename tfuncptr5<Tr, T0, T1, T2, T3, T4>::type f,
  T0 a0, T1 a1, T2 a2, T3 a3, T4 a4)
{
  return f(a0, a1, a2, a3, a4);
}

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename Ta0, typename Ta1, typename Ta2,
  typename Ta3, typename Ta4, typename Ta5>
static inline Tr
tfuncptr6___call(
  typename tfuncptr6<Tr, T0, T1, T2, T3, T4, T5>::type f,
  T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5)
{
  return f(a0, a1, a2, a3, a4, a5);
}

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename T6, typename Ta0, typename Ta1,
  typename Ta2, typename Ta3, typename Ta4, typename Ta5, typename Ta6>
static inline Tr
tfuncptr7___call(
  typename tfuncptr7<Tr, T0, T1, T2, T3, T4, T5, T6>::type f,
  T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6)
{
  return f(a0, a1, a2, a3, a4, a5, a6);
}

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename T6, typename T7, typename Ta0,
  typename Ta1, typename Ta2, typename Ta3, typename Ta4, typename Ta5,
  typename Ta6, typename Ta7>
static inline Tr
tfuncptr8___call(
  typename tfuncptr8<Tr, T0, T1, T2, T3, T4, T5, T6, T7>::type f,
  T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7)
{
  return f(a0, a1, a2, a3, a4, a5, a6, a7);
}

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename T6, typename T7, typename T8,
  typename Ta0, typename Ta1, typename Ta2, typename Ta3, typename Ta4,
  typename Ta5, typename Ta6, typename Ta7, typename Ta8>
static inline Tr
tfuncptr9___call(
  typename tfuncptr9<Tr, T0, T1, T2, T3, T4, T5, T6, T7, T8>::type f,
  T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8)
{
  return f(a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

template <typename Tr, typename T0, typename T1, typename T2, typename T3,
  typename T4, typename T5, typename T6, typename T7, typename T8, typename T9,
  typename Ta0, typename Ta1, typename Ta2, typename Ta3, typename Ta4,
  typename Ta5, typename Ta6, typename Ta7, typename Ta8, typename Ta9>
static inline Tr
tfuncptr10___call(
  typename tfuncptr10<Tr, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type f,
  T0 a0, T1 a1, T2 a2, T3 a3, T4 a4, T5 a5, T6 a6, T7 a7, T8 a8, T9 a9)
{
  return f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

};
;
/* inline */
namespace pxcrt { namespace gl {
using namespace pxcrt;

static inline const void *offset_to_void_cp(bt_size_t x)
{ return reinterpret_cast<const void *>(x); }

static inline bt_string ccharptr_to_string(const char *x)
{
  if (x == 0) { return bt_string(); }
  return bt_string(reinterpret_cast<const unsigned char *>(x),
    std::strlen(x));
}

static inline bt_string charptr_to_string(char *x)
{ return ccharptr_to_string(reinterpret_cast<const char *>(x)); }

static inline bt_string cubptr_to_string(const GLubyte *x)
{ return ccharptr_to_string(reinterpret_cast<const char *>(x)); }

static inline bt_string ubptr_to_string(GLubyte *x)
{ return ccharptr_to_string(reinterpret_cast<const char *>(x)); }

extern int check_error_enabled;

static inline bt_int get_check_error_enabled()
{ return check_error_enabled; }

static inline void set_check_error_enabled(bt_int v)
{ check_error_enabled = v; }

}; };
;
/* inline */
namespace pgl3d$n { namespace drawer$n {
static inline ::pxcrt::bt_int sdl_byteorder()
{ return SDL_BYTEORDER; }
static inline ::pxcrt::bt_int sdl_lil_endian()
{ return SDL_LIL_ENDIAN; }
static inline ::pxcrt::bt_int sdl_big_endian()
{ return SDL_BIG_ENDIAN; }
}; };
;
/* inline */
namespace pxcrt {

extern pxcrt::pxcvarray<pxcrt::bt_string> pxc_argv;
extern pxcrt::pxcvarray<pxcrt::bt_string> pxc_environ;

};
;
/* inline */
namespace pxcrt { namespace gl {
static inline GLenum glewInit()
{
#ifdef _MSC_VER
  ::glewExperimental = 1;
  GLenum r = ::glewInit();
  ::glGetError();
  return r;
#else
  return 0;
#endif
}
}; };
;
/* inline */
namespace pgl3d$n {
static inline void set_high_dpi(int value)
{
#ifdef _MSC_VER
  SetProcessDpiAwareness((PROCESS_DPI_AWARENESS)value);
#endif
}
};
;
/* function prototype decls */
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$initial$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$vararg$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$fp$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$fp$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$family$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _allocator$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$array_common$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$array_common$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$refguard$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$varray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$varray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$varray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$varray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$varray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$cast$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$array_common$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$refguard$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$varray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$svarray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$farray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$darray$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$deque$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _container$$array$$util$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$family$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _numeric$$fp$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
namespace numeric { 
int fpclassify_double(pxcrt::bt_double x$);
int fpclassify_float(pxcrt::bt_float x$);
pxcrt::bt_bool signbit_double(pxcrt::bt_double x$);
pxcrt::bt_bool signbit_float(pxcrt::bt_float x$);
pxcrt::bt_double frexp_double(pxcrt::bt_double x$, pxcrt::bt_int& exp$);
pxcrt::bt_float frexp_float(pxcrt::bt_float x$, pxcrt::bt_int& exp$);
pxcrt::bt_double ldexp_double(pxcrt::bt_double x$, pxcrt::bt_int exp$);
pxcrt::bt_float ldexp_float(pxcrt::bt_float x$, pxcrt::bt_int exp$);
pxcrt::bt_double modf_double(pxcrt::bt_double x$, pxcrt::bt_double& exp$);
pxcrt::bt_float modf_double(pxcrt::bt_float x$, pxcrt::bt_float& exp$);
}; /* namespace numeric */
extern "C" void _numeric$$integral$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _meta$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _numeric$$integral$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _meta$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _meta$$family$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _numeric$$integral$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _container$$array$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _meta$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _meta$$family$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _numeric$$cast$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _generic$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _numeric$$integral$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _numeric$$integral$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _container$$array$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _numeric$$cast$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _numeric$$limit$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _numeric$$fp$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
extern "C" void _meta$$nsmain$c();
namespace numeric { 
}; /* namespace numeric */
namespace text { 
void fp_to_decimal_float(pxcrt::bt_float v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
void fp_to_decimal_double(pxcrt::bt_double v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
pxcrt::bt_float decimal_to_fp_nocheck_float(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
pxcrt::bt_double decimal_to_fp_nocheck_double(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
pxcrt::bt_float decimal_to_fp_float(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
pxcrt::bt_double decimal_to_fp_double(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
}; /* namespace text */
extern "C" void _numeric$$integral$$nsmain$c();
namespace text { 
}; /* namespace text */
extern "C" void _container$$array$$nsmain$c();
namespace text { 
}; /* namespace text */
namespace pxcrt { 
void minimal_encode(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
void minimal_decode(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$serialize$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _generic$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$family$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$cast$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$string$$positional$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$string$$minimal_encode$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
namespace text$n { namespace string$n { namespace serialize$n { 
void unit_to_string$f(pxcrt::bt_unit v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
void bool_to_string$f(pxcrt::bt_bool v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
void string_append_none$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$);
pxcrt::bt_size_t token_length$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
pxcrt::bt_size_t find_brace_close$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > str_decode$f83(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& stok$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > string_parse_string_unescape$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
pxcrt::bt_bool parse_bool$f87(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& stok$);
pxcrt::bt_bool string_parse_bool$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
pxcrt::bt_unit string_parse_unit$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
pxcrt::bt_size_t string_parse_symbol_peek$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& stok$);
void string_parse_symbol$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& stok$, ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
void string_parse_token_skip$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
};};}; /* namespace text::string::serialize */
extern "C" void _numeric$$integral$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _numeric$$fp$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _numeric$$union_tag$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _container$$array$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _meta$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _meta$$family$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _text$$string$$serialize$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _container$$array$$varray$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _ordered$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _numeric$$integral$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _container$$array$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _ordered$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _container$$tree_map$$tree_map$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _numeric$$integral$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _container$$array$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _exception$$impl$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _numeric$$integral$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _container$$array$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
extern "C" void _meta$$nsmain$c();
namespace text$n { namespace string$n { namespace serialize$n { 
};};}; /* namespace text::string::serialize */
namespace pxcrt { 
::pxcrt::pxcvarray< pxcrt::bt_uchar > c_exception_message(const std::exception& ex$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > c_exception_stack_trace(const std::exception& ex$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > exception_message(const pxcrt::exception& ex$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > exception_stack_trace(const pxcrt::exception& ex$);
}; /* namespace pxcrt */
namespace exception$n { 
void c_exception_append_to_string$f(const std::exception& ex$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& str$);
void exception_append_to_string$f(const pxcrt::exception& ex$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& str$);
}; /* namespace exception */
namespace pxcrt { 
void set_stack_trace_limit(pxcrt::bt_size_t sz$);
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$family$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _exception$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$string$$serialize$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$vararg$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$fp$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$union_tag$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _ordered$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
namespace equality$n { 
void hash_combine$f(pxcrt::bt_size_t& x$, pxcrt::bt_size_t v$);
}; /* namespace equality */
extern "C" void _container$$array$$varray$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _numeric$$integral$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _numeric$$cast$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _exception$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _meta$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _operator$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _equality$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _numeric$$integral$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _meta$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _meta$$vararg$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _meta$$family$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _allocator$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _numeric$$integral$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _pointer$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _algebraic$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _container$$array$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
extern "C" void _meta$$nsmain$c();
namespace equality$n { 
}; /* namespace equality */
namespace pxcrt { 
pxcrt::crawptr< pxcrt::bt_uchar >::type strlit_to_crawptr(const ::pxcrt::bt_strlit& x$);
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$family$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$cast$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$string$$serialize$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$vararg$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$family$$nsmain$c();
namespace pxcrt { 
pxcrt::io debug_system();
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$string$$serialize$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _exception$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _pointer$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
namespace io$n { namespace errno$n { 
int io_get_errno$f(const pxcrt::io& sys$);
void io_set_errno$f(const pxcrt::io& sys$, int e$);
void errno_t_append_to_string$f(int e$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& s$);
void errno_t_check$f(int e$);
};}; /* namespace io::errno */
extern "C" void _numeric$$integral$$nsmain$c();
namespace io$n { namespace errno$n { 
};}; /* namespace io::errno */
extern "C" void _numeric$$fp$$nsmain$c();
namespace io$n { namespace errno$n { 
};}; /* namespace io::errno */
extern "C" void _numeric$$cast$$nsmain$c();
namespace io$n { namespace errno$n { 
};}; /* namespace io::errno */
extern "C" void _io$$nsmain$c();
namespace io$n { namespace errno$n { 
};}; /* namespace io::errno */
namespace pxcrt { 
::timeval gettimeofday(const pxcrt::io& iop$);
std::time_t time(const pxcrt::io& iop$);
::pxcrt::bt_ulonglong high_resolution_timer(const pxcrt::io& iop$);
::pxcrt::bt_ulonglong high_resolution_timer_frequency(const pxcrt::io& iop$);
pxcrt::bt_uint io_sleep(const pxcrt::io& iop$, pxcrt::bt_uint sec$);
pxcrt::bt_uint io_usleep(const pxcrt::io& iop$, pxcrt::bt_uint usec$);
}; /* namespace pxcrt */
namespace io$n { namespace time$n { 
pxcrt::bt_double io_gettimeofday_double$f(const pxcrt::io& iop$);
};}; /* namespace io::time */
namespace pxcrt { 
void time_init();
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$cast$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _pointer$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$errno$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$time$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _exception$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _operator$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _algebraic$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$vararg$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
namespace io$n { namespace file$n { 
::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ io_open_st$f(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$, int flags$, pxcrt::mode_t  md$);
::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_mt$s$r$ io_open_mt$f(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$, int flags$, pxcrt::mode_t  md$);
};}; /* namespace io::file */
namespace pxcrt { 
pxcrt::bt_int io_open_fd(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$, int flags$, pxcrt::mode_t  md$);
pxcrt::file_st io_make_file_st(const pxcrt::io& iop$, pxcrt::bt_int fd$);
pxcrt::file_mt io_make_file_mt(const pxcrt::io& iop$, pxcrt::bt_int fd$);
pxcrt::bt_int file_fileno(const pxcrt::file& f$);
int file_read_impl(const pxcrt::file& f$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$, pxcrt::bt_size_t& len$);
}; /* namespace pxcrt */
namespace io$n { namespace file$n { 
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ file_read$f(const pxcrt::file& f$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$, pxcrt::bt_size_t len$);
};}; /* namespace io::file */
namespace pxcrt { 
int file_write_impl(const pxcrt::file& f$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$, pxcrt::bt_size_t& len_r$);
}; /* namespace pxcrt */
namespace io$n { namespace file$n { 
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ file_write$f(const pxcrt::file& f$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
};}; /* namespace io::file */
namespace pxcrt { 
int file_lseek_impl(const pxcrt::file& f$, pxcrt::off_t& offset$, int whence$);
}; /* namespace pxcrt */
namespace io$n { namespace file$n { 
::io$n::errno$n::errno_or_value$v$p$io$$file$n$$off_t$s$r$ file_lseek$f(const pxcrt::file& f$, pxcrt::off_t offset$, int whence$);
};}; /* namespace io::file */
namespace pxcrt { 
int file_st_close(pxcrt::file_st& f$);
int io_stat(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$, pxcrt::statbuf& buf$);
}; /* namespace pxcrt */
namespace io$n { namespace file$n { 
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ file_read_all$f(const pxcrt::file& f$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ file_write_all$f(const pxcrt::file& f$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
::io$n::errno$n::errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$ io_read_file$f(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$);
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ io_write_file$f(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$ io_pipe$f(const pxcrt::io& sys$);
};}; /* namespace io::file */
namespace pxcrt { 
::pxcrt::pxcvarray< pxcrt::file_mt > io_pipe_internal(const pxcrt::io& sys$, int& err_r$);
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$file$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$errno$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$string$$serialize$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$string$$split$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _algebraic$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$vararg$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$family$$nsmain$c();
namespace pxcrt { 
pxcrt::file_st io_stdin(const pxcrt::io& iop$);
pxcrt::file_st io_stdout(const pxcrt::io& iop$);
pxcrt::file_st io_stderr(const pxcrt::io& iop$);
void debug_log_internal(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$errno$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$file$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$nsmain$c();
namespace pxcrt { 
pxcrt::bt_bool set_signal_handler(const pxcrt::io& iop$, int sig$, pxcrt::sighandler_t handler$);
pxcrt::bt_bool get_signaled(const pxcrt::io& iop$);
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$cast$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _algebraic$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$standard$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$errno$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$signal$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$file$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _exception$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
namespace io$n { namespace process$n { 
void io__exit$f(const pxcrt::io& sys$, pxcrt::bt_int st$);
void exit$f(pxcrt::bt_int st$);
void io_abort$f(const pxcrt::io& sys$);
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$ io_fork$f(const pxcrt::io& sys$);
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pipe_process$s$r$ io_popen$f(const pxcrt::io& sys$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& command$, const ::pxcrt::bt_cslice< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& argv$, pxcrt::bt_bool for_write$, pxcrt::bt_bool search_path$);
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$wait_t$s$r$ io_wait$f(const pxcrt::io& sys$, int& st_r$);
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$wait_t$s$r$ io_waitpid$f(const pxcrt::io& sys$, pxcrt::pid_t p$, int opt$);
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$status_t$s$r$ io_shell_exec$f(const pxcrt::io& sys$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& cmd$);
};}; /* namespace io::process */
namespace pxcrt { 
pxcrt::bt_bool wifexited(int st$);
pxcrt::bt_int wexitstatus(int st$);
pxcrt::bt_bool wifsignaled(int st$);
int wtermsig(int st$);
int execv(const pxcrt::io& sys$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& path$, const ::pxcrt::bt_cslice< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& argv$);
int execvp(const pxcrt::io& sys$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& path$, const ::pxcrt::bt_cslice< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& argv$);
void _exit_internal(const pxcrt::io& sys$, pxcrt::bt_int status$);
void exit_internal(const pxcrt::io& sys$, pxcrt::bt_int status$);
void abort_internal(const pxcrt::io& sys$);
pxcrt::pid_t fork_internal(const pxcrt::io& sys$);
pxcrt::pid_t wait_internal(const pxcrt::io& sys$, int& st_r$);
pxcrt::pid_t waitpid_internal(const pxcrt::io& sys$, pxcrt::pid_t pid$, int& st_r$, int opt$);
pxcrt::bt_int shell_exec_internal(const pxcrt::io& sys$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& cmd$);
int dup2_internal(const pxcrt::io& sys$, const pxcrt::file& ofp$, const pxcrt::file& nfp$);
void io_process_init();
}; /* namespace pxcrt */
extern "C" void _operator$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _pointer$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _operator$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _pointer$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$errno$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _algebraic$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _exception$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _callable$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _text$$string$$serialize$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _container$$array$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _pointer$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _operator$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _thread$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _callable$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _algebraic$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
namespace thread$n { namespace queue$n { 
::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$ queue_wait_pop$f(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$);
void queue_thread_main$f(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$);
void queue_thread_stop$f(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$, pxcrt::bt_int mode$);
void queue_push_notify$f(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$, const ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$& ep$);
};}; /* namespace thread::queue */
extern "C" void _numeric$$integral$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _meta$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _numeric$$integral$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _numeric$$fp$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _algebraic$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _container$$array$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _container$$tree_map$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _container$$hash_map$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _pointer$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _pointer$$raw$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _numeric$$distinct$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _numeric$$cast$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _text$$string$$serialize$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _text$$string$$split$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _io$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _io$$process$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _io$$standard$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _io$$file$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _generic$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _ordered$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _equality$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _callable$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _thread$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _thread$$queue$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _aligned$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _operator$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _common$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _meta$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _common$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _glm$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _meta$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _exception$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _numeric$$integral$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _pointer$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _operator$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _pointer$$raw$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _container$$array$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _meta$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
extern "C" void _meta$$vararg$$nsmain$c();
namespace thread$n { namespace queue$n { 
};}; /* namespace thread::queue */
namespace pointer$n { namespace raw_unsafe$n { 
pxcrt::crawptr< pxcrt::bt_char >::type varray_c_str$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$);
};}; /* namespace pointer::raw_unsafe */
extern "C" void _common$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _meta$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _container$$array$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _meta$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _common$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _pointer$$raw$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _container$$raw$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _SDL2$$api_base$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _meta$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _common$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _pointer$$raw$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _container$$raw$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _SDL2$$api_base$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _SDL2$$api_types$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
extern "C" void _meta$$nsmain$c();
namespace pointer$n { namespace raw_unsafe$n { 
};}; /* namespace pointer::raw_unsafe */
namespace SDL2$n { namespace api_functions$n { 
pxcrt::bt_int SDL_JoystickNumHats(pxcrt::rawptr< SDL_Joystick >::type joystick$);
void SDL_LogSetPriority(pxcrt::bt_int category$, int priority$);
void SDL_LogResetPriorities();
pxcrt::bt_int SDL_CondWait(pxcrt::rawptr< SDL_cond >::type cond$, pxcrt::rawptr< SDL_mutex >::type mutex$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderUNICODE_Blended_Wrapped(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_ushort >::type text$, SDL_Color fg$, pxcrt::bt_uint wrapLength$);
int SDL_HasClipboardText();
pxcrt::bt_int TTF_FontDescent(pxcrt::crawptr< TTF_Font >::type font$);
void SDL_SetWindowIcon(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< SDL_Surface >::type icon$);
pxcrt::bt_int TTF_FontLineSkip(pxcrt::crawptr< TTF_Font >::type font$);
int SDL_LogGetPriority(pxcrt::bt_int category$);
void SDL_GetWindowSize(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::bt_double SDL_sin(pxcrt::bt_double x$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetRevision();
pxcrt::bt_int SDL_FillRect(pxcrt::rawptr< SDL_Surface >::type dst$, pxcrt::crawptr< SDL_Rect >::type rect$, pxcrt::bt_uint color$);
pxcrt::bt_int SDL_HapticGetEffectStatus(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::bt_int effect$);
void SDL_free(pxcrt::rawptr< void >::type mem$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadGIF_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_SetRelativeMouseMode(int enabled$);
pxcrt::bt_int SDL_GameControllerEventState(pxcrt::bt_int state$);
pxcrt::bt_int SDL_GL_MakeCurrent(pxcrt::rawptr< SDL_Window >::type window$, SDL_GLContext context$);
pxcrt::bt_int SDL_JoystickNumBalls(pxcrt::rawptr< SDL_Joystick >::type joystick$);
void SDL_Quit();
int SDL_GetModState();
pxcrt::rawptr< SDL_Surface >::type TTF_RenderText_Shaded(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, SDL_Color fg$, SDL_Color bg$);
SDL_Keycode SDL_GetKeyFromScancode(int scancode$);
pxcrt::bt_int SDL_GetDisplayMode(pxcrt::bt_int displayIndex$, pxcrt::bt_int modeIndex$, pxcrt::rawptr< SDL_DisplayMode >::type mode$);
void TTF_CloseFont(pxcrt::rawptr< TTF_Font >::type font$);
pxcrt::bt_int SDL_strcmp(pxcrt::crawptr< pxcrt::bt_char >::type str1$, pxcrt::crawptr< pxcrt::bt_char >::type str2$);
pxcrt::bt_int SDL_FillRects(pxcrt::rawptr< SDL_Surface >::type dst$, pxcrt::crawptr< SDL_Rect >::type rects$, pxcrt::bt_int count$, pxcrt::bt_uint color$);
pxcrt::bt_long TTF_FontFaces(pxcrt::crawptr< TTF_Font >::type font$);
pxcrt::bt_int SDL_SetSurfaceColorMod(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::bt_uchar r$, pxcrt::bt_uchar g$, pxcrt::bt_uchar b$);
pxcrt::rawptr< SDL_sem >::type SDL_CreateSemaphore(pxcrt::bt_uint initial_value$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetError();
int SDL_HasSSE42();
pxcrt::bt_uint SDL_GetTicks();
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetScancodeName(int scancode$);
pxcrt::bt_int IMG_isXV(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int IMG_SavePNG(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::crawptr< pxcrt::bt_char >::type file$);
void TTF_Quit();
int SDL_HasEvents(pxcrt::bt_uint minType$, pxcrt::bt_uint maxType$);
pxcrt::rawptr< SDL_Renderer >::type SDL_CreateRenderer(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::bt_int index$, pxcrt::bt_uint flags$);
void SDL_RenderGetScale(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< pxcrt::bt_float >::type scaleX$, pxcrt::rawptr< pxcrt::bt_float >::type scaleY$);
pxcrt::bt_double SDL_ceil(pxcrt::bt_double x$);
SDL_JoystickGUID SDL_JoystickGetGUIDFromString(pxcrt::crawptr< pxcrt::bt_char >::type pchGUID$);
pxcrt::bt_int SDL_ConvertPixels(pxcrt::bt_int width$, pxcrt::bt_int height$, pxcrt::bt_uint src_format$, pxcrt::crawptr< void >::type src$, pxcrt::bt_int src_pitch$, pxcrt::bt_uint dst_format$, pxcrt::rawptr< void >::type dst$, pxcrt::bt_int dst_pitch$);
int SDL_HasSSE41();
pxcrt::bt_double SDL_sqrt(pxcrt::bt_double x$);
pxcrt::rawptr< SDL_Surface >::type IMG_Load_RW(pxcrt::rawptr< SDL_RWops >::type src$, pxcrt::bt_int freesrc$);
pxcrt::crawptr< SDL_version >::type IMG_Linked_Version();
pxcrt::rawptr< void >::type SDL_memset(pxcrt::rawptr< void >::type dst$, pxcrt::bt_int c$, pxcrt::bt_size_t len$);
pxcrt::bt_int SDL_SetWindowGammaRamp(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::crawptr< pxcrt::bt_ushort >::type red$, pxcrt::crawptr< pxcrt::bt_ushort >::type green$, pxcrt::crawptr< pxcrt::bt_ushort >::type blue$);
pxcrt::bt_int SDL_JoystickNumAxes(pxcrt::rawptr< SDL_Joystick >::type joystick$);
pxcrt::bt_int SDL_RenderDrawRect(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Rect >::type rect$);
pxcrt::bt_int IMG_SavePNG_RW(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_int freedst$);
pxcrt::rawptr< SDL_Cursor >::type SDL_CreateColorCursor(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::bt_int hot_x$, pxcrt::bt_int hot_y$);
int SDL_IsTextInputActive();
int SDL_HasMMX();
pxcrt::bt_long SDL_strtol(pxcrt::crawptr< pxcrt::bt_char >::type str$, pxcrt::rawptr< pxcrt::rawptr< pxcrt::bt_char >::type >::type endp$, pxcrt::bt_int base$);
int SDL_GameControllerGetButtonFromString(pxcrt::crawptr< pxcrt::bt_char >::type pchString$);
pxcrt::bt_int IMG_isPNG(pxcrt::rawptr< SDL_RWops >::type src$);
void SDL_SetWindowMinimumSize(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::bt_int min_w$, pxcrt::bt_int min_h$);
pxcrt::bt_int TTF_SizeUTF8(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetVideoDriver(pxcrt::bt_int index$);
SDL_JoystickGUID SDL_JoystickGetDeviceGUID(pxcrt::bt_int device_index$);
pxcrt::bt_int SDL_NumHaptics();
pxcrt::bt_int SDL_SetWindowDisplayMode(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::crawptr< SDL_DisplayMode >::type mode$);
int SDL_HasAVX();
void SDL_FreeWAV(pxcrt::rawptr< pxcrt::bt_uchar >::type audio_buf$);
pxcrt::rawptr< void >::type SDL_memcpy(pxcrt::rawptr< void >::type dst$, pxcrt::crawptr< void >::type src$, pxcrt::bt_size_t len$);
pxcrt::bt_int SDL_AtomicSet(pxcrt::rawptr< SDL_atomic_t >::type a$, pxcrt::bt_int v$);
void SDL_RestoreWindow(pxcrt::rawptr< SDL_Window >::type window$);
void SDL_ShowWindow(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_int SDL_strncmp(pxcrt::crawptr< pxcrt::bt_char >::type str1$, pxcrt::crawptr< pxcrt::bt_char >::type str2$, pxcrt::bt_size_t maxlen$);
int SDL_GameControllerGetAttached(pxcrt::rawptr< SDL_GameController >::type gamecontroller$);
pxcrt::bt_int SDL_GetNumRenderDrivers();
SDL_GLContext SDL_GL_GetCurrentContext();
pxcrt::bt_int SDL_HapticIndex(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::rawptr< TTF_Font >::type TTF_OpenFontIndexRW(pxcrt::rawptr< SDL_RWops >::type src$, pxcrt::bt_int freesrc$, pxcrt::bt_int ptsize$, pxcrt::bt_long index$);
pxcrt::bt_int SDL_GetNumTouchDevices();
void SDL_QuitSubSystem(pxcrt::bt_uint flags$);
int SDL_IntersectRectAndLine(pxcrt::crawptr< SDL_Rect >::type rect$, pxcrt::rawptr< pxcrt::bt_int >::type X1$, pxcrt::rawptr< pxcrt::bt_int >::type Y1$, pxcrt::rawptr< pxcrt::bt_int >::type X2$, pxcrt::rawptr< pxcrt::bt_int >::type Y2$);
void SDL_GL_DeleteContext(SDL_GLContext context$);
pxcrt::bt_int SDL_GetNumVideoDrivers();
void SDL_LockAudio();
pxcrt::bt_int SDL_SetWindowBrightness(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::bt_float brightness$);
pxcrt::bt_int SDL_RenderDrawPoints(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Point >::type points$, pxcrt::bt_int count$);
int SDL_HasSSE2();
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetDisplayName(pxcrt::bt_int displayIndex$);
pxcrt::bt_int SDL_HapticUnpause(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::rawptr< SDL_Window >::type SDL_CreateWindow(pxcrt::crawptr< pxcrt::bt_char >::type title$, pxcrt::bt_int x$, pxcrt::bt_int y$, pxcrt::bt_int w$, pxcrt::bt_int h$, pxcrt::bt_uint flags$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_JoystickNameForIndex(pxcrt::bt_int device_index$);
SDL_JoystickID SDL_JoystickInstanceID(pxcrt::rawptr< SDL_Joystick >::type joystick$);
pxcrt::bt_int SDL_HapticEffectSupported(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::rawptr< SDL_HapticEffect >::type effect$);
pxcrt::bt_int TTF_GetFontHinting(pxcrt::crawptr< TTF_Font >::type font$);
pxcrt::bt_int SDL_PollEvent(pxcrt::rawptr< SDL_Event >::type event$);
pxcrt::bt_ulong SDL_GetPerformanceFrequency();
pxcrt::rawptr< SDL_PixelFormat >::type SDL_AllocFormat(pxcrt::bt_uint pixel_format$);
pxcrt::rawptr< SDL_Window >::type SDL_CreateShapedWindow(pxcrt::crawptr< pxcrt::bt_char >::type title$, pxcrt::bt_uint x$, pxcrt::bt_uint y$, pxcrt::bt_uint w$, pxcrt::bt_uint h$, pxcrt::bt_uint flags$);
pxcrt::bt_int SDL_GetWindowDisplayIndex(pxcrt::rawptr< SDL_Window >::type window$);
void SDL_WaitThread(pxcrt::rawptr< SDL_Thread >::type thread$, pxcrt::rawptr< pxcrt::bt_int >::type status$);
pxcrt::bt_float SDL_cosf(pxcrt::bt_float x$);
int SDL_GL_ExtensionSupported(pxcrt::crawptr< pxcrt::bt_char >::type extension$);
pxcrt::bt_int TTF_SizeText(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::bt_int IMG_isXCF(pxcrt::rawptr< SDL_RWops >::type src$);
void SDL_EnableScreenSaver();
pxcrt::bt_int SDL_GetRenderDrawColor(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< pxcrt::bt_uchar >::type r$, pxcrt::rawptr< pxcrt::bt_uchar >::type g$, pxcrt::rawptr< pxcrt::bt_uchar >::type b$, pxcrt::rawptr< pxcrt::bt_uchar >::type a$);
pxcrt::bt_int SDL_GetSurfaceColorMod(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::rawptr< pxcrt::bt_uchar >::type r$, pxcrt::rawptr< pxcrt::bt_uchar >::type g$, pxcrt::rawptr< pxcrt::bt_uchar >::type b$);
void SDL_GL_UnloadLibrary();
int SDL_RenderTargetSupported(pxcrt::rawptr< SDL_Renderer >::type renderer$);
pxcrt::bt_int TTF_FontAscent(pxcrt::crawptr< TTF_Font >::type font$);
pxcrt::bt_uint SDL_GetWindowPixelFormat(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_uchar SDL_EventState(pxcrt::bt_uint type$, pxcrt::bt_int state$);
pxcrt::rawptr< SDL_Window >::type SDL_CreateWindowFrom(pxcrt::crawptr< void >::type data$);
pxcrt::bt_int SDL_GetRendererInfo(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_RendererInfo >::type info$);
pxcrt::bt_int SDL_SetTextureBlendMode(pxcrt::rawptr< SDL_Texture >::type texture$, int blendMode$);
pxcrt::bt_uint SDL_ReadLE32(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::rawptr< SDL_RWops >::type SDL_RWFromMem(pxcrt::rawptr< void >::type mem$, pxcrt::bt_int size$);
void SDL_Delay(pxcrt::bt_uint ms$);
pxcrt::bt_int SDL_JoystickNumButtons(pxcrt::rawptr< SDL_Joystick >::type joystick$);
pxcrt::bt_int SDL_OpenAudio(pxcrt::rawptr< SDL_AudioSpec >::type desired$, pxcrt::rawptr< SDL_AudioSpec >::type obtained$);
pxcrt::bt_int SDL_UpdateWindowSurface(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_int SDL_WaitEventTimeout(pxcrt::rawptr< SDL_Event >::type event$, pxcrt::bt_int timeout$);
void SDL_FlushEvents(pxcrt::bt_uint minType$, pxcrt::bt_uint maxType$);
int SDL_HasAltiVec();
pxcrt::bt_int IMG_Init(pxcrt::bt_int flags$);
pxcrt::bt_int SDL_HapticOpened(pxcrt::bt_int device_index$);
pxcrt::bt_int SDL_HapticNumEffects(pxcrt::rawptr< SDL_Haptic >::type haptic$);
int SDL_HasSSE();
pxcrt::bt_int SDL_GetDisplayBounds(pxcrt::bt_int displayIndex$, pxcrt::rawptr< SDL_Rect >::type rect$);
pxcrt::bt_int SDL_isspace(pxcrt::bt_int x$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderGlyph_Shaded(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::bt_ushort ch$, SDL_Color fg$, SDL_Color bg$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadXV_RW(pxcrt::rawptr< SDL_RWops >::type src$);
void SDL_StopTextInput();
pxcrt::rawptr< SDL_Surface >::type IMG_LoadCUR_RW(pxcrt::rawptr< SDL_RWops >::type src$);
void SDL_GetRGB(pxcrt::bt_uint pixel$, pxcrt::crawptr< SDL_PixelFormat >::type format$, pxcrt::rawptr< pxcrt::bt_uchar >::type r$, pxcrt::rawptr< pxcrt::bt_uchar >::type g$, pxcrt::rawptr< pxcrt::bt_uchar >::type b$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_ultoa(pxcrt::bt_ulong value$, pxcrt::rawptr< pxcrt::bt_char >::type str$, pxcrt::bt_int radix$);
void SDL_SetCursor(pxcrt::rawptr< SDL_Cursor >::type cursor$);
pxcrt::bt_int SDL_Init(pxcrt::bt_uint flags$);
pxcrt::rawptr< SDL_Texture >::type IMG_LoadTexture_RW(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_RWops >::type src$, pxcrt::bt_int freesrc$);
pxcrt::rawptr< SDL_GameController >::type SDL_GameControllerOpen(pxcrt::bt_int joystick_index$);
pxcrt::rawptr< SDL_Joystick >::type SDL_JoystickOpen(pxcrt::bt_int device_index$);
int SDL_GetRelativeMouseMode();
void SDL_DestroyRenderer(pxcrt::rawptr< SDL_Renderer >::type renderer$);
void SDL_AtomicLock(pxcrt::rawptr< SDL_SpinLock >::type lock$);
void SDL_GetRGBA(pxcrt::bt_uint pixel$, pxcrt::crawptr< SDL_PixelFormat >::type format$, pxcrt::rawptr< pxcrt::bt_uchar >::type r$, pxcrt::rawptr< pxcrt::bt_uchar >::type g$, pxcrt::rawptr< pxcrt::bt_uchar >::type b$, pxcrt::rawptr< pxcrt::bt_uchar >::type a$);
pxcrt::bt_double SDL_log(pxcrt::bt_double x$);
void SDL_RenderGetClipRect(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_Rect >::type rect$);
pxcrt::bt_int IMG_isPNM(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_SemWaitTimeout(pxcrt::rawptr< SDL_sem >::type sem$, pxcrt::bt_uint ms$);
pxcrt::bt_int TTF_FontFaceIsFixedWidth(pxcrt::crawptr< TTF_Font >::type font$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderText_Blended(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, SDL_Color fg$);
pxcrt::bt_int IMG_isGIF(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_ulong SDL_ReadLE64(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int TTF_GetFontStyle(pxcrt::crawptr< TTF_Font >::type font$);
pxcrt::bt_uint SDL_WasInit(pxcrt::bt_uint flags$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadPNM_RW(pxcrt::rawptr< SDL_RWops >::type src$);
int SDL_SetHint(pxcrt::crawptr< pxcrt::bt_char >::type name$, pxcrt::crawptr< pxcrt::bt_char >::type value$);
pxcrt::bt_int SDL_HapticUpdateEffect(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::bt_int effect$, pxcrt::rawptr< SDL_HapticEffect >::type data$);
pxcrt::bt_int SDL_GetNumDisplayModes(pxcrt::bt_int displayIndex$);
SDL_GLContext SDL_GL_CreateContext(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_int SDL_SemPost(pxcrt::rawptr< SDL_sem >::type sem$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_GetPrefPath(pxcrt::crawptr< pxcrt::bt_char >::type org$, pxcrt::crawptr< pxcrt::bt_char >::type app$);
int SDL_PixelFormatEnumToMasks(pxcrt::bt_uint format$, pxcrt::rawptr< pxcrt::bt_int >::type bpp$, pxcrt::rawptr< pxcrt::bt_uint >::type Rmask$, pxcrt::rawptr< pxcrt::bt_uint >::type Gmask$, pxcrt::rawptr< pxcrt::bt_uint >::type Bmask$, pxcrt::rawptr< pxcrt::bt_uint >::type Amask$);
pxcrt::bt_int SDL_GetDesktopDisplayMode(pxcrt::bt_int displayIndex$, pxcrt::rawptr< SDL_DisplayMode >::type mode$);
SDL_iconv_t SDL_iconv_open(pxcrt::crawptr< pxcrt::bt_char >::type tocode$, pxcrt::crawptr< pxcrt::bt_char >::type fromcode$);
pxcrt::bt_int SDL_isdigit(pxcrt::bt_int x$);
pxcrt::bt_int SDL_WaitEvent(pxcrt::rawptr< SDL_Event >::type event$);
pxcrt::bt_int SDL_SoftStretch(pxcrt::rawptr< SDL_Surface >::type src$, pxcrt::crawptr< SDL_Rect >::type srcrect$, pxcrt::rawptr< SDL_Surface >::type dst$, pxcrt::crawptr< SDL_Rect >::type dstrect$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_lltoa(pxcrt::bt_long value$, pxcrt::rawptr< pxcrt::bt_char >::type str$, pxcrt::bt_int radix$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_GetClipboardText();
pxcrt::bt_uint SDL_ReadBE32(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_GL_GetSwapInterval();
pxcrt::rawptr< SDL_Surface >::type IMG_LoadPNG_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderUTF8_Blended(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, SDL_Color fg$);
void SDL_UnionRect(pxcrt::crawptr< SDL_Rect >::type A$, pxcrt::crawptr< SDL_Rect >::type B$, pxcrt::rawptr< SDL_Rect >::type result$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_strlwr(pxcrt::rawptr< pxcrt::bt_char >::type str$);
pxcrt::rawptr< SDL_Texture >::type SDL_CreateTexture(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::bt_uint format$, pxcrt::bt_int access$, pxcrt::bt_int w$, pxcrt::bt_int h$);
void SDL_FreeCursor(pxcrt::rawptr< SDL_Cursor >::type cursor$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadPCX_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_iconv_close(SDL_iconv_t cd$);
pxcrt::bt_float SDL_GetWindowBrightness(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_int SDL_GetCPUCacheLineSize();
pxcrt::bt_int SDL_strcasecmp(pxcrt::crawptr< pxcrt::bt_char >::type str1$, pxcrt::crawptr< pxcrt::bt_char >::type str2$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_GetBasePath();
pxcrt::bt_int SDL_SetSurfacePalette(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::rawptr< SDL_Palette >::type palette$);
pxcrt::bt_ulong SDL_strtoull(pxcrt::crawptr< pxcrt::bt_char >::type str$, pxcrt::rawptr< pxcrt::rawptr< pxcrt::bt_char >::type >::type endp$, pxcrt::bt_int base$);
pxcrt::rawptr< SDL_Surface >::type IMG_ReadXPMFromArray(pxcrt::rawptr< pxcrt::rawptr< pxcrt::bt_char >::type >::type xpm$);
pxcrt::rawptr< SDL_Cursor >::type SDL_CreateCursor(pxcrt::crawptr< pxcrt::bt_uchar >::type data$, pxcrt::crawptr< pxcrt::bt_uchar >::type mask$, pxcrt::bt_int w$, pxcrt::bt_int h$, pxcrt::bt_int hot_x$, pxcrt::bt_int hot_y$);
int SDL_IsScreenSaverEnabled();
pxcrt::bt_size_t SDL_WriteLE16(pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_ushort value$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetCurrentVideoDriver();
pxcrt::bt_int SDL_RenderCopy(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::crawptr< SDL_Rect >::type srcrect$, pxcrt::crawptr< SDL_Rect >::type dstrect$);
pxcrt::bt_int SDL_atoi(pxcrt::crawptr< pxcrt::bt_char >::type str$);
pxcrt::bt_int SDL_LowerBlit(pxcrt::rawptr< SDL_Surface >::type src$, pxcrt::rawptr< SDL_Rect >::type srcrect$, pxcrt::rawptr< SDL_Surface >::type dst$, pxcrt::rawptr< SDL_Rect >::type dstrect$);
void SDL_ClearError();
void SDL_SetWindowTitle(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::crawptr< pxcrt::bt_char >::type title$);
pxcrt::bt_uint SDL_MasksToPixelFormatEnum(pxcrt::bt_int bpp$, pxcrt::bt_uint Rmask$, pxcrt::bt_uint Gmask$, pxcrt::bt_uint Bmask$, pxcrt::bt_uint Amask$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_itoa(pxcrt::bt_int value$, pxcrt::rawptr< pxcrt::bt_char >::type str$, pxcrt::bt_int radix$);
pxcrt::bt_int SDL_GL_GetAttribute(int attr$, pxcrt::rawptr< pxcrt::bt_int >::type value$);
void SDL_DestroyWindow(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_uint SDL_HapticQuery(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::bt_size_t SDL_WriteU8(pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_uchar value$);
pxcrt::rawptr< void >::type SDL_LoadObject(pxcrt::crawptr< pxcrt::bt_char >::type sofile$);
void SDL_DestroyMutex(pxcrt::rawptr< SDL_mutex >::type mutex$);
pxcrt::bt_int SDL_UpperBlit(pxcrt::rawptr< SDL_Surface >::type src$, pxcrt::crawptr< SDL_Rect >::type srcrect$, pxcrt::rawptr< SDL_Surface >::type dst$, pxcrt::rawptr< SDL_Rect >::type dstrect$);
pxcrt::bt_int SDL_SetWindowShape(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< SDL_Surface >::type shape$, pxcrt::rawptr< SDL_WindowShapeMode >::type shape_mode$);
pxcrt::bt_int SDL_BuildAudioCVT(pxcrt::rawptr< SDL_AudioCVT >::type cvt$, SDL_AudioFormat src_format$, pxcrt::bt_uchar src_channels$, pxcrt::bt_int src_rate$, SDL_AudioFormat dst_format$, pxcrt::bt_uchar dst_channels$, pxcrt::bt_int dst_rate$);
pxcrt::bt_size_t SDL_strlen(pxcrt::crawptr< pxcrt::bt_char >::type str$);
int SDL_HasEvent(pxcrt::bt_uint type$);
void SDL_JoystickGetGUIDString(SDL_JoystickGUID guid$, pxcrt::rawptr< pxcrt::bt_char >::type pszGUID$, pxcrt::bt_int cbGUID$);
pxcrt::rawptr< SDL_Surface >::type SDL_CreateRGBSurface(pxcrt::bt_uint flags$, pxcrt::bt_int width$, pxcrt::bt_int height$, pxcrt::bt_int depth$, pxcrt::bt_uint Rmask$, pxcrt::bt_uint Gmask$, pxcrt::bt_uint Bmask$, pxcrt::bt_uint Amask$);
pxcrt::bt_double SDL_floor(pxcrt::bt_double x$);
pxcrt::rawptr< void >::type SDL_SetWindowData(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::crawptr< pxcrt::bt_char >::type name$, pxcrt::rawptr< void >::type userdata$);
pxcrt::bt_int TTF_GetFontKerning(pxcrt::crawptr< TTF_Font >::type font$);
int SDL_GetWindowWMInfo(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< SDL_SysWMinfo >::type info$);
pxcrt::bt_int SDL_RenderDrawPoint(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::bt_int x$, pxcrt::bt_int y$);
void SDL_GL_SwapWindow(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_int SDL_CondBroadcast(pxcrt::rawptr< SDL_cond >::type cond$);
pxcrt::bt_double SDL_strtod(pxcrt::crawptr< pxcrt::bt_char >::type str$, pxcrt::rawptr< pxcrt::rawptr< pxcrt::bt_char >::type >::type endp$);
void SDL_AtomicUnlock(pxcrt::rawptr< SDL_SpinLock >::type lock$);
void SDL_WarpMouseInWindow(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::bt_int x$, pxcrt::bt_int y$);
pxcrt::bt_int SDL_abs(pxcrt::bt_int x$);
void SDL_SetWindowPosition(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::bt_int x$, pxcrt::bt_int y$);
pxcrt::bt_size_t SDL_WriteBE16(pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_ushort value$);
int SDL_HasScreenKeyboardSupport();
void SDL_PumpEvents();
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetKeyName(SDL_Keycode key$);
pxcrt::bt_double SDL_asin(pxcrt::bt_double x$);
pxcrt::bt_size_t SDL_WriteBE64(pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_ulong value$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadTyped_RW(pxcrt::rawptr< SDL_RWops >::type src$, pxcrt::bt_int freesrc$, pxcrt::crawptr< pxcrt::bt_char >::type type$);
SDL_JoystickGUID SDL_JoystickGetGUID(pxcrt::rawptr< SDL_Joystick >::type joystick$);
pxcrt::rawptr< SDL_Window >::type SDL_GetKeyboardFocus();
pxcrt::rawptr< void >::type SDL_AtomicGetPtr(pxcrt::rawptr< pxcrt::rawptr< void >::type >::type a$);
pxcrt::bt_int SDL_GL_UnbindTexture(pxcrt::rawptr< SDL_Texture >::type texture$);
pxcrt::rawptr< SDL_Cursor >::type SDL_GetCursor();
pxcrt::rawptr< void >::type SDL_memmove(pxcrt::rawptr< void >::type dst$, pxcrt::crawptr< void >::type src$, pxcrt::bt_size_t len$);
pxcrt::bt_uint SDL_RegisterEvents(pxcrt::bt_int numevents$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_strchr(pxcrt::crawptr< pxcrt::bt_char >::type str$, pxcrt::bt_int c$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderUNICODE_Solid(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_ushort >::type text$, SDL_Color fg$);
pxcrt::rawptr< void >::type SDL_calloc(pxcrt::bt_size_t nmemb$, pxcrt::bt_size_t size$);
pxcrt::rawptr< void >::type SDL_GetWindowData(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::crawptr< pxcrt::bt_char >::type name$);
pxcrt::bt_int SDL_RenderCopyEx(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::crawptr< SDL_Rect >::type srcrect$, pxcrt::crawptr< SDL_Rect >::type dstrect$, pxcrt::bt_double angle$, pxcrt::crawptr< SDL_Point >::type center$, int flip$);
int SDL_Has3DNow();
pxcrt::bt_size_t SDL_WriteLE32(pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_uint value$);
pxcrt::rawptr< SDL_RWops >::type SDL_RWFromFile(pxcrt::crawptr< pxcrt::bt_char >::type file$, pxcrt::crawptr< pxcrt::bt_char >::type mode$);
pxcrt::bt_int SDL_CondWaitTimeout(pxcrt::rawptr< SDL_cond >::type cond$, pxcrt::rawptr< SDL_mutex >::type mutex$, pxcrt::bt_uint ms$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadICO_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int IMG_isICO(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::rawptr< SDL_Surface >::type SDL_LoadBMP_RW(pxcrt::rawptr< SDL_RWops >::type src$, pxcrt::bt_int freesrc$);
pxcrt::bt_int SDL_HapticRumblePlay(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::bt_float strength$, pxcrt::bt_uint length$);
int SDL_RemoveTimer(SDL_TimerID id$);
int SDL_IntersectRect(pxcrt::crawptr< SDL_Rect >::type A$, pxcrt::crawptr< SDL_Rect >::type B$, pxcrt::rawptr< SDL_Rect >::type result$);
pxcrt::bt_double SDL_acos(pxcrt::bt_double x$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GameControllerName(pxcrt::rawptr< SDL_GameController >::type gamecontroller$);
pxcrt::bt_uint SDL_MapRGB(pxcrt::crawptr< SDL_PixelFormat >::type format$, pxcrt::bt_uchar r$, pxcrt::bt_uchar g$, pxcrt::bt_uchar b$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetThreadName(pxcrt::rawptr< SDL_Thread >::type thread$);
int SDL_GameControllerGetAxisFromString(pxcrt::crawptr< pxcrt::bt_char >::type pchString$);
pxcrt::bt_ushort SDL_ReadBE16(pxcrt::rawptr< SDL_RWops >::type src$);
int SDL_IsGameController(pxcrt::bt_int joystick_index$);
void SDL_DisableScreenSaver();
pxcrt::bt_int SDL_PeepEvents(pxcrt::rawptr< SDL_Event >::type events$, pxcrt::bt_int numevents$, int action$, pxcrt::bt_uint minType$, pxcrt::bt_uint maxType$);
pxcrt::bt_int SDL_InitSubSystem(pxcrt::bt_uint flags$);
pxcrt::rawptr< SDL_Texture >::type SDL_CreateTextureFromSurface(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_Surface >::type surface$);
pxcrt::bt_int SDL_ShowCursor(pxcrt::bt_int toggle$);
pxcrt::bt_int SDL_GL_SetAttribute(int attr$, pxcrt::bt_int value$);
pxcrt::bt_int SDL_SetSurfaceAlphaMod(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::bt_uchar alpha$);
SDL_TouchID SDL_GetTouchDevice(pxcrt::bt_int index$);
void SDL_StartTextInput();
pxcrt::rawptr< SDL_Window >::type SDL_GetMouseFocus();
pxcrt::bt_int SDL_ConvertAudio(pxcrt::rawptr< SDL_AudioCVT >::type cvt$);
pxcrt::bt_int SDL_LockSurface(pxcrt::rawptr< SDL_Surface >::type surface$);
void SDL_GameControllerClose(pxcrt::rawptr< SDL_GameController >::type gamecontroller$);
SDL_TLSID SDL_TLSCreate();
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetWindowTitle(pxcrt::rawptr< SDL_Window >::type window$);
int SDL_HasRDTSC();
pxcrt::rawptr< SDL_Surface >::type TTF_RenderText_Solid(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, SDL_Color fg$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderUTF8_Blended_Wrapped(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, SDL_Color fg$, pxcrt::bt_uint wrapLength$);
void SDL_MixAudio(pxcrt::rawptr< pxcrt::bt_uchar >::type dst$, pxcrt::crawptr< pxcrt::bt_uchar >::type src$, pxcrt::bt_uint len$, pxcrt::bt_int volume$);
pxcrt::rawptr< SDL_Joystick >::type SDL_GameControllerGetJoystick(pxcrt::rawptr< SDL_GameController >::type gamecontroller$);
pxcrt::bt_uint SDL_SemValue(pxcrt::rawptr< SDL_sem >::type sem$);
int SDL_IsShapedWindow(pxcrt::crawptr< SDL_Window >::type window$);
pxcrt::rawptr< void >::type SDL_AtomicSetPtr(pxcrt::rawptr< pxcrt::rawptr< void >::type >::type a$, pxcrt::rawptr< void >::type v$);
void SDL_HapticDestroyEffect(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::bt_int effect$);
pxcrt::rawptr< SDL_Texture >::type SDL_GetRenderTarget(pxcrt::rawptr< SDL_Renderer >::type renderer$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderText_Blended_Wrapped(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, SDL_Color fg$, pxcrt::bt_uint wrapLength$);
pxcrt::bt_float SDL_sinf(pxcrt::bt_float x$);
pxcrt::bt_int TTF_GetFontOutline(pxcrt::crawptr< TTF_Font >::type font$);
void SDL_ClearHints();
void SDL_DestroyCond(pxcrt::rawptr< SDL_cond >::type cond$);
void SDL_SetModState(int modstate$);
pxcrt::bt_int SDL_RenderFillRects(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Rect >::type rects$, pxcrt::bt_int count$);
void SDL_GL_GetDrawableSize(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::bt_ulong SDL_GetPerformanceCounter();
pxcrt::bt_int SDL_SetSurfaceRLE(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::bt_int flag$);
pxcrt::bt_int SDL_LoadDollarTemplates(SDL_TouchID touchId$, pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_GetNumVideoDisplays();
pxcrt::bt_int SDL_AtomicGet(pxcrt::rawptr< SDL_atomic_t >::type a$);
int SDL_IsScreenKeyboardShown(pxcrt::rawptr< SDL_Window >::type window$);
void SDL_UnloadObject(pxcrt::rawptr< void >::type handle$);
pxcrt::bt_int SDL_SaveBMP_RW(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_int freedst$);
pxcrt::bt_int SDL_GetRevisionNumber();
void SDL_ResetAssertionReport();
pxcrt::rawptr< SDL_RWops >::type SDL_RWFromFP(pxcrt::rawptr< void >::type fp$, int autoclose$);
pxcrt::bt_size_t SDL_strlcpy(pxcrt::rawptr< pxcrt::bt_char >::type dst$, pxcrt::crawptr< pxcrt::bt_char >::type src$, pxcrt::bt_size_t maxlen$);
pxcrt::bt_int SDL_GetWindowDisplayMode(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< SDL_DisplayMode >::type mode$);
void SDL_DetachThread(pxcrt::rawptr< SDL_Thread >::type thread$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_HapticName(pxcrt::bt_int device_index$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_strrchr(pxcrt::crawptr< pxcrt::bt_char >::type str$, pxcrt::bt_int c$);
pxcrt::bt_size_t SDL_WriteBE32(pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_uint value$);
int SDL_EnclosePoints(pxcrt::crawptr< SDL_Point >::type points$, pxcrt::bt_int count$, pxcrt::crawptr< SDL_Rect >::type clip$, pxcrt::rawptr< SDL_Rect >::type result$);
pxcrt::bt_int SDL_HapticStopEffect(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::bt_int effect$);
int SDL_SetClipRect(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::crawptr< SDL_Rect >::type rect$);
pxcrt::bt_int SDL_strncasecmp(pxcrt::crawptr< pxcrt::bt_char >::type str1$, pxcrt::crawptr< pxcrt::bt_char >::type str2$, pxcrt::bt_size_t len$);
pxcrt::bt_ulong SDL_ReadBE64(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_SetThreadPriority(int priority$);
void SDL_JoystickClose(pxcrt::rawptr< SDL_Joystick >::type joystick$);
void SDL_RaiseWindow(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_strdup(pxcrt::crawptr< pxcrt::bt_char >::type str$);
pxcrt::rawptr< SDL_Surface >::type SDL_ConvertSurfaceFormat(pxcrt::rawptr< SDL_Surface >::type src$, pxcrt::bt_uint pixel_format$, pxcrt::bt_uint flags$);
pxcrt::bt_int SDL_GetTextureAlphaMod(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::rawptr< pxcrt::bt_uchar >::type alpha$);
pxcrt::rawptr< TTF_Font >::type TTF_OpenFontRW(pxcrt::rawptr< SDL_RWops >::type src$, pxcrt::bt_int freesrc$, pxcrt::bt_int ptsize$);
pxcrt::bt_int SDL_RenderSetLogicalSize(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::bt_int w$, pxcrt::bt_int h$);
void SDL_UnlockSurface(pxcrt::rawptr< SDL_Surface >::type surface$);
pxcrt::bt_int SDL_GetSurfaceBlendMode(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::rawptr< int >::type blendMode$);
pxcrt::bt_int SDL_Error(int code$);
pxcrt::bt_int TTF_WasInit();
void SDL_MixAudioFormat(pxcrt::rawptr< pxcrt::bt_uchar >::type dst$, pxcrt::crawptr< pxcrt::bt_uchar >::type src$, SDL_AudioFormat format$, pxcrt::bt_uint len$, pxcrt::bt_int volume$);
pxcrt::bt_int SDL_RenderFillRect(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Rect >::type rect$);
void SDL_GetVersion(pxcrt::rawptr< SDL_version >::type ver$);
pxcrt::crawptr< SDL_version >::type TTF_Linked_Version();
pxcrt::rawptr< SDL_Surface >::type TTF_RenderUNICODE_Blended(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_ushort >::type text$, SDL_Color fg$);
pxcrt::bt_int TTF_Init();
pxcrt::bt_int SDL_HapticStopAll(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::rawptr< SDL_Haptic >::type SDL_HapticOpen(pxcrt::bt_int device_index$);
int SDL_GetScancodeFromKey(SDL_Keycode key$);
pxcrt::bt_int SDL_HapticRumbleStop(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::rawptr< SDL_RWops >::type SDL_AllocRW();
void SDL_GL_ResetAttributes();
pxcrt::rawptr< SDL_Window >::type SDL_GetWindowFromID(pxcrt::bt_uint id$);
pxcrt::bt_int IMG_isTIF(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int IMG_isBMP(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_UpdateTexture(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::crawptr< SDL_Rect >::type rect$, pxcrt::crawptr< void >::type pixels$, pxcrt::bt_int pitch$);
pxcrt::bt_int SDL_UpdateWindowSurfaceRects(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::crawptr< SDL_Rect >::type rects$, pxcrt::bt_int numrects$);
pxcrt::bt_ushort SDL_ReadLE16(pxcrt::rawptr< SDL_RWops >::type src$);
int SDL_AtomicCASPtr(pxcrt::rawptr< pxcrt::rawptr< void >::type >::type a$, pxcrt::rawptr< void >::type oldval$, pxcrt::rawptr< void >::type newval$);
pxcrt::bt_int SDL_RenderDrawLine(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::bt_int x1$, pxcrt::bt_int y1$, pxcrt::bt_int x2$, pxcrt::bt_int y2$);
pxcrt::rawptr< TTF_Font >::type TTF_OpenFont(pxcrt::crawptr< pxcrt::bt_char >::type file$, pxcrt::bt_int ptsize$);
pxcrt::bt_int SDL_SetPaletteColors(pxcrt::rawptr< SDL_Palette >::type palette$, pxcrt::crawptr< SDL_Color >::type colors$, pxcrt::bt_int firstcolor$, pxcrt::bt_int ncolors$);
pxcrt::bt_int SDL_SemTryWait(pxcrt::rawptr< SDL_sem >::type sem$);
pxcrt::bt_int SDL_AtomicAdd(pxcrt::rawptr< SDL_atomic_t >::type a$, pxcrt::bt_int v$);
pxcrt::crawptr< SDL_assert_data >::type SDL_GetAssertionReport();
pxcrt::bt_int SDL_RecordGesture(SDL_TouchID touchId$);
pxcrt::rawptr< SDL_Cursor >::type SDL_GetDefaultCursor();
pxcrt::rawptr< SDL_Surface >::type IMG_LoadBMP_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_ulong SDL_strtoul(pxcrt::crawptr< pxcrt::bt_char >::type str$, pxcrt::rawptr< pxcrt::rawptr< pxcrt::bt_char >::type >::type endp$, pxcrt::bt_int base$);
pxcrt::bt_int SDL_ShowMessageBox(pxcrt::crawptr< SDL_MessageBoxData >::type messageboxdata$, pxcrt::rawptr< pxcrt::bt_int >::type buttonid$);
void SDL_GameControllerUpdate();
pxcrt::bt_int SDL_HapticNumAxes(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::rawptr< pxcrt::bt_char >::type TTF_FontFaceStyleName(pxcrt::crawptr< TTF_Font >::type font$);
void SDL_RenderPresent(pxcrt::rawptr< SDL_Renderer >::type renderer$);
void SDL_FlushEvent(pxcrt::bt_uint type$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_strrev(pxcrt::rawptr< pxcrt::bt_char >::type str$);
void IMG_Quit();
pxcrt::bt_int SDL_TryLockMutex(pxcrt::rawptr< SDL_mutex >::type mutex$);
pxcrt::bt_int SDL_LowerBlitScaled(pxcrt::rawptr< SDL_Surface >::type src$, pxcrt::rawptr< SDL_Rect >::type srcrect$, pxcrt::rawptr< SDL_Surface >::type dst$, pxcrt::rawptr< SDL_Rect >::type dstrect$);
void TTF_SetFontOutline(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::bt_int outline$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_JoystickName(pxcrt::rawptr< SDL_Joystick >::type joystick$);
pxcrt::bt_short SDL_JoystickGetAxis(pxcrt::rawptr< SDL_Joystick >::type joystick$, pxcrt::bt_int axis$);
void SDL_RenderGetLogicalSize(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::bt_double SDL_cos(pxcrt::bt_double x$);
pxcrt::bt_int SDL_GetTextureBlendMode(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::rawptr< int >::type blendMode$);
void SDL_FreeSurface(pxcrt::rawptr< SDL_Surface >::type surface$);
pxcrt::bt_double SDL_fabs(pxcrt::bt_double x$);
pxcrt::bt_int SDL_GetNumAudioDrivers();
pxcrt::rawptr< pxcrt::bt_char >::type SDL_ulltoa(pxcrt::bt_ulong value$, pxcrt::rawptr< pxcrt::bt_char >::type str$, pxcrt::bt_int radix$);
pxcrt::bt_int TTF_GlyphMetrics(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::bt_ushort ch$, pxcrt::rawptr< pxcrt::bt_int >::type minx$, pxcrt::rawptr< pxcrt::bt_int >::type maxx$, pxcrt::rawptr< pxcrt::bt_int >::type miny$, pxcrt::rawptr< pxcrt::bt_int >::type maxy$, pxcrt::rawptr< pxcrt::bt_int >::type advance$);
pxcrt::bt_int SDL_GetNumAudioDevices(pxcrt::bt_int iscapture$);
void SDL_PauseAudioDevice(SDL_AudioDeviceID dev$, pxcrt::bt_int pause_on$);
pxcrt::bt_int SDL_GetSystemRAM();
void SDL_GetWindowMinimumSize(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::bt_int SDL_CreateWindowAndRenderer(pxcrt::bt_int width$, pxcrt::bt_int height$, pxcrt::bt_uint window_flags$, pxcrt::rawptr< pxcrt::rawptr< SDL_Window >::type >::type window$, pxcrt::rawptr< pxcrt::rawptr< SDL_Renderer >::type >::type renderer$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderUTF8_Shaded(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, SDL_Color fg$, SDL_Color bg$);
pxcrt::bt_int SDL_RenderClear(pxcrt::rawptr< SDL_Renderer >::type renderer$);
pxcrt::bt_int SDL_GetTextureColorMod(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::rawptr< pxcrt::bt_uchar >::type r$, pxcrt::rawptr< pxcrt::bt_uchar >::type g$, pxcrt::rawptr< pxcrt::bt_uchar >::type b$);
pxcrt::bt_size_t SDL_strlcat(pxcrt::rawptr< pxcrt::bt_char >::type dst$, pxcrt::crawptr< pxcrt::bt_char >::type src$, pxcrt::bt_size_t maxlen$);
void SDL_UnlockAudio();
pxcrt::bt_int IMG_isLBM(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::rawptr< SDL_DisplayMode >::type SDL_GetClosestDisplayMode(pxcrt::bt_int displayIndex$, pxcrt::crawptr< SDL_DisplayMode >::type mode$, pxcrt::rawptr< SDL_DisplayMode >::type closest$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetAudioDeviceName(pxcrt::bt_int index$, pxcrt::bt_int iscapture$);
pxcrt::bt_int SDL_HapticSetGain(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::bt_int gain$);
void SDL_MinimizeWindow(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetPixelFormatName(pxcrt::bt_uint format$);
pxcrt::bt_int SDL_SetTextureColorMod(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::bt_uchar r$, pxcrt::bt_uchar g$, pxcrt::bt_uchar b$);
void SDL_HapticClose(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::bt_int SDL_UpdateYUVTexture(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::crawptr< SDL_Rect >::type rect$, pxcrt::crawptr< pxcrt::bt_uchar >::type Yplane$, pxcrt::bt_int Ypitch$, pxcrt::crawptr< pxcrt::bt_uchar >::type Uplane$, pxcrt::bt_int Upitch$, pxcrt::crawptr< pxcrt::bt_uchar >::type Vplane$, pxcrt::bt_int Vpitch$);
pxcrt::bt_int SDL_GetCurrentDisplayMode(pxcrt::bt_int displayIndex$, pxcrt::rawptr< SDL_DisplayMode >::type mode$);
pxcrt::bt_uint SDL_GetWindowID(pxcrt::rawptr< SDL_Window >::type window$);
SDL_threadID SDL_ThreadID();
pxcrt::bt_int SDL_GetWindowGammaRamp(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< pxcrt::bt_ushort >::type red$, pxcrt::rawptr< pxcrt::bt_ushort >::type green$, pxcrt::rawptr< pxcrt::bt_ushort >::type blue$);
pxcrt::rawptr< SDL_Surface >::type SDL_CreateRGBSurfaceFrom(pxcrt::rawptr< void >::type pixels$, pxcrt::bt_int width$, pxcrt::bt_int height$, pxcrt::bt_int depth$, pxcrt::bt_int pitch$, pxcrt::bt_uint Rmask$, pxcrt::bt_uint Gmask$, pxcrt::bt_uint Bmask$, pxcrt::bt_uint Amask$);
pxcrt::bt_int IMG_isPCX(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int IMG_isWEBP(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_UpperBlitScaled(pxcrt::rawptr< SDL_Surface >::type src$, pxcrt::crawptr< SDL_Rect >::type srcrect$, pxcrt::rawptr< SDL_Surface >::type dst$, pxcrt::rawptr< SDL_Rect >::type dstrect$);
void SDL_AudioQuit();
pxcrt::bt_int SDL_GL_SetSwapInterval(pxcrt::bt_int interval$);
pxcrt::bt_int TTF_SizeUNICODE(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_ushort >::type text$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
void SDL_UnlockTexture(pxcrt::rawptr< SDL_Texture >::type texture$);
pxcrt::bt_int SDL_LockTexture(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::crawptr< SDL_Rect >::type rect$, pxcrt::rawptr< pxcrt::rawptr< void >::type >::type pixels$, pxcrt::rawptr< pxcrt::bt_int >::type pitch$);
pxcrt::bt_int SDL_SetClipboardText(pxcrt::crawptr< pxcrt::bt_char >::type text$);
pxcrt::rawptr< SDL_cond >::type SDL_CreateCond();
pxcrt::bt_size_t SDL_utf8strlcpy(pxcrt::rawptr< pxcrt::bt_char >::type dst$, pxcrt::crawptr< pxcrt::bt_char >::type src$, pxcrt::bt_size_t dst_bytes$);
pxcrt::bt_int SDL_toupper(pxcrt::bt_int x$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetAudioDriver(pxcrt::bt_int index$);
pxcrt::bt_int SDL_GetRenderDrawBlendMode(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< int >::type blendMode$);
pxcrt::bt_int SDL_QueryTexture(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::rawptr< pxcrt::bt_uint >::type format$, pxcrt::rawptr< pxcrt::bt_int >::type access$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::bt_int IMG_isXPM(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_SetSurfaceBlendMode(pxcrt::rawptr< SDL_Surface >::type surface$, int blendMode$);
int SDL_HasSSE3();
pxcrt::bt_uchar SDL_JoystickGetButton(pxcrt::rawptr< SDL_Joystick >::type joystick$, pxcrt::bt_int button$);
pxcrt::bt_uchar SDL_JoystickGetHat(pxcrt::rawptr< SDL_Joystick >::type joystick$, pxcrt::bt_int hat$);
pxcrt::rawptr< SDL_Renderer >::type SDL_CreateSoftwareRenderer(pxcrt::rawptr< SDL_Surface >::type surface$);
int SDL_HasIntersection(pxcrt::crawptr< SDL_Rect >::type A$, pxcrt::crawptr< SDL_Rect >::type B$);
void SDL_JoystickUpdate();
pxcrt::bt_int SDL_MouseIsHaptic();
pxcrt::bt_int SDL_SetColorKey(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::bt_int flag$, pxcrt::bt_uint key$);
pxcrt::bt_int SDL_SaveAllDollarTemplates(pxcrt::rawptr< SDL_RWops >::type dst$);
pxcrt::bt_int SDL_NumJoysticks();
int SDL_JoystickGetAttached(pxcrt::rawptr< SDL_Joystick >::type joystick$);
int SDL_GetWindowGrab(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_int SDL_ShowSimpleMessageBox(pxcrt::bt_uint flags$, pxcrt::crawptr< pxcrt::bt_char >::type title$, pxcrt::crawptr< pxcrt::bt_char >::type message$, pxcrt::rawptr< SDL_Window >::type window$);
void SDL_SetWindowSize(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::bt_int w$, pxcrt::bt_int h$);
void SDL_DestroySemaphore(pxcrt::rawptr< SDL_sem >::type sem$);
pxcrt::bt_size_t SDL_iconv(SDL_iconv_t cd$, pxcrt::rawptr< pxcrt::crawptr< pxcrt::bt_char >::type >::type inbuf$, pxcrt::rawptr< pxcrt::bt_size_t >::type inbytesleft$, pxcrt::rawptr< pxcrt::rawptr< pxcrt::bt_char >::type >::type outbuf$, pxcrt::rawptr< pxcrt::bt_size_t >::type outbytesleft$);
int SDL_AtomicTryLock(pxcrt::rawptr< SDL_SpinLock >::type lock$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadJPG_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_RenderDrawLines(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Point >::type points$, pxcrt::bt_int count$);
pxcrt::bt_double SDL_pow(pxcrt::bt_double x$, pxcrt::bt_double y$);
int SDL_SetHintWithPriority(pxcrt::crawptr< pxcrt::bt_char >::type name$, pxcrt::crawptr< pxcrt::bt_char >::type value$, int priority$);
pxcrt::bt_int SDL_HapticRumbleSupported(pxcrt::rawptr< SDL_Haptic >::type haptic$);
void SDL_CloseAudio();
void TTF_SetFontHinting(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::bt_int hinting$);
pxcrt::rawptr< SDL_RWops >::type SDL_RWFromConstMem(pxcrt::crawptr< void >::type mem$, pxcrt::bt_int size$);
void SDL_VideoQuit();
pxcrt::rawptr< pxcrt::bt_char >::type SDL_strupr(pxcrt::rawptr< pxcrt::bt_char >::type str$);
pxcrt::bt_int SDL_RenderSetScale(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::bt_float scaleX$, pxcrt::bt_float scaleY$);
pxcrt::rawptr< SDL_Finger >::type SDL_GetTouchFinger(SDL_TouchID touchID$, pxcrt::bt_int index$);
void TTF_SetFontKerning(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::bt_int allowed$);
pxcrt::bt_uchar SDL_ReadU8(pxcrt::rawptr< SDL_RWops >::type src$);
int SDL_GetAudioStatus();
pxcrt::rawptr< pxcrt::bt_char >::type SDL_GameControllerMapping(pxcrt::rawptr< SDL_GameController >::type gamecontroller$);
void SDL_SetTextInputRect(pxcrt::rawptr< SDL_Rect >::type rect$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_ltoa(pxcrt::bt_long value$, pxcrt::rawptr< pxcrt::bt_char >::type str$, pxcrt::bt_int radix$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_strstr(pxcrt::crawptr< pxcrt::bt_char >::type haystack$, pxcrt::crawptr< pxcrt::bt_char >::type needle$);
void SDL_LockAudioDevice(SDL_AudioDeviceID dev$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadTIF_RW(pxcrt::rawptr< SDL_RWops >::type src$);
void SDL_CalculateGammaRamp(pxcrt::bt_float gamma$, pxcrt::rawptr< pxcrt::bt_ushort >::type ramp$);
void SDL_RenderGetViewport(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_Rect >::type rect$);
pxcrt::bt_int SDL_SetWindowFullscreen(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::bt_uint flags$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_getenv(pxcrt::crawptr< pxcrt::bt_char >::type name$);
pxcrt::bt_int SDL_UnlockMutex(pxcrt::rawptr< SDL_mutex >::type mutex$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderUNICODE_Shaded(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_ushort >::type text$, SDL_Color fg$, SDL_Color bg$);
pxcrt::rawptr< SDL_Texture >::type IMG_LoadTexture(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< pxcrt::bt_char >::type file$);
pxcrt::rawptr< void >::type SDL_LoadFunction(pxcrt::rawptr< void >::type handle$, pxcrt::crawptr< pxcrt::bt_char >::type name$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetCurrentAudioDriver();
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GameControllerGetStringForAxis(int axis$);
pxcrt::bt_int SDL_JoystickIsHaptic(pxcrt::rawptr< SDL_Joystick >::type joystick$);
pxcrt::bt_int SDL_SetRenderTarget(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_Texture >::type texture$);
void SDL_DestroyTexture(pxcrt::rawptr< SDL_Texture >::type texture$);
pxcrt::bt_int SDL_GL_BindTexture(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::rawptr< pxcrt::bt_float >::type texw$, pxcrt::rawptr< pxcrt::bt_float >::type texh$);
pxcrt::bt_uint SDL_GetWindowFlags(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::rawptr< SDL_mutex >::type SDL_CreateMutex();
void TTF_SetFontStyle(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::bt_int style$);
pxcrt::bt_int SDL_GetCPUCount();
pxcrt::bt_int SDL_SaveDollarTemplate(SDL_GestureID gestureId$, pxcrt::rawptr< SDL_RWops >::type dst$);
pxcrt::bt_int SDL_RenderSetClipRect(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Rect >::type rect$);
pxcrt::bt_int SDL_tolower(pxcrt::bt_int x$);
void SDL_FreePalette(pxcrt::rawptr< SDL_Palette >::type palette$);
int SDL_GetScancodeFromName(pxcrt::crawptr< pxcrt::bt_char >::type name$);
void SDL_SetMainReady();
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GameControllerNameForIndex(pxcrt::bt_int joystick_index$);
pxcrt::bt_double SDL_atof(pxcrt::crawptr< pxcrt::bt_char >::type str$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderGlyph_Blended(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::bt_ushort ch$, SDL_Color fg$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetHint(pxcrt::crawptr< pxcrt::bt_char >::type name$);
pxcrt::bt_int SDL_VideoInit(pxcrt::crawptr< pxcrt::bt_char >::type driver_name$);
pxcrt::rawptr< SDL_Texture >::type IMG_LoadTextureTyped_RW(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< SDL_RWops >::type src$, pxcrt::bt_int freesrc$, pxcrt::crawptr< pxcrt::bt_char >::type type$);
SDL_AudioDeviceID SDL_OpenAudioDevice(pxcrt::crawptr< pxcrt::bt_char >::type device$, pxcrt::bt_int iscapture$, pxcrt::crawptr< SDL_AudioSpec >::type desired$, pxcrt::rawptr< SDL_AudioSpec >::type obtained$, pxcrt::bt_int allowed_changes$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GetPlatform();
pxcrt::bt_int SDL_SetRenderDrawBlendMode(pxcrt::rawptr< SDL_Renderer >::type renderer$, int blendMode$);
pxcrt::bt_int SDL_HapticNumEffectsPlaying(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::rawptr< SDL_Window >::type SDL_GL_GetCurrentWindow();
pxcrt::bt_int SDL_GetRenderDriverInfo(pxcrt::bt_int index$, pxcrt::rawptr< SDL_RendererInfo >::type info$);
void SDL_SetWindowGrab(pxcrt::rawptr< SDL_Window >::type window$, int grabbed$);
int SDL_GetPowerInfo(pxcrt::rawptr< pxcrt::bt_int >::type secs$, pxcrt::rawptr< pxcrt::bt_int >::type pct$);
pxcrt::bt_int SDL_JoystickEventState(pxcrt::bt_int state$);
void SDL_PauseAudio(pxcrt::bt_int pause_on$);
pxcrt::bt_int SDL_GL_LoadLibrary(pxcrt::crawptr< pxcrt::bt_char >::type path$);
pxcrt::bt_int SDL_CondSignal(pxcrt::rawptr< SDL_cond >::type cond$);
void SDL_MaximizeWindow(pxcrt::rawptr< SDL_Window >::type window$);
void SDL_CloseAudioDevice(SDL_AudioDeviceID dev$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadXCF_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::rawptr< SDL_Palette >::type SDL_AllocPalette(pxcrt::bt_int ncolors$);
pxcrt::bt_int SDL_AudioInit(pxcrt::crawptr< pxcrt::bt_char >::type driver_name$);
void TTF_ByteSwappedUNICODE(pxcrt::bt_int swapped$);
pxcrt::rawptr< TTF_Font >::type TTF_OpenFontIndex(pxcrt::crawptr< pxcrt::bt_char >::type file$, pxcrt::bt_int ptsize$, pxcrt::bt_long index$);
pxcrt::bt_int SDL_GameControllerAddMapping(pxcrt::crawptr< pxcrt::bt_char >::type mappingString$);
pxcrt::bt_int SDL_LockMutex(pxcrt::rawptr< SDL_mutex >::type mutex$);
void SDL_LogSetAllPriority(int priority$);
pxcrt::rawptr< void >::type SDL_realloc(pxcrt::rawptr< void >::type mem$, pxcrt::bt_size_t size$);
pxcrt::bt_int SDL_GetColorKey(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::rawptr< pxcrt::bt_uint >::type key$);
void SDL_FreeRW(pxcrt::rawptr< SDL_RWops >::type area$);
pxcrt::rawptr< SDL_AudioSpec >::type SDL_LoadWAV_RW(pxcrt::rawptr< SDL_RWops >::type src$, pxcrt::bt_int freesrc$, pxcrt::rawptr< SDL_AudioSpec >::type spec$, pxcrt::rawptr< pxcrt::rawptr< pxcrt::bt_uchar >::type >::type audio_buf$, pxcrt::rawptr< pxcrt::bt_uint >::type audio_len$);
pxcrt::rawptr< SDL_Surface >::type SDL_ConvertSurface(pxcrt::rawptr< SDL_Surface >::type src$, pxcrt::crawptr< SDL_PixelFormat >::type fmt$, pxcrt::bt_uint flags$);
pxcrt::bt_double SDL_atan2(pxcrt::bt_double x$, pxcrt::bt_double y$);
pxcrt::rawptr< SDL_Haptic >::type SDL_HapticOpenFromMouse();
pxcrt::bt_int SDL_RenderReadPixels(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Rect >::type rect$, pxcrt::bt_uint format$, pxcrt::rawptr< void >::type pixels$, pxcrt::bt_int pitch$);
void SDL_FreeFormat(pxcrt::rawptr< SDL_PixelFormat >::type format$);
pxcrt::rawptr< SDL_Haptic >::type SDL_HapticOpenFromJoystick(pxcrt::rawptr< SDL_Joystick >::type joystick$);
pxcrt::bt_double SDL_atan(pxcrt::bt_double x$);
void SDL_GetWindowMaximumSize(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::rawptr< SDL_Surface >::type IMG_Load(pxcrt::crawptr< pxcrt::bt_char >::type file$);
pxcrt::bt_int IMG_isCUR(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_setenv(pxcrt::crawptr< pxcrt::bt_char >::type name$, pxcrt::crawptr< pxcrt::bt_char >::type value$, pxcrt::bt_int overwrite$);
pxcrt::bt_int SDL_GetShapedWindowMode(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< SDL_WindowShapeMode >::type shape_mode$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadXPM_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_double SDL_scalbn(pxcrt::bt_double x$, pxcrt::bt_int n$);
pxcrt::bt_uint SDL_MapRGBA(pxcrt::crawptr< SDL_PixelFormat >::type format$, pxcrt::bt_uchar r$, pxcrt::bt_uchar g$, pxcrt::bt_uchar b$, pxcrt::bt_uchar a$);
pxcrt::bt_int SDL_GetSurfaceAlphaMod(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::rawptr< pxcrt::bt_uchar >::type alpha$);
pxcrt::bt_int SDL_RenderSetViewport(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Rect >::type rect$);
void SDL_SetWindowMaximumSize(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::bt_int max_w$, pxcrt::bt_int max_h$);
pxcrt::crawptr< pxcrt::bt_uchar >::type SDL_GetKeyboardState(pxcrt::rawptr< pxcrt::bt_int >::type numkeys$);
SDL_Keycode SDL_GetKeyFromName(pxcrt::crawptr< pxcrt::bt_char >::type name$);
pxcrt::bt_long SDL_strtoll(pxcrt::crawptr< pxcrt::bt_char >::type str$, pxcrt::rawptr< pxcrt::rawptr< pxcrt::bt_char >::type >::type endp$, pxcrt::bt_int base$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_iconv_string(pxcrt::crawptr< pxcrt::bt_char >::type tocode$, pxcrt::crawptr< pxcrt::bt_char >::type fromcode$, pxcrt::crawptr< pxcrt::bt_char >::type inbuf$, pxcrt::bt_size_t inbytesleft$);
pxcrt::bt_int SDL_RenderDrawRects(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::crawptr< SDL_Rect >::type rects$, pxcrt::bt_int count$);
pxcrt::bt_double SDL_copysign(pxcrt::bt_double x$, pxcrt::bt_double y$);
void SDL_SetWindowBordered(pxcrt::rawptr< SDL_Window >::type window$, int bordered$);
pxcrt::bt_int IMG_isJPG(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int SDL_SetPixelFormatPalette(pxcrt::rawptr< SDL_PixelFormat >::type format$, pxcrt::rawptr< SDL_Palette >::type palette$);
pxcrt::rawptr< void >::type SDL_malloc(pxcrt::bt_size_t size$);
int SDL_ReportAssertion(pxcrt::rawptr< SDL_assert_data >::type _0$, pxcrt::crawptr< pxcrt::bt_char >::type _1$, pxcrt::crawptr< pxcrt::bt_char >::type _2$, pxcrt::bt_int _3$);
pxcrt::bt_int SDL_PushEvent(pxcrt::rawptr< SDL_Event >::type event$);
pxcrt::bt_int SDL_GameControllerAddMappingsFromRW(pxcrt::rawptr< SDL_RWops >::type rw$, pxcrt::bt_int freerw$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadWEBP_RW(pxcrt::rawptr< SDL_RWops >::type src$);
void SDL_HideWindow(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::rawptr< SDL_Cursor >::type SDL_CreateSystemCursor(int id$);
pxcrt::rawptr< void >::type SDL_TLSGet(SDL_TLSID id$);
pxcrt::bt_uint SDL_GetRelativeMouseState(pxcrt::rawptr< pxcrt::bt_int >::type x$, pxcrt::rawptr< pxcrt::bt_int >::type y$);
void SDL_GetWindowPosition(pxcrt::rawptr< SDL_Window >::type window$, pxcrt::rawptr< pxcrt::bt_int >::type x$, pxcrt::rawptr< pxcrt::bt_int >::type y$);
pxcrt::bt_int SDL_GetNumTouchFingers(SDL_TouchID touchID$);
pxcrt::bt_size_t SDL_WriteLE64(pxcrt::rawptr< SDL_RWops >::type dst$, pxcrt::bt_ulong value$);
pxcrt::bt_int SDL_JoystickGetBall(pxcrt::rawptr< SDL_Joystick >::type joystick$, pxcrt::bt_int ball$, pxcrt::rawptr< pxcrt::bt_int >::type dx$, pxcrt::rawptr< pxcrt::bt_int >::type dy$);
pxcrt::bt_int SDL_SetRenderDrawColor(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::bt_uchar r$, pxcrt::bt_uchar g$, pxcrt::bt_uchar b$, pxcrt::bt_uchar a$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderGlyph_Solid(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::bt_ushort ch$, SDL_Color fg$);
pxcrt::bt_int SDL_SetTextureAlphaMod(pxcrt::rawptr< SDL_Texture >::type texture$, pxcrt::bt_uchar alpha$);
pxcrt::rawptr< SDL_Surface >::type SDL_GetWindowSurface(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::rawptr< SDL_Renderer >::type SDL_GetRenderer(pxcrt::rawptr< SDL_Window >::type window$);
pxcrt::bt_int SDL_HapticPause(pxcrt::rawptr< SDL_Haptic >::type haptic$);
pxcrt::rawptr< SDL_Surface >::type TTF_RenderUTF8_Solid(pxcrt::rawptr< TTF_Font >::type font$, pxcrt::crawptr< pxcrt::bt_char >::type text$, SDL_Color fg$);
pxcrt::bt_int SDL_SemWait(pxcrt::rawptr< SDL_sem >::type sem$);
pxcrt::bt_uchar SDL_GameControllerGetButton(pxcrt::rawptr< SDL_GameController >::type gamecontroller$, int button$);
pxcrt::bt_int SDL_GetRendererOutputSize(pxcrt::rawptr< SDL_Renderer >::type renderer$, pxcrt::rawptr< pxcrt::bt_int >::type w$, pxcrt::rawptr< pxcrt::bt_int >::type h$);
pxcrt::rawptr< pxcrt::bt_char >::type TTF_FontFaceFamilyName(pxcrt::crawptr< TTF_Font >::type font$);
pxcrt::rawptr< pxcrt::bt_char >::type SDL_uitoa(pxcrt::bt_uint value$, pxcrt::rawptr< pxcrt::bt_char >::type str$, pxcrt::bt_int radix$);
pxcrt::bt_int SDL_HapticRumbleInit(pxcrt::rawptr< SDL_Haptic >::type haptic$);
void SDL_GetClipRect(pxcrt::rawptr< SDL_Surface >::type surface$, pxcrt::rawptr< SDL_Rect >::type rect$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadLBM_RW(pxcrt::rawptr< SDL_RWops >::type src$);
pxcrt::bt_int TTF_FontHeight(pxcrt::crawptr< TTF_Font >::type font$);
void SDL_UnlockAudioDevice(SDL_AudioDeviceID dev$);
pxcrt::bt_int SDL_memcmp(pxcrt::crawptr< void >::type s1$, pxcrt::crawptr< void >::type s2$, pxcrt::bt_size_t len$);
pxcrt::bt_uint SDL_GetMouseState(pxcrt::rawptr< pxcrt::bt_int >::type x$, pxcrt::rawptr< pxcrt::bt_int >::type y$);
pxcrt::rawptr< void >::type SDL_GL_GetProcAddress(pxcrt::crawptr< pxcrt::bt_char >::type proc$);
pxcrt::bt_int SDL_HapticNewEffect(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::rawptr< SDL_HapticEffect >::type effect$);
int SDL_AtomicCAS(pxcrt::rawptr< SDL_atomic_t >::type a$, pxcrt::bt_int oldval$, pxcrt::bt_int newval$);
pxcrt::bt_int SDL_HapticRunEffect(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::bt_int effect$, pxcrt::bt_uint iterations$);
pxcrt::bt_int TTF_GlyphIsProvided(pxcrt::crawptr< TTF_Font >::type font$, pxcrt::bt_ushort ch$);
pxcrt::bt_int SDL_HapticSetAutocenter(pxcrt::rawptr< SDL_Haptic >::type haptic$, pxcrt::bt_int autocenter$);
pxcrt::crawptr< pxcrt::bt_char >::type SDL_GameControllerGetStringForButton(int button$);
pxcrt::rawptr< SDL_Surface >::type IMG_LoadTGA_RW(pxcrt::rawptr< SDL_RWops >::type src$);
SDL_threadID SDL_GetThreadID(pxcrt::rawptr< SDL_Thread >::type thread$);
};}; /* namespace SDL2::api_functions */
extern "C" void _common$$nsmain$c();
namespace SDL2$n { namespace api_functions$n { 
};}; /* namespace SDL2::api_functions */
extern "C" void _pointer$$raw$$nsmain$c();
namespace SDL2$n { namespace api_functions$n { 
};}; /* namespace SDL2::api_functions */
extern "C" void _container$$raw$$nsmain$c();
namespace SDL2$n { namespace api_functions$n { 
};}; /* namespace SDL2::api_functions */
extern "C" void _SDL2$$api_base$$nsmain$c();
namespace SDL2$n { namespace api_functions$n { 
};}; /* namespace SDL2::api_functions */
extern "C" void _SDL2$$api_types$$nsmain$c();
namespace SDL2$n { namespace api_functions$n { 
};}; /* namespace SDL2::api_functions */
extern "C" void _SDL2$$api_functions$$nsmain$c();
namespace SDL2$n { namespace api_functions$n { 
};}; /* namespace SDL2::api_functions */
extern "C" void _meta$$nsmain$c();
namespace SDL2$n { namespace api_functions$n { 
};}; /* namespace SDL2::api_functions */
namespace SDL2 { 
pxcrt::bt_long RWsize(pxcrt::rawptr< SDL_RWops >::type ctx$);
pxcrt::bt_long RWseek(pxcrt::rawptr< SDL_RWops >::type ctx$, pxcrt::bt_long offset$, pxcrt::bt_int whence$);
pxcrt::bt_size_t RWread(pxcrt::rawptr< SDL_RWops >::type ctx$, pxcrt::rawptr< void >::type p$, pxcrt::bt_size_t sz$, pxcrt::bt_size_t maxnum$);
pxcrt::bt_size_t RWwrite(pxcrt::rawptr< SDL_RWops >::type ctx$, pxcrt::crawptr< void >::type p$, pxcrt::bt_size_t sz$, pxcrt::bt_size_t num$);
pxcrt::bt_int RWclose(pxcrt::rawptr< SDL_RWops >::type ctx$);
}; /* namespace SDL2 */
extern "C" void _common$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _pointer$$raw$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _container$$raw$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$api_base$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$api_types$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$api_functions$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$api_wrappers$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _meta$$nsmain$c();
namespace SDL2 { 
void Log(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& mess$);
void LogInfo(pxcrt::bt_int cat$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& mess$);
void LogWarn(pxcrt::bt_int cat$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& mess$);
void LogError(pxcrt::bt_int cat$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& mess$);
}; /* namespace SDL2 */
extern "C" void _common$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _meta$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _meta$$vararg$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$api_base$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$api_types$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$api_functions$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$api_wrappers$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
extern "C" void _SDL2$$misc$$nsmain$c();
namespace SDL2 { 
}; /* namespace SDL2 */
namespace pgl3d$n { namespace glconf$n { 
void sdllog_impl$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
};}; /* namespace pgl3d::glconf */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace glconf$n { 
};}; /* namespace pgl3d::glconf */
extern "C" void _pointer$$raw_unsafe$$nsmain$c();
namespace pgl3d$n { namespace glconf$n { 
};}; /* namespace pgl3d::glconf */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { namespace glconf$n { 
};}; /* namespace pgl3d::glconf */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace glconf$n { 
};}; /* namespace pgl3d::glconf */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { namespace glconf$n { 
};}; /* namespace pgl3d::glconf */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glconf$n { 
};}; /* namespace pgl3d::glconf */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace glconf$n { 
};}; /* namespace pgl3d::glconf */
extern "C" void _pgl3d$$glconf$$nsmain$c();
namespace pgl3d$n { namespace glconf$n { 
};}; /* namespace pgl3d::glconf */
namespace pgl3d$n { namespace glvertex$n { 
void float_slice_set_int$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& s$, pxcrt::bt_int v$);
};}; /* namespace pgl3d::glvertex */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
extern "C" void _container$$array$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
extern "C" void _io$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
extern "C" void _io$$file$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
extern "C" void _io$$errno$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
extern "C" void _text$$string$$split$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
extern "C" void _text$$string$$serialize$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
extern "C" void _meta$$family$$nsmain$c();
namespace pgl3d$n { namespace glvertex$n { 
};}; /* namespace pgl3d::glvertex */
namespace io$n { namespace text$n { 
pxcrt::bt_bool is_space_or_tab$f(pxcrt::bt_uchar ch$);
};}; /* namespace io::text */
extern "C" void _common$$nsmain$c();
namespace io$n { namespace text$n { 
};}; /* namespace io::text */
extern "C" void _io$$text$$nsmain$c();
namespace io$n { namespace text$n { 
};}; /* namespace io::text */
extern "C" void _io$$errno$$nsmain$c();
namespace io$n { namespace text$n { 
};}; /* namespace io::text */
extern "C" void _exception$$nsmain$c();
namespace io$n { namespace text$n { 
};}; /* namespace io::text */
extern "C" void _glm$$nsmain$c();
namespace io$n { namespace text$n { 
};}; /* namespace io::text */
extern "C" void _meta$$nsmain$c();
namespace io$n { namespace text$n { 
};}; /* namespace io::text */
namespace pgl3d$n { namespace wfobj$n { 
void parse_token$f8(::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& elems_work$4$pgl3d$$wfobj$ns1, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& tok$);
void parse_line$f4(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > >& p$4$pgl3d$$wfobj$ns1, ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& elems_work$4$pgl3d$$wfobj$ns1, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >& g$4$pgl3d$$wfobj$ns1, ::pxcrt::bt_cslice< pxcrt::bt_uchar > line$);
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > wfobject_read$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& str$);
void wfobject_test$f();
};}; /* namespace pgl3d::wfobj */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
extern "C" void _operator$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
extern "C" void _pgl3d$$wfobj$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
extern "C" void _pgl3d$$glconf$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
extern "C" void _pgl3d$$glvertex$$nsmain$c();
namespace pgl3d$n { namespace wfobj$n { 
};}; /* namespace pgl3d::wfobj */
namespace pgl3d$n { namespace glgeometry$n { 
pxcrt::bt_float pi_float$f();
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type polygon_center$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$);
pxcrt::bt_float polygon_radius$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$);
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal_from_poly$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$);
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type poly_cross_at$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, pxcrt::bt_size_t i$);
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal_scale_from_poly$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$);
void gf_regular_polygon$f(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_polygon_points$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& pts$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_bump_rec$f(pxcrt::bt_float z$, pxcrt::bt_float scale$, pxcrt::bt_int recurse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type pos$f58(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& vec$, pxcrt::bt_float x$, pxcrt::bt_float xmax$);
void gf_rand_bump$f(pxcrt::bt_size_t num$, pxcrt::bt_float scale$, pxcrt::bt_float xmin$, pxcrt::bt_float xmax$, pxcrt::bt_float ymin$, pxcrt::bt_float ymax$, pxcrt::bt_float zmin$, pxcrt::bt_float zmax$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c2$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
pxcrt::glmpx::tmat4< pxcrt::bt_float >::type poly_trans$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$);
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type generate_rand_sphere$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, pxcrt::bt_bool surface_flag$, pxcrt::bt_float radius$);
pxcrt::glmpx::tquat< pxcrt::bt_float >::type generate_rand_quat$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$);
void gf_rand_sphere$f(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, pxcrt::bt_bool surface_flag$, pxcrt::bt_bool rotate_flag$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_lid$f(const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_ctx_fill$f(pxcrt::bt_size_t n$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_ctx_fill_smooth$f(pxcrt::bt_size_t n$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_ctx_poly_joint$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_ctx_point_joint$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_hole$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_sphere$f(pxcrt::bt_size_t split$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_import_wfobj$f(const ::pgl3d$n::wfobj$n::wfobject$s& wfo$, const ::pgl3d$n::wfobj$n::wfgroup$s& wfgrp$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type pos$f96(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& vec$, pxcrt::bt_size_t i$, pxcrt::bt_size_t imax$);
void gf_rectangle_split$f(pxcrt::bt_size_t split_x$, pxcrt::bt_size_t split_y$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_rotate_local$f(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& q$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_apply$f(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void gf_bump_apply$f(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, pxcrt::bt_bool split_reverse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
};}; /* namespace pgl3d::glgeometry */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$glvertex$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$glgeometry$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$glconf$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$scene_node$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$intern_pool$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$glconf$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _meta$$vararg$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pointer$$tfuncptr$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$glgeometry$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$scene_node$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
extern "C" void _pgl3d$$pglbase$$nsmain$c();
namespace pgl3d$n { namespace glgeometry$n { 
};}; /* namespace pgl3d::glgeometry */
namespace pgl3d$n { namespace drawer_base$n { 
void prepare_instance_data_noop$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$);
};}; /* namespace pgl3d::drawer_base */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace drawer_base$n { 
};}; /* namespace pgl3d::drawer_base */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace drawer_base$n { 
};}; /* namespace pgl3d::drawer_base */
extern "C" void _pointer$$raw$$nsmain$c();
namespace pgl3d$n { namespace drawer_base$n { 
};}; /* namespace pgl3d::drawer_base */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace drawer_base$n { 
};}; /* namespace pgl3d::drawer_base */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace drawer_base$n { 
};}; /* namespace pgl3d::drawer_base */
extern "C" void _pointer$$raw$$nsmain$c();
namespace pgl3d$n { namespace drawer_base$n { 
};}; /* namespace pgl3d::drawer_base */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace drawer_base$n { 
};}; /* namespace pgl3d::drawer_base */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace drawer_base$n { 
};}; /* namespace pgl3d::drawer_base */
namespace pxcrt { 
pxcrt::crawptr< void >::type offset_to_void_cp(pxcrt::bt_size_t x$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > ccharptr_to_string(pxcrt::crawptr< pxcrt::bt_char >::type x$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > charptr_to_string(pxcrt::rawptr< pxcrt::bt_char >::type x$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > cubptr_to_string(pxcrt::crawptr< pxcrt::bt_uchar >::type x$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > ubptr_to_string(pxcrt::rawptr< pxcrt::bt_uchar >::type x$);
pxcrt::bt_int get_check_error_enabled();
void set_check_error_enabled(pxcrt::bt_int v$);
}; /* namespace pxcrt */
namespace GL$n { namespace base$n { 
void gl_check_error$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$);
void gl_check_error_if$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$);
};}; /* namespace GL::base */
namespace $n {
GLenum glGetError();
}; /* namespace */
extern "C" void _meta$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _meta$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _common$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _GL$$base$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _GL$$api_gl$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _GL$$api_gles2$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _meta$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _common$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _glm$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _GL$$compat$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _meta$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _meta$$vararg$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _exception$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _pointer$$raw$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _SDL2$$api_base$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _SDL2$$api_types$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _SDL2$$api_functions$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _SDL2$$api_wrappers$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _SDL2$$misc$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _pgl3d$$glconf$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _common$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _pointer$$raw_unsafe$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _glm$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _GL$$compat$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _meta$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _exception$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _pgl3d$$glresource$$nsmain$c();
namespace $n {
}; /* namespace */
namespace pgl3d$n { namespace glshader$n { 
pxcrt::bt_uint compile_shader$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$, GLenum type$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& err_r$);
pxcrt::bt_uint create_program$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& vertex_shader$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fragment_shader$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& err_r$);
};}; /* namespace pgl3d::glshader */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _pointer$$raw_unsafe$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _GL$$compat$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _pgl3d$$glshader$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _pgl3d$$glresource$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
extern "C" void _pgl3d$$glvertex$$nsmain$c();
namespace pgl3d$n { namespace glshader$n { 
};}; /* namespace pgl3d::glshader */
namespace pgl3d$n { namespace glbuffer$n { 
void vertex_buffer_draw$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, pxcrt::bt_size_t vs_id$, ::pgl3d$n::glshader$n::glshader_i$i& sdr$);
void vertex_buffer_draw_pre$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, ::pgl3d$n::glshader$n::glshader_i$i& sdr$);
void vertex_buffer_draw_post$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, ::pgl3d$n::glshader$n::glshader_i$i& sdr$);
void vertex_buffer_draw_elems$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, pxcrt::bt_size_t vs_id$, pxcrt::bt_size_t num_instance$);
void vertex_buffer_draw_elems_instanced$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, pxcrt::bt_size_t vs_id$, pxcrt::bt_size_t num_instance$);
};}; /* namespace pgl3d::glbuffer */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _pointer$$raw_unsafe$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _GL$$compat$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _pgl3d$$glshader$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _pgl3d$$glresource$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _pgl3d$$glvertex$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _pgl3d$$glbuffer$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
extern "C" void _pgl3d$$pglbase$$nsmain$c();
namespace pgl3d$n { namespace glbuffer$n { 
};}; /* namespace pgl3d::glbuffer */
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
void aggregated_ibuffer_frame_begin$f(::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, pxcrt::bt_bool enable_instanced$, pxcrt::bt_bool enable_uniform_instancing$);
void aggregated_ibuffer_frame_end$f(::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, pxcrt::bt_bool enable_instanced$, pxcrt::bt_bool enable_uniform_instancing$);
void aggregated_ibuffer_draw$f(const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pgl3d$n::glshader$n::glshader_i$i& sdr$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, pxcrt::bt_bool enable_instanced$, pxcrt::bt_bool enable_uniform_instancing$);
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pointer$$raw_unsafe$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _glm$$raw$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pointer$$tfuncptr$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _GL$$compat$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$glresource$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$glshader$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$glgeometry$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$glbuffer$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$scene_node$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$pglbase$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$intern_pool$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$shader_config$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$aggregated_ibuffer$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _pgl3d$$drawer_base$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
};}; /* namespace pgl3d::aggregated_ibuffer */
namespace pgl3d$n { namespace drawer$n { 
void dgf_particle_internal$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void dgf_particle_bb_internal$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void dgf_noop$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_particle_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_particle_bb_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_noop$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > triangles_shader_vert$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_bool instancing$, pxcrt::bt_int opt$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > triangles_shader_frag$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_bool instancing$, pxcrt::bt_int opt$);
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > init_particle_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$);
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > init_particle_bb_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$);
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > init_lineparticle_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$);
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > init_font2_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$);
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > init_rect2d_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$);
void prepare_instance_data_default$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$);
void prepare_instance_data_triangles$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$);
void prepare_instance_data_particle$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$);
void prepare_instance_data_lineparticle$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$);
void prepare_instance_data_rect2d$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$);
void prepare_instance_data_font2$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$);
void prepare_instance_data_ft_rec$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$);
pxcrt::bt_int sdl_byteorder();
pxcrt::bt_int sdl_lil_endian();
pxcrt::bt_int sdl_big_endian();
void check_byteorder$f();
pxcrt::bt_uint read_3_uint$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$, pxcrt::bt_size_t o$);
void write_4_uint$f(const ::pxcrt::bt_slice< pxcrt::bt_uchar >& buf$, pxcrt::bt_size_t o$, pxcrt::bt_uint val$);
void init_font$f(::pgl3d$n::drawer$n::texture_data$s& fnt$);
pxcrt::bt_uint get_shift$f257(pxcrt::bt_uint m$);
void init_main_texture$f(::pgl3d$n::drawer$n::texture_data$s& tex_dpat$, ::pgl3d$n::drawer$n::texture_data$s& tex_tilemap$);
};}; /* namespace pgl3d::drawer */
extern "C" void _pgl3d$$shader_config$$nsmain$c();
namespace pgl3d$n { namespace drawer$n { 
};}; /* namespace pgl3d::drawer */
extern "C" void _pgl3d$$pglbase$$nsmain$c();
namespace pgl3d$n { namespace drawer$n { 
};}; /* namespace pgl3d::drawer */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace drawer$n { 
};}; /* namespace pgl3d::drawer */
extern "C" void _pgl3d$$drawer_base$$nsmain$c();
namespace pgl3d$n { namespace drawer$n { 
};}; /* namespace pgl3d::drawer */
extern "C" void _pgl3d$$drawer$$nsmain$c();
namespace pgl3d$n { namespace drawer$n { 
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace drawer_export$n { 
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_triangles$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$, pxcrt::bt_int opt$);
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_triangles2$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_lineparticle$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_particle$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_particle_bb$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_rect2d$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_font2$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$);
};}; /* namespace pgl3d::drawer_export */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _pgl3d$$scene_node$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _pgl3d$$pglbase$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _pgl3d$$shader_config$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _pgl3d$$drawer_export$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _SDL2$$api_base$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _SDL2$$api_types$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _numeric$$integral$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _numeric$$cast$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _container$$array$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _io$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _io$$errno$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _io$$signal$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace drawer_export$n { 
};}; /* namespace pgl3d::drawer_export */
namespace io$n { namespace environ$n { 
::pxcrt::pxcvarray< pxcrt::bt_uchar > get_option$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > getenv$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$);
};}; /* namespace io::environ */
namespace pxcrt { 
void io_environ_init();
}; /* namespace pxcrt */
extern "C" void _common$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
namespace pgl3d$n { namespace pglcommon$n { 
pxcrt::bt_float to_radians$f(pxcrt::bt_float deg$);
};}; /* namespace pgl3d::pglcommon */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _io$$environ$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _text$$string$$positional$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _pgl3d$$scene_node$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _pgl3d$$pglbase$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _pgl3d$$pglcommon$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _pgl3d$$application$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
extern "C" void _pgl3d$$drawer_base$$nsmain$c();
namespace pgl3d$n { namespace pglcommon$n { 
};}; /* namespace pgl3d::pglcommon */
namespace pgl3d$n { namespace pglmotion$n { 
void motion_thread_main$f(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& sptr$, const ::pgl3d$n::scene_node$n::node_factory$s& nfac0$);
void clear_instances$f(::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$);
};}; /* namespace pgl3d::pglmotion */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pointer$$raw_unsafe$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _glm$$raw$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pointer$$tfuncptr$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _GL$$compat$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$glresource$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$glshader$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$glgeometry$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$glbuffer$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$scene_node$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$pglbase$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$intern_pool$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$shader_config$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$aggregated_ibuffer$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$drawer_base$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
extern "C" void _pgl3d$$drawer$$nsmain$c();
namespace pgl3d$n { namespace pglmotion$n { 
};}; /* namespace pgl3d::pglmotion */
namespace pgl3d$n { namespace pglshader$n { 
::pxcrt::pxcvarray< pxcrt::bt_uint > pglshader_draw_frame$f(::pgl3d$n::pglshader$n::pglshader$s& pgs$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$);
pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > get_drawer_names$f(const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& drawers$);
::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > downcast_drawers$f(const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& drawers$);
void dgf_poly_joint_internal$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void dgf_point_joint_internal$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
void update_mvp$f(::pgl3d$n::pglbase$n::projection_info$s& cam$);
void init_shadowmap_fbo$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$, ::pgl3d$n::pglshader$n::shadowmap_fbo$s& sfbo$);
};}; /* namespace pgl3d::pglshader */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace pglshader$n { 
};}; /* namespace pgl3d::pglshader */
extern "C" void _GL$$base$$nsmain$c();
namespace pgl3d$n { namespace pglshader$n { 
};}; /* namespace pgl3d::pglshader */
namespace pxcrt { 
GLenum glewInit();
}; /* namespace pxcrt */
extern "C" void _common$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _meta$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _io$$environ$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _GL$$compat$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _GL$$glew$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
extern "C" void _pgl3d$$glresource$$nsmain$c();
namespace pxcrt { 
}; /* namespace pxcrt */
namespace pgl3d$n { 
void set_high_dpi(pxcrt::bt_int value$);
}; /* namespace pgl3d$n */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pointer$$raw$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _numeric$$fpmath$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _io$$time$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _io$$environ$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _exception$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _text$$string$$positional$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$glgeometry$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$scene_node$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$pglmotion$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$pglbase$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$pglcommon$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$application$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$wfobj$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _GL$$compat$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$glresource$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$glshader$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$glbuffer$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$pglshader$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
extern "C" void _pgl3d$$sdlcontext$$nsmain$c();
namespace pgl3d$n { 
}; /* namespace pgl3d$n */
namespace pgl3d$n { namespace mainloop$n { 
void mainloop$f(::pgl3d$n::application$n::pgl3d_application$i& app$);
::pxcrt::pxcvarray< pxcrt::bt_uchar > sdl_read_file$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >& fn$);
pxcrt::bt_int set_swap_interval$f(pxcrt::bt_int vsync$);
void toggle_fullscreen$f23(::pgl3d$n::sdlcontext$n::sdlcontext$s& sdlc$23$pgl3d$$mainloop$ns1, pxcrt::bt_int& fullscreen$23$pgl3d$$mainloop$ns1);
void do_commands$f23(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands$23$pgl3d$$mainloop$ns1, ::pgl3d$n::mainloop$n::framerate_control$s& frctl$23$pgl3d$$mainloop$ns1, ::pgl3d$n::sdlcontext$n::sdlcontext$s& _0$up, pxcrt::bt_int& _1$up);
void swap_data_cl$f42(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands$23$pgl3d$$mainloop$ns1, ::pgl3d$n::pglshader$n::pglshader$s& pgs$23$pgl3d$$mainloop$ns1, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& local_whole_instances$23$pgl3d$$mainloop$ns1, ::pgl3d$n::mainloop$n::framerate_control$s& frctl$23$pgl3d$$mainloop$ns1, pxcrt::bt_size_t& saved_stat_num_objects$23$pgl3d$$mainloop$ns1, ::pgl3d$n::pglbase$n::projection_info$s& cam_drawing_frame$23$pgl3d$$mainloop$ns1, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& mess$42$pgl3d$$mainloop$ns1, ::pgl3d$n::pglmotion$n::motion_thread_shared$s& mts$);
void mainloop_internal$f(::pgl3d$n::application$n::pgl3d_application$i& app$);
};}; /* namespace pgl3d::mainloop */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _container$$raw$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _pointer$$tfuncptr$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _Bullet$$base$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _container$$raw$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
extern "C" void _meta$$vararg$$nsmain$c();
namespace pgl3d$n { namespace mainloop$n { 
};}; /* namespace pgl3d::mainloop */
namespace $n {
pxcrt::bt_uint btSwapEndianFloat(pxcrt::bt_float d_0$);
void bt_edge_plane(const ::btVector3& e1_0$, const ::btVector3& e2_1$, const ::btVector3& normal_2$, ::btVector4& plane_3$);
pxcrt::bt_float btDot(const ::btVector3& v1_0$, const ::btVector3& v2_1$);
pxcrt::bt_float btLog(pxcrt::bt_float x_0$);
pxcrt::bt_int bt_plane_clip_triangle(const ::btVector4& plane_0$, const ::btVector3& point0_1$, const ::btVector3& point1_2$, const ::btVector3& point2_3$, pxcrt::rawptr< ::btVector3 >::type clipped_4$);
::btVector3 btAabbSupport(const ::btVector3& halfExtents_0$, const ::btVector3& supportDir_1$);
void btAlignedFreeInternal(pxcrt::rawptr< void >::type ptr_0$);
pxcrt::bt_float btFmod(pxcrt::bt_float x_0$, pxcrt::bt_float y_1$);
void btGenerateInternalEdgeInfo(pxcrt::rawptr< ::btBvhTriangleMeshShape >::type trimeshShape_0$, pxcrt::rawptr< ::btTriangleInfoMap >::type triangleInfoMap_1$);
void btSwapVector3Endian(const ::btVector3& sourceVec_0$, ::btVector3& destVec_1$);
pxcrt::bt_double btUnswapEndianDouble(pxcrt::crawptr< pxcrt::bt_uchar >::type src_0$);
void btAdjustInternalEdgeContacts(::btManifoldPoint& cp_0$, pxcrt::crawptr< ::btCollisionObjectWrapper >::type trimeshColObj0Wrap_1$, pxcrt::crawptr< ::btCollisionObjectWrapper >::type otherColObj1Wrap_2$, pxcrt::bt_int partId0_3$, pxcrt::bt_int index0_4$, pxcrt::bt_int normalAdjustFlags_5$);
pxcrt::bt_float btDistance2(const ::btVector3& v1_0$, const ::btVector3& v2_1$);
pxcrt::bt_float btExp(pxcrt::bt_float x_0$);
pxcrt::bt_int bt_plane_clip_polygon(const ::btVector4& plane_0$, pxcrt::crawptr< ::btVector3 >::type polygon_points_1$, pxcrt::bt_int polygon_point_count_2$, pxcrt::rawptr< ::btVector3 >::type clipped_3$);
pxcrt::bt_float btCos(pxcrt::bt_float x_0$);
pxcrt::bt_bool btFuzzyZero(pxcrt::bt_float x_0$);
pxcrt::bt_float btFsel(pxcrt::bt_float a_0$, pxcrt::bt_float b_1$, pxcrt::bt_float c_2$);
pxcrt::bt_float bt_distance_point_plane(const ::btVector4& plane_0$, const ::btVector3& point_1$);
pxcrt::bt_float btDistance(const ::btVector3& v1_0$, const ::btVector3& v2_1$);
pxcrt::bt_bool btGreaterEqual(pxcrt::bt_float a_0$, pxcrt::bt_float eps_1$);
void bt_quantize_clamp(pxcrt::rawptr< pxcrt::bt_ushort >::type out_0$, const ::btVector3& point_1$, const ::btVector3& min_bound_2$, const ::btVector3& max_bound_3$, const ::btVector3& bvhQuantization_4$);
pxcrt::bt_float btAtan2Fast(pxcrt::bt_float y_0$, pxcrt::bt_float x_1$);
pxcrt::bt_int btIsNegative(pxcrt::bt_float x_0$);
void btAlignedAllocSetCustom(pxcrt::tfuncptr1< pxcrt::rawptr< void >::type,pxcrt::bt_size_t >::type allocFunc_0$, pxcrt::tfuncptr1< void,pxcrt::rawptr< void >::type >::type freeFunc_1$);
void bt_calc_quantization_parameters(::btVector3& outMinBound_0$, ::btVector3& outMaxBound_1$, ::btVector3& bvhQuantization_2$, const ::btVector3& srcMinBound_3$, const ::btVector3& srcMaxBound_4$, pxcrt::bt_float quantizationMargin_5$);
pxcrt::bt_uint btSwapEndian(pxcrt::bt_int val_0$);
pxcrt::bt_ushort btSwapEndian(pxcrt::bt_ushort val_0$);
pxcrt::bt_ushort btSwapEndian(pxcrt::bt_short val_0$);
pxcrt::bt_uint btSwapEndian(pxcrt::bt_uint val_0$);
pxcrt::bt_float btUnswapEndianFloat(pxcrt::bt_uint a_0$);
void btTransformAabb(const ::btVector3& localAabbMin_0$, const ::btVector3& localAabbMax_1$, pxcrt::bt_float margin_2$, const ::btTransform& trans_3$, ::btVector3& aabbMinOut_4$, ::btVector3& aabbMaxOut_5$);
void btTransformAabb(const ::btVector3& halfExtents_0$, pxcrt::bt_float margin_1$, const ::btTransform& t_2$, ::btVector3& aabbMinOut_3$, ::btVector3& aabbMaxOut_4$);
pxcrt::bt_float btAngle(const ::btQuaternion& q1_0$, const ::btQuaternion& q2_1$);
pxcrt::bt_float btAngle(const ::btVector3& v1_0$, const ::btVector3& v2_1$);
pxcrt::bt_float btTan(pxcrt::bt_float x_0$);
pxcrt::bt_float btAcos(pxcrt::bt_float x_0$);
void bt_vec_blend(::btVector3& vr_0$, const ::btVector3& va_1$, const ::btVector3& vb_2$, pxcrt::bt_float blend_factor_3$);
void bt_plane_clip_polygon_collect(const ::btVector3& point0_0$, const ::btVector3& point1_1$, pxcrt::bt_float dist0_2$, pxcrt::bt_float dist1_3$, pxcrt::rawptr< ::btVector3 >::type clipped_4$, pxcrt::bt_int& clipped_count_5$);
pxcrt::bt_bool btCompareTransformsEqual(const ::btTransform& t1_0$, const ::btTransform& t2_1$);
pxcrt::rawptr< void >::type btAlignedAllocInternal(pxcrt::bt_size_t size_0$, pxcrt::bt_int alignment_1$);
pxcrt::bt_float btSqrt(pxcrt::bt_float y_0$);
pxcrt::bt_bool btRayAabb(const ::btVector3& rayFrom_0$, const ::btVector3& rayTo_1$, const ::btVector3& aabbMin_2$, const ::btVector3& aabbMax_3$, pxcrt::bt_float& param_4$, ::btVector3& normal_5$);
pxcrt::bt_int btStrLen(pxcrt::crawptr< pxcrt::bt_char >::type str_0$);
pxcrt::bt_float btTriple(const ::btVector3& v1_0$, const ::btVector3& v2_1$, const ::btVector3& v3_2$);
void bt_segment_collision(const ::btVector3& vA1_0$, const ::btVector3& vA2_1$, const ::btVector3& vB1_2$, const ::btVector3& vB2_3$, ::btVector3& vPointA_4$, ::btVector3& vPointB_5$);
pxcrt::bt_float btAdjustAngleToLimits(pxcrt::bt_float angleInRadians_0$, pxcrt::bt_float angleLowerLimitInRadians_1$, pxcrt::bt_float angleUpperLimitInRadians_2$);
::btVector3 Lerp(const ::btVector3& a_0$, const ::btVector3& b_1$, pxcrt::bt_float t_2$);
pxcrt::bt_int btSelect(pxcrt::bt_uint condition_0$, pxcrt::bt_int valueIfConditionNonZero_1$, pxcrt::bt_int valueIfConditionZero_2$);
pxcrt::bt_float btSelect(pxcrt::bt_uint condition_0$, pxcrt::bt_float valueIfConditionNonZero_1$, pxcrt::bt_float valueIfConditionZero_2$);
pxcrt::bt_uint btSelect(pxcrt::bt_uint condition_0$, pxcrt::bt_uint valueIfConditionNonZero_1$, pxcrt::bt_uint valueIfConditionZero_2$);
::btVector3 bt_unquantize(pxcrt::crawptr< pxcrt::bt_ushort >::type vecIn_0$, const ::btVector3& offset_1$, const ::btVector3& bvhQuantization_2$);
pxcrt::bt_int bt_line_plane_collision(const ::btVector4& plane_0$, const ::btVector3& vDir_1$, const ::btVector3& vPoint_2$, ::btVector3& pout_3$, pxcrt::bt_float& tparam_4$, pxcrt::bt_float tmin_5$, pxcrt::bt_float tmax_6$);
void btAlignedAllocSetCustomAligned(pxcrt::tfuncptr2< pxcrt::rawptr< void >::type,pxcrt::bt_size_t,pxcrt::bt_int >::type allocFunc_0$, pxcrt::tfuncptr1< void,pxcrt::rawptr< void >::type >::type freeFunc_1$);
pxcrt::bt_bool btRayAabb2(const ::btVector3& rayFrom_0$, const ::btVector3& rayInvDirection_1$, pxcrt::crawptr< pxcrt::bt_uint >::type raySign_2$, pxcrt::crawptr< ::btVector3 >::type bounds_3$, pxcrt::bt_float& tmin_4$, pxcrt::bt_float lambda_min_5$, pxcrt::bt_float lambda_max_6$);
pxcrt::bt_float btAtan(pxcrt::bt_float x_0$);
pxcrt::bt_float btFabs(pxcrt::bt_float x_0$);
pxcrt::bt_bool btMachineIsLittleEndian();
pxcrt::bt_int btGetVersion();
void btSwapScalarEndian(const pxcrt::bt_float& sourceVal_0$, pxcrt::bt_float& destVal_1$);
pxcrt::bt_float btAtan2(pxcrt::bt_float x_0$, pxcrt::bt_float y_1$);
pxcrt::bt_float btAsin(pxcrt::bt_float x_0$);
pxcrt::bt_float btPow(pxcrt::bt_float x_0$, pxcrt::bt_float y_1$);
::btVector3 btCross(const ::btVector3& v1_0$, const ::btVector3& v2_1$);
pxcrt::bt_float btNormalizeAngle(pxcrt::bt_float angleInRadians_0$);
pxcrt::bt_float btDegrees(pxcrt::bt_float x_0$);
pxcrt::bt_bool btEqual(pxcrt::bt_float a_0$, pxcrt::bt_float eps_1$);
pxcrt::bt_float bt_mat3_dot_col(const ::btMatrix3x3& mat_0$, const ::btVector3& vec3_1$, pxcrt::bt_int colindex_2$);
pxcrt::bt_float btSin(pxcrt::bt_float x_0$);
void bt_closest_point_on_segment(::btVector3& cp_0$, const ::btVector3& v_1$, const ::btVector3& e1_2$, const ::btVector3& e2_3$);
pxcrt::bt_int btOutcode(const ::btVector3& p_0$, const ::btVector3& halfExtent_1$);
void btUnSwapVector3Endian(::btVector3& vector_0$);
void btSwapEndianDouble(pxcrt::bt_double d_0$, pxcrt::rawptr< pxcrt::bt_uchar >::type dst_1$);
pxcrt::bt_float btLargeDot(pxcrt::crawptr< pxcrt::bt_float >::type a_0$, pxcrt::crawptr< pxcrt::bt_float >::type b_1$, pxcrt::bt_int n_2$);
pxcrt::bt_float btRadians(pxcrt::bt_float x_0$);
}; /* namespace */
extern "C" void _common$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _Bullet$$base$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _Bullet$$api$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _pointer$$raw_unsafe$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _meta$$nsmain$c();
namespace $n {
}; /* namespace */
extern "C" void _meta$$vararg$$nsmain$c();
namespace $n {
}; /* namespace */
namespace pgl3d$n { namespace dynamics_world$n { 
::btRigidBody makeRigidBody$f(pxcrt::rawptr< ::btCollisionShape >::type shape$, pxcrt::rawptr< ::btDefaultMotionState >::type motionState$, pxcrt::bt_float mass$);
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _pgl3d$$glresource$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
extern "C" void _pointer$$raw$$nsmain$c();
namespace pgl3d$n { namespace dynamics_world$n { 
};}; /* namespace pgl3d::dynamics_world */
namespace pgl3d$n { namespace sdlutil$n { 
pxcrt::bt_bool sdl_load_file$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& fname$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf_r$);
};}; /* namespace pgl3d::sdlutil */
extern "C" void _common$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _meta$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _glm$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _text$$string$$positional$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$application$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$mainloop$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$pglcommon$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$glconf$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$glgeometry$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$wfobj$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$drawer_export$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$device_motion$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$dynamics_world$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _Bullet$$base$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _Bullet$$api$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
extern "C" void _pgl3d$$sdlutil$$nsmain$c();
namespace pgl3d$n { namespace sdlutil$n { 
};}; /* namespace pgl3d::sdlutil */
namespace demoapp$n { 
void $f2(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& m$1$demoapp$ns0, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& line$);
void handle_event$f(::demoapp$n::app_impl$s& app$, const SDL_Event& ev$, pxcrt::bt_float frame_speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$);
pxcrt::bt_uint get_key$f102(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& keys$102, int k$);
void handle_keys$f(::demoapp$n::app_impl$s& app$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& keys$102, pxcrt::bt_float frame_speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$);
pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > init_drawers$f(::demoapp$n::app_impl$s& app$, const ::pgl3d$n::shader_config$n::shader_config$s& sconf$);
void shapes_add$f119(::pgl3d$n::pglbase$n::make_vertices_i$i& pgs$119, ::demoapp$n::app_impl$s& app$119, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$);
void build_vertices$f(::demoapp$n::app_impl$s& app$119, ::pgl3d$n::pglbase$n::make_vertices_i$i& pgs$119);
::pgl3d$n::scene_node$n::scene_node$s make_node$f();
void scene_control_set_message$f(::demoapp$n::scene_control$s& sctl$, ::pgl3d$n::scene_node$n::scene_node$s& sn_text$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& text$, pxcrt::bt_uint x$, pxcrt::bt_uint y$, pxcrt::bt_uint font_width$, pxcrt::bt_uint font_height$, pxcrt::bt_float screen_w$, pxcrt::bt_float screen_h$);
::btTransform to_btTransform$f(const ::pgl3d$n::pglbase$n::position_angle$s& posang$);
void scene_control_update_buttons$f(::demoapp$n::scene_control$s& sctl$, ::pgl3d$n::scene_node$n::scene_node$s& sn_buttons$);
pxcrt::bt_bool lp_is_finished$f150(const ::demoapp$n::lpbullet_data$s& lpb$);
void step_lp$f148(const pxcrt::bt_float& speed$148$demoapp$ns0, ::demoapp$n::scene_control$s& sctl$148);
void spawn_lp$f148(::demoapp$n::scene_control$s& sctl$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& tr$, pxcrt::bt_float speed$);
void prepare_one$f148(::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$148, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$148, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$148, const ::pgl3d$n::scene_node$n::scene_node$s& sn$);
void step_snobj$f148(const pxcrt::bt_float& speed$148$demoapp$ns0, ::demoapp$n::scene_control$s& sctl$148, ::pgl3d$n::scene_node$n::scene_node$s& sn_work$148$demoapp$ns0, pxcrt::bt_bool& spawn_now$148$demoapp$ns0, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& _0$up, ::pgl3d$n::pglbase$n::node_common_data$s& _1$up, ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > const& _2$up, ::pgl3d$n::scene_node$n::scene_node$s& sn_scene$);
void step_snobj_dynamics$f148(const pxcrt::bt_float& speed$148$demoapp$ns0, const ::demoapp$n::demoapp_scene_shared$s& ss$148, ::demoapp$n::scene_control$s& sctl$148, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& _0$up, ::pgl3d$n::pglbase$n::node_common_data$s& _1$up, ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > const& _2$up, ::pgl3d$n::scene_node$n::scene_node$s& sn_scene$, pxcrt::bt_bool spawn_obj$);
void scene_control_step$f(::demoapp$n::scene_control$s& sctl$148, const ::demoapp$n::demoapp_scene_shared$s& ss$148, pxcrt::bt_float frame_speed$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$148, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$148, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$148);
}; /* namespace demoapp */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_char$f$p$42$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_parse_token$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$text$$string$$serialize$n$$str_decode$f83$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
static inline pxcrt::bt_bool string_parse_token$f$p$meta$n$$bool$t$q$text$$string$$serialize$n$$parse_bool$f87$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > to_string$f$p$io$$errno$n$$errno_t$s$r$(const int& x$);
static inline void serialize_to_string$f$p$io$$errno$n$$errno_t$s$r$(const int& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$io$$errno$n$$errno_t$s$r$(const int& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_double static_cast$f$p$meta$n$$double$t$q$io$$time$n$$time_t$s$r$(const std::time_t& x$);
static inline pxcrt::bt_double static_cast$f$p$meta$n$$double$t$q$io$$time$n$$suseconds_t$s$r$(const pxcrt::suseconds_t& x$);
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline pxcrt::bt_size_t union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$meta$n$$size_t$t$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$& x$);
}; /* namespace operator */
namespace io$n { namespace file$n { 
static inline ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ io_open$f$p$m$ll$p$m$ll$p$io$n$$io$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$io$$file$n$$open_flags_t$s$q$0$li$r$$r$$r$(const pxcrt::io& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const int& a2$);
};}; /* namespace io::file */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > make_ptr$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$m$ll$r$();
static inline pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > box_pointer$f$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$();
}; /* namespace pointer */
namespace operator$n { 
static inline pxcrt::file_st union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$io$$file$n$$file_st$s$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$& x$);
}; /* namespace operator */
namespace io$n { namespace file$n { 
static inline ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ io_open$f$p$m$ll$p$m$ll$p$io$n$$io$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$io$$file$n$$open_flags_t$s$q$0$li$r$$q$m$ll$p$io$$file$n$$mode_t$s$q$0$li$r$$r$$r$(const pxcrt::io& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const int& a2$, const pxcrt::mode_t & a3$);
};}; /* namespace io::file */
namespace operator$n { 
static inline pxcrt::pid_t union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$io$$process$n$$pid_t$s$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$& x$);
static inline ::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$& x$);
}; /* namespace operator */
namespace numeric$n { namespace cast$n { 
static inline int static_cast$f$p$io$$process$n$$status_t$s$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$);
};}; /* namespace numeric::cast */
namespace thread$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ make_thread_ptr$f$p$thread$$queue$n$$queue_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$);
}; /* namespace thread */
namespace pointer$n { 
static inline pxcrt::rcptr< ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ > make_ptr$f$p$thread$n$$thread$s$p$thread$$queue$n$$queue_thread_main$f$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& a0$);
static inline pxcrt::rcptr< ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ > box_pointer$f$p$pxcrt$$ptr$p$thread$n$$thread$s$p$thread$$queue$n$$queue_thread_main$f$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& a0$);
static inline pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > make_tptr$f$p$thread$$queue$n$$task_queue_shared$s$q$m$ll$r$();
static inline pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > box_pointer$f$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$m$ll$r$();
}; /* namespace pointer */
namespace operator$n { 
static inline ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ union_field$f$p$some$ls$q$algebraic$n$$option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$$r$(const ::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$& x$);
}; /* namespace operator */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > to_string$f$p$meta$n$$unit$t$r$(const pxcrt::bt_unit& x$);
static inline void serialize_to_string$f$p$meta$n$$unit$t$r$(const pxcrt::bt_unit& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$unit$t$r$(const pxcrt::bt_unit& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace ordered$n { 
static inline pxcrt::bt_int compare_strict_weak$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$);
}; /* namespace ordered */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$);
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline pxcrt::rawptr< pxcrt::bt_uchar >::type add$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$r$(const pxcrt::rawptr< pxcrt::bt_uchar >::type& x$, const pxcrt::bt_size_t& y$);
static inline pxcrt::rawptr< pxcrt::bt_uchar >::type binop$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(const pxcrt::rawptr< pxcrt::bt_uchar >::type& x$, const pxcrt::bt_size_t& y$);
}; /* namespace operator */
namespace SDL2$n { namespace api_base$n { 
static inline pxcrt::bt_int SDL_Enum___to$f$p$meta$n$$int$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(int x$);
};}; /* namespace SDL2::api_base */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(const int& x$);
};}; /* namespace numeric::cast */
namespace ordered$n { 
static inline pxcrt::bt_size_t min$f$p$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$, const pxcrt::bt_size_t& y$);
}; /* namespace ordered */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$size_t$t$q$10$li$r$(pxcrt::bt_size_t v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$);
};}; /* namespace numeric::cast */
namespace container$n { namespace array$n { 
static inline void reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_slice< pxcrt::bt_uchar >& x$);
};}; /* namespace container::array */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$);
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$);
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > make_ptr$f$p$pgl3d$$wfobj$n$$wfobject$s$q$m$ll$r$();
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$wfobj$n$$wfobject$s$r$$q$m$ll$r$();
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > make_ptr$f$p$pgl3d$$wfobj$n$$wfgroup$s$q$m$ll$r$();
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$wfobj$n$$wfgroup$s$r$$q$m$ll$r$();
}; /* namespace pointer */
namespace container$n { namespace array$n { 
static inline void split_foreach$f$p$pgl3d$$wfobj$n$$parse_line$f4$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > const& _0$up, ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& _1$up, pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > const& _2$up, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$);
static inline pxcrt::bt_size_t find_mapped$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, pxcrt::bt_size_t k$, const pxcrt::bt_uchar& x$);
static inline ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,3LL > make_farray_split$f$p$3$li$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$);
};}; /* namespace container::array */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_float from_string$f$p$meta$n$$float$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
static inline pxcrt::bt_float deserialize_from_string$f$p$meta$n$$float$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline pxcrt::bt_float deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_float decimal_to_fp$f$p$meta$n$$float$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_float string_parse_token$f$p$meta$n$$float$t$q$text$$string$$positional$n$$decimal_to_fp$f$p$meta$n$$float$t$r$$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
static inline pxcrt::bt_uint from_string$f$p$meta$n$$uint$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
static inline pxcrt::bt_uint deserialize_from_string$f$p$meta$n$$uint$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline pxcrt::bt_uint deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uint$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_uint positional_to_integral$f$p$meta$n$$uint$t$q$10$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
static inline pxcrt::bt_uint positional_to_integral_internal$f$p$meta$n$$uint$t$q$10$li$q$1$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
static inline pxcrt::bt_bool uchar_to_integral$f$p$meta$n$$uint$t$q$10$li$r$(pxcrt::bt_uchar v$, pxcrt::bt_uint& dig_r$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$);
};}; /* namespace numeric::cast */
namespace numeric$n { namespace limit$n { 
static inline pxcrt::bt_uint lowest$f$p$meta$n$$uint$t$r$();
};}; /* namespace numeric::limit */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_uint positional_to_integral_internal$f$p$meta$n$$uint$t$q$10$li$q$0$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace limit$n { 
static inline pxcrt::bt_uint highest$f$p$meta$n$$uint$t$r$();
};}; /* namespace numeric::limit */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_uint string_parse_token$f$p$meta$n$$uint$t$q$text$$string$$positional$n$$positional_to_integral$f$p$meta$n$$uint$t$q$10$li$r$$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
};};}; /* namespace text::string::serialize */
namespace container$n { namespace array$n { 
static inline void split_foreach$f$p$pgl3d$$wfobj$n$$parse_token$f8$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& _0$up, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$);
};}; /* namespace container::array */
namespace operator$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$& x$);
}; /* namespace operator */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$uint$t$r$(pxcrt::bt_uint x$);
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$);
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline void adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
static inline void binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$add$ls$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
}; /* namespace operator */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$size_t$t$r$(pxcrt::bt_size_t x$);
};}; /* namespace pgl3d::glgeometry */
namespace operator$n { 
static inline void diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline void binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$sub$ls$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
}; /* namespace operator */
namespace ordered$n { 
static inline pxcrt::bt_float max$f$p$meta$n$$float$t$r$(const pxcrt::bt_float& x$, const pxcrt::bt_float& y$);
}; /* namespace ordered */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline void reverse$f$p$container$$array$n$$slice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(const ::pxcrt::bt_slice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& x$);
};}; /* namespace container::array */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type div$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
}; /* namespace operator */
namespace pgl3d$n { namespace glgeometry$n { 
static inline void polygon_scale$f$p$container$$array$n$$darrayst$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, pxcrt::bt_float scale$);
};}; /* namespace pgl3d::glgeometry */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$add$ls$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,4LL > make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$4$li$r$(const ::pgl3d$n::glgeometry$n::vertex_attr$s& a0$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a1$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a2$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a3$);
};}; /* namespace container::array */
namespace pgl3d$n { namespace glgeometry$n { 
static inline ::pgl3d$n::glgeometry$n::vertex_attr$s tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$);
};}; /* namespace pgl3d::glgeometry */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type mul$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tmat3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$mul$ls$r$(const pxcrt::glmpx::tmat3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL > make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$3$li$r$(const ::pgl3d$n::glgeometry$n::vertex_attr$s& a0$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a1$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a2$);
};}; /* namespace container::array */
namespace operator$n { 
static inline pxcrt::glmpx::tmat4< pxcrt::bt_float >::type mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tmat4< pxcrt::bt_float >::type binop$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$mul$ls$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec4< pxcrt::bt_float >::type mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec4< pxcrt::bt_float >::type binop$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$q$mul$ls$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type& y$);
static inline void mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& y$);
static inline void binopa$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$mul$ls$r$(pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& y$);
}; /* namespace operator */
namespace numeric$n { namespace cast$n { 
static inline ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type static_cast$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$);
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& x$);
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_strlit& y$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$q$add$ls$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_strlit& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_strlit& y$);
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$);
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline void array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$);
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline void array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$);
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > array___add$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$);
};}; /* namespace container::array */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$GL$$base$n$$GLenum$s$r$(const GLenum& x$);
};}; /* namespace numeric::cast */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const pxcrt::bt_int& a1$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$int$t$r$(const pxcrt::bt_int& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$int$t$q$10$li$r$(pxcrt::bt_int v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$);
};}; /* namespace numeric::cast */
namespace $n {
void glActiveTexture(const GLenum texture$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glActiveTexture$f(const GLenum texture$);
};}; /* namespace GL::compat */
namespace $n {
void glAttachShader(const pxcrt::bt_uint program$, const pxcrt::bt_uint shader$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glAttachShader$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint shader$);
};}; /* namespace GL::compat */
namespace $n {
void glBindAttribLocation(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_char >::type name$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBindAttribLocation$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_char >::type name$);
};}; /* namespace GL::compat */
namespace $n {
void glBindBuffer(const GLenum target$, const pxcrt::bt_uint buffer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBindBuffer$f(const GLenum target$, const pxcrt::bt_uint buffer$);
};}; /* namespace GL::compat */
namespace $n {
void glBindFramebuffer(const GLenum target$, const pxcrt::bt_uint framebuffer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBindFramebuffer$f(const GLenum target$, const pxcrt::bt_uint framebuffer$);
};}; /* namespace GL::compat */
namespace $n {
void glBindRenderbuffer(const GLenum target$, const pxcrt::bt_uint renderbuffer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBindRenderbuffer$f(const GLenum target$, const pxcrt::bt_uint renderbuffer$);
};}; /* namespace GL::compat */
namespace $n {
void glBindTexture(const GLenum target$, const pxcrt::bt_uint texture$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBindTexture$f(const GLenum target$, const pxcrt::bt_uint texture$);
};}; /* namespace GL::compat */
namespace $n {
void glBlendColor(const pxcrt::bt_float red$, const pxcrt::bt_float green$, const pxcrt::bt_float blue$, const pxcrt::bt_float alpha$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBlendColor$f(const pxcrt::bt_float red$, const pxcrt::bt_float green$, const pxcrt::bt_float blue$, const pxcrt::bt_float alpha$);
};}; /* namespace GL::compat */
namespace $n {
void glBlendEquation(const GLenum mode$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBlendEquation$f(const GLenum mode$);
};}; /* namespace GL::compat */
namespace $n {
void glBlendEquationSeparate(const GLenum modeRGB$, const GLenum modeAlpha$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBlendEquationSeparate$f(const GLenum modeRGB$, const GLenum modeAlpha$);
};}; /* namespace GL::compat */
namespace $n {
void glBlendFunc(const GLenum sfactor$, const GLenum dfactor$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBlendFunc$f(const GLenum sfactor$, const GLenum dfactor$);
};}; /* namespace GL::compat */
namespace $n {
void glBlendFuncSeparate(const GLenum sfactorRGB$, const GLenum dfactorRGB$, const GLenum sfactorAlpha$, const GLenum dfactorAlpha$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBlendFuncSeparate$f(const GLenum sfactorRGB$, const GLenum dfactorRGB$, const GLenum sfactorAlpha$, const GLenum dfactorAlpha$);
};}; /* namespace GL::compat */
namespace $n {
void glBufferData(const GLenum target$, const GLsizeiptr size$, const pxcrt::crawptr< void >::type data$, const GLenum usage$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBufferData$f(const GLenum target$, const GLsizeiptr size$, const pxcrt::crawptr< void >::type data$, const GLenum usage$);
};}; /* namespace GL::compat */
namespace $n {
void glBufferSubData(const GLenum target$, const GLintptr offset$, const GLsizeiptr size$, const pxcrt::crawptr< void >::type data$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glBufferSubData$f(const GLenum target$, const GLintptr offset$, const GLsizeiptr size$, const pxcrt::crawptr< void >::type data$);
};}; /* namespace GL::compat */
namespace $n {
GLenum glCheckFramebufferStatus(const GLenum target$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
GLenum glCheckFramebufferStatus$f(const GLenum target$);
};}; /* namespace GL::compat */
namespace $n {
void glClear(const GLbitfield mask$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glClear$f(const GLbitfield mask$);
};}; /* namespace GL::compat */
namespace $n {
void glClearColor(const pxcrt::bt_float red$, const pxcrt::bt_float green$, const pxcrt::bt_float blue$, const pxcrt::bt_float alpha$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glClearColor$f(const pxcrt::bt_float red$, const pxcrt::bt_float green$, const pxcrt::bt_float blue$, const pxcrt::bt_float alpha$);
};}; /* namespace GL::compat */
namespace $n {
void glClearDepthf(const pxcrt::bt_float d$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glClearDepthf$f(const pxcrt::bt_float d$);
};}; /* namespace GL::compat */
namespace $n {
void glClearStencil(const pxcrt::bt_int s$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glClearStencil$f(const pxcrt::bt_int s$);
};}; /* namespace GL::compat */
namespace $n {
void glColorMask(const pxcrt::bt_uchar red$, const pxcrt::bt_uchar green$, const pxcrt::bt_uchar blue$, const pxcrt::bt_uchar alpha$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glColorMask$f(const pxcrt::bt_uchar red$, const pxcrt::bt_uchar green$, const pxcrt::bt_uchar blue$, const pxcrt::bt_uchar alpha$);
};}; /* namespace GL::compat */
namespace $n {
void glCompileShader(const pxcrt::bt_uint shader$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glCompileShader$f(const pxcrt::bt_uint shader$);
};}; /* namespace GL::compat */
namespace $n {
void glCompressedTexImage2D(const GLenum target$, const pxcrt::bt_int level$, const GLenum internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$, const pxcrt::bt_int imageSize$, const pxcrt::crawptr< void >::type data$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glCompressedTexImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const GLenum internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$, const pxcrt::bt_int imageSize$, const pxcrt::crawptr< void >::type data$);
};}; /* namespace GL::compat */
namespace $n {
void glCompressedTexSubImage2D(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const pxcrt::bt_int imageSize$, const pxcrt::crawptr< void >::type data$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glCompressedTexSubImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const pxcrt::bt_int imageSize$, const pxcrt::crawptr< void >::type data$);
};}; /* namespace GL::compat */
namespace $n {
void glCopyTexImage2D(const GLenum target$, const pxcrt::bt_int level$, const GLenum internalformat$, const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glCopyTexImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const GLenum internalformat$, const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$);
};}; /* namespace GL::compat */
namespace $n {
void glCopyTexSubImage2D(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glCopyTexSubImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uint glCreateProgram();
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uint glCreateProgram$f();
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uint glCreateShader(const GLenum type$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uint glCreateShader$f(const GLenum type$);
};}; /* namespace GL::compat */
namespace $n {
void glCullFace(const GLenum mode$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glCullFace$f(const GLenum mode$);
};}; /* namespace GL::compat */
namespace $n {
void glDeleteBuffers(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type buffers$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDeleteBuffers$f(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type buffers$);
};}; /* namespace GL::compat */
namespace $n {
void glDeleteFramebuffers(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type framebuffers$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDeleteFramebuffers$f(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type framebuffers$);
};}; /* namespace GL::compat */
namespace $n {
void glDeleteProgram(const pxcrt::bt_uint program$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDeleteProgram$f(const pxcrt::bt_uint program$);
};}; /* namespace GL::compat */
namespace $n {
void glDeleteRenderbuffers(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type renderbuffers$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDeleteRenderbuffers$f(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type renderbuffers$);
};}; /* namespace GL::compat */
namespace $n {
void glDeleteShader(const pxcrt::bt_uint shader$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDeleteShader$f(const pxcrt::bt_uint shader$);
};}; /* namespace GL::compat */
namespace $n {
void glDeleteTextures(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type textures$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDeleteTextures$f(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type textures$);
};}; /* namespace GL::compat */
namespace $n {
void glDepthFunc(const GLenum func$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDepthFunc$f(const GLenum func$);
};}; /* namespace GL::compat */
namespace $n {
void glDepthMask(const pxcrt::bt_uchar flag$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDepthMask$f(const pxcrt::bt_uchar flag$);
};}; /* namespace GL::compat */
namespace $n {
void glDepthRangef(const pxcrt::bt_float n$, const pxcrt::bt_float f$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDepthRangef$f(const pxcrt::bt_float n$, const pxcrt::bt_float f$);
};}; /* namespace GL::compat */
namespace $n {
void glDetachShader(const pxcrt::bt_uint program$, const pxcrt::bt_uint shader$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDetachShader$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint shader$);
};}; /* namespace GL::compat */
namespace $n {
void glDisable(const GLenum cap$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDisable$f(const GLenum cap$);
};}; /* namespace GL::compat */
namespace $n {
void glDisableVertexAttribArray(const pxcrt::bt_uint index$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDisableVertexAttribArray$f(const pxcrt::bt_uint index$);
};}; /* namespace GL::compat */
namespace $n {
void glDrawArrays(const GLenum mode$, const pxcrt::bt_int first$, const pxcrt::bt_int count$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDrawArrays$f(const GLenum mode$, const pxcrt::bt_int first$, const pxcrt::bt_int count$);
};}; /* namespace GL::compat */
namespace $n {
void glDrawElements(const GLenum mode$, const pxcrt::bt_int count$, const GLenum type$, const pxcrt::crawptr< void >::type indices$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glDrawElements$f(const GLenum mode$, const pxcrt::bt_int count$, const GLenum type$, const pxcrt::crawptr< void >::type indices$);
};}; /* namespace GL::compat */
namespace $n {
void glEnable(const GLenum cap$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glEnable$f(const GLenum cap$);
};}; /* namespace GL::compat */
namespace $n {
void glEnableVertexAttribArray(const pxcrt::bt_uint index$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glEnableVertexAttribArray$f(const pxcrt::bt_uint index$);
};}; /* namespace GL::compat */
namespace $n {
void glFinish();
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glFinish$f();
};}; /* namespace GL::compat */
namespace $n {
void glFlush();
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glFlush$f();
};}; /* namespace GL::compat */
namespace $n {
void glFramebufferRenderbuffer(const GLenum target$, const GLenum attachment$, const GLenum renderbuffertarget$, const pxcrt::bt_uint renderbuffer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glFramebufferRenderbuffer$f(const GLenum target$, const GLenum attachment$, const GLenum renderbuffertarget$, const pxcrt::bt_uint renderbuffer$);
};}; /* namespace GL::compat */
namespace $n {
void glFramebufferTexture2D(const GLenum target$, const GLenum attachment$, const GLenum textarget$, const pxcrt::bt_uint texture$, const pxcrt::bt_int level$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glFramebufferTexture2D$f(const GLenum target$, const GLenum attachment$, const GLenum textarget$, const pxcrt::bt_uint texture$, const pxcrt::bt_int level$);
};}; /* namespace GL::compat */
namespace $n {
void glFrontFace(const GLenum mode$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glFrontFace$f(const GLenum mode$);
};}; /* namespace GL::compat */
namespace $n {
void glGenBuffers(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type buffers$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGenBuffers$f(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type buffers$);
};}; /* namespace GL::compat */
namespace $n {
void glGenerateMipmap(const GLenum target$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGenerateMipmap$f(const GLenum target$);
};}; /* namespace GL::compat */
namespace $n {
void glGenFramebuffers(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type framebuffers$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGenFramebuffers$f(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type framebuffers$);
};}; /* namespace GL::compat */
namespace $n {
void glGenRenderbuffers(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type renderbuffers$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGenRenderbuffers$f(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type renderbuffers$);
};}; /* namespace GL::compat */
namespace $n {
void glGenTextures(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type textures$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGenTextures$f(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type textures$);
};}; /* namespace GL::compat */
namespace $n {
void glGetActiveAttrib(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_int >::type size$, const pxcrt::rawptr< GLenum >::type type$, const pxcrt::rawptr< pxcrt::bt_char >::type name$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetActiveAttrib$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_int >::type size$, const pxcrt::rawptr< GLenum >::type type$, const pxcrt::rawptr< pxcrt::bt_char >::type name$);
};}; /* namespace GL::compat */
namespace $n {
void glGetActiveUniform(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_int >::type size$, const pxcrt::rawptr< GLenum >::type type$, const pxcrt::rawptr< pxcrt::bt_char >::type name$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetActiveUniform$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_int >::type size$, const pxcrt::rawptr< GLenum >::type type$, const pxcrt::rawptr< pxcrt::bt_char >::type name$);
};}; /* namespace GL::compat */
namespace $n {
void glGetAttachedShaders(const pxcrt::bt_uint program$, const pxcrt::bt_int maxCount$, const pxcrt::rawptr< pxcrt::bt_int >::type count$, const pxcrt::rawptr< pxcrt::bt_uint >::type shaders$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetAttachedShaders$f(const pxcrt::bt_uint program$, const pxcrt::bt_int maxCount$, const pxcrt::rawptr< pxcrt::bt_int >::type count$, const pxcrt::rawptr< pxcrt::bt_uint >::type shaders$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_int glGetAttribLocation(const pxcrt::bt_uint program$, const pxcrt::crawptr< pxcrt::bt_char >::type name$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_int glGetAttribLocation$f(const pxcrt::bt_uint program$, const pxcrt::crawptr< pxcrt::bt_char >::type name$);
};}; /* namespace GL::compat */
namespace $n {
void glGetBooleanv(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_uchar >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetBooleanv$f(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_uchar >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetBufferParameteriv(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetBufferParameteriv$f(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
GLenum glGetError();
}; /* namespace */
namespace GL$n { namespace compat$n { 
GLenum glGetError$f();
};}; /* namespace GL::compat */
namespace $n {
void glGetFloatv(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetFloatv$f(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetFramebufferAttachmentParameteriv(const GLenum target$, const GLenum attachment$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetFramebufferAttachmentParameteriv$f(const GLenum target$, const GLenum attachment$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetIntegerv(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetIntegerv$f(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetProgramiv(const pxcrt::bt_uint program$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetProgramiv$f(const pxcrt::bt_uint program$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetProgramInfoLog(const pxcrt::bt_uint program$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type infoLog$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetProgramInfoLog$f(const pxcrt::bt_uint program$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type infoLog$);
};}; /* namespace GL::compat */
namespace $n {
void glGetRenderbufferParameteriv(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetRenderbufferParameteriv$f(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetShaderiv(const pxcrt::bt_uint shader$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetShaderiv$f(const pxcrt::bt_uint shader$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetShaderInfoLog(const pxcrt::bt_uint shader$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type infoLog$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetShaderInfoLog$f(const pxcrt::bt_uint shader$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type infoLog$);
};}; /* namespace GL::compat */
namespace $n {
void glGetShaderPrecisionFormat(const GLenum shadertype$, const GLenum precisiontype$, const pxcrt::rawptr< pxcrt::bt_int >::type range$, const pxcrt::rawptr< pxcrt::bt_int >::type precision$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetShaderPrecisionFormat$f(const GLenum shadertype$, const GLenum precisiontype$, const pxcrt::rawptr< pxcrt::bt_int >::type range$, const pxcrt::rawptr< pxcrt::bt_int >::type precision$);
};}; /* namespace GL::compat */
namespace $n {
void glGetShaderSource(const pxcrt::bt_uint shader$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type source$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetShaderSource$f(const pxcrt::bt_uint shader$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type source$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::crawptr< pxcrt::bt_uchar >::type glGetString(const GLenum name$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::crawptr< pxcrt::bt_uchar >::type glGetString$f(const GLenum name$);
};}; /* namespace GL::compat */
namespace $n {
void glGetTexParameterfv(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetTexParameterfv$f(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetTexParameteriv(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetTexParameteriv$f(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetUniformfv(const pxcrt::bt_uint program$, const pxcrt::bt_int location$, const pxcrt::rawptr< pxcrt::bt_float >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetUniformfv$f(const pxcrt::bt_uint program$, const pxcrt::bt_int location$, const pxcrt::rawptr< pxcrt::bt_float >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetUniformiv(const pxcrt::bt_uint program$, const pxcrt::bt_int location$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetUniformiv$f(const pxcrt::bt_uint program$, const pxcrt::bt_int location$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_int glGetUniformLocation(const pxcrt::bt_uint program$, const pxcrt::crawptr< pxcrt::bt_char >::type name$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_int glGetUniformLocation$f(const pxcrt::bt_uint program$, const pxcrt::crawptr< pxcrt::bt_char >::type name$);
};}; /* namespace GL::compat */
namespace $n {
void glGetVertexAttribfv(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetVertexAttribfv$f(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetVertexAttribiv(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetVertexAttribiv$f(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glGetVertexAttribPointerv(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::rawptr< void >::type >::type pointer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glGetVertexAttribPointerv$f(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::rawptr< void >::type >::type pointer$);
};}; /* namespace GL::compat */
namespace $n {
void glHint(const GLenum target$, const GLenum mode$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glHint$f(const GLenum target$, const GLenum mode$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uchar glIsBuffer(const pxcrt::bt_uint buffer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uchar glIsBuffer$f(const pxcrt::bt_uint buffer$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uchar glIsEnabled(const GLenum cap$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uchar glIsEnabled$f(const GLenum cap$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uchar glIsFramebuffer(const pxcrt::bt_uint framebuffer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uchar glIsFramebuffer$f(const pxcrt::bt_uint framebuffer$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uchar glIsProgram(const pxcrt::bt_uint program$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uchar glIsProgram$f(const pxcrt::bt_uint program$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uchar glIsRenderbuffer(const pxcrt::bt_uint renderbuffer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uchar glIsRenderbuffer$f(const pxcrt::bt_uint renderbuffer$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uchar glIsShader(const pxcrt::bt_uint shader$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uchar glIsShader$f(const pxcrt::bt_uint shader$);
};}; /* namespace GL::compat */
namespace $n {
pxcrt::bt_uchar glIsTexture(const pxcrt::bt_uint texture$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
pxcrt::bt_uchar glIsTexture$f(const pxcrt::bt_uint texture$);
};}; /* namespace GL::compat */
namespace $n {
void glLineWidth(const pxcrt::bt_float width$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glLineWidth$f(const pxcrt::bt_float width$);
};}; /* namespace GL::compat */
namespace $n {
void glLinkProgram(const pxcrt::bt_uint program$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glLinkProgram$f(const pxcrt::bt_uint program$);
};}; /* namespace GL::compat */
namespace $n {
void glPixelStorei(const GLenum pname$, const pxcrt::bt_int param$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glPixelStorei$f(const GLenum pname$, const pxcrt::bt_int param$);
};}; /* namespace GL::compat */
namespace $n {
void glPolygonOffset(const pxcrt::bt_float factor$, const pxcrt::bt_float units$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glPolygonOffset$f(const pxcrt::bt_float factor$, const pxcrt::bt_float units$);
};}; /* namespace GL::compat */
namespace $n {
void glReadPixels(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const GLenum type$, const pxcrt::rawptr< void >::type pixels$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glReadPixels$f(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const GLenum type$, const pxcrt::rawptr< void >::type pixels$);
};}; /* namespace GL::compat */
namespace $n {
void glReleaseShaderCompiler();
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glReleaseShaderCompiler$f();
};}; /* namespace GL::compat */
namespace $n {
void glRenderbufferStorage(const GLenum target$, const GLenum internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glRenderbufferStorage$f(const GLenum target$, const GLenum internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$);
};}; /* namespace GL::compat */
namespace $n {
void glSampleCoverage(const pxcrt::bt_float value$, const pxcrt::bt_uchar invert$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glSampleCoverage$f(const pxcrt::bt_float value$, const pxcrt::bt_uchar invert$);
};}; /* namespace GL::compat */
namespace $n {
void glScissor(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glScissor$f(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$);
};}; /* namespace GL::compat */
namespace $n {
void glShaderBinary(const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_uint >::type shaders$, const GLenum binaryformat$, const pxcrt::crawptr< void >::type binary$, const pxcrt::bt_int length$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glShaderBinary$f(const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_uint >::type shaders$, const GLenum binaryformat$, const pxcrt::crawptr< void >::type binary$, const pxcrt::bt_int length$);
};}; /* namespace GL::compat */
namespace $n {
void glShaderSource(const pxcrt::bt_uint shader$, const pxcrt::bt_int count$, const pxcrt::rawptr< pxcrt::crawptr< pxcrt::bt_char >::type >::type string$, const pxcrt::crawptr< pxcrt::bt_int >::type length$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glShaderSource$f(const pxcrt::bt_uint shader$, const pxcrt::bt_int count$, const pxcrt::rawptr< pxcrt::crawptr< pxcrt::bt_char >::type >::type string$, const pxcrt::crawptr< pxcrt::bt_int >::type length$);
};}; /* namespace GL::compat */
namespace $n {
void glStencilFunc(const GLenum func$, const pxcrt::bt_int ref$, const pxcrt::bt_uint mask$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glStencilFunc$f(const GLenum func$, const pxcrt::bt_int ref$, const pxcrt::bt_uint mask$);
};}; /* namespace GL::compat */
namespace $n {
void glStencilFuncSeparate(const GLenum face$, const GLenum func$, const pxcrt::bt_int ref$, const pxcrt::bt_uint mask$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glStencilFuncSeparate$f(const GLenum face$, const GLenum func$, const pxcrt::bt_int ref$, const pxcrt::bt_uint mask$);
};}; /* namespace GL::compat */
namespace $n {
void glStencilMask(const pxcrt::bt_uint mask$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glStencilMask$f(const pxcrt::bt_uint mask$);
};}; /* namespace GL::compat */
namespace $n {
void glStencilMaskSeparate(const GLenum face$, const pxcrt::bt_uint mask$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glStencilMaskSeparate$f(const GLenum face$, const pxcrt::bt_uint mask$);
};}; /* namespace GL::compat */
namespace $n {
void glStencilOp(const GLenum fail$, const GLenum zfail$, const GLenum zpass$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glStencilOp$f(const GLenum fail$, const GLenum zfail$, const GLenum zpass$);
};}; /* namespace GL::compat */
namespace $n {
void glStencilOpSeparate(const GLenum face$, const GLenum sfail$, const GLenum dpfail$, const GLenum dppass$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glStencilOpSeparate$f(const GLenum face$, const GLenum sfail$, const GLenum dpfail$, const GLenum dppass$);
};}; /* namespace GL::compat */
namespace $n {
void glTexImage2D(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$, const GLenum format$, const GLenum type$, const pxcrt::crawptr< void >::type pixels$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glTexImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$, const GLenum format$, const GLenum type$, const pxcrt::crawptr< void >::type pixels$);
};}; /* namespace GL::compat */
namespace $n {
void glTexParameterf(const GLenum target$, const GLenum pname$, const pxcrt::bt_float param$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glTexParameterf$f(const GLenum target$, const GLenum pname$, const pxcrt::bt_float param$);
};}; /* namespace GL::compat */
namespace $n {
void glTexParameterfv(const GLenum target$, const GLenum pname$, const pxcrt::crawptr< pxcrt::bt_float >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glTexParameterfv$f(const GLenum target$, const GLenum pname$, const pxcrt::crawptr< pxcrt::bt_float >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glTexParameteri(const GLenum target$, const GLenum pname$, const pxcrt::bt_int param$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glTexParameteri$f(const GLenum target$, const GLenum pname$, const pxcrt::bt_int param$);
};}; /* namespace GL::compat */
namespace $n {
void glTexParameteriv(const GLenum target$, const GLenum pname$, const pxcrt::crawptr< pxcrt::bt_int >::type params$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glTexParameteriv$f(const GLenum target$, const GLenum pname$, const pxcrt::crawptr< pxcrt::bt_int >::type params$);
};}; /* namespace GL::compat */
namespace $n {
void glTexSubImage2D(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const GLenum type$, const pxcrt::crawptr< void >::type pixels$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glTexSubImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const GLenum type$, const pxcrt::crawptr< void >::type pixels$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform1f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform1f$f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform1fv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform1fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform1i(const pxcrt::bt_int location$, const pxcrt::bt_int v0$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform1i$f(const pxcrt::bt_int location$, const pxcrt::bt_int v0$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform1iv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform1iv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform2f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform2f$f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform2fv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform2fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform2i(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform2i$f(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform2iv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform2iv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform3f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$, const pxcrt::bt_float v2$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform3f$f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$, const pxcrt::bt_float v2$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform3fv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform3fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform3i(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$, const pxcrt::bt_int v2$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform3i$f(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$, const pxcrt::bt_int v2$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform3iv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform3iv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform4f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$, const pxcrt::bt_float v2$, const pxcrt::bt_float v3$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform4f$f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$, const pxcrt::bt_float v2$, const pxcrt::bt_float v3$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform4fv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform4fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform4i(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$, const pxcrt::bt_int v2$, const pxcrt::bt_int v3$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform4i$f(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$, const pxcrt::bt_int v2$, const pxcrt::bt_int v3$);
};}; /* namespace GL::compat */
namespace $n {
void glUniform4iv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniform4iv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniformMatrix2fv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniformMatrix2fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniformMatrix3fv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniformMatrix3fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUniformMatrix4fv(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUniformMatrix4fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$);
};}; /* namespace GL::compat */
namespace $n {
void glUseProgram(const pxcrt::bt_uint program$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glUseProgram$f(const pxcrt::bt_uint program$);
};}; /* namespace GL::compat */
namespace $n {
void glValidateProgram(const pxcrt::bt_uint program$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glValidateProgram$f(const pxcrt::bt_uint program$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttrib1f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttrib1f$f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttrib1fv(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttrib1fv$f(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttrib2f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttrib2f$f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttrib2fv(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttrib2fv$f(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttrib3f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$, const pxcrt::bt_float z$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttrib3f$f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$, const pxcrt::bt_float z$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttrib3fv(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttrib3fv$f(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttrib4f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$, const pxcrt::bt_float z$, const pxcrt::bt_float w$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttrib4f$f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$, const pxcrt::bt_float z$, const pxcrt::bt_float w$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttrib4fv(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttrib4fv$f(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$);
};}; /* namespace GL::compat */
namespace $n {
void glVertexAttribPointer(const pxcrt::bt_uint index$, const pxcrt::bt_int size$, const GLenum type$, const pxcrt::bt_uchar normalized$, const pxcrt::bt_int stride$, const pxcrt::crawptr< void >::type pointer$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glVertexAttribPointer$f(const pxcrt::bt_uint index$, const pxcrt::bt_int size$, const GLenum type$, const pxcrt::bt_uchar normalized$, const pxcrt::bt_int stride$, const pxcrt::crawptr< void >::type pointer$);
};}; /* namespace GL::compat */
namespace $n {
void glViewport(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$);
}; /* namespace */
namespace GL$n { namespace compat$n { 
void glViewport$f(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$);
};}; /* namespace GL::compat */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< pxcrt::crawptr< pxcrt::bt_char >::type,1LL > make_farray_func$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$1$li$r$(const pxcrt::crawptr< pxcrt::bt_char >::type& a0$);
};}; /* namespace container::array */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$);
};}; /* namespace numeric::cast */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< pxcrt::bt_int,1LL > make_farray_func$f$p$meta$n$$int$t$q$1$li$r$(const pxcrt::bt_int& a0$);
};}; /* namespace container::array */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a3$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a3$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(const pxcrt::bt_int& a0$, const pxcrt::bt_int& a1$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a2$);
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$);
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a2$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a2$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$uint$t$q$10$li$r$(pxcrt::bt_uint v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$);
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$);
};};}; /* namespace text::string::split */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > make_ptr$f$p$pgl3d$$glvertex$n$$vertices$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_set$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const pxcrt::bt_size_t& a0$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_set$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const pxcrt::bt_size_t& a0$);
}; /* namespace pointer */
namespace numeric$n { namespace cast$n { 
static inline GLsizeiptr static_cast$f$p$GL$$base$n$$GLsizeiptr$s$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$);
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > make_ptr$f$p$pgl3d$$glbuffer$n$$async_buffer$s$q$m$ll$r$();
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$async_buffer$s$r$$q$m$ll$r$();
}; /* namespace pointer */
namespace operator$n { 
static inline pxcrt::rawptr< pxcrt::bt_float >::type add$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$r$(const pxcrt::rawptr< pxcrt::bt_float >::type& x$, const pxcrt::bt_size_t& y$);
static inline pxcrt::rawptr< pxcrt::bt_float >::type binop$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(const pxcrt::rawptr< pxcrt::bt_float >::type& x$, const pxcrt::bt_size_t& y$);
}; /* namespace operator */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > init_triangles_shader$f$p$1$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::crawptr< pxcrt::bt_char >::type strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_strlit& x$);
};}; /* namespace pointer::raw */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_strlit& a1$, const pxcrt::bt_int& a2$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_strlit& a1$, const pxcrt::bt_int& a2$);
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glshader$n { 
static inline void set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(pxcrt::bt_int loc$, const ::pxcrt::bt_cslice< pxcrt::bt_float >& value$, pxcrt::bt_size_t offset$, pxcrt::bt_int cnt$);
};}; /* namespace pgl3d::glshader */
namespace operator$n { 
static inline pxcrt::crawptr< pxcrt::bt_float >::type add$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$r$(const pxcrt::crawptr< pxcrt::bt_float >::type& x$, const pxcrt::bt_size_t& y$);
static inline pxcrt::crawptr< pxcrt::bt_float >::type binop$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(const pxcrt::crawptr< pxcrt::bt_float >::type& x$, const pxcrt::bt_size_t& y$);
}; /* namespace operator */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$);
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > init_zprepass_shader$f$p$1$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$);
};}; /* namespace pgl3d::drawer */
namespace operator$n { 
static inline void adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$);
static inline void binopa$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$);
static inline void adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$);
static inline void binopa$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline void array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$);
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$);
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$);
};}; /* namespace container::array */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > init_shadowmap_shader$f$p$1$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > to_string$f$p$meta$n$$int$t$r$(const pxcrt::bt_int& x$);
};};}; /* namespace text::string::serialize */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_triangles$f$r$();
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$);
};}; /* namespace pgl3d::drawer */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(const pxcrt::bt_long& x$);
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(const pxcrt::bt_size_t& a0$, pxcrt::bt_bool& a1$, pxcrt::bt_bool& a2$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_buffer$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(const pxcrt::bt_size_t& a0$, pxcrt::bt_bool& a1$, pxcrt::bt_bool& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_polygon_filler$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
static inline void dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
static inline void dgf_fill_tattr_internal$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
};}; /* namespace pgl3d::drawer */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type minus$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type unaryop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$minus$ls$q$m$lm$p$t$r$meta$$family$n$$is_numeric_family$a$p$$n$$t$x1$q$meta$n$$family$s$p$$n$$t$x1$r$$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$);
}; /* namespace operator */
namespace ordered$n { 
static inline pxcrt::bt_float min$f$p$meta$n$$float$t$r$(const pxcrt::bt_float& x$, const pxcrt::bt_float& y$);
}; /* namespace ordered */
namespace operator$n { 
static inline void mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline void binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
}; /* namespace operator */
namespace pgl3d$n { namespace glvertex$n { 
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& vals$19, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$);
static inline pxcrt::bt_size_t ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$);
static inline pxcrt::bt_size_t ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type cross_one$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s > const& _0$up, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& _1$up, pxcrt::bt_size_t i$);
static inline pxcrt::bt_bool removable$f39$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(pxcrt::bt_size_t& i$38$pgl3d$$glvertex$ns1, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& cross_sum$31$pgl3d$$glvertex$ns1, ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s > const& _0$up, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& _1$up);
static inline void push_one$f39$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(pxcrt::bt_size_t& i$38$pgl3d$$glvertex$ns1, ::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1);
};}; /* namespace pgl3d::glvertex */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$long$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_long& a1$, const pxcrt::bt_size_t& a2$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$long$t$r$(const pxcrt::bt_long& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$long$t$r$(const pxcrt::bt_long& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$long$t$q$10$li$r$(pxcrt::bt_long v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$long$t$r$(const pxcrt::bt_long& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glvertex$n { 
static inline void push_float$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_vertex_attributes$s& v$);
static inline void push_float$f$p$meta$n$$float$t$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const pxcrt::bt_float& v$);
static inline void push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& v$);
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& a3$, const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& a4$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& a3$, const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& a4$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_char$f$p$123$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$);
static inline void string_append_char$f$p$44$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const ::pgl3d$n::drawer$n::triangles_vertex_attributes$s& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_noesc$f$p$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_strlit& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(const pxcrt::bt_float& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void fp_to_decimal$f$p$meta$n$$float$t$r$(pxcrt::bt_float x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_char$f$p$125$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$);
static inline void serialize_to_string$f$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
}; /* namespace pointer */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< pxcrt::bt_float,4LL > make_farray_func$f$p$meta$n$$float$t$q$4$li$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_float& a2$, const pxcrt::bt_float& a3$);
};}; /* namespace container::array */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > init_triangles_shader$f$p$0$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > init_zprepass_shader$f$p$0$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > init_shadowmap_shader$f$p$0$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$);
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_polygon_filler$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
static inline void dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
static inline void dgf_fill_tattr_internal$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glvertex$n { 
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& vals$19, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$);
static inline pxcrt::bt_size_t ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$);
static inline pxcrt::bt_size_t ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type cross_one$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s > const& _0$up, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& _1$up, pxcrt::bt_size_t i$);
static inline pxcrt::bt_bool removable$f39$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(pxcrt::bt_size_t& i$38$pgl3d$$glvertex$ns1, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& cross_sum$31$pgl3d$$glvertex$ns1, ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s > const& _0$up, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& _1$up);
static inline void push_one$f39$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(pxcrt::bt_size_t& i$38$pgl3d$$glvertex$ns1, ::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1);
static inline void push_float$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s& v$);
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& a3$, const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& a4$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& a3$, const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& a4$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline void set_uniform$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$r$(pxcrt::bt_int loc$, const ::pxcrt::bt_cslice< pxcrt::bt_float >& value$, pxcrt::bt_size_t offset$, pxcrt::bt_int cnt$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_lineparticle$f$r$();
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glvertex$n { 
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$q$0$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1);
static inline void push_float$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s& v$);
static inline void push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& v$);
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$int$t$r$(pxcrt::bt_int x$);
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$);
};}; /* namespace numeric::cast */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< pxcrt::bt_float,2LL > make_farray_func$f$p$meta$n$$float$t$q$2$li$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$);
};}; /* namespace container::array */
namespace ordered$n { 
static inline pxcrt::bt_int max$f$p$meta$n$$int$t$r$(const pxcrt::bt_int& x$, const pxcrt::bt_int& y$);
}; /* namespace ordered */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_particle$f$r$();
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$);
};}; /* namespace pgl3d::drawer */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_default$f$r$();
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline void set_uniform$f$p$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(pxcrt::bt_int loc$, const ::pxcrt::bt_cslice< pxcrt::bt_float >& value$, pxcrt::bt_size_t offset$, pxcrt::bt_int cnt$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_font2$f$r$();
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$);
};}; /* namespace pgl3d::drawer */
namespace ordered$n { 
static inline pxcrt::bt_uint max$f$p$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$, const pxcrt::bt_uint& y$);
}; /* namespace ordered */
namespace pgl3d$n { namespace glvertex$n { 
static inline void push_float$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::font2_vertex_attributes$s& v$);
};}; /* namespace pgl3d::glvertex */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_rect2d$f$r$();
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glvertex$n { 
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$q$0$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1);
static inline void push_float$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s& v$);
static inline void push_float$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::particle_vertex_attributes$s& v$);
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$q$0$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1);
static inline void push_float$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s& v$);
};}; /* namespace pgl3d::glvertex */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$);
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$);
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$);
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline void buffer_append$f$p$aligned$n$$aligned_16$s$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pxcrt::aligned_16< pxcrt::glmpx::tmat4< pxcrt::bt_float >::type >& v$);
static inline void buffer_append$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& v$);
};}; /* namespace pgl3d::drawer */
namespace pointer$n { namespace tfuncptr$n { 
static inline void tfuncptr3___call$f$p$m$ll$p$m$ll$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$scene_node$s$q$0$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$node_common_data$s$q$1$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$instance_data$s$q$1$li$r$$r$$r$(const pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type& a0$, const ::pgl3d$n::scene_node$n::scene_node$s& a1$, ::pgl3d$n::pglbase$n::node_common_data$s& a2$, ::pgl3d$n::pglbase$n::instance_data$s& a3$);
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$);
};}; /* namespace pgl3d::glconf */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,4LL > make_farray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$4$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a3$);
};}; /* namespace container::array */
namespace operator$n { 
static inline pxcrt::bt_bool ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$(const pxcrt::rawptr< TTF_Font >::type& x$, const pxcrt::rawptr< TTF_Font >::type& y$);
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$ne$ls$r$(const pxcrt::rawptr< TTF_Font >::type& x$, const pxcrt::rawptr< TTF_Font >::type& y$);
}; /* namespace operator */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$, const pxcrt::bt_size_t& a2$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$, const pxcrt::bt_size_t& a2$);
};};}; /* namespace text::string::split */
namespace operator$n { 
static inline pxcrt::bt_bool eq$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$(const pxcrt::rawptr< TTF_Font >::type& x$, const pxcrt::rawptr< TTF_Font >::type& y$);
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$eq$ls$r$(const pxcrt::rawptr< TTF_Font >::type& x$, const pxcrt::rawptr< TTF_Font >::type& y$);
}; /* namespace operator */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$);
};};}; /* namespace text::string::split */
namespace operator$n { 
static inline pxcrt::bt_bool ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$r$(const pxcrt::rawptr< SDL_Surface >::type& x$, const pxcrt::rawptr< SDL_Surface >::type& y$);
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$ne$ls$r$(const pxcrt::rawptr< SDL_Surface >::type& x$, const pxcrt::rawptr< SDL_Surface >::type& y$);
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > make_ptr$f$p$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$q$m$ll$r$();
static inline pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > box_pointer$f$p$pxcrt$$ptr$p$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$r$$q$m$ll$r$();
}; /* namespace pointer */
namespace operator$n { 
static inline pxcrt::rawptr< TTF_Font >::type implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$$r$(const ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$& x$);
}; /* namespace operator */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::bt_uint power_of_2$f$p$meta$n$$uint$t$r$(pxcrt::bt_uint v$);
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_int cast_int$f$p$meta$n$$uint$t$r$(pxcrt::bt_uint x$);
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const pxcrt::bt_uint& a2$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const pxcrt::bt_uint& a2$);
};};}; /* namespace text::string::split */
namespace operator$n { 
static inline pxcrt::rawptr< SDL_Surface >::type implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$r$(const ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$& x$);
}; /* namespace operator */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_uint cast_uint$f$p$meta$n$$uint$t$r$(pxcrt::bt_uint x$);
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$);
};}; /* namespace pgl3d::glconf */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_int cast_int$f$p$GL$$base$n$$GLenum$s$r$(GLenum x$);
};}; /* namespace pgl3d::glgeometry */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::crawptr< void >::type rawptr___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$void$t$r$$q$pointer$$raw$n$$rawptr$s$p$meta$n$$void$t$r$$r$(pxcrt::rawptr< void >::type x$);
};}; /* namespace pointer::raw */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const pxcrt::bt_uint& a0$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const pxcrt::bt_uint& a0$);
}; /* namespace pointer */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const pxcrt::bt_uint& a2$);
};}; /* namespace pgl3d::glconf */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_int cast_int$f$p$meta$n$$int$t$r$(pxcrt::bt_int x$);
};}; /* namespace pgl3d::glgeometry */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_triangles$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$, pxcrt::bt_int& a1$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_triangles$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$, pxcrt::bt_int& a1$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles2$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_triangles2$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles2$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_triangles2$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_lineparticle$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_lineparticle$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_lineparticle$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_lineparticle$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_particle$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_particle$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle_bb$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_particle_bb$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle_bb$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_particle_bb$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_rect2d$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_rect2d$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_rect2d$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_rect2d$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_font2$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_font2$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_font2$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_font2$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$);
static inline pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > make_tptr$f$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$container$$array$n$$varray$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$pgl3d$$application$n$$pgl3d_scene_shared$i$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& a0$, const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >& a1$, const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >& a2$);
static inline pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > box_pointer$f$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$container$$array$n$$varray$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$pgl3d$$application$n$$pgl3d_scene_shared$i$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& a0$, const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >& a1$, const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >& a2$);
}; /* namespace pointer */
namespace thread$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ make_thread_ptr$f$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& sptr$, const ::pgl3d$n::scene_node$n::node_factory$s& nfac0$);
}; /* namespace thread */
namespace pointer$n { 
static inline pxcrt::rcptr< ::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ > make_ptr$f$p$thread$n$$thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& a0$, const ::pgl3d$n::scene_node$n::node_factory$s& a1$);
static inline pxcrt::rcptr< ::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ > box_pointer$f$p$pxcrt$$ptr$p$thread$n$$thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& a0$, const ::pgl3d$n::scene_node$n::node_factory$s& a1$);
static inline pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > make_tptr$f$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$q$m$ll$r$();
static inline pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > box_pointer$f$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$m$ll$r$();
}; /* namespace pointer */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& a2$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& a2$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$10$li$r$(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& x$);
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$r$$r$(const pxcrt::bt_uint& a0$, const pxcrt::bt_bool& a1$, const pxcrt::bt_bool& a2$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_buffer$s$r$$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$r$$r$(const pxcrt::bt_uint& a0$, const pxcrt::bt_bool& a1$, const pxcrt::bt_bool& a2$);
}; /* namespace pointer */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer_base$n$$prepare_instance_data_noop$f$r$();
};}; /* namespace pointer::tfuncptr */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$);
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::pglshader$n::build_context_impl$s > make_ptr$f$p$pgl3d$$pglshader$n$$build_context_impl$s$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$1$li$r$$r$$r$(::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >& a0$, ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& a1$);
static inline pxcrt::rcptr< ::pgl3d$n::pglshader$n::build_context_impl$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$pglshader$n$$build_context_impl$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$1$li$r$$r$$r$(::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >& a0$, ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& a1$);
}; /* namespace pointer */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uint > make_varray_func$f$p$meta$n$$uint$t$q$2$li$r$(const pxcrt::bt_uint& a0$, const pxcrt::bt_uint& a1$);
};}; /* namespace container::array */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$float$t$r$(pxcrt::bt_float x$);
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$float$t$r$(const pxcrt::bt_float& x$);
};}; /* namespace numeric::cast */
namespace ordered$n { 
static inline pxcrt::bt_double max$f$p$meta$n$$double$t$r$(const pxcrt::bt_double& x$, const pxcrt::bt_double& y$);
}; /* namespace ordered */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$double$t$r$(pxcrt::bt_double x$);
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$double$t$r$(const pxcrt::bt_double& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$);
};};}; /* namespace text::string::split */
namespace operator$n { 
static inline pxcrt::bt_bool ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$r$(const pxcrt::rawptr< SDL_Window >::type& x$, const pxcrt::rawptr< SDL_Window >::type& y$);
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$ne$ls$r$(const pxcrt::rawptr< SDL_Window >::type& x$, const pxcrt::rawptr< SDL_Window >::type& y$);
}; /* namespace operator */
namespace SDL2$n { namespace api_base$n { 
static inline pxcrt::bt_uint SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(int x$);
};}; /* namespace SDL2::api_base */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(const int& x$);
};}; /* namespace numeric::cast */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_int from_string$f$p$meta$n$$int$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
static inline pxcrt::bt_int deserialize_from_string$f$p$meta$n$$int$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline pxcrt::bt_int deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$int$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_int positional_to_integral$f$p$meta$n$$int$t$q$10$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
static inline pxcrt::bt_int positional_to_integral_internal$f$p$meta$n$$int$t$q$10$li$q$1$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
static inline pxcrt::bt_bool uchar_to_integral$f$p$meta$n$$int$t$q$10$li$r$(pxcrt::bt_uchar v$, pxcrt::bt_int& dig_r$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$);
};}; /* namespace numeric::cast */
namespace numeric$n { namespace limit$n { 
static inline pxcrt::bt_int lowest$f$p$meta$n$$int$t$r$();
};}; /* namespace numeric::limit */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_int positional_to_integral_internal$f$p$meta$n$$int$t$q$10$li$q$0$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace limit$n { 
static inline pxcrt::bt_int highest$f$p$meta$n$$int$t$r$();
};}; /* namespace numeric::limit */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_int string_parse_token$f$p$meta$n$$int$t$q$text$$string$$positional$n$$positional_to_integral$f$p$meta$n$$int$t$q$10$li$r$$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$);
};};}; /* namespace text::string::serialize */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$);
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$exception$n$$c_exception$i$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const std::exception& a1$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$exception$n$$c_exception$i$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const std::exception& a1$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$exception$n$$c_exception$i$r$(const std::exception& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$exception$n$$c_exception$i$r$(const std::exception& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace operator$n { 
static inline pxcrt::bt_bool ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$(const pxcrt::rawptr< SDL_RWops >::type& x$, const pxcrt::rawptr< SDL_RWops >::type& y$);
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$ne$ls$r$(const pxcrt::rawptr< SDL_RWops >::type& x$, const pxcrt::rawptr< SDL_RWops >::type& y$);
static inline pxcrt::bt_bool eq$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$(const pxcrt::rawptr< SDL_RWops >::type& x$, const pxcrt::rawptr< SDL_RWops >::type& y$);
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$eq$ls$r$(const pxcrt::rawptr< SDL_RWops >::type& x$, const pxcrt::rawptr< SDL_RWops >::type& y$);
static inline pxcrt::rawptr< SDL_RWops >::type implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$$r$(const ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$& x$);
}; /* namespace operator */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_double static_cast$f$p$meta$n$$double$t$q$numeric$$integral$n$$ulonglong$s$r$(const ::pxcrt::bt_ulonglong& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$numeric$$integral$n$$ulonglong$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_ulonglong& a1$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$numeric$$integral$n$$ulonglong$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_ulonglong& a1$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$numeric$$integral$n$$ulonglong$s$r$(const ::pxcrt::bt_ulonglong& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$numeric$$integral$n$$ulonglong$s$r$(const ::pxcrt::bt_ulonglong& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$numeric$$integral$n$$ulonglong$s$q$10$li$r$(::pxcrt::bt_ulonglong v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$numeric$$integral$n$$ulonglong$s$r$(const ::pxcrt::bt_ulonglong& x$);
static inline pxcrt::bt_double static_cast$f$p$meta$n$$double$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$);
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline pxcrt::rawptr< SDL_Window >::type implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$$r$(const ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$& x$);
}; /* namespace operator */
namespace SDL2$n { namespace api_base$n { 
static inline pxcrt::bt_uchar SDL_Enum___to$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(int x$);
};}; /* namespace SDL2::api_base */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(const int& x$);
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const ::pxcrt::bt_strlit& a2$, const pxcrt::bt_int& a3$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const ::pxcrt::bt_strlit& a2$, const pxcrt::bt_int& a3$);
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$1$li$r$$q$m$ll$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$1$li$r$$r$$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const ::pxcrt::farray< pxcrt::bt_uint,8LL >& a2$, const pxcrt::bt_size_t& a3$, const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a4$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& a5$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$float$t$r$(const pxcrt::bt_float& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
static inline void serialize_to_string$f$p$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$r$(const ::pxcrt::farray< pxcrt::bt_uint,8LL >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$r$(const ::pxcrt::farray< pxcrt::bt_uint,8LL >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace container$n { namespace tree_map$n { 
static inline void tree_map_compare_swap$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& x$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& y$);
};}; /* namespace container::tree_map */
namespace Bullet$n { namespace api$n { 
static inline ::btVector3 btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_float& a2$);
};}; /* namespace Bullet::api */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::rawptr< ::btMotionState >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btMotionState$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDefaultMotionState$s$r$$r$(pxcrt::rawptr< ::btDefaultMotionState >::type x$);
static inline pxcrt::rawptr< ::btCollisionConfiguration >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionConfiguration$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDefaultCollisionConfiguration$s$r$$r$(pxcrt::rawptr< ::btDefaultCollisionConfiguration >::type x$);
static inline pxcrt::rawptr< ::btDispatcher >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDispatcher$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionDispatcher$s$r$$r$(pxcrt::rawptr< ::btCollisionDispatcher >::type x$);
static inline pxcrt::rawptr< ::btBroadphaseInterface >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btBroadphaseInterface$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDbvtBroadphase$s$r$$r$(pxcrt::rawptr< ::btDbvtBroadphase >::type x$);
static inline pxcrt::rawptr< ::btConstraintSolver >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btConstraintSolver$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btSequentialImpulseConstraintSolver$s$r$$r$(pxcrt::rawptr< ::btSequentialImpulseConstraintSolver >::type x$);
static inline pxcrt::rawptr< ::btCollisionObject >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionObject$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btRigidBody$s$r$$r$(pxcrt::rawptr< ::btRigidBody >::type x$);
};}; /* namespace pointer::raw */
namespace Bullet$n { namespace api$n { 
static inline void btDiscreteDynamicsWorld_addRigidBody$f$p$m$ll$p$m$ll$p$Bullet$$api$n$$btDiscreteDynamicsWorld$s$q$1$li$r$$q$m$ll$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btRigidBody$s$r$$q$0$li$r$$r$$r$(::btDiscreteDynamicsWorld& a0$, const pxcrt::rawptr< ::btRigidBody >::type& a1$);
};}; /* namespace Bullet::api */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,2LL > make_farray_split$f$p$2$li$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$);
static inline void split_foreach$f$p$demoapp$n$$$f2$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& _0$up, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$);
static inline pxcrt::bt_size_t find_mapped$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& c$, pxcrt::bt_size_t k$, const pxcrt::bt_uchar& x$);
};}; /* namespace container::array */
namespace io$n { namespace standard$n { 
static inline void println$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& a1$);
};}; /* namespace io::standard */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& a1$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_escape$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$);
};};}; /* namespace text::string::serialize */
namespace pointer$n { 
static inline pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > make_tptr$f$p$demoapp$n$$demoapp_scene_shared$s$q$m$ll$r$();
static inline pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > box_pointer$f$p$pxcrt$$tptr$p$demoapp$n$$demoapp_scene_shared$s$r$$q$m$ll$r$();
static inline pxcrt::rcptr< ::demoapp$n::demoapp_scene$s > make_ptr$f$p$demoapp$n$$demoapp_scene$s$q$m$ll$p$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$pxcrt$$tcptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(const ::pgl3d$n::scene_node$n::node_factory$s& a0$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& a1$);
static inline pxcrt::rcptr< ::demoapp$n::demoapp_scene$s > box_pointer$f$p$pxcrt$$ptr$p$demoapp$n$$demoapp_scene$s$r$$q$m$ll$p$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$pxcrt$$tcptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(const ::pgl3d$n::scene_node$n::node_factory$s& a0$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& a1$);
}; /* namespace pointer */
namespace operator$n { 
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type sub$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$sub$ls$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type add$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$add$ls$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type div$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline void diva$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline void binopa$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type mul$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$mul$ls$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$);
static inline pxcrt::bt_float getelem$f$p$container$$raw$n$$rawarray$s$p$meta$n$$float$t$q$4$li$r$$q$meta$n$$uint$t$r$(const ::pxcrt::rawarray< pxcrt::bt_float,4LL >::type& x$, const pxcrt::bt_uint& y$);
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type mul$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$);
static inline void suba$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$);
static inline void binopa$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$sub$ls$r$(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$);
}; /* namespace operator */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$uchar$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$, const pxcrt::bt_uchar& a3$);
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$uchar$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$, const pxcrt::bt_uchar& a3$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$uchar$t$q$10$li$r$(pxcrt::bt_uchar v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$);
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$SDL2$$api_types$n$$SDL_Scancode$s$r$(const int& x$);
};}; /* namespace numeric::cast */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$int$t$q$16$li$r$(pxcrt::bt_int v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$);
};};}; /* namespace text::string::positional */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$);
};}; /* namespace pgl3d::glconf */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$SDL2$$api_types$n$$SDL_Scancode$s$r$(const int& x$);
};}; /* namespace numeric::cast */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,1LL > make_farray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$);
static inline ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > make_varray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$2$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$);
static inline ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > make_varray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$);
};}; /* namespace container::array */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$(const ::pgl3d$n::wfobj$n::wfobject$s& wfo$, const ::pgl3d$n::wfobj$n::wfgroup$s& wfgrp$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$$q$m$ll$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$0$li$r$$q$m$ll$p$pgl3d$$wfobj$n$$wfgroup$s$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const ::pgl3d$n::wfobj$n::wfobject$s& a0$, const ::pgl3d$n::wfobj$n::wfgroup$s& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$$r$$q$m$ll$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$0$li$r$$q$m$ll$p$pgl3d$$wfobj$n$$wfgroup$s$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const ::pgl3d$n::wfobj$n::wfobject$s& a0$, const ::pgl3d$n::wfobj$n::wfgroup$s& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t n$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, pxcrt::bt_bool split_reverse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, pxcrt::bt_bool& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, pxcrt::bt_bool& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float z$, pxcrt::bt_float scale$, pxcrt::bt_int recurse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_float& a1$, pxcrt::bt_int& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a4$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_float& a1$, pxcrt::bt_int& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a4$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$(pxcrt::bt_size_t split$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$(pxcrt::bt_size_t n$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$();
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$$q$m$ll$r$();
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$$r$$q$m$ll$r$();
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t split_x$, pxcrt::bt_size_t split_y$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& q$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$$q$m$ll$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$(pxcrt::bt_size_t num$, pxcrt::bt_float scale$, pxcrt::bt_float xmin$, pxcrt::bt_float xmax$, pxcrt::bt_float ymin$, pxcrt::bt_float ymax$, pxcrt::bt_float zmin$, pxcrt::bt_float zmax$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c2$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, pxcrt::bt_float& a1$, pxcrt::bt_float& a2$, pxcrt::bt_float& a3$, pxcrt::bt_float& a4$, pxcrt::bt_float& a5$, pxcrt::bt_float& a6$, pxcrt::bt_float& a7$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a8$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a9$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a10$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a11$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, pxcrt::bt_float& a1$, pxcrt::bt_float& a2$, pxcrt::bt_float& a3$, pxcrt::bt_float& a4$, pxcrt::bt_float& a5$, pxcrt::bt_float& a6$, pxcrt::bt_float& a7$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a8$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a9$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a10$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a11$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, pxcrt::bt_bool surface_flag$, pxcrt::bt_bool rotate_flag$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_size_t& a1$, pxcrt::bt_bool& a2$, pxcrt::bt_bool& a3$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a4$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a5$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_size_t& a1$, pxcrt::bt_bool& a2$, pxcrt::bt_bool& a3$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a4$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a5$);
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$);
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$);
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$);
static inline pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > > make_tptr$f$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_float >& a0$);
static inline pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > > box_pointer$f$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_float >& a0$);
}; /* namespace pointer */
namespace io$n { namespace standard$n { 
static inline void debug_log$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_float >& a3$);
};}; /* namespace io::standard */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_float >& a3$);
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_float >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$);
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_float >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$);
};}; /* namespace text::serialize */
namespace container$n { namespace array$n { 
static inline ::pxcrt::darray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > make_darray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$);
};}; /* namespace container::array */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::rawptr< ::btCollisionShape >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionShape$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$(pxcrt::rawptr< ::btBoxShape >::type x$);
};}; /* namespace pointer::raw */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$q$m$ll$p$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(const ::btVector3& a0$);
static inline pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$m$ll$p$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(const ::btVector3& a0$);
}; /* namespace pointer */
namespace Bullet$n { namespace api$n { 
static inline ::btTransform btTransform_$f$p$m$ll$p$m$ll$p$Bullet$$api$n$$btQuaternion$s$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(const ::btQuaternion& a0$, const ::btVector3& a1$);
};}; /* namespace Bullet::api */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ >& a0$, const pxcrt::bt_float& a1$, const ::btTransform& a2$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ >& a0$, const pxcrt::bt_float& a1$, const ::btTransform& a2$);
}; /* namespace pointer */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::rawptr< ::btCollisionShape >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionShape$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$(pxcrt::rawptr< ::btConvexHullShape >::type x$);
};}; /* namespace pointer::raw */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$q$m$ll$p$m$ll$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const pxcrt::crawptr< pxcrt::bt_float >::type& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$);
static inline pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$m$ll$p$m$ll$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const pxcrt::crawptr< pxcrt::bt_float >::type& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$1$li$r$$r$$r$(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ >& a0$, const pxcrt::bt_float& a1$, ::btTransform& a2$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$1$li$r$$r$$r$(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ >& a0$, const pxcrt::bt_float& a1$, ::btTransform& a2$);
}; /* namespace pointer */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$);
};}; /* namespace numeric::cast */
namespace Bullet$n { namespace api$n { 
static inline ::btQuaternion btQuaternion_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_float& a2$, const pxcrt::bt_float& a3$);
};}; /* namespace Bullet::api */
namespace pgl3d$n { namespace pglcommon$n { 
static inline void erase_cond$f$p$demoapp$n$$lp_is_finished$f150$q$container$$array$n$$varray$s$p$demoapp$n$$lpbullet_data$s$r$$r$(::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s >& arr$);
};}; /* namespace pgl3d::pglcommon */
namespace generic$n { 
static inline void swap$f$p$demoapp$n$$lpbullet_data$s$r$(::demoapp$n::lpbullet_data$s& x$, ::demoapp$n::lpbullet_data$s& y$);
static inline void swap$f$p$container$$array$n$$farray$s$p$meta$n$$float$t$q$9$li$r$$r$(::pxcrt::farray< pxcrt::bt_float,9LL >& x$, ::pxcrt::farray< pxcrt::bt_float,9LL >& y$);
}; /* namespace generic */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape_i$i$r$$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i >& a0$, const pxcrt::bt_float& a1$, const ::btTransform& a2$);
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape_i$i$r$$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i >& a0$, const pxcrt::bt_float& a1$, const ::btTransform& a2$);
}; /* namespace pointer */
namespace io$n { namespace standard$n { 
static inline void debug_log$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$);
};}; /* namespace io::standard */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$float$t$r$(const pxcrt::bt_float& x$);
};}; /* namespace numeric::cast */
#ifndef PXC_IMPORT_HEADER
/* inline c */
/* inline */

namespace pxcrt {

bt_unit unit_value;
char **process_argv;

}; // namespace pxcrt
// extern "implementation" inline
;
/* inline */
namespace pxcrt {

#ifndef PXCRT_NO_LOCAL_POOL

thread_local void *local_pool_blocks;

void __attribute__((destructor(101))) clear_local_pool()
{
  while (local_pool_blocks != 0) {
    void *next = *(void **)local_pool_blocks;
    global_deallocate_n(local_pool_blocks, local_pool_block_alloc_size);
    local_pool_blocks = next;
  }
}

#else

void clear_local_pool()
{
}

#endif

}; // namespace pxcrt
;
/* inline */
namespace pxcrt {

svarray_rep empty_rep; /* pod */

}; // namespace pxcrt
;
/* inline */
namespace text {
using namespace pxcrt;

static void fp_to_decimal_internal(const char *fmt, bt_double x, bt_string& s)
{
// FIXME: cease to use snprintf
  const size_t osz = s.size();
  char *buf = reinterpret_cast<char *>(s.reserve_back<1>(20));
  int len = snprintf(buf, 20, fmt, x);
  if (len < 0) {
    return;
  }
  if (len < 10) {
    s.rawarr_set_valid_len(osz + len);
    return;
  }
  const int alen = len;
  buf = reinterpret_cast<char *>(s.reserve_back<1>(alen + 1));
  len = snprintf(buf, alen + 1, fmt, x);
  if (len < 0) {
    return;
  }
  s.rawarr_set_valid_len(osz + len);
}

static cstrref get_decimal_part(cstrref const& buf)
{
  const size_t n = buf.size();
  const bt_uchar *const p = buf.rawarr();
  size_t i = 0;
  for (; i < n; ++i) {
    const bt_uchar ch = p[i];
    if ((ch >= '0' && ch <= '9') ||
      /*
      (ch >= 'a' && ch <= 'z') ||
      (ch >= 'A' && ch <= 'Z') ||
      */
      ch == '+' || ch == '-' || ch == '.') {
    } else {
      break;
    }
  }
  return cstrref(p, i);
}

void fp_to_decimal_double(bt_double x, bt_string& buf)
{ fp_to_decimal_internal("%.16f", x, buf); }

void fp_to_decimal_float(bt_float x, bt_string& buf)
{ fp_to_decimal_internal("%.7f", x, buf); }

bt_double decimal_to_fp_nocheck_double(cstrref const& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, pbuf);
  double r = 0;
#ifdef _MSC_VER
  sscanf_s(buf_nt.get(), "%lf", &r);
#else
  sscanf(buf_nt.get(), "%lf", &r);
#endif
  return r;
}

bt_float decimal_to_fp_nocheck_float(cstrref const& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, pbuf);
  float r = 0;
#ifdef _MSC_VER
  sscanf_s(buf_nt.get(), "%f", &r);
#else
  sscanf(buf_nt.get(), "%f", &r);
#endif
  return r;
}

bt_double decimal_to_fp_double(cstrref& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, pbuf);
  double r = 0;
  int n = 0;
#ifdef _MSC_VER
  sscanf_s(buf_nt.get(), "%lf%n", &r, &n);
#else
  sscanf(buf_nt.get(), "%lf%n", &r, &n);
#endif
  if (n > 0) {
    buf.increment_front(n);
  }
  return r;
}

bt_float decimal_to_fp_float(cstrref& buf)
{
  cstrref pbuf = get_decimal_part(buf);
  PXCRT_ALLOCA_NTSTRING(buf_nt, pbuf);
  float r = 0;
  int n = 0;
#ifdef _MSC_VER
  sscanf_s(buf_nt.get(), "%f%n", &r, &n);
#else
  sscanf(buf_nt.get(), "%f%n", &r, &n);
#endif
  if (n > 0) {
    buf.increment_front(n);
  }
  return r;
}

};
;
/* inline */
namespace pxcrt {
using namespace pxcrt;

void minimal_encode(cstrref const& src, bt_string& buf)
{
  /* escapes 0x00 - 0x0f, 0x2c, 0x7a - 0x7f */
  const size_t srclen = src.size();
  const bt_uchar *const start = src.rawarr();
  const bt_uchar *const end = start + srclen;
  const size_t osize = buf.size();
  bt_uchar *const wstart = buf.reserve_back<2>(srclen); /* srclen * 2 */
  bt_uchar *wptr = wstart;
  for (const bt_uchar *p = start; p != end; ++p) {
    const bt_uchar c = p[0];
    if ((c >= 0x10 && c <= 0x7a && c != 0x2c) || c >= 0x80) {
      wptr[0] = c;
      ++wptr;
    } else if (c < 0x30) {
      wptr[0] = '~';
      wptr[1] = c + 0x20;
      wptr += 2;
    } else {
      wptr[0] = '~';
      wptr[1] = c - 0x20;
      wptr += 2;
    }
  }
  assert((size_t)(wptr - wstart) <= srclen * 2);
  buf.rawarr_set_valid_len(osize + wptr - wstart);
}

void minimal_decode(cstrref const& src, bt_string& buf)
{
  const size_t srclen = src.size();
  const bt_uchar *const start = src.rawarr();
  const bt_uchar *const end = start + srclen;
  const size_t osize = buf.size();
  bt_uchar *const wstart = buf.reserve_back<1>(srclen);
  bt_uchar *wptr = wstart;
  for (const bt_uchar *p = start; p != end; ++p) {
    if (p[0] == '~' && p + 1 != end) {
      bt_uchar ch = p[1];
      (*wptr++) = ch < 0x50 ? ch - 0x20 : ch + 0x20;
      p++;
    } else {
      (*wptr++) = p[0];
    }
  }
  assert((size_t)(wptr - wstart) <= srclen);
  buf.rawarr_set_valid_len(osize + wptr - wstart);
}

}; // namespace pxcrt
;
/* inline */
#include <string>
// #ifdef PXC_POSIX
// #include <unistd.h>
// #endif
#ifdef __GLIBC__
#include <execinfo.h>
#endif
namespace pxcrt {

logic_error::logic_error() : std::logic_error("pxcrt::logic_error")
{ }
bt_string logic_error::message() const
{ return cstr_to_string("logic_error"); }

runtime_error::runtime_error() : std::runtime_error("pxcrt::runtime_error")
{ }
bt_string runtime_error::message() const
{ return cstr_to_string("runtime_error"); }

bad_alloc::bad_alloc()
{ }
bt_string bad_alloc::message() const
{ return cstr_to_string("bad_alloc"); }

bt_string invalid_index::message() const
{ return cstr_to_string("invalid_index"); }
bt_string invalid_field::message() const
{ return cstr_to_string("invalid_field"); }
bt_string would_invalidate::message() const
{ return cstr_to_string("would_invalidate"); }

void throw_bad_alloc()
{ PXC_THROW(bad_alloc()); }
void throw_invalid_index()
{ PXC_THROW(invalid_index()); }
void throw_invalid_field()
{ PXC_THROW(invalid_field()); }
void throw_would_invalidate()
{ PXC_THROW(would_invalidate()); }

size_t stack_trace_limit = static_cast<size_t>(-1);

void set_stack_trace_limit(size_t sz)
{
  stack_trace_limit = sz;
}

exception::exception()
{
#ifdef __GLIBC__
  if (stack_trace_limit != 0) {
    size_t n = std::min(static_cast<size_t>(5), stack_trace_limit);
    while (true) {
      trace.resize(n);
      backtrace(&trace[0], trace.size());
      if (trace[trace.size() - 1] == 0) {
	while (trace[trace.size() - 1] == 0) {
	  trace.resize(trace.size() - 1);
	}
	break;
      }
      size_t n2 = std::min(n * 2, stack_trace_limit);
      if (n2 <= n) {
	break;
      }
      n = n2;
    }
  }
#endif
}

struct auto_free {
  auto_free(void *ptr) : ptr(ptr) { }
  ~auto_free() { free(ptr); }
private:
  auto_free(const auto_free&);
  auto_free& operator =(const auto_free&);
  void *ptr;
};

bt_string exception_message(pxcrt::exception const& exc)
{
  return exc.message();
}

bt_string exception_stack_trace(pxcrt::exception const& exc)
{
  bt_string r;
#ifdef __GLIBC__
  std::vector<void *> const& tr = exc.trace; 
  char **syms = backtrace_symbols(&tr[0], tr.size());
  if (syms == 0) {
    throw_bad_alloc();
  }
  auto_free af(syms);
  for (size_t i = 0; i < tr.size(); ++i) {
    r.append(cstrref(
      reinterpret_cast<const bt_uchar *>(syms[i]), strlen(syms[i])));
    r.push_back('\n');
  }
#endif
  return r;
}

bt_string c_exception_message(std::exception const& exc)
{
  const exception *const e = dynamic_cast<const exception *>(&exc);
  if (e == 0) {
    const char *const s = exc.what();
    const bt_uchar *const us = reinterpret_cast<const bt_uchar *>(s);
    return bt_string(us, strlen(s));
  } else {
    return e->message();
  }
}

bt_string c_exception_stack_trace(std::exception const& exc)
{
  const exception *const e = dynamic_cast<const exception *>(&exc);
  if (e == 0) {
    return bt_string();
  }
  return exception_stack_trace(*e);
}

std::string c_exception_to_stdstring(const std::exception& ex)
{
  std::string mess;
  bt_string s0 = c_exception_message(ex);
  mess.insert(mess.end(), s0.begin(), s0.end());
  if (!mess.empty() && mess[mess.size() - 1] != '\n') {
    mess += "\n";
  }
  bt_string st = c_exception_stack_trace(ex);
  mess.insert(mess.end(), st.begin(), st.end());
  return mess;
}

void c_exception_log_stderr(const std::exception& ex)
{
  const std::string mess = c_exception_to_stdstring(ex);
#ifdef PXC_POSIX
  ::write(2, mess.data(), mess.size());
#else
  _write(2, mess.data(), mess.size());
#endif
}

int main_nothrow(void (*main_f)(void))
{
  PXC_TRY {
    PXC_TRY {
      (*main_f)();
    } PXC_CATCH(const std::exception& ex) {
      #if !PXC_NOEXCEPTIONS
      c_exception_log_stderr(ex);
      return 1;
      #endif
    }
  } PXC_CATCH(...) {
    const char *const mess = "PXCMAIN: Uncaught exception\n";
#ifdef PXC_POSIX
    ::write(2, mess, strlen(mess));
#else
    _write(2, mess, strlen(mess));
#endif
    return 1;
  }
  return 0;
}

}; // namespace pxcrt
;
/* inline */

namespace pxcrt {

const denom_info denom_list[38] = {{17,&modulo_fixed<17>},{29,&modulo_fixed<29>},{37,&modulo_fixed<37>},{53,&modulo_fixed<53>},{67,&modulo_fixed<67>},{79,&modulo_fixed<79>},{97,&modulo_fixed<97>},{131,&modulo_fixed<131>},{193,&modulo_fixed<193>},{257,&modulo_fixed<257>},{389,&modulo_fixed<389>},{521,&modulo_fixed<521>},{769,&modulo_fixed<769>},{1031,&modulo_fixed<1031>},{1543,&modulo_fixed<1543>},{2053,&modulo_fixed<2053>},{3079,&modulo_fixed<3079>},{6151,&modulo_fixed<6151>},{12289,&modulo_fixed<12289>},{24593,&modulo_fixed<24593>},{49157,&modulo_fixed<49157>},{98317,&modulo_fixed<98317>},{196613,&modulo_fixed<196613>},{393241,&modulo_fixed<393241>},{786433,&modulo_fixed<786433>},{1572869,&modulo_fixed<1572869>},{3145739,&modulo_fixed<3145739>},{6291469,&modulo_fixed<6291469>},{12582917,&modulo_fixed<12582917>},{25165843,&modulo_fixed<25165843>},{50331653,&modulo_fixed<50331653>},{100663319,&modulo_fixed<100663319>},{201326611,&modulo_fixed<201326611>},{402653189,&modulo_fixed<402653189>},{805306457,&modulo_fixed<805306457>},{1610612741,&modulo_fixed<1610612741>},{3221225473,&modulo_fixed<3221225473>},{4294967291,&modulo_fixed<4294967291>}};

}; // namespace pxcrt

;
/* inline */
namespace pxcrt {

io io_system(0);

io debug_system()
{
  return io(0);
}

};
;
/* inline */
#include <errno.h>
;
/* inline */
namespace pxcrt {
using namespace pxcrt;

#ifdef PXC_POSIX

::timeval gettimeofday(io const& iop)
{
  ::timeval tv = { };
  ::gettimeofday(&tv, 0); /* no need to check error */
  return tv;
}

bt_ulonglong high_resolution_timer(io const& iop)
{
  ::timeval tv = { };
  ::gettimeofday(&tv, 0); /* no need to check error */
  unsigned long long v = tv.tv_sec;
  v *= 1000000;
  v += tv.tv_usec;
  return v;
}

bt_ulonglong high_resolution_timer_frequency(io const& iop)
{
  return 1000000ULL;
}

#endif

#ifdef PXC_WINDOWS

::timeval gettimeofday(io const& iop)
{
  FILETIME ft = { };
  unsigned long long v = 0;
  GetSystemTimeAsFileTime(&ft);
  v = ft.dwHighDateTime;
  v <<= 32;
  v += ft.dwLowDateTime;
  v -= 116444736000000000ULL;
  v /= 10;
  ::timeval tv = { };
  tv.tv_sec = (long)(v / 1000000);
  tv.tv_usec = (long)(v % 1000000);
  return tv;
}

bt_ulonglong high_resolution_timer(io const& iop)
{
  LARGE_INTEGER v = { };
  if (!QueryPerformanceCounter(&v)) {
    return 0;
  }
  return v.QuadPart;
}

bt_ulonglong high_resolution_timer_frequency(io const& iop)
{
  LARGE_INTEGER v = { };
  if (!QueryPerformanceFrequency(&v)) {
    return 0;
  }
  return v.QuadPart;
}

#endif

std::time_t time(io const& iop)
{
  return std::time(0);
}

bt_uint io_sleep(io const& iop, bt_uint sec)
{
#ifdef PXC_POSIX
  ::sleep(sec);
#else
  Sleep(sec * 1000);
#endif
  return 0;
}

bt_uint io_usleep(io const& iop, bt_uint usec)
{
#ifdef PXC_POSIX
  ::usleep(usec);
#else
  Sleep(usec / 1000);
#endif
  return 0;
}

void time_init()
{
  /* not multi-thread safe */
#ifdef PXC_POSIX
  ::tzset();
#else
  _tzset();
#endif
}

}; // namespace pxcrt
;
/* inline */
namespace pxcrt {

typedef int errno_t;

bt_int io_open_fd(io const& iop, cstrref const& fn, int flags, mode_t md)
{
  PXCRT_ALLOCA_NTSTRING(fn_nt, fn);
#ifdef PXC_POSIX
  return ::open(fn_nt.get(), flags, md);
#else
  bt_int r = -1;
  errno = ::_sopen_s(&r, fn_nt.get(), flags, 0, md);
  return r;
#endif
}

file_st io_make_file_st(io const& iop, bt_int fd)
{
  return make_file_st(fd);
}

file_mt io_make_file_mt(io const& iop, bt_int fd)
{
  return make_file_mt(fd);
}

file_st make_file_st(bt_int fd)
{
  PXC_TRY {
    file_st r(fd); /* throws */
    return r;
  } PXC_CATCH(...) {
    if (fd >= 2) {
      file_st_rep f(fd); /* closes fd */
    }
    PXC_RETHROW;
  }
}

file_mt make_file_mt(bt_int fd)
{
  PXC_TRY {
    file_mt r(fd); /* throws */
    return r;
  } PXC_CATCH(...) {
    if (fd >= 2) {
      file_mt_rep f(fd); /* closes fd */
    }
    PXC_RETHROW;
  }
}

errno_t file_read_impl(file const& f, bt_string& buf, size_t& len)
{
  int const fd = f.get();
  bt_size_t sz = len;
  if (sz > SSIZE_MAX) {
    sz = SSIZE_MAX;
  }
  bt_size_t osz = buf.size();
  void *const ptr = buf.reserve_back<1>(sz);
#ifdef PXC_POSIX
  const pxcrt::bt_ssize_t rlen = ::read(fd, ptr, sz);
#else
  const pxcrt::bt_ssize_t rlen = ::_read(fd, ptr, sz);
#endif
  if (rlen < 0) {
    return errno;
  }
  buf.rawarr_set_valid_len(osz + rlen);
  len = rlen;
  return 0;
}

errno_t file_write_impl(file const& f, cstrref const& buf, size_t& len_r)
{
  int const fd = f.get();
  bt_size_t sz = buf.size();
  if (sz > SSIZE_MAX) {
    sz = SSIZE_MAX;
  }
  const unsigned char *const ptr = buf.rawarr();
#ifdef PXC_POSIX
  const pxcrt::bt_ssize_t wlen = ::write(fd, ptr, sz);
#else
  const pxcrt::bt_ssize_t wlen = ::_write(fd, ptr, sz);
#endif
  if (wlen < 0) {
    return errno;
  }
  len_r = wlen;
  return 0;
}

errno_t file_lseek_impl(file const& f, off_t& offset, int whence)
{
  int const fd = f.get();
#ifdef PXC_POSIX
  off_t r = ::lseek(fd, offset, whence);
#else
  off_t r = ::_lseeki64(fd, offset, whence);
#endif
  if (r == (off_t)-1) {
    offset = 0;
    return errno;
  }
  offset = r;
  return 0;
}

int /* errno_t */ file_st_close(file_st& f)
{
  int const fd = f.ptr->value.fd;
  f.ptr->value.fd = -1;
#ifdef PXC_POSIX
  int const rv = ::close(fd);
#else
  int const rv = ::_close(fd);
#endif
  return rv == 0 ? 0 : errno;
}

errno_t io_stat(io const& iop, cstrref const& fn, pxcrt::statbuf& buf)
{
  PXCRT_ALLOCA_NTSTRING(fn_nt, fn);
#ifdef PXC_POSIX
  const int e = ::stat(fn_nt.get(), &buf);
#else
  const int e = ::_stat(fn_nt.get(), &buf);
#endif
  if (e != 0) {
    return errno;
  }
  return 0;
}

::pxcrt::pxcvarray<file_mt> io_pipe_internal(::pxcrt::io const& sys,
  int& err_r)
{
  int fds[2];
#ifdef PXC_POSIX
  const int e = ::pipe(fds);
#else
  const int e = ::_pipe(fds, 4096, 0);
#endif
  if (e != 0) {
    err_r = errno;
    fds[0] = fds[1] = -1;
  }
  ::pxcrt::pxcvarray<file_mt> r;
  if (e == 0) {
    r.push_back(make_file_mt(fds[0]));
    r.push_back(make_file_mt(fds[1]));
  }
  return r;
}

};
;
/* inline */
namespace pxcrt {

typedef ::algebraic$n::option$v$p$io$$file$n$$file_st$s$r$ optfile;

/* TODO: slow */
file_st io_stdin(io const& iop)  {
  optfile pxc_stdin;
  pxc_stdin.some$$l(make_file_st(0));
  return pxc_stdin.some$$r();
}
file_st io_stdout(io const& iop) {
  optfile pxc_stdout;
  pxc_stdout.some$$l(make_file_st(1));
  return pxc_stdout.some$$r();
}
file_st io_stderr(io const& iop) {
  optfile pxc_stderr;
  pxc_stderr.some$$l(make_file_st(2));
  return pxc_stderr.some$$r();
}
void debug_log_internal(cstrref const& s)
{
#ifdef PXC_POSIX
  ::write(2, s.rawarr(), s.size());
#else
  _write(2, s.rawarr(), s.size());
#endif
}

};
;
/* inline */
namespace pxcrt {

static volatile int v_signalled[256];

void sighandler_set_signaled(int sig)
{
  if (sig >= 0 && sig < 256) {
    v_signalled[sig] = 1;
  }
}

bool get_signaled(io const& iop, int sig)
{
  if (sig >= 0 && sig < 256) {
    return (v_signalled[sig] != 0);
  }
  return false;
}

bool set_signal_handler(io const& iop, int sig, sighandler_t h)
{
  errno = 0;
  const sighandler_t r = std::signal(sig, h);
  return (r != SIG_ERR);
}

};
;
/* inline */
namespace pxcrt {

using namespace pxcrt;

void _exit_internal(io const& sys, bt_int st)
{
  _exit(st);
}

void exit_internal(io const& sys, bt_int st)
{
  exit(st);
}

void abort_internal(io const& sys)
{
  abort();
}

pxcrt::pid_t fork_internal(io const& sys)
{
#ifdef PXC_POSIX
  return fork();
#else
  abort();
#endif
}

pxcrt::pid_t wait_internal(io const& sys, int& st_r)
{
#ifdef PXC_POSIX
  return wait(&st_r);
#else
  abort();
#endif
}

pxcrt::pid_t waitpid_internal(io const& sys, pxcrt::pid_t pid, int& st_r,
  int opt)
{
#ifdef PXC_POSIX
  return waitpid(pid, &st_r, opt);
#else
  abort();
#endif
}

bool wifexited(int st)
{
#ifdef PXC_POSIX
  return WIFEXITED(st) != 0;
#else
  return true;
#endif
}

int wexitstatus(int st)
{
#ifdef PXC_POSIX
  return WIFEXITED(st) ? WEXITSTATUS(st) : 0;
#else
  return st;
#endif
}

bool wifsignaled(int st)
{
#ifdef PXC_POSIX
  return WIFSIGNALED(st) != 0;
#else
  return false;
#endif
}

int wtermsig(int st)
{
#ifdef PXC_POSIX
  return WIFSIGNALED(st) ? WTERMSIG(st) : 0;
#else
  return 0;
#endif
}

static int execv_internal(bool execvp_flag, cstrref const& path,
  bt_cslice<bt_string> const& argv)
{
#ifdef PXC_POSIX
  PXCRT_ALLOCA_NTSTRING(path_nt, path);
  pxcvarray<bt_string> argv_nt;
  argv_nt.resize(argv.size(), bt_string());
  char *argv_rp[argv.size() + 1];
  for (size_t i = 0; i < argv.size(); ++i) {
    argv_nt[i] = argv[i];
    argv_nt[i].push_back('\0');
    argv_rp[i] = reinterpret_cast<char *>(argv_nt[i].rawarr());
  }
  argv_rp[argv.size()] = 0;
  if (execvp_flag) {
    ::execvp(path_nt.get(), argv_rp);
  } else {
    ::execv(path_nt.get(), argv_rp);
  }
  return errno;
#else
  abort();
#endif
}

int execv(io const& sys, cstrref const& path,
  bt_cslice<bt_string> const& argv)
{
  return execv_internal(false, path, argv);
}

int execvp(io const& sys, cstrref const& file,
  bt_cslice<bt_string> const& argv)
{
  return execv_internal(true, file, argv);
}

int shell_exec_internal(io const& sys, cstrref const& cmd)
{
  PXCRT_ALLOCA_NTSTRING(cmd_nt, cmd);
  return std::system(cmd_nt.get());
}

int dup2_internal(io const& sys, file const& ofp, file const& nfp)
{
#ifdef PXC_POSIX
  if (dup2(ofp.get(), nfp.get()) < 0) {
#else
  if (_dup2(ofp.get(), nfp.get()) < 0) {
#endif
    return errno;
  }
  return 0;
}

};
;
/* inline */

namespace SDL2 {
using namespace pxcrt;

void Log(cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_Log("%s", mess_nt.get());
}

void LogInfo(bt_int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogInfo(cat, "%s", mess_nt.get());
}

void LogWarn(bt_int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogWarn(cat, "%s", mess_nt.get());
}

void LogError(bt_int cat, cstrref const& mess)
{
  PXCRT_ALLOCA_NTSTRING(mess_nt, mess);
  SDL_LogError(cat, "%s", mess_nt.get());
}

};
;
/* inline */
namespace pxcrt { namespace gl {

int check_error_enabled = 0;

}; };
;
/* inline */
#ifdef PXC_POSIX
extern "C" {
extern char **environ;
}
#endif
namespace pxcrt {

#ifdef PXC_POSIX
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#endif

pxcrt::pxcvarray<pxcrt::bt_string> pxc_argv;
pxcrt::pxcvarray<pxcrt::bt_string> pxc_environ;

using namespace pxcrt;

void io_environ_init()
{
/* windows is not supported yet */
#ifdef PXC_POSIX
  pxc_argv.clear();
  {
    char **p = ::pxcrt::process_argv;
    if (p != 0 && *p != 0) { ++p; }
    while (p != 0 && *p != 0) {
      const unsigned char *uent = reinterpret_cast<const unsigned char *>(*p);
      const pxcrt::bt_string s(uent, strlen(*p));
      pxc_argv.push_back(s);
      ++p;
    }
  }
  {
    char buf[32];
    int c = 0;
    while (true) {
      snprintf(buf, sizeof(buf), "PXC_ARG%d", c++);
      const char *ent = getenv(buf);
      if (ent == 0) {
	break;
      }
      const unsigned char *uent = reinterpret_cast<const unsigned char *>(ent);
      const pxcrt::bt_string s(uent, strlen(ent));
      pxc_argv.push_back(s);
      unsetenv(buf);
    }
  }
  {
    char **p = ::environ;
    while (*p != 0) {
      const unsigned char *uent = reinterpret_cast<const unsigned char *>(*p);
      const pxcrt::bt_string s(uent, strlen(*p));
      pxc_environ.push_back(s);
      ++p;
    }
  }
#endif
}

};
;
namespace numeric$n { namespace cast$n { 
/* global variables */
/* function definitions */
};}; /* namespace numeric::cast */
namespace text$n { namespace string$n { namespace serialize$n { 
ser_default$s::ser_default$s(){
}
void unit_to_string$f(pxcrt::bt_unit v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$42$li$r$(buf$);
}
void bool_to_string$f(pxcrt::bt_bool v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
 if (v$) {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(buf$ , pxcrt::bt_strlit("1"));
 } else {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(buf$ , pxcrt::bt_strlit("0"));
 }
}
void string_append_none$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$) {
}
pxcrt::bt_size_t token_length$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 {
  const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& ag$fe = (s$);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::bt_uchar *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   pxcrt::bt_uchar ch$ = ar$fe[i$];
   {
    if (ch$ == 123U) {
     if (i$ == pxcrt::bt_size_t((0LL))) {
      return ::text$n::string$n::serialize$n::find_brace_close$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(s$, pxcrt::bt_size_t(1LL), s$.size())) + pxcrt::bt_size_t(1LL);
     } else {
      return i$;
     }
    }
    if (ch$ == 125U || ch$ == 44U) {
     return i$;
    }
   }
  }
 }
 return s$.size();
}
pxcrt::bt_size_t find_brace_close$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 pxcrt::bt_size_t level$ = pxcrt::bt_size_t(1LL);
 {
  const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& ag$fe = (s$);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::bt_uchar *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   pxcrt::bt_uchar ch$ = ar$fe[i$];
   {
    if (ch$ == 125U) {
     if (--level$ == pxcrt::bt_size_t((0LL))) {
      return i$ + pxcrt::bt_size_t(1LL);
     }
    } else if (ch$ == 123U) {
     ++level$;
    }
   }
  }
 }
 return s$.size();
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > str_decode$f83(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& stok$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > r$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 pxcrt::minimal_decode(stok$ , r$);
 return r$;
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > string_parse_string_unescape$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 return ::text$n::string$n::serialize$n::string_parse_token$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$text$$string$$serialize$n$$str_decode$f83$r$(s$);
}
pxcrt::bt_bool parse_bool$f87(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& stok$) {
 if (stok$.empty() || eq_memcmp(stok$,::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("0")))) {
  return false;
 } else {
  return true;
 }
}
pxcrt::bt_bool string_parse_bool$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 return ::text$n::string$n::serialize$n::string_parse_token$f$p$meta$n$$bool$t$q$text$$string$$serialize$n$$parse_bool$f87$r$(s$);
}
pxcrt::bt_unit string_parse_unit$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 ::text$n::string$n::serialize$n::string_parse_token_skip$f(s$);
 return pxcrt::bt_unit();
}
pxcrt::bt_size_t string_parse_symbol_peek$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& stok$) {
 const pxcrt::bt_size_t sz$ = stok$.size();
 const pxcrt::bt_size_t toklen$ = ::text$n::string$n::serialize$n::token_length$f(stok$);
 stok$.decrement_back(sz$ - toklen$);
 return toklen$;
}
void string_parse_symbol$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& stok$, ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 const pxcrt::bt_size_t sz$ = stok$.size();
 const pxcrt::bt_size_t toklen$ = ::text$n::string$n::serialize$n::token_length$f(stok$);
 stok$.decrement_back(sz$ - toklen$);
 s$.increment_front(toklen$);
}
void string_parse_token_skip$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 const pxcrt::bt_size_t toklen$ = ::text$n::string$n::serialize$n::token_length$f(s$);
 s$.increment_front(toklen$);
}
};};}; /* namespace text::string::serialize */
namespace exception$n { 
void c_exception_append_to_string$f(const std::exception& ex$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& str$) {
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(str$ , pxcrt::c_exception_message(ex$));
 if (str$.size() > pxcrt::bt_size_t((0LL)) && pxcrt::bt_uchar(pxcrt::get_elem_value(str$,str$.size() - pxcrt::bt_size_t(1LL))) != 10U) {
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(str$ , 10U);
 }
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(str$ , pxcrt::c_exception_stack_trace(ex$));
}
void exception_append_to_string$f(const pxcrt::exception& ex$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& str$) {
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(str$ , pxcrt::exception_message(ex$));
 if (str$.size() > pxcrt::bt_size_t((0LL)) && pxcrt::bt_uchar(pxcrt::get_elem_value(str$,str$.size() - pxcrt::bt_size_t(1LL))) != 10U) {
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(str$ , 10U);
 }
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(str$ , pxcrt::exception_stack_trace(ex$));
}
}; /* namespace exception */
namespace equality$n { 
void hash_combine$f(pxcrt::bt_size_t& x$, pxcrt::bt_size_t v$) {
 x$ ^= v$ + pxcrt::bt_size_t(2654435769LL) + (x$ << 6LL) + (x$ >> 2LL);
}
}; /* namespace equality */
namespace io$n { namespace errno$n { 
int io_get_errno$f(const pxcrt::io& sys$) {
 return errno;
 return 0;
}
void io_set_errno$f(const pxcrt::io& sys$, int e$) {
 errno = e$;
}
void errno_t_append_to_string$f(int e$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& s$) {
 const char *s = 0;
if (e$ == E2BIG) { s = "E2BIG"; }
else if (e$ == EACCES) { s = "EACCES"; }
else if (e$ == EADDRINUSE) { s = "EADDRINUSE"; }
else if (e$ == EADDRNOTAVAIL) { s = "EADDRNOTAVAIL"; }
else if (e$ == EAFNOSUPPORT) { s = "EAFNOSUPPORT"; }
else if (e$ == EAGAIN) { s = "EAGAIN"; }
else if (e$ == EALREADY) { s = "EALREADY"; }
else if (e$ == EBADF) { s = "EBADF"; }
else if (e$ == EBADMSG) { s = "EBADMSG"; }
else if (e$ == EBUSY) { s = "EBUSY"; }
else if (e$ == ECANCELED) { s = "ECANCELED"; }
else if (e$ == ECHILD) { s = "ECHILD"; }
else if (e$ == ECONNABORTED) { s = "ECONNABORTED"; }
else if (e$ == ECONNREFUSED) { s = "ECONNREFUSED"; }
else if (e$ == ECONNRESET) { s = "ECONNRESET"; }
else if (e$ == EDEADLK) { s = "EDEADLK"; }
else if (e$ == EDESTADDRREQ) { s = "EDESTADDRREQ"; }
else if (e$ == EDOM) { s = "EDOM"; }
else if (e$ == EDQUOT) { s = "EDQUOT"; }
else if (e$ == EEXIST) { s = "EEXIST"; }
else if (e$ == EFAULT) { s = "EFAULT"; }
else if (e$ == EFBIG) { s = "EFBIG"; }
else if (e$ == EHOSTUNREACH) { s = "EHOSTUNREACH"; }
else if (e$ == EIDRM) { s = "EIDRM"; }
else if (e$ == EILSEQ) { s = "EILSEQ"; }
else if (e$ == EINPROGRESS) { s = "EINPROGRESS"; }
else if (e$ == EINTR) { s = "EINTR"; }
else if (e$ == EINVAL) { s = "EINVAL"; }
else if (e$ == EIO) { s = "EIO"; }
else if (e$ == EISCONN) { s = "EISCONN"; }
else if (e$ == EISDIR) { s = "EISDIR"; }
else if (e$ == ELOOP) { s = "ELOOP"; }
else if (e$ == EMFILE) { s = "EMFILE"; }
else if (e$ == EMLINK) { s = "EMLINK"; }
else if (e$ == EMSGSIZE) { s = "EMSGSIZE"; }
else if (e$ == EMULTIHOP) { s = "EMULTIHOP"; }
else if (e$ == ENAMETOOLONG) { s = "ENAMETOOLONG"; }
else if (e$ == ENETDOWN) { s = "ENETDOWN"; }
else if (e$ == ENETRESET) { s = "ENETRESET"; }
else if (e$ == ENETUNREACH) { s = "ENETUNREACH"; }
else if (e$ == ENFILE) { s = "ENFILE"; }
else if (e$ == ENOBUFS) { s = "ENOBUFS"; }
else if (e$ == ENODATA) { s = "ENODATA"; }
else if (e$ == ENODEV) { s = "ENODEV"; }
else if (e$ == ENOENT) { s = "ENOENT"; }
else if (e$ == ENOEXEC) { s = "ENOEXEC"; }
else if (e$ == ENOLCK) { s = "ENOLCK"; }
else if (e$ == ENOLINK) { s = "ENOLINK"; }
else if (e$ == ENOMEM) { s = "ENOMEM"; }
else if (e$ == ENOMSG) { s = "ENOMSG"; }
else if (e$ == ENOPROTOOPT) { s = "ENOPROTOOPT"; }
else if (e$ == ENOSPC) { s = "ENOSPC"; }
else if (e$ == ENOSR) { s = "ENOSR"; }
else if (e$ == ENOSTR) { s = "ENOSTR"; }
else if (e$ == ENOSYS) { s = "ENOSYS"; }
else if (e$ == ENOTCONN) { s = "ENOTCONN"; }
else if (e$ == ENOTDIR) { s = "ENOTDIR"; }
else if (e$ == ENOTEMPTY) { s = "ENOTEMPTY"; }
else if (e$ == ENOTSOCK) { s = "ENOTSOCK"; }
else if (e$ == ENOTSUP) { s = "ENOTSUP"; }
else if (e$ == ENOTTY) { s = "ENOTTY"; }
else if (e$ == ENXIO) { s = "ENXIO"; }
else if (e$ == EOPNOTSUPP) { s = "EOPNOTSUPP"; }
else if (e$ == EOVERFLOW) { s = "EOVERFLOW"; }
else if (e$ == EPERM) { s = "EPERM"; }
else if (e$ == EPIPE) { s = "EPIPE"; }
else if (e$ == EPROTO) { s = "EPROTO"; }
else if (e$ == EPROTONOSUPPORT) { s = "EPROTONOSUPPORT"; }
else if (e$ == EPROTOTYPE) { s = "EPROTOTYPE"; }
else if (e$ == ERANGE) { s = "ERANGE"; }
else if (e$ == EROFS) { s = "EROFS"; }
else if (e$ == ESPIPE) { s = "ESPIPE"; }
else if (e$ == ESRCH) { s = "ESRCH"; }
else if (e$ == ESTALE) { s = "ESTALE"; }
else if (e$ == ETIME) { s = "ETIME"; }
else if (e$ == ETIMEDOUT) { s = "ETIMEDOUT"; }
else if (e$ == ETXTBSY) { s = "ETXTBSY"; }
else if (e$ == EWOULDBLOCK) { s = "EWOULDBLOCK"; }
else if (e$ == EXDEV) { s = "EXDEV"; }
if (s != 0) {
s$.append(reinterpret_cast<const unsigned char *>(s), std::strlen(s));
} else {
char buf[32];
int len = snprintf(buf, sizeof(buf), "errno(%d)",   static_cast<int>(e$));
s$.append(reinterpret_cast<unsigned char *>(buf), len);
};
}
void errno_t_check$f(int e$) {
 if (e$ != 0) {
  PXC_THROW(::exception$n::unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(e$)).get_crange())));
 }
}
};}; /* namespace io::errno */
namespace io$n { namespace time$n { 
pxcrt::bt_double io_gettimeofday_double$f(const pxcrt::io& iop$) {
 ::timeval tv$ = pxcrt::gettimeofday(iop$);
 const pxcrt::bt_double rv$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$double$t$q$io$$time$n$$time_t$s$r$(tv$.tv_sec) + ::numeric$n::cast$n::static_cast$f$p$meta$n$$double$t$q$io$$time$n$$suseconds_t$s$r$(tv$.tv_usec) / 1000000.0;
 return rv$;
}
};}; /* namespace io::time */
namespace io$n { namespace file$n { 
::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ io_open_st$f(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$, int flags$, pxcrt::mode_t  md$) {
 ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ r$;
 pxcrt::bt_int fd$ = pxcrt::io_open_fd(iop$ , fn$ , flags$ , md$);
 if (fd$ >= (0LL)) {
  (r$.value$$l(pxcrt::io_make_file_st(iop$ , fd$)));
 } else {
  (r$.errno$$l(::io$n::errno$n::io_get_errno$f(iop$)));
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_mt$s$r$ io_open_mt$f(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$, int flags$, pxcrt::mode_t  md$) {
 ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_mt$s$r$ r$;
 pxcrt::bt_int fd$ = pxcrt::io_open_fd(iop$ , fn$ , flags$ , md$);
 if (fd$ >= (0LL)) {
  (r$.value$$l(pxcrt::io_make_file_mt(iop$ , fd$)));
 } else {
  (r$.errno$$l(::io$n::errno$n::io_get_errno$f(iop$)));
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ file_read$f(const pxcrt::file& f$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$, pxcrt::bt_size_t len$) {
 ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ r$;
 const int e$ = pxcrt::file_read_impl(f$ , buf$ , len$);
 if (e$ != 0) {
  (r$.errno$$l(e$));
 } else {
  (r$.value$$l(len$));
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ file_write$f(const pxcrt::file& f$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
 ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ r$;
 pxcrt::bt_size_t len$ = pxcrt::bt_size_t((0LL));
 const int e$ = pxcrt::file_write_impl(f$ , buf$ , len$);
 if (e$ != 0) {
  (r$.errno$$l(e$));
 } else {
  (r$.value$$l(len$));
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$io$$file$n$$off_t$s$r$ file_lseek$f(const pxcrt::file& f$, pxcrt::off_t offset$, int whence$) {
 ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$off_t$s$r$ r$;
 const int e$ = pxcrt::file_lseek_impl(f$ , offset$ , whence$);
 if (e$ != 0) {
  (r$.errno$$l(e$));
 } else {
  (r$.value$$l(offset$));
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ file_read_all$f(const pxcrt::file& f$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
 pxcrt::bt_size_t rlen$ = pxcrt::bt_size_t((0LL));
 while (true) {
  const pxcrt::bt_size_t len$ = pxcrt::bt_size_t(16384LL);
  const ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ r$ = ::io$n::file$n::file_read$f(f$ , buf$ , len$);
  {
   ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ const& ag$fe = (r$);
   if (ag$fe.get_$e() == ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$::value$$e) {
    const pxcrt::bt_size_t rl$ = ag$fe.value$$r();
    {
     if (rl$ == pxcrt::bt_size_t((0LL))) {
      break;
     }
     rlen$ += rl$;
    }
   } else {
    return r$;
   }
  }
 }
 ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ r$;
 (r$.value$$l(rlen$));
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ file_write_all$f(const pxcrt::file& f$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
 pxcrt::bt_size_t len_r$ = pxcrt::bt_size_t((0LL));
 pxcrt::bt_size_t curpos$ = pxcrt::bt_size_t((0LL));
 pxcrt::bt_size_t endpos$ = buf$.size();
 while (curpos$ != endpos$) {
  const ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ r$ = ::io$n::file$n::file_write$f(f$ , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(buf$, curpos$, endpos$));
  if ((r$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$::errno$$e)) {
   return r$;
  }
  const pxcrt::bt_size_t wlen$ = (::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$meta$n$$size_t$t$r$$r$(r$));
  if (wlen$ == pxcrt::bt_size_t((0LL))) {
   break;
  }
  curpos$ += wlen$;
  len_r$ += wlen$;
 }
 ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ r$;
 (r$.value$$l(len_r$));
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$ io_read_file$f(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$) {
 ::io$n::errno$n::errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$ r$;
 const ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ f$ = ::io$n::file$n::io_open$f$p$m$ll$p$m$ll$p$io$n$$io$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$io$$file$n$$open_flags_t$s$q$0$li$r$$r$$r$(iop$ , fn$ , O_RDONLY);
 {
  ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ const& ag$fe = (f$);
  if (ag$fe.get_$e() == ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$::errno$$e) {
   const int err$ = ag$fe.errno$$r();
   {
    (r$.errno$$l(err$));
   }
  } else {
   const pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > buf$ = ::pointer$n::make_ptr$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$m$ll$r$();
   const ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ ra$ = ::io$n::file$n::file_read_all$f((::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$io$$file$n$$file_st$s$r$$r$(f$)) , ((pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > >(buf$))->value));
   {
    ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ const& ag$fe = (ra$);
    if (ag$fe.get_$e() == ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$::errno$$e) {
     const int err$ = ag$fe.errno$$r();
     {
      (r$.errno$$l(err$));
     }
    } else {
     (r$.value$$l(buf$));
    }
   }
  }
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ io_write_file$f(const pxcrt::io& iop$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fn$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
 ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$ r$;
 const ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ f$ = ::io$n::file$n::io_open$f$p$m$ll$p$m$ll$p$io$n$$io$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$io$$file$n$$open_flags_t$s$q$0$li$r$$q$m$ll$p$io$$file$n$$mode_t$s$q$0$li$r$$r$$r$(iop$ , fn$ , O_WRONLY | O_CREAT | O_TRUNC , S_IRWXU | S_IRWXG | S_IRWXO);
 {
  ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ const& ag$fe = (f$);
  if (ag$fe.get_$e() == ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$::errno$$e) {
   const int err$ = ag$fe.errno$$r();
   {
    (r$.errno$$l(err$));
   }
  } else {
   r$ = ::io$n::file$n::file_write_all$f((::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$io$$file$n$$file_st$s$r$$r$(f$)) , buf$);
  }
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$ io_pipe$f(const pxcrt::io& sys$) {
 ::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$ r$;
 int err$ = 0;
 ::pxcrt::pxcvarray< pxcrt::file_mt > v$ = pxcrt::io_pipe_internal(sys$ , err$);
 if (err$ != 0) {
  (r$.errno$$l(err$));
 } else {
  (r$.value$$l(::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$((::pxcrt::pxcvarray< pxcrt::file_mt >::guard_ref< ::pxcrt::pxcvarray< pxcrt::file_mt > > (v$).get())[pxcrt::bt_size_t((0LL))] , (::pxcrt::pxcvarray< pxcrt::file_mt >::guard_ref< ::pxcrt::pxcvarray< pxcrt::file_mt > > (v$).get())[pxcrt::bt_size_t(1LL)])));
 }
 return r$;
}
};}; /* namespace io::file */
namespace io$n { namespace process$n { 
void io__exit$f(const pxcrt::io& sys$, pxcrt::bt_int st$) {
 pxcrt::_exit_internal(sys$ , st$);
}
void exit$f(pxcrt::bt_int st$) {
 pxcrt::exit_internal(pxcrt::io_system , st$);
}
void io_abort$f(const pxcrt::io& sys$) {
 pxcrt::abort_internal(sys$);
}
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$ io_fork$f(const pxcrt::io& sys$) {
 const pxcrt::pid_t pid$ = pxcrt::fork_internal(sys$);
 ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$ r$;
 if (pid$ < pxcrt::pid_t((0LL))) {
  (r$.errno$$l(::io$n::errno$n::io_get_errno$f(sys$)));
 } else {
  (r$.value$$l(pid$));
 }
 return r$;
}
pipe_process$s::pipe_process$s(pxcrt::pid_t pid0$, const pxcrt::file_mt& file0$) : pid$(pid0$), file$(file0$) {
}
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pipe_process$s$r$ io_popen$f(const pxcrt::io& sys$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& command$, const ::pxcrt::bt_cslice< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& argv$, pxcrt::bt_bool for_write$, pxcrt::bt_bool search_path$) {
 ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pipe_process$s$r$ r$;
 ::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$ p$ = ::io$n::file$n::io_pipe$f(sys$);
 {
  ::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$ const& ag$fe = (p$);
  if (ag$fe.get_$e() == ::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::errno$$e) {
   const int e$ = ag$fe.errno$$r();
   {
    (r$.errno$$l(e$));
    return r$;
   }
  }
 }
 const ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$ rfork$ = ::io$n::process$n::io_fork$f(sys$);
 {
  ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$ const& ag$fe = (rfork$);
  if (ag$fe.get_$e() == ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$::errno$$e) {
   const int e$ = ag$fe.errno$$r();
   {
    (r$.errno$$l(e$));
    return r$;
   }
  }
 }
 const pxcrt::pid_t pid$ = (::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$io$$process$n$$pid_t$s$r$$r$(rfork$));
 if (pid$ == pxcrt::pid_t((0LL))) {
  try {
   int err$ = int();
   if (for_write$) {
    err$ = pxcrt::dup2_internal(sys$ , (::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$$r$(p$)).first$ , pxcrt::io_stdin(sys$));
   } else {
    err$ = pxcrt::dup2_internal(sys$ , (::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$$r$(p$)).second$ , pxcrt::io_stdout(sys$));
   }
   (p$.errno$$l(0));
   if (err$ == 0) {
    if (search_path$) {
     pxcrt::execvp(sys$ , command$ , argv$);
    } else {
     pxcrt::execv(sys$ , command$ , argv$);
    }
   }
  } catch (const std::exception& ex$) {
  }
  ::io$n::process$n::io__exit$f(sys$ , 127LL);
 }
 if (for_write$) {
  (r$.value$$l(::io$n::process$n::pipe_process$s(pid$ , (::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$$r$(p$)).second$)));
 } else {
  (r$.value$$l(::io$n::process$n::pipe_process$s(pid$ , (::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$$r$(p$)).first$)));
 }
 return r$;
}
wait_t$s::wait_t$s() : pid$(), status$(){
 /* pid$ */;
 /* status$ */;
}
wait_t$s::wait_t$s(pxcrt::pid_t pid$, int status$) : pid$(pid$), status$(status$){
 /* pid$ */;
 /* status$ */;
}
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$wait_t$s$r$ io_wait$f(const pxcrt::io& sys$, int& st_r$) {
 int st$ = int();
 const pxcrt::pid_t pid$ = pxcrt::wait_internal(sys$ , st$);
 ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$wait_t$s$r$ r$;
 if (pid$ < pxcrt::pid_t((0LL))) {
  (r$.errno$$l(::io$n::errno$n::io_get_errno$f(sys$)));
 } else {
  (r$.value$$l(::io$n::process$n::wait_t$s(pid$ , st$)));
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$wait_t$s$r$ io_waitpid$f(const pxcrt::io& sys$, pxcrt::pid_t p$, int opt$) {
 int st$ = int();
 const pxcrt::pid_t pid$ = pxcrt::waitpid_internal(sys$ , p$ , st$ , opt$);
 ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$wait_t$s$r$ r$;
 if (pid$ < pxcrt::pid_t((0LL))) {
  (r$.errno$$l(::io$n::errno$n::io_get_errno$f(sys$)));
 } else {
  (r$.value$$l(::io$n::process$n::wait_t$s(pid$ , st$)));
 }
 return r$;
}
::io$n::errno$n::errno_or_value$v$p$io$$process$n$$status_t$s$r$ io_shell_exec$f(const pxcrt::io& sys$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& cmd$) {
 const pxcrt::bt_int st$ = pxcrt::shell_exec_internal(sys$ , cmd$);
 ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$status_t$s$r$ r$;
 if (st$ < (0LL)) {
  (r$.errno$$l(::io$n::errno$n::io_get_errno$f(sys$)));
 } else {
  (r$.value$$l(::numeric$n::cast$n::static_cast$f$p$io$$process$n$$status_t$s$q$meta$n$$int$t$r$(st$)));
 }
 return r$;
}
};}; /* namespace io::process */
namespace thread$n { namespace queue$n { 
void task_queue$s::push$f(const ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$& e$) {
 ::thread$n::queue$n::queue_push_notify$f(shared$ , e$);
}
task_queue$s::~task_queue$s() PXC_NOTHROW {
 try {
  ::thread$n::queue$n::queue_thread_stop$f(shared$ , 1LL);
 } catch (...) { ::abort(); }
}
void task_queue$s::construct$f(pxcrt::bt_size_t num_thrs$) {
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < num_thrs$; ++i$) {
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ >,::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ >(thrs$ , ::thread$n::make_thread_ptr$f$p$thread$$queue$n$$queue_thread_main$f$r$(shared$));
 }
}
task_queue$s::task_queue$s(pxcrt::bt_size_t num_thrs$) : shared$(::pointer$n::make_tptr$f$p$thread$$queue$n$$task_queue_shared$s$q$m$ll$r$()), thrs$() {
 construct$f(num_thrs$);
}
task_queue_shared$s::task_queue_shared$s() : queue$(), stop_thread$((0LL)) {
}
::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$ queue_wait_pop$f(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$) {
 ::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$ ent$;
 pxcrt::lock_guard< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > lck$((tq$));
 ::thread$n::queue$n::task_queue_shared$s& q$ = ((lck$)->value);
 while (true) {
  const pxcrt::bt_int sf$ = q$.stop_thread$;
  const pxcrt::bt_bool em$ = q$.queue$.empty();
  if (sf$ < (0LL) || (sf$ > (0LL) && em$)) {
   break;
  }
  if (q$.queue$.empty()) {
   lck$.wait();
   continue;
  }
  (ent$.some$$l(::pxcrt::array_pop_front< ::pxcrt::pxcdeque< ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ > >(q$.queue$)));
  break;
 }
 return ent$;
}
void queue_thread_main$f(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$) {
 while (true) {
  ::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$ ent$ = ::thread$n::queue$n::queue_wait_pop$f(tq$);
  if ((ent$.get_$e() == ::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::none$$e)) {
   break;
  }
  (::operator$n::union_field$f$p$some$ls$q$algebraic$n$$option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$$r$(ent$)).__call$f();
 }
}
void queue_thread_stop$f(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$, pxcrt::bt_int mode$) {
 pxcrt::lock_guard< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > lck$((tq$));
 (((lck$)->value)).stop_thread$ = mode$;
 lck$.notify_all();
}
void queue_push_notify$f(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$, const ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$& ep$) {
 pxcrt::lock_guard< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > lck$((tq$));
 ::thread$n::queue$n::task_queue_shared$s& q$ = ((lck$)->value);
 const pxcrt::bt_bool need_notify$ = q$.queue$.empty();
 ::pxcrt::array_push_back< ::pxcrt::pxcdeque< ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ >,::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ >(q$.queue$ , ep$);
 if (need_notify$) {
  lck$.notify_one();
 }
}
};}; /* namespace thread::queue */
namespace pgl3d$n { namespace scene_node$n { 
joint_id_type$s::joint_id_type$s() : bo_id$(pxcrt::bt_uint((0LL))), vs_id$(-1LL) {
}
scene_node$s::scene_node$s(const ::pgl3d$n::scene_node$n::joint_id_type$s& joint_id0$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& trans0$) : trans$(trans0$), joint_id$(joint_id0$), children$() {
}
::pgl3d$n::scene_node$n::scene_node$s node_factory$s::make_node_by_id$f(const ::pgl3d$n::scene_node$n::joint_id_type$s& joint_id$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& trans$) const {
 ::pgl3d$n::scene_node$n::scene_node$s sn$((joint_id$), (trans$));
 if (joint_id$.vs_id$ >= (0LL)) {
  ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_buffer_info$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_buffer_info$s > > t0((binfo$));
  const ::pgl3d$n::scene_node$n::node_buffer_info$s& nbi$ = (t0.get())[pxcrt::bt_size_t(joint_id$.bo_id$)];
  ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_vs_info$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_vs_info$s > > t1((nbi$.vs_arr$));
  const ::pgl3d$n::scene_node$n::node_vs_info$s& nvi$ = (t1.get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(joint_id$.vs_id$)];
  {
   const ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_joint_info$s >& ag$fe = (nvi$.joints$);
   ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_joint_info$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_joint_info$s > > ag$fg(ag$fe);
   const size_t sz$fe = ag$fe.size();
   const ::pgl3d$n::scene_node$n::node_joint_info$s *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    const ::pgl3d$n::scene_node$n::node_joint_info$s& nji$ = ar$fe[i$];
    {
     const ::pgl3d$n::scene_node$n::scene_node$s csn$ = make_node_by_id$f(nji$.joint_id$ , nji$.trans$);
     ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >,::pgl3d$n::scene_node$n::scene_node$s >(sn$.children$ , csn$);
    }
   }
  }
 }
 return sn$;
}
::pgl3d$n::scene_node$n::scene_node$s node_factory$s::make_node_by_name$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& trans$) const {
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > t0((name_to_id$));
 const pxcrt::range_base< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ >, true > rng$ = (t0.get()).equal_crange(::pxcrt::pxcvarray< pxcrt::bt_uchar >(name$));
 return make_node_by_id$f(((rng$).cderef()) , trans$);
}
::pgl3d$n::scene_node$n::joint_id_type$s node_factory$s::get_joint_id_by_name$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > t0((name_to_id$));
 const pxcrt::range_base< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ >, true > rng$ = (t0.get()).equal_crange(::pxcrt::pxcvarray< pxcrt::bt_uchar >(name$));
 return ((rng$).cderef());
}
node_factory$s::node_factory$s() : binfo$(), name_to_id$(){
 /* binfo$ */;
 /* name_to_id$ */;
}
node_factory$s::node_factory$s(::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_buffer_info$s > binfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pgl3d$n::scene_node$n::joint_id_type$s,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > name_to_id$) : binfo$(binfo$), name_to_id$(name_to_id$){
 /* binfo$ */;
 /* name_to_id$ */;
}
node_buffer_info$s::node_buffer_info$s() : vs_arr$(){
 /* vs_arr$ */;
}
node_buffer_info$s::node_buffer_info$s(::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_vs_info$s > vs_arr$) : vs_arr$(vs_arr$){
 /* vs_arr$ */;
}
node_vs_info$s::node_vs_info$s() : joints$(){
 /* joints$ */;
}
node_vs_info$s::node_vs_info$s(::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_joint_info$s > joints$) : joints$(joints$){
 /* joints$ */;
}
node_joint_info$s::node_joint_info$s() : joint_id$(), trans$(){
 /* joint_id$ */;
 /* trans$ */;
}
node_joint_info$s::node_joint_info$s(::pgl3d$n::scene_node$n::joint_id_type$s joint_id$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans$) : joint_id$(joint_id$), trans$(trans$){
 /* joint_id$ */;
 /* trans$ */;
}
};}; /* namespace pgl3d::scene_node */
namespace pointer$n { namespace raw_unsafe$n { 
pxcrt::crawptr< pxcrt::bt_char >::type varray_c_str$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$) {
 const pxcrt::bt_size_t sz$ = x$.size();
 x$.reserve(sz$ + pxcrt::bt_size_t(1LL));
 const pxcrt::rawptr< pxcrt::bt_uchar >::type p$ = pxcrt::array_to_rawptr< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >(x$);
 (pxcrt::rawptr___deref< pxcrt::bt_uchar >(((::operator$n::add$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$r$(p$ , sz$))))) = pxcrt::bt_uchar((0LL));
 return pxcrt::crawptr_to_ccharptr< pxcrt::bt_uchar >(pxcrt::array_to_crawptr< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >(x$));
}
};}; /* namespace pointer::raw_unsafe */
namespace pgl3d$n { namespace glconf$n { 
void sdllog_impl$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 SDL2::LogInfo(::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$int$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_LOG_CATEGORY_APPLICATION) , s$);
}
};}; /* namespace pgl3d::glconf */
namespace pgl3d$n { namespace glvertex$n { 
node_joint$s::node_joint$s() : joint_name$(), trans$(){
 /* joint_name$ */;
 /* trans$ */;
}
node_joint$s::node_joint$s(::pxcrt::pxcvarray< pxcrt::bt_uchar > joint_name$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans$) : joint_name$(joint_name$), trans$(trans$){
 /* joint_name$ */;
 /* trans$ */;
}
void float_slice_set_int$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& s$, pxcrt::bt_int v$) {
 if (s$.size() < pxcrt::bt_size_t(1LL)) {
  return;
 }
 const pxcrt::rawptr< pxcrt::bt_int >::type t0 = pxcrt::size_t_to_rawptr< pxcrt::bt_int >(pxcrt::rawptr_to_size_t< pxcrt::bt_float >(pxcrt::slice_to_rawptr< pxcrt::bt_float >(s$)));
 const ::pxcrt::bt_slice< pxcrt::bt_int > si$ = pxcrt::rawptr_to_slice< pxcrt::bt_int >(t0 , pxcrt::bt_size_t(1LL));
 si$[pxcrt::bt_size_t((0LL))] = v$;
}
void vertices$s::prepare_multiple_copies$f(pxcrt::bt_bool enable_copying_instancing$) {
 vertex_values_size_per_copy$ = vertex_values$.size();
 elements_size_per_copy$ = elements$.size();
 num_copies$ = pxcrt::bt_size_t(1LL);
 if (!has_instance_id$ || !1LL || !enable_copying_instancing$) {
  return;
 }
 num_copies$ = ::ordered$n::min$f$p$meta$n$$size_t$t$r$(num_copies_hint$ , pxcrt::bt_size_t(8LL));
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("vertices::prepare_multiple_copies") , num_copies$);
 const pxcrt::bt_size_t num_vertices$ = vertex_values$.size() / num_float_per_vertex$;
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_float >,pxcrt::bt_float >(vertex_values$ , vertex_values_size_per_copy$ * num_copies$ , pxcrt::bt_float());
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , elements_size_per_copy$ * num_copies$ , pxcrt::bt_uint());
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t(1LL); i$ < num_copies$; ++i$) {
  const pxcrt::bt_size_t vi$ = vertex_values_size_per_copy$ * i$;
  const pxcrt::bt_size_t ei$ = elements_size_per_copy$ * i$;
  for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < vertex_values_size_per_copy$; ++j$) {
   vertex_values$[vi$ + j$] = vertex_values$[j$];
  }
  for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < num_vertices$; ++j$) {
   (::pxcrt::pxcvarray< pxcrt::bt_float >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_float > > (vertex_values$).get())[vi$ + j$ * num_float_per_vertex$] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$size_t$t$r$(i$);
  }
  for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < elements_size_per_copy$; ++j$) {
   pxcrt::bt_uint e$ = elements$[j$];
   if (e$ != 4294967295U) {
    e$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(num_vertices$ * i$);
   }
   elements$[ei$ + j$] = e$;
  }
 }
}
void vertices$s::push_joint$f(const ::pgl3d$n::glvertex$n::node_joint$s& e$) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::glvertex$n::node_joint$s >,::pgl3d$n::glvertex$n::node_joint$s >(joints$ , e$);
}
vertices$s::vertices$s(pxcrt::bt_size_t num_float_per_vertex0$) : num_float_per_vertex$(num_float_per_vertex0$), vertex_values$(), elements$(), positions$(), joints$(), num_copies_hint$(pxcrt::bt_size_t(1LL)), has_instance_id$(), num_copies$(pxcrt::bt_size_t(1LL)), vertex_values_size_per_copy$(), elements_size_per_copy$() {
}
};}; /* namespace pgl3d::glvertex */
namespace io$n { namespace text$n { 
pxcrt::bt_bool is_space_or_tab$f(pxcrt::bt_uchar ch$) {
 return ch$ == 32U || ch$ == 9U;
}
};}; /* namespace io::text */
namespace pgl3d$n { namespace wfobj$n { 
wfobject$s::wfobject$s() : mtllib$(), v$(), vn$(), vt$(), groups$(){
 /* mtllib$ */;
 /* v$ */;
 /* vn$ */;
 /* vt$ */;
 /* groups$ */;
}
wfobject$s::wfobject$s(::pxcrt::pxcvarray< pxcrt::bt_uchar > mtllib$, ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type > v$, ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type > vn$, ::pxcrt::pxcvarray< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type > vt$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > groups$) : mtllib$(mtllib$), v$(v$), vn$(vn$), vt$(vt$), groups$(groups$){
 /* mtllib$ */;
 /* v$ */;
 /* vn$ */;
 /* vt$ */;
 /* groups$ */;
}
wfgroup$s::wfgroup$s() : usemtl$(), f$(){
 /* usemtl$ */;
 /* f$ */;
}
wfgroup$s::wfgroup$s(::pxcrt::pxcvarray< pxcrt::bt_uchar > usemtl$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > > f$) : usemtl$(usemtl$), f$(f$){
 /* usemtl$ */;
 /* f$ */;
}
wfelement$s::wfelement$s() : vertex$(), normal$(), texcoord$(){
 /* vertex$ */;
 /* normal$ */;
 /* texcoord$ */;
}
wfelement$s::wfelement$s(pxcrt::bt_uint vertex$, pxcrt::bt_uint normal$, pxcrt::bt_uint texcoord$) : vertex$(vertex$), normal$(normal$), texcoord$(texcoord$){
 /* vertex$ */;
 /* normal$ */;
 /* texcoord$ */;
}
void parse_token$f8(::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& elems_work$4$pgl3d$$wfobj$ns1, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& tok$) {
 const ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,3LL > earr$ = ::container$n::array$n::make_farray_split$f$p$3$li$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(tok$ , 47U);
 ::pgl3d$n::wfobj$n::wfelement$s e$;
 e$.vertex$ = ::text$n::string$n::serialize$n::from_string$f$p$meta$n$$uint$t$r$(earr$[pxcrt::bt_size_t((0LL))]);
 e$.normal$ = ::text$n::string$n::serialize$n::from_string$f$p$meta$n$$uint$t$r$(earr$[pxcrt::bt_size_t(1LL)]);
 e$.texcoord$ = ::text$n::string$n::serialize$n::from_string$f$p$meta$n$$uint$t$r$(earr$[pxcrt::bt_size_t(2LL)]);
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >,::pgl3d$n::wfobj$n::wfelement$s >(elems_work$4$pgl3d$$wfobj$ns1 , e$);
}
void parse_line$f4(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > >& p$4$pgl3d$$wfobj$ns1, ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& elems_work$4$pgl3d$$wfobj$ns1, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >& g$4$pgl3d$$wfobj$ns1, ::pxcrt::bt_cslice< pxcrt::bt_uchar > line$) {
 if (line$.size() >= pxcrt::bt_size_t(2LL)) {
  const pxcrt::bt_uchar ch0$ = line$[pxcrt::bt_size_t((0LL))];
  const pxcrt::bt_uchar ch1$ = line$[pxcrt::bt_size_t(1LL)];
  if (ch0$ == 118U && ch1$ == 32U) {
   line$.increment_front(pxcrt::bt_size_t(2LL));
   const ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,3LL > arr$ = ::container$n::array$n::make_farray_split$f$p$3$li$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(line$ , 32U);
   pxcrt::glmpx::tvec3< pxcrt::bt_float >::type vtx$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
   vtx$.x = ::text$n::string$n::serialize$n::from_string$f$p$meta$n$$float$t$r$(arr$[pxcrt::bt_size_t((0LL))]);
   vtx$.y = ::text$n::string$n::serialize$n::from_string$f$p$meta$n$$float$t$r$(arr$[pxcrt::bt_size_t(1LL)]);
   vtx$.z = ::text$n::string$n::serialize$n::from_string$f$p$meta$n$$float$t$r$(arr$[pxcrt::bt_size_t(2LL)]);
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >,pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > >(p$4$pgl3d$$wfobj$ns1))->value)).v$ , vtx$);
  }
  if (ch0$ == 102U && ch1$ == 32U) {
   line$.increment_front(pxcrt::bt_size_t(2LL));
   elems_work$4$pgl3d$$wfobj$ns1.clear();
   ::container$n::array$n::split_foreach$f$p$pgl3d$$wfobj$n$$parse_token$f8$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(elems_work$4$pgl3d$$wfobj$ns1 , line$ , 32U);
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > >,::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >(g$4$pgl3d$$wfobj$ns1))->value)).f$ , elems_work$4$pgl3d$$wfobj$ns1);
  }
 }
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > wfobject_read$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& str$) {
 const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > p$4$pgl3d$$wfobj$ns1 = ::pointer$n::make_ptr$f$p$pgl3d$$wfobj$n$$wfobject$s$q$m$ll$r$();
 const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > g$4$pgl3d$$wfobj$ns1 = ::pointer$n::make_ptr$f$p$pgl3d$$wfobj$n$$wfgroup$s$q$m$ll$r$();
 ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > elems_work$4$pgl3d$$wfobj$ns1 = ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >();
 ::container$n::array$n::split_foreach$f$p$pgl3d$$wfobj$n$$parse_line$f4$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(p$4$pgl3d$$wfobj$ns1, elems_work$4$pgl3d$$wfobj$ns1, g$4$pgl3d$$wfobj$ns1 , str$ , 10U);
 (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > >(p$4$pgl3d$$wfobj$ns1))->value)).groups$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("")) , g$4$pgl3d$$wfobj$ns1);
 return p$4$pgl3d$$wfobj$ns1;
}
void wfobject_test$f() {
 const pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > str$ = (::operator$n::union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(::io$n::file$n::io_read_file$f(pxcrt::io_system , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("untitled.obj")))));
 ::pgl3d$n::wfobj$n::wfobject_read$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (((pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > >(str$))->value)).get_crange()));
}
};}; /* namespace pgl3d::wfobj */
namespace pgl3d$n { namespace glgeometry$n { 
vertex_attr$s::vertex_attr$s() : pos$(), nor$(), tan$(), uvw$() {
}
pxcrt::bt_uint rand_generator$s::generate$f() {
 pxcrt::bt_uint rv$ = seed$;
 seed$ = seed$ * 1664525U + 1013904223U;
 return rv$;
}
pxcrt::bt_float rand_generator$s::generate_float$f() {
 return ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$uint$t$r$(generate$f()) / pxcrt::bt_float(4294967296.0);
}
rand_generator$s::rand_generator$s(pxcrt::bt_uint seed0$) : seed$(seed0$) {
}
mesh_index$s::mesh_index$s() : x$(), y$(), z$(), w$(){
 /* x$ */;
 /* y$ */;
 /* z$ */;
 /* w$ */;
}
mesh_index$s::mesh_index$s(pxcrt::bt_size_t x$, pxcrt::bt_size_t y$, pxcrt::bt_size_t z$, pxcrt::bt_size_t w$) : x$(x$), y$(y$), z$(z$), w$(w$){
 /* x$ */;
 /* y$ */;
 /* z$ */;
 /* w$ */;
}
pxcrt::bt_float pi_float$f() {
 return pxcrt::bt_float(3.1415926535897932384626433832795);
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type polygon_center$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$) {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
 {
  const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (poly$);
  const size_t sz$fe = ag$fe.size();
  const ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pgl3d$n::glgeometry$n::vertex_attr$s& p$ = ar$fe[i$];
   {
    (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(c$ , p$.pos$));
   }
  }
 }
 (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(c$ , ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$size_t$t$r$(poly$.size())));
 return c$;
}
pxcrt::bt_float polygon_radius$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$) {
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c$ = ::pgl3d$n::glgeometry$n::polygon_center$f(poly$);
 pxcrt::bt_float r$ = pxcrt::bt_float(0.0);
 {
  const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (poly$);
  const size_t sz$fe = ag$fe.size();
  const ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pgl3d$n::glgeometry$n::vertex_attr$s& p$ = ar$fe[i$];
   {
    r$ = ::ordered$n::max$f$p$meta$n$$float$t$r$(r$ , pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(p$.pos$ , c$))));
   }
  }
 }
 return r$;
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal_from_poly$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$) {
 return glm::normalize< pxcrt::bt_float >(::pgl3d$n::glgeometry$n::normal_scale_from_poly$f(poly$));
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type poly_cross_at$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, pxcrt::bt_size_t i$) {
 const pxcrt::bt_size_t sz$ = poly$.size();
 const pxcrt::bt_size_t i1$ = (i$ + pxcrt::bt_size_t(1LL)) >= sz$ ? (i$ + pxcrt::bt_size_t(1LL) - sz$) : (i$ + pxcrt::bt_size_t(1LL));
 const pxcrt::bt_size_t i2$ = (i$ + pxcrt::bt_size_t(2LL)) >= sz$ ? (i$ + pxcrt::bt_size_t(2LL) - sz$) : (i$ + pxcrt::bt_size_t(2LL));
 return glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[i1$].pos$ , poly$[i$].pos$)) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[i2$].pos$ , poly$[i1$].pos$)));
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal_scale_from_poly$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$) {
 const pxcrt::bt_size_t sz$ = poly$.size();
 if (sz$ < pxcrt::bt_size_t(3LL)) {
  return pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
 }
 if (sz$ == pxcrt::bt_size_t(3LL)) {
  return (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$)) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(1LL)].pos$))) , 3.0f));
 } else {
  pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < sz$; ++i$) {
   (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(v$ , ::pgl3d$n::glgeometry$n::poly_cross_at$f(poly$ , i$)));
  }
  return v$;
 }
}
void gf_regular_polygon$f(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ::pxcrt::darray< ::pgl3d$n::glgeometry$n::vertex_attr$s > arr$((n$), (::pgl3d$n::glgeometry$n::vertex_attr$s()));
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < n$; ++i$) {
  const pxcrt::bt_float a$ = (::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$size_t$t$r$(i$) * 2.0f * ::pgl3d$n::glgeometry$n::pi_float$f()) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$size_t$t$r$(n$);
  arr$[i$].pos$.x = numeric::sin< pxcrt::bt_float >(a$) * radius$;
  arr$[i$].pos$.y = -numeric::cos< pxcrt::bt_float >(a$) * radius$;
  arr$[i$].pos$.z = 0.0f;
 }
 c0$.__call$f(ctx$ , arr$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
 ::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(arr$.range());
 c1$.__call$f(ctx$ , arr$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
}
void gf_polygon_points$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& pts$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > arr$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(pts$);
 c0$.__call$f(ctx$ , arr$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
 ::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(arr$.range());
 c1$.__call$f(ctx$ , arr$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
}
void gf_bump_rec$f(pxcrt::bt_float z$, pxcrt::bt_float scale$, pxcrt::bt_int recurse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 if (poly$.size() < pxcrt::bt_size_t(3LL)) {
  return;
 }
 ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > front$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(poly$);
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type nor$ = (::operator$n::div$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(::pgl3d$n::glgeometry$n::normal_scale_from_poly$f(poly$) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$size_t$t$r$(poly$.size())));
 {
  ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (front$);
  const size_t sz$fe = ag$fe.size();
  ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   ::pgl3d$n::glgeometry$n::vertex_attr$s& e$ = ar$fe[i$];
   {
    (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(e$.pos$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(nor$ , z$))));
   }
  }
 }
 ::pgl3d$n::glgeometry$n::polygon_scale$f$p$container$$array$n$$darrayst$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(front$ , scale$);
 if (recurse$ > 1LL) {
  ::pgl3d$n::glgeometry$n::gf_bump_rec$f(z$ , scale$ , recurse$ - 1LL , c0$ , c1$ , ctx$ , front$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
 } else {
  c1$.__call$f(ctx$ , front$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
 }
 const pxcrt::bt_size_t sz$ = front$.size();
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < sz$; ++i$) {
  const pxcrt::bt_size_t i1$ = i$ + pxcrt::bt_size_t(1LL) != sz$ ? i$ + pxcrt::bt_size_t(1LL) : pxcrt::bt_size_t((0LL));
  const ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,4LL > side$ = ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$4$li$r$(poly$[i$] , poly$[i1$] , front$[i1$] , front$[i$]);
  c0$.__call$f(ctx$ , side$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
 }
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type pos$f58(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& vec$, pxcrt::bt_float x$, pxcrt::bt_float xmax$) {
 return (::operator$n::div$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vec$ , x$)) , xmax$));
}
void gf_rand_bump$f(pxcrt::bt_size_t num$, pxcrt::bt_float scale$, pxcrt::bt_float xmin$, pxcrt::bt_float xmax$, pxcrt::bt_float ymin$, pxcrt::bt_float ymax$, pxcrt::bt_float zmin$, pxcrt::bt_float zmax$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c2$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 if (poly$.size() != pxcrt::bt_size_t(4LL)) {
  return;
 }
 ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > front$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(poly$);
 ::pgl3d$n::glgeometry$n::polygon_scale$f$p$container$$array$n$$darrayst$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(front$ , scale$);
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < num$; ++i$) {
  const pxcrt::bt_float xsz$ = xmin$ + (xmax$ - xmin$) * (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f();
  const pxcrt::bt_float ysz$ = ymin$ + (ymax$ - ymin$) * (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f();
  const pxcrt::bt_float zsz$ = zmin$ + (zmax$ - zmin$) * (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f();
  const pxcrt::bt_float xp$ = (1.0f - xsz$) * (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f();
  const pxcrt::bt_float yp$ = (1.0f - ysz$) * (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f();
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type s0$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t((0LL))].pos$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$))) , xp$))));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type s1$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t((0LL))].pos$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$))) , (xp$ + xsz$)))));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type s2$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(3LL)].pos$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(3LL)].pos$))) , (xp$ + xsz$)))));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type s3$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(3LL)].pos$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(3LL)].pos$))) , xp$))));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type t0$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s0$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s3$ , s0$))) , yp$))));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type t1$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s1$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s2$ , s1$))) , yp$))));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type t2$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s1$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s2$ , s1$))) , (yp$ + ysz$)))));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type t3$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s0$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s3$ , s0$))) , (yp$ + ysz$)))));
  const ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,4LL > poly1$ = ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$4$li$r$(::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(t0$) , ::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(t1$) , ::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(t2$) , ::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(t3$));
  ::pgl3d$n::glgeometry$n::gf_bump_rec$f(zsz$ , pxcrt::bt_float(1.0) , 1LL , c0$ , c1$ , ctx$ , poly1$ , mp$);
 }
 c2$.__call$f(ctx$ , poly$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
}
pxcrt::glmpx::tmat4< pxcrt::bt_float >::type poly_trans$f(const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$) {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ex$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ey$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ez$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
 if (poly$.size() >= pxcrt::bt_size_t(3LL)) {
  ex$ = glm::normalize< pxcrt::bt_float >(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$))));
  ez$ = ::pgl3d$n::glgeometry$n::normal_from_poly$f(poly$);
 } else {
  ex$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0));
  ez$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0));
 }
 ey$ = glm::cross< pxcrt::bt_float >(ez$ , ex$);
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c$ = ::pgl3d$n::glgeometry$n::polygon_center$f(poly$);
 return pxcrt::glmpx::make_tmat4< pxcrt::bt_float >(ex$.x , ex$.y , ex$.z , pxcrt::bt_float(0.0) , ey$.x , ey$.y , ey$.z , pxcrt::bt_float(0.0) , ez$.x , ez$.y , ez$.z , pxcrt::bt_float(0.0) , c$.x , c$.y , c$.z , pxcrt::bt_float(1.0));
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type generate_rand_sphere$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, pxcrt::bt_bool surface_flag$, pxcrt::bt_float radius$) {
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type r$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
 while (true) {
  const pxcrt::bt_float x$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f() * 2.0f - 1.0f;
  const pxcrt::bt_float y$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f() * 2.0f - 1.0f;
  const pxcrt::bt_float z$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f() * 2.0f - 1.0f;
  const pxcrt::bt_float d$ = x$ * x$ + y$ * y$ + z$ * z$;
  if (d$ > 1.0f) {
   continue;
  }
  if (surface_flag$) {
   if (d$ < 0.001f) {
    continue;
   }
   const pxcrt::bt_float m$ = radius$ / numeric::sqrt< pxcrt::bt_float >(d$);
   r$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(x$ * m$ , y$ * m$ , z$ * m$);
  } else {
   r$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(x$ * radius$ , y$ * radius$ , z$ * radius$);
  }
  break;
 }
 return r$;
}
pxcrt::glmpx::tquat< pxcrt::bt_float >::type generate_rand_quat$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$) {
 const pxcrt::bt_float x$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f();
 const pxcrt::bt_float y$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f();
 const pxcrt::bt_float z$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate_float$f();
 const pxcrt::bt_float pi2$ = ::pgl3d$n::glgeometry$n::pi_float$f() * 2.0f;
 const pxcrt::bt_float xq0$ = numeric::sqrt< pxcrt::bt_float >(1.0f - x$);
 const pxcrt::bt_float xq1$ = numeric::sqrt< pxcrt::bt_float >(x$);
 return pxcrt::glmpx::make_tquat_wxyz< pxcrt::bt_float >(xq0$ * numeric::sin< pxcrt::bt_float >(y$ * pi2$) , xq0$ * numeric::cos< pxcrt::bt_float >(y$ * pi2$) , xq1$ * numeric::sin< pxcrt::bt_float >(z$ * pi2$) , xq1$ * numeric::cos< pxcrt::bt_float >(z$ * pi2$));
}
void gf_rand_sphere$f(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, pxcrt::bt_bool surface_flag$, pxcrt::bt_bool rotate_flag$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,1LL > arr$ = ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,1LL >();
 pxcrt::bt_size_t i$ = pxcrt::bt_size_t();
 while (i$ < n$) {
  arr$[pxcrt::bt_size_t((0LL))].pos$ = ::pgl3d$n::glgeometry$n::generate_rand_sphere$f(rnd$ , surface_flag$ , radius$);
  if (rotate_flag$) {
   const pxcrt::glmpx::tmat3< pxcrt::bt_float >::type m$ = glm::mat3_cast< pxcrt::bt_float >(::pgl3d$n::glgeometry$n::generate_rand_quat$f(rnd$));
   arr$[pxcrt::bt_size_t((0LL))].nor$ = (::operator$n::mul$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(m$ , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0))));
   arr$[pxcrt::bt_size_t((0LL))].tan$ = (::operator$n::mul$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(m$ , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0))));
  }
  c0$.__call$f(ctx$ , arr$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
  ++i$;
 }
}
void gf_lid$f(const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > arr$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(poly$);
 c0$.__call$f(ctx$ , arr$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
 ::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(arr$.range());
 c1$.__call$f(ctx$ , arr$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
}
void gf_ctx_fill$f(pxcrt::bt_size_t n$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ctx$.fill$f(true , false , n$ , ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("")) , poly$ , mp$);
}
void gf_ctx_fill_smooth$f(pxcrt::bt_size_t n$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ctx$.fill$f(false , false , n$ , ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("")) , poly$ , mp$);
}
void gf_ctx_poly_joint$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ctx$.fill$f(true , true , pxcrt::bt_size_t((0LL)) , joint_name$ , poly$ , mp$);
}
void gf_ctx_point_joint$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ctx$.fill$f(true , false , pxcrt::bt_size_t((0LL)) , joint_name$ , poly$ , mp$);
}
void gf_hole$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
}
void gf_sphere$f(pxcrt::bt_size_t split$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 const pxcrt::bt_size_t poly_sz$ = poly$.size();
 if (poly_sz$ < pxcrt::bt_size_t(3LL)) {
  return;
 }
 if (split$ == pxcrt::bt_size_t((0LL))) {
  c0$.__call$f(ctx$ , poly$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
 }
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type pcenter$ = ::pgl3d$n::glgeometry$n::polygon_center$f(poly$);
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type nor$ = ::pgl3d$n::glgeometry$n::normal_from_poly$f(poly$);
 const pxcrt::bt_float radius$ = ::pgl3d$n::glgeometry$n::polygon_radius$f(poly$);
 ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > sp$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(poly$);
 ::pgl3d$n::glgeometry$n::mesh_index$s mp1$;
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t(1LL); i$ < split$; ++i$) {
  mp1$.x$ = i$;
  const pxcrt::bt_float a1$ = ::pgl3d$n::glgeometry$n::pi_float$f() * ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$size_t$t$r$(i$) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$size_t$t$r$(split$ * pxcrt::bt_size_t(2LL));
  ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > p$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(poly$);
  {
   ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (p$);
   const size_t sz$fe = ag$fe.size();
   ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t j$ = 0; j$ != sz$fe; ++j$) {
    ::pgl3d$n::glgeometry$n::vertex_attr$s& x$ = ar$fe[j$];
    {
     (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.pos$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(nor$ , radius$)) , numeric::sin< pxcrt::bt_float >(a1$)))));
    }
   }
  }
  ::pgl3d$n::glgeometry$n::polygon_scale$f$p$container$$array$n$$darrayst$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(p$ , numeric::cos< pxcrt::bt_float >(a1$));
  for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < poly_sz$; ++j$) {
   const pxcrt::bt_size_t j1$ = j$ + pxcrt::bt_size_t(1LL) != poly_sz$ ? j$ + pxcrt::bt_size_t(1LL) : pxcrt::bt_size_t((0LL));
   ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,4LL > side$ = ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$4$li$r$(sp$[j$] , sp$[j1$] , p$[j1$] , p$[j$]);
   {
    ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,4LL >& ag$fe = (side$);
    const size_t sz$fe = ag$fe.size();
    ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
    for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
     ::pgl3d$n::glgeometry$n::vertex_attr$s& p$ = ar$fe[i$];
     {
      p$.nor$ = glm::normalize< pxcrt::bt_float >(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(p$.pos$ , pcenter$))));
     }
    }
   }
   mp1$.y$ = j$;
   c0$.__call$f(ctx$ , side$ , mp1$);
  }
  for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < poly_sz$; ++j$) {
   sp$[j$] = p$[j$];
  }
 }
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type top_pos$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(pcenter$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(nor$ , radius$))));
 for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < poly_sz$; ++j$) {
  const pxcrt::bt_size_t j1$ = j$ + pxcrt::bt_size_t(1LL) != poly_sz$ ? j$ + pxcrt::bt_size_t(1LL) : pxcrt::bt_size_t((0LL));
  ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL > side$ = ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$3$li$r$(::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(top_pos$) , sp$[j$] , sp$[j1$]);
  {
   ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL >& ag$fe = (side$);
   const size_t sz$fe = ag$fe.size();
   ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    ::pgl3d$n::glgeometry$n::vertex_attr$s& p$ = ar$fe[i$];
    {
     p$.nor$ = glm::normalize< pxcrt::bt_float >(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(p$.pos$ , pcenter$))));
    }
   }
  }
  c0$.__call$f(ctx$ , side$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
 }
}
void gf_import_wfobj$f(const ::pgl3d$n::wfobj$n::wfobject$s& wfo$, const ::pgl3d$n::wfobj$n::wfgroup$s& wfgrp$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ::pgl3d$n::glgeometry$n::mesh_index$s midx$;
 ::pxcrt::pxcvarray< ::pgl3d$n::glgeometry$n::vertex_attr$s > arr$ = ::pxcrt::pxcvarray< ::pgl3d$n::glgeometry$n::vertex_attr$s >();
 {
  const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > >& ag$fe = (wfgrp$.f$);
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& p$ = ar$fe[i$];
   {
    if (arr$.size() != p$.size()) {
     ::pxcrt::array_resize< ::pxcrt::pxcvarray< ::pgl3d$n::glgeometry$n::vertex_attr$s >,::pgl3d$n::glgeometry$n::vertex_attr$s >(arr$ , p$.size() , ::pgl3d$n::glgeometry$n::vertex_attr$s());
    }
    ::pxcrt::pxcvarray< ::pgl3d$n::glgeometry$n::vertex_attr$s >& sli$ = arr$;
    {
     const ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& ag$fe = (p$);
     ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s > > ag$fg(ag$fe);
     const size_t sz$fe = ag$fe.size();
     const ::pgl3d$n::wfobj$n::wfelement$s *const ar$fe = ag$fe.rawarr();
     for (pxcrt::bt_size_t j$ = 0; j$ != sz$fe; ++j$) {
      const ::pgl3d$n::wfobj$n::wfelement$s& v$ = ar$fe[j$];
      {
       ::pxcrt::pxcvarray< ::pgl3d$n::glgeometry$n::vertex_attr$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::glgeometry$n::vertex_attr$s > > t0((sli$));
       ::pgl3d$n::glgeometry$n::vertex_attr$s& ae$ = (t0.get())[j$];
       const pxcrt::bt_uint vid$ = v$.vertex$;
       if (vid$ > pxcrt::bt_uint((0LL)) && wfo$.v$.size() >= pxcrt::bt_size_t(vid$)) {
        ae$.pos$ = wfo$.v$[pxcrt::bt_size_t(vid$ - pxcrt::bt_uint(1LL))];
       }
       const pxcrt::bt_uint nid$ = v$.normal$;
       if (nid$ > pxcrt::bt_uint((0LL)) && wfo$.vn$.size() >= pxcrt::bt_size_t(nid$)) {
        ae$.nor$ = wfo$.vn$[pxcrt::bt_size_t(nid$ - pxcrt::bt_uint(1LL))];
       }
       const pxcrt::bt_uint cid$ = v$.texcoord$;
       if (cid$ > pxcrt::bt_uint((0LL)) && wfo$.vt$.size() >= pxcrt::bt_size_t(cid$)) {
        const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type coord$ = wfo$.vt$[pxcrt::bt_size_t(cid$ - pxcrt::bt_uint(1LL))];
        ae$.uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(coord$.x , coord$.y , 0.0f);
       }
      }
     }
    }
    midx$.x$ = i$;
    c0$.__call$f(ctx$ , (::pxcrt::pxcvarray< ::pgl3d$n::glgeometry$n::vertex_attr$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::glgeometry$n::vertex_attr$s > > (arr$).get_crange()) , midx$);
   }
  }
 }
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type pos$f96(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& vec$, pxcrt::bt_size_t i$, pxcrt::bt_size_t imax$) {
 return (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vec$ , (::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$size_t$t$r$(i$) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$size_t$t$r$(imax$))));
}
void gf_rectangle_split$f(pxcrt::bt_size_t split_x$, pxcrt::bt_size_t split_y$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 if (poly$.size() != pxcrt::bt_size_t(4LL)) {
  return;
 }
 ::pgl3d$n::glgeometry$n::mesh_index$s mp1$;
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < split_x$; ++i$) {
  mp1$.x$ = i$;
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type s0$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t((0LL))].pos$ , ::pgl3d$n::glgeometry$n::pos$f96((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$)) , i$ , split_x$)));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type s1$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t((0LL))].pos$ , ::pgl3d$n::glgeometry$n::pos$f96((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$)) , i$ + pxcrt::bt_size_t(1LL) , split_x$)));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type s2$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(3LL)].pos$ , ::pgl3d$n::glgeometry$n::pos$f96((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(3LL)].pos$)) , i$ + pxcrt::bt_size_t(1LL) , split_x$)));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type s3$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(3LL)].pos$ , ::pgl3d$n::glgeometry$n::pos$f96((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(3LL)].pos$)) , i$ , split_x$)));
  for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < split_y$; ++j$) {
   mp1$.y$ = j$;
   const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type t0$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s0$ , ::pgl3d$n::glgeometry$n::pos$f96((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s3$ , s0$)) , j$ , split_y$)));
   const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type t1$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s1$ , ::pgl3d$n::glgeometry$n::pos$f96((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s2$ , s1$)) , j$ , split_y$)));
   const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type t2$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s1$ , ::pgl3d$n::glgeometry$n::pos$f96((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s2$ , s1$)) , j$ + pxcrt::bt_size_t(1LL) , split_y$)));
   const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type t3$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s0$ , ::pgl3d$n::glgeometry$n::pos$f96((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(s3$ , s0$)) , j$ + pxcrt::bt_size_t(1LL) , split_y$)));
   c0$.__call$f(ctx$ , ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$4$li$r$(::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(t0$) , ::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(t1$) , ::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(t2$) , ::pgl3d$n::glgeometry$n::tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(t3$)) , mp1$);
  }
 }
}
void gf_rotate_local$f(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& q$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans$ = ::pgl3d$n::glgeometry$n::poly_trans$f(poly$);
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans_inv$ = glm::inverse< pxcrt::bt_float >(trans$);
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type m$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$((::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(trans_inv$ , glm::mat4_cast< pxcrt::bt_float >(q$))) , trans$));
 ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > p$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(poly$);
 {
  ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (p$);
  const size_t sz$fe = ag$fe.size();
  ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   ::pgl3d$n::glgeometry$n::vertex_attr$s& v$ = ar$fe[i$];
   {
    const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type v1$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(m$ , pxcrt::glmpx::make_tvec4< pxcrt::bt_float >(v$.pos$.x , v$.pos$.y , v$.pos$.z , pxcrt::bt_float(1.0))));
    v$.pos$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(v1$.x , v1$.y , v1$.z);
   }
  }
 }
 c0$.__call$f(ctx$ , p$ , mp$);
}
void gf_apply$f(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > p$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(poly$);
 {
  ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (p$);
  const size_t sz$fe = ag$fe.size();
  ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   ::pgl3d$n::glgeometry$n::vertex_attr$s& v$ = ar$fe[i$];
   {
    const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type v1$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(m$ , pxcrt::glmpx::make_tvec4< pxcrt::bt_float >(v$.pos$.x , v$.pos$.y , v$.pos$.z , pxcrt::bt_float(1.0))));
    v$.pos$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(v1$.x / v1$.w , v1$.y / v1$.w , v1$.z / v1$.w);
   }
  }
 }
 c0$.__call$f(ctx$ , p$ , mp$);
}
void gf_bump_apply$f(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, pxcrt::bt_bool split_reverse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans$ = ::pgl3d$n::glgeometry$n::poly_trans$f(poly$);
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type trans_inv$ = glm::inverse< pxcrt::bt_float >(trans$);
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type m1$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$((::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(trans_inv$ , m$)) , trans$));
 ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s > front$ = ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >(poly$);
 {
  ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (front$);
  const size_t sz$fe = ag$fe.size();
  ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   ::pgl3d$n::glgeometry$n::vertex_attr$s& v$ = ar$fe[i$];
   {
    const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type v1$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(m1$ , pxcrt::glmpx::make_tvec4< pxcrt::bt_float >(v$.pos$.x , v$.pos$.y , v$.pos$.z , pxcrt::bt_float(1.0))));
    v$.pos$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(v1$.x / v1$.w , v1$.y / v1$.w , v1$.z / v1$.w);
   }
  }
 }
 c1$.__call$f(ctx$ , front$ , mp$);
 const pxcrt::bt_size_t sz$ = poly$.size();
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < sz$; ++i$) {
  const pxcrt::bt_size_t i1$ = i$ + pxcrt::bt_size_t(1LL) != sz$ ? i$ + pxcrt::bt_size_t(1LL) : pxcrt::bt_size_t((0LL));
  if (split_reverse$) {
   const ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL > s0$ = ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$3$li$r$(poly$[i$] , poly$[i1$] , front$[i1$]);
   const ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL > s1$ = ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$3$li$r$(front$[i1$] , front$[i$] , poly$[i$]);
   c0$.__call$f(ctx$ , s0$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
   c0$.__call$f(ctx$ , s1$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
  } else {
   const ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL > s0$ = ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$3$li$r$(poly$[i$] , poly$[i1$] , front$[i$]);
   const ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL > s1$ = ::container$n::array$n::make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$3$li$r$(front$[i$] , poly$[i1$] , front$[i1$]);
   c0$.__call$f(ctx$ , s0$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
   c0$.__call$f(ctx$ , s1$ , ::pgl3d$n::glgeometry$n::mesh_index$s());
  }
 }
}
};}; /* namespace pgl3d::glgeometry */
namespace pgl3d$n { namespace pglbase$n { 
instance_data$s::instance_data$s() : instance_buffer$(), glbuffer_offset_float$(){
 /* instance_buffer$ */;
 /* glbuffer_offset_float$ */;
}
instance_data$s::instance_data$s(::pxcrt::pxcvarray< pxcrt::bt_float > instance_buffer$, pxcrt::bt_size_t glbuffer_offset_float$) : instance_buffer$(instance_buffer$), glbuffer_offset_float$(glbuffer_offset_float$){
 /* instance_buffer$ */;
 /* glbuffer_offset_float$ */;
}
pxcrt::glmpx::tmat4< pxcrt::bt_float >::type position_angle$s::to_mat4$f() const {
 return (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(glm::translate< pxcrt::bt_float >(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type() , position$) , glm::mat4_cast< pxcrt::bt_float >(angle$)));
}
void position_angle$s::translate_relative$f(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& v$) {
 (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(position$ , (::operator$n::mul$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(glm::mat3_cast< pxcrt::bt_float >(angle$) , v$))));
}
void position_angle$s::rotate_angle_axis$f(pxcrt::bt_float a$, pxcrt::bt_float x$, pxcrt::bt_float y$, pxcrt::bt_float z$) {
 (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(a$ , x$ , y$ , z$)));
}
void position_angle$s::normalize$f() {
 glm::normalize< pxcrt::bt_float >(angle$);
}
position_angle$s::position_angle$s() : position$(), angle$(){
 /* position$ */;
 /* angle$ */;
}
position_angle$s::position_angle$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tquat< pxcrt::bt_float >::type angle$) : position$(position$), angle$(angle$){
 /* position$ */;
 /* angle$ */;
}
projection_info$s::projection_info$s() : projection$(), sm_projection$(), camera$(), light$(), screen_width$(), screen_height$() {
}
vertex_buffer_pool_key$s::vertex_buffer_pool_key$s(){
}
texture_info$s::texture_info$s() : surface_w$(), surface_h$(), char_w$(), char_h$() {
}
node_common_data$s::node_common_data$s() : shadowmapping_vp$(), vp$(), stat_num_objects$(){
 /* shadowmapping_vp$ */;
 /* vp$ */;
 /* stat_num_objects$ */;
}
node_common_data$s::node_common_data$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmapping_vp$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$, pxcrt::bt_size_t stat_num_objects$) : shadowmapping_vp$(shadowmapping_vp$), vp$(vp$), stat_num_objects$(stat_num_objects$){
 /* shadowmapping_vp$ */;
 /* vp$ */;
 /* stat_num_objects$ */;
}
};}; /* namespace pgl3d::pglbase */
namespace pgl3d$n { namespace shader_config$n { 
pxcrt::bt_bool shader_config$s::is_gl3_or_gles3$f() const {
 return major$ >= 3LL;
}
pxcrt::bt_bool shader_config$s::is_gl33_or_gles3$f() const {
 return major$ >= 3LL && (is_gles$ || minor$ >= 3LL);
}
::pxcrt::bt_strlit shader_config$s::prepend$f() const {
 if (is_gles$) {
  if (is_gl3_or_gles3$f()) {
   return pxcrt::bt_strlit("#version 300 es\012precision highp float;\012");
  } else {
   return pxcrt::bt_strlit("precision highp float;\012");
  }
 } else {
  if (is_gl3_or_gles3$f()) {
   return pxcrt::bt_strlit("#version 150\012");
  } else {
   return pxcrt::bt_strlit("#version 120\012");
  }
 }
}
::pxcrt::bt_strlit shader_config$s::vert_in$f() const {
 return is_gl3_or_gles3$f() ? pxcrt::bt_strlit("in ") : pxcrt::bt_strlit("attribute ");
}
::pxcrt::bt_strlit shader_config$s::vert_out$f() const {
 return is_gl3_or_gles3$f() ? pxcrt::bt_strlit("out ") : pxcrt::bt_strlit("varying ");
}
::pxcrt::bt_strlit shader_config$s::frag_in$f() const {
 return is_gl3_or_gles3$f() ? pxcrt::bt_strlit("in ") : pxcrt::bt_strlit("varying ");
}
::pxcrt::bt_strlit shader_config$s::texture2d$f() const {
 return is_gl3_or_gles3$f() ? pxcrt::bt_strlit("texture") : pxcrt::bt_strlit("texture2D");
}
::pxcrt::bt_strlit shader_config$s::shadow2d$f() const {
 return is_gl3_or_gles3$f() ? pxcrt::bt_strlit("texture") : pxcrt::bt_strlit("shadow2D");
}
::pxcrt::bt_strlit shader_config$s::fragcolor$f() const {
 return is_gl3_or_gles3$f() ? pxcrt::bt_strlit("fragcolor") : pxcrt::bt_strlit("gl_FragColor");
}
::pxcrt::bt_strlit shader_config$s::decl_fragcolor$f() const {
 return is_gl3_or_gles3$f() ? pxcrt::bt_strlit("out vec4 fragcolor;\012") : pxcrt::bt_strlit("\012");
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > shader_config$s::decl_instance_id$f(pxcrt::bt_bool shader_has_iid$) const {
 if (1LL != pxcrt::bt_long((0LL)) && shader_has_iid$) {
  return (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(vert_in$f() , pxcrt::bt_strlit("float instance_id;\012")));
 } else {
  return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit(""));
 }
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > shader_config$s::decl_instance_attr$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& t$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& n$, pxcrt::bt_bool shader_support_instancing$, pxcrt::bt_bool shader_has_iid$) const {
 if (1LL != pxcrt::bt_long((0LL)) && shader_has_iid$) {
  return (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("uniform ") , t$)) , pxcrt::bt_strlit(" "))) , n$)) , pxcrt::bt_strlit("["))) , pxcrt::bt_strlit("8"))) , pxcrt::bt_strlit("];\012")));
 } else {
  if (shader_support_instancing$ && enable_instanced$) {
   if (enable_uniform_instancing$) {
    return (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("uniform ") , t$)) , pxcrt::bt_strlit(" "))) , n$)) , pxcrt::bt_strlit("["))) , pxcrt::bt_strlit("8"))) , pxcrt::bt_strlit("];\012")));
   } else {
    return (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(vert_in$f() , t$)) , pxcrt::bt_strlit(" "))) , n$)) , pxcrt::bt_strlit(";\012")));
   }
  } else {
   return (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("uniform ") , t$)) , pxcrt::bt_strlit(" "))) , n$)) , pxcrt::bt_strlit(";\012")));
  }
 }
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > shader_config$s::instance_attr$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& n$, pxcrt::bt_bool shader_support_instancing$, pxcrt::bt_bool shader_has_iid$) const {
 if (1LL != pxcrt::bt_long((0LL)) && shader_has_iid$) {
  return (::operator$n::add$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(n$ , pxcrt::bt_strlit("[int(instance_id)]")));
 } else {
  if (shader_support_instancing$ && enable_instanced$ && enable_uniform_instancing$) {
   return (::operator$n::add$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(n$ , pxcrt::bt_strlit("[gl_InstanceID]")));
  } else {
   return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(n$);
  }
 }
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > shader_config$s::empty_shader_vert$f() const {
 return (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(prepend$f() , pxcrt::bt_strlit("void main(void) { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); }\012")));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > shader_config$s::empty_shader_frag$f() const {
 return (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(prepend$f() , pxcrt::bt_strlit("void main(void) { }\012")));
}
shader_config$s::shader_config$s(pxcrt::bt_bool is_gles0$, pxcrt::bt_int major0$, pxcrt::bt_int minor0$, pxcrt::bt_bool msaa0$) : is_gles$(is_gles0$), major$(major0$), minor$(minor0$), enable_shadowmapping$(true), enable_shadowmapping_multisample$(false), enable_normalmapping$(true), enable_zprepass$(!is_gles$), enable_msaa$(msaa0$), enable_instanced$(major$ >= 3LL && 1LL == pxcrt::bt_long((0LL))), enable_uniform_instancing$(enable_instanced$ && (major$ < 3LL || is_gles$ || (!is_gles$ && minor$ < 3LL))), enable_depth_texture$((major$ >= 3LL)), enable_sampler2dshadow$(enable_depth_texture$ && !is_gles$) {
}
};}; /* namespace pgl3d::shader_config */
namespace pgl3d$n { namespace drawer_base$n { 
void prepare_instance_data_noop$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$) {
}
};}; /* namespace pgl3d::drawer_base */
namespace GL$n { namespace base$n { 
void gl_check_error$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) {
 const GLenum e$ = ::glGetError();
 if (::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$GL$$base$n$$GLenum$s$r$(e$) != (0LL)) {
  PXC_THROW(::exception$n::runtime_error_template$s$p$opengl__error$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::split$n::string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(name$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$GL$$base$n$$GLenum$s$r$(e$))).get_crange())));
 }
}
void gl_check_error_if$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) {
 if (pxcrt::gl::get_check_error_enabled() != (0LL)) {
  ::GL$n::base$n::gl_check_error$f(name$);
 }
}
};}; /* namespace GL::base */
namespace pgl3d$n { namespace glshader$n { 
pxcrt::bt_uint compile_shader$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$, GLenum type$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& err_r$) {
 pxcrt::bt_uint res$ = ::GL$n::compat$n::glCreateShader$f(type$);
 ::pxcrt::farray< pxcrt::crawptr< pxcrt::bt_char >::type,1LL > source$ = ::container$n::array$n::make_farray_func$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$1$li$r$(pxcrt::crawptr_to_ccharptr< pxcrt::bt_uchar >(pxcrt::cslice_to_crawptr< pxcrt::bt_uchar >(src$)));
 const ::pxcrt::farray< pxcrt::bt_int,1LL > length$ = ::container$n::array$n::make_farray_func$f$p$meta$n$$int$t$q$1$li$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(src$.size()));
 ::GL$n::compat$n::glShaderSource$f(res$ , 1LL , pxcrt::array_to_rawptr< ::pxcrt::farray< pxcrt::crawptr< pxcrt::bt_char >::type,1LL > >(source$) , pxcrt::array_to_crawptr< ::pxcrt::farray< pxcrt::bt_int,1LL > >(length$));
 ::GL$n::compat$n::glCompileShader$f(res$);
 pxcrt::bt_int success$ = pxcrt::bt_int();
 ::GL$n::compat$n::glGetShaderiv$f(res$ , GL_COMPILE_STATUS , pxcrt::address< pxcrt::bt_int >(success$));
 if (success$ == (0LL)) {
  pxcrt::bt_int sz$ = pxcrt::bt_int();
  {
   sz$ = 4096LL;
  }
  ::pxcrt::pxcvarray< pxcrt::bt_uchar > buf$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
  ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_int >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(sz$) , (0LL));
  pxcrt::bt_int len$ = pxcrt::bt_int();
  ::GL$n::compat$n::glGetShaderInfoLog$f(res$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(sz$) , pxcrt::address< pxcrt::bt_int >(len$) , pxcrt::rawptr_to_charptr< pxcrt::bt_uchar >(pxcrt::array_to_rawptr< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >(buf$)));
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(pxcrt::bt_strlit("compile_shader failed:") , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$GL$$base$n$$GLenum$s$r$(type$) , success$ , buf$);
  err_r$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$GL$$base$n$$GLenum$s$r$(type$) , success$ , buf$);
  ::GL$n::compat$n::glDeleteShader$f(res$);
  res$ = pxcrt::bt_uint((0LL));
 }
 return res$;
}
pxcrt::bt_uint create_program$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& vertex_shader$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& fragment_shader$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& err_r$) {
 pxcrt::bt_uint prog$ = ::GL$n::compat$n::glCreateProgram$f();
 pxcrt::bt_uint shader$ = pxcrt::bt_uint();
 pxcrt::bt_int success$ = 1LL;
 if (!vertex_shader$.empty()) {
  shader$ = ::pgl3d$n::glshader$n::compile_shader$f(vertex_shader$ , GL_VERTEX_SHADER , err_r$);
  if (shader$ != pxcrt::bt_uint((0LL))) {
   ::GL$n::compat$n::glAttachShader$f(prog$ , shader$);
  } else {
   success$ = (0LL);
  }
 }
 if (!fragment_shader$.empty()) {
  shader$ = ::pgl3d$n::glshader$n::compile_shader$f(fragment_shader$ , GL_FRAGMENT_SHADER , err_r$);
  if (shader$ != pxcrt::bt_uint((0LL))) {
   ::GL$n::compat$n::glAttachShader$f(prog$ , shader$);
   if (!attrib_to_avoid_0$.empty()) {
    ::GL$n::compat$n::glBindAttribLocation$f(prog$ , pxcrt::bt_uint(1LL) , pxcrt::crawptr_to_ccharptr< pxcrt::bt_uchar >(pxcrt::strlit_to_crawptr(attrib_to_avoid_0$)));
   }
  } else {
   success$ = (0LL);
  }
 }
 if (success$ == (0LL)) {
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("create_program failed:") , success$);
  ::GL$n::compat$n::glDeleteProgram$f(prog$);
  prog$ = pxcrt::bt_uint((0LL));
 } else {
  ::GL$n::compat$n::glLinkProgram$f(prog$);
  pxcrt::bt_int linkst$ = pxcrt::bt_int();
  ::GL$n::compat$n::glGetProgramiv$f(prog$ , GL_LINK_STATUS , pxcrt::address< pxcrt::bt_int >(linkst$));
  if (linkst$ == (0LL)) {
   ::pxcrt::pxcvarray< pxcrt::bt_uchar > buf$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
   ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_int >(buf$ , pxcrt::bt_size_t(4096LL) , (0LL));
   pxcrt::bt_int len$ = pxcrt::bt_int();
   ::GL$n::compat$n::glGetProgramInfoLog$f(prog$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(buf$.size()) , pxcrt::address< pxcrt::bt_int >(len$) , pxcrt::rawptr_to_charptr< pxcrt::bt_uchar >(pxcrt::array_to_rawptr< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >(buf$)));
   ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_int >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(len$) , (0LL));
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(pxcrt::bt_strlit("linkprogram failed:") , prog$ , buf$);
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(pxcrt::bt_strlit("vert:") , vertex_shader$);
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(pxcrt::bt_strlit("frag:") , fragment_shader$);
   ::GL$n::compat$n::glDeleteProgram$f(prog$);
   prog$ = pxcrt::bt_uint((0LL));
  } else {
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("linkprogram succeeded:") , prog$);
  }
 }
 return prog$;
}
};}; /* namespace pgl3d::glshader */
namespace pgl3d$n { namespace glbuffer$n { 
vertex_set$s::vertex_set$s(pxcrt::bt_size_t num_float_per_vertex0$) : vs_id$(), vs_name$(), vtxs$(::pointer$n::make_ptr$f$p$pgl3d$$glvertex$n$$vertices$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(num_float_per_vertex0$)), vertex_values_offset$(), elements_offset$() {
}
void async_buffer$s::map_buffer$f(pxcrt::bt_size_t sz_bytes$) {
 /* staticif empty */
}
void async_buffer$s::unmap_buffer$f() {
 /* staticif empty */
}
GLenum async_buffer$s::client_wait_sync$f(pxcrt::bt_long timeout$) {
 /* staticif empty *//* staticif-else */
 return GLenum();
 /* staticif-else end */
}
void async_buffer$s::init$f() {
 vbo$.generate$f();
 fence_sync$f();
}
void async_buffer$s::fence_sync$f() {
 delete_sync$f();
 /* staticif empty */
}
void async_buffer$s::delete_sync$f() {
 /* staticif empty */
}
async_buffer$s::~async_buffer$s() PXC_NOTHROW {
 try {
  unmap_buffer$f();
  delete_sync$f();
 } catch (...) { ::abort(); }
}
async_buffer$s::async_buffer$s() : vbo$(), mapped_ptr$(), fence$(), size_bytes$() {
 init$f();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > vertex_buffer$s::make_if$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& name$) {
 {
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > const& ag$fe = (vs_names$);
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::cfind_type i$it = ag$fe.find(name$);
  if (i$it != ag$fe.notfound()) {
   const pxcrt::bt_size_t id$ = ag$fe.get_cmapped(i$it);
   {
    return vs_arr$[id$];
   }
  } else {
   const pxcrt::bt_size_t id$ = vs_arr$.size();
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > p$ = ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_set$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(num_float_per_vertex$);
   (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(p$))->value)).vs_id$ = id$;
   (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(p$))->value)).vs_name$ = name$;
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >(vs_arr$ , p$);
   vs_names$[name$] = id$;
   return p$;
  }
 }
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > vertex_buffer$s::get_vertices$f(pxcrt::bt_size_t vs_id$) const {
 return (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > > > (vs_arr$).get()),vs_id$)))->value)).vtxs$;
}
pxcrt::bt_size_t vertex_buffer$s::num_vs$f() const {
 return vs_arr$.size();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > vertex_buffer$s::get_by_id$f(pxcrt::bt_size_t vs_id$) const {
 return vs_arr$[vs_id$];
}
pxcrt::bt_bool vertex_buffer$s::exists$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& name$) const {
 return vs_names$.exists(name$);
}
pxcrt::bt_bool vertex_buffer$s::has_name$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& name$) const {
 return vs_names$.exists(name$);
}
pxcrt::bt_size_t vertex_buffer$s::get_id_by_name$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& name$) const {
 {
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > const& ag$fe = (vs_names$);
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::cfind_type i$it = ag$fe.find(name$);
  if (i$it != ag$fe.notfound()) {
   const pxcrt::bt_size_t id$ = ag$fe.get_cmapped(i$it);
   {
    return id$;
   }
  } else {
   PXC_THROW(::exception$n::runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  }
 }
}
pxcrt::bt_size_t vertex_buffer$s::num_vs_ids$f() const {
 return vs_arr$.size();
}
pxcrt::bt_bool vertex_buffer$s::create_vbo$f(pxcrt::bt_bool enable_copying_instancing$) {
 if (vbo_values$.get$f() != pxcrt::bt_uint((0LL)) || vbo_elems$.get$f() != pxcrt::bt_uint((0LL))) {
  return false;
 }
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >& ag$fe = (vs_arr$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >& be$ = ar$fe[i$];
   {
    (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).vtxs$))->value)).prepare_multiple_copies$f(enable_copying_instancing$);
   }
  }
 }
 ::pxcrt::pxcvarray< pxcrt::bt_float > vertex_values$ = ::pxcrt::pxcvarray< pxcrt::bt_float >();
 ::pxcrt::pxcvarray< pxcrt::bt_uint > elements$ = ::pxcrt::pxcvarray< pxcrt::bt_uint >();
 pxcrt::bt_size_t num_v$ = pxcrt::bt_size_t((0LL));
 pxcrt::bt_size_t num_e$ = pxcrt::bt_size_t((0LL));
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >& ag$fe = (vs_arr$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >& be$ = ar$fe[i$];
   {
    num_v$ += (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).vtxs$))->value)).vertex_values$.size();
    num_e$ += (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).vtxs$))->value)).elements$.size();
   }
  }
 }
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_float >,pxcrt::bt_double >(vertex_values$ , num_v$ , 0.0);
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_int >(elements$ , num_e$ , (0LL));
 num_vertex_values$ = num_v$;
 num_elements$ = num_e$;
 num_v$ = pxcrt::bt_size_t((0LL));
 num_e$ = pxcrt::bt_size_t((0LL));
 {
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >& ag$fe = (vs_arr$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >::guard_ref< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >& be$ = ar$fe[i$];
   {
    {
          const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > t1 = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).vtxs$;
const ::pxcrt::pxcvarray< pxcrt::bt_float >& ag$fe = ((((t1)->value)).vertex_values$);
     ::pxcrt::pxcvarray< pxcrt::bt_float >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_float > > ag$fg(ag$fe);
     const size_t sz$fe = ag$fe.size();
     const pxcrt::bt_float *const ar$fe = ag$fe.rawarr();
     for (pxcrt::bt_size_t j$ = 0; j$ != sz$fe; ++j$) {
      const pxcrt::bt_float& v$ = ar$fe[j$];
      {
       vertex_values$[num_v$ + j$] = v$;
      }
     }
    }
    {
          const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > t3 = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).vtxs$;
const ::pxcrt::pxcvarray< pxcrt::bt_uint >& ag$fe = ((((t3)->value)).elements$);
     ::pxcrt::pxcvarray< pxcrt::bt_uint >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uint > > ag$fg(ag$fe);
     const size_t sz$fe = ag$fe.size();
     const pxcrt::bt_uint *const ar$fe = ag$fe.rawarr();
     for (pxcrt::bt_size_t j$ = 0; j$ != sz$fe; ++j$) {
      const pxcrt::bt_uint& e$ = ar$fe[j$];
      {
       if (e$ == 4294967295U) {
        elements$[num_e$ + j$] = e$;
       } else {
        (::pxcrt::pxcvarray< pxcrt::bt_uint >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uint > > (elements$).get())[num_e$ + j$] = e$ + ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(num_v$ / num_float_per_vertex$);
       }
      }
     }
    }
    (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).vertex_values_offset$ = num_v$;
    (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).elements_offset$ = num_e$;
    num_v$ += (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).vtxs$))->value)).vertex_values$.size();
    num_e$ += (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(be$))->value)).vtxs$))->value)).elements$.size();
   }
  }
 }
 {
  vbo_values$.generate$f();
  vbo_elems$.generate$f();
  if (vbo_values$.get$f() == pxcrt::bt_uint((0LL)) || vbo_elems$.get$f() == pxcrt::bt_uint((0LL))) {
   return false;
  }
  ::GL$n::compat$n::glBindBuffer$f(GL_ARRAY_BUFFER , vbo_values$.get$f());
  ::GL$n::compat$n::glBufferData$f(GL_ARRAY_BUFFER , ::numeric$n::cast$n::static_cast$f$p$GL$$base$n$$GLsizeiptr$s$q$meta$n$$size_t$t$r$(vertex_values$.size()) * GLsizeiptr(4LL) , pxcrt::crawptr_to_cvoidptr< pxcrt::bt_float >(pxcrt::array_to_crawptr< ::pxcrt::pxcvarray< pxcrt::bt_float > >(vertex_values$)) , GL_STATIC_DRAW);
  ::GL$n::compat$n::glBindBuffer$f(GL_ARRAY_BUFFER , pxcrt::bt_uint((0LL)));
  ::GL$n::compat$n::glBindBuffer$f(GL_ELEMENT_ARRAY_BUFFER , vbo_elems$.get$f());
  ::GL$n::compat$n::glBufferData$f(GL_ELEMENT_ARRAY_BUFFER , ::numeric$n::cast$n::static_cast$f$p$GL$$base$n$$GLsizeiptr$s$q$meta$n$$size_t$t$r$(elements$.size()) * GLsizeiptr(4LL) , pxcrt::crawptr_to_cvoidptr< pxcrt::bt_uint >(pxcrt::array_to_crawptr< ::pxcrt::pxcvarray< pxcrt::bt_uint > >(elements$)) , GL_STATIC_DRAW);
  ::GL$n::compat$n::glBindBuffer$f(GL_ELEMENT_ARRAY_BUFFER , pxcrt::bt_uint((0LL)));
 }
 return true;
}
vertex_buffer$s::vertex_buffer$s(pxcrt::bt_size_t num_float_per_vertex0$, pxcrt::bt_bool draw_mode_points0$, pxcrt::bt_bool is_sub_drawer0$) : draw_mode_points$(draw_mode_points0$), is_sub_drawer$(is_sub_drawer0$), num_float_per_vertex$(num_float_per_vertex0$), vbo_values$(), vbo_elems$(), num_vertex_values$(), num_elements$(), vs_names$(), vs_arr$() {
}
void vertex_buffer_draw$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, pxcrt::bt_size_t vs_id$, ::pgl3d$n::glshader$n::glshader_i$i& sdr$) {
 ::pgl3d$n::glbuffer$n::vertex_buffer_draw_pre$f(bo$ , sdr$);
 ::pgl3d$n::glbuffer$n::vertex_buffer_draw_elems$f(bo$ , vs_id$ , pxcrt::bt_size_t(1LL));
 ::pgl3d$n::glbuffer$n::vertex_buffer_draw_post$f(bo$ , sdr$);
}
void vertex_buffer_draw_pre$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, ::pgl3d$n::glshader$n::glshader_i$i& sdr$) {
 ::GL$n::compat$n::glBindBuffer$f(GL_ARRAY_BUFFER , bo$.vbo_values$.get$f());
 sdr$.enable_vertex_attrib_array$f(bo$.num_float_per_vertex$);
 ::GL$n::compat$n::glBindBuffer$f(GL_ARRAY_BUFFER , pxcrt::bt_uint((0LL)));
 ::GL$n::compat$n::glBindBuffer$f(GL_ELEMENT_ARRAY_BUFFER , bo$.vbo_elems$.get$f());
 /* staticif empty */
}
void vertex_buffer_draw_post$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, ::pgl3d$n::glshader$n::glshader_i$i& sdr$) {
 sdr$.disable_vertex_attrib_array$f();
 ::GL$n::compat$n::glBindBuffer$f(GL_ELEMENT_ARRAY_BUFFER , pxcrt::bt_uint((0LL)));
 /* staticif empty */
}
void vertex_buffer_draw_elems$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, pxcrt::bt_size_t vs_id$, pxcrt::bt_size_t num_instance$) {
 const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > t0 = bo$.get_by_id$f(vs_id$);
 const ::pgl3d$n::glbuffer$n::vertex_set$s& be$ = ((t0)->value);
 if (num_instance$ > (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(be$.vtxs$))->value)).num_copies$) {
  PXC_THROW(::exception$n::runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
 }
 const pxcrt::bt_size_t elem_offset$ = be$.elements_offset$;
 const pxcrt::bt_size_t elem_num$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(be$.vtxs$))->value)).elements_size_per_copy$ * num_instance$;
 GLenum mode$ = bo$.draw_mode_points$ ? GL_POINTS : 0LL ? GL_TRIANGLE_FAN : GL_TRIANGLES;
 /* staticif empty */{
  ::GL$n::compat$n::glDrawElements$f(mode$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(elem_num$) , GL_UNSIGNED_INT , pxcrt::gl::offset_to_void_cp(elem_offset$ * pxcrt::bt_size_t(4LL)));
 }
}
void vertex_buffer_draw_elems_instanced$f(const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, pxcrt::bt_size_t vs_id$, pxcrt::bt_size_t num_instance$) {
 /* staticif empty *//* staticif-else */
 PXC_THROW(::exception$n::runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
 /* staticif-else end */
}
};}; /* namespace pgl3d::glbuffer */
namespace pgl3d$n { namespace aggregated_ibuffer$n { 
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > aggregated_ibuffer$s::get_current$f() const {
 return buffers$[buffer_current$];
}
void aggregated_ibuffer$s::switch_buffer$f() {
 ++buffer_current$;
 if (buffer_current$ >= buffers$.size()) {
  buffer_current$ = pxcrt::bt_size_t((0LL));
 }
}
void aggregated_ibuffer$s::init$f() {
 for (pxcrt::bt_int i$ = (0LL); i$ < 2LL; ++i$) {
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > >(buffers$ , ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$async_buffer$s$q$m$ll$r$());
 }
}
aggregated_ibuffer$s::aggregated_ibuffer$s() : buffers$(), buffer_current$() {
 init$f();
}
void aggregated_ibuffer_frame_begin$f(::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, pxcrt::bt_bool enable_instanced$, pxcrt::bt_bool enable_uniform_instancing$) {
 if (enable_instanced$ && !enable_uniform_instancing$) {
  pxcrt::bt_size_t offset_float$ = pxcrt::bt_size_t((0LL));
  {
   ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& ag$fe = (whole_instances$);
   ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > ag$fg(ag$fe);
   const size_t sz$fe = ag$fe.size();
   ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t bo_id$ = 0; bo_id$ != sz$fe; ++bo_id$) {
    ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$ = ar$fe[bo_id$];
    {
     {
      ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& ag$fe = (bo_ib$);
      ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > ag$fg(ag$fe);
      const size_t sz$fe = ag$fe.size();
      ::pgl3d$n::pglbase$n::instance_data$s *const ar$fe = ag$fe.rawarr();
      for (pxcrt::bt_size_t vs_id$ = 0; vs_id$ != sz$fe; ++vs_id$) {
       ::pgl3d$n::pglbase$n::instance_data$s& inst$ = ar$fe[vs_id$];
       {
        ::pxcrt::pxcvarray< pxcrt::bt_float >& arr$ = inst$.instance_buffer$;
        inst$.glbuffer_offset_float$ = offset_float$;
        offset_float$ += arr$.size();
       }
      }
     }
    }
   }
  }
  if (offset_float$ != pxcrt::bt_size_t((0LL))) {
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > t0 = aibuf$.get_current$f();
   ::pgl3d$n::glbuffer$n::async_buffer$s& cur_buf$ = ((t0)->value);
   const pxcrt::bt_size_t total_size_float$ = offset_float$;
   offset_float$ = pxcrt::bt_size_t((0LL));
   cur_buf$.client_wait_sync$f(pxcrt::bt_long(1000000000LL * 10LL));
   cur_buf$.map_buffer$f(total_size_float$ * pxcrt::bt_size_t(4U));
   const pxcrt::rawptr< pxcrt::bt_float >::type mapped_ptr$ = cur_buf$.mapped_ptr$;
   {
    ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& ag$fe = (whole_instances$);
    ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > ag$fg(ag$fe);
    const size_t sz$fe = ag$fe.size();
    ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > *const ar$fe = ag$fe.rawarr();
    for (pxcrt::bt_size_t bo_id$ = 0; bo_id$ != sz$fe; ++bo_id$) {
     ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$ = ar$fe[bo_id$];
     {
      {
       ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& ag$fe = (bo_ib$);
       ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > ag$fg(ag$fe);
       const size_t sz$fe = ag$fe.size();
       ::pgl3d$n::pglbase$n::instance_data$s *const ar$fe = ag$fe.rawarr();
       for (pxcrt::bt_size_t vs_id$ = 0; vs_id$ != sz$fe; ++vs_id$) {
        ::pgl3d$n::pglbase$n::instance_data$s& inst$ = ar$fe[vs_id$];
        {
         const ::pxcrt::pxcvarray< pxcrt::bt_float >& arr$ = inst$.instance_buffer$;
         const pxcrt::bt_size_t sz$ = arr$.size();
         pxcrt::rawptr< pxcrt::bt_float >::type t0 = ::operator$n::add$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$r$(mapped_ptr$ , offset_float$);
         ::pxcrt::bt_slice< pxcrt::bt_float > sli$ = pxcrt::rawptr_to_slice< pxcrt::bt_float >((t0) , sz$);
         for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < sz$; ++j$) {
          sli$[j$] = arr$[j$];
         }
         offset_float$ += sz$;
        }
       }
      }
     }
    }
   }
   cur_buf$.unmap_buffer$f();
  }
 }
}
void aggregated_ibuffer_frame_end$f(::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, pxcrt::bt_bool enable_instanced$, pxcrt::bt_bool enable_uniform_instancing$) {
 if (enable_instanced$ && !enable_uniform_instancing$) {
  (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > >(aibuf$.get_current$f()))->value)).fence_sync$f();
  aibuf$.switch_buffer$f();
 }
}
void aggregated_ibuffer_draw$f(const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pgl3d$n::glshader$n::glshader_i$i& sdr$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, pxcrt::bt_bool enable_instanced$, pxcrt::bt_bool enable_uniform_instancing$) {
 ::pgl3d$n::glbuffer$n::vertex_buffer_draw_pre$f(bo$ , sdr$);
 if (enable_instanced$ && !enable_uniform_instancing$) {
  sdr$.enable_instance_attrib_array$f(true);
  ::GL$n::compat$n::glBindBuffer$f(GL_ARRAY_BUFFER , (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > >(aibuf$.get_current$f()))->value)).vbo$.get$f());
 }
 for (pxcrt::bt_size_t vs_id$ = pxcrt::bt_size_t((0LL)); vs_id$ < bo$.num_vs$f(); ++vs_id$) {
  ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > t0((bo_ib$));
  const ::pgl3d$n::pglbase$n::instance_data$s& instance$ = (t0.get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$size_t$t$r$(vs_id$)];
  const ::pxcrt::pxcvarray< pxcrt::bt_float >& arr$ = instance$.instance_buffer$;
  if (arr$.empty()) {
   continue;
  }
  if (enable_instanced$ && !enable_uniform_instancing$) {
   /* staticif empty */
  } else if (enable_uniform_instancing$) {
   const pxcrt::bt_size_t iattr_num_float$ = sdr$.instance_attrib_num_float$f();
   pxcrt::bt_size_t j$ = pxcrt::bt_size_t();
   const pxcrt::bt_size_t jmax$ = arr$.size() / iattr_num_float$;
   for (j$ = pxcrt::bt_size_t((0LL)); j$ < jmax$; j$ += pxcrt::bt_size_t(8LL)) {
    pxcrt::bt_size_t k$ = ::ordered$n::min$f$p$meta$n$$size_t$t$r$((jmax$ - j$) , pxcrt::bt_size_t(8LL));
    sdr$.instance_attrib_set_uniform$f((::pxcrt::pxcvarray< pxcrt::bt_float >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_float > > (arr$).get_crange()) , j$ * iattr_num_float$ , k$);
    ::pgl3d$n::glbuffer$n::vertex_buffer_draw_elems_instanced$f(bo$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$size_t$t$r$(vs_id$) , k$);
   }
  } else {
   const pxcrt::bt_size_t iattr_num_float$ = sdr$.instance_attrib_num_float$f();
   pxcrt::bt_size_t j$ = pxcrt::bt_size_t();
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > t0 = bo$.get_by_id$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$size_t$t$r$(vs_id$));
   const ::pgl3d$n::glbuffer$n::vertex_set$s& be$ = ((t0)->value);
   const pxcrt::bt_size_t jmax$ = arr$.size() / iattr_num_float$;
   const pxcrt::bt_size_t inst_mul$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(be$.vtxs$))->value)).num_copies$;
   for (j$ = pxcrt::bt_size_t((0LL)); j$ < jmax$; j$ += inst_mul$) {
    pxcrt::bt_size_t k$ = ::ordered$n::min$f$p$meta$n$$size_t$t$r$((jmax$ - j$) , inst_mul$);
    sdr$.instance_attrib_set_uniform$f((::pxcrt::pxcvarray< pxcrt::bt_float >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_float > > (arr$).get_crange()) , j$ * iattr_num_float$ , k$);
    ::pgl3d$n::glbuffer$n::vertex_buffer_draw_elems$f(bo$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$size_t$t$r$(vs_id$) , k$);
   }
  }
 }
 if (enable_instanced$ && !enable_uniform_instancing$) {
  ::GL$n::compat$n::glBindBuffer$f(GL_ARRAY_BUFFER , pxcrt::bt_uint((0LL)));
  sdr$.enable_instance_attrib_array$f(false);
 }
 ::pgl3d$n::glbuffer$n::vertex_buffer_draw_post$f(bo$ , sdr$);
}
};}; /* namespace pgl3d::aggregated_ibuffer */
namespace pgl3d$n { namespace drawer$n { 
triangles_uniforms$s::triangles_uniforms$s() : view_projection_matrix$(), sampler$(), sampler_tilemap$(), sampler_sm$(), camera_pos$(), light_pos$(), light_on$(), shadowmap_vp$(){
 /* view_projection_matrix$ */;
 /* sampler$ */;
 /* sampler_tilemap$ */;
 /* sampler_sm$ */;
 /* camera_pos$ */;
 /* light_pos$ */;
 /* light_on$ */;
 /* shadowmap_vp$ */;
}
triangles_uniforms$s::triangles_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$, pxcrt::bt_int sampler$, pxcrt::bt_int sampler_tilemap$, pxcrt::bt_int sampler_sm$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type camera_pos$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type light_pos$, pxcrt::bt_float light_on$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmap_vp$) : view_projection_matrix$(view_projection_matrix$), sampler$(sampler$), sampler_tilemap$(sampler_tilemap$), sampler_sm$(sampler_sm$), camera_pos$(camera_pos$), light_pos$(light_pos$), light_on$(light_on$), shadowmap_vp$(shadowmap_vp$){
 /* view_projection_matrix$ */;
 /* sampler$ */;
 /* sampler_tilemap$ */;
 /* sampler_sm$ */;
 /* camera_pos$ */;
 /* light_pos$ */;
 /* light_on$ */;
 /* shadowmap_vp$ */;
}
triangles_vertex_attributes$s::triangles_vertex_attributes$s() : instance_id$(), position$(), normal$(), tangent$(), uvw$(){
 /* instance_id$ */;
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
triangles_vertex_attributes$s::triangles_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$) : instance_id$(instance_id$), position$(position$), normal$(normal$), tangent$(tangent$), uvw$(uvw$){
 /* instance_id$ */;
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
triangles2_vertex_attributes$s::triangles2_vertex_attributes$s() : position$(), normal$(), tangent$(), uvw$(){
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
triangles2_vertex_attributes$s::triangles2_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$) : position$(position$), normal$(normal$), tangent$(tangent$), uvw$(uvw$){
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
zprepass_vertex_attributes$s::zprepass_vertex_attributes$s() : instance_id$(), position$(), normal$(), tangent$(), uvw$(){
 /* instance_id$ */;
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
zprepass_vertex_attributes$s::zprepass_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$) : instance_id$(instance_id$), position$(position$), normal$(normal$), tangent$(tangent$), uvw$(uvw$){
 /* instance_id$ */;
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
zprepass2_vertex_attributes$s::zprepass2_vertex_attributes$s() : position$(), normal$(), tangent$(), uvw$(){
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
zprepass2_vertex_attributes$s::zprepass2_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$) : position$(position$), normal$(normal$), tangent$(tangent$), uvw$(uvw$){
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
shadowmap_vertex_attributes$s::shadowmap_vertex_attributes$s() : instance_id$(), position$(), normal$(), tangent$(), uvw$(){
 /* instance_id$ */;
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
shadowmap_vertex_attributes$s::shadowmap_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$) : instance_id$(instance_id$), position$(position$), normal$(normal$), tangent$(tangent$), uvw$(uvw$){
 /* instance_id$ */;
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
shadowmap2_vertex_attributes$s::shadowmap2_vertex_attributes$s() : position$(), normal$(), tangent$(), uvw$(){
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
shadowmap2_vertex_attributes$s::shadowmap2_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type normal$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tangent$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type uvw$) : position$(position$), normal$(normal$), tangent$(tangent$), uvw$(uvw$){
 /* position$ */;
 /* normal$ */;
 /* tangent$ */;
 /* uvw$ */;
}
triangles_instance_attributes$s::triangles_instance_attributes$s() : model_matrix$(){
 /* model_matrix$ */;
}
triangles_instance_attributes$s::triangles_instance_attributes$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type model_matrix$) : model_matrix$(model_matrix$){
 /* model_matrix$ */;
}
zprepass_uniforms$s::zprepass_uniforms$s() : view_projection_matrix$(){
 /* view_projection_matrix$ */;
}
zprepass_uniforms$s::zprepass_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$) : view_projection_matrix$(view_projection_matrix$){
 /* view_projection_matrix$ */;
}
shadowmap_uniforms$s::shadowmap_uniforms$s() : shadowmap_vp$(){
 /* shadowmap_vp$ */;
}
shadowmap_uniforms$s::shadowmap_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type shadowmap_vp$) : shadowmap_vp$(shadowmap_vp$){
 /* shadowmap_vp$ */;
}
font_uniforms$s::font_uniforms$s() : sampler$(){
 /* sampler$ */;
}
font_uniforms$s::font_uniforms$s(pxcrt::bt_int sampler$) : sampler$(sampler$){
 /* sampler$ */;
}
font2_uniforms$s::font2_uniforms$s() : screen_size_px$(), sampler$(){
 /* screen_size_px$ */;
 /* sampler$ */;
}
font2_uniforms$s::font2_uniforms$s(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type screen_size_px$, pxcrt::bt_int sampler$) : screen_size_px$(screen_size_px$), sampler$(sampler$){
 /* screen_size_px$ */;
 /* sampler$ */;
}
font2_instance_attributes$s::font2_instance_attributes$s() : idata$(){
 /* idata$ */;
}
font2_instance_attributes$s::font2_instance_attributes$s(pxcrt::glmpx::tvec4< pxcrt::bt_float >::type idata$) : idata$(idata$){
 /* idata$ */;
}
font2_vertex_attributes$s::font2_vertex_attributes$s() : instance_id$(), texture_size_px$(), texture_origin_px$(), char_size_px$(), coord_clamp$(), char_px$(), char_point_size$(){
 /* instance_id$ */;
 /* texture_size_px$ */;
 /* texture_origin_px$ */;
 /* char_size_px$ */;
 /* coord_clamp$ */;
 /* char_px$ */;
 /* char_point_size$ */;
}
font2_vertex_attributes$s::font2_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type texture_size_px$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type texture_origin_px$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type char_size_px$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type coord_clamp$, pxcrt::bt_float char_px$, pxcrt::bt_float char_point_size$) : instance_id$(instance_id$), texture_size_px$(texture_size_px$), texture_origin_px$(texture_origin_px$), char_size_px$(char_size_px$), coord_clamp$(coord_clamp$), char_px$(char_px$), char_point_size$(char_point_size$){
 /* instance_id$ */;
 /* texture_size_px$ */;
 /* texture_origin_px$ */;
 /* char_size_px$ */;
 /* coord_clamp$ */;
 /* char_px$ */;
 /* char_point_size$ */;
}
rect2d_vertex_attributes$s::rect2d_vertex_attributes$s() : instance_id$(), vert$(){
 /* instance_id$ */;
 /* vert$ */;
}
rect2d_vertex_attributes$s::rect2d_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type vert$) : instance_id$(instance_id$), vert$(vert$){
 /* instance_id$ */;
 /* vert$ */;
}
rect2d_instance_attributes$s::rect2d_instance_attributes$s() : idata$(){
 /* idata$ */;
}
rect2d_instance_attributes$s::rect2d_instance_attributes$s(pxcrt::glmpx::tvec4< pxcrt::bt_float >::type idata$) : idata$(idata$){
 /* idata$ */;
}
rect2d_uniforms$s::rect2d_uniforms$s(){
}
particle_uniforms$s::particle_uniforms$s() : point_size_base$(){
 /* point_size_base$ */;
}
particle_uniforms$s::particle_uniforms$s(pxcrt::bt_float point_size_base$) : point_size_base$(point_size_base$){
 /* point_size_base$ */;
}
particle_instance_attributes$s::particle_instance_attributes$s() : model_matrix$(){
 /* model_matrix$ */;
}
particle_instance_attributes$s::particle_instance_attributes$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type model_matrix$) : model_matrix$(model_matrix$){
 /* model_matrix$ */;
}
particle_vertex_attributes$s::particle_vertex_attributes$s() : position$(){
 /* position$ */;
}
particle_vertex_attributes$s::particle_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$) : position$(position$){
 /* position$ */;
}
particle_bb_uniforms$s::particle_bb_uniforms$s() : view_projection_matrix$(), camera_matrix$(), point_size_base$(){
 /* view_projection_matrix$ */;
 /* camera_matrix$ */;
 /* point_size_base$ */;
}
particle_bb_uniforms$s::particle_bb_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$, pxcrt::glmpx::tmat4< pxcrt::bt_float >::type camera_matrix$, pxcrt::bt_float point_size_base$) : view_projection_matrix$(view_projection_matrix$), camera_matrix$(camera_matrix$), point_size_base$(point_size_base$){
 /* view_projection_matrix$ */;
 /* camera_matrix$ */;
 /* point_size_base$ */;
}
particle_bb_vertex_attributes$s::particle_bb_vertex_attributes$s() : position$(), local_position$(){
 /* position$ */;
 /* local_position$ */;
}
particle_bb_vertex_attributes$s::particle_bb_vertex_attributes$s(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type position$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type local_position$) : position$(position$), local_position$(local_position$){
 /* position$ */;
 /* local_position$ */;
}
lineparticle_uniforms$s::lineparticle_uniforms$s() : view_projection_matrix$(), screen_size_px$(), screen_size_base$(){
 /* view_projection_matrix$ */;
 /* screen_size_px$ */;
 /* screen_size_base$ */;
}
lineparticle_uniforms$s::lineparticle_uniforms$s(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view_projection_matrix$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type screen_size_px$, pxcrt::bt_float screen_size_base$) : view_projection_matrix$(view_projection_matrix$), screen_size_px$(screen_size_px$), screen_size_base$(screen_size_base$){
 /* view_projection_matrix$ */;
 /* screen_size_px$ */;
 /* screen_size_base$ */;
}
lineparticle_vertex_attributes$s::lineparticle_vertex_attributes$s() : instance_id$(), vert$(){
 /* instance_id$ */;
 /* vert$ */;
}
lineparticle_vertex_attributes$s::lineparticle_vertex_attributes$s(pxcrt::bt_float instance_id$, pxcrt::glmpx::tvec2< pxcrt::bt_float >::type vert$) : instance_id$(instance_id$), vert$(vert$){
 /* instance_id$ */;
 /* vert$ */;
}
lineparticle_instance_attributes$s::lineparticle_instance_attributes$s() : idata$(){
 /* idata$ */;
}
lineparticle_instance_attributes$s::lineparticle_instance_attributes$s(pxcrt::glmpx::tmat3< pxcrt::bt_float >::type idata$) : idata$(idata$){
 /* idata$ */;
}
void drawer_triangles$s::init$f() {
 ::pgl3d$n::drawer$n::init_main_texture$f(texture_dpat$ , texture_tilemap$);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_triangles$s::get_vbid_name$f() const {
 return (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vbid_triangles_") , ::text$n::string$n::serialize$n::to_string$f$p$meta$n$$int$t$r$(opt$)));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_triangles$s::get_main_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_triangles_0"));
}
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type drawer_triangles$s::get_prepare_instance_data_funcptr$f() const {
 return ::pointer$n::tfuncptr$n::make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_triangles$f$r$();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > drawer_triangles$s::make_vertex_buffer$f() const {
 return ::pgl3d$n::drawer$n::make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(false , opt$ != (0LL));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_triangles$s::builtin_vertex_set_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit(""));
}
void drawer_triangles$s::make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ drawer_triangles$s::make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 return ::pgl3d$n::drawer$n::make_dgf_polygon_filler$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(vptr$);
}
::pgl3d$n::pglbase$n::texture_info$s drawer_triangles$s::get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 ::pgl3d$n::pglbase$n::texture_info$s r$;
 if (eq_memcmp(name$,::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("main")))) {
  r$.surface_w$ = texture_dpat$.surface_w$;
  r$.surface_h$ = texture_dpat$.surface_h$;
 }
 return r$;
}
void drawer_triangles$s::draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) {
 if (step$ == 1LL) {
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_view$ = glm::inverse< pxcrt::bt_float >(cam_df$.light$.to_mat4$f());
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.sm_projection$ , sm_view$));
  ::GL$n::compat$n::glUseProgram$f(((*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ >(sdr_shadow$)))).program$);
  {
   ::GL$n::compat$n::glUniformMatrix4fv$f(((*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ >(sdr_shadow$)))).u_shadowmap_vp$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(sm_vp$));
   ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , (*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ >(sdr_shadow$))) , bo$ , bo_ib$ , bo_id$ , glc$.enable_instanced$ , glc$.enable_uniform_instancing$);
  }
 } else if (step$ == 2LL) {
  pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view$ = pxcrt::glmpx::tmat4< pxcrt::bt_float >::type();
  view$ = glm::inverse< pxcrt::bt_float >(cam_df$.camera$.to_mat4$f());
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.projection$ , view$));
  const pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > t0 = sdr_zp$;
  ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$& sdr$ = (*(t0));
  ::GL$n::compat$n::glUseProgram$f(sdr$.program$);
  ::GL$n::compat$n::glUniformMatrix4fv$f(sdr$.u_view_projection_matrix$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(vp$));
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , sdr$ , bo$ , bo_ib$ , bo_id$ , glc$.enable_instanced$ , glc$.enable_uniform_instancing$);
 } else if (step$ == 3LL) {
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_view$ = glm::inverse< pxcrt::bt_float >(cam_df$.light$.to_mat4$f());
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.sm_projection$ , sm_view$));
  pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view$ = pxcrt::glmpx::tmat4< pxcrt::bt_float >::type();
  view$ = glm::inverse< pxcrt::bt_float >(cam_df$.camera$.to_mat4$f());
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.projection$ , view$));
  const ::pxcrt::farray< pxcrt::bt_float,4LL > red$ = ::container$n::array$n::make_farray_func$f$p$meta$n$$float$t$q$4$li$r$(pxcrt::bt_float(0.8) , pxcrt::bt_float(0.1) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0));
  const pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > t0 = sdr_solid$;
  ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$& sdr$ = (*(t0));
  ::GL$n::compat$n::glUseProgram$f(sdr$.program$);
  ::GL$n::compat$n::glUniform3fv$f(sdr$.u_light_pos$ , 1LL , pxcrt::glmpx::tvec3_to_crawptr< pxcrt::bt_float >(cam_df$.light$.position$));
  ::GL$n::compat$n::glUniform3fv$f(sdr$.u_camera_pos$ , 1LL , pxcrt::glmpx::tvec3_to_crawptr< pxcrt::bt_float >(cam_df$.camera$.position$));
  ::GL$n::compat$n::glUniform1i$f(sdr$.u_sampler$ , 1LL);
  ::GL$n::compat$n::glUniform1i$f(sdr$.u_sampler_tilemap$ , 2LL);
  ::GL$n::compat$n::glUniform1i$f(sdr$.u_sampler_sm$ , 3LL);
  ::GL$n::compat$n::glUniform1f$f(sdr$.u_light_on$ , 1.0f);
  ::GL$n::compat$n::glUniformMatrix4fv$f(sdr$.u_shadowmap_vp$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(sm_vp$));
  ::GL$n::compat$n::glUniformMatrix4fv$f(sdr$.u_view_projection_matrix$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(vp$));
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , sdr$ , bo$ , bo_ib$ , bo_id$ , glc$.enable_instanced$ , glc$.enable_uniform_instancing$);
 }
}
drawer_triangles$s::drawer_triangles$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$, pxcrt::bt_int opt0$) : count$z(1), opt$(opt0$), sdr_solid$(::pgl3d$n::drawer$n::init_triangles_shader$f$p$1$li$r$(glc$ , opt$)), sdr_zp$(::pgl3d$n::drawer$n::init_zprepass_shader$f$p$1$li$r$(glc$ , opt$)), sdr_shadow$(::pgl3d$n::drawer$n::init_shadowmap_shader$f$p$1$li$r$(glc$ , opt$)), texture_dpat$(), texture_tilemap$() {
 init$f();
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_triangles2$s::get_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_triangles2"));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_triangles2$s::get_main_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_triangles2"));
}
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type drawer_triangles2$s::get_prepare_instance_data_funcptr$f() const {
 return ::pointer$n::tfuncptr$n::make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_triangles$f$r$();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > drawer_triangles2$s::make_vertex_buffer$f() const {
 return ::pgl3d$n::drawer$n::make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(false , false);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_triangles2$s::builtin_vertex_set_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit(""));
}
void drawer_triangles2$s::make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ drawer_triangles2$s::make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 return ::pgl3d$n::drawer$n::make_dgf_polygon_filler$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(vptr$);
}
::pgl3d$n::pglbase$n::texture_info$s drawer_triangles2$s::get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 return ::pgl3d$n::pglbase$n::texture_info$s();
}
void drawer_triangles2$s::draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) {
 if (step$ == 1LL) {
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_view$ = glm::inverse< pxcrt::bt_float >(cam_df$.light$.to_mat4$f());
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.sm_projection$ , sm_view$));
  ::GL$n::compat$n::glUseProgram$f(((*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ >(sdr_shadow$)))).program$);
  {
   ::GL$n::compat$n::glUniformMatrix4fv$f(((*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ >(sdr_shadow$)))).u_shadowmap_vp$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(sm_vp$));
   ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , (*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ >(sdr_shadow$))) , bo$ , bo_ib$ , bo_id$ , false , false);
  }
 } else if (step$ == 2LL) {
  pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view$ = pxcrt::glmpx::tmat4< pxcrt::bt_float >::type();
  view$ = glm::inverse< pxcrt::bt_float >(cam_df$.camera$.to_mat4$f());
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.projection$ , view$));
  ::GL$n::compat$n::glUseProgram$f(((*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ >(sdr_zp$)))).program$);
  ::GL$n::compat$n::glUniformMatrix4fv$f(((*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ >(sdr_zp$)))).u_view_projection_matrix$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(vp$));
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , (*(pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ >(sdr_zp$))) , bo$ , bo_ib$ , bo_id$ , false , false);
 } else if (step$ == 3LL) {
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_view$ = glm::inverse< pxcrt::bt_float >(cam_df$.light$.to_mat4$f());
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.sm_projection$ , sm_view$));
  pxcrt::glmpx::tmat4< pxcrt::bt_float >::type view$ = pxcrt::glmpx::tmat4< pxcrt::bt_float >::type();
  view$ = glm::inverse< pxcrt::bt_float >(cam_df$.camera$.to_mat4$f());
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.projection$ , view$));
  const ::pxcrt::farray< pxcrt::bt_float,4LL > red$ = ::container$n::array$n::make_farray_func$f$p$meta$n$$float$t$q$4$li$r$(pxcrt::bt_float(0.8) , pxcrt::bt_float(0.1) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0));
  const pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > t0 = sdr_solid$;
  ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$& sdr$ = (*(t0));
  ::GL$n::compat$n::glUseProgram$f(sdr$.program$);
  ::GL$n::compat$n::glUniform3fv$f(sdr$.u_light_pos$ , 1LL , pxcrt::glmpx::tvec3_to_crawptr< pxcrt::bt_float >(cam_df$.light$.position$));
  ::GL$n::compat$n::glUniform3fv$f(sdr$.u_camera_pos$ , 1LL , pxcrt::glmpx::tvec3_to_crawptr< pxcrt::bt_float >(cam_df$.camera$.position$));
  ::GL$n::compat$n::glUniform1i$f(sdr$.u_sampler$ , 1LL);
  ::GL$n::compat$n::glUniform1i$f(sdr$.u_sampler_tilemap$ , 2LL);
  ::GL$n::compat$n::glUniform1i$f(sdr$.u_sampler_sm$ , 3LL);
  ::GL$n::compat$n::glUniform1f$f(sdr$.u_light_on$ , 1.0f);
  ::GL$n::compat$n::glUniformMatrix4fv$f(sdr$.u_shadowmap_vp$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(sm_vp$));
  ::GL$n::compat$n::glUniformMatrix4fv$f(sdr$.u_view_projection_matrix$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(vp$));
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , sdr$ , bo$ , bo_ib$ , bo_id$ , false , false);
 }
}
drawer_triangles2$s::drawer_triangles2$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) : count$z(1), sdr_solid$(::pgl3d$n::drawer$n::init_triangles_shader$f$p$0$li$r$(glc$ , (0LL))), sdr_zp$(::pgl3d$n::drawer$n::init_zprepass_shader$f$p$0$li$r$(glc$ , (0LL))), sdr_shadow$(::pgl3d$n::drawer$n::init_shadowmap_shader$f$p$0$li$r$(glc$ , (0LL))) {
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_lineparticle$s::get_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_lineparticle"));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_lineparticle$s::get_main_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_lineparticle"));
}
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type drawer_lineparticle$s::get_prepare_instance_data_funcptr$f() const {
 return ::pointer$n::tfuncptr$n::make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_lineparticle$f$r$();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > drawer_lineparticle$s::make_vertex_buffer$f() const {
 return ::pgl3d$n::drawer$n::make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(false , false);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_lineparticle$s::builtin_vertex_set_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("lineparticle"));
}
void drawer_lineparticle$s::make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 ::pxcrt::farray< ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s,4LL > vs$ = ::pxcrt::farray< ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s,4LL >();
 vs$[pxcrt::bt_size_t((0LL))].vert$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(-0.5));
 vs$[pxcrt::bt_size_t(1LL)].vert$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(-0.5));
 vs$[pxcrt::bt_size_t(2LL)].vert$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(0.5));
 vs$[pxcrt::bt_size_t(3LL)].vert$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.5));
 (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_polygon_distinct$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$q$0$li$r$(vs$);
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ drawer_lineparticle$s::make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 return ::pgl3d$n::drawer$n::make_dgf_noop$f(vptr$);
}
::pgl3d$n::pglbase$n::texture_info$s drawer_lineparticle$s::get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 return ::pgl3d$n::pglbase$n::texture_info$s();
}
void drawer_lineparticle$s::draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) {
 if (step$ == 4LL) {
  ::GL$n::compat$n::glDepthFunc$f(GL_LEQUAL);
  ::GL$n::compat$n::glDepthMask$f(pxcrt::bt_uchar(1LL));
  pxcrt::glmpx::tmat4< pxcrt::bt_float >::type cam_mat$ = pxcrt::glmpx::tmat4< pxcrt::bt_float >::type();
  cam_mat$ = cam_df$.camera$.to_mat4$f();
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.projection$ , (glm::inverse< pxcrt::bt_float >(cam_mat$))));
  const ::pxcrt::farray< pxcrt::bt_float,2LL > screen_size_px$ = ::container$n::array$n::make_farray_func$f$p$meta$n$$float$t$q$2$li$r$(::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(cam_df$.screen_width$) , ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(cam_df$.screen_height$));
  const pxcrt::bt_float screen_size_base$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(::ordered$n::max$f$p$meta$n$$int$t$r$(cam_df$.screen_width$ , cam_df$.screen_height$));
  const pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > t0 = sdr_lp$;
  ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$& sdr$ = (*(t0));
  ::GL$n::compat$n::glUseProgram$f(sdr$.program$);
  ::GL$n::compat$n::glUniformMatrix4fv$f(sdr$.u_view_projection_matrix$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(vp$));
  ::GL$n::compat$n::glUniform2fv$f(sdr$.u_screen_size_px$ , 1LL , pxcrt::array_to_crawptr< ::pxcrt::farray< pxcrt::bt_float,2LL > >(screen_size_px$));
  ::GL$n::compat$n::glUniform1fv$f(sdr$.u_screen_size_base$ , 1LL , pxcrt::caddress< pxcrt::bt_float >(screen_size_base$));
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , sdr$ , bo$ , bo_ib$ , bo_id$ , glc$.enable_instanced$ , glc$.enable_uniform_instancing$);
 }
}
drawer_lineparticle$s::drawer_lineparticle$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) : count$z(1), sdr_lp$(::pgl3d$n::drawer$n::init_lineparticle_shader$f(glc$)) {
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_particle$s::get_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_particle"));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_particle$s::get_main_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_particle"));
}
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type drawer_particle$s::get_prepare_instance_data_funcptr$f() const {
 return ::pointer$n::tfuncptr$n::make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_particle$f$r$();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > drawer_particle$s::make_vertex_buffer$f() const {
 return ::pgl3d$n::drawer$n::make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(true , false);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_particle$s::builtin_vertex_set_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit(""));
}
void drawer_particle$s::make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ drawer_particle$s::make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 return ::pgl3d$n::drawer$n::make_dgf_particle_filler$f(vptr$);
}
::pgl3d$n::pglbase$n::texture_info$s drawer_particle$s::get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 return ::pgl3d$n::pglbase$n::texture_info$s();
}
void drawer_particle$s::draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) {
 if (step$ == 4LL) {
  ::GL$n::compat$n::glBlendFunc$f(GL_ONE , GL_ONE);
  const pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > t0 = sdr_sp$;
  ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$& sdr$ = (*(t0));
  ::GL$n::compat$n::glUseProgram$f(sdr$.program$);
  ::GL$n::compat$n::glUniform1f$f(sdr$.u_point_size_base$ , 0.1f * ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(::ordered$n::max$f$p$meta$n$$int$t$r$(cam_df$.screen_width$ , cam_df$.screen_height$)));
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , sdr$ , bo$ , bo_ib$ , bo_id$ , glc$.enable_instanced$ , glc$.enable_uniform_instancing$);
 }
}
drawer_particle$s::drawer_particle$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) : count$z(1), sdr_sp$(::pgl3d$n::drawer$n::init_particle_shader$f(glc$)) {
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_particle_bb$s::get_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_particle_bb"));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_particle_bb$s::get_main_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_particle_bb"));
}
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type drawer_particle_bb$s::get_prepare_instance_data_funcptr$f() const {
 return ::pointer$n::tfuncptr$n::make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_default$f$r$();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > drawer_particle_bb$s::make_vertex_buffer$f() const {
 return ::pgl3d$n::drawer$n::make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(false , false);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_particle_bb$s::builtin_vertex_set_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit(""));
}
void drawer_particle_bb$s::make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ drawer_particle_bb$s::make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 return ::pgl3d$n::drawer$n::make_dgf_particle_bb_filler$f(vptr$);
}
::pgl3d$n::pglbase$n::texture_info$s drawer_particle_bb$s::get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 return ::pgl3d$n::pglbase$n::texture_info$s();
}
void drawer_particle_bb$s::draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) {
 if (step$ == 4LL) {
  ::GL$n::compat$n::glBlendFunc$f(GL_ONE , GL_ONE);
  const pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > t0 = sdr_pb$;
  ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$& sdr$ = (*(t0));
  ::GL$n::compat$n::glUseProgram$f(sdr$.program$);
  pxcrt::glmpx::tmat4< pxcrt::bt_float >::type cam_mat$ = pxcrt::glmpx::tmat4< pxcrt::bt_float >::type();
  cam_mat$ = cam_df$.camera$.to_mat4$f();
  const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.projection$ , (glm::inverse< pxcrt::bt_float >(cam_mat$))));
  ::GL$n::compat$n::glUniformMatrix4fv$f(sdr$.u_view_projection_matrix$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat4_to_crawptr< pxcrt::bt_float >(vp$));
  ::GL$n::compat$n::glUniformMatrix3fv$f(sdr$.u_camera_matrix$ , 1LL , pxcrt::bt_uchar((0LL)) , pxcrt::glmpx::tmat3_to_crawptr< pxcrt::bt_float >(pxcrt::glmpx::tmat4_to_3< pxcrt::bt_float >(cam_mat$)));
  ::GL$n::compat$n::glUniform1f$f(sdr$.u_point_size_base$ , 0.1f);
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , sdr$ , bo$ , bo_ib$ , bo_id$ , glc$.enable_instanced$ , glc$.enable_uniform_instancing$);
 }
}
drawer_particle_bb$s::drawer_particle_bb$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) : count$z(1), sdr_pb$(::pgl3d$n::drawer$n::init_particle_bb_shader$f(glc$)) {
}
void drawer_font2$s::init$f() {
 ::pgl3d$n::drawer$n::init_font$f(texture_font$);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_font2$s::get_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_font2"));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_font2$s::get_main_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_font2"));
}
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type drawer_font2$s::get_prepare_instance_data_funcptr$f() const {
 return ::pointer$n::tfuncptr$n::make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_font2$f$r$();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > drawer_font2$s::make_vertex_buffer$f() const {
 return ::pgl3d$n::drawer$n::make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(true , false);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_font2$s::builtin_vertex_set_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("default_font"));
}
void drawer_font2$s::make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 const ::pgl3d$n::pglbase$n::texture_info$s ti$ = get_texture_info$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("font")));
 const pxcrt::bt_float char_w$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(ti$.char_w$);
 const pxcrt::bt_float char_h$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(ti$.char_h$);
 const pxcrt::bt_float point_size$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(::ordered$n::max$f$p$meta$n$$uint$t$r$(ti$.char_w$ , ti$.char_h$));
 const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type char_size_px$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(char_w$ , char_h$);
 const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type texture_size_px$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(ti$.surface_w$) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(ti$.surface_h$));
 const pxcrt::bt_float clamp_x$ = char_w$ / point_size$;
 const pxcrt::bt_float clamp_y$ = char_h$ / point_size$;
 ::pgl3d$n::drawer$n::font2_vertex_attributes$s v$;
 v$.char_size_px$ = char_size_px$;
 v$.texture_size_px$ = texture_size_px$;
 v$.texture_origin_px$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0));
 v$.coord_clamp$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(clamp_x$ , clamp_y$);
 v$.char_px$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(ti$.char_w$);
 v$.char_point_size$ = point_size$;
 (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_point$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(v$);
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ drawer_font2$s::make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 return ::pgl3d$n::drawer$n::make_dgf_noop$f(vptr$);
}
::pgl3d$n::pglbase$n::texture_info$s drawer_font2$s::get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 ::pgl3d$n::pglbase$n::texture_info$s r$;
 if (eq_memcmp(name$,::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("font")))) {
  r$.surface_w$ = texture_font$.surface_w$;
  r$.surface_h$ = texture_font$.surface_h$;
  r$.char_w$ = texture_font$.char_w$;
  r$.char_h$ = texture_font$.char_h$;
 }
 return r$;
}
void drawer_font2$s::draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) {
 if (step$ == 4LL) {
  ::GL$n::compat$n::glBlendFunc$f(GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA);
  const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type screen_size_px$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(cam_df$.screen_width$) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(cam_df$.screen_height$));
  const pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > t0 = sdr_fn$;
  ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$& sdr$ = (*(t0));
  ::GL$n::compat$n::glUseProgram$f(sdr$.program$);
  ::GL$n::compat$n::glUniform1i$f(sdr$.u_sampler$ , (0LL));
  ::GL$n::compat$n::glUniform2fv$f(sdr$.u_screen_size_px$ , 1LL , pxcrt::glmpx::tvec2_to_crawptr< pxcrt::bt_float >(screen_size_px$));
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , sdr$ , bo$ , bo_ib$ , bo_id$ , glc$.enable_instanced$ , glc$.enable_uniform_instancing$);
 }
}
drawer_font2$s::drawer_font2$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) : count$z(1), sdr_fn$(::pgl3d$n::drawer$n::init_font2_shader$f(glc$)), texture_font$() {
 init$f();
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_rect2d$s::get_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_rect2d"));
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_rect2d$s::get_main_vbid_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vbid_rect2d"));
}
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type drawer_rect2d$s::get_prepare_instance_data_funcptr$f() const {
 return ::pointer$n::tfuncptr$n::make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_rect2d$f$r$();
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > drawer_rect2d$s::make_vertex_buffer$f() const {
 return ::pgl3d$n::drawer$n::make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(false , false);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > drawer_rect2d$s::builtin_vertex_set_name$f() const {
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("rect2d"));
}
void drawer_rect2d$s::make_builtin_vertex_sets$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 ::pxcrt::farray< ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s,4LL > vs$ = ::pxcrt::farray< ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s,4LL >();
 vs$[pxcrt::bt_size_t((0LL))].vert$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0));
 vs$[pxcrt::bt_size_t(1LL)].vert$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0));
 vs$[pxcrt::bt_size_t(2LL)].vert$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(1.0));
 vs$[pxcrt::bt_size_t(3LL)].vert$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0));
 (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_polygon_distinct$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$q$0$li$r$(vs$);
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ drawer_rect2d$s::make_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) const {
 return ::pgl3d$n::drawer$n::make_dgf_noop$f(vptr$);
}
::pgl3d$n::pglbase$n::texture_info$s drawer_rect2d$s::get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 return ::pgl3d$n::pglbase$n::texture_info$s();
}
void drawer_rect2d$s::draw$f(int step$, const ::pgl3d$n::glbuffer$n::vertex_buffer$s& bo$, const ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& bo_ib$, const ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer$s& aibuf$, ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pgl3d$n::shader_config$n::shader_config$s& glc$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) {
 if (step$ == 4LL) {
  ::GL$n::compat$n::glBlendFunc$f(GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA);
  const pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > t0 = sdr_re$;
  ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$& sdr$ = (*(t0));
  ::GL$n::compat$n::glUseProgram$f(sdr$.program$);
  ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_draw$f(aibuf$ , sdr$ , bo$ , bo_ib$ , bo_id$ , glc$.enable_instanced$ , glc$.enable_uniform_instancing$);
 }
}
drawer_rect2d$s::drawer_rect2d$s(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) : count$z(1), sdr_re$(::pgl3d$n::drawer$n::init_rect2d_shader$f(glc$)) {
}
void dgf_particle_internal$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 {
  const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (poly$);
  const size_t sz$fe = ag$fe.size();
  const ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pgl3d$n::glgeometry$n::vertex_attr$s& p$ = ar$fe[i$];
   {
    ::pgl3d$n::drawer$n::particle_vertex_attributes$s x$;
    x$.position$ = p$.pos$;
    (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_point$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(x$);
   }
  }
 }
}
void dgf_particle_bb_internal$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 {
  const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (poly$);
  const size_t sz$fe = ag$fe.size();
  const ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pgl3d$n::glgeometry$n::vertex_attr$s& p$ = ar$fe[i$];
   {
    ::pxcrt::farray< ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s,4LL > vtxs$ = ::pxcrt::farray< ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s,4LL >();
    {
     ::pxcrt::farray< ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s,4LL >& ag$fe = (vtxs$);
     const size_t sz$fe = ag$fe.size();
     ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s *const ar$fe = ag$fe.rawarr();
     for (pxcrt::bt_size_t j$ = 0; j$ != sz$fe; ++j$) {
      ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s& v$ = ar$fe[j$];
      {
       v$.position$ = p$.pos$;
      }
     }
    }
    vtxs$[pxcrt::bt_size_t((0LL))].local_position$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(-1.0) , pxcrt::bt_float(-1.0));
    vtxs$[pxcrt::bt_size_t(1LL)].local_position$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(-1.0));
    vtxs$[pxcrt::bt_size_t(2LL)].local_position$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(1.0));
    vtxs$[pxcrt::bt_size_t(3LL)].local_position$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(pxcrt::bt_float(-1.0) , pxcrt::bt_float(1.0));
    (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_polygon_distinct$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$q$0$li$r$(vtxs$);
   }
  }
 }
}
void dgf_noop$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_particle_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
 return ::callable$n::make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$(vptr$);
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_particle_bb_filler$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
 return ::callable$n::make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$(vptr$);
}
::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_noop$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
 return ::callable$n::make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$(vptr$);
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > triangles_shader_vert$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_bool instancing$, pxcrt::bt_int opt$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat4 view_projection_matrix;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat4 shadowmap_vp;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(true)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mat4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , instancing$ , true)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 position;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 normal;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 tangent;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_position;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_normal;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_tangent;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_binormal;\012")))));
 if (g$.enable_shadowmapping$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec4 vary_smpos;\012")))));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("  vec4 gpos4 = ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , instancing$ , true)))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("    * vec4(position, 1.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  gl_Position = view_projection_matrix * gpos4;\012")));
 if (g$.is_gl3_or_gles3$f()) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("  mat3 normal_matrix = mat3(") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , instancing$ , true))) , pxcrt::bt_strlit(");\012")))));
 } else {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("  mat4 mm = ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , instancing$ , true))) , pxcrt::bt_strlit(";\012")))));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  mat3 normal_matrix = mat3(mm[0].xyz, mm[1].xyz, mm[2].xyz);\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  vary_position = gpos4.xyz / gpos4.w;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  vary_normal = normal_matrix * normal;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  vary_tangent = normal_matrix * tangent;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  vary_uvw = uvw;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  vary_binormal = cross(vary_normal, vary_tangent);\012")));
 if (g$.enable_shadowmapping$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  vary_smpos = shadowmap_vp * gpos4;\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
 return v$;
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > triangles_shader_frag$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_bool instancing$, pxcrt::bt_int opt$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform sampler2D sampler;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform sampler2D sampler_tilemap;\012")));
 if (g$.enable_sampler2dshadow$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform sampler2DShadow sampler_sm;\012")));
 } else {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform sampler2D sampler_sm;\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform vec3 camera_pos;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform vec3 light_pos;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform float light_on;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform mat4 shadowmap_vp;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_position;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_normal;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_tangent;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_binormal;\012")))));
 if (g$.enable_shadowmapping$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec4 vary_smpos;\012")))));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.decl_fragcolor$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec3 light_dir = normalize(light_pos - vary_position);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float light_distance = length(light_pos - vary_position);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\012")));
 if (opt$ != (0LL)) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec4 color_dif = vec4(0.52, 0.28, 0.42, 1.0);\012")));
 } else if (instancing$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec4 color_dif = vec4(0.42, 0.42, 0.42, 1.0);\012")));
 } else {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec4 color_dif = vec4(0.43, 0.42, 0.44, 1.0);\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float mate_ambient = 0.2;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float mate_specular = 0.5;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float distbr = min(100.0 / light_distance , light_on);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec3 nor = vary_normal;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec3 camera_dir = normalize(camera_pos - vary_position);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float is_front = float(dot(camera_dir, nor) > 0.0);\012")));
 if (g$.enable_normalmapping$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tile_size = 32.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tilemap_size = 128.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tiletex_size = 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv0 = vary_uvw.xy / vary_uvw.z;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tm = floor(uv0);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tmfr = uv0 - uv_tm;\012")));
  if (opt$ != (0LL)) {
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 p = uv_tmfr - 0.5;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("if (dot(p, p) < 0.125) { discard; }\012")));
  }
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_ti = uv_tmfr * tile_size;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uvi = floor(uv_ti);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uvj = uv_ti - uvi;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("vec4 ti = ") , g$.texture2d$f()))));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  (sampler_tilemap, uv_tm / tilemap_size);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_pixel = floor(ti.xy * 255.0 + 0.5) * tile_size + uvi;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("mate_ambient = ti.z;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("mate_specular = ti.w;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("vec4 c0 = ") , g$.texture2d$f()))));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  (sampler, uv_pixel / tiletex_size);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float alv0 = floor(c0.a * 255.0 + 0.5);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float avol = floor(alv0 / 16.0);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("int alv = int(alv0 - avol * 16.0 + 0.5);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float lt = float(uvj.y - uvj.x >= 0.0);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float lb = float(uvj.y + uvj.x <= 1.0);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec4 avlv = vec4(float(alv == 1), float(alv == 3), ")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float(alv == 5), float(alv == 7));\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float ut1 = dot(avlv, vec4(-lt, 1.0-lb, 1.0-lt, -lb));\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float vt1 = dot(avlv, vec4(lt-1.0, -lb, lt, 1.0-lb));\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("ut1 += float(alv == 4);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vt1 -= float(alv == 2);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("avol = (avol - 8.0) * distbr * 0.2;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("color += vec4(c0.xyz, 0.0) * float(alv == 10);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("distbr *= float(alv != 10);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec3 nor_delta = vary_tangent * ut1 * avol\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  + vary_binormal * vt1 * avol;\012")));
  if (opt$ != (0LL)) {
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("nor_delta *= is_front;\012")));
  }
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("nor = normalize(nor + nor_delta);\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec3 reflection_vec = reflect(-light_dir, nor);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float cos_angle = max(0.0, dot(camera_dir, reflection_vec));\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float specular = pow(cos_angle, 16.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float diffuse = clamp(dot(light_dir, nor), 0.0, 1.0);\012")));
 if (opt$ == (0LL)) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("specular = min(specular, is_front);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("diffuse = min(diffuse, is_front);\012")));
 }
 if (g$.enable_shadowmapping$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec4 smp = vary_smpos;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec3 smpos = ((smp.xyz / smp.w) + 1.0) * 0.5;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float lflag = float(int(smpos.x <= 0.0) + int(smpos.x >= 1.0)")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  + int(smpos.y <= 0.0) + int(smpos.y >= 1.0) == 0);\012")));
 } else {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float lflag = 1.0;\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float lstr = lflag;\012")));
 if (g$.enable_shadowmapping$) {
  if (g$.enable_depth_texture$) {
   if (g$.enable_sampler2dshadow$) {
    (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("smpos.z *= 0.9995;\012")));
    if (g$.enable_shadowmapping_multisample$) {
     (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("lstr = (")));
     (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.shadow2d$f() , pxcrt::bt_strlit("(sampler_sm, smpos+vec3(-0.0003,-0.0003,0.0)) +")))));
     (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.shadow2d$f() , pxcrt::bt_strlit("(sampler_sm, smpos+vec3(-0.0003,0.0003,0.0)) +")))));
     (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.shadow2d$f() , pxcrt::bt_strlit("(sampler_sm, smpos+vec3(0.0003,-0.0003,0.0)) +")))));
     (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.shadow2d$f() , pxcrt::bt_strlit("(sampler_sm, smpos+vec3(0.0003,0.0003,0.0)))")))));
     if (!g$.is_gl3_or_gles3$f()) {
      (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit(".r")));
     }
     (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  / 4.0;\012")));
    } else {
     (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("lstr = ") , g$.shadow2d$f())) , pxcrt::bt_strlit("(sampler_sm, smpos)")))));
     if (!g$.is_gl3_or_gles3$f()) {
      (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit(".r")));
     }
     (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit(";\012")));
    }
   } else {
    (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("float zval = ") , g$.texture2d$f()))));
    (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("   (sampler_sm, smpos.xy * lflag).x;\012")));
    (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("lstr = float(smpos.z < zval * 1.0005) * lflag;\012")));
   }
  } else {
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("vec4 smz = ") , g$.texture2d$f()))));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  (sampler_sm, smpos.xy * lflag);\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float z0 = floor(smz.r * 255.0 + 0.5);\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float z1 = floor(smz.g * 255.0 + 0.5);\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float z2 = floor(smz.b * 255.0 + 0.5);\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float zval = z0 * 65536.0 + z1 * 256.0 + z2;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("lstr = float(smpos.z * 16770000.0 < zval) * lflag;\012")));
  }
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("color += vec4(1.0, 1.0, 1.0, 1.0)")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  * (mate_specular * specular * distbr * distbr * lstr);\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.fragcolor$f() , pxcrt::bt_strlit(" = color + ")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  (color_dif * (diffuse * distbr * lstr + mate_ambient));\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
 return f$;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > init_particle_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(false)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mat4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , true , false)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform float point_size_base;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 position;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("gl_Position = ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , true , false)))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  * vec4(position, 1.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_PointSize = point_size_base / gl_Position.w;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.decl_fragcolor$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 xy = gl_PointCoord * 2.0 - 1.0;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float d = dot(xy, xy);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float b = max(0.0, 1.0 - d);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.fragcolor$f() , pxcrt::bt_strlit(" = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
 return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("model_matrix"));
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > init_particle_bb_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(false)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mat4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , true , false)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat4 view_projection_matrix;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat3 camera_matrix;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform float point_size_base;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 position;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec2 local_position;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec2 point_coord;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vec4 pos = ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , true , false)))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  * vec4(position, 1.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec3 posb = camera_matrix")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  * vec3(local_position * point_size_base, 0.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_Position = view_projection_matrix * vec4(pos.xyz + posb, 1.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("point_coord = local_position;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.decl_fragcolor$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec2 point_coord;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 xy = point_coord;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float d = dot(xy, xy);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float b = max(0.0, 1.0 - d);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.fragcolor$f() , pxcrt::bt_strlit(" = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
 return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("model_matrix"));
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > init_lineparticle_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$) {
 const pxcrt::bt_bool has_inst$ = true;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(true)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mat3")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("idata")) , true , has_inst$)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat4 view_projection_matrix;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform vec2 screen_size_px;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform float screen_size_base;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec2 vert;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_coord;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec2 edge;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vec4 p0p = view_projection_matrix * vec4(") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("idata")) , true , has_inst$))) , pxcrt::bt_strlit("[0], 1.0);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vec4 p1p = view_projection_matrix * vec4(") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("idata")) , true , has_inst$))) , pxcrt::bt_strlit("[1], 1.0);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float pz0 = p0p.z / p0p.w;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float pz1 = p1p.z / p1p.w;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float pz = (pz0 + pz1) * 0.5;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 p0 = p0p.xy * screen_size_px / p0p.w;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 p1 = p1p.xy * screen_size_px / p1p.w;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float is_posi = min(float(p0p.w > 0.0), float(p1p.w > 0.0));\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 pvec = p1 - p0;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float plen = length(pvec);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vec2 r = screen_size_base * ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("idata")) , true , has_inst$))) , pxcrt::bt_strlit("[2].x"))) , pxcrt::bt_strlit(" / vec2(p0p.w, p1p.w);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float rmx = max(r[0], r[1]);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("r = max(r, rmx - plen * 0.5);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float rp = r[0] + (r[1] - r[0]) * vert.x;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 qvec = normalize(vec2(-pvec.y, pvec.x)) * rp;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float x_extend_0 = (vert.x - 1.0) * r[0] * 0.5 / plen;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float x_extend_1 = vert.x * r[1] * 0.5 / plen;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 vert_ex = vec2(vert.x + x_extend_0 + x_extend_1, vert.y);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 vpos = p0 + mat2(pvec, qvec) * vert_ex;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_Position = vec4(vpos * is_posi / screen_size_px, pz, 1.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 c = vec2(vert.x - 0.5, vert.y) * 2.0;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float rrat = r[1] / r[0];\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float rrat_v = 1.0 + (rrat - 1.0) * vert.x;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_coord = vec3(c, 1.0) * rrat_v;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float edge_rat = clamp(max(r[0], r[1]) / plen, 0.125, 1.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("edge = vec2(1.0 - edge_rat, 1.0 / edge_rat);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.decl_fragcolor$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_coord;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec2 edge;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 c = vary_coord.xy / vary_coord.z;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("c.x = max(abs(c.x) - edge.x, 0.0) * edge.y;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("float a = 1.0 - length(c);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("if (a < 0.25) { discard; };\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.fragcolor$f() , pxcrt::bt_strlit(" = vec4(a * 2.0, a * 2.0, a * 4.0, 1.0);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
 return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit(""));
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > init_font2_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform vec2 screen_size_px;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec2 texture_size_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec2 texture_origin_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec2 char_size_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec2 coord_clamp;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("float char_point_size;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(true)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("vec4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("idata")) , true , true)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec2 vary_texture_size_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec2 vary_texture_origin_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec2 vary_char_size_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec2 vary_coord_clamp;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("float vary_point_size;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vec4 idata_i = ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("idata")) , true , true))) , pxcrt::bt_strlit(";\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("float ch = idata_i.x;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 screen_pos = idata_i.zw;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 screen_px = ")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  floor((screen_pos + 1.0) * screen_size_px * 0.5 + 0.5);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("screen_px += char_point_size * 0.5;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("screen_pos = screen_px / screen_size_px * 2.0 - 1.0;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_Position = vec4(screen_pos, 0.0, 1.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_PointSize = char_point_size;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_texture_size_px = texture_size_px;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_texture_origin_px = texture_origin_px")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  + vec2(char_size_px.x * ch, 0.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_char_size_px = char_size_px;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_coord_clamp = coord_clamp;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_point_size = char_point_size;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("uniform sampler2D sampler;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec2 vary_texture_size_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec2 vary_texture_origin_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec2 vary_char_size_px;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec2 vary_coord_clamp;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("float vary_point_size;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.decl_fragcolor$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 xy = gl_PointCoord;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("if (xy.x > vary_coord_clamp.x) { discard; }\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 pcoord = vary_point_size * xy;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 texcoord = (vary_texture_origin_px + pcoord)")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  / vary_texture_size_px;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("vec4 col = ") , g$.texture2d$f())) , pxcrt::bt_strlit("(sampler, texcoord);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.fragcolor$f() , pxcrt::bt_strlit(" = vec4(1.0, 1.0, 0.0, col.a);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
 return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("idata"));
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > init_rect2d_shader$f(const ::pgl3d$n::shader_config$n::shader_config$s& g$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec2 vert;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(true)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("vec4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("idata")) , true , true)));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$((::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vec4 idata_i = ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("idata")) , true , true))) , pxcrt::bt_strlit(";\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec2 screen_pos = idata_i.xy + idata_i.zw * vert;\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_Position = vec4(screen_pos, 0.0, 1.0);\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.decl_fragcolor$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.fragcolor$f() , pxcrt::bt_strlit(" = vec4(1.0, 1.0, 1.0, 0.3);\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
 return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("idata"));
}
void prepare_instance_data_default$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$) {
 ::pgl3d$n::drawer$n::buffer_append$f$p$aligned$n$$aligned_16$s$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$$r$(idata$.instance_buffer$ , sn$.trans$);
}
void prepare_instance_data_triangles$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$) {
 ::pgl3d$n::drawer$n::buffer_append$f$p$aligned$n$$aligned_16$s$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$$r$(idata$.instance_buffer$ , sn$.trans$);
}
void prepare_instance_data_particle$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$) {
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type mvp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(ncd$.vp$ , sn$.trans$.value));
 ::pgl3d$n::drawer$n::buffer_append$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(idata$.instance_buffer$ , mvp$);
}
void prepare_instance_data_lineparticle$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$) {
 const ::pxcrt::bt_cslice< pxcrt::bt_float > sli$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(sn$.trans$.value);
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(idata$.instance_buffer$ , ::pxcrt::bt_cslice< pxcrt::bt_float >(sli$, pxcrt::bt_size_t((0LL)), pxcrt::bt_size_t(9LL)));
}
void prepare_instance_data_rect2d$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$) {
 const ::pxcrt::bt_cslice< pxcrt::bt_float > sli$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(sn$.trans$.value);
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(idata$.instance_buffer$ , ::pxcrt::bt_cslice< pxcrt::bt_float >(sli$, pxcrt::bt_size_t((0LL)), pxcrt::bt_size_t(4LL)));
}
void prepare_instance_data_font2$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, ::pgl3d$n::pglbase$n::instance_data$s& idata$) {
 const ::pxcrt::bt_cslice< pxcrt::bt_float > sli$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(sn$.trans$.value);
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(idata$.instance_buffer$ , ::pxcrt::bt_cslice< pxcrt::bt_float >(sli$, pxcrt::bt_size_t((0LL)), pxcrt::bt_size_t(4LL)));
}
void prepare_instance_data_ft_rec$f(const ::pgl3d$n::scene_node$n::scene_node$s& sn$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$) {
 const pxcrt::bt_uint& bo_id$ = sn$.joint_id$.bo_id$;
 const pxcrt::bt_int& vs_id$ = sn$.joint_id$.vs_id$;
 if (bo_id$ >= pxcrt::bt_uint((0LL)) && vs_id$ >= (0LL)) {
  ++ncd$.stat_num_objects$;
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > t0((whole_instances$));
  ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > t1(((t0.get())[pxcrt::bt_size_t(bo_id$)]));
  ::pgl3d$n::pglbase$n::instance_data$s& idata$ = (t1.get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(vs_id$)];
  ::pointer$n::tfuncptr$n::tfuncptr3___call$f$p$m$ll$p$m$ll$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$scene_node$s$q$0$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$node_common_data$s$q$1$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$instance_data$s$q$1$li$r$$r$$r$(ftable$[pxcrt::bt_size_t(bo_id$)] , sn$ , ncd$ , idata$);
 }
 {
  const ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >& ag$fe = (sn$.children$);
  ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const ::pgl3d$n::scene_node$n::scene_node$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pgl3d$n::scene_node$n::scene_node$s& snp$ = ar$fe[i$];
   {
    ::pgl3d$n::drawer$n::prepare_instance_data_ft_rec$f(snp$ , ncd$ , ftable$ , whole_instances$);
   }
  }
 }
}
texture_data$s::texture_data$s() : surface_w$(), surface_h$(), char_w$(), char_h$(), char_x$(), texture_id$(){
 /* surface_w$ */;
 /* surface_h$ */;
 /* char_w$ */;
 /* char_h$ */;
 /* char_x$ */;
 /* texture_id$ */;
}
void check_byteorder$f() {
 if (sdl_byteorder() != sdl_lil_endian() && sdl_byteorder() != sdl_big_endian()) {
  PXC_THROW(::exception$n::runtime_error_template$s$p$unknown_20byteorder$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
 }
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("byteorder ") , sdl_byteorder());
}
pxcrt::bt_uint read_3_uint$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$, pxcrt::bt_size_t o$) {
 pxcrt::bt_uint v$ = pxcrt::bt_uint();
 if (sdl_byteorder() == sdl_lil_endian()) {
  v$ += pxcrt::bt_uint(buf$[o$ + pxcrt::bt_size_t(2LL)]);
  v$ *= pxcrt::bt_uint(256LL);
  v$ += pxcrt::bt_uint(buf$[o$ + pxcrt::bt_size_t(1LL)]);
  v$ *= pxcrt::bt_uint(256LL);
  v$ += pxcrt::bt_uint(buf$[o$ + pxcrt::bt_size_t((0LL))]);
 } else if (sdl_byteorder() == sdl_big_endian()) {
  v$ += pxcrt::bt_uint(buf$[o$ + pxcrt::bt_size_t((0LL))]);
  v$ *= pxcrt::bt_uint(256LL);
  v$ += pxcrt::bt_uint(buf$[o$ + pxcrt::bt_size_t(1LL)]);
  v$ *= pxcrt::bt_uint(256LL);
  v$ += pxcrt::bt_uint(buf$[o$ + pxcrt::bt_size_t(2LL)]);
 }
 return v$;
}
void write_4_uint$f(const ::pxcrt::bt_slice< pxcrt::bt_uchar >& buf$, pxcrt::bt_size_t o$, pxcrt::bt_uint val$) {
 if (sdl_byteorder() == sdl_lil_endian()) {
  buf$[o$ + pxcrt::bt_size_t(3LL)] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(val$ >> 24LL);
  buf$[o$ + pxcrt::bt_size_t(2LL)] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(val$ >> 16LL);
  buf$[o$ + pxcrt::bt_size_t(1LL)] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(val$ >> 8LL);
  buf$[o$ + pxcrt::bt_size_t((0LL))] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(val$);
 } else if (sdl_byteorder() == sdl_big_endian()) {
  buf$[o$ + pxcrt::bt_size_t((0LL))] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(val$ >> 24LL);
  buf$[o$ + pxcrt::bt_size_t(1LL)] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(val$ >> 16LL);
  buf$[o$ + pxcrt::bt_size_t(2LL)] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(val$ >> 8LL);
  buf$[o$ + pxcrt::bt_size_t(3LL)] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(val$);
 }
}
void init_font$f(::pgl3d$n::drawer$n::texture_data$s& fnt$) {
 ::pgl3d$n::drawer$n::check_byteorder$f();
 {
  ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,4LL > fnames$ = ::container$n::array$n::make_farray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$4$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("mplus-1m-bold.ttf")) , ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("/Library/Fonts/Osaka.ttf")) , ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("/usr/share/fonts/mplus/mplus-1m-bold.ttf")) , ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("/usr/share/fonts/liberation/LiberationMono-Regular.ttf")));
  ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$ font$;
  {
   ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,4LL >& ag$fe = (fnames$);
   const size_t sz$fe = ag$fe.size();
   ::pxcrt::pxcvarray< pxcrt::bt_uchar > *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    ::pxcrt::pxcvarray< pxcrt::bt_uchar >& fn$ = ar$fe[i$];
    {
     const pxcrt::rawptr< TTF_Font >::type p$ = TTF_OpenFont(::pointer$n::raw_unsafe$n::varray_c_str$f(fn$) , 18LL);
     ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("openfont") , fn$ , pxcrt::rawptr_to_size_t< TTF_Font >(p$));
     font$.reset$f(p$);
     if ((::operator$n::ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$(font$.get$f() , pxcrt::rawptr< TTF_Font >::type()))) {
      break;
     }
    }
   }
  }
  if ((::operator$n::eq$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$(font$.get$f() , pxcrt::rawptr< TTF_Font >::type()))) {
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("failed to load font"));
   PXC_THROW(::exception$n::runtime_error_template$s$p$load_20font$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
  }
  SDL_Color fg$ = SDL_Color();
  fg$.r = pxcrt::bt_uchar(255LL);
  fg$.g = pxcrt::bt_uchar(255LL);
  fg$.b = pxcrt::bt_uchar(255LL);
  fg$.a = pxcrt::bt_uchar(255LL);
  pxcrt::bt_uint hmax$ = pxcrt::bt_uint((0LL));
  pxcrt::bt_uint wmax$ = pxcrt::bt_uint((0LL));
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > > sur_arr$ = ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > >();
  for (pxcrt::bt_int i$ = (0LL); i$ < 96LL; ++i$) {
   ::pxcrt::farray< pxcrt::bt_uchar,2LL > z$ = ::pxcrt::farray< pxcrt::bt_uchar,2LL >();
   z$[pxcrt::bt_size_t((0LL))] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$int$t$r$(i$ + 32LL);
   z$[pxcrt::bt_size_t(1LL)] = pxcrt::bt_uchar(0U);
   const pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > sur$ = ::pointer$n::make_ptr$f$p$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$q$m$ll$r$();
   (((pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > >(sur$))->value)).reset$f(TTF_RenderUTF8_Blended(::operator$n::implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$$r$(font$) , pxcrt::crawptr_to_ccharptr< pxcrt::bt_uchar >(pxcrt::slice_to_crawptr< pxcrt::bt_uchar >(z$.range())) , fg$));
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > >,pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > >(sur_arr$ , sur$);
   const pxcrt::rawptr< SDL_Surface >::type t2 = (((pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > >(sur$))->value)).get$f();
   const ::pxcrt::bt_slice< SDL_Surface > sur_ref$ = pxcrt::rawptr_to_slice< SDL_Surface >(t2 , pxcrt::bt_size_t(1LL));
   hmax$ = ::ordered$n::max$f$p$meta$n$$uint$t$r$(hmax$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(((*(sur_ref$))).h));
   wmax$ = ::ordered$n::max$f$p$meta$n$$uint$t$r$(wmax$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(((*(sur_ref$))).w));
  }
  ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ sur_chars$;
  sur_chars$.reset$f(SDL_CreateRGBSurface(pxcrt::bt_uint((0LL)) , ::pgl3d$n::glgeometry$n::cast_int$f$p$meta$n$$uint$t$r$(::pgl3d$n::drawer$n::power_of_2$f$p$meta$n$$uint$t$r$(wmax$ * 96U)) , ::pgl3d$n::glgeometry$n::cast_int$f$p$meta$n$$uint$t$r$(::pgl3d$n::drawer$n::power_of_2$f$p$meta$n$$uint$t$r$(hmax$)) , 32LL , pxcrt::bt_uint((0LL)) , pxcrt::bt_uint((0LL)) , pxcrt::bt_uint((0LL)) , pxcrt::bt_uint((0LL))));
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("wmax, hmax") , wmax$ , hmax$);
  fnt$.char_x$.clear();
  pxcrt::bt_uint xcur$ = pxcrt::bt_uint((0LL));
  {
   const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > >& ag$fe = (sur_arr$);
   ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > > > ag$fg(ag$fe);
   const size_t sz$fe = ag$fe.size();
   const pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    const pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > ep$ = ar$fe[i$];
    {
     const pxcrt::rawptr< SDL_Surface >::type t1 = (((pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > >(ep$))->value)).get$f();
     const SDL_Surface& e$ = (*(pxcrt::rawptr_to_slice< SDL_Surface >(t1 , pxcrt::bt_size_t(1LL))));
     SDL_Rect r0$ = SDL_Rect();
     SDL_Rect r1$ = SDL_Rect();
     r0$.x = (0LL);
     r0$.y = (0LL);
     r0$.w = e$.w;
     r0$.h = e$.h;
     r1$.x = ::pgl3d$n::glgeometry$n::cast_int$f$p$meta$n$$uint$t$r$(xcur$);
     r1$.y = (0LL);
     r1$.w = r0$.w;
     r1$.h = r1$.h;
     const pxcrt::bt_int v$ = SDL_UpperBlit(::operator$n::implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$r$(((pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > >(ep$))->value)) , pxcrt::caddress< SDL_Rect >(r0$) , ::operator$n::implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$r$(sur_chars$) , pxcrt::address< SDL_Rect >(r1$));
     xcur$ += ::pgl3d$n::glgeometry$n::cast_uint$f$p$meta$n$$uint$t$r$(wmax$);
     ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(fnt$.char_x$ , xcur$);
    }
   }
  }
  fnt$.char_w$ = wmax$;
  fnt$.char_h$ = hmax$;
  const pxcrt::rawptr< SDL_Surface >::type t0 = sur_chars$.get$f();
  const SDL_Surface& sur_chars_ref$ = (*(pxcrt::rawptr_to_slice< SDL_Surface >(t0 , pxcrt::bt_size_t(1LL))));
  fnt$.surface_w$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(sur_chars_ref$.w);
  fnt$.surface_h$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(sur_chars_ref$.h);
  const pxcrt::rawptr< pxcrt::bt_uchar >::type t1 = pxcrt::rawptr_cast< pxcrt::bt_uchar,void >(sur_chars_ref$.pixels);
  const ::pxcrt::bt_slice< pxcrt::bt_uchar > sur_chars_buf$ = pxcrt::rawptr_to_slice< pxcrt::bt_uchar >(t1 , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(sur_chars_ref$.pitch * sur_chars_ref$.h));
  for (pxcrt::bt_int x$ = (0LL); x$ < sur_chars_ref$.w; ++x$) {
   for (pxcrt::bt_int y$ = (0LL); y$ < sur_chars_ref$.h; ++y$) {
    const pxcrt::bt_size_t i$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$((y$ * sur_chars_ref$.w + x$) * 4LL);
    sur_chars_buf$[i$ + pxcrt::bt_size_t((0LL))] = pxcrt::bt_uchar(255LL);
    sur_chars_buf$[i$ + pxcrt::bt_size_t(1LL)] = pxcrt::bt_uchar(255LL);
    sur_chars_buf$[i$ + pxcrt::bt_size_t(2LL)] = pxcrt::bt_uchar(255LL);
   }
  }
  ::GL$n::compat$n::glActiveTexture$f(GL_TEXTURE0);
  fnt$.texture_id$.generate$f();
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("font_texture_id") , fnt$.texture_id$.get$f());
  ::GL$n::compat$n::glBindTexture$f(GL_TEXTURE_2D , fnt$.texture_id$.get$f());
  ::GL$n::compat$n::glTexImage2D$f(GL_TEXTURE_2D , (0LL) , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_RGBA) , sur_chars_ref$.w , sur_chars_ref$.h , (0LL) , GL_RGBA , GL_UNSIGNED_BYTE , ::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$void$t$r$$q$pointer$$raw$n$$rawptr$s$p$meta$n$$void$t$r$$r$(sur_chars_ref$.pixels));
  ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_NEAREST));
  ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_NEAREST));
 }
}
pxcrt::bt_uint get_shift$f257(pxcrt::bt_uint m$) {
 pxcrt::bt_uint r$ = pxcrt::bt_uint((0LL));
 for (pxcrt::bt_uint i$ = pxcrt::bt_uint((0LL)); i$ < pxcrt::bt_uint(32LL); ++i$) {
  if ((m$ & pxcrt::bt_uint(1LL)) != pxcrt::bt_uint((0LL))) {
   break;
  }
  r$ += pxcrt::bt_uint(1LL);
  m$ >>= pxcrt::bt_uint(1LL);
 }
 return r$;
}
void init_main_texture$f(::pgl3d$n::drawer$n::texture_data$s& tex_dpat$, ::pgl3d$n::drawer$n::texture_data$s& tex_tilemap$) {
 ::pgl3d$n::drawer$n::check_byteorder$f();
 {
  ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ sur0$;
  sur0$.reset$f(IMG_Load(::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("dpat.png"))));
  const pxcrt::rawptr< SDL_Surface >::type t0 = sur0$.get$f();
  const SDL_Surface& sur0ref$ = (*(pxcrt::rawptr_to_slice< SDL_Surface >(t0 , pxcrt::bt_size_t(1LL))));
  const pxcrt::rawptr< SDL_PixelFormat >::type fmtp$ = sur0ref$.format;
  const SDL_PixelFormat& fmt$ = (*(pxcrt::rawptr_to_slice< SDL_PixelFormat >(sur0ref$.format , pxcrt::bt_size_t(1LL))));
  const pxcrt::bt_uchar bpp$ = fmt$.BytesPerPixel;
  if (bpp$ != pxcrt::bt_uchar(4LL) && bpp$ != pxcrt::bt_uchar(3LL)) {
   PXC_THROW(::exception$n::runtime_error_template$s$p$img__load$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
  }
  const pxcrt::bt_uint sur0_w$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(sur0ref$.w);
  const pxcrt::bt_uint sur0_h$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(sur0ref$.h);
  pxcrt::bt_uint tex_w$ = ::pgl3d$n::drawer$n::power_of_2$f$p$meta$n$$uint$t$r$(sur0_w$);
  pxcrt::bt_uint tex_h$ = ::pgl3d$n::drawer$n::power_of_2$f$p$meta$n$$uint$t$r$(sur0_h$);
  ::pxcrt::pxcvarray< pxcrt::bt_uint > uibuf$ = ::pxcrt::pxcvarray< pxcrt::bt_uint >();
  ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_int >(uibuf$ , pxcrt::bt_size_t(tex_w$ * tex_h$) , (0LL));
  pxcrt::bt_uint rmask$ = fmt$.Rmask;
  pxcrt::bt_uint gmask$ = fmt$.Gmask;
  pxcrt::bt_uint bmask$ = fmt$.Bmask;
  pxcrt::bt_uint amask$ = fmt$.Amask;
  pxcrt::bt_uint rshift$ = ::pgl3d$n::drawer$n::get_shift$f257(rmask$);
  pxcrt::bt_uint gshift$ = ::pgl3d$n::drawer$n::get_shift$f257(gmask$);
  pxcrt::bt_uint bshift$ = ::pgl3d$n::drawer$n::get_shift$f257(bmask$);
  pxcrt::bt_uint ashift$ = ::pgl3d$n::drawer$n::get_shift$f257(amask$);
  const pxcrt::rawptr< SDL_Surface >::type t1 = sur0$.get$f();
  const SDL_Surface& sur0_ref$ = (*(pxcrt::rawptr_to_slice< SDL_Surface >(t1 , pxcrt::bt_size_t(1LL))));
  const pxcrt::rawptr< pxcrt::bt_uchar >::type t2 = pxcrt::rawptr_cast< pxcrt::bt_uchar,void >(sur0_ref$.pixels);
  const ::pxcrt::bt_slice< pxcrt::bt_uchar > sur0buf$ = pxcrt::rawptr_to_slice< pxcrt::bt_uchar >(t2 , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(sur0_ref$.pitch * sur0_ref$.h));
  for (pxcrt::bt_uint by$ = pxcrt::bt_uint((0LL)); by$ < sur0_h$ / pxcrt::bt_uint(64LL); ++by$) {
   for (pxcrt::bt_uint iy$ = pxcrt::bt_uint((0LL)); iy$ < 32U; ++iy$) {
    for (pxcrt::bt_uint x$ = pxcrt::bt_uint((0LL)); x$ < sur0_w$; ++x$) {
     const pxcrt::bt_uint o0n$ = ((by$ * pxcrt::bt_uint(64LL) + iy$) * sur0_w$ + x$) * pxcrt::bt_uint(bpp$);
     const pxcrt::bt_uint o0c$ = ((by$ * pxcrt::bt_uint(64LL) + iy$ + pxcrt::bt_uint(32LL)) * sur0_w$ + x$) * pxcrt::bt_uint(bpp$);
     const pxcrt::bt_uint o1$ = ((by$ * pxcrt::bt_uint(32LL) + iy$) * tex_w$ + x$) * pxcrt::bt_uint(4LL);
     const pxcrt::bt_uint nor0$ = ::pgl3d$n::drawer$n::read_3_uint$f(sur0buf$ , pxcrt::bt_size_t(o0n$));
     const pxcrt::bt_uint col0$ = ::pgl3d$n::drawer$n::read_3_uint$f(sur0buf$ , pxcrt::bt_size_t(o0c$));
     pxcrt::bt_uint norr$ = (nor0$ >> rshift$) & 255U;
     pxcrt::bt_uint norg$ = (nor0$ >> gshift$) & 255U;
     pxcrt::bt_uint norb$ = (nor0$ >> bshift$) & 255U;
     const pxcrt::bt_uint nor$ = (norr$ << 16LL) | (norg$ << 8LL) | norb$;
     pxcrt::bt_uint colr$ = (col0$ >> rshift$) & 255U;
     pxcrt::bt_uint colg$ = (col0$ >> gshift$) & 255U;
     pxcrt::bt_uint colb$ = (col0$ >> bshift$) & 255U;
     const pxcrt::bt_uint col$ = (colb$ << 16LL) | (colg$ << 8LL) | colr$;
     pxcrt::bt_uint val$ = pxcrt::bt_uint();
     if (nor$ == pxcrt::bt_uint(16711680LL)) {
      val$ = pxcrt::bt_uint(145LL);
     } else if (nor$ == pxcrt::bt_uint(65280LL)) {
      val$ = pxcrt::bt_uint(146LL);
     } else if (nor$ == pxcrt::bt_uint(16776960LL)) {
      val$ = pxcrt::bt_uint(147LL);
     } else if (nor$ == pxcrt::bt_uint(255LL)) {
      val$ = pxcrt::bt_uint(148LL);
     } else if (nor$ == pxcrt::bt_uint(16711935LL)) {
      val$ = pxcrt::bt_uint(149LL);
     } else if (nor$ == pxcrt::bt_uint(65535LL)) {
      val$ = pxcrt::bt_uint(114LL);
     } else if (nor$ == pxcrt::bt_uint(16777215LL)) {
      val$ = pxcrt::bt_uint(151LL);
     } else if (nor$ == pxcrt::bt_uint(8421504LL)) {
      val$ = pxcrt::bt_uint(116LL);
     } else if (nor$ == pxcrt::bt_uint(12599360LL)) {
      val$ = pxcrt::bt_uint(113LL);
     } else if (nor$ == pxcrt::bt_uint(12632128LL)) {
      val$ = pxcrt::bt_uint(115LL);
     } else if (nor$ == pxcrt::bt_uint(12599488LL)) {
      val$ = pxcrt::bt_uint(117LL);
     } else if (nor$ == pxcrt::bt_uint(12632256LL)) {
      val$ = pxcrt::bt_uint(119LL);
     } else if (nor$ == pxcrt::bt_uint(8421568LL)) {
      val$ = pxcrt::bt_uint(15LL);
     }
     uibuf$[pxcrt::bt_size_t((by$ * pxcrt::bt_uint(32LL) + iy$) * tex_w$ + x$)] = (val$ << 24LL) | col$;
    }
   }
  }
  const GLenum mode$ = GL_RGBA;
  ::GL$n::compat$n::glActiveTexture$f(GL_TEXTURE1);
  tex_dpat$.texture_id$.generate$f();
  ::GL$n::compat$n::glBindTexture$f(GL_TEXTURE_2D , tex_dpat$.texture_id$.get$f());
  pxcrt::bt_int mipmap_level$ = (0LL);
  while (true) {
   ::GL$n::compat$n::glTexImage2D$f(GL_TEXTURE_2D , mipmap_level$ , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(mode$) , ::pgl3d$n::glgeometry$n::cast_int$f$p$meta$n$$uint$t$r$(tex_w$) , ::pgl3d$n::glgeometry$n::cast_int$f$p$meta$n$$uint$t$r$(tex_h$) , (0LL) , mode$ , GL_UNSIGNED_BYTE , pxcrt::crawptr_to_cvoidptr< pxcrt::bt_uint >(pxcrt::array_to_crawptr< ::pxcrt::pxcvarray< pxcrt::bt_uint > >(uibuf$)));
   const pxcrt::bt_uint tex_w_prev$ = tex_w$;
   const pxcrt::bt_uint tex_h_prev$ = tex_h$;
   tex_w$ /= pxcrt::bt_uint(2LL);
   tex_h$ /= pxcrt::bt_uint(2LL);
   if (tex_w$ == pxcrt::bt_uint((0LL)) || tex_h$ == pxcrt::bt_uint((0LL)) || mipmap_level$ >= (0LL)) {
    break;
   }
   ++mipmap_level$;
   for (pxcrt::bt_uint y$ = pxcrt::bt_uint((0LL)); y$ < tex_h$; ++y$) {
    for (pxcrt::bt_uint x$ = pxcrt::bt_uint((0LL)); x$ < tex_w$; ++x$) {
     ::pxcrt::farray< pxcrt::bt_uint,4LL > v$ = ::pxcrt::farray< pxcrt::bt_uint,4LL >();
     v$[pxcrt::bt_size_t((0LL))] = uibuf$[pxcrt::bt_size_t((y$ * pxcrt::bt_uint(2LL) + pxcrt::bt_uint((0LL))) * tex_w_prev$ + (x$ * pxcrt::bt_uint(2LL) + pxcrt::bt_uint((0LL))))];
     v$[pxcrt::bt_size_t(1LL)] = uibuf$[pxcrt::bt_size_t((y$ * pxcrt::bt_uint(2LL) + pxcrt::bt_uint((0LL))) * tex_w_prev$ + (x$ * pxcrt::bt_uint(2LL) + pxcrt::bt_uint(1LL)))];
     v$[pxcrt::bt_size_t(2LL)] = uibuf$[pxcrt::bt_size_t((y$ * pxcrt::bt_uint(2LL) + pxcrt::bt_uint(1LL)) * tex_w_prev$ + (x$ * pxcrt::bt_uint(2LL) + pxcrt::bt_uint((0LL))))];
     v$[pxcrt::bt_size_t(3LL)] = uibuf$[pxcrt::bt_size_t((y$ * pxcrt::bt_uint(2LL) + pxcrt::bt_uint(1LL)) * tex_w_prev$ + (x$ * pxcrt::bt_uint(2LL) + pxcrt::bt_uint(1LL)))];
     pxcrt::bt_uint val_b$ = pxcrt::bt_uint();
     pxcrt::bt_uint val_g$ = pxcrt::bt_uint();
     pxcrt::bt_uint val_r$ = pxcrt::bt_uint();
     pxcrt::bt_size_t opaque_count$ = pxcrt::bt_size_t((0LL));
     for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < pxcrt::bt_size_t(4LL); ++j$) {
      val_b$ += (pxcrt::bt_uint(pxcrt::get_elem_value(v$,j$)) >> 16LL) & pxcrt::bt_uint(255LL);
      val_g$ += (pxcrt::bt_uint(pxcrt::get_elem_value(v$,j$)) >> 8LL) & pxcrt::bt_uint(255LL);
      val_r$ += (pxcrt::bt_uint(pxcrt::get_elem_value(v$,j$)) >> (0LL)) & pxcrt::bt_uint(255LL);
      if (((pxcrt::bt_uint(pxcrt::get_elem_value(v$,j$)) >> 24LL) & pxcrt::bt_uint(15LL)) == pxcrt::bt_uint(10LL)) {
       ++opaque_count$;
      }
     }
     val_b$ /= pxcrt::bt_uint(4LL);
     val_g$ /= pxcrt::bt_uint(4LL);
     val_r$ /= pxcrt::bt_uint(4LL);
     const pxcrt::bt_uint val_a$ = opaque_count$ > pxcrt::bt_size_t((0LL)) ? 10U : (pxcrt::bt_uint(pxcrt::get_elem_value(v$,pxcrt::bt_size_t((0LL)))) >> 24LL) & pxcrt::bt_uint(255LL);
    }
   }
  }
  ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_NEAREST));
  ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(mipmap_level$ > (0LL) ? GL_NEAREST_MIPMAP_NEAREST : GL_NEAREST));
  tex_dpat$.surface_w$ = tex_w$;
  tex_dpat$.surface_h$ = tex_h$;
  /* staticif empty */
 }
 {
  ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ sur1$;
  sur1$.reset$f(SDL_CreateRGBSurface(pxcrt::bt_uint((0LL)) , 128LL , 128LL , 32LL , pxcrt::bt_uint((0LL)) , pxcrt::bt_uint((0LL)) , pxcrt::bt_uint((0LL)) , pxcrt::bt_uint((0LL))));
  const pxcrt::rawptr< SDL_Surface >::type t0 = sur1$.get$f();
  const SDL_Surface& sur1_ref$ = (*(pxcrt::rawptr_to_slice< SDL_Surface >(t0 , pxcrt::bt_size_t(1LL))));
  const pxcrt::rawptr< pxcrt::bt_uchar >::type t1 = pxcrt::rawptr_cast< pxcrt::bt_uchar,void >(sur1_ref$.pixels);
  const ::pxcrt::bt_slice< pxcrt::bt_uchar > sur1buf$ = pxcrt::rawptr_to_slice< pxcrt::bt_uchar >(t1 , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(sur1_ref$.pitch * sur1_ref$.h));
  const pxcrt::bt_uint sur1_w$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(sur1_ref$.w);
  const pxcrt::bt_uint sur1_h$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(sur1_ref$.h);
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(333U);
  for (pxcrt::bt_uint y$ = pxcrt::bt_uint((0LL)); y$ < sur1_h$; ++y$) {
   for (pxcrt::bt_uint x$ = pxcrt::bt_uint((0LL)); x$ < sur1_w$; ++x$) {
    const pxcrt::bt_uint o1$ = (y$ * sur1_w$ + x$) * pxcrt::bt_uint(4LL);
    const pxcrt::bt_uint v0$ = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >(rnd$))->value)).generate$f() / pxcrt::bt_uint(65536LL);
    const pxcrt::bt_uint v1$ = v0$ % pxcrt::bt_uint(8LL);
    const pxcrt::bt_uint v2$ = (v0$ / pxcrt::bt_uint(8LL)) % pxcrt::bt_uint(8LL);
    const pxcrt::bt_uint specular_ambient$ = pxcrt::bt_uint(65376LL);
    if (x$ == pxcrt::bt_uint((0LL)) && y$ == pxcrt::bt_uint((0LL))) {
     ::pgl3d$n::drawer$n::write_4_uint$f(sur1buf$ , pxcrt::bt_size_t(o1$) , specular_ambient$ << 16LL);
    } else {
     ::pgl3d$n::drawer$n::write_4_uint$f(sur1buf$ , pxcrt::bt_size_t(o1$) , (v1$ % pxcrt::bt_uint(8LL)) | specular_ambient$ << 16LL);
    }
   }
  }
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("sur1buf") , sur1_w$ , sur1_h$);
  const GLenum mode$ = GL_RGBA;
  ::GL$n::compat$n::glActiveTexture$f(GL_TEXTURE2);
  tex_tilemap$.surface_w$ = sur1_w$;
  tex_tilemap$.surface_h$ = sur1_h$;
  tex_tilemap$.texture_id$.generate$f();
  ::GL$n::compat$n::glBindTexture$f(GL_TEXTURE_2D , tex_tilemap$.texture_id$.get$f());
  ::GL$n::compat$n::glTexImage2D$f(GL_TEXTURE_2D , (0LL) , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(mode$) , ::pgl3d$n::glgeometry$n::cast_int$f$p$meta$n$$int$t$r$(sur1_ref$.w) , ::pgl3d$n::glgeometry$n::cast_int$f$p$meta$n$$int$t$r$(sur1_ref$.h) , (0LL) , mode$ , GL_UNSIGNED_BYTE , pxcrt::crawptr_to_cvoidptr< pxcrt::bt_uchar >(pxcrt::slice_to_crawptr< pxcrt::bt_uchar >(sur1buf$)));
  ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_NEAREST));
  ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_NEAREST));
 }
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace drawer_export$n { 
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_triangles$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$, pxcrt::bt_int opt$) {
 return ::pointer$n::make_ptr$f$p$pgl3d$$drawer$n$$drawer_triangles$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(glc$ , opt$);
}
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_triangles2$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) {
 return ::pointer$n::make_ptr$f$p$pgl3d$$drawer$n$$drawer_triangles2$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(glc$);
}
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_lineparticle$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) {
 return ::pointer$n::make_ptr$f$p$pgl3d$$drawer$n$$drawer_lineparticle$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(glc$);
}
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_particle$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) {
 return ::pointer$n::make_ptr$f$p$pgl3d$$drawer$n$$drawer_particle$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(glc$);
}
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_particle_bb$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) {
 return ::pointer$n::make_ptr$f$p$pgl3d$$drawer$n$$drawer_particle_bb$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(glc$);
}
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_rect2d$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) {
 return ::pointer$n::make_ptr$f$p$pgl3d$$drawer$n$$drawer_rect2d$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(glc$);
}
pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > make_drawer_font2$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$) {
 return ::pointer$n::make_ptr$f$p$pgl3d$$drawer$n$$drawer_font2$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(glc$);
}
};}; /* namespace pgl3d::drawer_export */
namespace io$n { namespace environ$n { 
::pxcrt::pxcvarray< pxcrt::bt_uchar > get_option$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) {
 const pxcrt::bt_size_t sz$ = name$.size();
 {
  const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& ag$fe = (pxcrt::pxc_argv);
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const ::pxcrt::pxcvarray< pxcrt::bt_uchar > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ar$fe[i$];
   {
    if (s$.size() >= sz$ && eq_memcmp(::pxcrt::bt_cslice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get()), pxcrt::bt_size_t((0LL)), sz$),name$)) {
     if (s$.size() > sz$ && pxcrt::bt_uchar(pxcrt::get_elem_value(s$,sz$)) == 61U) {
      return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(::pxcrt::bt_cslice< pxcrt::bt_uchar >(s$, sz$ + pxcrt::bt_size_t(1LL), s$.size()));
     } else {
      return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"));
     }
    }
   }
  }
 }
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > getenv$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > x$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(name$);
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(x$ , 61U);
 const pxcrt::bt_size_t len$ = x$.size();
 {
  const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& ag$fe = (pxcrt::pxc_environ);
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const ::pxcrt::pxcvarray< pxcrt::bt_uchar > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ar$fe[i$];
   {
    if (eq_memcmp(::pxcrt::bt_cslice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get()), pxcrt::bt_size_t((0LL)), len$),(::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (x$).get_crange()))) {
     return ::pxcrt::pxcvarray< pxcrt::bt_uchar >(::pxcrt::bt_cslice< pxcrt::bt_uchar >(s$, len$, s$.size()));
    }
   }
  }
 }
 return ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
}
};}; /* namespace io::environ */
namespace pgl3d$n { namespace pglcommon$n { 
pxcrt::bt_float to_radians$f(pxcrt::bt_float deg$) {
 return deg$ * 3.14159265f / 180.0f;
}
};}; /* namespace pgl3d::pglcommon */
namespace pgl3d$n { namespace pglmotion$n { 
motion_thread_shared$s::motion_thread_shared$s(const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances0$, const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >& pss0$, const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >& pidft0$) : whole_instances$(whole_instances0$), pss$(pss0$), pidft$(pidft0$), modifying$(false), terminate_motion_thread$(false), frame_speed_mul$(1.0f), cam$(), message$(), stat_num_objects$(), commands$() {
}
motion_thread_object$s::~motion_thread_object$s() PXC_NOTHROW {
 try {
  pxcrt::lock_guard< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > lck$((sharedp$));
  (((lck$)->value)).terminate_motion_thread$ = true;
  lck$.notify_one();
 } catch (...) { ::abort(); }
}
motion_thread_object$s::motion_thread_object$s(const ::pgl3d$n::scene_node$n::node_factory$s& nfac$, const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >& pss$, const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >& pidft$) : sharedp$(::pointer$n::make_tptr$f$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$container$$array$n$$varray$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$pgl3d$$application$n$$pgl3d_scene_shared$i$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$0$li$r$$r$$r$(whole_instances$ , pss$ , pidft$)), thr$(::thread$n::make_thread_ptr$f$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(sharedp$ , nfac$)) {
}
void motion_thread_main$f(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& sptr$, const ::pgl3d$n::scene_node$n::node_factory$s& nfac0$) {
 const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene$i > ps$ = ((*((pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >::guard_val< const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i > > (((((pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >::guard_val< const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > > (sptr$).get()))->value)).pss$).get())))).make_scene$f(nfac0$);
 pxcrt::lock_guard< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > lck$((sptr$));
 while (true) {
  ::pgl3d$n::pglmotion$n::motion_thread_shared$s& shared$ = ((lck$)->value);
  if (shared$.terminate_motion_thread$) {
   break;
  }
  if (!shared$.modifying$) {
   lck$.wait();
   continue;
  }
  {
   ::pgl3d$n::pglmotion$n::clear_instances$f(shared$.whole_instances$);
   ::pgl3d$n::pglbase$n::position_angle$s camera_upd$;
   ::pgl3d$n::pglbase$n::position_angle$s light_upd$;
   ((*(pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene$i >(ps$)))).on_motion_step$f(shared$.frame_speed_mul$ , shared$.cam$ , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (shared$.message$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > ((((pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >::guard_val< const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > > (shared$.pidft$).get()))->value)).get_crange()) , shared$.whole_instances$ , (*((pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >::guard_val< const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i > > (shared$.pss$).get()))) , camera_upd$ , light_upd$ , shared$.commands$);
   shared$.cam$.camera$ = camera_upd$;
   shared$.cam$.light$ = light_upd$;
  }
  shared$.modifying$ = false;
  lck$.notify_one();
 }
}
void clear_instances$f(::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$) {
 {
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& ag$fe = (whole_instances$);
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t bo_id$ = 0; bo_id$ != sz$fe; ++bo_id$) {
   ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& instances$ = ar$fe[bo_id$];
   {
    {
     ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& ag$fe = (instances$);
     ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > ag$fg(ag$fe);
     const size_t sz$fe = ag$fe.size();
     ::pgl3d$n::pglbase$n::instance_data$s *const ar$fe = ag$fe.rawarr();
     for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
      ::pgl3d$n::pglbase$n::instance_data$s& ai$ = ar$fe[i$];
      {
       ai$.instance_buffer$.clear();
      }
     }
    }
   }
  }
 }
}
};}; /* namespace pgl3d::pglmotion */
namespace pgl3d$n { namespace pglshader$n { 
::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type pglshader$s::to_vbid$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 return vbid_pool$.to_id$f(name$);
}
::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type pglshader$s::intern_vbid$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) {
 const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type r$ = vbid_pool$.intern$f(name$);
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_strlit("intern ") , name$ , r$);
 return r$;
}
void pglshader$s::set_vertex_buffer$f(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type vbid$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >& p$) {
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >(vertex_buffers$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(vbid$) + pxcrt::bt_size_t(1LL) , ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$r$$r$(0U , false , false));
 vertex_buffers$[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(vbid$)] = p$;
}
void pglshader$s::init$f() {
 /* staticif empty */
 /* staticif empty */
 /* staticif empty */
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type >,pxcrt::bt_int >(drawer_vbids$ , drawers$.size() , (0LL));
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type >,pxcrt::bt_int >(drawer_main_vbids$ , drawers$.size() , (0LL));
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >& ag$fe = (drawers$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >& pd$ = ar$fe[i$];
   {
    (::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type > > (drawer_vbids$).get())[i$] = intern_vbid$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).get_vbid_name$f()).get_crange()));
    (::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type > > (drawer_main_vbids$).get())[i$] = intern_vbid$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).get_main_vbid_name$f()).get_crange()));
    pxcrt::bt_size_t j$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$((::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type > > (drawer_vbids$).get())[i$]);
    {
     pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >::guard_val< const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > > t0((pidft$));
     ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& pidftv$ = (((t0.get()))->value);
     if (pidftv$.size() <= j$) {
      ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >,pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >(pidftv$ , j$ + pxcrt::bt_size_t(1LL) , ::pointer$n::tfuncptr$n::make_tfuncptr$f$p$pgl3d$$drawer_base$n$$prepare_instance_data_noop$f$r$());
      (::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >::guard_ref< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > (pidftv$).get())[j$] = ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).get_prepare_instance_data_funcptr$f();
     }
    }
    set_vertex_buffer$f(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type(pxcrt::get_elem_value(drawer_vbids$,i$)) , ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).make_vertex_buffer$f());
   }
  }
 }
}
void pglshader$s::prepare$f(::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances_r$, ::pgl3d$n::scene_node$n::node_factory$s& nfac_r$) {
 prepare_builtin_vertex_sets$f();
 prepare_vertex_buffers$f();
 prepare_whole_instances$f(whole_instances_r$);
 prepare_node_factory$f(nfac_r$);
}
void pglshader$s::prepare_builtin_vertex_sets$f() {
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >& ag$fe = (drawers$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >& pd$ = ar$fe[i$];
   {
    const ::pxcrt::pxcvarray< pxcrt::bt_uchar > name$ = ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).builtin_vertex_set_name$f();
    if (name$.empty()) {
     continue;
    }
    const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$ = drawer_vbids$[i$];
    const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > vtx$ = make_vertices$f(bo_id$ , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (name$).get_crange()));
    ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).make_builtin_vertex_sets$f(vtx$);
   }
  }
 }
}
void pglshader$s::prepare_vertex_buffers$f() {
 const pxcrt::bt_bool enable_copying_instancing$ = !glc$.enable_instanced$;
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >& ag$fe = (vertex_buffers$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >& bo$ = ar$fe[i$];
   {
    (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(bo$))->value)).create_vbo$f(enable_copying_instancing$);
   }
  }
 }
}
void pglshader$s::prepare_whole_instances$f(::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$) const {
 const pxcrt::bt_bool enable_copying_instancing$ = !glc$.enable_instanced$;
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >,::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >(whole_instances$ , vertex_buffers$.size() , ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >());
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >& ag$fe = (vertex_buffers$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >& bo$ = ar$fe[i$];
   {
    ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > t0((whole_instances$));
    ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >& instances$ = (t0.get())[i$];
    for (pxcrt::bt_size_t j$ = pxcrt::bt_size_t((0LL)); j$ < (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(bo$))->value)).vs_arr$.size(); ++j$) {
     ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >,::pgl3d$n::pglbase$n::instance_data$s >(instances$ , ::pgl3d$n::pglbase$n::instance_data$s());
    }
   }
  }
 }
}
void pglshader$s::prepare_node_factory$f(::pgl3d$n::scene_node$n::node_factory$s& nf$) const {
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >& ag$fe = (vertex_buffers$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t bo_id$ = 0; bo_id$ != sz$fe; ++bo_id$) {
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >& bop$ = ar$fe[bo_id$];
   {
    {
          const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > t0 = bop$;
const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& ag$fe = ((((t0)->value)).vs_names$);
     pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > ag$fg(ag$fe);
     for (pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::const_iterator i$fe = ag$fe.begin(); i$fe != ag$fe.end(); ++i$fe) {
      const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& n$ = ag$fe.get_ckey(i$fe);
      const pxcrt::bt_size_t id$ = ag$fe.get_cmapped(i$fe);
      {
       if ((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(bop$))->value)).is_sub_drawer$) {
        continue;
       }
       ::pgl3d$n::scene_node$n::joint_id_type$s jid$;
       jid$.bo_id$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(bo_id$);
       jid$.vs_id$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(id$);
       nf$.name_to_id$[n$] = jid$;
      }
     }
    }
    ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_buffer_info$s >,::pgl3d$n::scene_node$n::node_buffer_info$s >(nf$.binfo$ , ::pgl3d$n::scene_node$n::node_buffer_info$s());
    ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_buffer_info$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_buffer_info$s > > t1((nf$.binfo$));
    ::pgl3d$n::scene_node$n::node_buffer_info$s& nbi$ = (t1.get())[nf$.binfo$.size() - pxcrt::bt_size_t(1LL)];
    {
          const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > t2 = bop$;
const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >& ag$fe = ((((t2)->value)).vs_arr$);
     ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > > > ag$fg(ag$fe);
     const size_t sz$fe = ag$fe.size();
     const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > *const ar$fe = ag$fe.rawarr();
     for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
      const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >& vsp$ = ar$fe[i$];
      {
       ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_vs_info$s >,::pgl3d$n::scene_node$n::node_vs_info$s >(nbi$.vs_arr$ , ::pgl3d$n::scene_node$n::node_vs_info$s());
       ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_vs_info$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_vs_info$s > > t0((nbi$.vs_arr$));
       ::pgl3d$n::scene_node$n::node_vs_info$s& nvi$ = (t0.get())[nbi$.vs_arr$.size() - pxcrt::bt_size_t(1LL)];
       {
                const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > t2 = (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >(vsp$))->value)).vtxs$;
const ::pxcrt::pxcvarray< ::pgl3d$n::glvertex$n::node_joint$s >& ag$fe = ((((t2)->value)).joints$);
        ::pxcrt::pxcvarray< ::pgl3d$n::glvertex$n::node_joint$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::glvertex$n::node_joint$s > > ag$fg(ag$fe);
        const size_t sz$fe = ag$fe.size();
        const ::pgl3d$n::glvertex$n::node_joint$s *const ar$fe = ag$fe.rawarr();
        for (pxcrt::bt_size_t j$ = 0; j$ != sz$fe; ++j$) {
         const ::pgl3d$n::glvertex$n::node_joint$s& nj$ = ar$fe[j$];
         {
          ::pgl3d$n::scene_node$n::node_joint_info$s nji$;
          nji$.joint_id$ = find_joint_id_by_name$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (nj$.joint_name$).get_crange()));
          nji$.trans$ = nj$.trans$;
          ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::node_joint_info$s >,::pgl3d$n::scene_node$n::node_joint_info$s >(nvi$.joints$ , nji$);
         }
        }
       }
      }
     }
    }
   }
  }
 }
}
::pgl3d$n::scene_node$n::joint_id_type$s pglshader$s::find_joint_id_by_name$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 ::pgl3d$n::scene_node$n::joint_id_type$s scene_id$;
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >& ag$fe = (vertex_buffers$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >& bo$ = ar$fe[i$];
   {
    if (!(((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(bo$))->value)).is_sub_drawer$ && (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(bo$))->value)).has_name$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >(name$))) {
     scene_id$.bo_id$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(i$);
     scene_id$.vs_id$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(bo$))->value)).get_id_by_name$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >(name$)));
     break;
    }
   }
  }
 }
 return scene_id$;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > pglshader$s::get_vertices$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 ::pgl3d$n::scene_node$n::joint_id_type$s jid$ = find_joint_id_by_name$f(name$);
 return (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > (vertex_buffers$).get()),::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$uint$t$r$(jid$.bo_id$))))->value)).get_vertices$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(jid$.vs_id$));
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > pglshader$s::make_vertices$f(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) {
 return (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > (vertex_buffers$).get()),::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(bo_id$))))->value)).make_if$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >(name$))))->value)).vtxs$;
}
void pglshader$s::make_vertex_set$f(const ::pxcrt::bt_cslice< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& dr_names$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& expr$) {
 ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > > vptrs$ = ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >();
 ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ > fillers$ = ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >();
 {
  const ::pxcrt::bt_cslice< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >& ag$fe = (dr_names$);
  const size_t sz$fe = ag$fe.size();
  const ::pxcrt::pxcvarray< pxcrt::bt_uchar > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& dr_name$ = ar$fe[i$];
   {
    pxcrt::bt_size_t dr_id$ = (((pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > (drawer_names$).get()).equal_range(dr_name$)).deref());
    const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$ = drawer_vbids$[dr_id$];
    pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > vptr$ = make_vertices$f(bo_id$ , name$);
    ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ filler$ = ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >::guard_ref< ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > > (drawers$).get()),dr_id$))))).make_filler$f(vptr$);
    ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >(vptrs$ , vptr$);
    ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >,::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >(fillers$ , filler$);
   }
  }
 }
 pxcrt::rcptr< ::pgl3d$n::glgeometry$n::build_context_i$i > ctx$ = ::pointer$n::make_ptr$f$p$pgl3d$$pglshader$n$$build_context_impl$s$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$1$li$r$$r$$r$(vptrs$ , fillers$);
 expr$.__call$f((*(pxcrt::rcptr< ::pgl3d$n::glgeometry$n::build_context_i$i >(ctx$))) , ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >() , ::pgl3d$n::glgeometry$n::mesh_index$s());
}
::pgl3d$n::pglbase$n::texture_info$s pglshader$s::get_texture_info$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) const {
 ::pgl3d$n::pglbase$n::texture_info$s r$;
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >& ag$fe = (drawers$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >& pd$ = ar$fe[i$];
   {
    const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$ = drawer_vbids$[i$];
    r$ = ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).get_texture_info$f(name$);
    if (r$.surface_w$ != pxcrt::bt_uint((0LL))) {
     break;
    }
   }
  }
 }
 return r$;
}
void pglshader$s::resize_screen$f(pxcrt::bt_int width$, pxcrt::bt_int height$) {
 cam$.screen_width$ = width$;
 cam$.screen_height$ = height$;
 {
  sfbo$.sm_width$ = 1024LL;
  sfbo$.sm_height$ = 1024LL;
 }
 ::pgl3d$n::pglshader$n::init_shadowmap_fbo$f(glc$ , sfbo$);
 ::pgl3d$n::pglshader$n::update_mvp$f(cam$);
}
pglshader$s::pglshader$s(const ::pgl3d$n::shader_config$n::shader_config$s& sconf0$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& drawers0$, pxcrt::bt_int width0$, pxcrt::bt_int height0$) : count$z(1), glc$(sconf0$), drawer_names$(::pgl3d$n::pglshader$n::get_drawer_names$f(drawers0$)), drawers$(::pgl3d$n::pglshader$n::downcast_drawers$f(drawers0$)), drawer_vbids$(), drawer_main_vbids$(), sfbo$(), cam$(), vertex_buffers$(), agg_ibuffer$(), pidft$(::pointer$n::make_tptr$f$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$q$m$ll$r$()), vtxarr$(), vertex_buffer_id_map$(), vbid_pool$() {
 init$f();
 resize_screen$f(width0$ , height0$);
}
::pxcrt::pxcvarray< pxcrt::bt_uint > pglshader_draw_frame$f(::pgl3d$n::pglshader$n::pglshader$s& pgs$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, const ::pgl3d$n::pglbase$n::projection_info$s& cam_df$) {
 const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >& bos$ = pgs$.vertex_buffers$;
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_view$ = glm::inverse< pxcrt::bt_float >(cam_df$.light$.to_mat4$f());
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(cam_df$.sm_projection$ , sm_view$));
 const pxcrt::bt_uint tick1$ = SDL_GetTicks();
 ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_frame_begin$f(pgs$.agg_ibuffer$ , whole_instances$ , pgs$.glc$.enable_instanced$ , pgs$.glc$.enable_uniform_instancing$);
 const pxcrt::bt_uint tick2$ = SDL_GetTicks();
 if (pgs$.glc$.enable_shadowmapping$) {
  pxcrt::bt_int saved_fb$ = pxcrt::bt_int();
  ::GL$n::compat$n::glGetIntegerv$f(GL_FRAMEBUFFER_BINDING , pxcrt::address< pxcrt::bt_int >(saved_fb$));
  ::GL$n::compat$n::glBindFramebuffer$f(GL_FRAMEBUFFER , pgs$.sfbo$.fbo$.get$f());
  ::GL$n::compat$n::glViewport$f((0LL) , (0LL) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(pgs$.sfbo$.sm_width$) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(pgs$.sfbo$.sm_height$));
  ::GL$n::compat$n::glDisable$f(GL_CULL_FACE);
  ::GL$n::compat$n::glEnable$f(GL_DEPTH_TEST);
  ::GL$n::compat$n::glDepthMask$f(pxcrt::bt_uchar(1LL));
  if (pgs$.glc$.enable_depth_texture$) {
   ::GL$n::compat$n::glColorMask$f(pxcrt::bt_uchar((0LL)) , pxcrt::bt_uchar((0LL)) , pxcrt::bt_uchar((0LL)) , pxcrt::bt_uchar((0LL)));
  } else {
   ::GL$n::compat$n::glColorMask$f(pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL));
  }
  ::GL$n::compat$n::glDepthFunc$f(GL_LEQUAL);
  ::GL$n::compat$n::glDisable$f(GL_BLEND);
  ::GL$n::compat$n::glClear$f(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  {
   const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >& ag$fe = (pgs$.drawers$);
   ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > > ag$fg(ag$fe);
   const size_t sz$fe = ag$fe.size();
   const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >& pd$ = ar$fe[i$];
    {
     const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$ = pgs$.drawer_vbids$[i$];
     const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type main_bo_id$ = pgs$.drawer_main_vbids$[i$];
     ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).draw$f(1LL , ((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > (bos$).get()),::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(bo_id$))))->value) , (::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > (whole_instances$).get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(main_bo_id$)] , pgs$.agg_ibuffer$ , bo_id$ , pgs$.glc$ , cam_df$);
    }
   }
  }
  ::GL$n::compat$n::glBindFramebuffer$f(GL_FRAMEBUFFER , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(saved_fb$));
 }
 ::GL$n::compat$n::glViewport$f((0LL) , (0LL) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(pgs$.cam$.screen_width$) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(pgs$.cam$.screen_height$));
 if (pgs$.glc$.enable_zprepass$) {
  ::GL$n::compat$n::glDisable$f(GL_CULL_FACE);
  ::GL$n::compat$n::glEnable$f(GL_DEPTH_TEST);
  ::GL$n::compat$n::glDepthFunc$f(GL_LESS);
  ::GL$n::compat$n::glDepthMask$f(pxcrt::bt_uchar(1LL));
  ::GL$n::compat$n::glDisable$f(GL_BLEND);
  ::GL$n::compat$n::glClear$f(GL_DEPTH_BUFFER_BIT);
  ::GL$n::compat$n::glColorMask$f(pxcrt::bt_uchar((0LL)) , pxcrt::bt_uchar((0LL)) , pxcrt::bt_uchar((0LL)) , pxcrt::bt_uchar((0LL)));
  {
   const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >& ag$fe = (pgs$.drawers$);
   ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > > ag$fg(ag$fe);
   const size_t sz$fe = ag$fe.size();
   const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >& pd$ = ar$fe[i$];
    {
     const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$ = pgs$.drawer_vbids$[i$];
     const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type main_bo_id$ = pgs$.drawer_main_vbids$[i$];
     ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).draw$f(2LL , ((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > (bos$).get()),::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(bo_id$))))->value) , (::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > (whole_instances$).get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(main_bo_id$)] , pgs$.agg_ibuffer$ , bo_id$ , pgs$.glc$ , cam_df$);
    }
   }
  }
 }
 {
  ::GL$n::compat$n::glDisable$f(GL_BLEND);
  ::GL$n::compat$n::glDisable$f(GL_CULL_FACE);
  ::GL$n::compat$n::glEnable$f(GL_DEPTH_TEST);
  if (pgs$.glc$.enable_zprepass$) {
   ::GL$n::compat$n::glColorMask$f(pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL));
   ::GL$n::compat$n::glDepthFunc$f(GL_EQUAL);
   ::GL$n::compat$n::glClear$f(GL_COLOR_BUFFER_BIT);
  } else {
   ::GL$n::compat$n::glDepthMask$f(pxcrt::bt_uchar(1LL));
   ::GL$n::compat$n::glDepthFunc$f(GL_LESS);
   ::GL$n::compat$n::glColorMask$f(pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL));
   ::GL$n::compat$n::glClear$f(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  }
  {
   const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >& ag$fe = (pgs$.drawers$);
   ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > > ag$fg(ag$fe);
   const size_t sz$fe = ag$fe.size();
   const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >& pd$ = ar$fe[i$];
    {
     const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$ = pgs$.drawer_vbids$[i$];
     const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type main_bo_id$ = pgs$.drawer_main_vbids$[i$];
     ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).draw$f(3LL , ((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > (bos$).get()),::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(bo_id$))))->value) , (::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > (whole_instances$).get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(main_bo_id$)] , pgs$.agg_ibuffer$ , bo_id$ , pgs$.glc$ , cam_df$);
    }
   }
  }
 }
 {
  ::GL$n::compat$n::glDisable$f(GL_CULL_FACE);
  ::GL$n::compat$n::glEnable$f(GL_DEPTH_TEST);
  ::GL$n::compat$n::glDepthFunc$f(GL_LEQUAL);
  ::GL$n::compat$n::glDepthMask$f(pxcrt::bt_uchar((0LL)));
  ::GL$n::compat$n::glEnable$f(GL_BLEND);
  ::GL$n::compat$n::glBlendFunc$f(GL_ONE , GL_ONE);
  {
   const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >& ag$fe = (pgs$.drawers$);
   ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > > ag$fg(ag$fe);
   const size_t sz$fe = ag$fe.size();
   const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    const pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >& pd$ = ar$fe[i$];
    {
     const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type bo_id$ = pgs$.drawer_vbids$[i$];
     const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type main_bo_id$ = pgs$.drawer_main_vbids$[i$];
     ((*(pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >(pd$)))).draw$f(4LL , ((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > > > (bos$).get()),::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(bo_id$))))->value) , (::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > (whole_instances$).get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(main_bo_id$)] , pgs$.agg_ibuffer$ , bo_id$ , pgs$.glc$ , cam_df$);
    }
   }
  }
 }
 ::pgl3d$n::aggregated_ibuffer$n::aggregated_ibuffer_frame_end$f(pgs$.agg_ibuffer$ , pgs$.glc$.enable_instanced$ , pgs$.glc$.enable_uniform_instancing$);
 return ::container$n::array$n::make_varray_func$f$p$meta$n$$uint$t$q$2$li$r$(tick1$ , tick2$);
}
pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > get_drawer_names$f(const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& drawers$) {
 pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL));
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > r$ = pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >();
 {
  const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& ag$fe = (drawers$);
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > ag$fg(ag$fe);
  for (pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::const_iterator i$fe = ag$fe.begin(); i$fe != ag$fe.end(); ++i$fe) {
   const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& k$ = ag$fe.get_ckey(i$fe);
   const pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >& e$ = ag$fe.get_cmapped(i$fe);
   {
    r$[k$] = i$;
    ++i$;
   }
  }
 }
 return r$;
}
::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > downcast_drawers$f(const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& drawers$) {
 ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > > r$ = ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >();
 {
  const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& ag$fe = (drawers$);
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > ag$fg(ag$fe);
  for (pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::const_iterator i$fe = ag$fe.begin(); i$fe != ag$fe.end(); ++i$fe) {
   const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& k$ = ag$fe.get_ckey(i$fe);
   const pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >& e$ = ag$fe.get_cmapped(i$fe);
   {
    ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >,pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i > >(r$ , pxcrt::pointer_downcast< pxcrt::rcptr< ::pgl3d$n::drawer$n::pgldrawer_i$i >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i > >(e$));
   }
  }
 }
 return r$;
}
void build_context_impl$s::fill$f(pxcrt::bt_bool flat_flag$, pxcrt::bt_bool polyjoint$, pxcrt::bt_size_t n$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) const {
 if (joint_name$.empty()) {
  (::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >::guard_ref< const ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ > > (fillers$).get())[n$].__call$f(flat_flag$ , poly$ , mp$);
 } else if (polyjoint$) {
  ::pgl3d$n::pglshader$n::dgf_poly_joint_internal$f((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > > > (vptrs$).get())[pxcrt::bt_size_t((0LL))] , joint_name$ , poly$ , mp$);
 } else {
  ::pgl3d$n::pglshader$n::dgf_point_joint_internal$f((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > > > (vptrs$).get())[pxcrt::bt_size_t((0LL))] , joint_name$ , poly$ , mp$);
 }
}
build_context_impl$s::build_context_impl$s(::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >& vptrs0$, ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& fillers0$) : count$z(1), vptrs$(), fillers$() {
 ::pxcrt::pxcvarray_swap< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >(vptrs$ , vptrs0$);
 ::pxcrt::pxcvarray_swap< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >(fillers$ , fillers0$);
}
void dgf_poly_joint_internal$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 if (poly$.size() < pxcrt::bt_size_t(1LL)) {
  return;
 }
 ::pgl3d$n::glvertex$n::node_joint$s e$;
 e$.trans$ = ::pgl3d$n::glgeometry$n::poly_trans$f(poly$);
 e$.joint_name$ = joint_name$;
 (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_joint$f(e$);
}
void dgf_point_joint_internal$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
 if (poly$.size() < pxcrt::bt_size_t(1LL)) {
  return;
 }
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type p$ = poly$[pxcrt::bt_size_t((0LL))].pos$;
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ex$ = glm::normalize< pxcrt::bt_float >(poly$[pxcrt::bt_size_t((0LL))].nor$);
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ey$ = glm::normalize< pxcrt::bt_float >(poly$[pxcrt::bt_size_t((0LL))].tan$);
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ez$ = glm::cross< pxcrt::bt_float >(ex$ , ey$);
 ::pgl3d$n::glvertex$n::node_joint$s e$;
 e$.trans$ = pxcrt::glmpx::make_tmat4< pxcrt::bt_float >(ex$.x , ex$.y , ex$.z , pxcrt::bt_float(0.0) , ey$.x , ey$.y , ey$.z , pxcrt::bt_float(0.0) , ez$.x , ez$.y , ez$.z , pxcrt::bt_float(0.0) , p$.x , p$.y , p$.z , pxcrt::bt_float(1.0));
 e$.joint_name$ = joint_name$;
 (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_joint$f(e$);
}
void update_mvp$f(::pgl3d$n::pglbase$n::projection_info$s& cam$) {
 const pxcrt::bt_float perspective_distance$ = pxcrt::bt_float(1.0);
 const pxcrt::bt_float distance_max$ = pxcrt::bt_float(1000.0);
 const pxcrt::bt_int ssbase$ = ::ordered$n::max$f$p$meta$n$$int$t$r$(cam$.screen_height$ , cam$.screen_width$);
 const pxcrt::bt_float h$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(cam$.screen_height$) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(ssbase$);
 const pxcrt::bt_float w$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(cam$.screen_width$) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(ssbase$);
 ::GL$n::compat$n::glViewport$f((0LL) , (0LL) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(cam$.screen_width$) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(cam$.screen_height$));
 ::GL$n::compat$n::glDepthMask$f(pxcrt::bt_uchar(1LL));
 ::GL$n::compat$n::glColorMask$f(pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL) , pxcrt::bt_uchar(1LL));
 ::GL$n::compat$n::glClear$f(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 const pxcrt::bt_float d$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(perspective_distance$);
 {
  const pxcrt::bt_float near$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(d$);
  const pxcrt::bt_float far$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(d$ + distance_max$);
  const pxcrt::bt_float left$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(-w$);
  const pxcrt::bt_float right$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(w$);
  const pxcrt::bt_float bottom$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(-h$);
  const pxcrt::bt_float top$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(h$);
  cam$.projection$ = glm::frustum< pxcrt::bt_float >(left$ , right$ , bottom$ , top$ , near$ , far$);
 }
 {
  const pxcrt::bt_double sm_w$ = ::ordered$n::max$f$p$meta$n$$double$t$r$(1.0 , pxcrt::bt_double(w$));
  const pxcrt::bt_double sm_h$ = ::ordered$n::max$f$p$meta$n$$double$t$r$(1.0 , pxcrt::bt_double(h$));
  const pxcrt::bt_float near$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(d$);
  const pxcrt::bt_float far$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$float$t$r$(d$ + distance_max$);
  const pxcrt::bt_float left$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$double$t$r$(-sm_w$);
  const pxcrt::bt_float right$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$double$t$r$(sm_w$);
  const pxcrt::bt_float bottom$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$double$t$r$(-sm_h$);
  const pxcrt::bt_float top$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$double$t$r$(sm_h$);
  cam$.sm_projection$ = glm::frustum< pxcrt::bt_float >(left$ , right$ , bottom$ , top$ , near$ , far$);
 }
}
shadowmap_fbo$s::shadowmap_fbo$s() : fbo$(), sm_texture$(), sm_width$(), sm_height$(), depthbuf$(){
 /* fbo$ */;
 /* sm_texture$ */;
 /* sm_width$ */;
 /* sm_height$ */;
 /* depthbuf$ */;
}
void init_shadowmap_fbo$f(const ::pgl3d$n::shader_config$n::shader_config$s& glc$, ::pgl3d$n::pglshader$n::shadowmap_fbo$s& sfbo$) {
 if (glc$.enable_shadowmapping$) {
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("shadowmap size") , sfbo$.sm_width$ , sfbo$.sm_height$);
  pxcrt::bt_int saved_fb$ = pxcrt::bt_int();
  ::GL$n::compat$n::glGetIntegerv$f(GL_FRAMEBUFFER_BINDING , pxcrt::address< pxcrt::bt_int >(saved_fb$));
  ::GL$n::compat$n::glActiveTexture$f(GL_TEXTURE3);
  sfbo$.sm_texture$.generate$f();
  ::GL$n::compat$n::glBindTexture$f(GL_TEXTURE_2D , sfbo$.sm_texture$.get$f());
  if (glc$.enable_depth_texture$) {
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("depth_texture"));
   const GLenum f$ = glc$.enable_sampler2dshadow$ ? GL_LINEAR : GL_NEAREST;
   ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(f$));
   ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(f$));
   /* staticif empty */
   if (!glc$.is_gles$) {
    ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("depth_texture byte"));
    ::GL$n::compat$n::glTexImage2D$f(GL_TEXTURE_2D , (0LL) , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_DEPTH_COMPONENT) , sfbo$.sm_width$ , sfbo$.sm_height$ , (0LL) , GL_DEPTH_COMPONENT , GL_UNSIGNED_BYTE , pxcrt::gl::offset_to_void_cp(pxcrt::bt_size_t((0LL))));
   } else {
    if (glc$.is_gl3_or_gles3$f()) {
     ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("depth_texture int"));
     ::GL$n::compat$n::glTexImage2D$f(GL_TEXTURE_2D , (0LL) , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_DEPTH_COMPONENT16) , sfbo$.sm_width$ , sfbo$.sm_height$ , (0LL) , GL_DEPTH_COMPONENT , GL_UNSIGNED_INT , pxcrt::gl::offset_to_void_cp(pxcrt::bt_size_t((0LL))));
    } else {
     ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("depth_texture short"));
     ::GL$n::compat$n::glTexImage2D$f(GL_TEXTURE_2D , (0LL) , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_DEPTH_COMPONENT) , sfbo$.sm_width$ , sfbo$.sm_height$ , (0LL) , GL_DEPTH_COMPONENT , GL_UNSIGNED_SHORT , pxcrt::gl::offset_to_void_cp(pxcrt::bt_size_t((0LL))));
    }
   }
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("depth_texture done"));
  } else {
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("no depth_texture"));
   ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_NEAREST));
   ::GL$n::compat$n::glTexParameteri$f(GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_NEAREST));
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("no depth_texture rbga byte"));
   ::GL$n::compat$n::glTexImage2D$f(GL_TEXTURE_2D , (0LL) , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(GL_RGBA) , sfbo$.sm_width$ , sfbo$.sm_height$ , (0LL) , GL_RGBA , GL_UNSIGNED_BYTE , pxcrt::gl::offset_to_void_cp(pxcrt::bt_size_t((0LL))));
  }
  /* staticif empty */
  sfbo$.fbo$.generate$f();
  ::GL$n::compat$n::glBindFramebuffer$f(GL_FRAMEBUFFER , sfbo$.fbo$.get$f());
  if (glc$.enable_depth_texture$) {
   ::GL$n::compat$n::glFramebufferTexture2D$f(GL_FRAMEBUFFER , GL_DEPTH_ATTACHMENT , GL_TEXTURE_2D , sfbo$.sm_texture$.get$f() , (0LL));
  } else {
   ::GL$n::compat$n::glFramebufferTexture2D$f(GL_FRAMEBUFFER , GL_COLOR_ATTACHMENT0 , GL_TEXTURE_2D , sfbo$.sm_texture$.get$f() , (0LL));
  }
  if (glc$.enable_depth_texture$) {
   /* staticif empty */
  } else {
   pxcrt::bt_int orig_rb$ = pxcrt::bt_int();
   ::GL$n::compat$n::glGetIntegerv$f(GL_RENDERBUFFER_BINDING , pxcrt::address< pxcrt::bt_int >(orig_rb$));
   sfbo$.depthbuf$.generate$f();
   ::GL$n::compat$n::glBindRenderbuffer$f(GL_RENDERBUFFER , sfbo$.depthbuf$.get$f());
   ::GL$n::compat$n::glRenderbufferStorage$f(GL_RENDERBUFFER , GL_DEPTH_COMPONENT16 , sfbo$.sm_width$ , sfbo$.sm_height$);
   ::GL$n::compat$n::glFramebufferRenderbuffer$f(GL_FRAMEBUFFER , GL_DEPTH_ATTACHMENT , GL_RENDERBUFFER , sfbo$.depthbuf$.get$f());
   ::GL$n::compat$n::glBindRenderbuffer$f(GL_RENDERBUFFER , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(orig_rb$));
  }
  const GLenum e$ = ::GL$n::compat$n::glCheckFramebufferStatus$f(GL_FRAMEBUFFER);
  if (e$ != GL_FRAMEBUFFER_COMPLETE) {
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("incomplete framebuffer") , ::pgl3d$n::glgeometry$n::cast_int$f$p$GL$$base$n$$GLenum$s$r$(e$));
  } else {
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("complete framebuffer"));
  }
  ::GL$n::compat$n::glBindFramebuffer$f(GL_FRAMEBUFFER , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(saved_fb$));
 }
}
};}; /* namespace pgl3d::pglshader */
namespace pgl3d$n { namespace sdlcontext$n { 
void sdlcontext$s::init$f() {
 pgl3d$n::set_high_dpi((0LL));
 SDL_Init(::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_INIT_VIDEO));
 TTF_Init();
 const pxcrt::bt_int num_modes$ = SDL_GetNumDisplayModes((0LL));
 for (pxcrt::bt_int i$ = (0LL); i$ < num_modes$; ++i$) {
  SDL_DisplayMode mode$ = SDL_DisplayMode();
  SDL_GetDisplayMode((0LL) , i$ , pxcrt::address< SDL_DisplayMode >(mode$));
  if (mode$.w * mode$.h > init_w$ * init_h$) {
  }
  if (mode$.w * mode$.h < init_w$ * init_h$) {
  }
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("displaymode") , mode$.w , mode$.h);
 }
 SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER , 1LL);
 if (enable_msaa$) {
  SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS , 1LL);
  SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES , 4LL);
 }
 int wflags$ = SDL_WINDOW_OPENGL;
 /* staticif empty */{
  wflags$ |= SDL_WINDOW_RESIZABLE;
  wflags$ |= SDL_WINDOW_ALLOW_HIGHDPI;
 }
 pxcrt::bt_int vsync$ = 1LL;
 if (eq_memcmp(::io$n::environ$n::get_option$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("-f"))),::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1")))) {
  wflags$ |= SDL_WINDOW_FULLSCREEN_DESKTOP;
 }
 if (eq_memcmp(::io$n::environ$n::get_option$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("-d"))),::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1")))) {
  wflags$ |= SDL_WINDOW_FULLSCREEN_DESKTOP;
 }
 if (eq_memcmp(::io$n::environ$n::get_option$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("-v"))),::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1")))) {
  vsync$ = (0LL);
 }
 if (eq_memcmp(::io$n::environ$n::get_option$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("-h"))),::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1")))) {
  wflags$ &= ~SDL_WINDOW_ALLOW_HIGHDPI;
 }
 if (ne_memcmp(::io$n::environ$n::get_option$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("-w"))),::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("")))) {
  init_w$ = ::text$n::string$n::serialize$n::from_string$f$p$meta$n$$int$t$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::io$n::environ$n::get_option$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("-w")))).get_crange()));
 }
 if (ne_memcmp(::io$n::environ$n::get_option$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("-h"))),::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("")))) {
  init_h$ = ::text$n::string$n::serialize$n::from_string$f$p$meta$n$$int$t$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::io$n::environ$n::get_option$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("-h")))).get_crange()));
 }
 {
  wflags$ |= SDL_WINDOW_FULLSCREEN | SDL_WINDOW_BORDERLESS;
 }
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("create_window") , init_w$ , init_h$);
 sdl_window$.reset$f(SDL_CreateWindow(::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("PGL3D")) , 128LL , 128LL , init_w$ , init_h$ , ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(wflags$)));
 const pxcrt::rawptr< SDL_Window >::type wnd$ = sdl_window$.get$f();
 /* staticif empty */{
  {
   SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION , 2LL);
   SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION , (0LL));
   glmajor$ = 2LL;
   glminor$ = (0LL);
  }
  gles_flag$ = true;
 }
 SDL_GLContext glctx$ = SDL_GL_CreateContext(wnd$);
 pxcrt::gl::glewInit();
 const ::pxcrt::pxcvarray< pxcrt::bt_uchar > verstr$ = pxcrt::gl::cubptr_to_string(::glGetString(GL_VERSION));
 if (verstr$.empty()) {
  /* staticif empty *//* staticif-else */
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION , 2LL);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION , (0LL));
  glctx$ = SDL_GL_CreateContext(wnd$);
  glmajor$ = 2LL;
  glminor$ = (0LL);
  /* staticif-else end */
 }
 sdl_glcontext$.reset$f(glctx$);
 SDL_GL_GetDrawableSize(wnd$ , pxcrt::address< pxcrt::bt_int >(init_w$) , pxcrt::address< pxcrt::bt_int >(init_h$));
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("drawable size") , init_w$ , init_h$);
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(pxcrt::bt_strlit("GL_VERSION") , pxcrt::gl::cubptr_to_string(::GL$n::compat$n::glGetString$f(GL_VERSION)));
}
sdlcontext$s::sdlcontext$s() : init_w$(128LL), init_h$(128LL), enable_msaa$(false), gles_flag$(false), glmajor$(), glminor$(), vsync$((0LL)), sdl_window$(), sdl_glcontext$() {
 init$f();
}
};}; /* namespace pgl3d::sdlcontext */
namespace pgl3d$n { namespace mainloop$n { 
void mainloop$f(::pgl3d$n::application$n::pgl3d_application$i& app$) {
 pxcrt::gl::set_check_error_enabled(1LL);
 try {
  ::pgl3d$n::mainloop$n::mainloop_internal$f(app$);
 } catch (const std::exception& ex$) {
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$exception$n$$c_exception$i$q$0$li$r$$r$$r$(pxcrt::bt_strlit("uncaught exception") , ex$);
 }
}
::pxcrt::pxcvarray< pxcrt::bt_uchar > sdl_read_file$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >& fn$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > r$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$ rwop$;
 rwop$.reset$f(SDL_RWFromFile(::pointer$n::raw_unsafe$n::varray_c_str$f(fn$) , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("rb"))));
 if ((::operator$n::eq$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$(rwop$.get$f() , pxcrt::rawptr< SDL_RWops >::type()))) {
  PXC_THROW(::exception$n::runtime_error_template$s$p$sdl__read__file$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (fn$).get_crange())));
 }
 ::pxcrt::farray< pxcrt::bt_uchar,16384LL > buf$ = ::pxcrt::farray< pxcrt::bt_uchar,16384LL >();
 while (true) {
  const pxcrt::bt_size_t n$ = SDL2::RWread(::operator$n::implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$$r$(rwop$) , pxcrt::rawptr_to_voidptr< pxcrt::bt_uchar >(pxcrt::slice_to_rawptr< pxcrt::bt_uchar >(buf$.range())) , pxcrt::bt_size_t(1LL) , pxcrt::bt_size_t(16384LL));
  if (n$ == pxcrt::bt_size_t((0LL))) {
   break;
  }
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_slice< pxcrt::bt_uchar > >(r$ , ::pxcrt::bt_slice< pxcrt::bt_uchar >(buf$, pxcrt::bt_size_t((0LL)), n$));
 }
 return r$;
}
void frame_statistics$s::init$f() {
 const pxcrt::bt_uint t$ = SDL_GetTicks();
 {
  ::pxcrt::farray< pxcrt::bt_uint,8LL >& ag$fe = (ticks$);
  const size_t sz$fe = ag$fe.size();
  pxcrt::bt_uint *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   pxcrt::bt_uint& e$ = ar$fe[i$];
   {
    e$ = t$;
   }
  }
 }
}
void frame_statistics$s::save_ticks$f(pxcrt::bt_size_t idx$, pxcrt::bt_uint v$) {
 const pxcrt::bt_uint prev_tick$ = ticks$[idx$ == pxcrt::bt_size_t((0LL)) ? ticks$.size() - pxcrt::bt_size_t(1LL) : idx$ - pxcrt::bt_size_t(1LL)];
 pxcrt::bt_uint& cur_tick$ = ticks$[idx$];
 cur_tick$ = v$;
 ticks_sum$[idx$] += cur_tick$ - prev_tick$;
}
void frame_statistics$s::measure$f() {
 ++frames$;
 pxcrt::bt_uint t$ = SDL_GetTicks();
 if (t$ - tprevsec$ >= pxcrt::bt_uint(1000LL)) {
  const pxcrt::bt_float seconds$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$uint$t$r$(t$ - tprevsec$) / pxcrt::bt_float(1000.0);
  fps$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$uint$t$r$(frames$) / seconds$;
  ticks_sum_saved$ = ticks_sum$;
  ticks_sum$ = ::pxcrt::farray< pxcrt::bt_uint,8LL >();
  tprevsec$ = t$;
  frames$ = pxcrt::bt_uint((0LL));
 }
}
frame_statistics$s::frame_statistics$s() : tprevsec$(pxcrt::bt_uint((0LL))), frames$(pxcrt::bt_uint((0LL))), fps$(pxcrt::bt_float(0.0)), ticks$(), ticks_sum$(), ticks_sum_saved$() {
 init$f();
}
pxcrt::bt_int set_swap_interval$f(pxcrt::bt_int vsync$) {
 return SDL_GL_SetSwapInterval(vsync$);
}
void framerate_control$s::toggle_vsync$f() {
 vsync$ = vsync$ != (0LL) ? (0LL) : 1LL;
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("vsync=") , vsync$);
 swap_interval$ = ::pgl3d$n::mainloop$n::set_swap_interval$f(vsync$);
}
void framerate_control$s::start$f() {
 const ::pxcrt::bt_ulonglong t$ = pxcrt::high_resolution_timer(pxcrt::io_system);
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$numeric$$integral$n$$ulonglong$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("t=") , t$);
 {
  ::pxcrt::farray< ::pxcrt::bt_ulonglong,12LL >& ag$fe = (values$);
  const size_t sz$fe = ag$fe.size();
  ::pxcrt::bt_ulonglong *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   ::pxcrt::bt_ulonglong& v$ = ar$fe[i$];
   {
    v$ = t$;
   }
  }
 }
 cur$ = pxcrt::bt_size_t((0LL));
}
void framerate_control$s::control$f() {
 const ::pxcrt::bt_ulonglong t$ = pxcrt::high_resolution_timer(pxcrt::io_system);
 const ::pxcrt::bt_ulonglong t0$ = values$[cur$];
 values$[cur$] = t$;
 pxcrt::bt_double tdiff$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$double$t$q$numeric$$integral$n$$ulonglong$s$r$(t$ - t0$) * timer_res_inv$ / ::numeric$n::cast$n::static_cast$f$p$meta$n$$double$t$q$meta$n$$size_t$t$r$(values$.size());
 if (tdiff$ < 0.0001 || tdiff$ > 1.0) {
  tdiff$ = 1.0 / 60.0;
 }
 target_frame_speed_mul$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$double$t$r$(tdiff$ * 60.0);
 frame_speed_mul$ = target_frame_speed_mul$;
 if (++cur$ >= values$.size()) {
  cur$ = pxcrt::bt_size_t((0LL));
 }
}
framerate_control$s::framerate_control$s(pxcrt::bt_int vsync0$) : vsync$(vsync0$), swap_interval$(::pgl3d$n::mainloop$n::set_swap_interval$f(vsync0$)), timer_res$(pxcrt::high_resolution_timer_frequency(pxcrt::io_system)), timer_res_inv$(1.0 / ::numeric$n::cast$n::static_cast$f$p$meta$n$$double$t$q$numeric$$integral$n$$ulonglong$s$r$(timer_res$)), values$(), cur$(pxcrt::bt_size_t((0LL))), frame_speed_mul$(pxcrt::bt_float(1.0)), target_frame_speed_mul$(pxcrt::bt_float(1.0)) {
}
void toggle_fullscreen$f23(::pgl3d$n::sdlcontext$n::sdlcontext$s& sdlc$23$pgl3d$$mainloop$ns1, pxcrt::bt_int& fullscreen$23$pgl3d$$mainloop$ns1) {
 fullscreen$23$pgl3d$$mainloop$ns1 = fullscreen$23$pgl3d$$mainloop$ns1 != (0LL) ? (0LL) : 1LL;
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("fullscreen=") , fullscreen$23$pgl3d$$mainloop$ns1);
 SDL_SetWindowFullscreen(::operator$n::implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$$r$(sdlc$23$pgl3d$$mainloop$ns1.sdl_window$) , ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(fullscreen$23$pgl3d$$mainloop$ns1 != (0LL) ? SDL_WINDOW_FULLSCREEN_DESKTOP : int((0LL))));
}
void do_commands$f23(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands$23$pgl3d$$mainloop$ns1, ::pgl3d$n::mainloop$n::framerate_control$s& frctl$23$pgl3d$$mainloop$ns1, ::pgl3d$n::sdlcontext$n::sdlcontext$s& _0$up, pxcrt::bt_int& _1$up) {
 if (!commands$23$pgl3d$$mainloop$ns1.empty()) {
  {
   const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& ag$fe = (commands$23$pgl3d$$mainloop$ns1);
   pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > ag$fg(ag$fe);
   for (pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::const_iterator i$fe = ag$fe.begin(); i$fe != ag$fe.end(); ++i$fe) {
    const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& k$ = ag$fe.get_ckey(i$fe);
    const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$ = ag$fe.get_cmapped(i$fe);
    {
     if (eq_memcmp(k$,::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vsync")))) {
      frctl$23$pgl3d$$mainloop$ns1.toggle_vsync$f();
     } else if (eq_memcmp(k$,::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("fullscreen")))) {
      ::pgl3d$n::mainloop$n::toggle_fullscreen$f23(_0$up, _1$up);
     }
    }
   }
  }
  commands$23$pgl3d$$mainloop$ns1.clear();
 }
}
void swap_data_cl$f42(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands$23$pgl3d$$mainloop$ns1, ::pgl3d$n::pglshader$n::pglshader$s& pgs$23$pgl3d$$mainloop$ns1, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& local_whole_instances$23$pgl3d$$mainloop$ns1, ::pgl3d$n::mainloop$n::framerate_control$s& frctl$23$pgl3d$$mainloop$ns1, pxcrt::bt_size_t& saved_stat_num_objects$23$pgl3d$$mainloop$ns1, ::pgl3d$n::pglbase$n::projection_info$s& cam_drawing_frame$23$pgl3d$$mainloop$ns1, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& mess$42$pgl3d$$mainloop$ns1, ::pgl3d$n::pglmotion$n::motion_thread_shared$s& mts$) {
 cam_drawing_frame$23$pgl3d$$mainloop$ns1 = mts$.cam$;
 mts$.cam$ = pgs$23$pgl3d$$mainloop$ns1.cam$;
 mts$.frame_speed_mul$ = frctl$23$pgl3d$$mainloop$ns1.frame_speed_mul$;
 mts$.message$ = mess$42$pgl3d$$mainloop$ns1;
 ::container$n::tree_map$n::tree_map_compare_swap$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$(mts$.commands$ , commands$23$pgl3d$$mainloop$ns1);
 ::pxcrt::pxcvarray_swap< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >(local_whole_instances$23$pgl3d$$mainloop$ns1 , mts$.whole_instances$);
 saved_stat_num_objects$23$pgl3d$$mainloop$ns1 = mts$.stat_num_objects$;
}
void mainloop_internal$f(::pgl3d$n::application$n::pgl3d_application$i& app$) {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("PGL3D main"));
 ::pgl3d$n::sdlcontext$n::sdlcontext$s sdlc$23$pgl3d$$mainloop$ns1;
 SDL_EventState(::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_KEYUP) , (0LL));
 SDL_EventState(::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_TEXTEDITING) , (0LL));
 SDL_EventState(::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_TEXTINPUT) , (0LL));
 {
  SDL_EventState(::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_MOUSEBUTTONDOWN) , (0LL));
  SDL_EventState(::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_MOUSEBUTTONUP) , (0LL));
  SDL_EventState(::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_MOUSEMOTION) , (0LL));
 }
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("PGL3D init0"));
 ::pgl3d$n::shader_config$n::shader_config$s sconf$((sdlc$23$pgl3d$$mainloop$ns1.gles_flag$), (sdlc$23$pgl3d$$mainloop$ns1.glmajor$), (sdlc$23$pgl3d$$mainloop$ns1.glminor$), (sdlc$23$pgl3d$$mainloop$ns1.enable_msaa$));
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > drawers$ = app$.on_init_drawers$f(sconf$);
 ::pgl3d$n::pglshader$n::pglshader$s pgs$23$pgl3d$$mainloop$ns1((sconf$), (drawers$), (sdlc$23$pgl3d$$mainloop$ns1.init_w$), (sdlc$23$pgl3d$$mainloop$ns1.init_h$));
 app$.on_build_vertices$f(pgs$23$pgl3d$$mainloop$ns1);
 ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > local_whole_instances$23$pgl3d$$mainloop$ns1 = ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >();
 ::pgl3d$n::scene_node$n::node_factory$s nfac$;
 pgs$23$pgl3d$$mainloop$ns1.prepare$f(local_whole_instances$23$pgl3d$$mainloop$ns1 , nfac$);
 ::pgl3d$n::pglmotion$n::motion_thread_object$s mto$((nfac$), (local_whole_instances$23$pgl3d$$mainloop$ns1), (app$.get_scene_shared$f()), (pgs$23$pgl3d$$mainloop$ns1.pidft$));
 pxcrt::bt_size_t saved_stat_num_objects$23$pgl3d$$mainloop$ns1 = pxcrt::bt_size_t();
 const pxcrt::bt_bool test_scroll_mode$ = false;
 ::pgl3d$n::pglbase$n::projection_info$s cam_drawing_frame$23$pgl3d$$mainloop$ns1;
 ::pgl3d$n::mainloop$n::frame_statistics$s fr$;
 ::pgl3d$n::mainloop$n::framerate_control$s frctl$23$pgl3d$$mainloop$ns1((sdlc$23$pgl3d$$mainloop$ns1.vsync$));
 pxcrt::bt_int fullscreen$23$pgl3d$$mainloop$ns1 = (0LL);
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > commands$23$pgl3d$$mainloop$ns1 = pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >();
 pxcrt::bt_bool done$ = false;
 pxcrt::bt_bool paused$ = false;
 while (!done$) {
  pxcrt::bt_bool scene_next_flag$ = false;
  SDL_Event ev$ = SDL_Event();
  while (SDL_PollEvent(pxcrt::address< SDL_Event >(ev$)) != (0LL)) {
   const pxcrt::bt_uint etype$ = ev$.type;
   if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_WINDOWEVENT)) {
    if (ev$.window.event == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_WINDOWEVENT_RESIZED)) {
     pxcrt::bt_int w$ = pxcrt::bt_int();
     pxcrt::bt_int h$ = pxcrt::bt_int();
     SDL_GL_GetDrawableSize(::operator$n::implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$$r$(sdlc$23$pgl3d$$mainloop$ns1.sdl_window$) , pxcrt::address< pxcrt::bt_int >(w$) , pxcrt::address< pxcrt::bt_int >(h$));
     pgs$23$pgl3d$$mainloop$ns1.resize_screen$f(w$ , h$);
     frctl$23$pgl3d$$mainloop$ns1.start$f();
     ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("resized w=") , w$ , pxcrt::bt_strlit(" h=") , h$);
    } else if (ev$.window.event == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_WINDOWEVENT_HIDDEN)) {
     ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("hidden"));
    } else if (ev$.window.event == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_WINDOWEVENT_MINIMIZED) || ev$.window.event == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_WINDOWEVENT_FOCUS_LOST)) {
    } else if (ev$.window.event == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_WINDOWEVENT_RESTORED) || ev$.window.event == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_WINDOWEVENT_FOCUS_GAINED)) {
     paused$ = false;
     frctl$23$pgl3d$$mainloop$ns1.start$f();
     ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("restored"));
    } else {
    }
   } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_QUIT)) {
    done$ = true;
    break;
   }
   app$.on_event$f(ev$ , frctl$23$pgl3d$$mainloop$ns1.frame_speed_mul$ , pgs$23$pgl3d$$mainloop$ns1.cam$ , commands$23$pgl3d$$mainloop$ns1);
   ::pgl3d$n::mainloop$n::do_commands$f23(commands$23$pgl3d$$mainloop$ns1, frctl$23$pgl3d$$mainloop$ns1, sdlc$23$pgl3d$$mainloop$ns1, fullscreen$23$pgl3d$$mainloop$ns1);
  }
  {
   pxcrt::bt_int numkeys$ = pxcrt::bt_int();
   const pxcrt::crawptr< pxcrt::bt_uchar >::type ksp$ = SDL_GetKeyboardState(pxcrt::address< pxcrt::bt_int >(numkeys$));
   const ::pxcrt::bt_cslice< pxcrt::bt_uchar > ks$ = pxcrt::crawptr_to_cslice< pxcrt::bt_uchar >(ksp$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(numkeys$));
   app$.on_scankeys$f(ks$ , frctl$23$pgl3d$$mainloop$ns1.frame_speed_mul$ , pgs$23$pgl3d$$mainloop$ns1.cam$ , commands$23$pgl3d$$mainloop$ns1);
   ::pgl3d$n::mainloop$n::do_commands$f23(commands$23$pgl3d$$mainloop$ns1, frctl$23$pgl3d$$mainloop$ns1, sdlc$23$pgl3d$$mainloop$ns1, fullscreen$23$pgl3d$$mainloop$ns1);
  }
  fr$.save_ticks$f(pxcrt::bt_size_t((0LL)) , SDL_GetTicks());
  if (paused$) {
   SDL_Delay(pxcrt::bt_uint(100LL));
   fr$.tprevsec$ = SDL_GetTicks();
   continue;
  }
  {
   const ::pxcrt::pxcvarray< pxcrt::bt_uchar > mess$42$pgl3d$$mainloop$ns1 = ::text$n::string$n::split$n::string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$1$li$r$$q$m$ll$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$1$li$r$$r$$r$(fr$.fps$ , frctl$23$pgl3d$$mainloop$ns1.frame_speed_mul$ , fr$.ticks_sum_saved$ , saved_stat_num_objects$23$pgl3d$$mainloop$ns1 , pgs$23$pgl3d$$mainloop$ns1.cam$.camera$.angle$ , pgs$23$pgl3d$$mainloop$ns1.cam$.camera$.position$);
   mto$.wait_and_exec$f$p$pgl3d$$mainloop$n$$swap_data_cl$f42$r$(commands$23$pgl3d$$mainloop$ns1, pgs$23$pgl3d$$mainloop$ns1, local_whole_instances$23$pgl3d$$mainloop$ns1, frctl$23$pgl3d$$mainloop$ns1, saved_stat_num_objects$23$pgl3d$$mainloop$ns1, cam_drawing_frame$23$pgl3d$$mainloop$ns1, mess$42$pgl3d$$mainloop$ns1);
   ::pgl3d$n::mainloop$n::do_commands$f23(commands$23$pgl3d$$mainloop$ns1, frctl$23$pgl3d$$mainloop$ns1, sdlc$23$pgl3d$$mainloop$ns1, fullscreen$23$pgl3d$$mainloop$ns1);
  }
  fr$.save_ticks$f(pxcrt::bt_size_t(1LL) , SDL_GetTicks());
  {
   ::pxcrt::pxcvarray< pxcrt::bt_uint > tick_draw$ = ::pxcrt::pxcvarray< pxcrt::bt_uint >();
   tick_draw$ = ::pgl3d$n::pglshader$n::pglshader_draw_frame$f(pgs$23$pgl3d$$mainloop$ns1 , local_whole_instances$23$pgl3d$$mainloop$ns1 , cam_drawing_frame$23$pgl3d$$mainloop$ns1);
   if (tick_draw$.size() > pxcrt::bt_size_t(2LL)) {
    fr$.save_ticks$f(pxcrt::bt_size_t(2LL) , pxcrt::bt_uint(pxcrt::get_elem_value(tick_draw$,pxcrt::bt_size_t((0LL)))));
    fr$.save_ticks$f(pxcrt::bt_size_t(3LL) , pxcrt::bt_uint(pxcrt::get_elem_value(tick_draw$,pxcrt::bt_size_t(1LL))));
   } else {
    fr$.save_ticks$f(pxcrt::bt_size_t(2LL) , SDL_GetTicks());
    fr$.save_ticks$f(pxcrt::bt_size_t(3LL) , SDL_GetTicks());
   }
   fr$.save_ticks$f(pxcrt::bt_size_t(4LL) , SDL_GetTicks());
   fr$.measure$f();
  }
  fr$.save_ticks$f(pxcrt::bt_size_t(5LL) , SDL_GetTicks());
  frctl$23$pgl3d$$mainloop$ns1.control$f();
  fr$.save_ticks$f(pxcrt::bt_size_t(6LL) , SDL_GetTicks());
  SDL_GL_SwapWindow(::operator$n::implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$$r$(sdlc$23$pgl3d$$mainloop$ns1.sdl_window$));
  fr$.save_ticks$f(pxcrt::bt_size_t(7LL) , SDL_GetTicks());
  if (scene_next_flag$) {
   frctl$23$pgl3d$$mainloop$ns1.start$f();
  }
 }
}
};}; /* namespace pgl3d::mainloop */
namespace pgl3d$n { namespace dynamics_world$n { 
pgl3dRigidBody$s::pgl3dRigidBody$s(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i >& collisionShape0$, pxcrt::bt_float mass$, const ::btTransform& tr0$) : collisionShape$(collisionShape0$), motionState$(tr0$ , ::btTransform::getIdentity()), rigidBody$(::pgl3d$n::dynamics_world$n::makeRigidBody$f(((*(pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i >(collisionShape$)))).get$f() , pxcrt::address< ::btDefaultMotionState >(motionState$) , mass$)) {
}
::btRigidBody makeRigidBody$f(pxcrt::rawptr< ::btCollisionShape >::type shape$, pxcrt::rawptr< ::btDefaultMotionState >::type motionState$, pxcrt::bt_float mass$) {
 const pxcrt::bt_bool isDynamic$ = (mass$ != 0.0f);
 ::btVector3 localInertia$ = ::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(0.0f , 0.0f , 0.0f);
 if (isDynamic$) {
  ((pxcrt::rawptr___deref< ::btCollisionShape >(shape$))).calculateLocalInertia(mass$ , localInertia$);
 }
 ::btRigidBody::btRigidBodyConstructionInfo rbInfo$((mass$), (::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btMotionState$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDefaultMotionState$s$r$$r$(motionState$)), (shape$), (localInertia$));
 rbInfo$.m_friction = 0.0f;
 rbInfo$.m_rollingFriction = 0.0f;
 rbInfo$.m_restitution = 0.0f;
 const ::btRigidBody r$((rbInfo$));
 return r$;
}
pgl3dDynamicsWorld$s::~pgl3dDynamicsWorld$s() PXC_NOTHROW {
 try {
  clear$f();
 } catch (...) { ::abort(); }
}
void pgl3dDynamicsWorld$s::clear$f() {
 {
  const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >& ag$fe = (rigidBodies$);
  ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >& rb$ = ar$fe[i$];
   {
    dynamicsWorld$.removeCollisionObject(::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionObject$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btRigidBody$s$r$$r$(pxcrt::address< ::btRigidBody >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >(rb$))->value)).rigidBody$)));
   }
  }
 }
 rigidBodies$.clear();
}
void pgl3dDynamicsWorld$s::addRigidBody$f(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >& rigidBody$) {
 ::Bullet$n::api$n::btDiscreteDynamicsWorld_addRigidBody$f$p$m$ll$p$m$ll$p$Bullet$$api$n$$btDiscreteDynamicsWorld$s$q$1$li$r$$q$m$ll$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btRigidBody$s$r$$q$0$li$r$$r$$r$(dynamicsWorld$ , pxcrt::address< ::btRigidBody >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >(rigidBody$))->value)).rigidBody$));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >(rigidBodies$ , rigidBody$);
}
pgl3dDynamicsWorld$s::pgl3dDynamicsWorld$s() : collisionConfiguration$(::btDefaultCollisionConstructionInfo()), dispatcher$(::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionConfiguration$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDefaultCollisionConfiguration$s$r$$r$(pxcrt::address< ::btDefaultCollisionConfiguration >(collisionConfiguration$))), broadphase$(pxcrt::rawptr< ::btOverlappingPairCache >::type()), solver$(), dynamicsWorld$(::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDispatcher$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionDispatcher$s$r$$r$(pxcrt::address< ::btCollisionDispatcher >(dispatcher$)) , ::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btBroadphaseInterface$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDbvtBroadphase$s$r$$r$(pxcrt::address< ::btDbvtBroadphase >(broadphase$)) , ::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btConstraintSolver$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btSequentialImpulseConstraintSolver$s$r$$r$(pxcrt::address< ::btSequentialImpulseConstraintSolver >(solver$)) , ::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionConfiguration$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDefaultCollisionConfiguration$s$r$$r$(pxcrt::address< ::btDefaultCollisionConfiguration >(collisionConfiguration$))), rigidBodies$() {
}
};}; /* namespace pgl3d::dynamics_world */
namespace pgl3d$n { namespace sdlutil$n { 
pxcrt::bt_bool sdl_load_file$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& fname$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf_r$) {
 ::pgl3d$n::sdlutil$n::sdl_file$s$p$0$li$r$ fp$;
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > fn$ = fname$;
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_int >(fn$ , (0LL));
 fp$.reset$f(SDL_RWFromFile(pxcrt::crawptr_to_ccharptr< pxcrt::bt_uchar >(pxcrt::array_to_crawptr< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >(fn$)) , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("r"))));
 if (fp$.is_null$f()) {
  return false;
 }
 pxcrt::bt_long sz$ = SDL2::RWsize(fp$.get$f());
 if (sz$ < pxcrt::bt_long((0LL))) {
  sz$ = pxcrt::bt_long((0LL));
 }
 pxcrt::bt_size_t usz$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(sz$);
 buf_r$.clear();
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_int >(buf_r$ , usz$ , (0LL));
 if (SDL2::RWread(fp$.get$f() , pxcrt::rawptr_to_voidptr< pxcrt::bt_uchar >(pxcrt::array_to_rawptr< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >(buf_r$)) , usz$ , pxcrt::bt_size_t(1LL)) != usz$) {
  return false;
 }
 return true;
}
};}; /* namespace pgl3d::sdlutil */
namespace demoapp$n { 
void $f2(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& m$1$demoapp$ns0, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& line$) {
 const ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,2LL > a$ = ::container$n::array$n::make_farray_split$f$p$2$li$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(line$ , 61U);
 if (!a$[pxcrt::bt_size_t((0LL))].empty()) {
  m$1$demoapp$ns0[::pxcrt::pxcvarray< pxcrt::bt_uchar >(a$[pxcrt::bt_size_t((0LL))])] = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(a$[pxcrt::bt_size_t(1LL)]);
 }
}
pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > demoapp_application$s::on_init_drawers$f(const ::pgl3d$n::shader_config$n::shader_config$s& conf$) {
 return ::demoapp$n::init_drawers$f(app$ , conf$);
}
void demoapp_application$s::on_build_vertices$f(::pgl3d$n::pglbase$n::make_vertices_i$i& mvx$) {
 ::demoapp$n::build_vertices$f(app$ , mvx$);
}
void demoapp_application$s::on_event$f(const SDL_Event& ev$, pxcrt::bt_float speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$) {
 ::demoapp$n::handle_event$f(app$ , ev$ , speed$ , pjinfo$ , commands_r$);
}
void demoapp_application$s::on_scankeys$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& keys$, pxcrt::bt_float speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$) {
 ::demoapp$n::handle_keys$f(app$ , keys$ , speed$ , pjinfo$ , commands_r$);
}
pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i > demoapp_application$s::get_scene_shared$f() {
 return app$.scene_shared$;
}
demoapp_application$s::demoapp_application$s() : count$z(1), app$() {
}
void app_impl$s::init$f() {
 player$.position$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(-20.0) , pxcrt::bt_float(0.0));
 player$.angle$ = pxcrt::glmpx::make_tquat_wxyz< pxcrt::bt_float >(pxcrt::bt_float(0.70711) , pxcrt::bt_float(0.70711) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0));
}
app_impl$s::app_impl$s() : scene_shared$(::pointer$n::make_tptr$f$p$demoapp$n$$demoapp_scene_shared$s$q$m$ll$r$()), player$(), ictl$(pxcrt::io_system), scene_next_flag$(), light_on$(1.0f), app_commands$() {
 init$f();
}
pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene$i > demoapp_scene_shared$s::make_scene$f(const ::pgl3d$n::scene_node$n::node_factory$s& nodefac$) {
 return ::pointer$n::make_ptr$f$p$demoapp$n$$demoapp_scene$s$q$m$ll$p$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$pxcrt$$tcptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(nodefac$ , shapes$);
}
demoapp_scene_shared$s::demoapp_scene_shared$s() : count$z(1), posang$(), scene_next_flag$(), light_on$(), default_font_texture_info$(), app_commands$(), shapes$() {
}
void demoapp_scene$s::on_motion_step$f(pxcrt::bt_float frame_speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& status_message$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$, ::pgl3d$n::application$n::pgl3d_scene_shared$i& ss$, ::pgl3d$n::pglbase$n::position_angle$s& camera_r$, ::pgl3d$n::pglbase$n::position_angle$s& light_r$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$) {
 ::demoapp$n::demoapp_scene_shared$s& dss$ = pxcrt::downcast_mutable< ::demoapp$n::demoapp_scene_shared$s,::pgl3d$n::application$n::pgl3d_scene_shared$i >(ss$);
 camera_r$ = dss$.posang$;
 light_r$.position$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(camera_r$.position$ , (::operator$n::mul$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(glm::mat3_cast< pxcrt::bt_float >(camera_r$.angle$) , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(3.0) , pxcrt::bt_float(3.0) , pxcrt::bt_float(5.0))))));
 light_r$.angle$ = camera_r$.angle$;
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_view$ = glm::inverse< pxcrt::bt_float >(light_r$.to_mat4$f());
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type sm_vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(pjinfo$.sm_projection$ , sm_view$));
 const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type vp$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(pjinfo$.projection$ , glm::inverse< pxcrt::bt_float >(camera_r$.to_mat4$f())));
 ::pgl3d$n::pglbase$n::node_common_data$s ncd$;
 ncd$.shadowmapping_vp$ = sm_vp$;
 ncd$.vp$ = vp$;
 ::demoapp$n::scene_control_update_buttons$f(sctl$ , sctl$.node_buttons$);
 ::demoapp$n::scene_control_set_message$f(sctl$ , sctl$.node_status_message$ , status_message$ , pxcrt::bt_uint((0LL)) , pxcrt::bt_uint((0LL)) , dss$.default_font_texture_info$.char_w$ , dss$.default_font_texture_info$.char_h$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(pjinfo$.screen_width$) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(pjinfo$.screen_height$));
 ::demoapp$n::scene_control_step$f(sctl$ , dss$ , frame_speed$ , ncd$ , ftable$ , whole_instances$);
 prepare_instance_data_ft_rec$f(ncd$ , sctl$.node_status_message$ , ftable$ , whole_instances$);
 prepare_instance_data_ft_rec$f(ncd$ , sctl$.node_buttons$ , ftable$ , whole_instances$);
 prepare_instance_data_lp$f(ncd$ , ftable$ , whole_instances$);
}
pxcrt::bt_size_t demoapp_scene$s::prepare_instance_data_ft_rec$f(::pgl3d$n::pglbase$n::node_common_data$s& ncd$, const ::pgl3d$n::scene_node$n::scene_node$s& sn$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$) {
 pxcrt::bt_size_t r$ = pxcrt::bt_size_t((0LL));
 const pxcrt::bt_uint& bo_id$ = sn$.joint_id$.bo_id$;
 const pxcrt::bt_int& vs_id$ = sn$.joint_id$.vs_id$;
 if (bo_id$ >= pxcrt::bt_uint((0LL)) && vs_id$ >= (0LL)) {
  ++r$;
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > t0((whole_instances$));
  ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > t1(((t0.get())[pxcrt::bt_size_t(bo_id$)]));
  ::pgl3d$n::pglbase$n::instance_data$s& idata$ = (t1.get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(vs_id$)];
  ::pointer$n::tfuncptr$n::tfuncptr3___call$f$p$m$ll$p$m$ll$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$scene_node$s$q$0$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$node_common_data$s$q$1$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$instance_data$s$q$1$li$r$$r$$r$(ftable$[pxcrt::bt_size_t(bo_id$)] , sn$ , ncd$ , idata$);
 }
 {
  const ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >& ag$fe = (sn$.children$);
  ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >::guard_ref< const ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const ::pgl3d$n::scene_node$n::scene_node$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pgl3d$n::scene_node$n::scene_node$s& snp$ = ar$fe[i$];
   {
    r$ += prepare_instance_data_ft_rec$f(ncd$ , snp$ , ftable$ , whole_instances$);
   }
  }
 }
 return r$;
}
pxcrt::bt_size_t demoapp_scene$s::prepare_instance_data_lp$f(::pgl3d$n::pglbase$n::node_common_data$s& ncd$, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$) {
 const pxcrt::bt_uint bo_id$ = sctl$.joint_id_lp$.bo_id$;
 const pxcrt::bt_int vs_id$ = sctl$.joint_id_lp$.vs_id$;
 ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > t0((whole_instances$));
 ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > t1(((t0.get())[pxcrt::bt_size_t(bo_id$)]));
 ::pgl3d$n::pglbase$n::instance_data$s& idata$ = (t1.get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(vs_id$)];
 {
  const ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s >& ag$fe = (sctl$.lpbullet$);
  ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s >::guard_ref< const ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  const ::demoapp$n::lpbullet_data$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::demoapp$n::lpbullet_data$s& lpb$ = ar$fe[i$];
   {
    const ::pxcrt::bt_cslice< pxcrt::bt_float > sli$ = lpb$.value$.crange();
    ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(idata$.instance_buffer$ , ::pxcrt::bt_cslice< pxcrt::bt_float >(sli$, pxcrt::bt_size_t((0LL)), pxcrt::bt_size_t(9LL)));
   }
  }
 }
 return sctl$.lpbullet$.size();
}
demoapp_scene$s::demoapp_scene$s(const ::pgl3d$n::scene_node$n::node_factory$s& nodefac0$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& shapes$) : count$z(1), sctl$(nodefac0$ , shapes$) {
}
player_info$s::player_info$s() : device_rot_prev$(), angle$(), position$(), pos_delta$(), accel$(), accel_ratio$(0.1f) {
}
void input_control$s::finger_motion$f(pxcrt::bt_float x$, pxcrt::bt_float y$, pxcrt::bt_float dx$, pxcrt::bt_float dy$, SDL_FingerID fng$) {
 pxcrt::bt_size_t fid$ = pxcrt::bt_size_t(2LL);
 if (fingerids$.size() > pxcrt::bt_size_t((0LL)) && SDL_FingerID(pxcrt::get_elem_value(fingerids$,pxcrt::bt_size_t((0LL)))) == fng$) {
  fid$ = pxcrt::bt_size_t((0LL));
 } else if (fingerids$.size() > pxcrt::bt_size_t(1LL) && SDL_FingerID(pxcrt::get_elem_value(fingerids$,pxcrt::bt_size_t(1LL))) == fng$) {
  fid$ = pxcrt::bt_size_t(1LL);
 }
 if (fid$ < pxcrt::bt_size_t(2LL)) {
  cur_pos$[fid$] = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(x$ , y$);
  pos_distance_max$[fid$] = ::ordered$n::max$f$p$meta$n$$float$t$r$(pxcrt::glmpx::distance< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(cur_pos$[fid$] , start_pos$[fid$]) , pos_distance_max$[fid$]);
 } else {
 }
}
void input_control$s::finger_down$f(pxcrt::bt_float x$, pxcrt::bt_float y$, SDL_FingerID fng$) {
 pxcrt::bt_size_t fid$ = pxcrt::bt_size_t(2LL);
 if (fingerids$.size() > pxcrt::bt_size_t((0LL)) && SDL_FingerID(pxcrt::get_elem_value(fingerids$,pxcrt::bt_size_t((0LL)))) == fng$) {
  fid$ = pxcrt::bt_size_t((0LL));
 } else if (fingerids$.size() > pxcrt::bt_size_t(1LL) && SDL_FingerID(pxcrt::get_elem_value(fingerids$,pxcrt::bt_size_t(1LL))) == fng$) {
  fid$ = pxcrt::bt_size_t(1LL);
 } else if (fingerids$.size() < pxcrt::bt_size_t(2LL)) {
  fid$ = fingerids$.size();
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< SDL_FingerID >,SDL_FingerID >(fingerids$ , fng$);
 }
 if (fid$ < pxcrt::bt_size_t(2LL)) {
  fingdown$[fid$] = true;
  start_pos$[fid$] = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(x$ , y$);
  cur_pos$[fid$] = start_pos$[fid$];
  pos_distance_max$[fid$] = 0.0f;
  fingerdown_time$[pxcrt::bt_size_t((0LL))] = pxcrt::bt_size_t((0LL));
  fingerdown_time$[pxcrt::bt_size_t(1LL)] = pxcrt::bt_size_t((0LL));
  finger_zmove_mode$ = (0LL);
 }
}
pxcrt::bt_int input_control$s::finger_up$f(SDL_FingerID fng$) {
 pxcrt::bt_int tap_finger$ = -1LL;
 pxcrt::bt_size_t fid$ = pxcrt::bt_size_t(2LL);
 if (fingerids$.size() > pxcrt::bt_size_t((0LL)) && SDL_FingerID(pxcrt::get_elem_value(fingerids$,pxcrt::bt_size_t((0LL)))) == fng$) {
  fid$ = pxcrt::bt_size_t((0LL));
 } else if (fingerids$.size() > pxcrt::bt_size_t(1LL) && SDL_FingerID(pxcrt::get_elem_value(fingerids$,pxcrt::bt_size_t(1LL))) == fng$) {
  fid$ = pxcrt::bt_size_t(1LL);
 }
 if (fid$ < pxcrt::bt_size_t(2LL)) {
  if (pxcrt::bt_float(pxcrt::get_elem_value(pos_distance_max$,fid$)) < 0.01f && pxcrt::bt_bool(pxcrt::get_elem_value(fingdown$,fid$))) {
   tap_finger$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(fid$);
  }
  fingdown$[fid$] = false;
  if (fid$ == pxcrt::bt_size_t(1LL)) {
   start_pos$[pxcrt::bt_size_t((0LL))] = cur_pos$[pxcrt::bt_size_t((0LL))];
   ::pxcrt::array_resize< ::pxcrt::pxcvarray< SDL_FingerID >,pxcrt::bt_int >(fingerids$ , pxcrt::bt_size_t(1LL) , (0LL));
   fingdown$[pxcrt::bt_size_t(1LL)] = false;
  } else {
   ::pxcrt::array_erase< ::pxcrt::pxcvarray< SDL_FingerID > >(fingerids$ , pxcrt::bt_size_t((0LL)) , pxcrt::bt_size_t(1LL));
   if (fingerids$.empty()) {
    fingdown$[pxcrt::bt_size_t((0LL))] = false;
   } else {
    cur_pos$[pxcrt::bt_size_t((0LL))] = cur_pos$[pxcrt::bt_size_t(1LL)];
    start_pos$[pxcrt::bt_size_t((0LL))] = cur_pos$[pxcrt::bt_size_t(1LL)];
    fingdown$[pxcrt::bt_size_t((0LL))] = fingdown$[pxcrt::bt_size_t(1LL)];
    fingdown$[pxcrt::bt_size_t(1LL)] = false;
   }
  }
  fingerdown_time$[pxcrt::bt_size_t((0LL))] = pxcrt::bt_size_t((0LL));
  fingerdown_time$[pxcrt::bt_size_t(1LL)] = pxcrt::bt_size_t((0LL));
  finger_zmove_mode$ = (0LL);
 }
 return tap_finger$;
}
void input_control$s::finger_action_one_finger$f(pxcrt::glmpx::tquat< pxcrt::bt_float >::type& rot$, pxcrt::bt_float frame_speed$, pxcrt::bt_size_t fid$) {
 pxcrt::bt_float dx$ = (pxcrt::glmpx::tvec2< pxcrt::bt_float >::type(pxcrt::get_elem_value(cur_pos$,fid$)).x - pxcrt::glmpx::tvec2< pxcrt::bt_float >::type(pxcrt::get_elem_value(start_pos$,fid$)).x);
 pxcrt::bt_float dy$ = (pxcrt::glmpx::tvec2< pxcrt::bt_float >::type(pxcrt::get_elem_value(cur_pos$,fid$)).y - pxcrt::glmpx::tvec2< pxcrt::bt_float >::type(pxcrt::get_elem_value(start_pos$,fid$)).y);
 const pxcrt::bt_float d$ = pxcrt::glmpx::distance< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(start_pos$[fid$] , cur_pos$[fid$]);
 if (d$ > pxcrt::bt_float(3.0)) {
  dx$ /= d$ / pxcrt::bt_float(3.0);
  dy$ /= d$ / pxcrt::bt_float(3.0);
 }
 (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(rot$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(dy$ * pxcrt::bt_float(5.0) * frame_speed$) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0))));
 (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(rot$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(dx$ * pxcrt::bt_float(5.0) * frame_speed$) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0))));
 finger_xyrotate_delta$.x = dx$;
 finger_xyrotate_delta$.y = dy$;
}
void input_control$s::finger_action_two_fingers$f(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& angle$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& pos$, pxcrt::bt_float frame_speed$) {
 const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type d0$ = (::operator$n::sub$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(cur_pos$[pxcrt::bt_size_t((0LL))] , start_pos$[pxcrt::bt_size_t((0LL))]));
 const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type d1$ = (::operator$n::sub$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(cur_pos$[pxcrt::bt_size_t(1LL)] , start_pos$[pxcrt::bt_size_t(1LL)]));
 if (pxcrt::glmpx::dot< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(d0$ , d1$) < 0.0f) {
  if (finger_zmove_mode$ != 2LL) {
   const pxcrt::bt_float distance_start$ = pxcrt::glmpx::distance< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(start_pos$[pxcrt::bt_size_t((0LL))] , start_pos$[pxcrt::bt_size_t(1LL)]);
   pxcrt::bt_float distance_cur$ = pxcrt::glmpx::distance< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(cur_pos$[pxcrt::bt_size_t((0LL))] , cur_pos$[pxcrt::bt_size_t(1LL)]);
   if (distance_cur$ <= 0.0001f) {
    distance_cur$ = 0.0001f;
   }
   const pxcrt::bt_float rat$ = distance_start$ / distance_cur$;
   const pxcrt::bt_float prev$ = finger_zmove_delta$;
   if (rat$ > pxcrt::bt_float(1.2)) {
    finger_zmove_delta$ += 0.001f * frame_speed$;
    if (finger_zmove_delta$ >= pxcrt::bt_float(1.0)) {
     finger_zmove_delta$ = pxcrt::bt_float(1.0);
    }
    finger_zmove_mode$ = 1LL;
   } else if (rat$ < pxcrt::bt_float(0.8)) {
    finger_zmove_delta$ -= 0.001f * frame_speed$;
    if (finger_zmove_delta$ <= pxcrt::bt_float(-1.0)) {
     finger_zmove_delta$ = pxcrt::bt_float(-1.0);
    }
    finger_zmove_mode$ = 1LL;
   }
   if ((prev$ < 0.0f && finger_zmove_delta$ > 0.0f) || (prev$ > 0.0f && finger_zmove_delta$ < 0.0f)) {
    finger_zmove_delta$ = 0.0f;
    finger_zmove_mode$ = 2LL;
   }
  }
 } else {
  const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type d0$ = (::operator$n::sub$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(cur_pos$[pxcrt::bt_size_t((0LL))] , start_pos$[pxcrt::bt_size_t((0LL))]));
  const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type d1$ = (::operator$n::sub$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(cur_pos$[pxcrt::bt_size_t(1LL)] , start_pos$[pxcrt::bt_size_t(1LL)]));
  pxcrt::glmpx::tvec2< pxcrt::bt_float >::type avg$ = (::operator$n::div$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::add$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(d0$ , d1$))) , 2.0f));
  const pxcrt::bt_float d$ = (pxcrt::glmpx::distance< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(start_pos$[pxcrt::bt_size_t((0LL))] , cur_pos$[pxcrt::bt_size_t((0LL))]) , pxcrt::glmpx::distance< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(start_pos$[pxcrt::bt_size_t(1LL)] , cur_pos$[pxcrt::bt_size_t((0LL))])) / 2.0f;
  if (d$ > pxcrt::bt_float(3.0)) {
   (::operator$n::diva$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(avg$ , d$ / pxcrt::bt_float(3.0)));
  }
  (::operator$n::diva$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(avg$ , 32.0f));
  (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(pos$ , (::operator$n::mul$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(angle$ , ((::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(avg$.x , -avg$.y , pxcrt::bt_float(0.0)) , frame_speed$)))))));
 }
}
void input_control$s::finger_action_step$f(::demoapp$n::player_info$s& pl$, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& pos_delta$, pxcrt::bt_float frame_speed$) {
 dmotion$.update();
 pxcrt::glmpx::tquat< pxcrt::bt_float >::type device_rot$ = pxcrt::glmpx::tquat< pxcrt::bt_float >::type();
 device_rot$.x = (::operator$n::getelem$f$p$container$$raw$n$$rawarray$s$p$meta$n$$float$t$q$4$li$r$$q$meta$n$$uint$t$r$(dmotion$.value_xyzw , 0U));
 device_rot$.y = (::operator$n::getelem$f$p$container$$raw$n$$rawarray$s$p$meta$n$$float$t$q$4$li$r$$q$meta$n$$uint$t$r$(dmotion$.value_xyzw , 1U));
 device_rot$.z = (::operator$n::getelem$f$p$container$$raw$n$$rawarray$s$p$meta$n$$float$t$q$4$li$r$$q$meta$n$$uint$t$r$(dmotion$.value_xyzw , 2U));
 device_rot$.w = (::operator$n::getelem$f$p$container$$raw$n$$rawarray$s$p$meta$n$$float$t$q$4$li$r$$q$meta$n$$uint$t$r$(dmotion$.value_xyzw , 3U));
 (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(pl$.angle$ , glm::conjugate< pxcrt::bt_float >(pl$.device_rot_prev$)));
 (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(pl$.angle$ , device_rot$));
 pl$.angle$ = glm::normalize< pxcrt::bt_float >(pl$.angle$);
 pl$.device_rot_prev$ = device_rot$;
 if (pxcrt::bt_bool(pxcrt::get_elem_value(fingdown$,pxcrt::bt_size_t((0LL)))) && !pxcrt::bt_bool(pxcrt::get_elem_value(fingdown$,pxcrt::bt_size_t(1LL)))) {
  if (pxcrt::bt_size_t(pxcrt::get_elem_value(fingerdown_time$,pxcrt::bt_size_t((0LL)))) >= pxcrt::bt_size_t(2LL)) {
   finger_action_one_finger$f(pl$.angle$ , frame_speed$ , pxcrt::bt_size_t((0LL)));
  } else {
   start_pos$[pxcrt::bt_size_t((0LL))] = (::operator$n::div$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::add$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(start_pos$[pxcrt::bt_size_t((0LL))] , cur_pos$[pxcrt::bt_size_t((0LL))]))) , 2.0f));
   fingerdown_time$[pxcrt::bt_size_t((0LL))] += pxcrt::bt_size_t(1LL);
  }
  if (SDL_FingerID(pxcrt::get_elem_value(fingerids$,pxcrt::bt_size_t((0LL)))) == SDL_FingerID((0LL))) {
  }
 } else if (!pxcrt::bt_bool(pxcrt::get_elem_value(fingdown$,pxcrt::bt_size_t((0LL)))) && pxcrt::bt_bool(pxcrt::get_elem_value(fingdown$,pxcrt::bt_size_t(1LL)))) {
  if (pxcrt::bt_size_t(pxcrt::get_elem_value(fingerdown_time$,pxcrt::bt_size_t(1LL))) >= pxcrt::bt_size_t(2LL)) {
   finger_action_one_finger$f(pl$.angle$ , frame_speed$ , pxcrt::bt_size_t((0LL)));
  } else {
   start_pos$[pxcrt::bt_size_t(1LL)] = (::operator$n::div$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::add$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(start_pos$[pxcrt::bt_size_t(1LL)] , cur_pos$[pxcrt::bt_size_t(1LL)]))) , 2.0f));
   fingerdown_time$[pxcrt::bt_size_t(1LL)] += pxcrt::bt_size_t(1LL);
  }
 } else if (pxcrt::bt_bool(pxcrt::get_elem_value(fingdown$,pxcrt::bt_size_t((0LL)))) && pxcrt::bt_bool(pxcrt::get_elem_value(fingdown$,pxcrt::bt_size_t(1LL)))) {
  if (pxcrt::bt_size_t(pxcrt::get_elem_value(fingerdown_time$,pxcrt::bt_size_t((0LL)))) >= pxcrt::bt_size_t(2LL) && pxcrt::bt_size_t(pxcrt::get_elem_value(fingerdown_time$,pxcrt::bt_size_t(1LL))) >= pxcrt::bt_size_t(2LL)) {
   finger_action_two_fingers$f(pl$.angle$ , pl$.position$ , frame_speed$);
  } else {
   start_pos$[pxcrt::bt_size_t((0LL))] = (::operator$n::div$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::add$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(start_pos$[pxcrt::bt_size_t((0LL))] , cur_pos$[pxcrt::bt_size_t((0LL))]))) , 2.0f));
   fingerdown_time$[pxcrt::bt_size_t((0LL))] += pxcrt::bt_size_t(1LL);
   start_pos$[pxcrt::bt_size_t(1LL)] = (::operator$n::div$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::add$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(start_pos$[pxcrt::bt_size_t(1LL)] , cur_pos$[pxcrt::bt_size_t(1LL)]))) , 2.0f));
   fingerdown_time$[pxcrt::bt_size_t(1LL)] += pxcrt::bt_size_t(1LL);
  }
 } else {
  const pxcrt::bt_float len$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(finger_xyrotate_delta$);
  (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(pl$.angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(-finger_xyrotate_delta$.y * pxcrt::bt_float(2.0) * frame_speed$) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0))));
  (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(pl$.angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(-finger_xyrotate_delta$.x * pxcrt::bt_float(2.0) * frame_speed$) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0))));
  const pxcrt::bt_float decay$ = 0.03f * frame_speed$;
  if (len$ < decay$) {
   finger_xyrotate_delta$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(0.0f , 0.0f);
  } else {
   (::operator$n::suba$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(finger_xyrotate_delta$ , (::operator$n::div$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(finger_xyrotate_delta$ , decay$)) , len$))));
  }
 }
 pl$.pos_delta$ = (::operator$n::mul$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(glm::mat3_cast< pxcrt::bt_float >(pl$.angle$) , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , finger_zmove_delta$)));
 (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(pl$.position$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(pl$.pos_delta$ , frame_speed$))));
}
void input_control$s::add_zdelta$f(pxcrt::bt_float zaccel$, pxcrt::bt_float frame_speed$) {
 finger_zmove_delta$ += zaccel$ * frame_speed$;
 if (finger_zmove_delta$ <= pxcrt::bt_float(-1.0)) {
  finger_zmove_delta$ = pxcrt::bt_float(-1.0);
 }
 if (finger_zmove_delta$ >= pxcrt::bt_float(1.0)) {
  finger_zmove_delta$ = pxcrt::bt_float(1.0);
 }
 finger_zmove_mode$ = 1LL;
}
input_control$s::input_control$s(const pxcrt::io& iop$) : dmotion$(iop$ , 1.0 / 30.0), fingerids$(), fingdown$(), fingerdown_time$(), start_pos$(), cur_pos$(), pos_distance_max$(), finger_xyrotate_delta$(), finger_zmove_delta$(), finger_zmove_mode$((0LL)) {
}
void handle_event$f(::demoapp$n::app_impl$s& app$, const SDL_Event& ev$, pxcrt::bt_float frame_speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$) {
 const pxcrt::bt_uint etype$ = ev$.type;
 if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_WINDOWEVENT)) {
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_QUIT)) {
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_MULTIGESTURE)) {
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_MOUSEBUTTONDOWN)) {
  const pxcrt::bt_float bx$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(ev$.button.x) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(pjinfo$.screen_width$);
  const pxcrt::bt_float by$ = ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(ev$.button.y) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(pjinfo$.screen_height$);
  if (bx$ < pxcrt::bt_float(0.1) && by$ < pxcrt::bt_float(0.1)) {
   app$.scene_next_flag$ = true;
  } else if (bx$ > pxcrt::bt_float(0.9) && by$ < pxcrt::bt_float(0.1)) {
  } else if (bx$ > pxcrt::bt_float(0.9) && by$ > pxcrt::bt_float(0.9)) {
   app$.light_on$ = app$.light_on$ > 0.5f ? 0.0f : 1.0f;
  } else {
   ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$uchar$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("mousedown") , ev$.button.x , ev$.button.y , ev$.button.button);
   app$.ictl$.finger_down$f(::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(ev$.button.x) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(pjinfo$.screen_width$) , ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(ev$.button.y) / ::pgl3d$n::glgeometry$n::cast_float$f$p$meta$n$$int$t$r$(pjinfo$.screen_height$) , SDL_FingerID((0LL)));
  }
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_MOUSEBUTTONUP)) {
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_MOUSEMOTION)) {
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_FINGERDOWN)) {
  if (ev$.tfinger.x < pxcrt::bt_float(0.1) && ev$.tfinger.y < pxcrt::bt_float(0.1)) {
   app$.scene_next_flag$ = true;
  } else if (ev$.tfinger.x > pxcrt::bt_float(0.9) && ev$.tfinger.y < pxcrt::bt_float(0.1)) {
  } else if (ev$.tfinger.x > pxcrt::bt_float(0.9) && ev$.tfinger.y > pxcrt::bt_float(0.9)) {
   app$.player$.accel$ = !app$.player$.accel$;
   app$.light_on$ = app$.light_on$ > 0.5f ? 0.0f : 1.0f;
  } else {
   app$.ictl$.finger_down$f(ev$.tfinger.x , ev$.tfinger.y , ev$.tfinger.fingerId);
  }
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_FINGERUP)) {
  pxcrt::bt_int tap_finger$ = app$.ictl$.finger_up$f(ev$.tfinger.fingerId);
  if (tap_finger$ == (0LL)) {
   app$.app_commands$[::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("throw"))] = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"));
  }
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_FINGERMOTION)) {
  /* staticif */
  app$.ictl$.finger_motion$f(ev$.tfinger.x , ev$.tfinger.y , ev$.tfinger.dx , ev$.tfinger.dy , ev$.tfinger.fingerId);
  /* staticif end */
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_APP_WILLENTERBACKGROUND)) {
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_APP_DIDENTERFOREGROUND)) {
 } else if (etype$ == ::SDL2$n::api_base$n::SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(SDL_KEYDOWN)) {
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("KEYDOWN event") , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$SDL2$$api_types$n$$SDL_Scancode$s$r$(ev$.key.keysym.scancode));
  if (ev$.key.keysym.scancode == SDL_SCANCODE_TAB) {
   app$.scene_next_flag$ = true;
  }
  if (ev$.key.keysym.scancode == SDL_SCANCODE_0) {
   commands_r$[::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("fullscreen"))] = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"));
  }
  if (ev$.key.keysym.scancode == SDL_SCANCODE_LEFTBRACKET) {
   commands_r$[::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("vsync"))] = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"));
  }
  if (ev$.key.keysym.scancode == SDL_SCANCODE_T) {
   app$.app_commands$[::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("throw"))] = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"));
  }
 } else {
  ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
  ::text$n::string$n::positional$n::integral_to_positional$f$p$meta$n$$int$t$q$16$li$r$(::pgl3d$n::glgeometry$n::cast_int$f$p$meta$n$$uint$t$r$(ev$.type) , s$);
  ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(pxcrt::bt_strlit("unknown event") , s$);
 }
}
pxcrt::bt_uint get_key$f102(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& keys$102, int k$) {
 return pxcrt::bt_uint(keys$102[pxcrt::bt_size_t(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$SDL2$$api_types$n$$SDL_Scancode$s$r$(k$))]);
}
void handle_keys$f(::demoapp$n::app_impl$s& app$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& keys$102, pxcrt::bt_float frame_speed$, const ::pgl3d$n::pglbase$n::projection_info$s& pjinfo$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& commands_r$) {
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_UP) != pxcrt::bt_uint((0LL))) {
  (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(1.0f * frame_speed$) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_DOWN) != pxcrt::bt_uint((0LL))) {
  (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(-1.0f * frame_speed$) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_LEFT) != pxcrt::bt_uint((0LL))) {
  (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(1.0f * frame_speed$) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_RIGHT) != pxcrt::bt_uint((0LL))) {
  (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(-1.0f * frame_speed$) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_SPACE) != pxcrt::bt_uint((0LL))) {
  app$.ictl$.add_zdelta$f(-0.001f , frame_speed$);
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_LSHIFT) != pxcrt::bt_uint((0LL))) {
  app$.ictl$.add_zdelta$f(0.001f , frame_speed$);
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_A) != pxcrt::bt_uint((0LL))) {
  (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(app$.player$.position$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(-0.05) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0)))) , frame_speed$))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_D) != pxcrt::bt_uint((0LL))) {
  (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(app$.player$.position$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.05) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0)))) , frame_speed$))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_S) != pxcrt::bt_uint((0LL))) {
  (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(app$.player$.position$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(-0.05) , pxcrt::bt_float(0.0)))) , frame_speed$))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_W) != pxcrt::bt_uint((0LL))) {
  (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(app$.player$.position$ , (::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.05) , pxcrt::bt_float(0.0)))) , frame_speed$))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_Z) != pxcrt::bt_uint((0LL))) {
  (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(1.0f * frame_speed$) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_X) != pxcrt::bt_uint((0LL))) {
  (::operator$n::mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(app$.player$.angle$ , pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(-1.0f * frame_speed$) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0))));
 }
 if (::demoapp$n::get_key$f102(keys$102 , SDL_SCANCODE_RETURN) != pxcrt::bt_uint((0LL))) {
  app$.ictl$.finger_zmove_delta$ = pxcrt::bt_float(0.0);
  app$.ictl$.finger_zmove_mode$ = 1LL;
 }
 app$.ictl$.finger_action_step$f(app$.player$ , app$.player$.pos_delta$ , frame_speed$);
 {
  pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s >::guard_val< const pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > > t0((app$.scene_shared$));
  ::demoapp$n::demoapp_scene_shared$s& ss$ = (*((t0.get())));
  ss$.light_on$ = app$.light_on$;
  ss$.scene_next_flag$ = app$.scene_next_flag$;
  ss$.posang$.position$ = app$.player$.position$;
  ss$.posang$.angle$ = app$.player$.angle$;
  ::container$n::tree_map$n::tree_map_compare_swap$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$(ss$.app_commands$ , app$.app_commands$);
  app$.scene_next_flag$ = false;
 }
 app$.app_commands$.clear();
}
pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > init_drawers$f(::demoapp$n::app_impl$s& app$, const ::pgl3d$n::shader_config$n::shader_config$s& sconf$) {
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > r$ = pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< ::pgl3d$n::pglbase$n::pgldrawer_export_i$i >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >();
 r$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_triangles")) , ::pgl3d$n::drawer_export$n::make_drawer_triangles$f(sconf$ , (0LL)));
 r$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_triangles_alt")) , ::pgl3d$n::drawer_export$n::make_drawer_triangles$f(sconf$ , 1LL));
 r$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_triangles2")) , ::pgl3d$n::drawer_export$n::make_drawer_triangles2$f(sconf$));
 r$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_lineparticle")) , ::pgl3d$n::drawer_export$n::make_drawer_lineparticle$f(sconf$));
 r$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_particle")) , ::pgl3d$n::drawer_export$n::make_drawer_particle$f(sconf$));
 r$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_particle_bb")) , ::pgl3d$n::drawer_export$n::make_drawer_particle_bb$f(sconf$));
 r$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_rect2d")) , ::pgl3d$n::drawer_export$n::make_drawer_rect2d$f(sconf$));
 r$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_font2")) , ::pgl3d$n::drawer_export$n::make_drawer_font2$f(sconf$));
 return r$;
}
void shapes_add$f119(::pgl3d$n::pglbase$n::make_vertices_i$i& pgs$119, ::demoapp$n::app_impl$s& app$119, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& name$) {
 const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > t0 = pgs$119.get_vertices$f(name$);
 const ::pxcrt::pxcvarray< pxcrt::bt_float >& posdt$ = (((t0)->value)).positions$;
 ((*((pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s >::guard_val< const pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > > (app$119.scene_shared$).get())))).shapes$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(name$) , ::pointer$n::make_tptr$f$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(posdt$));
 ::io$n::standard$n::debug_log$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(pxcrt::bt_strlit("vtxs") , name$ , posdt$.size() , posdt$);
}
void build_vertices$f(::demoapp$n::app_impl$s& app$119, ::pgl3d$n::pglbase$n::make_vertices_i$i& pgs$119) {
 const ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,1LL > objs$ = ::container$n::array$n::make_farray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("parts")));
 const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > tr$ = ::container$n::array$n::make_varray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$2$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_triangles")) , ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_triangles_alt")));
 const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > tr2$ = ::container$n::array$n::make_varray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_triangles2")));
 const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > parti$ = ::container$n::array$n::make_varray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_particle")));
 const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > parti_bb$ = ::container$n::array$n::make_varray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("drawer_particle_bb")));
 {
  const ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,1LL >& ag$fe = (objs$);
  const size_t sz$fe = ag$fe.size();
  const ::pxcrt::pxcvarray< pxcrt::bt_uchar > *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   const ::pxcrt::pxcvarray< pxcrt::bt_uchar > name$ = ar$fe[i$];
   {
    ::pxcrt::pxcvarray< pxcrt::bt_uchar > fn$ = (::operator$n::add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(name$ , pxcrt::bt_strlit(".obj")));
    ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(pxcrt::bt_strlit("load") , fn$);
    const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > wfobjp$ = ::pgl3d$n::wfobj$n::wfobject_read$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::pgl3d$n::mainloop$n::sdl_read_file$f(fn$)).get_crange()));
    {
          const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > t1 = wfobjp$;
::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >& ag$fe = ((((t1)->value)).v$);
     ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >::guard_ref< ::pxcrt::pxcvarray< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type > > ag$fg(ag$fe);
     const size_t sz$fe = ag$fe.size();
     pxcrt::glmpx::tvec3< pxcrt::bt_float >::type *const ar$fe = ag$fe.rawarr();
     for (pxcrt::bt_size_t j$ = 0; j$ != sz$fe; ++j$) {
      pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& v$ = ar$fe[j$];
      {
      }
     }
    }
    {
          const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > t2 = wfobjp$;
const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& ag$fe = ((((t2)->value)).groups$);
     pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > ag$fg(ag$fe);
     for (pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::const_iterator i$fe = ag$fe.begin(); i$fe != ag$fe.end(); ++i$fe) {
      const ::pxcrt::pxcvarray< pxcrt::bt_uchar > k$ = ag$fe.get_ckey(i$fe);
      const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > g$ = ag$fe.get_cmapped(i$fe);
      {
       pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (name$).get_crange()) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$(((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > >(wfobjp$))->value) , ((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > >(g$))->value) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL)))));
      }
     }
    }
   }
  }
 }
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(pxcrt::bt_strlit("load prebuild"));
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(1U);
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type m$ = pxcrt::glmpx::tmat4< pxcrt::bt_float >::type();
 pxcrt::glmpx::tmat4< pxcrt::bt_float >::type m1$ = pxcrt::glmpx::tmat4< pxcrt::bt_float >::type();
 m$ = glm::translate< pxcrt::bt_float >(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type() , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(2.0)));
 m1$ = glm::rotate< pxcrt::bt_float >(glm::translate< pxcrt::bt_float >(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type() , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(-1.0))) , ::pgl3d$n::pglcommon$n::to_radians$f(pxcrt::bt_float(45.0)) , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0)));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("box")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(1.4142f * 1.0f , pxcrt::bt_size_t(4LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$(m1$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(m$ , false , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$(m1$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))))));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("saucer")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(3.0) , pxcrt::bt_size_t(40LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float(0.2) , pxcrt::bt_float(0.5) , 1LL , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL)))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float(0.01) , pxcrt::bt_float(0.9) , 5LL , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$(pxcrt::bt_size_t(10LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$(pxcrt::bt_size_t(1LL))))));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("saucer-multi")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(15.0) , pxcrt::bt_size_t(3LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float(1.0) , pxcrt::bt_float(1.0) , 1LL , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("saucer"))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$()) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$()));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("block-multi")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(600.0) , pxcrt::bt_size_t(4LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t(9LL) , pxcrt::bt_size_t(8LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("block")))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$()));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(1U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("block")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(50.0) , pxcrt::bt_size_t(4LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$(pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(pxcrt::bt_float(45.0)) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0)) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t(30LL) , pxcrt::bt_size_t(30LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$(pxcrt::bt_size_t(1LL) , pxcrt::bt_float(0.8) , pxcrt::bt_float(0.2) , pxcrt::bt_float(0.8) , pxcrt::bt_float(0.2) , pxcrt::bt_float(0.8) , pxcrt::bt_float(1.0) , pxcrt::bt_float(4.0) , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t(1LL)) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t(1LL)) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t(1LL))))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$(pxcrt::glmpx::make_tquat_angle_axis< pxcrt::bt_float >(::pgl3d$n::pglcommon$n::to_radians$f(pxcrt::bt_float(-45.0)) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0)) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float(0.01) , pxcrt::bt_float(1.0) , 1LL , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL)))))));
 m$ = glm::rotate< pxcrt::bt_float >(glm::translate< pxcrt::bt_float >(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type() , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0))) , ::pgl3d$n::pglcommon$n::to_radians$f(pxcrt::bt_float(10.0)) , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0)));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(1.0) , pxcrt::bt_size_t(6LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(m$ , false , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL)))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(m$ , false , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))))));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet-multi")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(600.0) , pxcrt::bt_size_t(4LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t(170LL) , pxcrt::bt_size_t(170LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet")))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$()));
 m$ = glm::rotate< pxcrt::bt_float >(glm::translate< pxcrt::bt_float >(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type() , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0))) , pxcrt::bt_float(10.0) , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(1.0)));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(1.0) , pxcrt::bt_size_t(5LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float(1.3) , pxcrt::bt_float(0.8) , 1LL , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL)))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float(0.8) , pxcrt::bt_float(0.8) , 1LL , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL))))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(991U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2-multi")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(200.0) , pxcrt::bt_size_t(37000LL) , false , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2")))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(991U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("block-multi2")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(500.0) , pxcrt::bt_size_t(200LL) , false , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("block")))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(991U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2-multi2")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(200.0) , pxcrt::bt_size_t(20000LL) , false , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2")))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(991U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2-multi3")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(200.0) , pxcrt::bt_size_t(2000LL) , false , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2")))));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet-multi-2")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(600.0) , pxcrt::bt_size_t(4LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t(80LL) , pxcrt::bt_size_t(80LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet")))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$()));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(991U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("saucer-multi3")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(200.0) , pxcrt::bt_size_t(200LL) , false , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("saucer")))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(991U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("ab-multi3")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(100.0) , pxcrt::bt_size_t(100LL) , false , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("airboat")))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(1U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (parti$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("particle")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(1.0) , pxcrt::bt_size_t(100LL) , true , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL)))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(991U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (parti$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("particle-multi")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(60.0) , pxcrt::bt_size_t(30000LL) , true , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("particle")))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(1U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (parti$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("particle-bb")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(1.0) , pxcrt::bt_size_t(100LL) , true , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t((0LL)))));
 rnd$ = ::pointer$n::make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(991U);
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (parti_bb$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("particle-bb-multi")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float(60.0) , pxcrt::bt_size_t(10000LL) , true , true , rnd$ , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("particle-bb")))));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (parti_bb$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mixed")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(1.0) , pxcrt::bt_size_t(5LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float(1.0) , pxcrt::bt_float(10.0) , 1LL , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$() , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("saucer")))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("particle-bb")))));
 pgs$119.make_vertex_set$f((::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > (tr$).get_crange()) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("rigidbody-multi")) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float(100.0) , pxcrt::bt_size_t(4LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t(10LL) , pxcrt::bt_size_t(10LL) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2")))) , ::callable$n::make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$()));
 ((*((pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s >::guard_val< const pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > > (app$119.scene_shared$).get())))).default_font_texture_info$ = pgs$119.get_texture_info$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("font")));
 ::demoapp$n::shapes_add$f119(pgs$119, app$119 , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("box")));
 ::demoapp$n::shapes_add$f119(pgs$119, app$119 , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2")));
}
::pgl3d$n::scene_node$n::scene_node$s make_node$f() {
 return ::pgl3d$n::scene_node$n::scene_node$s(::pgl3d$n::scene_node$n::joint_id_type$s() , pxcrt::glmpx::tmat4< pxcrt::bt_float >::type());
}
lpbullet_data$s::lpbullet_data$s() : value$(){
 /* value$ */;
}
lpbullet_data$s::lpbullet_data$s(::pxcrt::farray< pxcrt::bt_float,9LL > value$) : value$(value$){
 /* value$ */;
}
void scene_control$s::init$f() {
 node_scene$ = instantiate_cur_scene$f();
}
::pgl3d$n::scene_node$n::scene_node$s scene_control$s::instantiate_cur_scene$f() {
 const ::pxcrt::pxcvarray< pxcrt::bt_uchar > name$ = scene_names$[cur_scene$];
 ::pgl3d$n::scene_node$n::scene_node$s r$ = nodefac$.make_node_by_name$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (name$).get_crange()) , pxcrt::glmpx::tmat4< pxcrt::bt_float >::type());
 dynamics_world$.clear$f();
 boxes$.clear();
 if (cur_scene$ == pxcrt::bt_size_t((0LL))) {
  dynamics_world$.dynamicsWorld$.setGravity(::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(0.0f , 0.0f , -10.0f));
  const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ > groundShape$ = ::pointer$n::make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$q$m$ll$p$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(50.0f , 50.0f , 50.0f));
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > rbGround$ = ::pointer$n::make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(groundShape$ , 0.0f , ::Bullet$n::api$n::btTransform_$f$p$m$ll$p$m$ll$p$Bullet$$api$n$$btQuaternion$s$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(::btQuaternion::getIdentity() , ::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(0.0f , 20.0f , -60.0f)));
  ((pxcrt::rawptr___deref< ::btRigidBody >(::btRigidBody::upcast(::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionObject$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btRigidBody$s$r$$r$(pxcrt::address< ::btRigidBody >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >(rbGround$))->value)).rigidBody$)))))).setFriction(0.1f);
  dynamics_world$.addRigidBody$f(rbGround$);
  const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ > colShape$ = ::pointer$n::make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$q$m$ll$p$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(1.0f , 1.0f , 1.0f));
  pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >::guard_val< const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > > > t2(((((pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > (shapes$).get()).equal_range(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("bullet2")))).deref())));
  const ::pxcrt::pxcvarray< pxcrt::bt_float >& points$ = (((t2.get()))->value);
  const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ > colShape1$ = ::pointer$n::make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$q$m$ll$p$m$ll$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(pxcrt::array_to_crawptr< ::pxcrt::pxcvarray< pxcrt::bt_float > >(points$) , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(points$.size() / pxcrt::bt_size_t(3LL)) , 3LL * 4LL);
  pxcrt::bt_int xsize$ = 10LL;
  pxcrt::bt_int ysize$ = 5LL;
  pxcrt::bt_int zsize$ = 10LL;
  pxcrt::bt_float start_x$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(-xsize$ - xsize$ / 2LL);
  pxcrt::bt_float start_y$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(-ysize$ - ysize$ / 2LL);
  pxcrt::bt_float start_z$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(-zsize$);
  pxcrt::bt_int k$ = pxcrt::bt_int();
  pxcrt::bt_int i$ = pxcrt::bt_int();
  pxcrt::bt_int j$ = pxcrt::bt_int();
  ::btTransform startTransform$ = ::Bullet$n::api$n::btTransform_$f$p$m$ll$p$m$ll$p$Bullet$$api$n$$btQuaternion$s$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(::btQuaternion::getIdentity() , ::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(0.0f , 0.0f , 0.0f));
  for (pxcrt::bt_int k$ = (0LL); k$ < xsize$; ++k$) {
   for (pxcrt::bt_int i$ = (0LL); i$ < ysize$; ++i$) {
    for (pxcrt::bt_int j$ = (0LL); j$ < zsize$; ++j$) {
     const pxcrt::bt_float x$ = 3.5f * ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(k$) + start_x$;
     const pxcrt::bt_float y$ = 20.0f + 3.5f * ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(i$) + start_y$;
     const pxcrt::bt_float z$ = 10.0f + 2.1f * ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(j$) + start_z$;
     startTransform$.setOrigin(::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(x$ , y$ , z$));
     const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > rb$ = ::pointer$n::make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$1$li$r$$r$$r$(colShape1$ , 1.0f , startTransform$);
     ((pxcrt::rawptr___deref< ::btRigidBody >(::btRigidBody::upcast(::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionObject$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btRigidBody$s$r$$r$(pxcrt::address< ::btRigidBody >((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >(rb$))->value)).rigidBody$)))))).setFriction(1.0f);
     dynamics_world$.addRigidBody$f(rb$);
     if (boxes$.size() >= r$.children$.size()) {
      const ::pgl3d$n::scene_node$n::scene_node$s v$ = r$.children$[r$.children$.size() - pxcrt::bt_size_t(1LL)];
      ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >,::pgl3d$n::scene_node$n::scene_node$s >(r$.children$ , v$);
     }
     if (boxes$.size() < r$.children$.size()) {
      pxcrt::bt_size_t p$ = boxes$.size();
      ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > > t0((r$.children$));
      ::pgl3d$n::scene_node$n::scene_node$s& csn$ = (t0.get())[p$];
      pxcrt::glmpx::tvec3< pxcrt::bt_float >::type pos$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(x$ , y$ , z$);
      pxcrt::glmpx::tmat4< pxcrt::bt_float >::type m$ = glm::translate< pxcrt::bt_float >(pxcrt::glmpx::tmat4< pxcrt::bt_float >::type() , pos$);
      csn$.trans$.value = m$;
     }
     ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >(boxes$ , rb$);
    }
   }
  }
 }
 return r$;
}
void scene_control$s::scene_next$f() {
 ++cur_scene$;
 if (cur_scene$ >= scene_names$.size()) {
  cur_scene$ = pxcrt::bt_size_t((0LL));
 }
 node_scene$ = instantiate_cur_scene$f();
}
scene_control$s::scene_control$s(const ::pgl3d$n::scene_node$n::node_factory$s& nfac$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& shapes0$) : nodefac$(nfac$), prev_spawn$(pxcrt::bt_float(0.0)), motion_count$(pxcrt::bt_float(0.0)), joint_id_lp$(nodefac$.get_joint_id_by_name$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("lineparticle")))), joint_id_font$(nodefac$.get_joint_id_by_name$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("default_font")))), joint_id_rect2d$(nodefac$.get_joint_id_by_name$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("rect2d")))), cur_scene$(pxcrt::bt_size_t((0LL))), lpbullet$(), node_scene$(::demoapp$n::make_node$f()), node_status_message$(::demoapp$n::make_node$f()), node_buttons$(::demoapp$n::make_node$f()), dynamics_world$(), boxes$(), shapes$(shapes0$), scene_names$(::container$n::array$n::make_darray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("rigidbody-multi")))) {
 init$f();
}
void scene_control_set_message$f(::demoapp$n::scene_control$s& sctl$, ::pgl3d$n::scene_node$n::scene_node$s& sn_text$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& text$, pxcrt::bt_uint x$, pxcrt::bt_uint y$, pxcrt::bt_uint font_width$, pxcrt::bt_uint font_height$, pxcrt::bt_float screen_w$, pxcrt::bt_float screen_h$) {
 {
  ::pgl3d$n::scene_node$n::scene_node$s& nd$ = sn_text$;
  const pxcrt::bt_size_t n$ = text$.size();
  while (nd$.children$.size() < n$) {
   const ::pgl3d$n::scene_node$n::scene_node$s p$((sctl$.joint_id_font$), (pxcrt::glmpx::tmat4< pxcrt::bt_float >::type()));
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >,::pgl3d$n::scene_node$n::scene_node$s >(nd$.children$ , p$);
  }
  if (nd$.children$.size() > n$) {
   ::pxcrt::array_erase< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > >(nd$.children$ , n$ , nd$.children$.size());
  }
  {
   ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >& ag$fe = (nd$.children$);
   ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > > ag$fg(ag$fe);
   const size_t sz$fe = ag$fe.size();
   ::pgl3d$n::scene_node$n::scene_node$s *const ar$fe = ag$fe.rawarr();
   for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
    ::pgl3d$n::scene_node$n::scene_node$s& p$ = ar$fe[i$];
    {
     const ::pxcrt::bt_slice< pxcrt::bt_float >& sli$ = pxcrt::glmpx::tmat4_to_slice< pxcrt::bt_float >(p$.trans$.value);
     sli$[pxcrt::bt_size_t(2LL)] = (::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(x$) / screen_w$) * 2.0f - 1.0f;
     sli$[pxcrt::bt_size_t(3LL)] = (::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(y$) / screen_h$) * 2.0f - 1.0f;
     x$ += font_width$;
     if (i$ < text$.size()) {
      sli$[pxcrt::bt_size_t((0LL))] = ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uchar$t$r$(pxcrt::bt_uchar(pxcrt::get_elem_value(text$,i$)) - pxcrt::bt_uchar(32LL));
     } else {
      sli$[pxcrt::bt_size_t((0LL))] = 0.0f;
     }
    }
   }
  }
 }
}
::btTransform to_btTransform$f(const ::pgl3d$n::pglbase$n::position_angle$s& posang$) {
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& p$ = posang$.position$;
 const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a$ = posang$.angle$;
 const ::btQuaternion q$ = ::Bullet$n::api$n::btQuaternion_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(a$.x , a$.y , a$.z , a$.w);
 const ::btVector3 v$ = ::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(p$.x , p$.y , p$.z);
 return ::Bullet$n::api$n::btTransform_$f$p$m$ll$p$m$ll$p$Bullet$$api$n$$btQuaternion$s$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(q$ , v$);
}
void scene_control_update_buttons$f(::demoapp$n::scene_control$s& sctl$, ::pgl3d$n::scene_node$n::scene_node$s& sn_buttons$) {
 ::pgl3d$n::scene_node$n::scene_node$s& nd$ = sn_buttons$;
 if (nd$.children$.size() < pxcrt::bt_size_t(1LL)) {
  const ::pgl3d$n::scene_node$n::scene_node$s p$((sctl$.joint_id_rect2d$), (pxcrt::glmpx::tmat4< pxcrt::bt_float >::type()));
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >,::pgl3d$n::scene_node$n::scene_node$s >(nd$.children$ , p$);
 }
 ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > > t0((nd$.children$));
 ::pgl3d$n::scene_node$n::scene_node$s& cn$ = (t0.get())[pxcrt::bt_size_t((0LL))];
 const ::pxcrt::bt_slice< pxcrt::bt_float >& sli$ = pxcrt::glmpx::tmat4_to_slice< pxcrt::bt_float >(cn$.trans$.value);
 sli$[pxcrt::bt_size_t((0LL))] = -0.99f;
 sli$[pxcrt::bt_size_t(1LL)] = 0.81f;
 sli$[pxcrt::bt_size_t(2LL)] = 0.18f;
 sli$[pxcrt::bt_size_t(3LL)] = 0.18f;
}
pxcrt::bt_bool lp_is_finished$f150(const ::demoapp$n::lpbullet_data$s& lpb$) {
 return pxcrt::bt_float(pxcrt::get_elem_value(lpb$.value$,pxcrt::bt_size_t(7LL))) > 200.0f;
}
void step_lp$f148(const pxcrt::bt_float& speed$148$demoapp$ns0, ::demoapp$n::scene_control$s& sctl$148) {
 {
  ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s >& ag$fe = (sctl$148.lpbullet$);
  ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s >::guard_ref< ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  ::demoapp$n::lpbullet_data$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   ::demoapp$n::lpbullet_data$s& lpb$ = ar$fe[i$];
   {
    const ::pxcrt::bt_slice< pxcrt::bt_float > sli$ = lpb$.value$.range();
    pxcrt::glmpx::tvec3< pxcrt::bt_float >::type vec0$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(pxcrt::get_elem_value(sli$,pxcrt::bt_size_t((0LL)))) , pxcrt::bt_float(pxcrt::get_elem_value(sli$,pxcrt::bt_size_t(1LL))) , pxcrt::bt_float(pxcrt::get_elem_value(sli$,pxcrt::bt_size_t(2LL))));
    pxcrt::glmpx::tvec3< pxcrt::bt_float >::type vec1$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(pxcrt::get_elem_value(sli$,pxcrt::bt_size_t(3LL))) , pxcrt::bt_float(pxcrt::get_elem_value(sli$,pxcrt::bt_size_t(4LL))) , pxcrt::bt_float(pxcrt::get_elem_value(sli$,pxcrt::bt_size_t(5LL))));
    const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type vd$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(vec1$ , vec0$));
    (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(vec0$ , (::operator$n::div$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vd$ , speed$148$demoapp$ns0)) , 4.0f))));
    (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(vec1$ , (::operator$n::div$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$((::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vd$ , speed$148$demoapp$ns0)) , 4.0f))));
    sli$[pxcrt::bt_size_t((0LL))] = vec0$.x;
    sli$[pxcrt::bt_size_t(1LL)] = vec0$.y;
    sli$[pxcrt::bt_size_t(2LL)] = vec0$.z;
    sli$[pxcrt::bt_size_t(3LL)] = vec1$.x;
    sli$[pxcrt::bt_size_t(4LL)] = vec1$.y;
    sli$[pxcrt::bt_size_t(5LL)] = vec1$.z;
    const pxcrt::bt_float step$ = pxcrt::bt_float(pxcrt::get_elem_value(sli$,pxcrt::bt_size_t(7LL))) + speed$148$demoapp$ns0;
    const pxcrt::bt_float sz$ = ::ordered$n::min$f$p$meta$n$$float$t$r$(1.0f , (200.0f - step$) / 20.0f);
    sli$[pxcrt::bt_size_t(6LL)] = 0.25f * sz$;
    sli$[pxcrt::bt_size_t(7LL)] = step$;
   }
  }
 }
 ::pgl3d$n::pglcommon$n::erase_cond$f$p$demoapp$n$$lp_is_finished$f150$q$container$$array$n$$varray$s$p$demoapp$n$$lpbullet_data$s$r$$r$(sctl$148.lpbullet$);
}
void spawn_lp$f148(::demoapp$n::scene_control$s& sctl$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& tr$, pxcrt::bt_float speed$) {
 const pxcrt::bt_size_t lim$ = pxcrt::bt_size_t(200000U);
 if (sctl$.lpbullet$.size() > lim$) {
  return;
 }
 {
  ::demoapp$n::lpbullet_data$s lpb$;
  const ::pxcrt::bt_slice< pxcrt::bt_float >& sli$ = lpb$.value$.range();
  const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type p0$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(tr$ , pxcrt::glmpx::make_tvec4< pxcrt::bt_float >(0.0f , 0.0f , -5.0f , 1.0f)));
  const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type p1$ = (::operator$n::mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(tr$ , pxcrt::glmpx::make_tvec4< pxcrt::bt_float >(0.0f , 0.0f , -10.0f , 1.0f)));
  sli$[pxcrt::bt_size_t((0LL))] = p0$.x;
  sli$[pxcrt::bt_size_t(1LL)] = p0$.y;
  sli$[pxcrt::bt_size_t(2LL)] = p0$.z;
  sli$[pxcrt::bt_size_t(3LL)] = p1$.x;
  sli$[pxcrt::bt_size_t(4LL)] = p1$.y;
  sli$[pxcrt::bt_size_t(5LL)] = p1$.z;
  sli$[pxcrt::bt_size_t(6LL)] = 0.25f;
  sli$[pxcrt::bt_size_t(7LL)] = 0.0f;
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s >,::demoapp$n::lpbullet_data$s >(sctl$.lpbullet$ , lpb$);
 }
 return;
}
void prepare_one$f148(::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$148, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$148, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$148, const ::pgl3d$n::scene_node$n::scene_node$s& sn$) {
 const pxcrt::bt_uint& bo_id$ = sn$.joint_id$.bo_id$;
 const pxcrt::bt_int& vs_id$ = sn$.joint_id$.vs_id$;
 if (bo_id$ >= pxcrt::bt_uint((0LL)) && vs_id$ >= (0LL)) {
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >::guard_ref< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > > t0((whole_instances$148));
  ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > > t1(((t0.get())[pxcrt::bt_size_t(bo_id$)]));
  ::pgl3d$n::pglbase$n::instance_data$s& idata$ = (t1.get())[::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(vs_id$)];
  ::pointer$n::tfuncptr$n::tfuncptr3___call$f$p$m$ll$p$m$ll$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$scene_node$s$q$0$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$node_common_data$s$q$1$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$instance_data$s$q$1$li$r$$r$$r$(ftable$148[pxcrt::bt_size_t(bo_id$)] , sn$ , ncd$148 , idata$);
 }
}
void step_snobj$f148(const pxcrt::bt_float& speed$148$demoapp$ns0, ::demoapp$n::scene_control$s& sctl$148, ::pgl3d$n::scene_node$n::scene_node$s& sn_work$148$demoapp$ns0, pxcrt::bt_bool& spawn_now$148$demoapp$ns0, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& _0$up, ::pgl3d$n::pglbase$n::node_common_data$s& _1$up, ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > const& _2$up, ::pgl3d$n::scene_node$n::scene_node$s& sn_scene$) {
 ::pgl3d$n::scene_node$n::scene_node$s& snobj$ = sn_scene$;
 ::demoapp$n::prepare_one$f148(_0$up, _1$up, _2$up , snobj$);
 {
  ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >& ag$fe = (snobj$.children$);
  ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  ::pgl3d$n::scene_node$n::scene_node$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t ci$ = 0; ci$ != sz$fe; ++ci$) {
   ::pgl3d$n::scene_node$n::scene_node$s& csnp$ = ar$fe[ci$];
   {
    ::pgl3d$n::scene_node$n::scene_node$s& csn$ = csnp$;
    sn_work$148$demoapp$ns0.joint_id$ = csn$.joint_id$;
    sn_work$148$demoapp$ns0.trans$.value = glm::rotate< pxcrt::bt_float >(csn$.trans$.value , ::pgl3d$n::pglcommon$n::to_radians$f(sctl$148.motion_count$) , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(pxcrt::bt_float(1.0) , pxcrt::bt_float(0.0) , pxcrt::bt_float(0.0)));
    if (spawn_now$148$demoapp$ns0) {
     ::demoapp$n::spawn_lp$f148(sctl$148 , sn_work$148$demoapp$ns0.trans$.value , speed$148$demoapp$ns0);
    }
    ::demoapp$n::prepare_one$f148(_0$up, _1$up, _2$up , sn_work$148$demoapp$ns0);
   }
  }
 }
}
void step_snobj_dynamics$f148(const pxcrt::bt_float& speed$148$demoapp$ns0, const ::demoapp$n::demoapp_scene_shared$s& ss$148, ::demoapp$n::scene_control$s& sctl$148, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& _0$up, ::pgl3d$n::pglbase$n::node_common_data$s& _1$up, ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > const& _2$up, ::pgl3d$n::scene_node$n::scene_node$s& sn_scene$, pxcrt::bt_bool spawn_obj$) {
 if (spawn_obj$ && sn_scene$.children$.size() > pxcrt::bt_size_t((0LL))) {
  ::pgl3d$n::scene_node$n::scene_node$s csn$ = sn_scene$.children$[pxcrt::bt_size_t((0LL))];
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type a$ = (::operator$n::mul$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(ss$148.posang$.angle$ , pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , 0.0f , -200.0f)));
  ::pgl3d$n::pglbase$n::position_angle$s posang$ = ss$148.posang$;
  (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(posang$.position$ , (::operator$n::div$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(a$ , 500.0f))));
  const ::btTransform startTransform$ = ::demoapp$n::to_btTransform$f(posang$);
  const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > rb$ = ::pointer$n::make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape_i$i$r$$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$((((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >::guard_ref< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > > > (sctl$148.boxes$).get()),pxcrt::bt_size_t((0LL)))))->value)).collisionShape$ , 2.0f , startTransform$);
  (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >(rb$))->value)).rigidBody$.applyCentralImpulse(::Bullet$n::api$n::btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(a$.x , a$.y , a$.z));
  (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >(rb$))->value)).rigidBody$.activate(true);
  sctl$148.dynamics_world$.addRigidBody$f(rb$);
  csn$.trans$.value = ss$148.posang$.to_mat4$f();
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >,::pgl3d$n::scene_node$n::scene_node$s >(sn_scene$.children$ , csn$);
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >,pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >(sctl$148.boxes$ , rb$);
  ::io$n::standard$n::debug_log$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("spawn_obj") , sn_scene$.children$.size());
 }
 pxcrt::bt_float fixedstep$ = 0.1f / 60.0f;
 pxcrt::bt_float step$ = speed$148$demoapp$ns0 / 60.0f;
 if (step$ < fixedstep$) {
  fixedstep$ = step$;
 }
 pxcrt::bt_int substep$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$float$t$r$(step$ / fixedstep$) + 1LL;
 sctl$148.dynamics_world$.dynamicsWorld$.stepSimulation(step$ , 1LL , 1.0f / 60.0f);
 pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL));
 for (i$ = pxcrt::bt_size_t((0LL)); i$ < sctl$148.boxes$.size() && i$ < sn_scene$.children$.size(); ++i$) {
  ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s >::guard_ref< ::pxcrt::pxcvarray< ::pgl3d$n::scene_node$n::scene_node$s > > t0((sn_scene$.children$));
  ::pgl3d$n::scene_node$n::scene_node$s& csn$ = (t0.get())[i$];
  ::btTransform trans$ = ::btTransform();
  (((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > >(pxcrt::get_elem_value((::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > >::guard_ref< ::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > > > (sctl$148.boxes$).get()),i$)))->value)).motionState$.getWorldTransform(trans$);
  trans$.getOpenGLMatrix(pxcrt::slice_to_rawptr< pxcrt::bt_float >(pxcrt::glmpx::tmat4_to_slice< pxcrt::bt_float >(csn$.trans$.value)));
  ::demoapp$n::prepare_one$f148(_0$up, _1$up, _2$up , csn$);
 }
}
void scene_control_step$f(::demoapp$n::scene_control$s& sctl$148, const ::demoapp$n::demoapp_scene_shared$s& ss$148, pxcrt::bt_float frame_speed$, ::pgl3d$n::pglbase$n::node_common_data$s& ncd$148, const ::pxcrt::bt_cslice< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >& ftable$148, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& whole_instances$148) {
 if (ss$148.scene_next_flag$) {
  sctl$148.scene_next$f();
 }
 const pxcrt::bt_float speed$148$demoapp$ns0 = frame_speed$;
 ::pgl3d$n::scene_node$n::scene_node$s sn_work$148$demoapp$ns0 = ::demoapp$n::make_node$f();
 ::demoapp$n::step_lp$f148(speed$148$demoapp$ns0, sctl$148);
 pxcrt::bt_bool spawn_now$148$demoapp$ns0 = false;
 {
  sctl$148.prev_spawn$ += speed$148$demoapp$ns0;
  if (sctl$148.prev_spawn$ > pxcrt::bt_float(3.0)) {
   spawn_now$148$demoapp$ns0 = ss$148.light_on$ != 0.0f;
   sctl$148.prev_spawn$ -= pxcrt::bt_float(3.0);
  }
 }
 if (sctl$148.cur_scene$ == pxcrt::bt_size_t((0LL))) {
  pxcrt::bt_bool spawn_obj$ = false;
  {
   pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > t0((ss$148.app_commands$));
   pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > const& ag$fe = ((t0.get()));
   pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::cfind_type i$it = ag$fe.find(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("throw")));
   if (i$it != ag$fe.notfound()) {
    const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$ = ag$fe.get_cmapped(i$it);
    {
     spawn_obj$ = true;
    }
   }
  }
  ::demoapp$n::step_snobj_dynamics$f148(speed$148$demoapp$ns0, ss$148, sctl$148, whole_instances$148, ncd$148, ftable$148 , sctl$148.node_scene$ , spawn_obj$);
 } else {
  ::demoapp$n::step_snobj$f148(speed$148$demoapp$ns0, sctl$148, sn_work$148$demoapp$ns0, spawn_now$148$demoapp$ns0, whole_instances$148, ncd$148, ftable$148 , sctl$148.node_scene$);
 }
 sctl$148.motion_count$ += speed$148$demoapp$ns0;
 if (sctl$148.motion_count$ >= pxcrt::bt_float(360.0)) {
  sctl$148.motion_count$ -= pxcrt::bt_float(360.0);
 }
}
}; /* namespace demoapp */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_char$f$p$42$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_long >(v$ , 42LL);
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_parse_token$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$text$$string$$serialize$n$$str_decode$f83$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 const pxcrt::bt_size_t toklen$ = ::text$n::string$n::serialize$n::token_length$f(s$);
 ::pxcrt::bt_cslice< pxcrt::bt_uchar > stok$ = ::pxcrt::bt_cslice< pxcrt::bt_uchar >(s$, pxcrt::bt_size_t((0LL)), toklen$);
 s$.increment_front(toklen$);
 return ::text$n::string$n::serialize$n::str_decode$f83(stok$);
}
static inline pxcrt::bt_bool string_parse_token$f$p$meta$n$$bool$t$q$text$$string$$serialize$n$$parse_bool$f87$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 const pxcrt::bt_size_t toklen$ = ::text$n::string$n::serialize$n::token_length$f(s$);
 ::pxcrt::bt_cslice< pxcrt::bt_uchar > stok$ = ::pxcrt::bt_cslice< pxcrt::bt_uchar >(s$, pxcrt::bt_size_t((0LL)), toklen$);
 s$.increment_front(toklen$);
 return ::text$n::string$n::serialize$n::parse_bool$f87(stok$);
}
};};}; /* namespace text::string::serialize */
namespace exception$n { 
unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$::unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > unexpected_value_template$s$p$io$$errno$n$$errno_t$s$r$::message() const {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("unexpected_value{errno_t}("));
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
 return s$;
}
}; /* namespace exception */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > to_string$f$p$io$$errno$n$$errno_t$s$r$(const int& x$) {
 /* staticif empty *//* staticif-else */
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 ::text$n::string$n::serialize$n::serialize_to_string$f$p$io$$errno$n$$errno_t$s$r$(x$ , s$);
 return s$;
 /* staticif-else end */
}
static inline void serialize_to_string$f$p$io$$errno$n$$errno_t$s$r$(const int& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
 ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$io$$errno$n$$errno_t$s$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$io$$errno$n$$errno_t$s$r$(const int& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
 /* staticif */
 ::io$n::errno$n::errno_t_append_to_string$f(x$ , o$);
 /* staticif end */
}
};}; /* namespace text::serialize */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_double static_cast$f$p$meta$n$$double$t$q$io$$time$n$$time_t$s$r$(const std::time_t& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_double,std::time_t > c$ = numeric::static_cast_impl< pxcrt::bt_double,std::time_t >();
 return c$.convert(x$);
 /* staticif end */
}
static inline pxcrt::bt_double static_cast$f$p$meta$n$$double$t$q$io$$time$n$$suseconds_t$s$r$(const pxcrt::suseconds_t& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_double,pxcrt::suseconds_t > c$ = numeric::static_cast_impl< pxcrt::bt_double,pxcrt::suseconds_t >();
 return c$.convert(x$);
 /* staticif end */
}
};}; /* namespace numeric::cast */
namespace io$n { namespace errno$n { 
void errno_or_value$v$p$io$$file$n$$file_st$s$r$::init$(const errno_or_value$v$p$io$$file$n$$file_st$s$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: new(value$$p()) pxcrt::file_st(*(x.value$$p())); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$io$$file$n$$file_st$s$r$::deinit$() {
 typedef int io$$errno$n$$errno_t$s$dtor;
 typedef pxcrt::file_st io$$file$n$$file_st$s$dtor;
 switch (get_$e()) {
 case errno$$e: /* pod */; break;
 case value$$e: value$$p()->~io$$file$n$$file_st$s$dtor(); break;
 }
};
int errno_or_value$v$p$io$$file$n$$file_st$s$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
pxcrt::file_st errno_or_value$v$p$io$$file$n$$file_st$s$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$io$$file$n$$file_st$s$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
pxcrt::file_st errno_or_value$v$p$io$$file$n$$file_st$s$r$::value$$l(pxcrt::file_st x) {
 { deinit$(); _$e = errno$$e; new(value$$p()) pxcrt::file_st(x); _$e = value$$e; }
 return (*value$$p());
}
void errno_or_value$v$p$io$$file$n$$file_mt$s$r$::init$(const errno_or_value$v$p$io$$file$n$$file_mt$s$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: new(value$$p()) pxcrt::file_mt(*(x.value$$p())); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$io$$file$n$$file_mt$s$r$::deinit$() {
 typedef int io$$errno$n$$errno_t$s$dtor;
 typedef pxcrt::file_mt io$$file$n$$file_mt$s$dtor;
 switch (get_$e()) {
 case errno$$e: /* pod */; break;
 case value$$e: value$$p()->~io$$file$n$$file_mt$s$dtor(); break;
 }
};
int errno_or_value$v$p$io$$file$n$$file_mt$s$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
pxcrt::file_mt errno_or_value$v$p$io$$file$n$$file_mt$s$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$io$$file$n$$file_mt$s$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
pxcrt::file_mt errno_or_value$v$p$io$$file$n$$file_mt$s$r$::value$$l(pxcrt::file_mt x) {
 { deinit$(); _$e = errno$$e; new(value$$p()) pxcrt::file_mt(x); _$e = value$$e; }
 return (*value$$p());
}
void errno_or_value$v$p$meta$n$$size_t$t$r$::init$(const errno_or_value$v$p$meta$n$$size_t$t$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: *(value$$p()) = *(x.value$$p()); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$meta$n$$size_t$t$r$::deinit$() {
};
int errno_or_value$v$p$meta$n$$size_t$t$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
pxcrt::bt_size_t errno_or_value$v$p$meta$n$$size_t$t$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$meta$n$$size_t$t$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
pxcrt::bt_size_t errno_or_value$v$p$meta$n$$size_t$t$r$::value$$l(pxcrt::bt_size_t x) {
 { deinit$(); _$e = errno$$e; *(value$$p()) = x; _$e = value$$e; }
 return (*value$$p());
}
void errno_or_value$v$p$io$$file$n$$off_t$s$r$::init$(const errno_or_value$v$p$io$$file$n$$off_t$s$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: *(value$$p()) = *(x.value$$p()); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$io$$file$n$$off_t$s$r$::deinit$() {
};
int errno_or_value$v$p$io$$file$n$$off_t$s$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
pxcrt::off_t errno_or_value$v$p$io$$file$n$$off_t$s$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$io$$file$n$$off_t$s$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
pxcrt::off_t errno_or_value$v$p$io$$file$n$$off_t$s$r$::value$$l(pxcrt::off_t x) {
 { deinit$(); _$e = errno$$e; *(value$$p()) = x; _$e = value$$e; }
 return (*value$$p());
}
};}; /* namespace io::errno */
namespace operator$n { 
static inline pxcrt::bt_size_t union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$meta$n$$size_t$t$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$& x$) {
 if (!(x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$::value$$e)) {
  {
   if ((x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$meta$n$$size_t$t$r$::errno$$e)) {
    PXC_THROW(::exception$n::unexpected_value_template$s$p$errno__t$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(int((x$.errno$$r())))).get_crange())));
   }
  }
  /* staticif empty */
 }
 return (x$.value$$r());
}
}; /* namespace operator */
namespace exception$n { 
unexpected_value_template$s$p$errno__t$ls$r$::unexpected_value_template$s$p$errno__t$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > unexpected_value_template$s$p$errno__t$ls$r$::message() const {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("unexpected_value{errno_t}("));
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
 return s$;
}
}; /* namespace exception */
namespace io$n { namespace errno$n { 
void errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$::init$(const errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: new(value$$p()) pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > >(*(x.value$$p())); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$::deinit$() {
 typedef int io$$errno$n$$errno_t$s$dtor;
 typedef pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$dtor;
 switch (get_$e()) {
 case errno$$e: /* pod */; break;
 case value$$e: value$$p()->~pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$dtor(); break;
 }
};
int errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$::value$$l(pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > x) {
 { deinit$(); _$e = errno$$e; new(value$$p()) pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > >(x); _$e = value$$e; }
 return (*value$$p());
}
};}; /* namespace io::errno */
namespace io$n { namespace file$n { 
static inline ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ io_open$f$p$m$ll$p$m$ll$p$io$n$$io$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$io$$file$n$$open_flags_t$s$q$0$li$r$$r$$r$(const pxcrt::io& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const int& a2$) {
 int flags$ = O_RDONLY;
 pxcrt::mode_t  md$ = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
 {
  /* staticif */
  flags$ = a2$;
  /* staticif end */
 }
 /* staticif empty */
 /* staticif empty */
 return ::io$n::file$n::io_open_st$f(a0$ , a1$ , flags$ , md$);
}
};}; /* namespace io::file */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > make_ptr$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$m$ll$r$() {
 return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > box_pointer$f$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$() {
 /* staticif empty *//* staticif-else */
 pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >*const r$p1 = pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::allocate();
 try {
 new (&r$p1->value) ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
 } catch (...) {
 pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::deallocate(r$p1);
 throw;
 }
 pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > r$((r$p1));
 return r$;
 /* staticif-else end */
}
}; /* namespace pointer */
namespace operator$n { 
static inline pxcrt::file_st union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$io$$file$n$$file_st$s$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$& x$) {
 if (!(x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$::value$$e)) {
  {
   if ((x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$::errno$$e)) {
    PXC_THROW(::exception$n::unexpected_value_template$s$p$errno__t$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(int((x$.errno$$r())))).get_crange())));
   }
  }
  /* staticif empty */
 }
 return (x$.value$$r());
}
}; /* namespace operator */
namespace io$n { namespace file$n { 
static inline ::io$n::errno$n::errno_or_value$v$p$io$$file$n$$file_st$s$r$ io_open$f$p$m$ll$p$m$ll$p$io$n$$io$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$io$$file$n$$open_flags_t$s$q$0$li$r$$q$m$ll$p$io$$file$n$$mode_t$s$q$0$li$r$$r$$r$(const pxcrt::io& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const int& a2$, const pxcrt::mode_t & a3$) {
 int flags$ = O_RDONLY;
 pxcrt::mode_t  md$ = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
 {
  /* staticif */
  flags$ = a2$;
  /* staticif end */
 }
 {
  md$ = a3$;
 }
 /* staticif empty */
 return ::io$n::file$n::io_open_st$f(a0$ , a1$ , flags$ , md$);
}
};}; /* namespace io::file */
namespace algebraic$n { 
pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$(const pxcrt::file_mt& a0$, const pxcrt::file_mt& a1$) : first$(a0$), second$(a1$) {
}
}; /* namespace algebraic */
namespace io$n { namespace errno$n { 
void errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::init$(const errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: new(value$$p()) ::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$(*(x.value$$p())); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::deinit$() {
 typedef int io$$errno$n$$errno_t$s$dtor;
 typedef ::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$dtor;
 switch (get_$e()) {
 case errno$$e: /* pod */; break;
 case value$$e: value$$p()->~algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$dtor(); break;
 }
};
int errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::value$$l(::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ x) {
 { deinit$(); _$e = errno$$e; new(value$$p()) ::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$(x); _$e = value$$e; }
 return (*value$$p());
}
};}; /* namespace io::errno */
namespace algebraic$n { 
void option$v$p$io$$file$n$$file_st$s$r$::init$(const option$v$p$io$$file$n$$file_st$s$r$ & x) {
 _$e = none$$e;
 switch (x.get_$e()) {
 case none$$e: /* unit */; break;
 case some$$e: new(some$$p()) pxcrt::file_st(*(x.some$$p())); break;
 }
 _$e = x._$e;
};
void option$v$p$io$$file$n$$file_st$s$r$::deinit$() {
 typedef pxcrt::bt_unit meta$n$$unit$t$dtor;
 typedef pxcrt::file_st io$$file$n$$file_st$s$dtor;
 switch (get_$e()) {
 case none$$e: /* unit */; break;
 case some$$e: some$$p()->~io$$file$n$$file_st$s$dtor(); break;
 }
};
pxcrt::bt_unit option$v$p$io$$file$n$$file_st$s$r$::none$$r() const {
 if (get_$e() != none$$e) { pxcrt::throw_invalid_field(); }
 return pxcrt::unit_value;
}
pxcrt::file_st option$v$p$io$$file$n$$file_st$s$r$::some$$r() const {
 if (get_$e() != some$$e) { pxcrt::throw_invalid_field(); }
 return *some$$p();
}
pxcrt::bt_unit option$v$p$io$$file$n$$file_st$s$r$::none$$l(pxcrt::bt_unit x) {
 { deinit$(); _$e = none$$e; /* unit */; _$e = none$$e; }
 return pxcrt::unit_value;
}
pxcrt::file_st option$v$p$io$$file$n$$file_st$s$r$::some$$l(pxcrt::file_st x) {
 { deinit$(); _$e = none$$e; new(some$$p()) pxcrt::file_st(x); _$e = some$$e; }
 return (*some$$p());
}
}; /* namespace algebraic */
namespace io$n { namespace errno$n { 
void errno_or_value$v$p$io$$process$n$$pid_t$s$r$::init$(const errno_or_value$v$p$io$$process$n$$pid_t$s$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: *(value$$p()) = *(x.value$$p()); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$io$$process$n$$pid_t$s$r$::deinit$() {
};
int errno_or_value$v$p$io$$process$n$$pid_t$s$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
pxcrt::pid_t errno_or_value$v$p$io$$process$n$$pid_t$s$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$io$$process$n$$pid_t$s$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
pxcrt::pid_t errno_or_value$v$p$io$$process$n$$pid_t$s$r$::value$$l(pxcrt::pid_t x) {
 { deinit$(); _$e = errno$$e; *(value$$p()) = x; _$e = value$$e; }
 return (*value$$p());
}
void errno_or_value$v$p$io$$process$n$$pipe_process$s$r$::init$(const errno_or_value$v$p$io$$process$n$$pipe_process$s$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: new(value$$p()) ::io$n::process$n::pipe_process$s(*(x.value$$p())); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$io$$process$n$$pipe_process$s$r$::deinit$() {
 typedef int io$$errno$n$$errno_t$s$dtor;
 typedef ::io$n::process$n::pipe_process$s io$$process$n$$pipe_process$s$dtor;
 switch (get_$e()) {
 case errno$$e: /* pod */; break;
 case value$$e: value$$p()->~io$$process$n$$pipe_process$s$dtor(); break;
 }
};
int errno_or_value$v$p$io$$process$n$$pipe_process$s$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
::io$n::process$n::pipe_process$s errno_or_value$v$p$io$$process$n$$pipe_process$s$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$io$$process$n$$pipe_process$s$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
::io$n::process$n::pipe_process$s errno_or_value$v$p$io$$process$n$$pipe_process$s$r$::value$$l(::io$n::process$n::pipe_process$s x) {
 { deinit$(); _$e = errno$$e; new(value$$p()) ::io$n::process$n::pipe_process$s(x); _$e = value$$e; }
 return (*value$$p());
}
};}; /* namespace io::errno */
namespace operator$n { 
static inline pxcrt::pid_t union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$io$$process$n$$pid_t$s$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$& x$) {
 if (!(x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$::value$$e)) {
  {
   if ((x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$io$$process$n$$pid_t$s$r$::errno$$e)) {
    PXC_THROW(::exception$n::unexpected_value_template$s$p$errno__t$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(int((x$.errno$$r())))).get_crange())));
   }
  }
  /* staticif empty */
 }
 return (x$.value$$r());
}
static inline ::algebraic$n::pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$ union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$& x$) {
 if (!(x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::value$$e)) {
  {
   if ((x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$algebraic$n$$pair$s$p$io$$file$n$$file_mt$s$q$io$$file$n$$file_mt$s$r$$r$::errno$$e)) {
    PXC_THROW(::exception$n::unexpected_value_template$s$p$errno__t$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(int((x$.errno$$r())))).get_crange())));
   }
  }
  /* staticif empty */
 }
 return (x$.value$$r());
}
}; /* namespace operator */
namespace io$n { namespace errno$n { 
void errno_or_value$v$p$io$$process$n$$wait_t$s$r$::init$(const errno_or_value$v$p$io$$process$n$$wait_t$s$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: new(value$$p()) ::io$n::process$n::wait_t$s(*(x.value$$p())); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$io$$process$n$$wait_t$s$r$::deinit$() {
 typedef int io$$errno$n$$errno_t$s$dtor;
 typedef ::io$n::process$n::wait_t$s io$$process$n$$wait_t$s$dtor;
 switch (get_$e()) {
 case errno$$e: /* pod */; break;
 case value$$e: value$$p()->~io$$process$n$$wait_t$s$dtor(); break;
 }
};
int errno_or_value$v$p$io$$process$n$$wait_t$s$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
::io$n::process$n::wait_t$s errno_or_value$v$p$io$$process$n$$wait_t$s$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$io$$process$n$$wait_t$s$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
::io$n::process$n::wait_t$s errno_or_value$v$p$io$$process$n$$wait_t$s$r$::value$$l(::io$n::process$n::wait_t$s x) {
 { deinit$(); _$e = errno$$e; new(value$$p()) ::io$n::process$n::wait_t$s(x); _$e = value$$e; }
 return (*value$$p());
}
void errno_or_value$v$p$io$$process$n$$status_t$s$r$::init$(const errno_or_value$v$p$io$$process$n$$status_t$s$r$ & x) {
 _$e = errno$$e;
 switch (x.get_$e()) {
 case errno$$e: *(errno$$p()) = *(x.errno$$p()); break;
 case value$$e: *(value$$p()) = *(x.value$$p()); break;
 }
 _$e = x._$e;
};
void errno_or_value$v$p$io$$process$n$$status_t$s$r$::deinit$() {
};
int errno_or_value$v$p$io$$process$n$$status_t$s$r$::errno$$r() const {
 if (get_$e() != errno$$e) { pxcrt::throw_invalid_field(); }
 return *errno$$p();
}
int errno_or_value$v$p$io$$process$n$$status_t$s$r$::value$$r() const {
 if (get_$e() != value$$e) { pxcrt::throw_invalid_field(); }
 return *value$$p();
}
int errno_or_value$v$p$io$$process$n$$status_t$s$r$::errno$$l(int x) {
 { deinit$(); _$e = errno$$e; *(errno$$p()) = x; _$e = errno$$e; }
 return (*errno$$p());
}
int errno_or_value$v$p$io$$process$n$$status_t$s$r$::value$$l(int x) {
 { deinit$(); _$e = errno$$e; *(value$$p()) = x; _$e = value$$e; }
 return (*value$$p());
}
};}; /* namespace io::errno */
namespace numeric$n { namespace cast$n { 
static inline int static_cast$f$p$io$$process$n$$status_t$s$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$) {
 /* staticif */
 numeric::static_cast_impl< int,pxcrt::bt_int > c$ = numeric::static_cast_impl< int,pxcrt::bt_int >();
 return c$.convert(x$);
 /* staticif end */
}
};}; /* namespace numeric::cast */
namespace callable$n { 
tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$(const pxcrt::rcptr< ::callable$n::tcallable$i$p$meta$n$$void$t$q$m$ll$r$ >& p0$) : p$(p0$) {
}
inline void tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$::__call$f() const {
 return ((*((pxcrt::rcptr< ::callable$n::tcallable$i$p$meta$n$$void$t$q$m$ll$r$ >::guard_val< const pxcrt::rcptr< ::callable$n::tcallable$i$p$meta$n$$void$t$q$m$ll$r$ > > (p$).get())))).__call$f();
}
callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$(const pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$r$ >& p0$) : p$(p0$) {
}
inline void callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$::__call$f() const {
 return ((*(pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$r$ >(p$)))).__call$f();
}
}; /* namespace callable */
namespace thread$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ make_thread_ptr$f$p$thread$$queue$n$$queue_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$) {
 return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$(::pointer$n::make_ptr$f$p$thread$n$$thread$s$p$thread$$queue$n$$queue_thread_main$f$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$0$li$r$$r$$r$(tq$));
}
thread$s$p$thread$$queue$n$$queue_thread_main$f$r$::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$) : count$z(1), fobj$(tq$), need_join$(false), thd$() {
 init$f();
}
inline void thread$s$p$thread$$queue$n$$queue_thread_main$f$r$::init$f() {
 const int err$ = pxcrt::thread_create< ::thread$n::thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$ >(thd$ , fobj$);
 if (err$ != 0) {
  PXC_THROW(::exception$n::runtime_error_template$s$p$thread__create$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(err$)).get_crange())));
 }
 need_join$ = true;
}
inline thread$s$p$thread$$queue$n$$queue_thread_main$f$r$::~thread$s$p$thread$$queue$n$$queue_thread_main$f$r$() PXC_NOTHROW {
 try {
  __call$f();
 } catch (...) { ::abort(); }
}
inline void thread$s$p$thread$$queue$n$$queue_thread_main$f$r$::__call$f() {
 if (need_join$) {
  need_join$ = false;
  const int err$ = pxcrt::thread_join< ::thread$n::thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$ >(thd$);
  if (err$ != 0) {
   PXC_THROW(::exception$n::runtime_error_template$s$p$thread__join$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(err$)).get_crange())));
  }
 }
 /* staticif empty */
}
thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$::thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& tq$) : fld$(tq$), ret$() {
}
inline void thread_main_funcobj$s$p$thread$$queue$n$$queue_thread_main$f$r$::__call$f() {
 /* staticif */
 ::thread$n::queue$n::queue_thread_main$f(fld$._0$);
 /* staticif end */
}
}; /* namespace thread */
namespace operator$n { 
tuple$s$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$r$$q$m$ll$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& a0$) : _0$(a0$) {
}
}; /* namespace operator */
namespace exception$n { 
runtime_error_template$s$p$thread__create$ls$r$::runtime_error_template$s$p$thread__create$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$thread__create$ls$r$::message() const {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{thread_create}("));
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
 return s$;
}
runtime_error_template$s$p$thread__join$ls$r$::runtime_error_template$s$p$thread__join$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$thread__join$ls$r$::message() const {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{thread_join}("));
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
 return s$;
}
}; /* namespace exception */
namespace pointer$n { 
static inline pxcrt::rcptr< ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ > make_ptr$f$p$thread$n$$thread$s$p$thread$$queue$n$$queue_thread_main$f$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& a0$) {
 return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$thread$n$$thread$s$p$thread$$queue$n$$queue_thread_main$f$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ > box_pointer$f$p$pxcrt$$ptr$p$thread$n$$thread$s$p$thread$$queue$n$$queue_thread_main$f$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > >& a0$) {
 /* staticif empty *//* staticif-else */
 ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$*const r$p1 = ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$::allocate();
 try {
 new (r$p1) ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$(a0$);
 } catch (...) {
 ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$::deallocate(r$p1);
 throw;
 }
 pxcrt::rcptr< ::thread$n::thread$s$p$thread$$queue$n$$queue_thread_main$f$r$ > r$((r$p1));
 return r$;
 /* staticif-else end */
}
static inline pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > make_tptr$f$p$thread$$queue$n$$task_queue_shared$s$q$m$ll$r$() {
 return ::pointer$n::box_pointer$f$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > box_pointer$f$p$pxcrt$$tptr$p$thread$$queue$n$$task_queue_shared$s$r$$q$m$ll$r$() {
 /* staticif empty *//* staticif-else */
 pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s >*const r$p1 = pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s >::allocate();
 try {
 new (&r$p1->value) ::thread$n::queue$n::task_queue_shared$s();
 new (&r$p1->count$z) pxcrt::mtcount(); /* nothrow */
 try {
 new (&r$p1->monitor$z) pxcrt::monitor();
 } catch (...) {
 typedef ::thread$n::queue$n::task_queue_shared$s thread$$queue$n$$task_queue_shared$s$dtor;
 r$p1->value.~thread$$queue$n$$task_queue_shared$s$dtor();
 throw;
 }
 } catch (...) {
 pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s >::deallocate(r$p1);
 throw;
 }
 pxcrt::rcptr< pxcrt::trcval< ::thread$n::queue$n::task_queue_shared$s > > r$((r$p1));
 return r$;
 /* staticif-else end */
}
}; /* namespace pointer */
namespace algebraic$n { 
void option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::init$(const option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$ & x) {
 _$e = none$$e;
 switch (x.get_$e()) {
 case none$$e: /* unit */; break;
 case some$$e: new(some$$p()) ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$(*(x.some$$p())); break;
 }
 _$e = x._$e;
};
void option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::deinit$() {
 typedef pxcrt::bt_unit meta$n$$unit$t$dtor;
 typedef ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$dtor;
 switch (get_$e()) {
 case none$$e: /* unit */; break;
 case some$$e: some$$p()->~callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$dtor(); break;
 }
};
pxcrt::bt_unit option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::none$$r() const {
 if (get_$e() != none$$e) { pxcrt::throw_invalid_field(); }
 return pxcrt::unit_value;
}
::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::some$$r() const {
 if (get_$e() != some$$e) { pxcrt::throw_invalid_field(); }
 return *some$$p();
}
pxcrt::bt_unit option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::none$$l(pxcrt::bt_unit x) {
 { deinit$(); _$e = none$$e; /* unit */; _$e = none$$e; }
 return pxcrt::unit_value;
}
::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::some$$l(::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ x) {
 { deinit$(); _$e = none$$e; new(some$$p()) ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$(x); _$e = some$$e; }
 return (*some$$p());
}
}; /* namespace algebraic */
namespace operator$n { 
static inline ::callable$n::tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ union_field$f$p$some$ls$q$algebraic$n$$option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$$r$(const ::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$& x$) {
 if (!(x$.get_$e() == ::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::some$$e)) {
  {
   if ((x$.get_$e() == ::algebraic$n::option$v$p$callable$n$$tcallable_ptr$s$p$meta$n$$void$t$q$m$ll$r$$r$::none$$e)) {
    PXC_THROW(::exception$n::unexpected_value_template$s$p$unit$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$meta$n$$unit$t$r$(pxcrt::bt_unit((x$.none$$r())))).get_crange())));
   }
  }
  /* staticif empty */
 }
 return (x$.some$$r());
}
}; /* namespace operator */
namespace exception$n { 
unexpected_value_template$s$p$unit$ls$r$::unexpected_value_template$s$p$unit$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > unexpected_value_template$s$p$unit$ls$r$::message() const {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("unexpected_value{unit}("));
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
 return s$;
}
}; /* namespace exception */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > to_string$f$p$meta$n$$unit$t$r$(const pxcrt::bt_unit& x$) {
 /* staticif empty *//* staticif-else */
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$unit$t$r$(x$ , s$);
 return s$;
 /* staticif-else end */
}
static inline void serialize_to_string$f$p$meta$n$$unit$t$r$(const pxcrt::bt_unit& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
 ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$unit$t$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$unit$t$r$(const pxcrt::bt_unit& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
 /* staticif */
 ::text$n::string$n::serialize$n::unit_to_string$f(x$ , o$);
 /* staticif end */
}
};}; /* namespace text::serialize */
namespace container$n { namespace tree_map$n { 
cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(){
}
inline pxcrt::bt_int cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$::call$f(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) const {
 return ::ordered$n::compare_strict_weak$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(x$ , y$);
}
};}; /* namespace container::tree_map */
namespace ordered$n { 
static inline pxcrt::bt_int compare_strict_weak$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) {
 /* staticif */
 return ::pxcrt::pod_array_compare< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(x$ , y$);
 /* staticif end */
}
}; /* namespace ordered */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_size_t,pxcrt::bt_int > c$ = numeric::static_cast_impl< pxcrt::bt_size_t,pxcrt::bt_int >();
 return c$.convert(x$);
 /* staticif end */
}
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline pxcrt::rawptr< pxcrt::bt_uchar >::type add$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$r$(const pxcrt::rawptr< pxcrt::bt_uchar >::type& x$, const pxcrt::bt_size_t& y$) {
 /* staticif empty *//* staticif-else */
 return ::operator$n::binop$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline pxcrt::rawptr< pxcrt::bt_uchar >::type binop$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(const pxcrt::rawptr< pxcrt::bt_uchar >::type& x$, const pxcrt::bt_size_t& y$) {
 /* staticif */
 return pxcrt::rawptr_add< pxcrt::rawptr< pxcrt::bt_uchar >::type,pxcrt::bt_size_t >(x$ , y$);
 /* staticif end */
}
}; /* namespace operator */
namespace SDL2$n { namespace api_base$n { 
static inline pxcrt::bt_int SDL_Enum___to$f$p$meta$n$$int$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(int x$) {
 return ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(x$);
}
};}; /* namespace SDL2::api_base */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(const int& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_int,int > c$ = numeric::static_cast_impl< pxcrt::bt_int,int >();
 return c$.convert(x$);
 /* staticif end */
}
};}; /* namespace numeric::cast */
namespace ordered$n { 
static inline pxcrt::bt_size_t min$f$p$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$, const pxcrt::bt_size_t& y$) {
 return x$ < y$ ? x$ : y$;
}
}; /* namespace ordered */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$) {
 const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(a0$ , a1$);
 ::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$) {
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 {
  /* staticif empty */
  {
   ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
  }
 }
 {
  {
   ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
  }
  /* staticif empty */{
   ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a1$ , s$);
  }
 }
 return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
 ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$size_t$t$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
 /* staticif */
 ::text$n::string$n::positional$n::integral_to_positional$f$p$meta$n$$size_t$t$q$10$li$r$(x$ , o$);
 /* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$size_t$t$q$10$li$r$(pxcrt::bt_size_t v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
 /* staticif empty */
 if (v$ == pxcrt::bt_size_t((0LL))) {
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 48U);
  return;
 }
 pxcrt::bt_size_t pos0$ = buf$.size();
 if (v$ < pxcrt::bt_size_t((0LL))) {
  ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 45U);
  pos0$ += pxcrt::bt_size_t(1LL);
  while (v$ != pxcrt::bt_size_t((0LL))) {
   pxcrt::bt_size_t rem$ = v$ % pxcrt::bt_size_t(10LL);
   v$ /= pxcrt::bt_size_t(10LL);
   {
    ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$size_t$t$r$(-rem$) + 48U);
   }
  }
 } else {
  while (v$ != pxcrt::bt_size_t((0LL))) {
   pxcrt::bt_size_t rem$ = v$ % pxcrt::bt_size_t(10LL);
   v$ /= pxcrt::bt_size_t(10LL);
   {
    ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$size_t$t$r$(rem$) + 48U);
   }
  }
 }
 ::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::bt_slice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (buf$).get()), pos0$, buf$.size()));
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_size_t > c$ = numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_size_t >();
 return c$.convert(x$);
 /* staticif end */
}
};}; /* namespace numeric::cast */
namespace container$n { namespace array$n { 
static inline void reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_slice< pxcrt::bt_uchar >& x$) {
 pxcrt::bt_size_t s$ = pxcrt::bt_size_t((0LL));
 pxcrt::bt_size_t f$ = x$.size();
 while (s$ < f$) {
  --f$;
  pxcrt::bt_uchar v$ = (x$.begin()[s$]);
  (x$.begin()[s$]) = (x$.begin()[f$]);
  (x$.begin()[f$]) = v$;
  ++s$;
 }
}
};}; /* namespace container::array */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_size_t > c$ = numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_size_t >();
 return c$.convert(x$);
 /* staticif end */
}
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_uint,pxcrt::bt_size_t > c$ = numeric::static_cast_impl< pxcrt::bt_uint,pxcrt::bt_size_t >();
 return c$.convert(x$);
 /* staticif end */
}
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > make_ptr$f$p$pgl3d$$wfobj$n$$wfobject$s$q$m$ll$r$() {
 return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$wfobj$n$$wfobject$s$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$wfobj$n$$wfobject$s$r$$q$m$ll$r$() {
 /* staticif empty *//* staticif-else */
 pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s >::allocate();
 try {
 new (&r$p1->value) ::pgl3d$n::wfobj$n::wfobject$s();
 new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
 } catch (...) {
 pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s >::deallocate(r$p1);
 throw;
 }
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > r$((r$p1));
 return r$;
 /* staticif-else end */
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > make_ptr$f$p$pgl3d$$wfobj$n$$wfgroup$s$q$m$ll$r$() {
 return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$wfobj$n$$wfgroup$s$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$wfobj$n$$wfgroup$s$r$$q$m$ll$r$() {
 /* staticif empty *//* staticif-else */
 pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s >::allocate();
 try {
 new (&r$p1->value) ::pgl3d$n::wfobj$n::wfgroup$s();
 new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
 } catch (...) {
 pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s >::deallocate(r$p1);
 throw;
 }
 pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > r$((r$p1));
 return r$;
 /* staticif-else end */
}
}; /* namespace pointer */
namespace container$n { namespace array$n { 
static inline void split_foreach$f$p$pgl3d$$wfobj$n$$parse_line$f4$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfobject$s > > const& _0$up, ::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& _1$up, pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::wfobj$n::wfgroup$s > > const& _2$up, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$) {
 pxcrt::bt_size_t p$ = pxcrt::bt_size_t();
 while (true) {
  const pxcrt::bt_size_t pend$ = ::container$n::array$n::find_mapped$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(c$ , p$ , v$);
  ::pgl3d$n::wfobj$n::parse_line$f4(_0$up, _1$up, _2$up , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(c$, p$, pend$));
  if (pend$ == c$.size()) {
   break;
  }
  p$ = pend$ + pxcrt::bt_size_t(1LL);
 }
}
static inline pxcrt::bt_size_t find_mapped$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, pxcrt::bt_size_t k$, const pxcrt::bt_uchar& x$) {
 /* staticif */
 return ::pxcrt::find_mapped_memchr< ::pxcrt::bt_cslice< pxcrt::bt_uchar > >(c$ , k$ , x$);
 /* staticif end */
}
static inline ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,3LL > make_farray_split$f$p$3$li$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$) {
 ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,3LL > arr$ = ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,3LL >();
 pxcrt::bt_size_t p$ = pxcrt::bt_size_t();
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < pxcrt::bt_size_t(3LL); ++i$) {
  const pxcrt::bt_size_t pend$ = ::container$n::array$n::find_mapped$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(c$ , p$ , v$);
  (arr$.begin()[i$]) = ::pxcrt::bt_cslice< pxcrt::bt_uchar >(c$, p$, pend$);
  if (pend$ == c$.size()) {
   break;
  }
  p$ = pend$ + pxcrt::bt_size_t(1LL);
 }
 return arr$;
}
};}; /* namespace container::array */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_float from_string$f$p$meta$n$$float$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 /* staticif empty *//* staticif-else */
 ::pxcrt::bt_cslice< pxcrt::bt_uchar > s1$ = s$;
 return ::text$n::string$n::serialize$n::deserialize_from_string$f$p$meta$n$$float$t$r$(s1$);
 /* staticif-else end */
}
static inline pxcrt::bt_float deserialize_from_string$f$p$meta$n$$float$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 return ::text$n::serialize$n::deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(s$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline pxcrt::bt_float deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$) {
 /* staticif empty *//* staticif-else */
 /* staticif */
 /* staticif */
 return ::text$n::string$n::serialize$n::string_parse_token$f$p$meta$n$$float$t$q$text$$string$$positional$n$$decimal_to_fp$f$p$meta$n$$float$t$r$$r$(src$);
 /* staticif end */
 /* staticif end */
 /* staticif-else end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_float decimal_to_fp$f$p$meta$n$$float$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
 return text::decimal_to_fp_float(buf$);
}
};};}; /* namespace text::string::positional */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_float string_parse_token$f$p$meta$n$$float$t$q$text$$string$$positional$n$$decimal_to_fp$f$p$meta$n$$float$t$r$$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 const pxcrt::bt_size_t toklen$ = ::text$n::string$n::serialize$n::token_length$f(s$);
 ::pxcrt::bt_cslice< pxcrt::bt_uchar > stok$ = ::pxcrt::bt_cslice< pxcrt::bt_uchar >(s$, pxcrt::bt_size_t((0LL)), toklen$);
 s$.increment_front(toklen$);
 return ::text$n::string$n::positional$n::decimal_to_fp$f$p$meta$n$$float$t$r$(stok$);
}
static inline pxcrt::bt_uint from_string$f$p$meta$n$$uint$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 /* staticif empty *//* staticif-else */
 ::pxcrt::bt_cslice< pxcrt::bt_uchar > s1$ = s$;
 return ::text$n::string$n::serialize$n::deserialize_from_string$f$p$meta$n$$uint$t$r$(s1$);
 /* staticif-else end */
}
static inline pxcrt::bt_uint deserialize_from_string$f$p$meta$n$$uint$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 return ::text$n::serialize$n::deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uint$t$r$(s$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline pxcrt::bt_uint deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uint$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$) {
 /* staticif empty *//* staticif-else */
 /* staticif */
 /* staticif */
 return ::text$n::string$n::serialize$n::string_parse_token$f$p$meta$n$$uint$t$q$text$$string$$positional$n$$positional_to_integral$f$p$meta$n$$uint$t$q$10$li$r$$r$(src$);
 /* staticif end */
 /* staticif end */
 /* staticif-else end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_uint positional_to_integral$f$p$meta$n$$uint$t$q$10$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
 /* staticif empty */
 if (buf$.size() == pxcrt::bt_size_t((0LL))) {
  return pxcrt::bt_uint();
 }
 const pxcrt::bt_uchar ch$ = buf$[pxcrt::bt_size_t((0LL))];
 if (ch$ == 45U) {
  buf$.increment_front(pxcrt::bt_size_t(1LL));
  return ::text$n::string$n::positional$n::positional_to_integral_internal$f$p$meta$n$$uint$t$q$10$li$q$1$li$r$(buf$);
 } else if (ch$ == 43U) {
  buf$.increment_front(pxcrt::bt_size_t(1LL));
  return ::text$n::string$n::positional$n::positional_to_integral_internal$f$p$meta$n$$uint$t$q$10$li$q$0$li$r$(buf$);
 } else {
  return ::text$n::string$n::positional$n::positional_to_integral_internal$f$p$meta$n$$uint$t$q$10$li$q$0$li$r$(buf$);
 }
}
static inline pxcrt::bt_uint positional_to_integral_internal$f$p$meta$n$$uint$t$q$10$li$q$1$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
 pxcrt::bt_uint r$ = pxcrt::bt_uint();
 {
  const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& ag$fe = (buf$);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::bt_uchar *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t idx$ = 0; idx$ != sz$fe; ++idx$) {
   pxcrt::bt_uchar v$ = ar$fe[idx$];
   {
    pxcrt::bt_uint dig$ = pxcrt::bt_uint();
    if (::text$n::string$n::positional$n::uchar_to_integral$f$p$meta$n$$uint$t$q$10$li$r$(v$ , dig$)) {
     {
      if (r$ < (::numeric$n::limit$n::lowest$f$p$meta$n$$uint$t$r$() / pxcrt::bt_uint(10LL))) {
       buf$.increment_front(idx$);
       return r$;
      }
     }
     r$ *= pxcrt::bt_uint(10LL);
     {
      const pxcrt::bt_uint nr$ = r$ - dig$;
      if (nr$ > r$) {
       buf$.increment_front(idx$);
       return r$;
      }
      r$ = nr$;
     }
    } else {
     buf$.increment_front(idx$);
     return r$;
    }
   }
  }
 }
 buf$.increment_front(buf$.size());
 return r$;
}
static inline pxcrt::bt_bool uchar_to_integral$f$p$meta$n$$uint$t$q$10$li$r$(pxcrt::bt_uchar v$, pxcrt::bt_uint& dig_r$) {
 if (v$ >= 48U && v$ <= pxcrt::bt_uchar(67LL)) {
  dig_r$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$uchar$t$r$(v$ - 48U);
  return true;
 }
 /* staticif empty */
 return false;
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_uint,pxcrt::bt_uchar > c$ = numeric::static_cast_impl< pxcrt::bt_uint,pxcrt::bt_uchar >();
 return c$.convert(x$);
 /* staticif end */
}
};}; /* namespace numeric::cast */
namespace numeric$n { namespace limit$n { 
static inline pxcrt::bt_uint lowest$f$p$meta$n$$uint$t$r$() {
 numeric::limit_impl< pxcrt::bt_uint > obj$ = numeric::limit_impl< pxcrt::bt_uint >();
 return obj$.lowest();
}
};}; /* namespace numeric::limit */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_uint positional_to_integral_internal$f$p$meta$n$$uint$t$q$10$li$q$0$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
 pxcrt::bt_uint r$ = pxcrt::bt_uint();
 {
  const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& ag$fe = (buf$);
  const size_t sz$fe = ag$fe.size();
  const pxcrt::bt_uchar *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t idx$ = 0; idx$ != sz$fe; ++idx$) {
   pxcrt::bt_uchar v$ = ar$fe[idx$];
   {
    pxcrt::bt_uint dig$ = pxcrt::bt_uint();
    if (::text$n::string$n::positional$n::uchar_to_integral$f$p$meta$n$$uint$t$q$10$li$r$(v$ , dig$)) {
     /* staticif empty */{
      if (r$ > (::numeric$n::limit$n::highest$f$p$meta$n$$uint$t$r$() / pxcrt::bt_uint(10LL))) {
       buf$.increment_front(idx$);
       return r$;
      }
     }
     r$ *= pxcrt::bt_uint(10LL);
     /* staticif empty */{
      const pxcrt::bt_uint nr$ = r$ + dig$;
      if (nr$ < r$) {
       buf$.increment_front(idx$);
       return r$;
      }
      r$ = nr$;
     }
    } else {
     buf$.increment_front(idx$);
     return r$;
    }
   }
  }
 }
 buf$.increment_front(buf$.size());
 return r$;
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace limit$n { 
static inline pxcrt::bt_uint highest$f$p$meta$n$$uint$t$r$() {
 numeric::limit_impl< pxcrt::bt_uint > obj$ = numeric::limit_impl< pxcrt::bt_uint >();
 return obj$.highest();
}
};}; /* namespace numeric::limit */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_uint string_parse_token$f$p$meta$n$$uint$t$q$text$$string$$positional$n$$positional_to_integral$f$p$meta$n$$uint$t$q$10$li$r$$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 const pxcrt::bt_size_t toklen$ = ::text$n::string$n::serialize$n::token_length$f(s$);
 ::pxcrt::bt_cslice< pxcrt::bt_uchar > stok$ = ::pxcrt::bt_cslice< pxcrt::bt_uchar >(s$, pxcrt::bt_size_t((0LL)), toklen$);
 s$.increment_front(toklen$);
 return ::text$n::string$n::positional$n::positional_to_integral$f$p$meta$n$$uint$t$q$10$li$r$(stok$);
}
};};}; /* namespace text::string::serialize */
namespace container$n { namespace array$n { 
static inline void split_foreach$f$p$pgl3d$$wfobj$n$$parse_token$f8$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(::pxcrt::pxcvarray< ::pgl3d$n::wfobj$n::wfelement$s >& _0$up, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$) {
 pxcrt::bt_size_t p$ = pxcrt::bt_size_t();
 while (true) {
  const pxcrt::bt_size_t pend$ = ::container$n::array$n::find_mapped$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(c$ , p$ , v$);
  ::pgl3d$n::wfobj$n::parse_token$f8(_0$up , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(c$, p$, pend$));
  if (pend$ == c$.size()) {
   break;
  }
  p$ = pend$ + pxcrt::bt_size_t(1LL);
 }
}
};}; /* namespace container::array */
namespace operator$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > union_field$f$p$value$ls$q$io$$errno$n$$errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(const ::io$n::errno$n::errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$& x$) {
 if (!(x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$::value$$e)) {
  {
   if ((x$.get_$e() == ::io$n::errno$n::errno_or_value$v$p$pxcrt$$ptr$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$::errno$$e)) {
    PXC_THROW(::exception$n::unexpected_value_template$s$p$errno__t$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(int((x$.errno$$r())))).get_crange())));
   }
  }
  /* staticif empty */
 }
 return (x$.value$$r());
}
}; /* namespace operator */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$uint$t$r$(pxcrt::bt_uint x$) {
 return ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$) {
 /* staticif */
 numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_uint > c$ = numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_uint >();
 return c$.convert(x$);
 /* staticif end */
}
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline void adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
 /* staticif empty *//* staticif-else */
 ::operator$n::binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$add$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline void binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$add$ls$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
 /* staticif */
 x$ = pxcrt::glmpx::op_add< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(x$ , y$);
 /* staticif end */
}
}; /* namespace operator */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$size_t$t$r$(pxcrt::bt_size_t x$) {
 return ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$size_t$t$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace operator$n { 
static inline void diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
 /* staticif empty *//* staticif-else */
 ::operator$n::binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline void binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
 /* staticif */
 x$ = pxcrt::glmpx::op_div< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type,pxcrt::bt_float >(x$ , y$);
 /* staticif end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
 /* staticif empty *//* staticif-else */
 return ::operator$n::binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$sub$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$sub$ls$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
 /* staticif */
 return pxcrt::glmpx::op_sub< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(x$ , y$);
 /* staticif end */
}
}; /* namespace operator */
namespace ordered$n { 
static inline pxcrt::bt_float max$f$p$meta$n$$float$t$r$(const pxcrt::bt_float& x$, const pxcrt::bt_float& y$) {
 return x$ < y$ ? y$ : x$;
}
}; /* namespace ordered */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
 /* staticif empty *//* staticif-else */
 return ::operator$n::binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
 /* staticif */
 return pxcrt::glmpx::op_mul< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type,pxcrt::bt_float,pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(x$ , y$);
 /* staticif end */
}
}; /* namespace operator */
namespace callable$n { 
callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(const pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& p0$) : p$(p0$) {
}
inline void callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& a0$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& a1$, const ::pgl3d$n::glgeometry$n::mesh_index$s& a2$) const {
 return ((*(pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >(p$)))).__call$f(a0$ , a1$ , a2$);
}
}; /* namespace callable */
namespace container$n { namespace array$n { 
static inline void reverse$f$p$container$$array$n$$slice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(const ::pxcrt::bt_slice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& x$) {
 pxcrt::bt_size_t s$ = pxcrt::bt_size_t((0LL));
 pxcrt::bt_size_t f$ = x$.size();
 while (s$ < f$) {
  --f$;
  ::pgl3d$n::glgeometry$n::vertex_attr$s v$ = (x$.begin()[s$]);
  (x$.begin()[s$]) = (x$.begin()[f$]);
  (x$.begin()[f$]) = v$;
  ++s$;
 }
}
};}; /* namespace container::array */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type div$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
 /* staticif empty *//* staticif-else */
 return ::operator$n::binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
 /* staticif */
 return pxcrt::glmpx::op_div< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type,pxcrt::bt_float >(x$ , y$);
 /* staticif end */
}
}; /* namespace operator */
namespace pgl3d$n { namespace glgeometry$n { 
static inline void polygon_scale$f$p$container$$array$n$$darrayst$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$r$(::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, pxcrt::bt_float scale$) {
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c$ = ::pgl3d$n::glgeometry$n::polygon_center$f(poly$);
 {
  ::pxcrt::darrayst< ::pgl3d$n::glgeometry$n::vertex_attr$s >& ag$fe = (poly$);
  const size_t sz$fe = ag$fe.size();
  ::pgl3d$n::glgeometry$n::vertex_attr$s *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   ::pgl3d$n::glgeometry$n::vertex_attr$s& p$ = ar$fe[i$];
   {
    p$.pos$ = (::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(c$ , ((::operator$n::mul$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(p$.pos$ , c$))) , scale$)))));
   }
  }
 }
}
};}; /* namespace pgl3d::glgeometry */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
 /* staticif empty *//* staticif-else */
 return ::operator$n::binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$add$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$add$ls$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
 /* staticif */
 return pxcrt::glmpx::op_add< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(x$ , y$);
 /* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,4LL > make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$4$li$r$(const ::pgl3d$n::glgeometry$n::vertex_attr$s& a0$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a1$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a2$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a3$) {
 ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,4LL > arr$ = ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,4LL >();
 arr$[pxcrt::bt_size_t((0LL))] = a0$;
 arr$[pxcrt::bt_size_t(1LL)] = a1$;
 arr$[pxcrt::bt_size_t(2LL)] = a2$;
 arr$[pxcrt::bt_size_t(3LL)] = a3$;
 return arr$;
}
};}; /* namespace container::array */
namespace pgl3d$n { namespace glgeometry$n { 
static inline ::pgl3d$n::glgeometry$n::vertex_attr$s tvec3___to$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$) {
 ::pgl3d$n::glgeometry$n::vertex_attr$s r$;
 r$.pos$ = x$;
 return r$;
}
};}; /* namespace pgl3d::glgeometry */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type mul$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tmat3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
 /* staticif empty *//* staticif-else */
 return ::operator$n::binop$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$mul$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$mul$ls$r$(const pxcrt::glmpx::tmat3< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
 /* staticif */
 return pxcrt::glmpx::op_mul< pxcrt::glmpx::tmat3< pxcrt::bt_float >::type,pxcrt::glmpx::tvec3< pxcrt::bt_float >::type,pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(x$ , y$);
 /* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL > make_farray_func$f$p$pgl3d$$glgeometry$n$$vertex_attr$s$q$3$li$r$(const ::pgl3d$n::glgeometry$n::vertex_attr$s& a0$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a1$, const ::pgl3d$n::glgeometry$n::vertex_attr$s& a2$) {
 ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL > arr$ = ::pxcrt::farray< ::pgl3d$n::glgeometry$n::vertex_attr$s,3LL >();
 arr$[pxcrt::bt_size_t((0LL))] = a0$;
 arr$[pxcrt::bt_size_t(1LL)] = a1$;
 arr$[pxcrt::bt_size_t(2LL)] = a2$;
 return arr$;
}
};}; /* namespace container::array */
namespace operator$n { 
static inline pxcrt::glmpx::tmat4< pxcrt::bt_float >::type mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& y$) {
 /* staticif empty *//* staticif-else */
 return ::operator$n::binop$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$mul$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline pxcrt::glmpx::tmat4< pxcrt::bt_float >::type binop$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$mul$ls$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& y$) {
 /* staticif */
 return pxcrt::glmpx::op_mul< pxcrt::glmpx::tmat4< pxcrt::bt_float >::type,pxcrt::glmpx::tmat4< pxcrt::bt_float >::type,pxcrt::glmpx::tmat4< pxcrt::bt_float >::type >(x$ , y$);
 /* staticif end */
}
static inline pxcrt::glmpx::tvec4< pxcrt::bt_float >::type mul$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type& y$) {
 /* staticif empty *//* staticif-else */
 return ::operator$n::binop$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$q$mul$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline pxcrt::glmpx::tvec4< pxcrt::bt_float >::type binop$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$glm$n$$tvec4$s$p$meta$n$$float$t$r$$q$mul$ls$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec4< pxcrt::bt_float >::type& y$) {
 /* staticif */
 return pxcrt::glmpx::op_mul< pxcrt::glmpx::tmat4< pxcrt::bt_float >::type,pxcrt::glmpx::tvec4< pxcrt::bt_float >::type,pxcrt::glmpx::tvec4< pxcrt::bt_float >::type >(x$ , y$);
 /* staticif end */
}
static inline void mula$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& y$) {
 /* staticif empty *//* staticif-else */
 ::operator$n::binopa$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$mul$ls$r$(x$ , y$);
 /* staticif-else end */
}
static inline void binopa$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$mul$ls$r$(pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& y$) {
 /* staticif */
 x$ = pxcrt::glmpx::op_mul< pxcrt::glmpx::tquat< pxcrt::bt_float >::type,pxcrt::glmpx::tquat< pxcrt::bt_float >::type,pxcrt::glmpx::tquat< pxcrt::bt_float >::type >(x$ , y$);
 /* staticif end */
}
}; /* namespace operator */
namespace pgl3d$n { namespace intern_pool$n { 
intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$() : string_to_id$(), id_to_string$(){
 /* string_to_id$ */;
 /* id_to_string$ */;
}
intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > string_to_id$, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > id_to_string$) : string_to_id$(string_to_id$), id_to_string$(id_to_string$){
 /* string_to_id$ */;
 /* id_to_string$ */;
}
inline ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$::intern$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
 {
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > t0((string_to_id$));
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > const& ag$fe = ((t0.get()));
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::cfind_type i$it = ag$fe.find(::pxcrt::pxcvarray< pxcrt::bt_uchar >(s$));
  if (i$it != ag$fe.notfound()) {
   const pxcrt::bt_size_t& id$ = ag$fe.get_cmapped(i$it);
   {
    return ::numeric$n::cast$n::static_cast$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$meta$n$$size_t$t$r$(id$);
   }
  }
 }
 pxcrt::bt_size_t r$ = id_to_string$.size();
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >,::pxcrt::bt_cslice< pxcrt::bt_uchar > >(id_to_string$ , s$);
 string_to_id$.insert(::pxcrt::pxcvarray< pxcrt::bt_uchar >(s$) , r$);
 return ::numeric$n::cast$n::static_cast$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$meta$n$$size_t$t$r$(r$);
}
inline ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$::to_id$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) const {
 {
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > t0((string_to_id$));
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > const& ag$fe = ((t0.get()));
  pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_size_t,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::cfind_type i$it = ag$fe.find(::pxcrt::pxcvarray< pxcrt::bt_uchar >(s$));
  if (i$it != ag$fe.notfound()) {
   const pxcrt::bt_size_t& id$ = ag$fe.get_cmapped(i$it);
   {
    return ::numeric$n::cast$n::static_cast$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$meta$n$$size_t$t$r$(id$);
   }
  }
 }
 PXC_THROW(::exception$n::runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("to_id"))));
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$::to_string$f(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type id$) const {
 pxcrt::bt_size_t i$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(id$);
 {
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >::guard_ref< const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > > t0((id_to_string$));
  ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > const& ag$fe = ((t0.get()));
  pxcrt::bt_size_t i$it = (i$);
  if (i$it < ag$fe.size()) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& s$ = ag$fe[i$it];
  {
   return s$;
  }
 }
}
PXC_THROW(::exception$n::runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("to_string"))));
}
inline ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$::size$f() const {
return ::numeric$n::cast$n::static_cast$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$meta$n$$size_t$t$r$(id_to_string$.size());
}
};}; /* namespace pgl3d::intern_pool */
namespace numeric$n { namespace cast$n { 
static inline ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type static_cast$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$) {
/* staticif */
numeric::static_cast_impl< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type,pxcrt::bt_size_t > c$ = numeric::static_cast_impl< ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type,pxcrt::bt_size_t >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace exception$n { 
runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$::runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$pgl3d_3a_3aintern__pool_3a_3aintern__pool_7bpgl3d_3a_3apglbase_3a_3avertex__buffer__pool__key_7d$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{pgl3d::intern_pool::intern_pool{pgl3d::pglbase::vertex_buffer_pool_key}}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_size_t,::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type > c$ = numeric::static_cast_impl< pxcrt::bt_size_t,::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_strlit& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$q$add$ls$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_strlit& y$) {
/* staticif */
return ::container$n::array$n::array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_strlit& y$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > r$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(x$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(r$ , y$);
return r$;
}
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$) {
/* staticif */
return ::container$n::array$n::array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > r$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(x$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_cslice< pxcrt::bt_uchar > >(r$ , y$);
return r$;
}
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$) {
/* staticif */
::pxcrt::pxcvarray< pxcrt::bt_uchar > r$ = x$;
::container$n::array$n::array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(r$ , y$);
return r$;
/* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline void array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$) {
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(x$ , y$);
}
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$) {
/* staticif */
::pxcrt::pxcvarray< pxcrt::bt_uchar > r$ = x$;
::container$n::array$n::array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(r$ , y$);
return r$;
/* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline void array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& y$) {
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_cslice< pxcrt::bt_uchar > >(x$ , y$);
}
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$) {
/* staticif */
return ::container$n::array$n::array___add$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > array___add$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > r$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(x$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(r$ , y$);
return r$;
}
};}; /* namespace container::array */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$GL$$base$n$$GLenum$s$r$(const GLenum& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_int,GLenum > c$ = numeric::static_cast_impl< pxcrt::bt_int,GLenum >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace exception$n { 
runtime_error_template$s$p$opengl__error$ls$r$::runtime_error_template$s$p$opengl__error$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$opengl__error$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{opengl_error}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const pxcrt::bt_int& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_cslice< pxcrt::bt_uchar > >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a1$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$int$t$r$(const pxcrt::bt_int& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$int$t$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::positional$n::integral_to_positional$f$p$meta$n$$int$t$q$10$li$r$(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$int$t$q$10$li$r$(pxcrt::bt_int v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
/* staticif empty */
if (v$ == (0LL)) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 48U);
 return;
}
pxcrt::bt_size_t pos0$ = buf$.size();
if (v$ < (0LL)) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 45U);
 pos0$ += pxcrt::bt_size_t(1LL);
 while (v$ != (0LL)) {
  pxcrt::bt_int rem$ = v$ % pxcrt::bt_int(10LL);
  v$ /= pxcrt::bt_int(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$int$t$r$(-rem$) + 48U);
  }
 }
} else {
 while (v$ != (0LL)) {
  pxcrt::bt_int rem$ = v$ % pxcrt::bt_int(10LL);
  v$ /= pxcrt::bt_int(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$int$t$r$(rem$) + 48U);
  }
 }
}
::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::bt_slice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (buf$).get()), pos0$, buf$.size()));
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_int > c$ = numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_int >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace GL$n { namespace compat$n { 
void glActiveTexture$f(const GLenum texture$) {
/* staticif empty *//* staticif-else */
::glActiveTexture(texture$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glActiveTexture")));
/* staticif-else end */
}
void glAttachShader$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint shader$) {
/* staticif empty *//* staticif-else */
::glAttachShader(program$ , shader$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glAttachShader")));
/* staticif-else end */
}
void glBindAttribLocation$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_char >::type name$) {
/* staticif empty *//* staticif-else */
::glBindAttribLocation(program$ , index$ , name$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBindAttribLocation")));
/* staticif-else end */
}
void glBindBuffer$f(const GLenum target$, const pxcrt::bt_uint buffer$) {
/* staticif empty *//* staticif-else */
::glBindBuffer(target$ , buffer$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBindBuffer")));
/* staticif-else end */
}
void glBindFramebuffer$f(const GLenum target$, const pxcrt::bt_uint framebuffer$) {
/* staticif empty *//* staticif-else */
::glBindFramebuffer(target$ , framebuffer$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBindFramebuffer")));
/* staticif-else end */
}
void glBindRenderbuffer$f(const GLenum target$, const pxcrt::bt_uint renderbuffer$) {
/* staticif empty *//* staticif-else */
::glBindRenderbuffer(target$ , renderbuffer$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBindRenderbuffer")));
/* staticif-else end */
}
void glBindTexture$f(const GLenum target$, const pxcrt::bt_uint texture$) {
/* staticif empty *//* staticif-else */
::glBindTexture(target$ , texture$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBindTexture")));
/* staticif-else end */
}
void glBlendColor$f(const pxcrt::bt_float red$, const pxcrt::bt_float green$, const pxcrt::bt_float blue$, const pxcrt::bt_float alpha$) {
/* staticif empty *//* staticif-else */
::glBlendColor(red$ , green$ , blue$ , alpha$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBlendColor")));
/* staticif-else end */
}
void glBlendEquation$f(const GLenum mode$) {
/* staticif empty *//* staticif-else */
::glBlendEquation(mode$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBlendEquation")));
/* staticif-else end */
}
void glBlendEquationSeparate$f(const GLenum modeRGB$, const GLenum modeAlpha$) {
/* staticif empty *//* staticif-else */
::glBlendEquationSeparate(modeRGB$ , modeAlpha$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBlendEquationSeparate")));
/* staticif-else end */
}
void glBlendFunc$f(const GLenum sfactor$, const GLenum dfactor$) {
/* staticif empty *//* staticif-else */
::glBlendFunc(sfactor$ , dfactor$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBlendFunc")));
/* staticif-else end */
}
void glBlendFuncSeparate$f(const GLenum sfactorRGB$, const GLenum dfactorRGB$, const GLenum sfactorAlpha$, const GLenum dfactorAlpha$) {
/* staticif empty *//* staticif-else */
::glBlendFuncSeparate(sfactorRGB$ , dfactorRGB$ , sfactorAlpha$ , dfactorAlpha$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBlendFuncSeparate")));
/* staticif-else end */
}
void glBufferData$f(const GLenum target$, const GLsizeiptr size$, const pxcrt::crawptr< void >::type data$, const GLenum usage$) {
/* staticif empty *//* staticif-else */
::glBufferData(target$ , size$ , data$ , usage$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBufferData")));
/* staticif-else end */
}
void glBufferSubData$f(const GLenum target$, const GLintptr offset$, const GLsizeiptr size$, const pxcrt::crawptr< void >::type data$) {
/* staticif empty *//* staticif-else */
::glBufferSubData(target$ , offset$ , size$ , data$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glBufferSubData")));
/* staticif-else end */
}
GLenum glCheckFramebufferStatus$f(const GLenum target$) {
/* staticif */
const GLenum r$ = ::glCheckFramebufferStatus(target$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCheckFramebufferStatus")));
}
return r$;
/* staticif end */
}
void glClear$f(const GLbitfield mask$) {
/* staticif empty *//* staticif-else */
::glClear(mask$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glClear")));
/* staticif-else end */
}
void glClearColor$f(const pxcrt::bt_float red$, const pxcrt::bt_float green$, const pxcrt::bt_float blue$, const pxcrt::bt_float alpha$) {
/* staticif empty *//* staticif-else */
::glClearColor(red$ , green$ , blue$ , alpha$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glClearColor")));
/* staticif-else end */
}
void glClearDepthf$f(const pxcrt::bt_float d$) {
/* staticif empty *//* staticif-else */
::glClearDepthf(d$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glClearDepthf")));
/* staticif-else end */
}
void glClearStencil$f(const pxcrt::bt_int s$) {
/* staticif empty *//* staticif-else */
::glClearStencil(s$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glClearStencil")));
/* staticif-else end */
}
void glColorMask$f(const pxcrt::bt_uchar red$, const pxcrt::bt_uchar green$, const pxcrt::bt_uchar blue$, const pxcrt::bt_uchar alpha$) {
/* staticif empty *//* staticif-else */
::glColorMask(red$ , green$ , blue$ , alpha$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glColorMask")));
/* staticif-else end */
}
void glCompileShader$f(const pxcrt::bt_uint shader$) {
/* staticif empty *//* staticif-else */
::glCompileShader(shader$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCompileShader")));
/* staticif-else end */
}
void glCompressedTexImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const GLenum internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$, const pxcrt::bt_int imageSize$, const pxcrt::crawptr< void >::type data$) {
/* staticif empty *//* staticif-else */
::glCompressedTexImage2D(target$ , level$ , internalformat$ , width$ , height$ , border$ , imageSize$ , data$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCompressedTexImage2D")));
/* staticif-else end */
}
void glCompressedTexSubImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const pxcrt::bt_int imageSize$, const pxcrt::crawptr< void >::type data$) {
/* staticif empty *//* staticif-else */
::glCompressedTexSubImage2D(target$ , level$ , xoffset$ , yoffset$ , width$ , height$ , format$ , imageSize$ , data$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCompressedTexSubImage2D")));
/* staticif-else end */
}
void glCopyTexImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const GLenum internalformat$, const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$) {
/* staticif empty *//* staticif-else */
::glCopyTexImage2D(target$ , level$ , internalformat$ , x$ , y$ , width$ , height$ , border$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCopyTexImage2D")));
/* staticif-else end */
}
void glCopyTexSubImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$) {
/* staticif empty *//* staticif-else */
::glCopyTexSubImage2D(target$ , level$ , xoffset$ , yoffset$ , x$ , y$ , width$ , height$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCopyTexSubImage2D")));
/* staticif-else end */
}
pxcrt::bt_uint glCreateProgram$f() {
/* staticif */
const pxcrt::bt_uint r$ = ::glCreateProgram();
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCreateProgram")));
}
return r$;
/* staticif end */
}
pxcrt::bt_uint glCreateShader$f(const GLenum type$) {
/* staticif */
const pxcrt::bt_uint r$ = ::glCreateShader(type$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCreateShader")));
}
return r$;
/* staticif end */
}
void glCullFace$f(const GLenum mode$) {
/* staticif empty *//* staticif-else */
::glCullFace(mode$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glCullFace")));
/* staticif-else end */
}
void glDeleteBuffers$f(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type buffers$) {
/* staticif empty *//* staticif-else */
::glDeleteBuffers(n$ , buffers$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDeleteBuffers")));
/* staticif-else end */
}
void glDeleteFramebuffers$f(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type framebuffers$) {
/* staticif empty *//* staticif-else */
::glDeleteFramebuffers(n$ , framebuffers$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDeleteFramebuffers")));
/* staticif-else end */
}
void glDeleteProgram$f(const pxcrt::bt_uint program$) {
/* staticif empty *//* staticif-else */
::glDeleteProgram(program$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDeleteProgram")));
/* staticif-else end */
}
void glDeleteRenderbuffers$f(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type renderbuffers$) {
/* staticif empty *//* staticif-else */
::glDeleteRenderbuffers(n$ , renderbuffers$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDeleteRenderbuffers")));
/* staticif-else end */
}
void glDeleteShader$f(const pxcrt::bt_uint shader$) {
/* staticif empty *//* staticif-else */
::glDeleteShader(shader$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDeleteShader")));
/* staticif-else end */
}
void glDeleteTextures$f(const pxcrt::bt_int n$, const pxcrt::crawptr< pxcrt::bt_uint >::type textures$) {
/* staticif empty *//* staticif-else */
::glDeleteTextures(n$ , textures$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDeleteTextures")));
/* staticif-else end */
}
void glDepthFunc$f(const GLenum func$) {
/* staticif empty *//* staticif-else */
::glDepthFunc(func$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDepthFunc")));
/* staticif-else end */
}
void glDepthMask$f(const pxcrt::bt_uchar flag$) {
/* staticif empty *//* staticif-else */
::glDepthMask(flag$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDepthMask")));
/* staticif-else end */
}
void glDepthRangef$f(const pxcrt::bt_float n$, const pxcrt::bt_float f$) {
/* staticif empty *//* staticif-else */
::glDepthRangef(n$ , f$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDepthRangef")));
/* staticif-else end */
}
void glDetachShader$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint shader$) {
/* staticif empty *//* staticif-else */
::glDetachShader(program$ , shader$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDetachShader")));
/* staticif-else end */
}
void glDisable$f(const GLenum cap$) {
/* staticif empty *//* staticif-else */
::glDisable(cap$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDisable")));
/* staticif-else end */
}
void glDisableVertexAttribArray$f(const pxcrt::bt_uint index$) {
/* staticif empty *//* staticif-else */
::glDisableVertexAttribArray(index$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDisableVertexAttribArray")));
/* staticif-else end */
}
void glDrawArrays$f(const GLenum mode$, const pxcrt::bt_int first$, const pxcrt::bt_int count$) {
/* staticif empty *//* staticif-else */
::glDrawArrays(mode$ , first$ , count$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDrawArrays")));
/* staticif-else end */
}
void glDrawElements$f(const GLenum mode$, const pxcrt::bt_int count$, const GLenum type$, const pxcrt::crawptr< void >::type indices$) {
/* staticif empty *//* staticif-else */
::glDrawElements(mode$ , count$ , type$ , indices$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glDrawElements")));
/* staticif-else end */
}
void glEnable$f(const GLenum cap$) {
/* staticif empty *//* staticif-else */
::glEnable(cap$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glEnable")));
/* staticif-else end */
}
void glEnableVertexAttribArray$f(const pxcrt::bt_uint index$) {
/* staticif empty *//* staticif-else */
::glEnableVertexAttribArray(index$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glEnableVertexAttribArray")));
/* staticif-else end */
}
void glFinish$f() {
/* staticif empty *//* staticif-else */
::glFinish();
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glFinish")));
/* staticif-else end */
}
void glFlush$f() {
/* staticif empty *//* staticif-else */
::glFlush();
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glFlush")));
/* staticif-else end */
}
void glFramebufferRenderbuffer$f(const GLenum target$, const GLenum attachment$, const GLenum renderbuffertarget$, const pxcrt::bt_uint renderbuffer$) {
/* staticif empty *//* staticif-else */
::glFramebufferRenderbuffer(target$ , attachment$ , renderbuffertarget$ , renderbuffer$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glFramebufferRenderbuffer")));
/* staticif-else end */
}
void glFramebufferTexture2D$f(const GLenum target$, const GLenum attachment$, const GLenum textarget$, const pxcrt::bt_uint texture$, const pxcrt::bt_int level$) {
/* staticif empty *//* staticif-else */
::glFramebufferTexture2D(target$ , attachment$ , textarget$ , texture$ , level$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glFramebufferTexture2D")));
/* staticif-else end */
}
void glFrontFace$f(const GLenum mode$) {
/* staticif empty *//* staticif-else */
::glFrontFace(mode$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glFrontFace")));
/* staticif-else end */
}
void glGenBuffers$f(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type buffers$) {
/* staticif empty *//* staticif-else */
::glGenBuffers(n$ , buffers$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGenBuffers")));
/* staticif-else end */
}
void glGenerateMipmap$f(const GLenum target$) {
/* staticif empty *//* staticif-else */
::glGenerateMipmap(target$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGenerateMipmap")));
/* staticif-else end */
}
void glGenFramebuffers$f(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type framebuffers$) {
/* staticif empty *//* staticif-else */
::glGenFramebuffers(n$ , framebuffers$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGenFramebuffers")));
/* staticif-else end */
}
void glGenRenderbuffers$f(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type renderbuffers$) {
/* staticif empty *//* staticif-else */
::glGenRenderbuffers(n$ , renderbuffers$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGenRenderbuffers")));
/* staticif-else end */
}
void glGenTextures$f(const pxcrt::bt_int n$, const pxcrt::rawptr< pxcrt::bt_uint >::type textures$) {
/* staticif empty *//* staticif-else */
::glGenTextures(n$ , textures$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGenTextures")));
/* staticif-else end */
}
void glGetActiveAttrib$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_int >::type size$, const pxcrt::rawptr< GLenum >::type type$, const pxcrt::rawptr< pxcrt::bt_char >::type name$) {
/* staticif empty *//* staticif-else */
::glGetActiveAttrib(program$ , index$ , bufSize$ , length$ , size$ , type$ , name$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetActiveAttrib")));
/* staticif-else end */
}
void glGetActiveUniform$f(const pxcrt::bt_uint program$, const pxcrt::bt_uint index$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_int >::type size$, const pxcrt::rawptr< GLenum >::type type$, const pxcrt::rawptr< pxcrt::bt_char >::type name$) {
/* staticif empty *//* staticif-else */
::glGetActiveUniform(program$ , index$ , bufSize$ , length$ , size$ , type$ , name$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetActiveUniform")));
/* staticif-else end */
}
void glGetAttachedShaders$f(const pxcrt::bt_uint program$, const pxcrt::bt_int maxCount$, const pxcrt::rawptr< pxcrt::bt_int >::type count$, const pxcrt::rawptr< pxcrt::bt_uint >::type shaders$) {
/* staticif empty *//* staticif-else */
::glGetAttachedShaders(program$ , maxCount$ , count$ , shaders$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetAttachedShaders")));
/* staticif-else end */
}
pxcrt::bt_int glGetAttribLocation$f(const pxcrt::bt_uint program$, const pxcrt::crawptr< pxcrt::bt_char >::type name$) {
/* staticif */
const pxcrt::bt_int r$ = ::glGetAttribLocation(program$ , name$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetAttribLocation")));
}
return r$;
/* staticif end */
}
void glGetBooleanv$f(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_uchar >::type params$) {
/* staticif empty *//* staticif-else */
::glGetBooleanv(pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetBooleanv")));
/* staticif-else end */
}
void glGetBufferParameteriv$f(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetBufferParameteriv(target$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetBufferParameteriv")));
/* staticif-else end */
}
GLenum glGetError$f() {
/* staticif */
const GLenum r$ = ::glGetError();
/* staticif empty */
return r$;
/* staticif end */
}
void glGetFloatv$f(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$) {
/* staticif empty *//* staticif-else */
::glGetFloatv(pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetFloatv")));
/* staticif-else end */
}
void glGetFramebufferAttachmentParameteriv$f(const GLenum target$, const GLenum attachment$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetFramebufferAttachmentParameteriv(target$ , attachment$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetFramebufferAttachmentParameteriv")));
/* staticif-else end */
}
void glGetIntegerv$f(const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetIntegerv(pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetIntegerv")));
/* staticif-else end */
}
void glGetProgramiv$f(const pxcrt::bt_uint program$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetProgramiv(program$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetProgramiv")));
/* staticif-else end */
}
void glGetProgramInfoLog$f(const pxcrt::bt_uint program$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type infoLog$) {
/* staticif empty *//* staticif-else */
::glGetProgramInfoLog(program$ , bufSize$ , length$ , infoLog$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetProgramInfoLog")));
/* staticif-else end */
}
void glGetRenderbufferParameteriv$f(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetRenderbufferParameteriv(target$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetRenderbufferParameteriv")));
/* staticif-else end */
}
void glGetShaderiv$f(const pxcrt::bt_uint shader$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetShaderiv(shader$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetShaderiv")));
/* staticif-else end */
}
void glGetShaderInfoLog$f(const pxcrt::bt_uint shader$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type infoLog$) {
/* staticif empty *//* staticif-else */
::glGetShaderInfoLog(shader$ , bufSize$ , length$ , infoLog$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetShaderInfoLog")));
/* staticif-else end */
}
void glGetShaderPrecisionFormat$f(const GLenum shadertype$, const GLenum precisiontype$, const pxcrt::rawptr< pxcrt::bt_int >::type range$, const pxcrt::rawptr< pxcrt::bt_int >::type precision$) {
/* staticif empty *//* staticif-else */
::glGetShaderPrecisionFormat(shadertype$ , precisiontype$ , range$ , precision$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetShaderPrecisionFormat")));
/* staticif-else end */
}
void glGetShaderSource$f(const pxcrt::bt_uint shader$, const pxcrt::bt_int bufSize$, const pxcrt::rawptr< pxcrt::bt_int >::type length$, const pxcrt::rawptr< pxcrt::bt_char >::type source$) {
/* staticif empty *//* staticif-else */
::glGetShaderSource(shader$ , bufSize$ , length$ , source$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetShaderSource")));
/* staticif-else end */
}
pxcrt::crawptr< pxcrt::bt_uchar >::type glGetString$f(const GLenum name$) {
/* staticif */
const pxcrt::crawptr< pxcrt::bt_uchar >::type r$ = ::glGetString(name$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetString")));
}
return r$;
/* staticif end */
}
void glGetTexParameterfv$f(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$) {
/* staticif empty *//* staticif-else */
::glGetTexParameterfv(target$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetTexParameterfv")));
/* staticif-else end */
}
void glGetTexParameteriv$f(const GLenum target$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetTexParameteriv(target$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetTexParameteriv")));
/* staticif-else end */
}
void glGetUniformfv$f(const pxcrt::bt_uint program$, const pxcrt::bt_int location$, const pxcrt::rawptr< pxcrt::bt_float >::type params$) {
/* staticif empty *//* staticif-else */
::glGetUniformfv(program$ , location$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetUniformfv")));
/* staticif-else end */
}
void glGetUniformiv$f(const pxcrt::bt_uint program$, const pxcrt::bt_int location$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetUniformiv(program$ , location$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetUniformiv")));
/* staticif-else end */
}
pxcrt::bt_int glGetUniformLocation$f(const pxcrt::bt_uint program$, const pxcrt::crawptr< pxcrt::bt_char >::type name$) {
/* staticif */
const pxcrt::bt_int r$ = ::glGetUniformLocation(program$ , name$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetUniformLocation")));
}
return r$;
/* staticif end */
}
void glGetVertexAttribfv$f(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_float >::type params$) {
/* staticif empty *//* staticif-else */
::glGetVertexAttribfv(index$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetVertexAttribfv")));
/* staticif-else end */
}
void glGetVertexAttribiv$f(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glGetVertexAttribiv(index$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetVertexAttribiv")));
/* staticif-else end */
}
void glGetVertexAttribPointerv$f(const pxcrt::bt_uint index$, const GLenum pname$, const pxcrt::rawptr< pxcrt::rawptr< void >::type >::type pointer$) {
/* staticif empty *//* staticif-else */
::glGetVertexAttribPointerv(index$ , pname$ , pointer$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glGetVertexAttribPointerv")));
/* staticif-else end */
}
void glHint$f(const GLenum target$, const GLenum mode$) {
/* staticif empty *//* staticif-else */
::glHint(target$ , mode$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glHint")));
/* staticif-else end */
}
pxcrt::bt_uchar glIsBuffer$f(const pxcrt::bt_uint buffer$) {
/* staticif */
const pxcrt::bt_uchar r$ = ::glIsBuffer(buffer$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glIsBuffer")));
}
return r$;
/* staticif end */
}
pxcrt::bt_uchar glIsEnabled$f(const GLenum cap$) {
/* staticif */
const pxcrt::bt_uchar r$ = ::glIsEnabled(cap$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glIsEnabled")));
}
return r$;
/* staticif end */
}
pxcrt::bt_uchar glIsFramebuffer$f(const pxcrt::bt_uint framebuffer$) {
/* staticif */
const pxcrt::bt_uchar r$ = ::glIsFramebuffer(framebuffer$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glIsFramebuffer")));
}
return r$;
/* staticif end */
}
pxcrt::bt_uchar glIsProgram$f(const pxcrt::bt_uint program$) {
/* staticif */
const pxcrt::bt_uchar r$ = ::glIsProgram(program$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glIsProgram")));
}
return r$;
/* staticif end */
}
pxcrt::bt_uchar glIsRenderbuffer$f(const pxcrt::bt_uint renderbuffer$) {
/* staticif */
const pxcrt::bt_uchar r$ = ::glIsRenderbuffer(renderbuffer$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glIsRenderbuffer")));
}
return r$;
/* staticif end */
}
pxcrt::bt_uchar glIsShader$f(const pxcrt::bt_uint shader$) {
/* staticif */
const pxcrt::bt_uchar r$ = ::glIsShader(shader$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glIsShader")));
}
return r$;
/* staticif end */
}
pxcrt::bt_uchar glIsTexture$f(const pxcrt::bt_uint texture$) {
/* staticif */
const pxcrt::bt_uchar r$ = ::glIsTexture(texture$);
{
 ::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glIsTexture")));
}
return r$;
/* staticif end */
}
void glLineWidth$f(const pxcrt::bt_float width$) {
/* staticif empty *//* staticif-else */
::glLineWidth(width$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glLineWidth")));
/* staticif-else end */
}
void glLinkProgram$f(const pxcrt::bt_uint program$) {
/* staticif empty *//* staticif-else */
::glLinkProgram(program$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glLinkProgram")));
/* staticif-else end */
}
void glPixelStorei$f(const GLenum pname$, const pxcrt::bt_int param$) {
/* staticif empty *//* staticif-else */
::glPixelStorei(pname$ , param$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glPixelStorei")));
/* staticif-else end */
}
void glPolygonOffset$f(const pxcrt::bt_float factor$, const pxcrt::bt_float units$) {
/* staticif empty *//* staticif-else */
::glPolygonOffset(factor$ , units$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glPolygonOffset")));
/* staticif-else end */
}
void glReadPixels$f(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const GLenum type$, const pxcrt::rawptr< void >::type pixels$) {
/* staticif empty *//* staticif-else */
::glReadPixels(x$ , y$ , width$ , height$ , format$ , type$ , pixels$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glReadPixels")));
/* staticif-else end */
}
void glReleaseShaderCompiler$f() {
/* staticif empty *//* staticif-else */
::glReleaseShaderCompiler();
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glReleaseShaderCompiler")));
/* staticif-else end */
}
void glRenderbufferStorage$f(const GLenum target$, const GLenum internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$) {
/* staticif empty *//* staticif-else */
::glRenderbufferStorage(target$ , internalformat$ , width$ , height$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glRenderbufferStorage")));
/* staticif-else end */
}
void glSampleCoverage$f(const pxcrt::bt_float value$, const pxcrt::bt_uchar invert$) {
/* staticif empty *//* staticif-else */
::glSampleCoverage(value$ , invert$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glSampleCoverage")));
/* staticif-else end */
}
void glScissor$f(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$) {
/* staticif empty *//* staticif-else */
::glScissor(x$ , y$ , width$ , height$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glScissor")));
/* staticif-else end */
}
void glShaderBinary$f(const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_uint >::type shaders$, const GLenum binaryformat$, const pxcrt::crawptr< void >::type binary$, const pxcrt::bt_int length$) {
/* staticif empty *//* staticif-else */
::glShaderBinary(count$ , shaders$ , binaryformat$ , binary$ , length$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glShaderBinary")));
/* staticif-else end */
}
void glShaderSource$f(const pxcrt::bt_uint shader$, const pxcrt::bt_int count$, const pxcrt::rawptr< pxcrt::crawptr< pxcrt::bt_char >::type >::type string$, const pxcrt::crawptr< pxcrt::bt_int >::type length$) {
/* staticif empty *//* staticif-else */
::glShaderSource(shader$ , count$ , string$ , length$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glShaderSource")));
/* staticif-else end */
}
void glStencilFunc$f(const GLenum func$, const pxcrt::bt_int ref$, const pxcrt::bt_uint mask$) {
/* staticif empty *//* staticif-else */
::glStencilFunc(func$ , ref$ , mask$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glStencilFunc")));
/* staticif-else end */
}
void glStencilFuncSeparate$f(const GLenum face$, const GLenum func$, const pxcrt::bt_int ref$, const pxcrt::bt_uint mask$) {
/* staticif empty *//* staticif-else */
::glStencilFuncSeparate(face$ , func$ , ref$ , mask$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glStencilFuncSeparate")));
/* staticif-else end */
}
void glStencilMask$f(const pxcrt::bt_uint mask$) {
/* staticif empty *//* staticif-else */
::glStencilMask(mask$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glStencilMask")));
/* staticif-else end */
}
void glStencilMaskSeparate$f(const GLenum face$, const pxcrt::bt_uint mask$) {
/* staticif empty *//* staticif-else */
::glStencilMaskSeparate(face$ , mask$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glStencilMaskSeparate")));
/* staticif-else end */
}
void glStencilOp$f(const GLenum fail$, const GLenum zfail$, const GLenum zpass$) {
/* staticif empty *//* staticif-else */
::glStencilOp(fail$ , zfail$ , zpass$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glStencilOp")));
/* staticif-else end */
}
void glStencilOpSeparate$f(const GLenum face$, const GLenum sfail$, const GLenum dpfail$, const GLenum dppass$) {
/* staticif empty *//* staticif-else */
::glStencilOpSeparate(face$ , sfail$ , dpfail$ , dppass$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glStencilOpSeparate")));
/* staticif-else end */
}
void glTexImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int internalformat$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const pxcrt::bt_int border$, const GLenum format$, const GLenum type$, const pxcrt::crawptr< void >::type pixels$) {
/* staticif empty *//* staticif-else */
::glTexImage2D(target$ , level$ , internalformat$ , width$ , height$ , border$ , format$ , type$ , pixels$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glTexImage2D")));
/* staticif-else end */
}
void glTexParameterf$f(const GLenum target$, const GLenum pname$, const pxcrt::bt_float param$) {
/* staticif empty *//* staticif-else */
::glTexParameterf(target$ , pname$ , param$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glTexParameterf")));
/* staticif-else end */
}
void glTexParameterfv$f(const GLenum target$, const GLenum pname$, const pxcrt::crawptr< pxcrt::bt_float >::type params$) {
/* staticif empty *//* staticif-else */
::glTexParameterfv(target$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glTexParameterfv")));
/* staticif-else end */
}
void glTexParameteri$f(const GLenum target$, const GLenum pname$, const pxcrt::bt_int param$) {
/* staticif empty *//* staticif-else */
::glTexParameteri(target$ , pname$ , param$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glTexParameteri")));
/* staticif-else end */
}
void glTexParameteriv$f(const GLenum target$, const GLenum pname$, const pxcrt::crawptr< pxcrt::bt_int >::type params$) {
/* staticif empty *//* staticif-else */
::glTexParameteriv(target$ , pname$ , params$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glTexParameteriv")));
/* staticif-else end */
}
void glTexSubImage2D$f(const GLenum target$, const pxcrt::bt_int level$, const pxcrt::bt_int xoffset$, const pxcrt::bt_int yoffset$, const pxcrt::bt_int width$, const pxcrt::bt_int height$, const GLenum format$, const GLenum type$, const pxcrt::crawptr< void >::type pixels$) {
/* staticif empty *//* staticif-else */
::glTexSubImage2D(target$ , level$ , xoffset$ , yoffset$ , width$ , height$ , format$ , type$ , pixels$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glTexSubImage2D")));
/* staticif-else end */
}
void glUniform1f$f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$) {
/* staticif empty *//* staticif-else */
::glUniform1f(location$ , v0$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform1f")));
/* staticif-else end */
}
void glUniform1fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$) {
/* staticif empty *//* staticif-else */
::glUniform1fv(location$ , count$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform1fv")));
/* staticif-else end */
}
void glUniform1i$f(const pxcrt::bt_int location$, const pxcrt::bt_int v0$) {
/* staticif empty *//* staticif-else */
::glUniform1i(location$ , v0$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform1i")));
/* staticif-else end */
}
void glUniform1iv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$) {
/* staticif empty *//* staticif-else */
::glUniform1iv(location$ , count$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform1iv")));
/* staticif-else end */
}
void glUniform2f$f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$) {
/* staticif empty *//* staticif-else */
::glUniform2f(location$ , v0$ , v1$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform2f")));
/* staticif-else end */
}
void glUniform2fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$) {
/* staticif empty *//* staticif-else */
::glUniform2fv(location$ , count$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform2fv")));
/* staticif-else end */
}
void glUniform2i$f(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$) {
/* staticif empty *//* staticif-else */
::glUniform2i(location$ , v0$ , v1$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform2i")));
/* staticif-else end */
}
void glUniform2iv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$) {
/* staticif empty *//* staticif-else */
::glUniform2iv(location$ , count$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform2iv")));
/* staticif-else end */
}
void glUniform3f$f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$, const pxcrt::bt_float v2$) {
/* staticif empty *//* staticif-else */
::glUniform3f(location$ , v0$ , v1$ , v2$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform3f")));
/* staticif-else end */
}
void glUniform3fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$) {
/* staticif empty *//* staticif-else */
::glUniform3fv(location$ , count$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform3fv")));
/* staticif-else end */
}
void glUniform3i$f(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$, const pxcrt::bt_int v2$) {
/* staticif empty *//* staticif-else */
::glUniform3i(location$ , v0$ , v1$ , v2$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform3i")));
/* staticif-else end */
}
void glUniform3iv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$) {
/* staticif empty *//* staticif-else */
::glUniform3iv(location$ , count$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform3iv")));
/* staticif-else end */
}
void glUniform4f$f(const pxcrt::bt_int location$, const pxcrt::bt_float v0$, const pxcrt::bt_float v1$, const pxcrt::bt_float v2$, const pxcrt::bt_float v3$) {
/* staticif empty *//* staticif-else */
::glUniform4f(location$ , v0$ , v1$ , v2$ , v3$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform4f")));
/* staticif-else end */
}
void glUniform4fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_float >::type value$) {
/* staticif empty *//* staticif-else */
::glUniform4fv(location$ , count$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform4fv")));
/* staticif-else end */
}
void glUniform4i$f(const pxcrt::bt_int location$, const pxcrt::bt_int v0$, const pxcrt::bt_int v1$, const pxcrt::bt_int v2$, const pxcrt::bt_int v3$) {
/* staticif empty *//* staticif-else */
::glUniform4i(location$ , v0$ , v1$ , v2$ , v3$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform4i")));
/* staticif-else end */
}
void glUniform4iv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::crawptr< pxcrt::bt_int >::type value$) {
/* staticif empty *//* staticif-else */
::glUniform4iv(location$ , count$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniform4iv")));
/* staticif-else end */
}
void glUniformMatrix2fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$) {
/* staticif empty *//* staticif-else */
::glUniformMatrix2fv(location$ , count$ , transpose$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniformMatrix2fv")));
/* staticif-else end */
}
void glUniformMatrix3fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$) {
/* staticif empty *//* staticif-else */
::glUniformMatrix3fv(location$ , count$ , transpose$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniformMatrix3fv")));
/* staticif-else end */
}
void glUniformMatrix4fv$f(const pxcrt::bt_int location$, const pxcrt::bt_int count$, const pxcrt::bt_uchar transpose$, const pxcrt::crawptr< pxcrt::bt_float >::type value$) {
/* staticif empty *//* staticif-else */
::glUniformMatrix4fv(location$ , count$ , transpose$ , value$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUniformMatrix4fv")));
/* staticif-else end */
}
void glUseProgram$f(const pxcrt::bt_uint program$) {
/* staticif empty *//* staticif-else */
::glUseProgram(program$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glUseProgram")));
/* staticif-else end */
}
void glValidateProgram$f(const pxcrt::bt_uint program$) {
/* staticif empty *//* staticif-else */
::glValidateProgram(program$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glValidateProgram")));
/* staticif-else end */
}
void glVertexAttrib1f$f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$) {
/* staticif empty *//* staticif-else */
::glVertexAttrib1f(index$ , x$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttrib1f")));
/* staticif-else end */
}
void glVertexAttrib1fv$f(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$) {
/* staticif empty *//* staticif-else */
::glVertexAttrib1fv(index$ , v$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttrib1fv")));
/* staticif-else end */
}
void glVertexAttrib2f$f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$) {
/* staticif empty *//* staticif-else */
::glVertexAttrib2f(index$ , x$ , y$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttrib2f")));
/* staticif-else end */
}
void glVertexAttrib2fv$f(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$) {
/* staticif empty *//* staticif-else */
::glVertexAttrib2fv(index$ , v$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttrib2fv")));
/* staticif-else end */
}
void glVertexAttrib3f$f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$, const pxcrt::bt_float z$) {
/* staticif empty *//* staticif-else */
::glVertexAttrib3f(index$ , x$ , y$ , z$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttrib3f")));
/* staticif-else end */
}
void glVertexAttrib3fv$f(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$) {
/* staticif empty *//* staticif-else */
::glVertexAttrib3fv(index$ , v$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttrib3fv")));
/* staticif-else end */
}
void glVertexAttrib4f$f(const pxcrt::bt_uint index$, const pxcrt::bt_float x$, const pxcrt::bt_float y$, const pxcrt::bt_float z$, const pxcrt::bt_float w$) {
/* staticif empty *//* staticif-else */
::glVertexAttrib4f(index$ , x$ , y$ , z$ , w$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttrib4f")));
/* staticif-else end */
}
void glVertexAttrib4fv$f(const pxcrt::bt_uint index$, const pxcrt::crawptr< pxcrt::bt_float >::type v$) {
/* staticif empty *//* staticif-else */
::glVertexAttrib4fv(index$ , v$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttrib4fv")));
/* staticif-else end */
}
void glVertexAttribPointer$f(const pxcrt::bt_uint index$, const pxcrt::bt_int size$, const GLenum type$, const pxcrt::bt_uchar normalized$, const pxcrt::bt_int stride$, const pxcrt::crawptr< void >::type pointer$) {
/* staticif empty *//* staticif-else */
::glVertexAttribPointer(index$ , size$ , type$ , normalized$ , stride$ , pointer$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glVertexAttribPointer")));
/* staticif-else end */
}
void glViewport$f(const pxcrt::bt_int x$, const pxcrt::bt_int y$, const pxcrt::bt_int width$, const pxcrt::bt_int height$) {
/* staticif empty *//* staticif-else */
::glViewport(x$ , y$ , width$ , height$);
::GL$n::base$n::gl_check_error_if$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("glViewport")));
/* staticif-else end */
}
};}; /* namespace GL::compat */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< pxcrt::crawptr< pxcrt::bt_char >::type,1LL > make_farray_func$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$1$li$r$(const pxcrt::crawptr< pxcrt::bt_char >::type& a0$) {
::pxcrt::farray< pxcrt::crawptr< pxcrt::bt_char >::type,1LL > arr$ = ::pxcrt::farray< pxcrt::crawptr< pxcrt::bt_char >::type,1LL >();
arr$[pxcrt::bt_size_t((0LL))] = a0$;
return arr$;
}
};}; /* namespace container::array */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_size_t > c$ = numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_size_t >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< pxcrt::bt_int,1LL > make_farray_func$f$p$meta$n$$int$t$q$1$li$r$(const pxcrt::bt_int& a0$) {
::pxcrt::farray< pxcrt::bt_int,1LL > arr$ = ::pxcrt::farray< pxcrt::bt_int,1LL >();
arr$[pxcrt::bt_size_t((0LL))] = a0$;
return arr$;
}
};}; /* namespace container::array */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_int > c$ = numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_int >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a3$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a3$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a2$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , a3$);
 }
}
return s$;
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(const pxcrt::bt_int& a0$, const pxcrt::bt_int& a1$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a2$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a0$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , a2$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a1$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a2$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a2$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$uint$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , a2$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uint$t$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::positional$n::integral_to_positional$f$p$meta$n$$uint$t$q$10$li$r$(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$uint$t$q$10$li$r$(pxcrt::bt_uint v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
/* staticif empty */
if (v$ == pxcrt::bt_uint((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 48U);
 return;
}
pxcrt::bt_size_t pos0$ = buf$.size();
if (v$ < pxcrt::bt_uint((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 45U);
 pos0$ += pxcrt::bt_size_t(1LL);
 while (v$ != pxcrt::bt_uint((0LL))) {
  pxcrt::bt_uint rem$ = v$ % pxcrt::bt_uint(10LL);
  v$ /= pxcrt::bt_uint(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(-rem$) + 48U);
  }
 }
} else {
 while (v$ != pxcrt::bt_uint((0LL))) {
  pxcrt::bt_uint rem$ = v$ % pxcrt::bt_uint(10LL);
  v$ /= pxcrt::bt_uint(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(rem$) + 48U);
  }
 }
}
::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::bt_slice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (buf$).get()), pos0$, buf$.size()));
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_uint > c$ = numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_uint >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_cslice< pxcrt::bt_uchar > >(s$ , a1$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$uint$t$r$(a1$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > make_ptr$f$p$pgl3d$$glvertex$n$$vertices$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$) {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::glvertex$n::vertices$s(a0$);
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glresource$n { 
auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$() : hnd$(pxcrt::bt_uint(0LL)) {
}
inline pxcrt::bt_uint auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$::get$f() const {
return hnd$.value;
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$::generate$f() {
reset$f();
{
 ::GL$n::compat$n::glGenBuffers$f(1LL , pxcrt::address< pxcrt::bt_uint >(hnd$.value));
}
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$::reset$f() {
if (hnd$.value > pxcrt::bt_uint((0LL))) {
 {
  ::GL$n::compat$n::glDeleteBuffers$f(1LL , pxcrt::caddress< pxcrt::bt_uint >(hnd$.value));
 }
 hnd$.value = pxcrt::bt_uint((0LL));
}
}
inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$::~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenBuffers$f$q$GL$$compat$n$$glDeleteBuffers$f$r$() PXC_NOTHROW {
try {
 reset$f();
} catch (...) { ::abort(); }
}
};}; /* namespace pgl3d::glresource */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_set$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const pxcrt::bt_size_t& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_set$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_set$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const pxcrt::bt_size_t& a0$) {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::glbuffer$n::vertex_set$s(a0$);
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_set$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace exception$n { 
runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$::runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$vertex__buffer_2eget__id__by__name$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{vertex_buffer.get_id_by_name}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace numeric$n { namespace cast$n { 
static inline GLsizeiptr static_cast$f$p$GL$$base$n$$GLsizeiptr$s$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$) {
/* staticif */
numeric::static_cast_impl< GLsizeiptr,pxcrt::bt_size_t > c$ = numeric::static_cast_impl< GLsizeiptr,pxcrt::bt_size_t >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace exception$n { 
runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$::runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$vertex__buffer__draw__elems$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{vertex_buffer_draw_elems}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$::runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$vertex__buffer__draw__elems__instanced$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{vertex_buffer_draw_elems_instanced}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > make_ptr$f$p$pgl3d$$glbuffer$n$$async_buffer$s$q$m$ll$r$() {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$async_buffer$s$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$async_buffer$s$r$$q$m$ll$r$() {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::glbuffer$n::async_buffer$s();
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::async_buffer$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace operator$n { 
static inline pxcrt::rawptr< pxcrt::bt_float >::type add$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$r$(const pxcrt::rawptr< pxcrt::bt_float >::type& x$, const pxcrt::bt_size_t& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::rawptr< pxcrt::bt_float >::type binop$f$p$pointer$$raw$n$$rawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(const pxcrt::rawptr< pxcrt::bt_float >::type& x$, const pxcrt::bt_size_t& y$) {
/* staticif */
return pxcrt::rawptr_add< pxcrt::rawptr< pxcrt::bt_float >::type,pxcrt::bt_size_t >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_size_t,pxcrt::bt_size_t > c$ = numeric::static_cast_impl< pxcrt::bt_size_t,pxcrt::bt_size_t >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace callable$n { 
callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(const pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& p0$) : p$(p0$) {
}
inline void callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$::__call$f(const pxcrt::bt_bool& a0$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& a1$, const ::pgl3d$n::glgeometry$n::mesh_index$s& a2$) const {
return ((*(pxcrt::rcptr< ::callable$n::callable$i$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >(p$)))).__call$f(a0$ , a1$ , a2$);
}
}; /* namespace callable */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > init_triangles_shader$f$p$1$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pgl3d$n::drawer$n::triangles_shader_vert$f(g$ , 1LL != pxcrt::bt_long((0LL)) , opt$);
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pgl3d$n::drawer$n::triangles_shader_frag$f(g$ , 1LL != pxcrt::bt_long((0LL)) , opt$);
return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("model_matrix"));
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_view_projection_matrix$(-1LL), u_sampler$(-1LL), u_sampler_tilemap$(-1LL), u_sampler_sm$(-1LL), u_camera_pos$(-1LL), u_light_pos$(-1LL), u_light_on$(-1LL), u_shadowmap_vp$(-1LL), i_model_matrix$(-1LL), v_instance_id$(-1LL), v_position$(-1LL), v_normal$(-1LL), v_tangent$(-1LL), v_uvw$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_view_projection_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
::GL$n::compat$n::glGetError$f();
if (u_view_projection_matrix$ < (0LL)) {
 u_view_projection_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
}
u_sampler$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler")));
::GL$n::compat$n::glGetError$f();
if (u_sampler$ < (0LL)) {
 u_sampler$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("sampler") , u_sampler$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("sampler") , u_sampler$);
}
u_sampler_tilemap$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler_tilemap")));
::GL$n::compat$n::glGetError$f();
if (u_sampler_tilemap$ < (0LL)) {
 u_sampler_tilemap$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler_tilemap")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("sampler_tilemap") , u_sampler_tilemap$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("sampler_tilemap") , u_sampler_tilemap$);
}
u_sampler_sm$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler_sm")));
::GL$n::compat$n::glGetError$f();
if (u_sampler_sm$ < (0LL)) {
 u_sampler_sm$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler_sm")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("sampler_sm") , u_sampler_sm$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("sampler_sm") , u_sampler_sm$);
}
u_camera_pos$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("camera_pos")));
::GL$n::compat$n::glGetError$f();
if (u_camera_pos$ < (0LL)) {
 u_camera_pos$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("camera_pos")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("camera_pos") , u_camera_pos$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("camera_pos") , u_camera_pos$);
}
u_light_pos$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("light_pos")));
::GL$n::compat$n::glGetError$f();
if (u_light_pos$ < (0LL)) {
 u_light_pos$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("light_pos")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("light_pos") , u_light_pos$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("light_pos") , u_light_pos$);
}
u_light_on$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("light_on")));
::GL$n::compat$n::glGetError$f();
if (u_light_on$ < (0LL)) {
 u_light_on$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("light_on")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("light_on") , u_light_on$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("light_on") , u_light_on$);
}
u_shadowmap_vp$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("shadowmap_vp")));
::GL$n::compat$n::glGetError$f();
if (u_shadowmap_vp$ < (0LL)) {
 u_shadowmap_vp$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("shadowmap_vp")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("shadowmap_vp") , u_shadowmap_vp$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("shadowmap_vp") , u_shadowmap_vp$);
}
i_model_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
::GL$n::compat$n::glGetError$f();
if (i_model_matrix$ < (0LL)) {
 i_model_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
}
v_instance_id$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("instance_id")));
::GL$n::compat$n::glGetError$f();
v_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position")));
::GL$n::compat$n::glGetError$f();
v_normal$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("normal")));
::GL$n::compat$n::glGetError$f();
v_tangent$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("tangent")));
::GL$n::compat$n::glGetError$f();
v_uvw$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("uvw")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$.model_matrix$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(16LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(i_model_matrix$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_instance_id$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_normal$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_tangent$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_uvw$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_instance_id$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
}
if (v_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
}
if (v_normal$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
}
if (v_tangent$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
}
if (v_uvw$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
}
}
};}; /* namespace pgl3d::glshader */
namespace exception$n { 
runtime_error_template$s$p$create__program$ls$r$::runtime_error_template$s$p$create__program$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$create__program$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{create_program}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::crawptr< pxcrt::bt_char >::type strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_strlit& x$) {
return pxcrt::crawptr_to_ccharptr< pxcrt::bt_uchar >(pxcrt::strlit_to_crawptr(x$));
}
};}; /* namespace pointer::raw */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_strlit& a1$, const pxcrt::bt_int& a2$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_strlit& a1$, const pxcrt::bt_int& a2$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a1$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a2$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace exception$n { 
runtime_error_template$s$p$enable__instance__attrib__array$ls$r$::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$enable__instance__attrib__array$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{enable_instance_attrib_array}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
runtime_error_template$s$p$instance__attrib__pointer$ls$r$::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$instance__attrib__pointer$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{instance_attrib_pointer}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace pgl3d$n { namespace glshader$n { 
static inline void set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(pxcrt::bt_int loc$, const ::pxcrt::bt_cslice< pxcrt::bt_float >& value$, pxcrt::bt_size_t offset$, pxcrt::bt_int cnt$) {
/* staticif */
::GL$n::compat$n::glUniformMatrix4fv$f(loc$ , cnt$ , pxcrt::bt_uchar((0LL)) , (::operator$n::add$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$r$(pxcrt::cslice_to_crawptr< pxcrt::bt_float >(value$) , offset$)));
/* staticif end */
}
};}; /* namespace pgl3d::glshader */
namespace operator$n { 
static inline pxcrt::crawptr< pxcrt::bt_float >::type add$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$r$(const pxcrt::crawptr< pxcrt::bt_float >::type& x$, const pxcrt::bt_size_t& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::crawptr< pxcrt::bt_float >::type binop$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$q$add$ls$r$(const pxcrt::crawptr< pxcrt::bt_float >::type& x$, const pxcrt::bt_size_t& y$) {
/* staticif */
return pxcrt::rawptr_add< pxcrt::crawptr< pxcrt::bt_float >::type,pxcrt::bt_size_t >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uint,pxcrt::bt_int > c$ = numeric::static_cast_impl< pxcrt::bt_uint,pxcrt::bt_int >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > init_zprepass_shader$f$p$1$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat4 view_projection_matrix;\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mat4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , 1LL != pxcrt::bt_long((0LL)) , true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 position;\012")))));
if (opt$ != (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
}
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vec4 gpos4 = ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , 1LL != pxcrt::bt_long((0LL)) , true)))));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  * vec4(position, 1.0);\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_Position = view_projection_matrix * gpos4;\012")));
if (opt$ != (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_uvw = uvw;\012")));
}
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
if (opt$ == (0LL)) {
 f$ = g$.empty_shader_frag$f();
} else {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 if (g$.enable_normalmapping$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tile_size = 32.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tilemap_size = 128.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tiletex_size = 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv0 = vary_uvw.xy / vary_uvw.z;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tm = floor(uv0);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tmfr = uv0 - uv_tm;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 p = uv_tmfr - 0.5;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("if (dot(p, p) < 0.125) { discard; }\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
}
return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("model_matrix"));
}
};}; /* namespace pgl3d::drawer */
namespace operator$n { 
static inline void adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$) {
/* staticif empty *//* staticif-else */
::operator$n::binopa$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline void binopa$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$q$add$ls$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::bt_strlit& y$) {
/* staticif */
::container$n::array$n::array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(x$ , y$);
/* staticif end */
}
static inline void adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) {
/* staticif empty *//* staticif-else */
::operator$n::binopa$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline void binopa$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) {
/* staticif */
::container$n::array$n::array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline void array___adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) {
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(x$ , y$);
}
};}; /* namespace container::array */
namespace operator$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > binop$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$add$ls$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) {
/* staticif */
return ::container$n::array$n::array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > array___add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::bt_strlit& x$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& y$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > r$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(x$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(r$ , y$);
return r$;
}
};}; /* namespace container::array */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_view_projection_matrix$(-1LL), i_model_matrix$(-1LL), v_instance_id$(-1LL), v_position$(-1LL), v_normal$(-1LL), v_tangent$(-1LL), v_uvw$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_view_projection_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
::GL$n::compat$n::glGetError$f();
if (u_view_projection_matrix$ < (0LL)) {
 u_view_projection_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
}
i_model_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
::GL$n::compat$n::glGetError$f();
if (i_model_matrix$ < (0LL)) {
 i_model_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
}
v_instance_id$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("instance_id")));
::GL$n::compat$n::glGetError$f();
v_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position")));
::GL$n::compat$n::glGetError$f();
v_normal$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("normal")));
::GL$n::compat$n::glGetError$f();
v_tangent$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("tangent")));
::GL$n::compat$n::glGetError$f();
v_uvw$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("uvw")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$.model_matrix$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(16LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(i_model_matrix$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_instance_id$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_normal$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_tangent$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_uvw$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_instance_id$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
}
if (v_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
}
if (v_normal$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
}
if (v_tangent$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
}
if (v_uvw$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
}
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > init_shadowmap_shader$f$p$1$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat4 shadowmap_vp;\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mat4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , 1LL != pxcrt::bt_long((0LL)) , true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 position;\012")))));
if (opt$ != (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
}
if (!g$.enable_depth_texture$) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec4 vary_smpos;\012")))));
}
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec4 p = shadowmap_vp * ")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , 1LL != pxcrt::bt_long((0LL)) , true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  * vec4(position, 1.0);\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_Position = p;\012")));
if (!g$.enable_depth_texture$) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_smpos = p;\012")));
}
if (opt$ != (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_uvw = uvw;\012")));
}
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
if (g$.enable_depth_texture$ && opt$ == (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , g$.empty_shader_frag$f()));
} else {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 if (opt$ != (0LL)) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
 }
 if (!g$.enable_depth_texture$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec4 vary_smpos;\012")))));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.decl_fragcolor$f()));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 if (opt$ != (0LL)) {
  if (g$.enable_normalmapping$) {
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tile_size = 32.0;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tilemap_size = 128.0;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tiletex_size = 256.0;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv0 = vary_uvw.xy / vary_uvw.z;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tm = floor(uv0);\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tmfr = uv0 - uv_tm;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uvp = uv_tmfr - 0.5;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("if (dot(uvp, uvp) < 0.125) { discard; }\012")));
  }
 }
 if (!g$.enable_depth_texture$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  vec4 p = vary_smpos;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float pz = (p.z/p.w + 1.0) / 2.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float z = pz * 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float z0 = floor(z);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  z = (z - z0) * 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float z1 = floor(z);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  z = (z - z1) * 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float z2 = floor(z);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.fragcolor$f() , pxcrt::bt_strlit("= vec4(z0/255.0, z1/255.0, z2/255.0, 1.0);\012")))));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
}
return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("model_matrix"));
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_shadowmap_vp$(-1LL), i_model_matrix$(-1LL), v_instance_id$(-1LL), v_position$(-1LL), v_normal$(-1LL), v_tangent$(-1LL), v_uvw$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_shadowmap_vp$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("shadowmap_vp")));
::GL$n::compat$n::glGetError$f();
if (u_shadowmap_vp$ < (0LL)) {
 u_shadowmap_vp$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("shadowmap_vp")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("shadowmap_vp") , u_shadowmap_vp$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("shadowmap_vp") , u_shadowmap_vp$);
}
i_model_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
::GL$n::compat$n::glGetError$f();
if (i_model_matrix$ < (0LL)) {
 i_model_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
}
v_instance_id$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("instance_id")));
::GL$n::compat$n::glGetError$f();
v_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position")));
::GL$n::compat$n::glGetError$f();
v_normal$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("normal")));
::GL$n::compat$n::glGetError$f();
v_tangent$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("tangent")));
::GL$n::compat$n::glGetError$f();
v_uvw$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("uvw")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$.model_matrix$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(16LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(i_model_matrix$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_instance_id$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_normal$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_tangent$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_uvw$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_instance_id$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
}
if (v_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
}
if (v_normal$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
}
if (v_tangent$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
}
if (v_uvw$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
}
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > to_string$f$p$meta$n$$int$t$r$(const pxcrt::bt_int& x$) {
/* staticif empty *//* staticif-else */
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(x$ , s$);
return s$;
/* staticif-else end */
}
};};}; /* namespace text::string::serialize */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_triangles$f$r$() {
/* staticif empty */
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type r$ = pxcrt::tfuncptr_null< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >();
r$ = &(::pgl3d$n::drawer$n::prepare_instance_data_triangles$f);
return r$;
}
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(13LL) , points_mode$ , is_sub$);
}
};}; /* namespace pgl3d::drawer */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(const pxcrt::bt_long& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_size_t,pxcrt::bt_long > c$ = numeric::static_cast_impl< pxcrt::bt_size_t,pxcrt::bt_long >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(const pxcrt::bt_size_t& a0$, pxcrt::bt_bool& a1$, pxcrt::bt_bool& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_buffer$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_buffer$s$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(const pxcrt::bt_size_t& a0$, pxcrt::bt_bool& a1$, pxcrt::bt_bool& a2$) {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::glbuffer$n::vertex_buffer$s(a0$ , a1$ , a2$);
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_polygon_filler$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
return ::callable$n::make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$(vptr$);
}
static inline void dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
::pgl3d$n::drawer$n::dgf_fill_tattr_internal$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(vptr$ , flat_flag$ , poly$ , mp$);
}
static inline void dgf_fill_tattr_internal$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
const pxcrt::bt_size_t sz$ = poly$.size();
if (sz$ < pxcrt::bt_size_t(3LL)) {
 return;
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type nor$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tang$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
if (flat_flag$) {
 nor$ = ::pgl3d$n::glgeometry$n::normal_from_poly$f(poly$);
 tang$ = glm::normalize< pxcrt::bt_float >(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$))));
}
::pgl3d$n::drawer$n::triangles_vertex_attributes$s t0 = ::pgl3d$n::drawer$n::triangles_vertex_attributes$s();
::pxcrt::darrayst< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s > vtxs$((sz$), (t0), alloca(sizeof(::pgl3d$n::drawer$n::triangles_vertex_attributes$s) * (sz$)));
for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < sz$; ++i$) {
 ::pgl3d$n::drawer$n::triangles_vertex_attributes$s& v$ = vtxs$[i$];
 v$.position$ = poly$[i$].pos$;
 if (flat_flag$) {
  v$.normal$ = nor$;
  v$.tangent$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(tang$.x , tang$.y , tang$.z);
 } else {
  v$.normal$ = poly$[i$].nor$;
  v$.tangent$ = poly$[i$].tan$;
 }
 v$.uvw$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
}
if (sz$ == pxcrt::bt_size_t(4LL)) {
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c0$ = ((::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t((0LL))].pos$ , poly$[pxcrt::bt_size_t(1LL)].pos$)));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c1$ = ((::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t(2LL)].pos$)));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c2$ = ((::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(3LL)].pos$)));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c3$ = ((::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(3LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$)));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c02$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(c2$ , c0$));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c13$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(c3$ , c1$));
 if (numeric::fabs< pxcrt::bt_float >(pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c02$ , c13$)) < pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c02$) * pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c13$) * pxcrt::bt_float(0.05)) {
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v01$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v23$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(3LL)].pos$ , poly$[pxcrt::bt_size_t(2LL)].pos$));
  const pxcrt::bt_float dotv0123$ = pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v01$ , (::operator$n::minus$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(v23$)));
  const pxcrt::bt_float lenv01$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v01$);
  const pxcrt::bt_float lenv23$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v23$);
  const pxcrt::bt_float cosv0123$ = dotv0123$ / (lenv01$ * lenv23$);
  const pxcrt::bt_float ratv2301$ = lenv23$ / lenv01$;
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v12$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(1LL)].pos$));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v30$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t((0LL))].pos$ , poly$[pxcrt::bt_size_t(3LL)].pos$));
  const pxcrt::bt_float dotv1230$ = pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v12$ , (::operator$n::minus$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(v30$)));
  const pxcrt::bt_float lenv12$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v12$);
  const pxcrt::bt_float lenv30$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v30$);
  const pxcrt::bt_float cosv1230$ = dotv1230$ / (lenv12$ * lenv30$);
  const pxcrt::bt_float ratv3012$ = lenv30$ / lenv12$;
  const pxcrt::bt_float lenv0123$ = lenv01$ + lenv23$;
  const pxcrt::bt_float lenv1230$ = lenv12$ + lenv30$;
  pxcrt::glmpx::tvec2< pxcrt::bt_float >::type co$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(32.0f , 32.0f);
  co$.x = ::ordered$n::max$f$p$meta$n$$float$t$r$(4.0f , ::ordered$n::min$f$p$meta$n$$float$t$r$(128.0f , numeric::floor< pxcrt::bt_float >(lenv0123$)));
  co$.y = ::ordered$n::max$f$p$meta$n$$float$t$r$(4.0f , ::ordered$n::min$f$p$meta$n$$float$t$r$(128.0f , numeric::floor< pxcrt::bt_float >(lenv1230$)));
  if (cosv0123$ > cosv1230$) {
   if (ratv2301$ > pxcrt::bt_float(0.25) && ratv2301$ < pxcrt::bt_float(4.0) && cosv0123$ > 0.95f) {
    vtxs$[pxcrt::bt_size_t((0LL))].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , 0.0f , 1.0f);
    vtxs$[pxcrt::bt_size_t(1LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(co$.x , 0.0f , 1.0f);
    vtxs$[pxcrt::bt_size_t(2LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(co$.x , co$.y , 1.0f);
    vtxs$[pxcrt::bt_size_t(3LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , co$.y , 1.0f);
    if (ratv2301$ > 1.0f) {
     (::operator$n::mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(2LL)].uvw$ , ratv2301$));
     (::operator$n::mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(3LL)].uvw$ , ratv2301$));
    } else if (ratv2301$ < 1.0f) {
     (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t((0LL))].uvw$ , ratv2301$));
     (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(1LL)].uvw$ , ratv2301$));
    }
   }
  } else {
   if (ratv3012$ > pxcrt::bt_float(0.25) && ratv3012$ < pxcrt::bt_float(4.0) && cosv1230$ > 0.95f) {
    vtxs$[pxcrt::bt_size_t((0LL))].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , 0.0f , 1.0f);
    vtxs$[pxcrt::bt_size_t(1LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(co$.x , 0.0f , 1.0f);
    vtxs$[pxcrt::bt_size_t(2LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(co$.x , co$.y , 1.0f);
    vtxs$[pxcrt::bt_size_t(3LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , co$.y , 1.0f);
    if (ratv3012$ > 1.0f) {
     (::operator$n::mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(3LL)].uvw$ , ratv3012$));
     (::operator$n::mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t((0LL))].uvw$ , ratv3012$));
    } else if (ratv3012$ < 1.0f) {
     (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(1LL)].uvw$ , ratv3012$));
     (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(2LL)].uvw$ , ratv3012$));
    }
   }
  }
 }
}
(((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_polygon_distinct$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$(vtxs$);
}
};}; /* namespace pgl3d::drawer */
namespace operator$n { 
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type minus$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$) {
/* staticif empty *//* staticif-else */
return ::operator$n::unaryop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$minus$ls$q$m$lm$p$t$r$meta$$family$n$$is_numeric_family$a$p$$n$$t$x1$q$meta$n$$family$s$p$$n$$t$x1$r$$r$$r$(x$);
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type unaryop$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$minus$ls$q$m$lm$p$t$r$meta$$family$n$$is_numeric_family$a$p$$n$$t$x1$q$meta$n$$family$s$p$$n$$t$x1$r$$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$) {
/* staticif */
return pxcrt::glmpx::op_minus< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(x$);
/* staticif end */
}
}; /* namespace operator */
namespace ordered$n { 
static inline pxcrt::bt_float min$f$p$meta$n$$float$t$r$(const pxcrt::bt_float& x$, const pxcrt::bt_float& y$) {
return x$ < y$ ? x$ : y$;
}
}; /* namespace ordered */
namespace operator$n { 
static inline void mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
/* staticif empty *//* staticif-else */
::operator$n::binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline void binopa$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
/* staticif */
x$ = pxcrt::glmpx::op_mul< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type,pxcrt::bt_float,pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace pgl3d$n { namespace glvertex$n { 
inline void vertices$s::push_polygon_distinct$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& vals$19) {
if (num_float_per_vertex$ != pxcrt::bt_size_t(13LL)) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::split$n::string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$long$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("triangles_vertex_attributes") , 13LL , num_float_per_vertex$)).get_crange())));
}
{
 has_instance_id$ = true;
}
const pxcrt::bt_size_t first_id$19$pgl3d$$glvertex$ns1 = vertex_values$.size() / pxcrt::bt_size_t(13LL);
{
 const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& ag$fe = (vals$19);
 const size_t sz$fe = ag$fe.size();
 const ::pgl3d$n::drawer$n::triangles_vertex_attributes$s *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const ::pgl3d$n::drawer$n::triangles_vertex_attributes$s& val$ = ar$fe[i$];
  {
   ::pgl3d$n::glvertex$n::push_float$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(vertex_values$ , val$);
   {
    ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(positions$ , pxcrt::glmpx::tvec3_to_cslice< pxcrt::bt_float >(val$.position$));
   }
  }
 }
}
/* staticif empty */{
 ::pxcrt::pxcvarray< pxcrt::bt_size_t > ia$31$pgl3d$$glvertex$ns1 = ::pxcrt::pxcvarray< pxcrt::bt_size_t >();
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_size_t >,pxcrt::bt_uint >(ia$31$pgl3d$$glvertex$ns1 , vals$19.size() , 0U);
 {
  ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ag$fe = (ia$31$pgl3d$$glvertex$ns1);
  ::pxcrt::pxcvarray< pxcrt::bt_size_t >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_size_t > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  pxcrt::bt_size_t *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   pxcrt::bt_size_t& v$ = ar$fe[i$];
   {
    v$ = i$;
   }
  }
 }
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type cross_sum$31$pgl3d$$glvertex$ns1 = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < ia$31$pgl3d$$glvertex$ns1.size(); ++i$) {
  (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(cross_sum$31$pgl3d$$glvertex$ns1 , ::pgl3d$n::glvertex$n::cross_one$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(vals$19, ia$31$pgl3d$$glvertex$ns1 , i$)));
 }
 while (ia$31$pgl3d$$glvertex$ns1.size() >= pxcrt::bt_size_t(3LL)) {
  pxcrt::bt_size_t i$38$pgl3d$$glvertex$ns1 = ia$31$pgl3d$$glvertex$ns1.size() - pxcrt::bt_size_t(1LL);
  while (true) {
   if (::pgl3d$n::glvertex$n::removable$f39$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(i$38$pgl3d$$glvertex$ns1, cross_sum$31$pgl3d$$glvertex$ns1, vals$19, ia$31$pgl3d$$glvertex$ns1)) {
    ::pgl3d$n::glvertex$n::push_one$f39$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(i$38$pgl3d$$glvertex$ns1, elements$, first_id$19$pgl3d$$glvertex$ns1, ia$31$pgl3d$$glvertex$ns1);
    ::pxcrt::array_erase< ::pxcrt::pxcvarray< pxcrt::bt_size_t > >(ia$31$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(1LL));
    break;
   }
   if (i$38$pgl3d$$glvertex$ns1 == pxcrt::bt_size_t((0LL))) {
    ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$1$li$r$$r$$r$(pxcrt::bt_strlit("warning: split_convex failed") , ia$31$pgl3d$$glvertex$ns1.size() , vals$19.size() , vals$19 , ia$31$pgl3d$$glvertex$ns1);
    i$38$pgl3d$$glvertex$ns1 = ia$31$pgl3d$$glvertex$ns1.size() - pxcrt::bt_size_t(1LL);
    ::pgl3d$n::glvertex$n::push_one$f39$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(i$38$pgl3d$$glvertex$ns1, elements$, first_id$19$pgl3d$$glvertex$ns1, ia$31$pgl3d$$glvertex$ns1);
    ::pxcrt::array_erase< ::pxcrt::pxcvarray< pxcrt::bt_size_t > >(ia$31$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(1LL));
   }
   --i$38$pgl3d$$glvertex$ns1;
  }
 }
}
}
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1) {
/* staticif empty *//* staticif-else */
for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < vals$19.size() - pxcrt::bt_size_t(2LL); ++i$) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(1LL)));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(2LL)));
}
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& vals$19, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$) {
return vals$19[pxcrt::bt_size_t(pxcrt::get_elem_value(ia$31$pgl3d$$glvertex$ns1,i$))].position$;
}
static inline pxcrt::bt_size_t ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$) {
return (i$ == pxcrt::bt_size_t((0LL))) ? (ia$31$pgl3d$$glvertex$ns1.size() - pxcrt::bt_size_t(1LL)) : (i$ - pxcrt::bt_size_t(1LL));
}
static inline pxcrt::bt_size_t ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$) {
return (i$ != ia$31$pgl3d$$glvertex$ns1.size() - pxcrt::bt_size_t(1LL)) ? (i$ + pxcrt::bt_size_t(1LL)) : pxcrt::bt_size_t(0U);
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type cross_one$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s > const& _0$up, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& _1$up, pxcrt::bt_size_t i$) {
return glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$)))) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$)) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$))));
}
static inline pxcrt::bt_bool removable$f39$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(pxcrt::bt_size_t& i$38$pgl3d$$glvertex$ns1, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& cross_sum$31$pgl3d$$glvertex$ns1, ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s > const& _0$up, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& _1$up) {
const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ci$ = ::pgl3d$n::glvertex$n::cross_one$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$38$pgl3d$$glvertex$ns1);
/* staticif empty */
if (pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(cross_sum$31$pgl3d$$glvertex$ns1 , ci$) <= -0.000001f) {
 return false;
}
pxcrt::bt_size_t j$ = pxcrt::bt_size_t();
for (j$ = ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)); j$ != ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1); j$ = ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , j$)) {
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c0$ = glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$38$pgl3d$$glvertex$ns1) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)))) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , j$) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$38$pgl3d$$glvertex$ns1))));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c1$ = glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$38$pgl3d$$glvertex$ns1))) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , j$) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)))));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c2$ = glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)))) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , j$) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)))));
 const pxcrt::bt_float s0$ = pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c0$ , c1$);
 const pxcrt::bt_float s1$ = pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c0$ , c2$);
 if (s0$ > 0.0f && s1$ > 0.0f) {
  /* staticif empty */
  return false;
 }
}
return true;
}
static inline void push_one$f39$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(pxcrt::bt_size_t& i$38$pgl3d$$glvertex$ns1, ::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1) {
/* staticif empty */
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(pxcrt::get_elem_value(ia$31$pgl3d$$glvertex$ns1,::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(ia$31$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1)))));
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(pxcrt::get_elem_value(ia$31$pgl3d$$glvertex$ns1,i$38$pgl3d$$glvertex$ns1))));
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(pxcrt::get_elem_value(ia$31$pgl3d$$glvertex$ns1,::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$q$1$li$r$$(ia$31$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1)))));
}
};}; /* namespace pgl3d::glvertex */
namespace exception$n { 
runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$::runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{vertices::push_polygon_distinct}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$long$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_long& a1$, const pxcrt::bt_size_t& a2$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$long$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a2$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$long$t$r$(const pxcrt::bt_long& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$long$t$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$long$t$r$(const pxcrt::bt_long& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::positional$n::integral_to_positional$f$p$meta$n$$long$t$q$10$li$r$(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$long$t$q$10$li$r$(pxcrt::bt_long v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
/* staticif empty */
if (v$ == pxcrt::bt_long((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 48U);
 return;
}
pxcrt::bt_size_t pos0$ = buf$.size();
if (v$ < pxcrt::bt_long((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 45U);
 pos0$ += pxcrt::bt_size_t(1LL);
 while (v$ != pxcrt::bt_long((0LL))) {
  pxcrt::bt_long rem$ = v$ % 10LL;
  v$ /= 10LL;
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$long$t$r$(-rem$) + 48U);
  }
 }
} else {
 while (v$ != pxcrt::bt_long((0LL))) {
  pxcrt::bt_long rem$ = v$ % 10LL;
  v$ /= 10LL;
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$long$t$r$(rem$) + 48U);
  }
 }
}
::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::bt_slice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (buf$).get()), pos0$, buf$.size()));
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$long$t$r$(const pxcrt::bt_long& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_long > c$ = numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_long >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glvertex$n { 
static inline void push_float$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_vertex_attributes$s& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.instance_id$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.position$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.normal$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.tangent$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.uvw$);
/* staticif-else end */
}
static inline void push_float$f$p$meta$n$$float$t$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const pxcrt::bt_float& v$) {
/* staticif */
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_float >,pxcrt::bt_float >(arr$ , v$);
/* staticif end */
}
static inline void push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.x);
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.y);
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.z);
/* staticif-else end */
}
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& a3$, const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& a4$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$ , a4$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& a3$, const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& a4$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a2$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$(a3$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$r$(a4$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
{
 const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles_vertex_attributes$s >& ag$fe = (x$);
 const size_t sz$fe = ag$fe.size();
 const ::pgl3d$n::drawer$n::triangles_vertex_attributes$s *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const ::pgl3d$n::drawer$n::triangles_vertex_attributes$s& v$ = ar$fe[i$];
  {
   if (i$ != pxcrt::bt_size_t((0LL))) {
    ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
   }
   ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(v$ , o$);
  }
 }
}
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_char$f$p$123$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$) {
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_long >(v$ , 123LL);
}
static inline void string_append_char$f$p$44$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$) {
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_long >(v$ , 44LL);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(const ::pgl3d$n::drawer$n::triangles_vertex_attributes$s& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
if ((0LL) != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("instance_id") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$.instance_id$ , o$);
if (1LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("normal") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.normal$ , o$);
if (2LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.position$ , o$);
if (3LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("tangent") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.tangent$ , o$);
if (4LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("uvw") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.uvw$ , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_noesc$f$p$container$$array$n$$strlit$s$r$(const ::pxcrt::bt_strlit& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$) {
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(v$ , x$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(const pxcrt::bt_float& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::positional$n::fp_to_decimal$f$p$meta$n$$float$t$r$(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void fp_to_decimal$f$p$meta$n$$float$t$r$(pxcrt::bt_float x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
text::fp_to_decimal_float(x$ , buf$);
}
};};}; /* namespace text::string::positional */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
if ((0LL) != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("x") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$.x , o$);
if (1LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("y") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$.y , o$);
if (2LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("z") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$.z , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_char$f$p$125$li$r$(::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$) {
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_long >(v$ , 125LL);
}
static inline void serialize_to_string$f$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
{
 const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ag$fe = (x$);
 ::pxcrt::pxcvarray< pxcrt::bt_size_t >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_size_t > > ag$fg(ag$fe);
 const size_t sz$fe = ag$fe.size();
 const pxcrt::bt_size_t *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const pxcrt::bt_size_t& v$ = ar$fe[i$];
  {
   if (i$ != pxcrt::bt_size_t((0LL))) {
    ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
   }
   ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$size_t$t$r$(v$ , o$);
  }
 }
}
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(vptr$));
}
callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) : count$z(1), fld$(vptr$) {
}
inline void callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$::__call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::drawer$n::dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$(fld$._0$ , flat_flag$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$m$ll$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) : _0$(a0$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles_vertex_attributes$s$r$$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< pxcrt::bt_float,4LL > make_farray_func$f$p$meta$n$$float$t$q$4$li$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_float& a2$, const pxcrt::bt_float& a3$) {
::pxcrt::farray< pxcrt::bt_float,4LL > arr$ = ::pxcrt::farray< pxcrt::bt_float,4LL >();
arr$[pxcrt::bt_size_t((0LL))] = a0$;
arr$[pxcrt::bt_size_t(1LL)] = a1$;
arr$[pxcrt::bt_size_t(2LL)] = a2$;
arr$[pxcrt::bt_size_t(3LL)] = a3$;
return arr$;
}
};}; /* namespace container::array */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > init_triangles_shader$f$p$0$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pgl3d$n::drawer$n::triangles_shader_vert$f(g$ , 0LL != pxcrt::bt_long((0LL)) , opt$);
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pgl3d$n::drawer$n::triangles_shader_frag$f(g$ , 0LL != pxcrt::bt_long((0LL)) , opt$);
return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("model_matrix"));
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_view_projection_matrix$(-1LL), u_sampler$(-1LL), u_sampler_tilemap$(-1LL), u_sampler_sm$(-1LL), u_camera_pos$(-1LL), u_light_pos$(-1LL), u_light_on$(-1LL), u_shadowmap_vp$(-1LL), i_model_matrix$(-1LL), v_position$(-1LL), v_normal$(-1LL), v_tangent$(-1LL), v_uvw$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_view_projection_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
::GL$n::compat$n::glGetError$f();
if (u_view_projection_matrix$ < (0LL)) {
 u_view_projection_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
}
u_sampler$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler")));
::GL$n::compat$n::glGetError$f();
if (u_sampler$ < (0LL)) {
 u_sampler$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("sampler") , u_sampler$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("sampler") , u_sampler$);
}
u_sampler_tilemap$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler_tilemap")));
::GL$n::compat$n::glGetError$f();
if (u_sampler_tilemap$ < (0LL)) {
 u_sampler_tilemap$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler_tilemap")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("sampler_tilemap") , u_sampler_tilemap$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("sampler_tilemap") , u_sampler_tilemap$);
}
u_sampler_sm$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler_sm")));
::GL$n::compat$n::glGetError$f();
if (u_sampler_sm$ < (0LL)) {
 u_sampler_sm$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler_sm")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("sampler_sm") , u_sampler_sm$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("sampler_sm") , u_sampler_sm$);
}
u_camera_pos$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("camera_pos")));
::GL$n::compat$n::glGetError$f();
if (u_camera_pos$ < (0LL)) {
 u_camera_pos$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("camera_pos")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("camera_pos") , u_camera_pos$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("camera_pos") , u_camera_pos$);
}
u_light_pos$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("light_pos")));
::GL$n::compat$n::glGetError$f();
if (u_light_pos$ < (0LL)) {
 u_light_pos$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("light_pos")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("light_pos") , u_light_pos$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("light_pos") , u_light_pos$);
}
u_light_on$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("light_on")));
::GL$n::compat$n::glGetError$f();
if (u_light_on$ < (0LL)) {
 u_light_on$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("light_on")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("light_on") , u_light_on$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("light_on") , u_light_on$);
}
u_shadowmap_vp$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("shadowmap_vp")));
::GL$n::compat$n::glGetError$f();
if (u_shadowmap_vp$ < (0LL)) {
 u_shadowmap_vp$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("shadowmap_vp")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("shadowmap_vp") , u_shadowmap_vp$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("shadowmap_vp") , u_shadowmap_vp$);
}
i_model_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
::GL$n::compat$n::glGetError$f();
if (i_model_matrix$ < (0LL)) {
 i_model_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
}
v_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position")));
::GL$n::compat$n::glGetError$f();
v_normal$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("normal")));
::GL$n::compat$n::glGetError$f();
v_tangent$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("tangent")));
::GL$n::compat$n::glGetError$f();
v_uvw$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("uvw")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$.model_matrix$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(16LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(i_model_matrix$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_normal$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_tangent$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_uvw$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
}
if (v_normal$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
}
if (v_tangent$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
}
if (v_uvw$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
}
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$triangles_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > init_zprepass_shader$f$p$0$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat4 view_projection_matrix;\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mat4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , 0LL != pxcrt::bt_long((0LL)) , true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 position;\012")))));
if (opt$ != (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
}
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(pxcrt::bt_strlit("vec4 gpos4 = ") , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , 0LL != pxcrt::bt_long((0LL)) , true)))));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  * vec4(position, 1.0);\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_Position = view_projection_matrix * gpos4;\012")));
if (opt$ != (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_uvw = uvw;\012")));
}
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
if (opt$ == (0LL)) {
 f$ = g$.empty_shader_frag$f();
} else {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 if (g$.enable_normalmapping$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tile_size = 32.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tilemap_size = 128.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tiletex_size = 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv0 = vary_uvw.xy / vary_uvw.z;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tm = floor(uv0);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tmfr = uv0 - uv_tm;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 p = uv_tmfr - 0.5;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("if (dot(p, p) < 0.125) { discard; }\012")));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
}
return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("model_matrix"));
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_view_projection_matrix$(-1LL), i_model_matrix$(-1LL), v_position$(-1LL), v_normal$(-1LL), v_tangent$(-1LL), v_uvw$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_view_projection_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
::GL$n::compat$n::glGetError$f();
if (u_view_projection_matrix$ < (0LL)) {
 u_view_projection_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
}
i_model_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
::GL$n::compat$n::glGetError$f();
if (i_model_matrix$ < (0LL)) {
 i_model_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
}
v_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position")));
::GL$n::compat$n::glGetError$f();
v_normal$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("normal")));
::GL$n::compat$n::glGetError$f();
v_tangent$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("tangent")));
::GL$n::compat$n::glGetError$f();
v_uvw$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("uvw")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$.model_matrix$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(16LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(i_model_matrix$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_normal$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_tangent$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_uvw$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
}
if (v_normal$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
}
if (v_tangent$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
}
if (v_uvw$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
}
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$zprepass_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$zprepass2_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > init_shadowmap_shader$f$p$0$li$r$(const ::pgl3d$n::shader_config$n::shader_config$s& g$, pxcrt::bt_int opt$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > v$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , g$.prepend$f()));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("uniform mat4 shadowmap_vp;\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_id$f(true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.decl_instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("mat4")) , ::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , 0LL != pxcrt::bt_long((0LL)) , true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 position;\012")))));
if (opt$ != (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_in$f() , pxcrt::bt_strlit("vec3 uvw;\012")))));
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
}
if (!g$.enable_depth_texture$) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.vert_out$f() , pxcrt::bt_strlit("vec4 vary_smpos;\012")))));
}
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("void main(void) {\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vec4 p = shadowmap_vp * ")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , g$.instance_attr$f(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("model_matrix")) , 0LL != pxcrt::bt_long((0LL)) , true)));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("  * vec4(position, 1.0);\012")));
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("gl_Position = p;\012")));
if (!g$.enable_depth_texture$) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_smpos = p;\012")));
}
if (opt$ != (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("vary_uvw = uvw;\012")));
}
(::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(v$ , pxcrt::bt_strlit("}\012")));
::pxcrt::pxcvarray< pxcrt::bt_uchar > f$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
if (g$.enable_depth_texture$ && opt$ == (0LL)) {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , g$.empty_shader_frag$f()));
} else {
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.prepend$f()));
 if (opt$ != (0LL)) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec3 vary_uvw;\012")))));
 }
 if (!g$.enable_depth_texture$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.frag_in$f() , pxcrt::bt_strlit("vec4 vary_smpos;\012")))));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , g$.decl_fragcolor$f()));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("void main(void) {\012")));
 if (opt$ != (0LL)) {
  if (g$.enable_normalmapping$) {
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tile_size = 32.0;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tilemap_size = 128.0;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("const float tiletex_size = 256.0;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv0 = vary_uvw.xy / vary_uvw.z;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tm = floor(uv0);\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uv_tmfr = uv0 - uv_tm;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("vec2 uvp = uv_tmfr - 0.5;\012")));
   (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("if (dot(uvp, uvp) < 0.125) { discard; }\012")));
  }
 }
 if (!g$.enable_depth_texture$) {
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  vec4 p = vary_smpos;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float pz = (p.z/p.w + 1.0) / 2.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float z = pz * 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float z0 = floor(z);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  z = (z - z0) * 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float z1 = floor(z);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  z = (z - z1) * 256.0;\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("  float z2 = floor(z);\012")));
  (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(f$ , (::operator$n::add$f$p$container$$array$n$$strlit$s$q$container$$array$n$$strlit$s$r$(g$.fragcolor$f() , pxcrt::bt_strlit("= vec4(z0/255.0, z1/255.0, z2/255.0, 1.0);\012")))));
 }
 (::operator$n::adda$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$strlit$s$r$(f$ , pxcrt::bt_strlit("}\012")));
}
return ::pgl3d$n::glshader$n::make_glshader_ptr$f$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (v$).get_crange()) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (f$).get_crange()) , pxcrt::bt_strlit("model_matrix"));
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_shadowmap_vp$(-1LL), i_model_matrix$(-1LL), v_position$(-1LL), v_normal$(-1LL), v_tangent$(-1LL), v_uvw$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_shadowmap_vp$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("shadowmap_vp")));
::GL$n::compat$n::glGetError$f();
if (u_shadowmap_vp$ < (0LL)) {
 u_shadowmap_vp$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("shadowmap_vp")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("shadowmap_vp") , u_shadowmap_vp$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("shadowmap_vp") , u_shadowmap_vp$);
}
i_model_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
::GL$n::compat$n::glGetError$f();
if (i_model_matrix$ < (0LL)) {
 i_model_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
}
v_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position")));
::GL$n::compat$n::glGetError$f();
v_normal$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("normal")));
::GL$n::compat$n::glGetError$f();
v_tangent$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("tangent")));
::GL$n::compat$n::glGetError$f();
v_uvw$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("uvw")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$.model_matrix$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(16LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(i_model_matrix$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_normal$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_tangent$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_uvw$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
}
if (v_normal$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_normal$));
}
if (v_tangent$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_tangent$));
}
if (v_uvw$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_uvw$));
}
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$shadowmap_uniforms$s$q$pgl3d$$drawer$n$$triangles_instance_attributes$s$q$pgl3d$$drawer$n$$shadowmap2_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(12LL) , points_mode$ , is_sub$);
}
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_dgf_polygon_filler$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
return ::callable$n::make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$(vptr$);
}
static inline void dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
::pgl3d$n::drawer$n::dgf_fill_tattr_internal$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(vptr$ , flat_flag$ , poly$ , mp$);
}
static inline void dgf_fill_tattr_internal$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$, pxcrt::bt_bool flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
const pxcrt::bt_size_t sz$ = poly$.size();
if (sz$ < pxcrt::bt_size_t(3LL)) {
 return;
}
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type nor$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
pxcrt::glmpx::tvec3< pxcrt::bt_float >::type tang$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
if (flat_flag$) {
 nor$ = ::pgl3d$n::glgeometry$n::normal_from_poly$f(poly$);
 tang$ = glm::normalize< pxcrt::bt_float >(((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$))));
}
::pgl3d$n::drawer$n::triangles2_vertex_attributes$s t0 = ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s();
::pxcrt::darrayst< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s > vtxs$((sz$), (t0), alloca(sizeof(::pgl3d$n::drawer$n::triangles2_vertex_attributes$s) * (sz$)));
for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < sz$; ++i$) {
 ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s& v$ = vtxs$[i$];
 v$.position$ = poly$[i$].pos$;
 if (flat_flag$) {
  v$.normal$ = nor$;
  v$.tangent$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(tang$.x , tang$.y , tang$.z);
 } else {
  v$.normal$ = poly$[i$].nor$;
  v$.tangent$ = poly$[i$].tan$;
 }
 v$.uvw$ = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
}
if (sz$ == pxcrt::bt_size_t(4LL)) {
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c0$ = ((::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t((0LL))].pos$ , poly$[pxcrt::bt_size_t(1LL)].pos$)));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c1$ = ((::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t(2LL)].pos$)));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c2$ = ((::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(3LL)].pos$)));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c3$ = ((::operator$n::add$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(3LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$)));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c02$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(c2$ , c0$));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c13$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(c3$ , c1$));
 if (numeric::fabs< pxcrt::bt_float >(pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c02$ , c13$)) < pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c02$) * pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c13$) * pxcrt::bt_float(0.05)) {
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v01$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(1LL)].pos$ , poly$[pxcrt::bt_size_t((0LL))].pos$));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v23$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(3LL)].pos$ , poly$[pxcrt::bt_size_t(2LL)].pos$));
  const pxcrt::bt_float dotv0123$ = pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v01$ , (::operator$n::minus$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(v23$)));
  const pxcrt::bt_float lenv01$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v01$);
  const pxcrt::bt_float lenv23$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v23$);
  const pxcrt::bt_float cosv0123$ = dotv0123$ / (lenv01$ * lenv23$);
  const pxcrt::bt_float ratv2301$ = lenv23$ / lenv01$;
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v12$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t(2LL)].pos$ , poly$[pxcrt::bt_size_t(1LL)].pos$));
  const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type v30$ = (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(poly$[pxcrt::bt_size_t((0LL))].pos$ , poly$[pxcrt::bt_size_t(3LL)].pos$));
  const pxcrt::bt_float dotv1230$ = pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v12$ , (::operator$n::minus$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(v30$)));
  const pxcrt::bt_float lenv12$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v12$);
  const pxcrt::bt_float lenv30$ = pxcrt::glmpx::length< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(v30$);
  const pxcrt::bt_float cosv1230$ = dotv1230$ / (lenv12$ * lenv30$);
  const pxcrt::bt_float ratv3012$ = lenv30$ / lenv12$;
  const pxcrt::bt_float lenv0123$ = lenv01$ + lenv23$;
  const pxcrt::bt_float lenv1230$ = lenv12$ + lenv30$;
  pxcrt::glmpx::tvec2< pxcrt::bt_float >::type co$ = pxcrt::glmpx::make_tvec2< pxcrt::bt_float >(32.0f , 32.0f);
  co$.x = ::ordered$n::max$f$p$meta$n$$float$t$r$(4.0f , ::ordered$n::min$f$p$meta$n$$float$t$r$(128.0f , numeric::floor< pxcrt::bt_float >(lenv0123$)));
  co$.y = ::ordered$n::max$f$p$meta$n$$float$t$r$(4.0f , ::ordered$n::min$f$p$meta$n$$float$t$r$(128.0f , numeric::floor< pxcrt::bt_float >(lenv1230$)));
  if (cosv0123$ > cosv1230$) {
   if (ratv2301$ > pxcrt::bt_float(0.25) && ratv2301$ < pxcrt::bt_float(4.0) && cosv0123$ > 0.95f) {
    vtxs$[pxcrt::bt_size_t((0LL))].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , 0.0f , 1.0f);
    vtxs$[pxcrt::bt_size_t(1LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(co$.x , 0.0f , 1.0f);
    vtxs$[pxcrt::bt_size_t(2LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(co$.x , co$.y , 1.0f);
    vtxs$[pxcrt::bt_size_t(3LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , co$.y , 1.0f);
    if (ratv2301$ > 1.0f) {
     (::operator$n::mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(2LL)].uvw$ , ratv2301$));
     (::operator$n::mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(3LL)].uvw$ , ratv2301$));
    } else if (ratv2301$ < 1.0f) {
     (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t((0LL))].uvw$ , ratv2301$));
     (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(1LL)].uvw$ , ratv2301$));
    }
   }
  } else {
   if (ratv3012$ > pxcrt::bt_float(0.25) && ratv3012$ < pxcrt::bt_float(4.0) && cosv1230$ > 0.95f) {
    vtxs$[pxcrt::bt_size_t((0LL))].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , 0.0f , 1.0f);
    vtxs$[pxcrt::bt_size_t(1LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(co$.x , 0.0f , 1.0f);
    vtxs$[pxcrt::bt_size_t(2LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(co$.x , co$.y , 1.0f);
    vtxs$[pxcrt::bt_size_t(3LL)].uvw$ = pxcrt::glmpx::make_tvec3< pxcrt::bt_float >(0.0f , co$.y , 1.0f);
    if (ratv3012$ > 1.0f) {
     (::operator$n::mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(3LL)].uvw$ , ratv3012$));
     (::operator$n::mula$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t((0LL))].uvw$ , ratv3012$));
    } else if (ratv3012$ < 1.0f) {
     (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(1LL)].uvw$ , ratv3012$));
     (::operator$n::diva$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(vtxs$[pxcrt::bt_size_t(2LL)].uvw$ , ratv3012$));
    }
   }
  }
 }
}
(((pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >(vptr$))->value)).push_polygon_distinct$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$(vtxs$);
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glvertex$n { 
inline void vertices$s::push_polygon_distinct$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& vals$19) {
if (num_float_per_vertex$ != pxcrt::bt_size_t(12LL)) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::split$n::string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$long$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("triangles2_vertex_attributes") , 12LL , num_float_per_vertex$)).get_crange())));
}
/* staticif empty */{
}
const pxcrt::bt_size_t first_id$19$pgl3d$$glvertex$ns1 = vertex_values$.size() / pxcrt::bt_size_t(12LL);
{
 const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& ag$fe = (vals$19);
 const size_t sz$fe = ag$fe.size();
 const ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s& val$ = ar$fe[i$];
  {
   ::pgl3d$n::glvertex$n::push_float$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(vertex_values$ , val$);
   {
    ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(positions$ , pxcrt::glmpx::tvec3_to_cslice< pxcrt::bt_float >(val$.position$));
   }
  }
 }
}
/* staticif empty */{
 ::pxcrt::pxcvarray< pxcrt::bt_size_t > ia$31$pgl3d$$glvertex$ns1 = ::pxcrt::pxcvarray< pxcrt::bt_size_t >();
 ::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_size_t >,pxcrt::bt_uint >(ia$31$pgl3d$$glvertex$ns1 , vals$19.size() , 0U);
 {
  ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ag$fe = (ia$31$pgl3d$$glvertex$ns1);
  ::pxcrt::pxcvarray< pxcrt::bt_size_t >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_size_t > > ag$fg(ag$fe);
  const size_t sz$fe = ag$fe.size();
  pxcrt::bt_size_t *const ar$fe = ag$fe.rawarr();
  for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
   pxcrt::bt_size_t& v$ = ar$fe[i$];
   {
    v$ = i$;
   }
  }
 }
 pxcrt::glmpx::tvec3< pxcrt::bt_float >::type cross_sum$31$pgl3d$$glvertex$ns1 = pxcrt::glmpx::tvec3< pxcrt::bt_float >::type();
 for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < ia$31$pgl3d$$glvertex$ns1.size(); ++i$) {
  (::operator$n::adda$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(cross_sum$31$pgl3d$$glvertex$ns1 , ::pgl3d$n::glvertex$n::cross_one$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(vals$19, ia$31$pgl3d$$glvertex$ns1 , i$)));
 }
 while (ia$31$pgl3d$$glvertex$ns1.size() >= pxcrt::bt_size_t(3LL)) {
  pxcrt::bt_size_t i$38$pgl3d$$glvertex$ns1 = ia$31$pgl3d$$glvertex$ns1.size() - pxcrt::bt_size_t(1LL);
  while (true) {
   if (::pgl3d$n::glvertex$n::removable$f39$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(i$38$pgl3d$$glvertex$ns1, cross_sum$31$pgl3d$$glvertex$ns1, vals$19, ia$31$pgl3d$$glvertex$ns1)) {
    ::pgl3d$n::glvertex$n::push_one$f39$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(i$38$pgl3d$$glvertex$ns1, elements$, first_id$19$pgl3d$$glvertex$ns1, ia$31$pgl3d$$glvertex$ns1);
    ::pxcrt::array_erase< ::pxcrt::pxcvarray< pxcrt::bt_size_t > >(ia$31$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(1LL));
    break;
   }
   if (i$38$pgl3d$$glvertex$ns1 == pxcrt::bt_size_t((0LL))) {
    ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$1$li$r$$r$$r$(pxcrt::bt_strlit("warning: split_convex failed") , ia$31$pgl3d$$glvertex$ns1.size() , vals$19.size() , vals$19 , ia$31$pgl3d$$glvertex$ns1);
    i$38$pgl3d$$glvertex$ns1 = ia$31$pgl3d$$glvertex$ns1.size() - pxcrt::bt_size_t(1LL);
    ::pgl3d$n::glvertex$n::push_one$f39$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(i$38$pgl3d$$glvertex$ns1, elements$, first_id$19$pgl3d$$glvertex$ns1, ia$31$pgl3d$$glvertex$ns1);
    ::pxcrt::array_erase< ::pxcrt::pxcvarray< pxcrt::bt_size_t > >(ia$31$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(1LL));
   }
   --i$38$pgl3d$$glvertex$ns1;
  }
 }
}
}
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1) {
/* staticif empty *//* staticif-else */
for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < vals$19.size() - pxcrt::bt_size_t(2LL); ++i$) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(1LL)));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(2LL)));
}
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& vals$19, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$) {
return vals$19[pxcrt::bt_size_t(pxcrt::get_elem_value(ia$31$pgl3d$$glvertex$ns1,i$))].position$;
}
static inline pxcrt::bt_size_t ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$) {
return (i$ == pxcrt::bt_size_t((0LL))) ? (ia$31$pgl3d$$glvertex$ns1.size() - pxcrt::bt_size_t(1LL)) : (i$ - pxcrt::bt_size_t(1LL));
}
static inline pxcrt::bt_size_t ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1, pxcrt::bt_size_t i$) {
return (i$ != ia$31$pgl3d$$glvertex$ns1.size() - pxcrt::bt_size_t(1LL)) ? (i$ + pxcrt::bt_size_t(1LL)) : pxcrt::bt_size_t(0U);
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type cross_one$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s > const& _0$up, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& _1$up, pxcrt::bt_size_t i$) {
return glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$)))) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$)) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$))));
}
static inline pxcrt::bt_bool removable$f39$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(pxcrt::bt_size_t& i$38$pgl3d$$glvertex$ns1, pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& cross_sum$31$pgl3d$$glvertex$ns1, ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s > const& _0$up, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& _1$up) {
const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type ci$ = ::pgl3d$n::glvertex$n::cross_one$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$38$pgl3d$$glvertex$ns1);
/* staticif empty */
if (pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(cross_sum$31$pgl3d$$glvertex$ns1 , ci$) <= -0.000001f) {
 return false;
}
pxcrt::bt_size_t j$ = pxcrt::bt_size_t();
for (j$ = ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)); j$ != ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1); j$ = ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , j$)) {
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c0$ = glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$38$pgl3d$$glvertex$ns1) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)))) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , j$) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$38$pgl3d$$glvertex$ns1))));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c1$ = glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , i$38$pgl3d$$glvertex$ns1))) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , j$) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)))));
 const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type c2$ = glm::cross< pxcrt::bt_float >((::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)))) , (::operator$n::sub$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , j$) , ::pgl3d$n::glvertex$n::ia_pos$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_0$up, _1$up , ::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(_1$up , i$38$pgl3d$$glvertex$ns1)))));
 const pxcrt::bt_float s0$ = pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c0$ , c1$);
 const pxcrt::bt_float s1$ = pxcrt::glmpx::dot< pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(c0$ , c2$);
 if (s0$ > 0.0f && s1$ > 0.0f) {
  /* staticif empty */
  return false;
 }
}
return true;
}
static inline void push_one$f39$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(pxcrt::bt_size_t& i$38$pgl3d$$glvertex$ns1, ::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1, ::pxcrt::pxcvarray< pxcrt::bt_size_t >& ia$31$pgl3d$$glvertex$ns1) {
/* staticif empty */
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(pxcrt::get_elem_value(ia$31$pgl3d$$glvertex$ns1,::pgl3d$n::glvertex$n::ia_prev$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(ia$31$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1)))));
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(pxcrt::get_elem_value(ia$31$pgl3d$$glvertex$ns1,i$38$pgl3d$$glvertex$ns1))));
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + pxcrt::bt_size_t(pxcrt::get_elem_value(ia$31$pgl3d$$glvertex$ns1,::pgl3d$n::glvertex$n::ia_next$f31$ic$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$q$1$li$r$$(ia$31$pgl3d$$glvertex$ns1 , i$38$pgl3d$$glvertex$ns1)))));
}
static inline void push_float$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.position$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.normal$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.tangent$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.uvw$);
/* staticif-else end */
}
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& a3$, const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& a4$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$ , a4$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& a3$, const ::pxcrt::pxcvarray< pxcrt::bt_size_t >& a4$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a2$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$(a3$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$container$$array$n$$varray$s$p$meta$n$$size_t$t$r$$r$(a4$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$cslice$s$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
{
 const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s >& ag$fe = (x$);
 const size_t sz$fe = ag$fe.size();
 const ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s& v$ = ar$fe[i$];
  {
   if (i$ != pxcrt::bt_size_t((0LL))) {
    ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
   }
   ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(v$ , o$);
  }
 }
}
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(const ::pgl3d$n::drawer$n::triangles2_vertex_attributes$s& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
if ((0LL) != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("normal") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.normal$ , o$);
if (1LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.position$ , o$);
if (2LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("tangent") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.tangent$ , o$);
if (3LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("uvw") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$.uvw$ , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(vptr$));
}
callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) : count$z(1), fld$(vptr$) {
}
inline void callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$::__call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::drawer$n::dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$(fld$._0$ , flat_flag$ , poly$ , mp$);
}
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_polygon_filler_tattr$f$p$pgl3d$$drawer$n$$triangles2_vertex_attributes$s$r$$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_view_projection_matrix$(-1LL), u_screen_size_px$(-1LL), u_screen_size_base$(-1LL), i_idata$(-1LL), v_instance_id$(-1LL), v_vert$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_view_projection_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
::GL$n::compat$n::glGetError$f();
if (u_view_projection_matrix$ < (0LL)) {
 u_view_projection_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
}
u_screen_size_px$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("screen_size_px")));
::GL$n::compat$n::glGetError$f();
if (u_screen_size_px$ < (0LL)) {
 u_screen_size_px$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("screen_size_px")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("screen_size_px") , u_screen_size_px$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("screen_size_px") , u_screen_size_px$);
}
u_screen_size_base$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("screen_size_base")));
::GL$n::compat$n::glGetError$f();
if (u_screen_size_base$ < (0LL)) {
 u_screen_size_base$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("screen_size_base")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("screen_size_base") , u_screen_size_base$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("screen_size_base") , u_screen_size_base$);
}
i_idata$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("idata")));
::GL$n::compat$n::glGetError$f();
if (i_idata$ < (0LL)) {
 i_idata$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("idata")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("idata") , i_idata$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("idata") , i_idata$);
}
v_instance_id$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("instance_id")));
::GL$n::compat$n::glGetError$f();
v_vert$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("vert")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::lineparticle_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(9LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat3_to_cslice< pxcrt::bt_float >(v$.idata$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(9LL);
 if (i_idata$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(9LL);
 if (i_idata$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(9LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(9LL);
 if (i_idata$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$r$(i_idata$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_instance_id$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_vert$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_vert$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_vert$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_instance_id$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
}
if (v_vert$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_vert$));
}
}
static inline void set_uniform$f$p$glm$n$$tmat3$s$p$meta$n$$float$t$r$$r$(pxcrt::bt_int loc$, const ::pxcrt::bt_cslice< pxcrt::bt_float >& value$, pxcrt::bt_size_t offset$, pxcrt::bt_int cnt$) {
/* staticif */
::GL$n::compat$n::glUniformMatrix3fv$f(loc$ , cnt$ , pxcrt::bt_uchar((0LL)) , (::operator$n::add$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$r$(pxcrt::cslice_to_crawptr< pxcrt::bt_float >(value$) , offset$)));
/* staticif end */
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_lineparticle$f$r$() {
/* staticif empty */
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type r$ = pxcrt::tfuncptr_null< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >();
r$ = &(::pgl3d$n::drawer$n::prepare_instance_data_lineparticle$f);
return r$;
}
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(3LL) , points_mode$ , is_sub$);
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glvertex$n { 
inline void vertices$s::push_polygon_distinct$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$q$0$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s >& vals$19) {
if (num_float_per_vertex$ != pxcrt::bt_size_t(3LL)) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::split$n::string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$long$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("lineparticle_vertex_attributes") , 3LL , num_float_per_vertex$)).get_crange())));
}
{
 has_instance_id$ = true;
}
const pxcrt::bt_size_t first_id$19$pgl3d$$glvertex$ns1 = vertex_values$.size() / pxcrt::bt_size_t(3LL);
{
 const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s >& ag$fe = (vals$19);
 const size_t sz$fe = ag$fe.size();
 const ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s& val$ = ar$fe[i$];
  {
   ::pgl3d$n::glvertex$n::push_float$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(vertex_values$ , val$);
   /* staticif empty */
  }
 }
}
{
 ::pgl3d$n::glvertex$n::push_convex$f19$ic$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$q$0$li$r$$(elements$, vals$19, first_id$19$pgl3d$$glvertex$ns1);
}
}
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$q$0$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1) {
/* staticif empty *//* staticif-else */
for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < vals$19.size() - pxcrt::bt_size_t(2LL); ++i$) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(1LL)));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(2LL)));
}
/* staticif-else end */
}
static inline void push_float$f$p$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::lineparticle_vertex_attributes$s& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.instance_id$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(arr$ , v$.vert$);
/* staticif-else end */
}
static inline void push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.x);
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.y);
/* staticif-else end */
}
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$int$t$r$(pxcrt::bt_int x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$int$t$r$(const pxcrt::bt_int& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_int > c$ = numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_int >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< pxcrt::bt_float,2LL > make_farray_func$f$p$meta$n$$float$t$q$2$li$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$) {
::pxcrt::farray< pxcrt::bt_float,2LL > arr$ = ::pxcrt::farray< pxcrt::bt_float,2LL >();
arr$[pxcrt::bt_size_t((0LL))] = a0$;
arr$[pxcrt::bt_size_t(1LL)] = a1$;
return arr$;
}
};}; /* namespace container::array */
namespace ordered$n { 
static inline pxcrt::bt_int max$f$p$meta$n$$int$t$r$(const pxcrt::bt_int& x$, const pxcrt::bt_int& y$) {
return x$ < y$ ? y$ : x$;
}
}; /* namespace ordered */
namespace pgl3d$n { namespace glshader$n { 
glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_point_size_base$(-1LL), i_model_matrix$(-1LL), v_position$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_point_size_base$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("point_size_base")));
::GL$n::compat$n::glGetError$f();
if (u_point_size_base$ < (0LL)) {
 u_point_size_base$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("point_size_base")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("point_size_base") , u_point_size_base$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("point_size_base") , u_point_size_base$);
}
i_model_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
::GL$n::compat$n::glGetError$f();
if (i_model_matrix$ < (0LL)) {
 i_model_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
}
v_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::particle_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$.model_matrix$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(16LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(i_model_matrix$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
}
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_particle$f$r$() {
/* staticif empty */
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type r$ = pxcrt::tfuncptr_null< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >();
r$ = &(::pgl3d$n::drawer$n::prepare_instance_data_particle$f);
return r$;
}
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(3LL) , points_mode$ , is_sub$);
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_view_projection_matrix$(-1LL), u_camera_matrix$(-1LL), u_point_size_base$(-1LL), i_model_matrix$(-1LL), v_position$(-1LL), v_local_position$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_view_projection_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
::GL$n::compat$n::glGetError$f();
if (u_view_projection_matrix$ < (0LL)) {
 u_view_projection_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("view_projection_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("view_projection_matrix") , u_view_projection_matrix$);
}
u_camera_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("camera_matrix")));
::GL$n::compat$n::glGetError$f();
if (u_camera_matrix$ < (0LL)) {
 u_camera_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("camera_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("camera_matrix") , u_camera_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("camera_matrix") , u_camera_matrix$);
}
u_point_size_base$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("point_size_base")));
::GL$n::compat$n::glGetError$f();
if (u_point_size_base$ < (0LL)) {
 u_point_size_base$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("point_size_base")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("point_size_base") , u_point_size_base$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("point_size_base") , u_point_size_base$);
}
i_model_matrix$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
::GL$n::compat$n::glGetError$f();
if (i_model_matrix$ < (0LL)) {
 i_model_matrix$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("model_matrix")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("model_matrix") , i_model_matrix$);
}
v_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("position")));
::GL$n::compat$n::glGetError$f();
v_local_position$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("local_position")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::particle_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$.model_matrix$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(16LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(16LL);
 if (i_model_matrix$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(i_model_matrix$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(3LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_local_position$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_local_position$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_local_position$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_position$));
}
if (v_local_position$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_local_position$));
}
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_default$f$r$() {
/* staticif empty */
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type r$ = pxcrt::tfuncptr_null< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >();
r$ = &(::pgl3d$n::drawer$n::prepare_instance_data_default$f);
return r$;
}
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(5LL) , points_mode$ , is_sub$);
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glshader$n { 
glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), u_screen_size_px$(-1LL), u_sampler$(-1LL), i_idata$(-1LL), v_instance_id$(-1LL), v_texture_size_px$(-1LL), v_texture_origin_px$(-1LL), v_char_size_px$(-1LL), v_coord_clamp$(-1LL), v_char_px$(-1LL), v_char_point_size$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
u_screen_size_px$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("screen_size_px")));
::GL$n::compat$n::glGetError$f();
if (u_screen_size_px$ < (0LL)) {
 u_screen_size_px$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("screen_size_px")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("screen_size_px") , u_screen_size_px$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("screen_size_px") , u_screen_size_px$);
}
u_sampler$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler")));
::GL$n::compat$n::glGetError$f();
if (u_sampler$ < (0LL)) {
 u_sampler$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("sampler")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform(attr)") , pxcrt::bt_strlit("sampler") , u_sampler$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("uniform") , pxcrt::bt_strlit("sampler") , u_sampler$);
}
i_idata$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("idata")));
::GL$n::compat$n::glGetError$f();
if (i_idata$ < (0LL)) {
 i_idata$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("idata")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("idata") , i_idata$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("idata") , i_idata$);
}
v_instance_id$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("instance_id")));
::GL$n::compat$n::glGetError$f();
v_texture_size_px$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("texture_size_px")));
::GL$n::compat$n::glGetError$f();
v_texture_origin_px$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("texture_origin_px")));
::GL$n::compat$n::glGetError$f();
v_char_size_px$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("char_size_px")));
::GL$n::compat$n::glGetError$f();
v_coord_clamp$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("coord_clamp")));
::GL$n::compat$n::glGetError$f();
v_char_px$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("char_px")));
::GL$n::compat$n::glGetError$f();
v_char_point_size$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("char_point_size")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::font2_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(4LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tvec4_to_cslice< pxcrt::bt_float >(v$.idata$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(4LL);
 if (i_idata$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(4LL);
 if (i_idata$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(4LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(4LL);
 if (i_idata$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(i_idata$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_instance_id$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_texture_size_px$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_texture_size_px$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_texture_size_px$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_texture_origin_px$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_texture_origin_px$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_texture_origin_px$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_char_size_px$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_size_px$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_size_px$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_coord_clamp$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_coord_clamp$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_coord_clamp$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_char_px$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_px$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_px$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_char_point_size$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_point_size$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_point_size$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_instance_id$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
}
if (v_texture_size_px$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_texture_size_px$));
}
if (v_texture_origin_px$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_texture_origin_px$));
}
if (v_char_size_px$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_size_px$));
}
if (v_coord_clamp$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_coord_clamp$));
}
if (v_char_px$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_px$));
}
if (v_char_point_size$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_char_point_size$));
}
}
static inline void set_uniform$f$p$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(pxcrt::bt_int loc$, const ::pxcrt::bt_cslice< pxcrt::bt_float >& value$, pxcrt::bt_size_t offset$, pxcrt::bt_int cnt$) {
/* staticif */
::GL$n::compat$n::glUniform4fv$f(loc$ , cnt$ , (::operator$n::add$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$meta$n$$size_t$t$r$(pxcrt::cslice_to_crawptr< pxcrt::bt_float >(value$) , offset$)));
/* staticif end */
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_font2$f$r$() {
/* staticif empty */
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type r$ = pxcrt::tfuncptr_null< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >();
r$ = &(::pgl3d$n::drawer$n::prepare_instance_data_font2$f);
return r$;
}
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(11LL) , points_mode$ , is_sub$);
}
};}; /* namespace pgl3d::drawer */
namespace ordered$n { 
static inline pxcrt::bt_uint max$f$p$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$, const pxcrt::bt_uint& y$) {
return x$ < y$ ? y$ : x$;
}
}; /* namespace ordered */
namespace pgl3d$n { namespace glvertex$n { 
inline void vertices$s::push_point$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(const ::pgl3d$n::drawer$n::font2_vertex_attributes$s& val$) {
if (num_float_per_vertex$ != pxcrt::bt_size_t(11LL)) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
}
const pxcrt::bt_size_t first_id$ = vertex_values$.size() / pxcrt::bt_size_t(11LL);
::pgl3d$n::glvertex$n::push_float$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(vertex_values$ , val$);
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$));
/* staticif empty */
}
};}; /* namespace pgl3d::glvertex */
namespace exception$n { 
runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$::runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{vertices::push_point}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace pgl3d$n { namespace glvertex$n { 
static inline void push_float$f$p$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::font2_vertex_attributes$s& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.instance_id$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(arr$ , v$.texture_size_px$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(arr$ , v$.texture_origin_px$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(arr$ , v$.char_size_px$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(arr$ , v$.coord_clamp$);
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.char_px$);
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.char_point_size$);
/* staticif-else end */
}
};}; /* namespace pgl3d::glvertex */
namespace pgl3d$n { namespace glshader$n { 
glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) : count$z(1), program$(pxcrt::bt_uint((0LL))), error$(), i_idata$(-1LL), v_instance_id$(-1LL), v_vert$(-1LL) {
init$f(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
inline void glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::init$f(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
program$ = ::pgl3d$n::glshader$n::create_program$f(prog_v$ , prog_f$ , attrib_to_avoid_0$ , error$);
if (program$ == pxcrt::bt_uint((0LL))) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$create__program$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit("1"))));
}
i_idata$ = ::glGetUniformLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("idata")));
::GL$n::compat$n::glGetError$f();
if (i_idata$ < (0LL)) {
 i_idata$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("idata")));
 ::GL$n::compat$n::glGetError$f();
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance(attr)") , pxcrt::bt_strlit("idata") , i_idata$);
} else {
 ::pgl3d$n::glconf$n::sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(pxcrt::bt_strlit("instance") , pxcrt::bt_strlit("idata") , i_idata$);
}
v_instance_id$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("instance_id")));
::GL$n::compat$n::glGetError$f();
v_vert$ = ::glGetAttribLocation(program$ , ::pointer$n::raw$n::strlit___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$char$t$r$$q$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("vert")));
::GL$n::compat$n::glGetError$f();
}
inline void glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::instance_attrib_prepare$f(const ::pxcrt::bt_slice< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::rect2d_instance_attributes$s& v$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(4LL);
 /* staticif empty */{
  const ::pxcrt::bt_cslice< pxcrt::bt_float > src$ = pxcrt::glmpx::tvec4_to_cslice< pxcrt::bt_float >(v$.idata$);
  for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < nfl$; ++i$) {
   arr$[offset$ + i$] = src$[i$];
  }
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::enable_instance_attrib_array$f(pxcrt::bt_bool enable_flag$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(4LL);
 if (i_idata$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$enable__instance__attrib__array$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::instance_attrib_pointer$f(pxcrt::bt_size_t offset_float$) {
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(4LL);
 if (i_idata$ >= (0LL)) {
  /* staticif empty *//* staticif-else */
  PXC_THROW(::exception$n::runtime_error_template$s$p$instance__attrib__pointer$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
  /* staticif-else end */
 }
 offset$ += nfl$;
}
}
inline pxcrt::bt_size_t glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::instance_attrib_num_float$f() const {
return pxcrt::bt_size_t(4LL);
}
inline void glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::instance_attrib_set_uniform$f(const ::pxcrt::bt_cslice< pxcrt::bt_float >& arr$, pxcrt::bt_size_t offset$, pxcrt::bt_size_t cnt$) {
/* staticif empty */
{
 const pxcrt::bt_size_t nfl$ = pxcrt::bt_size_t(4LL);
 if (i_idata$ >= (0LL)) {
  ::pgl3d$n::glshader$n::set_uniform$f$p$glm$n$$tvec4$s$p$meta$n$$float$t$r$$r$(i_idata$ , arr$ , offset$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(cnt$));
 }
 offset$ += nfl$;
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::enable_vertex_attrib_array$f(pxcrt::bt_size_t num_float_per_vertex$) {
const pxcrt::bt_int stride_byte$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$size_t$t$r$(num_float_per_vertex$ * pxcrt::bt_size_t(4LL));
pxcrt::bt_size_t offset$ = pxcrt::bt_size_t((0LL));
if (v_instance_id$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(1LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
if (v_vert$ >= (0LL)) {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 ::GL$n::compat$n::glEnableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_vert$));
 ::GL$n::compat$n::glVertexAttribPointer$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_vert$) , nfloat$ , GL_FLOAT , pxcrt::bt_uchar((0LL)) , stride_byte$ , pxcrt::gl::offset_to_void_cp(offset$));
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
} else {
 const pxcrt::bt_int nfloat$ = pxcrt::bt_int(2LL);
 offset$ += ::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$int$t$r$(nfloat$) * pxcrt::bt_size_t(4LL);
}
}
inline void glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::disable_vertex_attrib_array$f() {
if (v_instance_id$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_instance_id$));
}
if (v_vert$ >= (0LL)) {
 ::GL$n::compat$n::glDisableVertexAttribArray$f(::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(v_vert$));
}
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer$n$$prepare_instance_data_rect2d$f$r$() {
/* staticif empty */
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type r$ = pxcrt::tfuncptr_null< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >();
r$ = &(::pgl3d$n::drawer$n::prepare_instance_data_rect2d$f);
return r$;
}
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_tattr_vertex_buffer$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(pxcrt::bt_bool points_mode$, pxcrt::bt_bool is_sub$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$r$$r$(::numeric$n::cast$n::static_cast$f$p$meta$n$$size_t$t$q$meta$n$$long$t$r$(3LL) , points_mode$ , is_sub$);
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glvertex$n { 
inline void vertices$s::push_polygon_distinct$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$q$0$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s >& vals$19) {
if (num_float_per_vertex$ != pxcrt::bt_size_t(3LL)) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::split$n::string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$long$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("rect2d_vertex_attributes") , 3LL , num_float_per_vertex$)).get_crange())));
}
{
 has_instance_id$ = true;
}
const pxcrt::bt_size_t first_id$19$pgl3d$$glvertex$ns1 = vertex_values$.size() / pxcrt::bt_size_t(3LL);
{
 const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s >& ag$fe = (vals$19);
 const size_t sz$fe = ag$fe.size();
 const ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s& val$ = ar$fe[i$];
  {
   ::pgl3d$n::glvertex$n::push_float$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(vertex_values$ , val$);
   /* staticif empty */
  }
 }
}
{
 ::pgl3d$n::glvertex$n::push_convex$f19$ic$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$q$0$li$r$$(elements$, vals$19, first_id$19$pgl3d$$glvertex$ns1);
}
}
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$q$0$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1) {
/* staticif empty *//* staticif-else */
for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < vals$19.size() - pxcrt::bt_size_t(2LL); ++i$) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(1LL)));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(2LL)));
}
/* staticif-else end */
}
static inline void push_float$f$p$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::rect2d_vertex_attributes$s& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$meta$n$$float$t$r$(arr$ , v$.instance_id$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(arr$ , v$.vert$);
/* staticif-else end */
}
inline void vertices$s::push_point$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(const ::pgl3d$n::drawer$n::particle_vertex_attributes$s& val$) {
if (num_float_per_vertex$ != pxcrt::bt_size_t(3LL)) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$vertices_3a_3apush__point$ls$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >(pxcrt::bt_strlit(""))));
}
const pxcrt::bt_size_t first_id$ = vertex_values$.size() / pxcrt::bt_size_t(3LL);
::pgl3d$n::glvertex$n::push_float$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(vertex_values$ , val$);
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$));
{
 ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(positions$ , pxcrt::glmpx::tvec3_to_cslice< pxcrt::bt_float >(val$.position$));
}
}
static inline void push_float$f$p$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::particle_vertex_attributes$s& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.position$);
/* staticif-else end */
}
inline void vertices$s::push_polygon_distinct$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$q$0$li$r$(const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s >& vals$19) {
if (num_float_per_vertex$ != pxcrt::bt_size_t(5LL)) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$vertices_3a_3apush__polygon__distinct$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::split$n::string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$long$t$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(pxcrt::bt_strlit("particle_bb_vertex_attributes") , 5LL , num_float_per_vertex$)).get_crange())));
}
/* staticif empty */{
}
const pxcrt::bt_size_t first_id$19$pgl3d$$glvertex$ns1 = vertex_values$.size() / pxcrt::bt_size_t(5LL);
{
 const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s >& ag$fe = (vals$19);
 const size_t sz$fe = ag$fe.size();
 const ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s& val$ = ar$fe[i$];
  {
   ::pgl3d$n::glvertex$n::push_float$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(vertex_values$ , val$);
   {
    ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(positions$ , pxcrt::glmpx::tvec3_to_cslice< pxcrt::bt_float >(val$.position$));
   }
  }
 }
}
{
 ::pgl3d$n::glvertex$n::push_convex$f19$ic$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$q$0$li$r$$(elements$, vals$19, first_id$19$pgl3d$$glvertex$ns1);
}
}
static inline void push_convex$f19$ic$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$q$0$li$r$$(::pxcrt::pxcvarray< pxcrt::bt_uint >& elements$, const ::pxcrt::bt_cslice< ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s >& vals$19, const pxcrt::bt_size_t& first_id$19$pgl3d$$glvertex$ns1) {
/* staticif empty *//* staticif-else */
for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < vals$19.size() - pxcrt::bt_size_t(2LL); ++i$) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(1LL)));
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(elements$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$size_t$t$r$(first_id$19$pgl3d$$glvertex$ns1 + i$ + pxcrt::bt_size_t(2LL)));
}
/* staticif-else end */
}
static inline void push_float$f$p$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pgl3d$n::drawer$n::particle_bb_vertex_attributes$s& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(arr$ , v$.position$);
::pgl3d$n::glvertex$n::push_float$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(arr$ , v$.local_position$);
/* staticif-else end */
}
};}; /* namespace pgl3d::glvertex */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(vptr$));
}
callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) : count$z(1), fld$(vptr$) {
}
inline void callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$::__call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::drawer$n::dgf_particle_internal$f(fld$._0$ , flat_flag$ , poly$ , mp$);
}
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_internal$f$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(vptr$));
}
callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) : count$z(1), fld$(vptr$) {
}
inline void callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$::__call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::drawer$n::dgf_particle_bb_internal$f(fld$._0$ , flat_flag$ , poly$ , mp$);
}
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_particle_bb_internal$f$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(vptr$));
}
callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& vptr$) : count$z(1), fld$(vptr$) {
}
inline void callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$::__call$f(const pxcrt::bt_bool& flat_flag$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::drawer$n::dgf_noop$f(fld$._0$ , flat_flag$ , poly$ , mp$);
}
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > >& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$drawer$n$$dgf_noop$f$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$particle_bb_uniforms$s$q$pgl3d$$drawer$n$$particle_instance_attributes$s$q$pgl3d$$drawer$n$$particle_bb_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$lineparticle_uniforms$s$q$pgl3d$$drawer$n$$lineparticle_instance_attributes$s$q$pgl3d$$drawer$n$$lineparticle_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$font2_uniforms$s$q$pgl3d$$drawer$n$$font2_instance_attributes$s$q$pgl3d$$drawer$n$$font2_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glshader$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > make_glshader_ptr$f$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_v$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& prog_f$, const ::pxcrt::bt_strlit& attrib_to_avoid_0$) {
return ::pointer$n::make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(prog_v$ , prog_f$ , attrib_to_avoid_0$);
}
};}; /* namespace pgl3d::glshader */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > make_ptr$f$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glshader$n$$glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::bt_strlit& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$*const r$p1 = ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::glshader$n::glshader$s$p$pgl3d$$drawer$n$$rect2d_uniforms$s$q$pgl3d$$drawer$n$$rect2d_instance_attributes$s$q$pgl3d$$drawer$n$$rect2d_vertex_attributes$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace drawer$n { 
static inline void buffer_append$f$p$aligned$n$$aligned_16$s$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const ::pxcrt::aligned_16< pxcrt::glmpx::tmat4< pxcrt::bt_float >::type >& v$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::drawer$n::buffer_append$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(arr$ , v$.value);
/* staticif-else end */
}
static inline void buffer_append$f$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$r$(::pxcrt::pxcvarray< pxcrt::bt_float >& arr$, const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& v$) {
/* staticif */
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_float >,::pxcrt::bt_cslice< pxcrt::bt_float > >(arr$ , pxcrt::glmpx::tmat4_to_cslice< pxcrt::bt_float >(v$));
/* staticif end */
}
};}; /* namespace pgl3d::drawer */
namespace pointer$n { namespace tfuncptr$n { 
static inline void tfuncptr3___call$f$p$m$ll$p$m$ll$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$scene_node$s$q$0$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$node_common_data$s$q$1$li$r$$q$m$ll$p$pgl3d$$pglbase$n$$instance_data$s$q$1$li$r$$r$$r$(const pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type& a0$, const ::pgl3d$n::scene_node$n::scene_node$s& a1$, ::pgl3d$n::pglbase$n::node_common_data$s& a2$, ::pgl3d$n::pglbase$n::instance_data$s& a3$) {
return pxcrt::tfuncptr3___call< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type,::pgl3d$n::scene_node$n::scene_node$s,::pgl3d$n::pglbase$n::node_common_data$s,::pgl3d$n::pglbase$n::instance_data$s >(a0$ , a1$ , a2$ , a3$);
}
};}; /* namespace pointer::tfuncptr */
namespace pgl3d$n { namespace glresource$n { 
auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$() : hnd$(pxcrt::bt_uint(0LL)) {
}
inline pxcrt::bt_uint auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$::get$f() const {
return hnd$.value;
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$::generate$f() {
reset$f();
{
 ::GL$n::compat$n::glGenTextures$f(1LL , pxcrt::address< pxcrt::bt_uint >(hnd$.value));
}
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$::reset$f() {
if (hnd$.value > pxcrt::bt_uint((0LL))) {
 {
  ::GL$n::compat$n::glDeleteTextures$f(1LL , pxcrt::caddress< pxcrt::bt_uint >(hnd$.value));
 }
 hnd$.value = pxcrt::bt_uint((0LL));
}
}
inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$::~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenTextures$f$q$GL$$compat$n$$glDeleteTextures$f$r$() PXC_NOTHROW {
try {
 reset$f();
} catch (...) { ::abort(); }
}
};}; /* namespace pgl3d::glresource */
namespace exception$n { 
runtime_error_template$s$p$unknown_20byteorder$ls$r$::runtime_error_template$s$p$unknown_20byteorder$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$unknown_20byteorder$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{unknown byteorder}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,4LL > make_farray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$4$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a3$) {
::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,4LL > arr$ = ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,4LL >();
arr$[pxcrt::bt_size_t((0LL))] = a0$;
arr$[pxcrt::bt_size_t(1LL)] = a1$;
arr$[pxcrt::bt_size_t(2LL)] = a2$;
arr$[pxcrt::bt_size_t(3LL)] = a3$;
return arr$;
}
};}; /* namespace container::array */
namespace pointer$n { namespace raw$n { 
scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$::scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$() : hnd$(pxcrt::rawptr< TTF_Font >::type()) {
}
inline void scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$::reset$f(const pxcrt::rawptr< TTF_Font >::type& v$) {
if ((::operator$n::ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$(hnd$.value , pxcrt::rawptr< TTF_Font >::type()))) {
 TTF_CloseFont(hnd$.value);
}
hnd$.value = v$;
}
inline pxcrt::rawptr< TTF_Font >::type scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$::get$f() const {
return hnd$.value;
}
inline scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$::~scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$() PXC_NOTHROW {
try {
 reset$f(pxcrt::rawptr< TTF_Font >::type());
} catch (...) { ::abort(); }
}
};}; /* namespace pointer::raw */
namespace operator$n { 
static inline pxcrt::bt_bool ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$(const pxcrt::rawptr< TTF_Font >::type& x$, const pxcrt::rawptr< TTF_Font >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$ne$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$ne$ls$r$(const pxcrt::rawptr< TTF_Font >::type& x$, const pxcrt::rawptr< TTF_Font >::type& y$) {
/* staticif */
return pxcrt::rawptr_ne< pxcrt::rawptr< TTF_Font >::type,pxcrt::rawptr< TTF_Font >::type >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$, const pxcrt::bt_size_t& a2$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$, const pxcrt::bt_size_t& a2$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , a1$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a2$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace operator$n { 
static inline pxcrt::bt_bool eq$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$(const pxcrt::rawptr< TTF_Font >::type& x$, const pxcrt::rawptr< TTF_Font >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$eq$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$eq$ls$r$(const pxcrt::rawptr< TTF_Font >::type& x$, const pxcrt::rawptr< TTF_Font >::type& y$) {
/* staticif */
return pxcrt::rawptr_eq< pxcrt::rawptr< TTF_Font >::type,pxcrt::rawptr< TTF_Font >::type >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(a0$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace exception$n { 
runtime_error_template$s$p$load_20font$ls$r$::runtime_error_template$s$p$load_20font$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$load_20font$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{load font}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace pointer$n { namespace raw$n { 
scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$() : hnd$(pxcrt::rawptr< SDL_Surface >::type()) {
}
inline void scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$::reset$f(const pxcrt::rawptr< SDL_Surface >::type& v$) {
if ((::operator$n::ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$r$(hnd$.value , pxcrt::rawptr< SDL_Surface >::type()))) {
 SDL_FreeSurface(hnd$.value);
}
hnd$.value = v$;
}
inline pxcrt::rawptr< SDL_Surface >::type scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$::get$f() const {
return hnd$.value;
}
inline scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$::~scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$() PXC_NOTHROW {
try {
 reset$f(pxcrt::rawptr< SDL_Surface >::type());
} catch (...) { ::abort(); }
}
};}; /* namespace pointer::raw */
namespace operator$n { 
static inline pxcrt::bt_bool ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$r$(const pxcrt::rawptr< SDL_Surface >::type& x$, const pxcrt::rawptr< SDL_Surface >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$ne$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$ne$ls$r$(const pxcrt::rawptr< SDL_Surface >::type& x$, const pxcrt::rawptr< SDL_Surface >::type& y$) {
/* staticif */
return pxcrt::rawptr_ne< pxcrt::rawptr< SDL_Surface >::type,pxcrt::rawptr< SDL_Surface >::type >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > make_ptr$f$p$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$q$m$ll$r$() {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > box_pointer$f$p$pxcrt$$ptr$p$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$r$$q$m$ll$r$() {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ >*const r$p1 = pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ >::allocate();
try {
new (&r$p1->value) ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$();
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$ > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace operator$n { 
static inline pxcrt::rawptr< TTF_Font >::type implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$$r$(const ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$& x$) {
return x$.__to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$();
}
}; /* namespace operator */
namespace pointer$n { namespace raw$n { 
inline pxcrt::rawptr< TTF_Font >::type scoped_nullable$s$p$SDL2$$api_functions$n$$TTF_CloseFont$f$r$::__to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$TTF_Font$s$r$$r$() const {
return hnd$.value;
}
};}; /* namespace pointer::raw */
namespace pgl3d$n { namespace drawer$n { 
static inline pxcrt::bt_uint power_of_2$f$p$meta$n$$uint$t$r$(pxcrt::bt_uint v$) {
pxcrt::bt_uint r$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$int$t$r$(1LL);
while (r$ != pxcrt::bt_uint((0LL)) && r$ < v$) {
 r$ <<= pxcrt::bt_uint(1LL);
}
return r$;
}
};}; /* namespace pgl3d::drawer */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_int cast_int$f$p$meta$n$$uint$t$r$(pxcrt::bt_uint x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$uint$t$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_uint > c$ = numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_uint >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$q$m$ll$p$meta$n$$uint$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const pxcrt::bt_uint& a2$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const pxcrt::bt_uint& a2$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$uint$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$uint$t$r$(a2$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace operator$n { 
static inline pxcrt::rawptr< SDL_Surface >::type implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$$r$(const ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$& x$) {
return x$.__to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$r$();
}
}; /* namespace operator */
namespace pointer$n { namespace raw$n { 
inline pxcrt::rawptr< SDL_Surface >::type scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_FreeSurface$f$r$::__to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Surface$s$r$$r$() const {
return hnd$.value;
}
};}; /* namespace pointer::raw */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_uint cast_uint$f$p$meta$n$$uint$t$r$(pxcrt::bt_uint x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$meta$n$$uint$t$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uint,pxcrt::bt_uint > c$ = numeric::static_cast_impl< pxcrt::bt_uint,pxcrt::bt_uint >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_int cast_int$f$p$GL$$base$n$$GLenum$s$r$(GLenum x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$GL$$base$n$$GLenum$s$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::crawptr< void >::type rawptr___to$f$p$pointer$$raw$n$$crawptr$s$p$meta$n$$void$t$r$$q$pointer$$raw$n$$rawptr$s$p$meta$n$$void$t$r$$r$(pxcrt::rawptr< void >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::crawptr< void >::type,pxcrt::rawptr< void >::type >(x$);
/* staticif end */
}
};}; /* namespace pointer::raw */
namespace exception$n { 
runtime_error_template$s$p$img__load$ls$r$::runtime_error_template$s$p$img__load$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$img__load$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{img_load}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > make_ptr$f$p$pgl3d$$glgeometry$n$$rand_generator$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const pxcrt::bt_uint& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const pxcrt::bt_uint& a0$) {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::glgeometry$n::rand_generator$s(a0$);
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_uint& a1$, const pxcrt::bt_uint& a2$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$uint$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_int cast_int$f$p$meta$n$$int$t$r$(pxcrt::bt_int x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$int$t$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_triangles$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$, pxcrt::bt_int& a1$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_triangles$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(a0$ , a1$);
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_triangles$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$, pxcrt::bt_int& a1$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::drawer$n::drawer_triangles$s*const r$p1 = ::pgl3d$n::drawer$n::drawer_triangles$s::allocate();
try {
new (r$p1) ::pgl3d$n::drawer$n::drawer_triangles$s(a0$ , a1$);
} catch (...) {
::pgl3d$n::drawer$n::drawer_triangles$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles$s > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles2$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_triangles2$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_triangles2$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles2$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_triangles2$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::drawer$n::drawer_triangles2$s*const r$p1 = ::pgl3d$n::drawer$n::drawer_triangles2$s::allocate();
try {
new (r$p1) ::pgl3d$n::drawer$n::drawer_triangles2$s(a0$);
} catch (...) {
::pgl3d$n::drawer$n::drawer_triangles2$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_triangles2$s > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_lineparticle$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_lineparticle$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_lineparticle$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_lineparticle$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_lineparticle$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::drawer$n::drawer_lineparticle$s*const r$p1 = ::pgl3d$n::drawer$n::drawer_lineparticle$s::allocate();
try {
new (r$p1) ::pgl3d$n::drawer$n::drawer_lineparticle$s(a0$);
} catch (...) {
::pgl3d$n::drawer$n::drawer_lineparticle$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_lineparticle$s > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_particle$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_particle$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_particle$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::drawer$n::drawer_particle$s*const r$p1 = ::pgl3d$n::drawer$n::drawer_particle$s::allocate();
try {
new (r$p1) ::pgl3d$n::drawer$n::drawer_particle$s(a0$);
} catch (...) {
::pgl3d$n::drawer$n::drawer_particle$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle$s > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle_bb$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_particle_bb$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_particle_bb$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle_bb$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_particle_bb$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::drawer$n::drawer_particle_bb$s*const r$p1 = ::pgl3d$n::drawer$n::drawer_particle_bb$s::allocate();
try {
new (r$p1) ::pgl3d$n::drawer$n::drawer_particle_bb$s(a0$);
} catch (...) {
::pgl3d$n::drawer$n::drawer_particle_bb$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_particle_bb$s > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_rect2d$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_rect2d$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_rect2d$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_rect2d$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_rect2d$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::drawer$n::drawer_rect2d$s*const r$p1 = ::pgl3d$n::drawer$n::drawer_rect2d$s::allocate();
try {
new (r$p1) ::pgl3d$n::drawer$n::drawer_rect2d$s(a0$);
} catch (...) {
::pgl3d$n::drawer$n::drawer_rect2d$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_rect2d$s > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_font2$s > make_ptr$f$p$pgl3d$$drawer$n$$drawer_font2$s$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_font2$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_font2$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$drawer$n$$drawer_font2$s$r$$q$m$ll$p$m$ll$p$pgl3d$$shader_config$n$$shader_config$s$q$0$li$r$$r$$r$(const ::pgl3d$n::shader_config$n::shader_config$s& a0$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::drawer$n::drawer_font2$s*const r$p1 = ::pgl3d$n::drawer$n::drawer_font2$s::allocate();
try {
new (r$p1) ::pgl3d$n::drawer$n::drawer_font2$s(a0$);
} catch (...) {
::pgl3d$n::drawer$n::drawer_font2$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::drawer$n::drawer_font2$s > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > make_tptr$f$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$container$$array$n$$varray$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$pgl3d$$application$n$$pgl3d_scene_shared$i$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& a0$, const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >& a1$, const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$container$$array$n$$varray$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$pgl3d$$application$n$$pgl3d_scene_shared$i$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > box_pointer$f$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$container$$array$n$$varray$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$pgl3d$$application$n$$pgl3d_scene_shared$i$r$$q$0$li$r$$q$m$ll$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& a0$, const pxcrt::rcptr< ::pgl3d$n::application$n::pgl3d_scene_shared$i >& a1$, const pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > >& a2$) {
/* staticif empty *//* staticif-else */
pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s >*const r$p1 = pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::pglmotion$n::motion_thread_shared$s(a0$ , a1$ , a2$);
new (&r$p1->count$z) pxcrt::mtcount(); /* nothrow */
try {
new (&r$p1->monitor$z) pxcrt::monitor();
} catch (...) {
typedef ::pgl3d$n::pglmotion$n::motion_thread_shared$s pgl3d$$pglmotion$n$$motion_thread_shared$s$dtor;
r$p1->value.~pgl3d$$pglmotion$n$$motion_thread_shared$s$dtor();
throw;
}
} catch (...) {
pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace thread$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$ make_thread_ptr$f$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& sptr$, const ::pgl3d$n::scene_node$n::node_factory$s& nfac0$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$r$(::pointer$n::make_ptr$f$p$thread$n$$thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$r$$r$(sptr$ , nfac0$));
}
thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& sptr$, const ::pgl3d$n::scene_node$n::node_factory$s& nfac0$) : count$z(1), fobj$(sptr$ , nfac0$), need_join$(false), thd$() {
init$f();
}
inline void thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$::init$f() {
const int err$ = pxcrt::thread_create< ::thread$n::thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ >(thd$ , fobj$);
if (err$ != 0) {
 PXC_THROW(::exception$n::runtime_error_template$s$p$thread__create$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(err$)).get_crange())));
}
need_join$ = true;
}
inline thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$::~thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$() PXC_NOTHROW {
try {
 __call$f();
} catch (...) { ::abort(); }
}
inline void thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$::__call$f() {
if (need_join$) {
 need_join$ = false;
 const int err$ = pxcrt::thread_join< ::thread$n::thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ >(thd$);
 if (err$ != 0) {
  PXC_THROW(::exception$n::runtime_error_template$s$p$thread__join$ls$r$((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (::text$n::string$n::serialize$n::to_string$f$p$io$$errno$n$$errno_t$s$r$(err$)).get_crange())));
 }
}
/* staticif empty */
}
thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$::thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& sptr$, const ::pgl3d$n::scene_node$n::node_factory$s& nfac0$) : fld$(sptr$ , nfac0$), ret$() {
}
inline void thread_main_funcobj$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$::__call$f() {
/* staticif */
::pgl3d$n::pglmotion$n::motion_thread_main$f(fld$._0$ , fld$._1$);
/* staticif end */
}
}; /* namespace thread */
namespace operator$n { 
tuple$s$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$pgl3d$$scene_node$n$$node_factory$s$r$$q$m$ll$r$::tuple$s$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$pgl3d$$scene_node$n$$node_factory$s$r$$q$m$ll$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& a0$, const ::pgl3d$n::scene_node$n::node_factory$s& a1$) : _0$(a0$), _1$(a1$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ > make_ptr$f$p$thread$n$$thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& a0$, const ::pgl3d$n::scene_node$n::node_factory$s& a1$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$thread$n$$thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$r$$r$(a0$ , a1$);
}
static inline pxcrt::rcptr< ::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ > box_pointer$f$p$pxcrt$$ptr$p$thread$n$$thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$$r$$q$m$ll$p$m$ll$p$pxcrt$$tptr$p$pgl3d$$pglmotion$n$$motion_thread_shared$s$r$$q$0$li$r$$q$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$r$$r$(const pxcrt::rcptr< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > >& a0$, const ::pgl3d$n::scene_node$n::node_factory$s& a1$) {
/* staticif empty *//* staticif-else */
::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$*const r$p1 = ::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$::allocate();
try {
new (r$p1) ::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$(a0$ , a1$);
} catch (...) {
::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::thread$n::thread$s$p$pgl3d$$pglmotion$n$$motion_thread_main$f$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > make_tptr$f$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$q$m$ll$r$() {
return ::pointer$n::box_pointer$f$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > box_pointer$f$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$r$$q$m$ll$r$() {
/* staticif empty *//* staticif-else */
pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > >*const r$p1 = pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > >::allocate();
try {
new (&r$p1->value) ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >();
new (&r$p1->count$z) pxcrt::mtcount(); /* nothrow */
try {
new (&r$p1->monitor$z) pxcrt::monitor();
} catch (...) {
typedef ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$dtor;
r$p1->value.~container$$array$n$$varray$s$p$pointer$$tfuncptr$n$$tfuncptr3$s$p$meta$n$$void$t$q$pointer$$tfuncptr$n$$cxxref$s$p$pointer$$tfuncptr$n$$cxxconst$s$p$pgl3d$$scene_node$n$$scene_node$s$r$$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$node_common_data$s$r$$q$pointer$$tfuncptr$n$$cxxref$s$p$pgl3d$$pglbase$n$$instance_data$s$r$$r$$r$$dtor();
throw;
}
} catch (...) {
pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type > > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glresource$n { 
auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$() : hnd$(pxcrt::bt_uint(0LL)) {
}
inline pxcrt::bt_uint auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$::get$f() const {
return hnd$.value;
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$::generate$f() {
reset$f();
/* staticif empty */
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$::reset$f() {
if (hnd$.value > pxcrt::bt_uint((0LL))) {
 /* staticif empty */
 hnd$.value = pxcrt::bt_uint((0LL));
}
}
inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$::~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$0$li$q$0$li$r$() PXC_NOTHROW {
try {
 reset$f();
} catch (...) { ::abort(); }
}
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& a2$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& a2$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_cslice< pxcrt::bt_uchar > >(s$ , a1$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(a2$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::positional$n::integral_to_positional$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$10$li$r$(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$q$10$li$r$(::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
/* staticif empty */
if (v$ == ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 48U);
 return;
}
pxcrt::bt_size_t pos0$ = buf$.size();
if (v$ < ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 45U);
 pos0$ += pxcrt::bt_size_t(1LL);
 while (v$ != ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type((0LL))) {
  ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type rem$ = v$ % ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type(10LL);
  v$ /= ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(-rem$) + 48U);
  }
 }
} else {
 while (v$ != ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type((0LL))) {
  ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type rem$ = v$ % ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type(10LL);
  v$ /= ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(rem$) + 48U);
  }
 }
}
::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::bt_slice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (buf$).get()), pos0$, buf$.size()));
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$numeric$$distinct$n$$distinct_int_impl$s$p$meta$n$$size_t$t$q$pgl3d$$intern_pool$n$$intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$$r$$r$(const ::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uchar,::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type > c$ = numeric::static_cast_impl< pxcrt::bt_uchar,::pxcrt::distinct< pxcrt::bt_size_t,::pgl3d$n::intern_pool$n::intern_pool$s$p$pgl3d$$pglbase$n$$vertex_buffer_pool_key$s$r$ >::type >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > make_ptr$f$p$pgl3d$$glbuffer$n$$vertex_buffer$s$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$r$$r$(const pxcrt::bt_uint& a0$, const pxcrt::bt_bool& a1$, const pxcrt::bt_bool& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_buffer$s$r$$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$glbuffer$n$$vertex_buffer$s$r$$q$m$ll$p$m$ll$p$meta$n$$uint$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$0$li$r$$r$$r$(const pxcrt::bt_uint& a0$, const pxcrt::bt_bool& a1$, const pxcrt::bt_bool& a2$) {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::glbuffer$n::vertex_buffer$s(pxcrt::bt_size_t(a0$) , a1$ , a2$);
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glbuffer$n::vertex_buffer$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pointer$n { namespace tfuncptr$n { 
static inline pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type make_tfuncptr$f$p$pgl3d$$drawer_base$n$$prepare_instance_data_noop$f$r$() {
/* staticif empty */
pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type r$ = pxcrt::tfuncptr_null< pxcrt::tfuncptr3< void,pxcrt::cxxref< pxcrt::cxxconst< ::pgl3d$n::scene_node$n::scene_node$s >::type >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::node_common_data$s >::type,pxcrt::cxxref< ::pgl3d$n::pglbase$n::instance_data$s >::type >::type >();
r$ = &(::pgl3d$n::drawer_base$n::prepare_instance_data_noop$f);
return r$;
}
};}; /* namespace pointer::tfuncptr */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_size_t static_cast$f$p$meta$n$$size_t$t$q$meta$n$$uint$t$r$(const pxcrt::bt_uint& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_size_t,pxcrt::bt_uint > c$ = numeric::static_cast_impl< pxcrt::bt_size_t,pxcrt::bt_uint >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::pglshader$n::build_context_impl$s > make_ptr$f$p$pgl3d$$pglshader$n$$build_context_impl$s$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$1$li$r$$r$$r$(::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >& a0$, ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& a1$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$pglshader$n$$build_context_impl$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$1$li$r$$r$$r$(a0$ , a1$);
}
static inline pxcrt::rcptr< ::pgl3d$n::pglshader$n::build_context_impl$s > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$pglshader$n$$build_context_impl$s$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$pxcrt$$ptr$p$pgl3d$$glvertex$n$$vertices$s$r$$r$$q$1$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$1$li$r$$r$$r$(::pxcrt::pxcvarray< pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glvertex$n::vertices$s > > >& a0$, ::pxcrt::pxcvarray< ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$meta$n$$bool$t$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ >& a1$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::pglshader$n::build_context_impl$s*const r$p1 = ::pgl3d$n::pglshader$n::build_context_impl$s::allocate();
try {
new (r$p1) ::pgl3d$n::pglshader$n::build_context_impl$s(a0$ , a1$);
} catch (...) {
::pgl3d$n::pglshader$n::build_context_impl$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::pglshader$n::build_context_impl$s > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace glresource$n { 
auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$() : hnd$(pxcrt::bt_uint(0LL)) {
}
inline pxcrt::bt_uint auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$::get$f() const {
return hnd$.value;
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$::generate$f() {
reset$f();
{
 ::GL$n::compat$n::glGenFramebuffers$f(1LL , pxcrt::address< pxcrt::bt_uint >(hnd$.value));
}
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$::reset$f() {
if (hnd$.value > pxcrt::bt_uint((0LL))) {
 {
  ::GL$n::compat$n::glDeleteFramebuffers$f(1LL , pxcrt::caddress< pxcrt::bt_uint >(hnd$.value));
 }
 hnd$.value = pxcrt::bt_uint((0LL));
}
}
inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$::~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenFramebuffers$f$q$GL$$compat$n$$glDeleteFramebuffers$f$r$() PXC_NOTHROW {
try {
 reset$f();
} catch (...) { ::abort(); }
}
};}; /* namespace pgl3d::glresource */
namespace container$n { namespace array$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uint > make_varray_func$f$p$meta$n$$uint$t$q$2$li$r$(const pxcrt::bt_uint& a0$, const pxcrt::bt_uint& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uint > arr$ = ::pxcrt::pxcvarray< pxcrt::bt_uint >();
::pxcrt::array_resize< ::pxcrt::pxcvarray< pxcrt::bt_uint >,pxcrt::bt_uint >(arr$ , pxcrt::bt_size_t(2LL) , pxcrt::bt_uint());
arr$[pxcrt::bt_size_t((0LL))] = a0$;
arr$[pxcrt::bt_size_t(1LL)] = a1$;
return arr$;
}
};}; /* namespace container::array */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$float$t$r$(pxcrt::bt_float x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$float$t$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$float$t$r$(const pxcrt::bt_float& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_float > c$ = numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_float >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace ordered$n { 
static inline pxcrt::bt_double max$f$p$meta$n$$double$t$r$(const pxcrt::bt_double& x$, const pxcrt::bt_double& y$) {
return x$ < y$ ? y$ : x$;
}
}; /* namespace ordered */
namespace pgl3d$n { namespace glgeometry$n { 
static inline pxcrt::bt_float cast_float$f$p$meta$n$$double$t$r$(pxcrt::bt_double x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$float$t$q$meta$n$$double$t$r$(x$);
}
};}; /* namespace pgl3d::glgeometry */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$double$t$r$(const pxcrt::bt_double& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_double > c$ = numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_double >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glresource$n { 
auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$::auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$() : hnd$(pxcrt::bt_uint(0LL)) {
}
inline pxcrt::bt_uint auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$::get$f() const {
return hnd$.value;
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$::generate$f() {
reset$f();
{
 ::GL$n::compat$n::glGenRenderbuffers$f(1LL , pxcrt::address< pxcrt::bt_uint >(hnd$.value));
}
}
inline void auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$::reset$f() {
if (hnd$.value > pxcrt::bt_uint((0LL))) {
 {
  ::GL$n::compat$n::glDeleteRenderbuffers$f(1LL , pxcrt::caddress< pxcrt::bt_uint >(hnd$.value));
 }
 hnd$.value = pxcrt::bt_uint((0LL));
}
}
inline auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$::~auto_handle$s$p$meta$n$$uint$t$q$0$li$q$GL$$compat$n$$glGenRenderbuffers$f$q$GL$$compat$n$$glDeleteRenderbuffers$f$r$() PXC_NOTHROW {
try {
 reset$f();
} catch (...) { ::abort(); }
}
};}; /* namespace pgl3d::glresource */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a2$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace pointer$n { namespace raw$n { 
scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$() : hnd$(pxcrt::rawptr< SDL_Window >::type()) {
}
inline void scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$::reset$f(const pxcrt::rawptr< SDL_Window >::type& v$) {
if ((::operator$n::ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$r$(hnd$.value , pxcrt::rawptr< SDL_Window >::type()))) {
 SDL_DestroyWindow(hnd$.value);
}
hnd$.value = v$;
}
inline pxcrt::rawptr< SDL_Window >::type scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$::get$f() const {
return hnd$.value;
}
inline scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$::~scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$() PXC_NOTHROW {
try {
 reset$f(pxcrt::rawptr< SDL_Window >::type());
} catch (...) { ::abort(); }
}
};}; /* namespace pointer::raw */
namespace operator$n { 
static inline pxcrt::bt_bool ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$r$(const pxcrt::rawptr< SDL_Window >::type& x$, const pxcrt::rawptr< SDL_Window >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$ne$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$ne$ls$r$(const pxcrt::rawptr< SDL_Window >::type& x$, const pxcrt::rawptr< SDL_Window >::type& y$) {
/* staticif */
return pxcrt::rawptr_ne< pxcrt::rawptr< SDL_Window >::type,pxcrt::rawptr< SDL_Window >::type >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace pointer$n { namespace raw$n { 
scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$() : hnd$(SDL_GLContext()) {
}
inline void scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$::reset$f(const SDL_GLContext& v$) {
if (hnd$.value != SDL_GLContext()) {
 SDL_GL_DeleteContext(hnd$.value);
}
hnd$.value = v$;
}
inline SDL_GLContext scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$::get$f() const {
return hnd$.value;
}
inline scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$::~scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_GL_DeleteContext$f$r$() PXC_NOTHROW {
try {
 reset$f(SDL_GLContext());
} catch (...) { ::abort(); }
}
};}; /* namespace pointer::raw */
namespace SDL2$n { namespace api_base$n { 
static inline pxcrt::bt_uint SDL_Enum___to$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(int x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(x$);
}
};}; /* namespace SDL2::api_base */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(const int& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uint,int > c$ = numeric::static_cast_impl< pxcrt::bt_uint,int >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_int from_string$f$p$meta$n$$int$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
/* staticif empty *//* staticif-else */
::pxcrt::bt_cslice< pxcrt::bt_uchar > s1$ = s$;
return ::text$n::string$n::serialize$n::deserialize_from_string$f$p$meta$n$$int$t$r$(s1$);
/* staticif-else end */
}
static inline pxcrt::bt_int deserialize_from_string$f$p$meta$n$$int$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
return ::text$n::serialize$n::deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$int$t$r$(s$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline pxcrt::bt_int deserialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$int$t$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& src$) {
/* staticif empty *//* staticif-else */
/* staticif */
/* staticif */
return ::text$n::string$n::serialize$n::string_parse_token$f$p$meta$n$$int$t$q$text$$string$$positional$n$$positional_to_integral$f$p$meta$n$$int$t$q$10$li$r$$r$(src$);
/* staticif end */
/* staticif end */
/* staticif-else end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_int positional_to_integral$f$p$meta$n$$int$t$q$10$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
/* staticif empty */
if (buf$.size() == pxcrt::bt_size_t((0LL))) {
 return pxcrt::bt_int();
}
const pxcrt::bt_uchar ch$ = buf$[pxcrt::bt_size_t((0LL))];
if (ch$ == 45U) {
 buf$.increment_front(pxcrt::bt_size_t(1LL));
 return ::text$n::string$n::positional$n::positional_to_integral_internal$f$p$meta$n$$int$t$q$10$li$q$1$li$r$(buf$);
} else if (ch$ == 43U) {
 buf$.increment_front(pxcrt::bt_size_t(1LL));
 return ::text$n::string$n::positional$n::positional_to_integral_internal$f$p$meta$n$$int$t$q$10$li$q$0$li$r$(buf$);
} else {
 return ::text$n::string$n::positional$n::positional_to_integral_internal$f$p$meta$n$$int$t$q$10$li$q$0$li$r$(buf$);
}
}
static inline pxcrt::bt_int positional_to_integral_internal$f$p$meta$n$$int$t$q$10$li$q$1$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
pxcrt::bt_int r$ = pxcrt::bt_int();
{
 const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& ag$fe = (buf$);
 const size_t sz$fe = ag$fe.size();
 const pxcrt::bt_uchar *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t idx$ = 0; idx$ != sz$fe; ++idx$) {
  pxcrt::bt_uchar v$ = ar$fe[idx$];
  {
   pxcrt::bt_int dig$ = pxcrt::bt_int();
   if (::text$n::string$n::positional$n::uchar_to_integral$f$p$meta$n$$int$t$q$10$li$r$(v$ , dig$)) {
    {
     if (r$ < (::numeric$n::limit$n::lowest$f$p$meta$n$$int$t$r$() / pxcrt::bt_int(10LL))) {
      buf$.increment_front(idx$);
      return r$;
     }
    }
    r$ *= pxcrt::bt_int(10LL);
    {
     const pxcrt::bt_int nr$ = r$ - dig$;
     if (nr$ > r$) {
      buf$.increment_front(idx$);
      return r$;
     }
     r$ = nr$;
    }
   } else {
    buf$.increment_front(idx$);
    return r$;
   }
  }
 }
}
buf$.increment_front(buf$.size());
return r$;
}
static inline pxcrt::bt_bool uchar_to_integral$f$p$meta$n$$int$t$q$10$li$r$(pxcrt::bt_uchar v$, pxcrt::bt_int& dig_r$) {
if (v$ >= 48U && v$ <= pxcrt::bt_uchar(67LL)) {
 dig_r$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$int$t$q$meta$n$$uchar$t$r$(v$ - 48U);
 return true;
}
/* staticif empty */
return false;
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_uchar > c$ = numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_uchar >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace numeric$n { namespace limit$n { 
static inline pxcrt::bt_int lowest$f$p$meta$n$$int$t$r$() {
numeric::limit_impl< pxcrt::bt_int > obj$ = numeric::limit_impl< pxcrt::bt_int >();
return obj$.lowest();
}
};}; /* namespace numeric::limit */
namespace text$n { namespace string$n { namespace positional$n { 
static inline pxcrt::bt_int positional_to_integral_internal$f$p$meta$n$$int$t$q$10$li$q$0$li$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& buf$) {
pxcrt::bt_int r$ = pxcrt::bt_int();
{
 const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& ag$fe = (buf$);
 const size_t sz$fe = ag$fe.size();
 const pxcrt::bt_uchar *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t idx$ = 0; idx$ != sz$fe; ++idx$) {
  pxcrt::bt_uchar v$ = ar$fe[idx$];
  {
   pxcrt::bt_int dig$ = pxcrt::bt_int();
   if (::text$n::string$n::positional$n::uchar_to_integral$f$p$meta$n$$int$t$q$10$li$r$(v$ , dig$)) {
    /* staticif empty */{
     if (r$ > (::numeric$n::limit$n::highest$f$p$meta$n$$int$t$r$() / pxcrt::bt_int(10LL))) {
      buf$.increment_front(idx$);
      return r$;
     }
    }
    r$ *= pxcrt::bt_int(10LL);
    /* staticif empty */{
     const pxcrt::bt_int nr$ = r$ + dig$;
     if (nr$ < r$) {
      buf$.increment_front(idx$);
      return r$;
     }
     r$ = nr$;
    }
   } else {
    buf$.increment_front(idx$);
    return r$;
   }
  }
 }
}
buf$.increment_front(buf$.size());
return r$;
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace limit$n { 
static inline pxcrt::bt_int highest$f$p$meta$n$$int$t$r$() {
numeric::limit_impl< pxcrt::bt_int > obj$ = numeric::limit_impl< pxcrt::bt_int >();
return obj$.highest();
}
};}; /* namespace numeric::limit */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline pxcrt::bt_int string_parse_token$f$p$meta$n$$int$t$q$text$$string$$positional$n$$positional_to_integral$f$p$meta$n$$int$t$q$10$li$r$$r$(::pxcrt::bt_cslice< pxcrt::bt_uchar >& s$) {
const pxcrt::bt_size_t toklen$ = ::text$n::string$n::serialize$n::token_length$f(s$);
::pxcrt::bt_cslice< pxcrt::bt_uchar > stok$ = ::pxcrt::bt_cslice< pxcrt::bt_uchar >(s$, pxcrt::bt_size_t((0LL)), toklen$);
s$.increment_front(toklen$);
return ::text$n::string$n::positional$n::positional_to_integral$f$p$meta$n$$int$t$q$10$li$r$(stok$);
}
};};}; /* namespace text::string::serialize */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , a1$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$exception$n$$c_exception$i$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const std::exception& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$exception$n$$c_exception$i$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$exception$n$$c_exception$i$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const std::exception& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$exception$n$$c_exception$i$r$(a1$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$exception$n$$c_exception$i$r$(const std::exception& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$exception$n$$c_exception$i$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$exception$n$$c_exception$i$r$(const std::exception& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::exception$n::c_exception_append_to_string$f(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace pointer$n { namespace raw$n { 
scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$::scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$() : hnd$(pxcrt::rawptr< SDL_RWops >::type()) {
}
inline void scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$::reset$f(const pxcrt::rawptr< SDL_RWops >::type& v$) {
if ((::operator$n::ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$(hnd$.value , pxcrt::rawptr< SDL_RWops >::type()))) {
 SDL2::RWclose(hnd$.value);
}
hnd$.value = v$;
}
inline pxcrt::rawptr< SDL_RWops >::type scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$::get$f() const {
return hnd$.value;
}
inline scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$::~scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$() PXC_NOTHROW {
try {
 reset$f(pxcrt::rawptr< SDL_RWops >::type());
} catch (...) { ::abort(); }
}
};}; /* namespace pointer::raw */
namespace operator$n { 
static inline pxcrt::bt_bool ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$(const pxcrt::rawptr< SDL_RWops >::type& x$, const pxcrt::rawptr< SDL_RWops >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$ne$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$ne$ls$r$(const pxcrt::rawptr< SDL_RWops >::type& x$, const pxcrt::rawptr< SDL_RWops >::type& y$) {
/* staticif */
return pxcrt::rawptr_ne< pxcrt::rawptr< SDL_RWops >::type,pxcrt::rawptr< SDL_RWops >::type >(x$ , y$);
/* staticif end */
}
static inline pxcrt::bt_bool eq$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$(const pxcrt::rawptr< SDL_RWops >::type& x$, const pxcrt::rawptr< SDL_RWops >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$eq$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::bt_bool binop$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$eq$ls$r$(const pxcrt::rawptr< SDL_RWops >::type& x$, const pxcrt::rawptr< SDL_RWops >::type& y$) {
/* staticif */
return pxcrt::rawptr_eq< pxcrt::rawptr< SDL_RWops >::type,pxcrt::rawptr< SDL_RWops >::type >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace exception$n { 
runtime_error_template$s$p$sdl__read__file$ls$r$::runtime_error_template$s$p$sdl__read__file$ls$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& m$) : count$z(1), msg$(::pxcrt::pxcvarray< pxcrt::bt_uchar >(m$)) {
}
inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > runtime_error_template$s$p$sdl__read__file$ls$r$::message() const {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("runtime_error{sdl_read_file}("));
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(s$ , msg$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(")"));
return s$;
}
}; /* namespace exception */
namespace operator$n { 
static inline pxcrt::rawptr< SDL_RWops >::type implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$$r$(const ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$& x$) {
return x$.__to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$();
}
}; /* namespace operator */
namespace pointer$n { namespace raw$n { 
inline pxcrt::rawptr< SDL_RWops >::type scoped_nullable$s$p$SDL2$$api_wrappers$n$$SDL_RWclose$f$r$::__to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$() const {
return hnd$.value;
}
};}; /* namespace pointer::raw */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_double static_cast$f$p$meta$n$$double$t$q$numeric$$integral$n$$ulonglong$s$r$(const ::pxcrt::bt_ulonglong& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_double,::pxcrt::bt_ulonglong > c$ = numeric::static_cast_impl< pxcrt::bt_double,::pxcrt::bt_ulonglong >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$numeric$$integral$n$$ulonglong$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_ulonglong& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$numeric$$integral$n$$ulonglong$s$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$numeric$$integral$n$$ulonglong$s$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_ulonglong& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$numeric$$integral$n$$ulonglong$s$r$(a1$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$numeric$$integral$n$$ulonglong$s$r$(const ::pxcrt::bt_ulonglong& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$numeric$$integral$n$$ulonglong$s$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$numeric$$integral$n$$ulonglong$s$r$(const ::pxcrt::bt_ulonglong& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::positional$n::integral_to_positional$f$p$numeric$$integral$n$$ulonglong$s$q$10$li$r$(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$numeric$$integral$n$$ulonglong$s$q$10$li$r$(::pxcrt::bt_ulonglong v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
/* staticif empty */
if (v$ == ::pxcrt::bt_ulonglong((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 48U);
 return;
}
pxcrt::bt_size_t pos0$ = buf$.size();
if (v$ < ::pxcrt::bt_ulonglong((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 45U);
 pos0$ += pxcrt::bt_size_t(1LL);
 while (v$ != ::pxcrt::bt_ulonglong((0LL))) {
  ::pxcrt::bt_ulonglong rem$ = v$ % ::pxcrt::bt_ulonglong(10LL);
  v$ /= ::pxcrt::bt_ulonglong(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$numeric$$integral$n$$ulonglong$s$r$(-rem$) + 48U);
  }
 }
} else {
 while (v$ != ::pxcrt::bt_ulonglong((0LL))) {
  ::pxcrt::bt_ulonglong rem$ = v$ % ::pxcrt::bt_ulonglong(10LL);
  v$ /= ::pxcrt::bt_ulonglong(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$numeric$$integral$n$$ulonglong$s$r$(rem$) + 48U);
  }
 }
}
::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::bt_slice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (buf$).get()), pos0$, buf$.size()));
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$numeric$$integral$n$$ulonglong$s$r$(const ::pxcrt::bt_ulonglong& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uchar,::pxcrt::bt_ulonglong > c$ = numeric::static_cast_impl< pxcrt::bt_uchar,::pxcrt::bt_ulonglong >();
return c$.convert(x$);
/* staticif end */
}
static inline pxcrt::bt_double static_cast$f$p$meta$n$$double$t$q$meta$n$$size_t$t$r$(const pxcrt::bt_size_t& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_double,pxcrt::bt_size_t > c$ = numeric::static_cast_impl< pxcrt::bt_double,pxcrt::bt_size_t >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace operator$n { 
static inline pxcrt::rawptr< SDL_Window >::type implicit_conversion_mf$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$q$pointer$$raw$n$$scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$$r$(const ::pointer$n::raw$n::scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$& x$) {
return x$.__to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$r$();
}
}; /* namespace operator */
namespace pointer$n { namespace raw$n { 
inline pxcrt::rawptr< SDL_Window >::type scoped_nullable$s$p$SDL2$$api_functions$n$$SDL_DestroyWindow$f$r$::__to$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_Window$s$r$$r$() const {
return hnd$.value;
}
};}; /* namespace pointer::raw */
namespace SDL2$n { namespace api_base$n { 
static inline pxcrt::bt_uchar SDL_Enum___to$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(int x$) {
return ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(x$);
}
};}; /* namespace SDL2::api_base */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$SDL2$$api_base$n$$SDL_Enum$s$r$(const int& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uchar,int > c$ = numeric::static_cast_impl< pxcrt::bt_uchar,int >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const ::pxcrt::bt_strlit& a2$, const pxcrt::bt_int& a3$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const ::pxcrt::bt_strlit& a2$, const pxcrt::bt_int& a3$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a2$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a3$ , s$);
 }
}
return s$;
}
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$1$li$r$$q$m$ll$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$1$li$r$$r$$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const ::pxcrt::farray< pxcrt::bt_uint,8LL >& a2$, const pxcrt::bt_size_t& a3$, const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a4$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& a5$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$float$t$r$(a0$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$float$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$r$(a2$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a3$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(a4$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(a5$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$float$t$r$(const pxcrt::bt_float& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$ , out$);
}
static inline void serialize_to_string$f$p$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$r$(const ::pxcrt::farray< pxcrt::bt_uint,8LL >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$farray$s$p$meta$n$$uint$t$q$8$li$r$$r$(const ::pxcrt::farray< pxcrt::bt_uint,8LL >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
{
 const ::pxcrt::farray< pxcrt::bt_uint,8LL >& ag$fe = (x$);
 const size_t sz$fe = ag$fe.size();
 const pxcrt::bt_uint *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const pxcrt::bt_uint& v$ = ar$fe[i$];
  {
   if (i$ != pxcrt::bt_size_t((0LL))) {
    ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
   }
   ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uint$t$r$(v$ , o$);
  }
 }
}
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tquat$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
if ((0LL) != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("w") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$.w , o$);
if (1LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("x") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$.x , o$);
if (2LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("y") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$.y , o$);
if (3LL != (0LL)) {
 ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
}
::text$n::string$n::serialize$n::string_append_noesc$f$p$container$$array$n$$strlit$s$r$(pxcrt::bt_strlit("z") , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(x$.z , o$);
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace container$n { namespace tree_map$n { 
static inline void tree_map_compare_swap$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& x$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& y$) {
::pxcrt::memfunc_swap< pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > >(x$ , y$);
}
};}; /* namespace container::tree_map */
namespace pgl3d$n { namespace pglmotion$n { 
inline void motion_thread_object$s::wait_and_exec$f$p$pgl3d$$mainloop$n$$swap_data_cl$f42$r$(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& _0$up, ::pgl3d$n::pglshader$n::pglshader$s& _1$up, ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< ::pgl3d$n::pglbase$n::instance_data$s > >& _2$up, ::pgl3d$n::mainloop$n::framerate_control$s& _3$up, pxcrt::bt_size_t& _4$up, ::pgl3d$n::pglbase$n::projection_info$s& _5$up, ::pxcrt::pxcvarray< pxcrt::bt_uchar > const& _6$up) {
pxcrt::lock_guard< pxcrt::trcval< ::pgl3d$n::pglmotion$n::motion_thread_shared$s > > lck$((sharedp$));
::pgl3d$n::pglmotion$n::motion_thread_shared$s& shared$ = ((lck$)->value);
while (true) {
 if (!shared$.modifying$) {
  break;
 }
 lck$.wait();
}
::pgl3d$n::mainloop$n::swap_data_cl$f42(_0$up, _1$up, _2$up, _3$up, _4$up, _5$up, _6$up , shared$);
shared$.modifying$ = true;
lck$.notify_one();
}
};}; /* namespace pgl3d::pglmotion */
namespace Bullet$n { namespace api$n { 
static inline ::btVector3 btVector3_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_float& a2$) {
/* staticif */
return ::btVector3(a0$ , a1$ , a2$);
/* staticif end */
}
};}; /* namespace Bullet::api */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::rawptr< ::btMotionState >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btMotionState$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDefaultMotionState$s$r$$r$(pxcrt::rawptr< ::btDefaultMotionState >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::rawptr< ::btMotionState >::type,pxcrt::rawptr< ::btDefaultMotionState >::type >(x$);
/* staticif end */
}
static inline pxcrt::rawptr< ::btCollisionConfiguration >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionConfiguration$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDefaultCollisionConfiguration$s$r$$r$(pxcrt::rawptr< ::btDefaultCollisionConfiguration >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::rawptr< ::btCollisionConfiguration >::type,pxcrt::rawptr< ::btDefaultCollisionConfiguration >::type >(x$);
/* staticif end */
}
static inline pxcrt::rawptr< ::btDispatcher >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDispatcher$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionDispatcher$s$r$$r$(pxcrt::rawptr< ::btCollisionDispatcher >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::rawptr< ::btDispatcher >::type,pxcrt::rawptr< ::btCollisionDispatcher >::type >(x$);
/* staticif end */
}
static inline pxcrt::rawptr< ::btBroadphaseInterface >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btBroadphaseInterface$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btDbvtBroadphase$s$r$$r$(pxcrt::rawptr< ::btDbvtBroadphase >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::rawptr< ::btBroadphaseInterface >::type,pxcrt::rawptr< ::btDbvtBroadphase >::type >(x$);
/* staticif end */
}
static inline pxcrt::rawptr< ::btConstraintSolver >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btConstraintSolver$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btSequentialImpulseConstraintSolver$s$r$$r$(pxcrt::rawptr< ::btSequentialImpulseConstraintSolver >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::rawptr< ::btConstraintSolver >::type,pxcrt::rawptr< ::btSequentialImpulseConstraintSolver >::type >(x$);
/* staticif end */
}
static inline pxcrt::rawptr< ::btCollisionObject >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionObject$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btRigidBody$s$r$$r$(pxcrt::rawptr< ::btRigidBody >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::rawptr< ::btCollisionObject >::type,pxcrt::rawptr< ::btRigidBody >::type >(x$);
/* staticif end */
}
};}; /* namespace pointer::raw */
namespace Bullet$n { namespace api$n { 
static inline void btDiscreteDynamicsWorld_addRigidBody$f$p$m$ll$p$m$ll$p$Bullet$$api$n$$btDiscreteDynamicsWorld$s$q$1$li$r$$q$m$ll$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btRigidBody$s$r$$q$0$li$r$$r$$r$(::btDiscreteDynamicsWorld& a0$, const pxcrt::rawptr< ::btRigidBody >::type& a1$) {
/* staticif */
return a0$.addRigidBody(a1$);
/* staticif end */
}
};}; /* namespace Bullet::api */
namespace pgl3d$n { namespace sdlutil$n { 
sdl_file$s$p$0$li$r$::sdl_file$s$p$0$li$r$() : ptr$(pxcrt::rawptr< SDL_RWops >::type()) {
}
inline pxcrt::bt_bool sdl_file$s$p$0$li$r$::is_null$f() const {
return (::operator$n::eq$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$(ptr$.value , pxcrt::rawptr< SDL_RWops >::type()));
}
inline pxcrt::rawptr< SDL_RWops >::type sdl_file$s$p$0$li$r$::get$f() const {
return ptr$.value;
}
inline void sdl_file$s$p$0$li$r$::reset$f(pxcrt::rawptr< SDL_RWops >::type p$) {
if ((::operator$n::ne$f$p$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$q$pointer$$raw$n$$rawptr$s$p$SDL2$$api_types$n$$SDL_RWops$s$r$$r$(ptr$.value , pxcrt::rawptr< SDL_RWops >::type()))) {
 SDL2::RWclose(ptr$.value);
}
ptr$.value = p$;
}
inline sdl_file$s$p$0$li$r$::~sdl_file$s$p$0$li$r$() PXC_NOTHROW {
try {
 reset$f(pxcrt::rawptr< SDL_RWops >::type());
} catch (...) { ::abort(); }
}
};}; /* namespace pgl3d::sdlutil */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,2LL > make_farray_split$f$p$2$li$q$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$) {
::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,2LL > arr$ = ::pxcrt::farray< ::pxcrt::bt_cslice< pxcrt::bt_uchar >,2LL >();
pxcrt::bt_size_t p$ = pxcrt::bt_size_t();
for (pxcrt::bt_size_t i$ = pxcrt::bt_size_t((0LL)); i$ < pxcrt::bt_size_t(2LL); ++i$) {
 const pxcrt::bt_size_t pend$ = ::container$n::array$n::find_mapped$f$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(c$ , p$ , v$);
 (arr$.begin()[i$]) = ::pxcrt::bt_cslice< pxcrt::bt_uchar >(c$, p$, pend$);
 if (pend$ == c$.size()) {
  break;
 }
 p$ = pend$ + pxcrt::bt_size_t(1LL);
}
return arr$;
}
static inline void split_foreach$f$p$demoapp$n$$$f2$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& _0$up, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& c$, const pxcrt::bt_uchar& v$) {
pxcrt::bt_size_t p$ = pxcrt::bt_size_t();
while (true) {
 const pxcrt::bt_size_t pend$ = ::container$n::array$n::find_mapped$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(c$ , p$ , v$);
 ::demoapp$n::$f2(_0$up , ::pxcrt::bt_cslice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (c$).get()), p$, pend$));
 if (pend$ == c$.size()) {
  break;
 }
 p$ = pend$ + pxcrt::bt_size_t(1LL);
}
}
static inline pxcrt::bt_size_t find_mapped$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$meta$n$$size_t$t$q$meta$n$$uchar$t$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& c$, pxcrt::bt_size_t k$, const pxcrt::bt_uchar& x$) {
/* staticif */
return ::pxcrt::find_mapped_memchr< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >(c$ , k$ , x$);
/* staticif end */
}
};}; /* namespace container::array */
namespace io$n { namespace standard$n { 
static inline void println$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$);
::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\012"));
::io$n::file$n::file_write_all$f(pxcrt::io_stdout(pxcrt::io_system) , (::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace io::standard */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_20$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit(" "));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(a1$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$r$(const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
pxcrt::bt_bool is_first$ = true;
{
 const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& ag$fe = (x$);
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::guard_ref< const pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > > ag$fg(ag$fe);
 for (pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >::const_iterator i$fe = ag$fe.begin(); i$fe != ag$fe.end(); ++i$fe) {
  const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& k$ = ag$fe.get_ckey(i$fe);
  const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$ = ag$fe.get_cmapped(i$fe);
  {
   if (is_first$) {
    is_first$ = false;
   } else {
    ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
   }
   ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(k$ , o$);
   ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
   ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(v$ , o$);
  }
 }
}
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_escape$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void string_append_escape$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& v$) {
pxcrt::minimal_encode((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (x$).get_crange()) , v$);
}
};};}; /* namespace text::string::serialize */
namespace pointer$n { 
static inline pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > make_tptr$f$p$demoapp$n$$demoapp_scene_shared$s$q$m$ll$r$() {
return ::pointer$n::box_pointer$f$p$pxcrt$$tptr$p$demoapp$n$$demoapp_scene_shared$s$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > box_pointer$f$p$pxcrt$$tptr$p$demoapp$n$$demoapp_scene_shared$s$r$$q$m$ll$r$() {
/* staticif empty *//* staticif-else */
::demoapp$n::demoapp_scene_shared$s*const r$p1 = ::demoapp$n::demoapp_scene_shared$s::allocate();
try {
new (r$p1) ::demoapp$n::demoapp_scene_shared$s();
} catch (...) {
::demoapp$n::demoapp_scene_shared$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::demoapp$n::demoapp_scene_shared$s > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< ::demoapp$n::demoapp_scene$s > make_ptr$f$p$demoapp$n$$demoapp_scene$s$q$m$ll$p$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$pxcrt$$tcptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(const ::pgl3d$n::scene_node$n::node_factory$s& a0$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& a1$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$demoapp$n$$demoapp_scene$s$r$$q$m$ll$p$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$pxcrt$$tcptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(a0$ , a1$);
}
static inline pxcrt::rcptr< ::demoapp$n::demoapp_scene$s > box_pointer$f$p$pxcrt$$ptr$p$demoapp$n$$demoapp_scene$s$r$$q$m$ll$p$m$ll$p$pgl3d$$scene_node$n$$node_factory$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$pxcrt$$tcptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(const ::pgl3d$n::scene_node$n::node_factory$s& a0$, pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >& a1$) {
/* staticif empty *//* staticif-else */
::demoapp$n::demoapp_scene$s*const r$p1 = ::demoapp$n::demoapp_scene$s::allocate();
try {
new (r$p1) ::demoapp$n::demoapp_scene$s(a0$ , a1$);
} catch (...) {
::demoapp$n::demoapp_scene$s::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::demoapp$n::demoapp_scene$s > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace operator$n { 
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type sub$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$sub$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$sub$ls$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$) {
/* staticif */
return pxcrt::glmpx::op_sub< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(x$ , y$);
/* staticif end */
}
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type add$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$add$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$add$ls$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$) {
/* staticif */
return pxcrt::glmpx::op_add< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(x$ , y$);
/* staticif end */
}
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type div$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
/* staticif */
return pxcrt::glmpx::op_div< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type,pxcrt::bt_float >(x$ , y$);
/* staticif end */
}
static inline void diva$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
/* staticif empty *//* staticif-else */
::operator$n::binopa$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline void binopa$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$div$ls$r$(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
/* staticif */
x$ = pxcrt::glmpx::op_div< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type,pxcrt::bt_float >(x$ , y$);
/* staticif end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type mul$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$mul$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec3< pxcrt::bt_float >::type binop$f$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$glm$n$$tvec3$s$p$meta$n$$float$t$r$$q$mul$ls$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec3< pxcrt::bt_float >::type& y$) {
/* staticif */
return pxcrt::glmpx::op_mul< pxcrt::glmpx::tquat< pxcrt::bt_float >::type,pxcrt::glmpx::tvec3< pxcrt::bt_float >::type,pxcrt::glmpx::tvec3< pxcrt::bt_float >::type >(x$ , y$);
/* staticif end */
}
static inline pxcrt::bt_float getelem$f$p$container$$raw$n$$rawarray$s$p$meta$n$$float$t$q$4$li$r$$q$meta$n$$uint$t$r$(const ::pxcrt::rawarray< pxcrt::bt_float,4LL >::type& x$, const pxcrt::bt_uint& y$) {
/* staticif empty *//* staticif-else */
return ::pxcrt::rawarray___getelem< pxcrt::bt_float,4LL >(x$ , pxcrt::bt_size_t(y$));
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type mul$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
/* staticif empty *//* staticif-else */
return ::operator$n::binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline pxcrt::glmpx::tvec2< pxcrt::bt_float >::type binop$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$meta$n$$float$t$q$mul$ls$r$(const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::bt_float& y$) {
/* staticif */
return pxcrt::glmpx::op_mul< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type,pxcrt::bt_float,pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(x$ , y$);
/* staticif end */
}
static inline void suba$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$r$(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$) {
/* staticif empty *//* staticif-else */
::operator$n::binopa$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$sub$ls$r$(x$ , y$);
/* staticif-else end */
}
static inline void binopa$f$p$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$glm$n$$tvec2$s$p$meta$n$$float$t$r$$q$sub$ls$r$(pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& x$, const pxcrt::glmpx::tvec2< pxcrt::bt_float >::type& y$) {
/* staticif */
x$ = pxcrt::glmpx::op_sub< pxcrt::glmpx::tvec2< pxcrt::bt_float >::type >(x$ , y$);
/* staticif end */
}
}; /* namespace operator */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$uchar$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$, const pxcrt::bt_uchar& a3$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$uchar$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$uchar$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$, const pxcrt::bt_uchar& a3$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a1$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$int$t$r$(a2$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$uchar$t$r$(a3$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uchar$t$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::positional$n::integral_to_positional$f$p$meta$n$$uchar$t$q$10$li$r$(x$ , o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$uchar$t$q$10$li$r$(pxcrt::bt_uchar v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
/* staticif empty */
if (v$ == pxcrt::bt_uchar((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 48U);
 return;
}
pxcrt::bt_size_t pos0$ = buf$.size();
if (v$ < pxcrt::bt_uchar((0LL))) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 45U);
 pos0$ += pxcrt::bt_size_t(1LL);
 while (v$ != pxcrt::bt_uchar((0LL))) {
  pxcrt::bt_uchar rem$ = v$ % pxcrt::bt_uchar(10LL);
  v$ /= pxcrt::bt_uchar(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uchar$t$r$(-rem$) + 48U);
  }
 }
} else {
 while (v$ != pxcrt::bt_uchar((0LL))) {
  pxcrt::bt_uchar rem$ = v$ % pxcrt::bt_uchar(10LL);
  v$ /= pxcrt::bt_uchar(10LL);
  {
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uchar$t$r$(rem$) + 48U);
  }
 }
}
::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::bt_slice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (buf$).get()), pos0$, buf$.size()));
}
};};}; /* namespace text::string::positional */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uchar static_cast$f$p$meta$n$$uchar$t$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_uchar > c$ = numeric::static_cast_impl< pxcrt::bt_uchar,pxcrt::bt_uchar >();
return c$.convert(x$);
/* staticif end */
}
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$SDL2$$api_types$n$$SDL_Scancode$s$r$(const int& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_int,int > c$ = numeric::static_cast_impl< pxcrt::bt_int,int >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace text$n { namespace string$n { namespace positional$n { 
static inline void integral_to_positional$f$p$meta$n$$int$t$q$16$li$r$(pxcrt::bt_int v$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& buf$) {
/* staticif empty */
if (v$ == (0LL)) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 48U);
 return;
}
pxcrt::bt_size_t pos0$ = buf$.size();
if (v$ < (0LL)) {
 ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , 45U);
 pos0$ += pxcrt::bt_size_t(1LL);
 while (v$ != (0LL)) {
  pxcrt::bt_int rem$ = v$ % pxcrt::bt_int(16LL);
  v$ /= pxcrt::bt_int(16LL);
  /* staticif empty */{
   const pxcrt::bt_uchar dv$ = -::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$int$t$r$(-rem$);
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , dv$ <= pxcrt::bt_uchar(10LL) ? dv$ + 48U : dv$ + 97U - pxcrt::bt_uchar(10LL));
  }
 }
} else {
 while (v$ != (0LL)) {
  pxcrt::bt_int rem$ = v$ % pxcrt::bt_int(16LL);
  v$ /= pxcrt::bt_int(16LL);
  /* staticif empty */{
   const pxcrt::bt_uchar dv$ = ::numeric$n::cast$n::static_cast$f$p$meta$n$$uchar$t$q$meta$n$$int$t$r$(rem$);
   ::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(buf$ , dv$ <= pxcrt::bt_uchar(10LL) ? dv$ + 48U : dv$ + 97U - pxcrt::bt_uchar(10LL));
  }
 }
}
::container$n::array$n::reverse$f$p$container$$array$n$$slice$s$p$meta$n$$uchar$t$r$$r$(::pxcrt::bt_slice< pxcrt::bt_uchar >((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (buf$).get()), pos0$, buf$.size()));
}
};};}; /* namespace text::string::positional */
namespace pgl3d$n { namespace glconf$n { 
static inline void sdllog$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$) {
const ::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(a0$ , a1$);
::pgl3d$n::glconf$n::sdllog_impl$f((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace pgl3d::glconf */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_uint static_cast$f$p$meta$n$$uint$t$q$SDL2$$api_types$n$$SDL_Scancode$s$r$(const int& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_uint,int > c$ = numeric::static_cast_impl< pxcrt::bt_uint,int >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace container$n { namespace array$n { 
static inline ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,1LL > make_farray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$) {
::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,1LL > arr$ = ::pxcrt::farray< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,1LL >();
arr$[pxcrt::bt_size_t((0LL))] = a0$;
return arr$;
}
static inline ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > make_varray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$2$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$, const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a1$) {
::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > arr$ = ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >();
::pxcrt::array_resize< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(arr$ , pxcrt::bt_size_t(2LL) , ::pxcrt::pxcvarray< pxcrt::bt_uchar >());
arr$[pxcrt::bt_size_t((0LL))] = a0$;
arr$[pxcrt::bt_size_t(1LL)] = a1$;
return arr$;
}
static inline ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > make_varray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$) {
::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > arr$ = ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >();
::pxcrt::array_resize< ::pxcrt::pxcvarray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > >,::pxcrt::pxcvarray< pxcrt::bt_uchar > >(arr$ , pxcrt::bt_size_t(1LL) , ::pxcrt::pxcvarray< pxcrt::bt_uchar >());
arr$[pxcrt::bt_size_t((0LL))] = a0$;
return arr$;
}
};}; /* namespace container::array */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$(const ::pgl3d$n::wfobj$n::wfobject$s& wfo$, const ::pgl3d$n::wfobj$n::wfgroup$s& wfgrp$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$$q$m$ll$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$0$li$r$$q$m$ll$p$pgl3d$$wfobj$n$$wfgroup$s$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(wfo$ , wfgrp$ , c0$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$(const ::pgl3d$n::wfobj$n::wfobject$s& wfo$, const ::pgl3d$n::wfobj$n::wfgroup$s& wfgrp$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) : count$z(1), fld$(wfo$ , wfgrp$ , c0$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_import_wfobj$f(fld$._0$ , fld$._1$ , fld$._2$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$pgl3d$$wfobj$n$$wfgroup$s$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$pgl3d$$wfobj$n$$wfgroup$s$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const ::pgl3d$n::wfobj$n::wfobject$s& a0$, const ::pgl3d$n::wfobj$n::wfgroup$s& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$) : _0$(a0$), _1$(a1$), _2$(a2$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$$q$m$ll$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$0$li$r$$q$m$ll$p$pgl3d$$wfobj$n$$wfgroup$s$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const ::pgl3d$n::wfobj$n::wfobject$s& a0$, const ::pgl3d$n::wfobj$n::wfgroup$s& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$$r$$q$m$ll$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$0$li$r$$q$m$ll$p$pgl3d$$wfobj$n$$wfgroup$s$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$$r$$q$m$ll$p$m$ll$p$pgl3d$$wfobj$n$$wfobject$s$q$0$li$r$$q$m$ll$p$pgl3d$$wfobj$n$$wfgroup$s$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const ::pgl3d$n::wfobj$n::wfobject$s& a0$, const ::pgl3d$n::wfobj$n::wfgroup$s& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$(a0$ , a1$ , a2$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_import_wfobj$f$q$3$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t n$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(n$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(pxcrt::bt_size_t n$) : count$z(1), fld$(n$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_ctx_fill$f(fld$._0$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$meta$n$$size_t$t$r$$q$m$ll$r$::tuple$s$p$m$ll$p$meta$n$$size_t$t$r$$q$m$ll$r$(const pxcrt::bt_size_t& a0$) : _0$(a0$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill$f$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(radius$ , n$ , c0$ , c1$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$) : count$z(1), fld$(radius$ , n$ , c0$ , c1$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_regular_polygon$f(fld$._0$ , fld$._1$ , fld$._2$ , fld$._3$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$) : _0$(a0$), _1$(a1$), _2$(a2$), _3$(a3$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$(a0$ , a1$ , a2$ , a3$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_regular_polygon$f$q$4$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(m$ , c0$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) : count$z(1), fld$(m$ , c0$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_apply$f(fld$._0$ , fld$._1$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) : _0$(a0$), _1$(a1$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$(a0$ , a1$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_apply$f$q$2$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, pxcrt::bt_bool split_reverse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(m$ , split_reverse$ , c0$ , c1$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& m$, pxcrt::bt_bool split_reverse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$) : count$z(1), fld$(m$ , split_reverse$ , c0$ , c1$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_bump_apply$f(fld$._0$ , fld$._1$ , fld$._2$ , fld$._3$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$meta$n$$bool$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$meta$n$$bool$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, const pxcrt::bt_bool& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$) : _0$(a0$), _1$(a1$), _2$(a2$), _3$(a3$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, pxcrt::bt_bool& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tmat4$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tmat4< pxcrt::bt_float >::type& a0$, pxcrt::bt_bool& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$(a0$ , a1$ , a2$ , a3$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_apply$f$q$4$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float z$, pxcrt::bt_float scale$, pxcrt::bt_int recurse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(z$ , scale$ , recurse$ , c0$ , c1$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(pxcrt::bt_float z$, pxcrt::bt_float scale$, pxcrt::bt_int recurse$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$) : count$z(1), fld$(z$ , scale$ , recurse$ , c0$ , c1$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_bump_rec$f(fld$._0$ , fld$._1$ , fld$._2$ , fld$._3$ , fld$._4$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$int$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$int$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_int& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a4$) : _0$(a0$), _1$(a1$), _2$(a2$), _3$(a3$), _4$(a4$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_float& a1$, pxcrt::bt_int& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a4$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$ , a4$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$int$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_float& a1$, pxcrt::bt_int& a2$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a3$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a4$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$(a0$ , a1$ , a2$ , a3$ , a4$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_bump_rec$f$q$5$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$(pxcrt::bt_size_t split$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(split$ , c0$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$(pxcrt::bt_size_t split$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) : count$z(1), fld$(split$ , c0$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_sphere$f(fld$._0$ , fld$._1$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_size_t& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) : _0$(a0$), _1$(a1$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$(a0$ , a1$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_sphere$f$q$2$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$(pxcrt::bt_size_t n$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(n$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$(pxcrt::bt_size_t n$) : count$z(1), fld$(n$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_ctx_fill_smooth$f(fld$._0$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$r$$r$(pxcrt::bt_size_t& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_fill_smooth$f$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(joint_name$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$) : count$z(1), fld$(joint_name$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_ctx_poly_joint$f(fld$._0$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$q$m$ll$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$) : _0$(a0$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_poly_joint$f$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$() {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$$q$m$ll$r$());
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$() : count$z(1), fld$(::operator$n::tuple$s$p$m$ll$q$m$ll$r$()) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_hole$f(ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$q$m$ll$r$::tuple$s$p$m$ll$q$m$ll$r$() {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$$q$m$ll$r$() {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$$r$$q$m$ll$r$();
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$$r$$q$m$ll$r$() {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$();
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_hole$f$q$0$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t split_x$, pxcrt::bt_size_t split_y$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(split_x$ , split_y$ , c0$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(pxcrt::bt_size_t split_x$, pxcrt::bt_size_t split_y$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) : count$z(1), fld$(split_x$ , split_y$ , c0$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_rectangle_split$f(fld$._0$ , fld$._1$ , fld$._2$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$size_t$t$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_size_t& a0$, const pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$) : _0$(a0$), _1$(a1$), _2$(a2$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, pxcrt::bt_size_t& a1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a2$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$(a0$ , a1$ , a2$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rectangle_split$f$q$3$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& q$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$$q$m$ll$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(q$ , c0$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& q$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) : count$z(1), fld$(q$ , c0$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_rotate_local$f(fld$._0$ , fld$._1$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) : _0$(a0$), _1$(a1$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$$q$m$ll$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$$r$$q$m$ll$p$m$ll$p$glm$n$$tquat$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(const pxcrt::glmpx::tquat< pxcrt::bt_float >::type& a0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a1$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$(a0$ , a1$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rotate_local$f$q$2$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$(pxcrt::bt_size_t num$, pxcrt::bt_float scale$, pxcrt::bt_float xmin$, pxcrt::bt_float xmax$, pxcrt::bt_float ymin$, pxcrt::bt_float ymax$, pxcrt::bt_float zmin$, pxcrt::bt_float zmax$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c2$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(num$ , scale$ , xmin$ , xmax$ , ymin$ , ymax$ , zmin$ , zmax$ , rnd$ , c0$ , c1$ , c2$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$(pxcrt::bt_size_t num$, pxcrt::bt_float scale$, pxcrt::bt_float xmin$, pxcrt::bt_float xmax$, pxcrt::bt_float ymin$, pxcrt::bt_float ymax$, pxcrt::bt_float zmin$, pxcrt::bt_float zmax$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c1$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c2$) : count$z(1), fld$(num$ , scale$ , xmin$ , xmax$ , ymin$ , ymax$ , zmin$ , zmax$ , rnd$ , c0$ , c1$ , c2$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_rand_bump$f(fld$._0$ , fld$._1$ , fld$._2$ , fld$._3$ , fld$._4$ , fld$._5$ , fld$._6$ , fld$._7$ , fld$._8$ , fld$._9$ , fld$._10$ , fld$._11$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$meta$n$$size_t$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$meta$n$$float$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_size_t& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_float& a2$, const pxcrt::bt_float& a3$, const pxcrt::bt_float& a4$, const pxcrt::bt_float& a5$, const pxcrt::bt_float& a6$, const pxcrt::bt_float& a7$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a8$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a9$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a10$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a11$) : _0$(a0$), _1$(a1$), _2$(a2$), _3$(a3$), _4$(a4$), _5$(a5$), _6$(a6$), _7$(a7$), _8$(a8$), _9$(a9$), _10$(a10$), _11$(a11$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, pxcrt::bt_float& a1$, pxcrt::bt_float& a2$, pxcrt::bt_float& a3$, pxcrt::bt_float& a4$, pxcrt::bt_float& a5$, pxcrt::bt_float& a6$, pxcrt::bt_float& a7$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a8$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a9$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a10$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a11$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$ , a4$ , a5$ , a6$ , a7$ , a8$ , a9$ , a10$ , a11$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_size_t& a0$, pxcrt::bt_float& a1$, pxcrt::bt_float& a2$, pxcrt::bt_float& a3$, pxcrt::bt_float& a4$, pxcrt::bt_float& a5$, pxcrt::bt_float& a6$, pxcrt::bt_float& a7$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a8$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a9$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a10$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a11$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$(a0$ , a1$ , a2$ , a3$ , a4$ , a5$ , a6$ , a7$ , a8$ , a9$ , a10$ , a11$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_bump$f$q$12$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, pxcrt::bt_bool surface_flag$, pxcrt::bt_bool rotate_flag$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(radius$ , n$ , surface_flag$ , rotate_flag$ , rnd$ , c0$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(pxcrt::bt_float radius$, pxcrt::bt_size_t n$, pxcrt::bt_bool surface_flag$, pxcrt::bt_bool rotate_flag$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& rnd$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& c0$) : count$z(1), fld$(radius$ , n$ , surface_flag$ , rotate_flag$ , rnd$ , c0$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_rand_sphere$f(fld$._0$ , fld$._1$ , fld$._2$ , fld$._3$ , fld$._4$ , fld$._5$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace operator$n { 
tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$meta$n$$bool$t$q$meta$n$$bool$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$::tuple$s$p$m$ll$p$meta$n$$float$t$q$meta$n$$size_t$t$q$meta$n$$bool$t$q$meta$n$$bool$t$q$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$r$$q$m$ll$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_size_t& a1$, const pxcrt::bt_bool& a2$, const pxcrt::bt_bool& a3$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a4$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a5$) : _0$(a0$), _1$(a1$), _2$(a2$), _3$(a3$), _4$(a4$), _5$(a5$) {
}
}; /* namespace operator */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_size_t& a1$, pxcrt::bt_bool& a2$, pxcrt::bt_bool& a3$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a4$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a5$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$ , a4$ , a5$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$$r$$q$m$ll$p$m$ll$p$meta$n$$float$t$q$1$li$r$$q$m$ll$p$meta$n$$size_t$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$meta$n$$bool$t$q$1$li$r$$q$m$ll$p$pxcrt$$ptr$p$pgl3d$$glgeometry$n$$rand_generator$s$r$$q$0$li$r$$q$m$ll$p$callable$n$$callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$$q$0$li$r$$r$$r$(pxcrt::bt_float& a0$, pxcrt::bt_size_t& a1$, pxcrt::bt_bool& a2$, pxcrt::bt_bool& a3$, const pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::glgeometry$n::rand_generator$s > >& a4$, const ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$& a5$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$(a0$ , a1$ , a2$ , a3$ , a4$ , a5$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_rand_sphere$f$q$6$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace callable$n { 
static inline ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$ make_callable_ptr$f$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$) {
return ::callable$n::callable_ptr$s$p$meta$n$$void$t$q$m$ll$p$pgl3d$$glgeometry$n$$build_context_i$i$q$container$$array$n$$cslice$s$p$pgl3d$$glgeometry$n$$vertex_attr$s$r$$q$pgl3d$$glgeometry$n$$mesh_index$s$r$$r$(::pointer$n::make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(joint_name$));
}
callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& joint_name$) : count$z(1), fld$(joint_name$) {
}
inline void callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$::__call$f(const ::pgl3d$n::glgeometry$n::build_context_i$i& ctx$, const ::pxcrt::bt_cslice< ::pgl3d$n::glgeometry$n::vertex_attr$s >& poly$, const ::pgl3d$n::glgeometry$n::mesh_index$s& mp$) {
return ::pgl3d$n::glgeometry$n::gf_ctx_point_joint$f(fld$._0$ , ctx$ , poly$ , mp$);
}
}; /* namespace callable */
namespace pointer$n { 
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ > make_ptr$f$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ > box_pointer$f$p$pxcrt$$ptr$p$callable$n$$callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$) {
/* staticif empty *//* staticif-else */
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$*const r$p1 = ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$::allocate();
try {
new (r$p1) ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$(a0$);
} catch (...) {
::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::callable$n::callable_tpl$s$p$pgl3d$$glgeometry$n$$gf_ctx_point_joint$f$q$1$li$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > > make_tptr$f$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_float >& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > > box_pointer$f$p$pxcrt$$tptr$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$$q$m$ll$p$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_float >& a0$) {
/* staticif */
pxcrt::rcptr< pxcrt::trcval< ::pxcrt::pxcvarray< pxcrt::bt_float > > > r$((a0$));
return r$;
/* staticif end */
}
}; /* namespace pointer */
namespace io$n { namespace standard$n { 
static inline void debug_log$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_float >& a3$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(a0$ , a1$ , a2$ , a3$);
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(s$ , 10U);
pxcrt::debug_log_internal((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace io::standard */
namespace text$n { namespace string$n { namespace split$n { 
static inline ::pxcrt::pxcvarray< pxcrt::bt_uchar > string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$array$n$$cslice$s$p$meta$n$$uchar$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$q$m$ll$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const ::pxcrt::bt_cslice< pxcrt::bt_uchar >& a1$, const pxcrt::bt_size_t& a2$, const ::pxcrt::pxcvarray< pxcrt::bt_float >& a3$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
{
 /* staticif empty */
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , a0$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_cslice< pxcrt::bt_uchar > >(s$ , a1$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$meta$n$$size_t$t$r$(a2$ , s$);
 }
}
{
 {
  ::pxcrt::array_append< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::bt_strlit >(s$ , pxcrt::bt_strlit("\011"));
 }
 /* staticif empty */{
  ::text$n::string$n::serialize$n::serialize_to_string$f$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$(a3$ , s$);
 }
}
return s$;
}
};};}; /* namespace text::string::split */
namespace text$n { namespace string$n { namespace serialize$n { 
static inline void serialize_to_string$f$p$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_float >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& out$) {
::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$(x$ , out$);
}
};};}; /* namespace text::string::serialize */
namespace text$n { namespace serialize$n { 
static inline void serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$container$$array$n$$varray$s$p$meta$n$$float$t$r$$r$(const ::pxcrt::pxcvarray< pxcrt::bt_float >& x$, ::pxcrt::pxcvarray< pxcrt::bt_uchar >& o$) {
/* staticif */
::text$n::string$n::serialize$n::string_append_char$f$p$123$li$r$(o$);
{
 const ::pxcrt::pxcvarray< pxcrt::bt_float >& ag$fe = (x$);
 ::pxcrt::pxcvarray< pxcrt::bt_float >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_float > > ag$fg(ag$fe);
 const size_t sz$fe = ag$fe.size();
 const pxcrt::bt_float *const ar$fe = ag$fe.rawarr();
 for (pxcrt::bt_size_t i$ = 0; i$ != sz$fe; ++i$) {
  const pxcrt::bt_float& v$ = ar$fe[i$];
  {
   if (i$ != pxcrt::bt_size_t((0LL))) {
    ::text$n::string$n::serialize$n::string_append_char$f$p$44$li$r$(o$);
   }
   ::text$n::serialize$n::serialize$f$p$text$$string$$serialize$n$$ser_default$s$q$meta$n$$float$t$r$(v$ , o$);
  }
 }
}
::text$n::string$n::serialize$n::string_append_char$f$p$125$li$r$(o$);
/* staticif end */
}
};}; /* namespace text::serialize */
namespace container$n { namespace array$n { 
static inline ::pxcrt::darray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > make_darray_func$f$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$1$li$r$(const ::pxcrt::pxcvarray< pxcrt::bt_uchar >& a0$) {
::pxcrt::darray< ::pxcrt::pxcvarray< pxcrt::bt_uchar > > arr$((pxcrt::bt_size_t(1LL)), (::pxcrt::pxcvarray< pxcrt::bt_uchar >()));
arr$[pxcrt::bt_size_t((0LL))] = a0$;
return arr$;
}
};}; /* namespace container::array */
namespace pgl3d$n { namespace dynamics_world$n { 
pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$(const ::btVector3& boxHalfExtents_0$) : count$z(1), value$(boxHalfExtents_0$) {
}
inline pxcrt::rawptr< ::btCollisionShape >::type pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$::get$f() {
return ::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionShape$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$(pxcrt::address< ::btBoxShape >(value$));
}
};}; /* namespace pgl3d::dynamics_world */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::rawptr< ::btCollisionShape >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionShape$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$(pxcrt::rawptr< ::btBoxShape >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::rawptr< ::btCollisionShape >::type,pxcrt::rawptr< ::btBoxShape >::type >(x$);
/* staticif end */
}
};}; /* namespace pointer::raw */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$q$m$ll$p$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(const ::btVector3& a0$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$m$ll$p$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(a0$);
}
static inline pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$m$ll$p$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(const ::btVector3& a0$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$*const r$p1 = ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$(a0$);
} catch (...) {
::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace Bullet$n { namespace api$n { 
static inline ::btTransform btTransform_$f$p$m$ll$p$m$ll$p$Bullet$$api$n$$btQuaternion$s$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btVector3$s$q$0$li$r$$r$$r$(const ::btQuaternion& a0$, const ::btVector3& a1$) {
/* staticif */
return ::btTransform(a0$ , a1$);
/* staticif end */
}
};}; /* namespace Bullet::api */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ >& a0$, const pxcrt::bt_float& a1$, const ::btTransform& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btBoxShape$s$r$ >& a0$, const pxcrt::bt_float& a1$, const ::btTransform& a2$) {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s(a0$ , a1$ , a2$);
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace pgl3d$n { namespace dynamics_world$n { 
pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$(pxcrt::crawptr< pxcrt::bt_float >::type points_0$, pxcrt::bt_int numPoints_1$, pxcrt::bt_int stride_2$) : count$z(1), value$(points_0$ , numPoints_1$ , stride_2$) {
}
inline pxcrt::rawptr< ::btCollisionShape >::type pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$::get$f() {
return ::pointer$n::raw$n::rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionShape$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$(pxcrt::address< ::btConvexHullShape >(value$));
}
};}; /* namespace pgl3d::dynamics_world */
namespace pointer$n { namespace raw$n { 
static inline pxcrt::rawptr< ::btCollisionShape >::type rawptr___to$f$p$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btCollisionShape$s$r$$q$pointer$$raw$n$$rawptr$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$(pxcrt::rawptr< ::btConvexHullShape >::type x$) {
/* staticif */
return ::pxcrt::rawptr_upcast< pxcrt::rawptr< ::btCollisionShape >::type,pxcrt::rawptr< ::btConvexHullShape >::type >(x$);
/* staticif end */
}
};}; /* namespace pointer::raw */
namespace pointer$n { 
static inline pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$q$m$ll$p$m$ll$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const pxcrt::crawptr< pxcrt::bt_float >::type& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$m$ll$p$m$ll$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$m$ll$p$m$ll$p$pointer$$raw$n$$crawptr$s$p$meta$n$$float$t$r$$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$q$m$ll$p$meta$n$$int$t$q$0$li$r$$r$$r$(const pxcrt::crawptr< pxcrt::bt_float >::type& a0$, const pxcrt::bt_int& a1$, const pxcrt::bt_int& a2$) {
/* staticif empty *//* staticif-else */
::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$*const r$p1 = ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$::allocate();
try {
new (r$p1) ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$(a0$ , a1$ , a2$);
} catch (...) {
::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$::deallocate(r$p1);
throw;
}
pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ > r$((r$p1));
return r$;
/* staticif-else end */
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$1$li$r$$r$$r$(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ >& a0$, const pxcrt::bt_float& a1$, ::btTransform& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$1$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$$r$$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$1$li$r$$r$$r$(const pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape$s$p$Bullet$$api$n$$btConvexHullShape$s$r$ >& a0$, const pxcrt::bt_float& a1$, ::btTransform& a2$) {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s(a0$ , a1$ , a2$);
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_float static_cast$f$p$meta$n$$float$t$q$meta$n$$uchar$t$r$(const pxcrt::bt_uchar& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_uchar > c$ = numeric::static_cast_impl< pxcrt::bt_float,pxcrt::bt_uchar >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
namespace Bullet$n { namespace api$n { 
static inline ::btQuaternion btQuaternion_$f$p$m$ll$p$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$r$$r$(const pxcrt::bt_float& a0$, const pxcrt::bt_float& a1$, const pxcrt::bt_float& a2$, const pxcrt::bt_float& a3$) {
/* staticif */
return ::btQuaternion(a0$ , a1$ , a2$ , a3$);
/* staticif end */
}
};}; /* namespace Bullet::api */
namespace pgl3d$n { namespace pglcommon$n { 
static inline void erase_cond$f$p$demoapp$n$$lp_is_finished$f150$q$container$$array$n$$varray$s$p$demoapp$n$$lpbullet_data$s$r$$r$(::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s >& arr$) {
const pxcrt::bt_size_t sz$ = arr$.size();
pxcrt::bt_size_t i0$ = pxcrt::bt_size_t((0LL));
pxcrt::bt_size_t i1$ = sz$ - pxcrt::bt_size_t(1LL);
if (sz$ == pxcrt::bt_size_t((0LL))) {
 return;
}
{
 ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s >::guard_ref< ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s > > t0((arr$));
 const ::pxcrt::bt_slice< ::demoapp$n::lpbullet_data$s > a$ = ::pxcrt::bt_slice< ::demoapp$n::lpbullet_data$s >((t0.get()), pxcrt::bt_size_t((0LL)), sz$);
 while (true) {
  while (i0$ < i1$ && ::demoapp$n::lp_is_finished$f150(a$[i1$])) {
   --i1$;
  }
  while (i0$ <= i1$ && !::demoapp$n::lp_is_finished$f150(a$[i0$])) {
   ++i0$;
  }
  if (i0$ >= i1$) {
   break;
  }
  ::generic$n::swap$f$p$demoapp$n$$lpbullet_data$s$r$(a$[i0$] , a$[i1$]);
 }
}
if (i0$ < sz$) {
 ::pxcrt::array_erase< ::pxcrt::pxcvarray< ::demoapp$n::lpbullet_data$s > >(arr$ , i0$ , sz$);
}
}
};}; /* namespace pgl3d::pglcommon */
namespace generic$n { 
static inline void swap$f$p$demoapp$n$$lpbullet_data$s$r$(::demoapp$n::lpbullet_data$s& x$, ::demoapp$n::lpbullet_data$s& y$) {
/* staticif */
::generic$n::swap$f$p$container$$array$n$$farray$s$p$meta$n$$float$t$q$9$li$r$$r$(x$.value$ , y$.value$);
/* staticif end */
}
static inline void swap$f$p$container$$array$n$$farray$s$p$meta$n$$float$t$q$9$li$r$$r$(::pxcrt::farray< pxcrt::bt_float,9LL >& x$, ::pxcrt::farray< pxcrt::bt_float,9LL >& y$) {
/* staticif empty *//* staticif-else */
const ::pxcrt::farray< pxcrt::bt_float,9LL > x0$ = x$;
x$ = y$;
y$ = x0$;
/* staticif-else end */
}
}; /* namespace generic */
namespace pointer$n { 
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > make_ptr$f$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape_i$i$r$$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i >& a0$, const pxcrt::bt_float& a1$, const ::btTransform& a2$) {
return ::pointer$n::box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape_i$i$r$$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(a0$ , a1$ , a2$);
}
static inline pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > box_pointer$f$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dRigidBody$s$r$$q$m$ll$p$m$ll$p$pxcrt$$ptr$p$pgl3d$$dynamics_world$n$$pgl3dCollisionShape_i$i$r$$q$1$li$r$$q$m$ll$p$meta$n$$float$t$q$0$li$r$$q$m$ll$p$Bullet$$api$n$$btTransform$s$q$0$li$r$$r$$r$(pxcrt::rcptr< ::pgl3d$n::dynamics_world$n::pgl3dCollisionShape_i$i >& a0$, const pxcrt::bt_float& a1$, const ::btTransform& a2$) {
/* staticif empty *//* staticif-else */
pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >*const r$p1 = pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >::allocate();
try {
new (&r$p1->value) ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s(a0$ , a1$ , a2$);
new (&r$p1->count$z) pxcrt::stcount(); /* nothrow */
} catch (...) {
pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s >::deallocate(r$p1);
throw;
}
pxcrt::rcptr< pxcrt::rcval< ::pgl3d$n::dynamics_world$n::pgl3dRigidBody$s > > r$((r$p1));
return r$;
/* staticif-else end */
}
}; /* namespace pointer */
namespace io$n { namespace standard$n { 
static inline void debug_log$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(const ::pxcrt::bt_strlit& a0$, const pxcrt::bt_size_t& a1$) {
::pxcrt::pxcvarray< pxcrt::bt_uchar > s$ = ::text$n::string$n::split$n::string_join$f$p$_09$ls$q$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$meta$n$$size_t$t$q$0$li$r$$r$$r$(a0$ , a1$);
::pxcrt::array_push_back< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,pxcrt::bt_uchar >(s$ , 10U);
pxcrt::debug_log_internal((::pxcrt::pxcvarray< pxcrt::bt_uchar >::guard_ref< const ::pxcrt::pxcvarray< pxcrt::bt_uchar > > (s$).get_crange()));
}
};}; /* namespace io::standard */
namespace numeric$n { namespace cast$n { 
static inline pxcrt::bt_int static_cast$f$p$meta$n$$int$t$q$meta$n$$float$t$r$(const pxcrt::bt_float& x$) {
/* staticif */
numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_float > c$ = numeric::static_cast_impl< pxcrt::bt_int,pxcrt::bt_float >();
return c$.convert(x$);
/* staticif end */
}
};}; /* namespace numeric::cast */
/* package main */
namespace numeric$n { namespace cast$n { 
};}; /* namespace numeric::cast */
namespace demoapp$n { 
void _demoapp$$nsmain()
{
pxcrt::io_environ_init();
{
 ::pxcrt::pxcvarray< pxcrt::bt_uchar > cnf$1$demoapp$ns0 = ::pxcrt::pxcvarray< pxcrt::bt_uchar >();
 ::pgl3d$n::sdlutil$n::sdl_load_file$f(::pxcrt::pxcvarray< pxcrt::bt_uchar >(pxcrt::bt_strlit("pgl3d.cnf")) , cnf$1$demoapp$ns0);
 pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > > m$1$demoapp$ns0 = pxcrt::with_guard< pxcrt::map_conf< ::pxcrt::pxcvarray< pxcrt::bt_uchar >,::pxcrt::pxcvarray< pxcrt::bt_uchar >,::container$n::tree_map$n::cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$ > >();
 ::container$n::array$n::split_foreach$f$p$demoapp$n$$$f2$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$meta$n$$uchar$t$r$(m$1$demoapp$ns0 , cnf$1$demoapp$ns0 , 10U);
 ::io$n::standard$n::println$f$p$m$ll$p$m$ll$p$container$$array$n$$strlit$s$q$0$li$r$$q$m$ll$p$container$$tree_map$n$$tree_map_compare$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$q$container$$tree_map$n$$cmp$s$p$container$$array$n$$varray$s$p$meta$n$$uchar$t$r$$r$$r$$q$1$li$r$$r$$r$(pxcrt::bt_strlit("map=") , m$1$demoapp$ns0);
}
{
 ::demoapp$n::demoapp_application$s app$4$demoapp$ns0;
 ::pgl3d$n::mainloop$n::mainloop$f(app$4$demoapp$ns0);
}
}
}; /* namespace demoapp */
/* package main c */
static int i$_demoapp$$nsmain$init = 0;
extern "C" {
void _demoapp$$nsmain$c()
{
if (i$_demoapp$$nsmain$init == 0) {
 ::demoapp$n::_demoapp$$nsmain();
 i$_demoapp$$nsmain$init = 1;
}
}
int main(int argc, char **argv)
{
 pxcrt::process_argv = argv;
 i$_demoapp$$nsmain$init = 0;
 return pxcrt::main_nothrow(& _demoapp$$nsmain$c);
}
}; /* extern "C" */
#endif /* PXC_IMPORT_HEADER */
