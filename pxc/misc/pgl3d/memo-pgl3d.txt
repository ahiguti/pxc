
---------------------------------------------------------------------------
TODO

- postprocess: depth bufferが不要なときはどうするか
- postprocess
- metalness
- envをぼかす方法

- シェーダ用テンプレートエンジン

- collision_shape_iのconstメソッドがmt-safeでないといけないがエラーチェック
  できていない。
- grid_bp_sharedでgrid_rbinfoのmt-safeであることをチェックできていない。

- vsmのときglColorMask指定する？
- FIXME: mbp gt750m macosxでゴミが出る。intel graphicsだと出ない。windowsだと
  同ハードでも出ない。
  enable_macos_nvidia_wa
- subtexel specular: -1から1の値。負のときは内側が反射、正のときは外側が
  反射。0.8のときは内側から80%の範囲が非反射。
- smpos0 .. smpos3 共通化
- parallax: タイルマップを無駄に引かないようにしたほうが速いと思われる。
- parallax: memo: uv座標がどちらかに間延びしていると視差も間延びして歪む
- main描画でglDepthMask(0)にするとlineparticleの重ね合わせがおかしく
  なる。alpha加算であれば正しくなるが、glDepthMask(1)とどっちがいいか。
- emscripten IDBFS
  test_idbfs_sync.c  
- lineseg_point_distance2

- ios, android再テスト

- shadowmap無効の時もspecular付ける

- bulletのoperator *など

- 物体のemit

- discardするシェーダはzprepassとshadowmappingのシェーダでもdiscard必要

- 頂点データかインスタンスデータが空のときはdrawしない。

- textureのサイズ power_of_2 やめる
  だいたいの環境で non power of two テクスチャ使えるはず

- num_copies_hintが効いているか確認

- 正方行列ではない行列はGLES3以降

- aggregated_ibuffer 2個 or 3個
- prepare_instance_data_defaultの効率

- テクスチャとフォントの読み込みと利用の手順整理
- テクスチャ、フォントを複数読み込んで利用できるようにする
- 頂点属性型を整理、num_float的マクロ整理

- 頂点データを動的に入れ替えられるようにする

---------------------------------------------------------------------------
DONE

- iosでvsm可能か？(done)
  GL_RG32Fを16Fにしたら動く
- postprocessのためのダミーインスタンスを入れるのはなくせないか(done)
- shapeの半径などは自動で計算(done)
- フレネル効果(done)
- skybox(done)
- shadowmapを4枚でなくてよいようにする(done)
- textureのロード時にはtexture unitは0ににし、描画時に各texture unitへ
  textureを明示的にbindする(done)
- 衝突判定がよくわかるようにカメラの前に衝突判定用オブジェクトを置く。(done)
- grid: box shape collider(done)
- grid_broadphase別スレ化(done)
- collision_shapeと球を衝突判定する方法調べよ(done)
- emccバックエンド: SDL2_ttfがportsに来たらもう一度try(done)
- nvのサンプルを見てshadowmapのコストが妥当か確認する(done)
  ほぼ同等のfps、shadowmapの有無でのfps変化も同等なので妥当と思われる。
  6043tri, 2500obj, 4shadowmaps, 4k, 24fps
  3.6億triangles/sec, シャドーマップ4枚, z-prepass, 本描画で合計6回
- init_triangles_shader{1} テンプレパラメータやめる(done)
  trnagles2削除(done)
- ライトの向きを軸と並行に固定することによって速くできるか。(done)
- lpの衝突判定(done)
- 物理エンジンの処理時間測定(done)
- 衝突判定のみのオブジェクトをどのように作るか(done)
  - 衝突のみ、kinematic、dynamicのそれぞれの振る舞いを表現するインタフェース
  - 衝突時に呼ばれるコールバック
- rigidbodyをscene_nodeと関連付ける(done)
- convex hullをglgeometry頂点データから作る(done)

---------------------------------------------------------------------------
ビルドメモ

iOS8.3でEAGLContext_renderbufferStorageがEXC_ARM_DA_ALIGNで死ぬのを回避
するにはEdit SchemeのOptionsのGPU Frame Captureを無効にする。

iosビルド
bulletは ./premake4_osx --ios xcode4 でios用xcodeprojができる
Architecturesがおかしいので修正。
Valid Architecturesがおかしいので修正。
Base SDKがOSXになっているので修正。
pgl3dプロジェクトにAdd Files ToでSDL, SDL_image, BulletCollisionなどの
xcodeprojを追加
Build PhasesのLink Binary With Librariesに.aを追加
TARGETSのpgl3dのHeader Search Pathsに
"$(SRCROOT)/pgl3d-extlib/SDL2/include"などを追加


windowsビルド
SDL/
SDL_image/
SDL_ttf/
PXCTest1/
のように配置

---------------------------------------------------------------------------

- parts.obj 頂点座標が完全に一致しているものがあるせいで三角形分割できない
f 514 486 485 528 548
  vertex	{x,1.0123960,y,-4.8927202,z,0.0000000}
  vertex	{x,1.0123960,y,-4.8927202,z,0.0000000}
  vertex	{x,0.9611670,y,-4.9025478,z,-0.1911880}
  vertex	{x,1.8766540,y,-4.6193981,z,-0.3732890}
  vertex	{x,1.9134190,y,-4.6193981,z,-0.0000000}


- particleもinstance化してみる
- instance化しない版のvbo_mainを作り、頂点データが大きいものはそちらを使う
- vboが大きくなったら性能が落ちる
  - vbo分割で回避できるか？
  - glDrawRangeElementsが効くか？
- glgeometryの頂点属性を積むコードはtattrとしてmain_vertex_attributesと
  だいたい同じ構造体を渡すことを期待している。これを汎用化できるか。
- zprepassが効いていることを簡単に確認できないか

polygon三角形分割
外積を全て足し合わせる。向きが決定。
どれか一つの頂点とその前後で外積を取り、それが三角形と同じ向きだったら
その頂点をpolygonから削除し、三角形をpush
無くなるまで繰り返す。
三角形の内側に他の頂点があるときは削れない

頂点jが(i-1, i, i+1)の内側にあるかどうかの判定
(i-1, i)と(i-1, j)の外積
(i, i+1)と(i, j)の外積
(i+1, i-1)と(i+1, j)の外積
が全て同じ負号

---------------------------------------------------------------------------
エンジンの外に出すべき項目

pgl3d.px
  build_vertices()
    pgs.make_vertices() を起点にして頂点データをセットしている。
    これはinit_texture実行後でないといけない。フォントの情報を必要とするから。
  input_control ictl;
    これは入力デバイスの状態を保存するデータ
  player_info player;
    入力デバイスで制御するカメラ
pglscene.px
  struct scene_control
    シーンノードを構築・更新する
pglshader.px
  init_texture 画像ファイルやフォントを読んでテクスチャにセットする

motionスレッドに渡すデータ
  frame_speed_mul フレーム時間
  scene_reset シーンを次に進めるかどうか
  message 画面下に出す文字列
  font_width
  font_height
motionスレッドから受け取るでーた
  cam カメラ
  bo_instances 描画インスタンスデータ
  stat_num_objects オブジェクト数の

エンジンの外に持つデータとコード
- 頂点データを構築するコード
- イベントとキー状態からカメラやシーンなどを更新するコード

motionスレッドに移動しないもの:
  SDL_QUIT
  pausedフラグ
  SDL_WINDOWEVENT - リサイズなどのハンドルはメインスレッドで
  frctl - フレームレート計算はメインスレッドでやる
motionスレッドに移動するもの:
  キーイベント
  キーボード状態
  MOUSE, FINGERイベント

---------------------------------------------------------------------------
motionスレッドに移動せずにエンジン分離だけ実装

interface pgl3d_application {
  function void on_build_vertices();
  function void on_frame(float speed); // フレーム処理の最初に呼ばれる
  function void on_event(SDL_Event const& ev);
  function void on_keystate(cslice{Uint8} const& keys);
  function void on_prepare_motion(); // motionスレッドのフレーム処理の直前
}

multithreaded interface pgl3d_motion {
  function ptr{pgl3d_scene} make_scene(); // motionスレッドから呼ばれる
}

threaded interface pgl3d_scene {
  function void on_motion_step();
}

公開関数
function string pgl3d_get_statistics_message();

demoappに分離
- build_vertices() 移動
- struct input_control; 移動
- struct player_info; 移動
- motion_thread_sharedのうち以下のもの
    int scene_reset;
    string message;
- struct scene_control; 移動

---------------------------------------------------------------------------
テクスチャ、フォントを複数読み込んで利用できるようにする

---------------------------------------------------------------------------
シェーダのインタフェース

- ドローコール前のuniformなど設定、ドローコールの発行
- インスタンスデータ作成

interface shader_solid {
  ;
}

interface shader_particle {
  ;
}

---------------------------------------------------------------------------
シェーダ抽象化で切り出しが必要な箇所

pglscene.px
  prepare_instance_data
    シーングラフからインスタンスデータを作る処理。
pglshareder.px
  pglshaderコンストラクタ
    vbidを実行時に払い出すように変更必要。
    vbidごとのvertex_bufferを作る処理。
  draw_frame
    ドローコールを発行する。

手順:
とりあえずvbidの払い出しとvertex_buffer構築から書き換える。
  vbidはグローバルではなくpglshaderに問い合わせて取得するように変更。
  make_vertices_iに問い合わせることもできるように。
シェーダGLSL, uniform, 頂点属性, インスタンス属性

---------------------------------------------------------------------------
シェーダ抽象化

solidシェーダ群:
  - shadowmapシェーダ
  - zprepassシェーダ
  - mainシェーダ
  不透過で多面体で構成されるオブジェクトのためのシェーダ。
  それぞれinstancingするかどうかの違いで二種類のシェーダがあり、
  対応してvboがvbid_mainとvbid_main2の二種類ある。
  現状一つの実装しかない。
particleシェーダ:
  - particleシェーダ
  - particle_bbシェーダ
  - lineparticleシェーダ
  - font2シェーダ
  - rect2dシェーダ
  これらはshadowmappingやz-prepassをおこなわない単体のシェーダ
  描画順序を指定できるようにしなければならない
  シェーダ毎にインスタンスデータのフォーマットが違う
  シェーダ毎にprepare_instance_dataで入れる内容が違う

solidシェーダは3パスに分かれているのでGLSLプログラムは3つ作る必要がある
particleシェーダは1パスでGLSLプログラムは1つだけ

prepare_instance_data
  varray{instances_type} mutable& ibs これにインスタンスデータを入れる
  ibs[bo_id] : bo_idはvbid_???のいずれか。
  これの実装を抽象化する必要がある。

struct vertex_buffer
  vbo_valuesとvbo_elemsの二つのVBOハンドルを持つ

metafunction instance_type varray{varray{instance_data}};
  [vs_id][0or1]
  vs_id: vboに入れた頂点データのid
  0or1: 0にはmodel行列 1にはmvp行列を入れる
struct instance_data
  varray{float} instance_buffer;
  インスタンス1つのmodel行列など

draw_instancedの6番目の引数(0or1)はインスタンスデータのうち、
model or mvpのどちらを使うかの区別。shadowmapシェーダがmvpのほうを
使っている(やめるか？)

---------------------------------------------------------------------------
描画順序

pglshader_draw_frame()

shadowmapping
  vbid_main / smsdr
  vbid_main2 / sm2sdr
  インスタンスデータのmvpのほうを使う
zprepass
  vbid_main zpsdr
  vbid_main2 zp2sdr
main ---- solid
  vbid_main sdr
  vbid_main2 m2sdr
lineparticle ---- solid
  cullface無効、depthtest有効、depthmask有効、blend無効
  vbid_lineparticle lpsdr
particle_bb ---- blend
  cullface無効、depthtest有効、depthmask無効、blend有効
  vbid_particle_bb prtbsdr
particle ---- blend
  cullface無効、depthtest有効、depthmask無効、blend有効
  vbid_particle spsdr
rect2d ---- blend
  cullface無効、depthtest無効、depthmask無効、blend有効
  vbid_rect2d rsdr
font ---- blend
  cullface無効、depthtest無効、depthmask無効、blend有効
  vbid_font2 f2sdr


---------------------------------------------------------------------------
テクスチャ

drawer_triangles/triangles2がdpat.pngを使っている
  sampler, sampler_tilemap, sampler_smが1, 2, 3
drawer_font2がfontを使っている
  samplerが0
glActiveTexture/glBindTextureを毎フレーム呼ぶ。各デバイスで変更前後に性能差
あるか確認。


---------------------------------------------------------------------------
scene_nodeメモリ食いすぎ

geometryデータから子ノードの変換行列を得るためにscene_nodeを使っている。
インスタンスの状態を保持するためにはscene_nodeである必要はない。
GPUに渡すインスタンスデータを作るためにprepare_instance_data_ft_rec()
でノードについて再帰的に積んでいるが、ここではsn.transしか見ていない。
sn.transの全体または一部から(必要なら何らかの変換をして)対応するバッファ
に対してappendする。
(案1)
scene_nodeはテンプレ引数なくす。
scene_node使うのはgeometryから接点情報を取る箇所だけ。
インスタンスの状態はアプリが独自に型付けて保持。
描画のためのGPUに渡すインスタンスデータを作るのはcslice{float}を渡すよう
にし、アプリが付けた型がそれを呼ぶ。
(移行手順)

1. まずアプリ定義型実装
2. GPUへのインスタンスデータ渡すところを書き換え
3. scene_nodeのテンプレ引数削除

---------------------------------------------------------------------------
アプリ定義型インタフェース

scene_nodeへのポインタを持つ。
move_stepメソッド: 
  ステップ移動
prepare_instance_dataメソッド
  自分の位置データを引数に指定してscene_nodeごとの関数ポインタを呼び出す。

---------------------------------------------------------------------------
頂点データの作り方を改良

triangles_vertex_attributesのようなものをpublicにしない。

drawerを指定して利用するvboを決定する。
  triangles, font2のように。
pgs.make_vertex_set(name, 式);
式は評価コンテキストを引数に持つようにする。
  fill, fill_smooth, poly_joint, point_jointはテンプレ引数を取るが、
  これらはdrawer?がインスタンス化する。
  gf_surface()というのを用意し、これは評価コンテキストからfillなどを
  呼び出す。 particle, particle_bbもgf_surfaceから呼び出す。
pgs.make_vertex_set("saucer",
  regular_polygon(3.0, 40,
    bump_rec(0.2, 0.5, 1, surf_flat(), surf_flat()),
    bump_rec(0.01, 0.9, 5, surf_flat(), sphere(10, surf_smooth()))));
コンテキストは、
  ptr{vertices} vptr;
  tcallable{gf_poly, {vptr, 

評価コンテキストはthreadedでなければならない。pglshaderはdrawerに対して

---------------------------------------------------------------------------
triangles_vertex_attributesのようなものをpublicにしない。

glvertex::vertices::push_polygon_distinct{tattr, split_convex}
これはtattrがpos又はpositionという名前のフィールドを持っていることを
期待している。glgeometryの中ではpoly_tがvertex_attrの配列で、vertex_attr
はpos, nor, tan, uvwのそれぞれvec3を持っている。
glvertex::vertices
  push_polygon_distinct(cslice{tattr} const& vals);
  push_point(tattr const& val);
  push_joint(node_joint const& e);

glbuffer::vertex_set(num_float_per_vertex0)
  ptr{vertices} vtxs = make_ptr{vertices}(num_float_per_vertex0);
glbuffer::vertex_buffer(num_float_per_vertex0)
  varray{ptr{vertex_set}} vs_arr;

---------------------------------------------------------------------------
シェーダ混在

特定の面だけを別シェーダで描きたいときに使う
頂点セットを作るときに複数のbo_idへfillする必要がある
シェーダごとに頂点属性は変わる
vs_id

頂点データ
vertex_buffer: 特定シェーダ向けvertex_setの集まり。これにbo_idが振られる。
  (vbidとbo_idは同じもの)
vertex_set: 特定シェーダ向け芋一個ぶんの頂点データと
  vertex_buffer中のオフセット情報。これにvs_idが振られる。
vertices: 特定シェーダ向け芋一個ぶんの頂点データ(values, elements)。

インスタンスデータ
aggregated_ibuffer: async_bufferが3つ。
async_buffer: 1フレーム1回glBufferDataでまとめて送る全インスタンスデータ。
whole_instances_type: 1フレームの全インスタンスデータ。async_bufferにコピー。
bo_instances_type: 特定シェーダ向け全インスタンスデータ。
instance_data: 特定の芋一個向けインスタンスデータ。async_buffer中のオフセット。

実現方法
- subdrawerなるものを作れるようにする。subdrawerはそれ自体用のインスタンス
  データを持たず、関連するmain_drawerのインスタンスデータを使って描画する。
- zprepass, shadowmappingは共通化すると効率良いかもしれないが後回し。
- 「このbo_idは別bo_idのインスタンスデータを使って描画せよ」
  pglshader_draw_frameのpd->draw()中、whole_instances[bo_id]を渡している
  部分、これをmain_drawerのbo_idに変換すればよい。
- subdrawerとmaindrawerは別々の頂点データを持つ。
- plshader::make_vertex_setで複数のdrawer名を指定できるようにする。

---------------------------------------------------------------------------
rigidbodyをscene_nodeと関連付ける

shapeを作る
  - そのshapeをconvex_hullであるかconcave_trianglesであるか等を指定
  - もとデータとなるvertexをjoint_idで指定

sceneのscene_objectを作る
  - sceneのトップレベルnodeからnodeのリストを得る。それらのjoint_idから
    shapeを得て、transから初期位置を得てrigidbodyを作る。


---------------------------------------------------------------------------
shadowmap

4枚シャドウマップを作る
それぞれで影キャスト元と先の距離を計算(depth値とsmposのz値との差から計算)
それぞれのシャドウマップには有効な距離の範囲がある。有効な範囲に影距離が
入っていた場合にのみそのシャドウマップから影を落とす。 <- まちがい
smposのz値は見ているピクセルのライトからの距離のdepth値
それとシャドウマップを読んだdepth値との差を、sm_distanceで掛けた値が
影とピクセルとの距離。
一つ近いシャドウマップの90%から100%の間で無効から有効に。
一つ遠いシャドウマップの90%から100%の間で有効から無効に。

近いマップを使える条件
  - 描画ピクセルとカメラの距離がマップのサイズより小さい
  - 影のさす元とカメラの距離がマップのサイズより小さい
    (shadowmapを参照したdepth値が0.5の付近にある)

---------------------------------------------------------------------------
lpの衝突判定

衝突対象の物体をbroadphaseに登録。
  dyncamicsWorldと別スレッドで判定するためには、衝突対象の物体の位置と
  大きさくらいをbtRigidBodyからコピーしておかなければならない。
全lpについて、findで衝突判定。

---------------------------------------------------------------------------

smp0	{0.0250000,0.0000000,0.0000000,0.0000000,0.0000000,0.0250000,0.0000000,0.0000000,0.0000000,0.0000000,-0.0250000,0.0000000,-0.0000000,-0.0000000,-0.0000000,1.0000000}
smp1	{0.0083333,0.0000000,0.0000000,0.0000000,0.0000000,0.0083333,0.0000000,0.0000000,0.0000000,0.0000000,-0.0083333,0.0000000,-0.0000000,-0.0000000,-0.0000000,1.0000000}

sm_projection0を掛ける: xyzそれぞれ 1.0/40.0 倍、zは負号反転
sm_projection1を掛ける: xyzそれぞれ 1.0/120.0 倍、zは負号反転

light m4        {1.0000000,0.0000000,0.0000000,0.0000000,0.0000000,1.0000000,0.0000000,0.0000000,0.0000000,0.0000000,1.0000000,0.0000000,0.0000000,-30.0000000,0.0000000,1.0000000}

light_view.inverse()を掛ける: camera_posを引く

v += "  vec3 ndelta = vary_normal * 0.02 / 40.;\n";
v += "  vec3 p = vary_position - camera_pos;\n";
v += "  vary_smpos0 = p / 40. + ndelta;\n";
v += "  vary_smpos1 = p / 120. + ndelta;\n";
v += "  vary_smpos2 = p / 360. + ndelta;\n";
v += "  vary_smpos3 = p / 1080. + ndelta;\n";

---------------------------------------------------------------------------
init_triangles_shader{1} テンプレパラメータやめる

copying instancingは止める。vertexattribdivisorかuniform instancingのどちらか。

model_matrixをuniformにするかvertexattribにしてEnableVertexAttribArrayするか



---------------------------------------------------------------------------
kinematic_object_i

- dynamic objectかどうか。dynamics_worldに登録される。
- 子オブジェクトをもつこともある
- フレームごとに自分自身の位置を移動したりする。
- 衝突したときのコールバック。
- その他全体に関わる処理(シーン切り替えなど)も実行できるようにしておく。 
- kinematic_object_factoryにmake_scene()で再帰的にkinematic_object一式を
  作成してdynamics_worldに登録される。
- prepare_instance_dataでインスタンスデータを詰めこむ。

interface scene_factory_i {
  function ptr{scene_object_i} make_scene(application_i mutable& app);
}
scene_objectはdynamics_worldを保持する。make_sceneはscene_objectの
コンストラクタを呼び、その中ではkinematic_objectをたくさん作って
dynamics_worldに登録する。

interface scene_object_i {
  function void on_motion_step(application_i mutable& app);
}
on_motion_stepは各kinematic_objectのupdate_stepを呼んでから、
dynamics_worldのmotion_stepを実行する。衝突のコールバック
on_collideが呼ばれる？

interface kinematic_object_i {
  function void update_step(scene_object_i mutable& sco);
  function void on_collide(scene_object_i mutable& sco,
    kinematic_object_i mutable& other);
}

種類毎に分けた密な配列にデータを詰め込めば効率よいはず。
全ての種類について密配列化するか、
極端にインスタンスが多い物だけにするか、
kinematic(dynamicではない)なものだけにするか。


---------------------------------------------------------------------------
collision_shapeと球を衝突判定する方法調べよ

CollisionShapeのペアに対し、そのペアを衝突判定するにふさわしいアルゴリズム
を作るのが、
btDefaultCollisionConfiguration::getCollisionAlgorithmCreateFunc(i,j) これ。
たとえばConvexHullとSphereであればbtConvexConvexAlgorithmで、これは中で
btGjkPairDetectorを毎回作って近い点を探している。
btGjkPairDetector::getClosestPoints() これ。
The ConvexHullDistance demo demonstrates direct use of btGjkPairDetector.
とのこと。

ConcaveConvexの組についてはbtConvexConcaveCollisionAlgorithm これは単独で
取り出すのは難しい？
processCollision()
concaveの各triangleに対して相手と衝突判定してるだけ？全量ではない。


---------------------------------------------------------------------------

rigid_bodyにcallbackオブジェクトを付ける。callbackオブジェクトはrigid_body
インスタンス毎のデータを持たないのであれば共有してもいい。

dynamics_worldにgrid_broadphase追加。衝突判定のみのオブジェクトの衝突判定
に使う。

swarm_iをdynamics_worldに追加できるようにする。
- swarm_i自体は多数のオブジェクトを配列として保持する。
- swarm_iはmultithreadedにする。dynamicsとは別スレで衝突判定するため。
- 各オブジェクトのデータはmodel matrixの大きさより多分小さい

各swarm_iはフレーム毎にstep()が呼ばれる。位置にデルタを加算したり、向きを
変えたりする。

grid_broadphaseには毎フレーム、rigidbodyの全インスタンスの情報をgridに
入れ、swarm_iの全インスタンスに対して衝突判定する。衝突していればswarm_i
のコールバックを呼ぶ。

grid_broadphaseの衝突判定narrow phaseは、とりあえずGJKだけ試してみる。

シーンを初期化すると、dynamic_object_iとswarm_iが複数dynamics_worldに
追加される。dynamic_object_iがdynamics_worldに追加されると、含まれる
collision_shapeとtransformの情報を見て複数かもしれないrigid_bodyが作ら
れる。dynamic_objectがdynamics_worldから削除されるときにはrigid_body
が削除される。dynamics_worldはdynamics_objectの強参照を保持する。
swarm_iについてもdynamic_objectとだいたい同じ。

threaded interface dynamic_object_i
{
  public ptr{rigid_body_i} get_rigid_body() const;
  public void on_collide();
  public void on_step(float speed);
}

multithreaded interface swarm_i
{
  public size_t size() const;
  public uint_t get(size_t idx, vec3 mutable& pos_r, float mutable& radius_r)
    const; // マスクを返す
  public void on_collide(size_t idx, dynamic_object_i const& o);
  // 消滅させるかどうか判定できるデータを各要素に持たせる必要がある。
}

swarmの衝突判定
1 dynamic_object一式をgridに登録。このときbtCollisionShapeの生ポインタも
  gridに保持しておく。これはnarrow phaseをするために必要。
2 swarmの各オブジェクトをgridで判定、相手のdynamic_objectのshapeに
  応じてnarrow phase判定。

collision_shapeにradiusを追加。grid_broadphaseに追加するのに必要
(あるいはgetAabbを使うほうがよい？)

---------------------------------------------------------------------------
bulletのNP並列化切り戻し

NP並列化関連
CMakeLists.txt
btBroadphaseProxy.h
btCollisionAlgorithm.h
btDbvtBroadphase.cpp
btDispatcher.h
btCollisionCreateFunc.h
btCollisionDispatcher.cpp
btCollisionDispatcher.h
btCompoundCollisionAlgorithm.cpp
btCompoundCompoundCollisionAlgorithm.cpp
btConvexConcaveCollisionAlgorithm.cpp
btConvexConcaveCollisionAlgorithm.h
btConvexConvexAlgorithm.cpp
btConvexConvexAlgorithm.h
btDefaultCollisionConfiguration.cpp
btDefaultCollisionConfiguration.h
btSoftBodyConcaveCollisionAlgorithm.cpp
btSoftBodyConcaveCollisionAlgorithm.h

BP高速化関連
btSimpleBroadphase.cpp
btSimpleBroadphase.h
btSequentialImpulseConstraintSolver.cpp
btDiscreteDynamicsWorld.cpp
btRigidBody.cpp
btScalar.h
btTransformUtil.h


無関係
OpenGlexampleBrowser.cpp
btOverlappingPairCache.h
btDimulationIslandManager.cpp
btAlignedAllocator.cpp
btAlignedAllocator.h
btPoolAllocator.h

---------------------------------------------------------------------------
parallax_warp

warp有効にすると、特に深さが深いときに速くなる。

// W = unused(8), Z = depth(8), Y = CPP(4) CPN(4), X = CNP(4) CNN(4)

void parallax_warp(in vec3 dir, inout vec4 tval, inout vec2 tpos,
  inout vec3 tsub)
{
  float cvt = floor((dir.x > 0.0 ? tex_val.y : tex_val.x) * 255.0 + 0.5);
  float cval = dir.y > 0.0 ? floor(cvt / 16.0) : fract(cvt / 16.0) * 16.0;
  cval = clamp(cval, 0.001, (tval.z - tsub.z) / dir.z);
    // tsubが1.0ちょうどになるのを回避するために0.001だけ動かす
  vec3 delta = dir * cval;
  vec2 npos = tpos + tsub.xy + delta.xy;
  tpos = floor(npos);
  tsub = vec3(npos - tpos, tsub.z + delta.z);
  parallax_read(tpos / tile_size, tval);
}

---------------------------------------------------------------------------
6方向hightmap

三角形をzが負からみたときの高さを計算
三角形の(x, y)座標が視点の(x, y)を含むか判定。
 ABxAP, BCxBP, CAxCPの負号が全て同じ
含むなら、平面とP(x, y)の交点となるz座標が高さとなる。
平面上のどこか一点A、視線と平面の交点P、法線ベクトルNとすると
平面の方程式: dot(P - A, N) = 0
(Px - Ax) * Nx + (Py - Ay) * Ny + (Pz - Az) * Nz = 0
(Pz - Az) * Nz = (Ax - Px) * Nx + (Ay - Py) * Ny
(Pz - Az) = ((Ax - Px) * Nx + (Ay - Py) * Ny) / Nz
Pz = ((Ax - Px) * Nx + (Ay - Py) * Ny) / Nz + Az
外積使うのは遅いので三角形の内部の点を網羅するほうがいい。
3点のAABBを調べ、x最小の点A, x最大の点Bとする。
for (px = floor(ax + 0.9999) + 0.5; px < bx; px += 1.0) {
  rat = (px - ax) / (bx - ax);
  pab = a + (b - a) * rat;
  if (px < cx) {
    rat = (px - ax) / (cx - ax);
    pacb = a + (c - a) * rat;
  } else {
    ra = (px - cx) / (bx - cx);
    pacb = c + (b - c) * rat;
  }
  y0 = pab.y;
  y1 = pacb.y;
  if (y0 < y1) { swap(y0, y1); }
  for (py = floor(y0 + 0.9999) + 0.5; py < y1; py += 1.0) {
    pz = ((ax - px) * nx + (ay - py) * ny) / nz + az;
    floor(px, py)の位置の深さがpzである
  }
}
ループの中は最低一回まわるように調整する?
px0 = floor(ax + 0.9999) + 0.5; // グリッドの中心
px1 = bx;
if (px0 >= px1) {
  px0 = (ax + bx + cx) / 3.0;
  px1 = px0 + 1.0;
}
function pair{float} calc_range(float ax, float bx)
{
  pair{float} r;
  r.first = floor(ax + 0.9999) + 0.5;
  r.second = bx;
  if (r.first >= r.second) {
    r.first = (ax + bx) / 2.0; // なるべく近いグリッド
    r.second = r.first + 1.0;
  }
  return r;
}

shapeのローカルaabbを求め、各三角形を(0,sz)にスケール。szは分割数。

衝突判定
3x2枚のheightmapのすべてについて衝突していれば衝突。
各heightmapについては、x,yのマップを引いてzが最小と最大の範囲に
はいっていれば衝突。

---------------------------------------------------------------------------

float linear_01(in float x, in float a, in float b)
{
  return clamp((x - a) / (b - a), 0.0, 1.0);
}

float linear_10(in float x, in float a, in float b)
{
  return clamp((b - x) / (b - a), 0.0, 1.0);
}

float max_vec3(in vec3 v)
{
  return max(v.x, max(v.y, v.z));
}

f += "bool n1 = all(lessThan(abs(p1),vec3(0.32,0.32,0.32))) &&";
フラグメントの位置がシャドウマップの中央1/3に入っている(カメラに近い)なら1
linear_10(max_vec3(abs(p1)), 0.28, 0.32);
f += "  abs(zval1 - 0.5) * 2.0 < zval_thr;\n";
フラグメントとキャスタの距離が閾値より近いなら1
linear_10(max_vec3(abs(zval1 - 0.5)), zval_thr * 0.8, zval_thr);
f += "float smv1 = min(1.0, sml1 + float(n1 ||";
f += "  any(greaterThanEqual(p1, vec3(1.0,1.0,1.0)))));\n";
フラグメントの位置がシャドウマップの範囲外なら1
linear_01(max_vec3(abs(p1)), 0.9, 1.0);

float smv1 = min(1.0, sml1
  + linear_10(max_vec3(abs(p1)), 0.33 * 0.9, 0.33)
  + linear_10(max_vec3((zval1 - 0.5) * 2.0, zval_thr * 0.9, zval_thr)
  + linear_01(max_vec3(abs(p1)), 0.9, 1.0));

---------------------------------------------------------------------------
box collider

radiusで判定した後にlocal aabbで判定できるようにする。
collision_shape_iにlocal_aabbを返す関数追加? 判定関数を作る？
さらに、local_aabbで判定した後にheightmapで判定できるようにする。
function bool collide(btVector3 const& pos, float ra);
  shapeのローカル座標へ変換。

各shapeにlocal判定の有無を返す関数を用意。それがtrueを返したら
local座標に変換したターゲット座標を渡してlocal判定実行。

function bool has_local_collision();
function bool local_collision(vec3 const& local_pos, float radius);

---------------------------------------------------------------------------
framebuffer

shadowmap用framebufferを作るところ。depth_textureではないケース。
GL_COLOR_ATTACHMENT0はテクスチャ、GL_DEPTH_ATTACHMENTはrenderbufferを
アタッチ。

int saved_fb;
// bindしてあるframebufferを覚えておく
glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
sfbo.fbo.generate();
glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
// colorにtexture(sm_texture)をアタッチ
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
  GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
int orig_rb;
// bindしてあるrenderbufferを覚えておく
glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
// glGenRenderbuffersでrenderbufferを作成
sfbo.depthbuf.generate();
glBindRenderbuffer(GL_RENDERBUFFER, sfbo.depthbuf.get());
// renderbuffer(depthbuf)のストレージを設定
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16,
  sfbo.sm_width, sfbo.sm_height);
// framebuffer(fbo)のdepthにrenderbuffer(depthbuf)をアタッチ
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
  GL_RENDERBUFFER, sfbo.depthbuf.get());
// bindしたrenderbufferを元に戻す
glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));

---------------------------------------------------------------------------
マテリアル

dpat: RGBとsubtexel法線パターン
pmpat: 視差マップのためのheightとclearance

float metalness;
float roughness;
vec3 color;

現状
  dpat:
    8bit: alv, avol
      tex_val.aの上4bitがavol, 下4bitがalv(0から10まで？)
      alv: 1, 3, 5, 7がLU, RU, RD, LDの四隅。2, 4が左右と上下の辺。0は傾けない。
    8bit * 3: RGB
  pmpat:
    8bit: 空き
    8bit: depth
    4bit * 4: clearance
変更後
  dpat:
    8bit: alv, avol
    8bit * 3: RGB
  pmpat:
    8bit: metalnessが1bit、roughnessが7bit (これ追加した)
    8bit: depth
    4bit * 4: clearance

dpatのpng画像
depth値とRGB値を別pngファイルにする。タイルエディタはdepth値の画像を使う？
gimpのレイヤでdepthとRGBを管理。
depth値は下位ビットから、R8段階、G8段階、B4段階
RGB値が

法線データはdepth値から計算。
計算方法:
  タイル境界を越えた位置にあるテクセルのdepthはclamp-to-edgeとする
  隣接する4つのテクセルの深さを読む
  上だけが深く3方は同じ -> 上凸
  上と左が深く2方は同じ -> 上左凸
  ..同様に全8方向
  浅いケースも同様に全8方向
  それ以外のパターンでは傾斜させない

法線を連続値にする？
計算方法:
  隣接8マスと中央との深さの差からxy方向の傾きを求め、平均する。
  法線ベクトルを8bit値の範囲に (-127から+127)
  depthと法線ベクトルは線形補間してよい。
  垂直面と水平面は区別しなくてよい。
  -> POMでよいのでは？

dpat/pmpat
64x64テクセルが16x16個、1024x1024テクセルのテクスチャが2枚。
(もっと大きくてもよい？ 性能をみて検討)
1テクセルあたりRGBA8が二つ(8byte)、計8Mbyte
タイル番号は1byteで表現可能
(横長に256個並べるか？)
default_color.png
default_depth.png

タイルパターン
タイルマップは1024x1024サイズ。(もっと大きくてもよい？)
4Gテクセル
default_tile.png

タイルの貼りかた
四角形の一番長い辺を底辺とする。
対向の辺から垂線を下ろした線分を求める。
対向の辺の、底辺から近いほうから底辺に水平に直線をひき、
垂線と交わった点を求める。
できた長方形の範囲の縦横が単純な整数比になるようにcropする。
(具体的にはあとで考える。深さ0の枠を作るため少しマージンを持たせる。)
cropした長方形の四隅にテクスチャ座標を決める。
四角形の四隅のテクスチャ座標を計算。
テクスチャ座標のaabbも4点全ての頂点データに含めておく。
(これはcropの内側かどうか判定するため。)
シェーダでは内側でなければ深さ0のdepthを返す。そのときの色はデフォルト色。

頂点データにaabb追加

---------------------------------------------------------------------------
メモ

頂点データエントリを追加するのはctx_fill()
中でbuild_context_iのfill()()
build_context_iインスタンスはpglshader::make_vertex_set()で作られる
fillerはdrawer::make_filler()で作られる
trianglesのときfillerの実体は
dgf_fill_tattr_internal{triangles_vertex_attributes}
これはpoly_tからarray{tattr}へデータをコピーし、push_polygon_distinct()
を呼ぶ。頂点データの大きさはtattrの大きさで決まる。

移行手順
- trianglesの*_vertex_attributesにuv_aabbフィールド追加。vec4型。
- dgf_fill_tattr_internalにuv_aabbをセットする処理追加。
- parallax_read()でuv_aabbの範囲かどうか見る
- tilemap()でuv_aabbの範囲かどうか見る

---------------------------------------------------------------------------
視差マップで平面より凸を許可

適用する平面より浮かせた面(5面)を作る。shadowmappingとprepassでは非表示。
四角形内座標として3次元値xyzを与える
四角形内の座標をあらわすvaryingを用意。(0,1)範囲内なら内。
テクスチャ座標の起点とオフセットを与える
parallaxのイテレートをuvw値スタートで実行、四角形から出たらdiscard
視線が法線に対して対向向きとは限らなくなる。
  ->特に変更不要と思われる

方針
- uvwのw値の従来の動作は止める
- ボーダーaabbはいらない(が、とりあえず残しておく)
- 4頂点を0,1であらわした境界判定用の頂点データ用意
- とりあえずprepassは無視して、浮かせた面を作る方向で
- 底面はボーダー色で塗る
- parallaxの始点を深さ付きで開始できるようにする
- 境界から出たらdiscard

移行手順
- uvwのw値を使わないように変更
- parallax_loop(): 始点を深さ付きで
- 浮かせた面を生成
- 境界判定用の頂点データ作る
- 境界から出たらdiscard 

parallax_loop()
引数のzをinoutに変更する

---------------------------------------------------------------------------
cosv0123 > cosv1230
  01と23のほうが12と30より平行に近い

