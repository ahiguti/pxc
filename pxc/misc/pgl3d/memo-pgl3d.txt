
---------------------------------------------------------------------------
TODO

- editmode: カメラの向きに近い軸を決めてカーソル移動

- windows: dbghelp.dllでminidump (google breakpadつかう?)

- ボクセルに二次曲線パラメータを埋め込む

- パターンエディタ

- 複数板貼り付けた大きなオブジェクトを作る

- 複数種類の板を用意

- cameraが内側外側の境目で乱れる

- voxel: 斜面を使うデータを生成

- zprepass効いてない(done)

- FIXME 真横あたりから見ると乱れる(done)

- stype=2を使ってraycastシェーダの後ろを表示(done)

- 頂点データ重複排除を再び有効に(tex3dで効果大きい)

- 初期ノードの全体ではなく一部の領域だけを貼り付けられるようにする。(done)
  - raycast_octreeは接触点と影点を返すようにし、呼ぶ側で判定するか。
  - 「一部の領域」がaabbでよいのであれば最上位レベルのaabbをraycast_octree
    の引数で渡し、eyeとlightを適当に変換するようにすればよい。

- 切断面データ無し、法線のみで球のデータを作る


- 切断面データ無しで法線埋め込み
  - 切断面データ有りの場合
    切断面との交点を(0,1)にclamp
  - 切断面データ無し、法線だけ見る場合
    dとして-sqrt(3)未満の値をセットすると必ず埋まっている側と判定される。
    切断面との交点を(0,1)にclampした点へ移動。
  - 法線を見ない場合
    dとして255をセットする。壁に衝突する。hit_wallの処理で空白ボクセルへ
    移動する。

- ループ回数上限に達した時には影にする(done)

- curpos_t削除したほうがよいか(done)
  curpos_t + curpos_iをcurpos_tiに。block_factorの剰余が旧curpos_iになる
  curpos_t : pos_tile(curpos_x)
    floor(curpos_x * block_scale) * block_factor;
  curpos_i : pos_pat(curpos_x)
    fract(curpos_x * block_scale) * block_factor;

- raycast_octreeループ内整理

- normal値をボクセルに持たせる(done)
- 乱数(done)
- webglで3dテクスチャ使えないので何か考える。

- 元絵の仮想サイズがbshiftに制限されないように(done)
- 中にめりこんだときとそうでないときに少しずれている。epsilon調整(done) 
- 中にめりこんでも表示できるよう裏面描画処理(done)
- self影(done)
- triangles-o1.fsh なぜ遅いのか(done)
  -> value_r = valueの位置
- boxを拡大(done)
- nodesのサイズをxyzそれぞれ異なる値を取れるように(done)
- 4096*4096*4096試してみる(done)

- sub-drawerの頂点データを作るとdrawer

- シェーダ用テンプレートエンジン(done)

- distance_to_boundary: 4方向の距離を正しく

- warp2でaabbを突き抜けるためself shadowがおかしい

- postprocess: depth bufferが不要なときはどうするか
- postprocess
- metalness
- envをぼかす方法

- skyboxをpngから読んでから逆ガンマ補正する

- collision_shape_iのconstメソッドがmt-safeでないといけないがエラーチェック
  できていない。
- grid_bp_sharedでgrid_rbinfoのmt-safeであることをチェックできていない。

- vsmのときglColorMask指定する？
- FIXME: mbp gt750m macosxでゴミが出る。intel graphicsだと出ない。windowsだと
  同ハードでも出ない。
  enable_macos_nvidia_wa
- subtexel specular: -1から1の値。負のときは内側が反射、正のときは外側が
  反射。0.8のときは内側から80%の範囲が非反射。
- smpos0 .. smpos3 共通化
- parallax: タイルマップを無駄に引かないようにしたほうが速いと思われる。
- parallax: memo: uv座標がどちらかに間延びしていると視差も間延びして歪む
- main描画でglDepthMask(0)にするとlineparticleの重ね合わせがおかしく
  なる。alpha加算であれば正しくなるが、glDepthMask(1)とどっちがいいか。
- emscripten IDBFS
  test_idbfs_sync.c  
- lineseg_point_distance2

- ios, android再テスト

- shadowmap無効の時もspecular付ける

- bulletのoperator *など

- 物体のemit

- discardするシェーダはzprepassとshadowmappingのシェーダでもdiscard必要

- 頂点データかインスタンスデータが空のときはdrawしない。

- textureのサイズ power_of_2 やめる
  だいたいの環境で non power of two テクスチャ使えるはず

- num_copies_hintが効いているか確認

- 正方行列ではない行列はGLES3以降

- aggregated_ibuffer 2個 or 3個
- prepare_instance_data_defaultの効率

- テクスチャとフォントの読み込みと利用の手順整理
- テクスチャ、フォントを複数読み込んで利用できるようにする
- 頂点属性型を整理、num_float的マクロ整理

- 頂点データを動的に入れ替えられるようにする

---------------------------------------------------------------------------
DONE

- iosでvsm可能か？(done)
  GL_RG32Fを16Fにしたら動く
- postprocessのためのダミーインスタンスを入れるのはなくせないか(done)
- shapeの半径などは自動で計算(done)
- フレネル効果(done)
- skybox(done)
- shadowmapを4枚でなくてよいようにする(done)
- textureのロード時にはtexture unitは0ににし、描画時に各texture unitへ
  textureを明示的にbindする(done)
- 衝突判定がよくわかるようにカメラの前に衝突判定用オブジェクトを置く。(done)
- grid: box shape collider(done)
- grid_broadphase別スレ化(done)
- collision_shapeと球を衝突判定する方法調べよ(done)
- emccバックエンド: SDL2_ttfがportsに来たらもう一度try(done)
- nvのサンプルを見てshadowmapのコストが妥当か確認する(done)
  ほぼ同等のfps、shadowmapの有無でのfps変化も同等なので妥当と思われる。
  6043tri, 2500obj, 4shadowmaps, 4k, 24fps
  3.6億triangles/sec, シャドーマップ4枚, z-prepass, 本描画で合計6回
- init_triangles_shader{1} テンプレパラメータやめる(done)
  trnagles2削除(done)
- ライトの向きを軸と並行に固定することによって速くできるか。(done)
- lpの衝突判定(done)
- 物理エンジンの処理時間測定(done)
- 衝突判定のみのオブジェクトをどのように作るか(done)
  - 衝突のみ、kinematic、dynamicのそれぞれの振る舞いを表現するインタフェース
  - 衝突時に呼ばれるコールバック
- rigidbodyをscene_nodeと関連付ける(done)
- convex hullをglgeometry頂点データから作る(done)

---------------------------------------------------------------------------
ビルドメモ

iOS8.3でEAGLContext_renderbufferStorageがEXC_ARM_DA_ALIGNで死ぬのを回避
するにはEdit SchemeのOptionsのGPU Frame Captureを無効にする。

iosビルド
bulletは ./premake4_osx --ios xcode4 でios用xcodeprojができる
Architecturesがおかしいので修正。
Valid Architecturesがおかしいので修正。
Base SDKがOSXになっているので修正。
pgl3dプロジェクトにAdd Files ToでSDL, SDL_image, BulletCollisionなどの
xcodeprojを追加
Build PhasesのLink Binary With Librariesに.aを追加
TARGETSのpgl3dのHeader Search Pathsに
"$(SRCROOT)/pgl3d-extlib/SDL2/include"などを追加


windowsビルド
SDL/
SDL_image/
SDL_ttf/
PXCTest1/
のように配置

---------------------------------------------------------------------------
メモ: glsl

https://en.wikibooks.org/wiki/GLSL_Programming/Vector_and_Matrix_Operations

mat3 m = mat3(
   1.1, 2.1, 3.1, // first column (not row!)
   1.2, 2.2, 3.2, // second column
   1.3, 2.3, 3.3  // third column
);
mat3 id = mat3(1.0); // puts 1.0 on the diagonal
                     // all other components are 0.0
vec3 column0 = vec3(0.0, 1.0, 0.0);
vec3 column1 = vec3(1.0, 0.0, 0.0);
vec3 column2 = vec3(0.0, 0.0, 1.0);
mat3 n = mat3(column0, column1, column2); // sets columns of matrix n

---------------------------------------------------------------------------

- parts.obj 頂点座標が完全に一致しているものがあるせいで三角形分割できない
f 514 486 485 528 548
  vertex	{x,1.0123960,y,-4.8927202,z,0.0000000}
  vertex	{x,1.0123960,y,-4.8927202,z,0.0000000}
  vertex	{x,0.9611670,y,-4.9025478,z,-0.1911880}
  vertex	{x,1.8766540,y,-4.6193981,z,-0.3732890}
  vertex	{x,1.9134190,y,-4.6193981,z,-0.0000000}


- particleもinstance化してみる
- instance化しない版のvbo_mainを作り、頂点データが大きいものはそちらを使う
- vboが大きくなったら性能が落ちる
  - vbo分割で回避できるか？
  - glDrawRangeElementsが効くか？
- glgeometryの頂点属性を積むコードはtattrとしてmain_vertex_attributesと
  だいたい同じ構造体を渡すことを期待している。これを汎用化できるか。
- zprepassが効いていることを簡単に確認できないか

polygon三角形分割
外積を全て足し合わせる。向きが決定。
どれか一つの頂点とその前後で外積を取り、それが三角形と同じ向きだったら
その頂点をpolygonから削除し、三角形をpush
無くなるまで繰り返す。
三角形の内側に他の頂点があるときは削れない

頂点jが(i-1, i, i+1)の内側にあるかどうかの判定
(i-1, i)と(i-1, j)の外積
(i, i+1)と(i, j)の外積
(i+1, i-1)と(i+1, j)の外積
が全て同じ負号

---------------------------------------------------------------------------
エンジンの外に出すべき項目

pgl3d.px
  build_vertices()
    pgs.make_vertices() を起点にして頂点データをセットしている。
    これはinit_texture実行後でないといけない。フォントの情報を必要とするから。
  input_control ictl;
    これは入力デバイスの状態を保存するデータ
  player_info player;
    入力デバイスで制御するカメラ
pglscene.px
  struct scene_control
    シーンノードを構築・更新する
pglshader.px
  init_texture 画像ファイルやフォントを読んでテクスチャにセットする

motionスレッドに渡すデータ
  frame_speed_mul フレーム時間
  scene_reset シーンを次に進めるかどうか
  message 画面下に出す文字列
  font_width
  font_height
motionスレッドから受け取るでーた
  cam カメラ
  bo_instances 描画インスタンスデータ
  stat_num_objects オブジェクト数の

エンジンの外に持つデータとコード
- 頂点データを構築するコード
- イベントとキー状態からカメラやシーンなどを更新するコード

motionスレッドに移動しないもの:
  SDL_QUIT
  pausedフラグ
  SDL_WINDOWEVENT - リサイズなどのハンドルはメインスレッドで
  frctl - フレームレート計算はメインスレッドでやる
motionスレッドに移動するもの:
  キーイベント
  キーボード状態
  MOUSE, FINGERイベント

---------------------------------------------------------------------------
motionスレッドに移動せずにエンジン分離だけ実装

interface pgl3d_application {
  function void on_build_vertices();
  function void on_frame(float speed); // フレーム処理の最初に呼ばれる
  function void on_event(SDL_Event const& ev);
  function void on_keystate(cslice{Uint8} const& keys);
  function void on_prepare_motion(); // motionスレッドのフレーム処理の直前
}

multithreaded interface pgl3d_motion {
  function ptr{pgl3d_scene} make_scene(); // motionスレッドから呼ばれる
}

threaded interface pgl3d_scene {
  function void on_motion_step();
}

公開関数
function string pgl3d_get_statistics_message();

demoappに分離
- build_vertices() 移動
- struct input_control; 移動
- struct player_info; 移動
- motion_thread_sharedのうち以下のもの
    int scene_reset;
    string message;
- struct scene_control; 移動

---------------------------------------------------------------------------
テクスチャ、フォントを複数読み込んで利用できるようにする

---------------------------------------------------------------------------
シェーダのインタフェース

- ドローコール前のuniformなど設定、ドローコールの発行
- インスタンスデータ作成

interface shader_solid {
  ;
}

interface shader_particle {
  ;
}

---------------------------------------------------------------------------
シェーダ抽象化で切り出しが必要な箇所

pglscene.px
  prepare_instance_data
    シーングラフからインスタンスデータを作る処理。
pglshareder.px
  pglshaderコンストラクタ
    vbidを実行時に払い出すように変更必要。
    vbidごとのvertex_bufferを作る処理。
  draw_frame
    ドローコールを発行する。

手順:
とりあえずvbidの払い出しとvertex_buffer構築から書き換える。
  vbidはグローバルではなくpglshaderに問い合わせて取得するように変更。
  make_vertices_iに問い合わせることもできるように。
シェーダGLSL, uniform, 頂点属性, インスタンス属性

---------------------------------------------------------------------------
シェーダ抽象化

solidシェーダ群:
  - shadowmapシェーダ
  - zprepassシェーダ
  - mainシェーダ
  不透過で多面体で構成されるオブジェクトのためのシェーダ。
  それぞれinstancingするかどうかの違いで二種類のシェーダがあり、
  対応してvboがvbid_mainとvbid_main2の二種類ある。
  現状一つの実装しかない。
particleシェーダ:
  - particleシェーダ
  - particle_bbシェーダ
  - lineparticleシェーダ
  - font2シェーダ
  - rect2dシェーダ
  これらはshadowmappingやz-prepassをおこなわない単体のシェーダ
  描画順序を指定できるようにしなければならない
  シェーダ毎にインスタンスデータのフォーマットが違う
  シェーダ毎にprepare_instance_dataで入れる内容が違う

solidシェーダは3パスに分かれているのでGLSLプログラムは3つ作る必要がある
particleシェーダは1パスでGLSLプログラムは1つだけ

prepare_instance_data
  varray{instances_type} mutable& ibs これにインスタンスデータを入れる
  ibs[bo_id] : bo_idはvbid_???のいずれか。
  これの実装を抽象化する必要がある。

struct vertex_buffer
  vbo_valuesとvbo_elemsの二つのVBOハンドルを持つ

metafunction instance_type varray{varray{instance_data}};
  [vs_id][0or1]
  vs_id: vboに入れた頂点データのid
  0or1: 0にはmodel行列 1にはmvp行列を入れる
struct instance_data
  varray{float} instance_buffer;
  インスタンス1つのmodel行列など

draw_instancedの6番目の引数(0or1)はインスタンスデータのうち、
model or mvpのどちらを使うかの区別。shadowmapシェーダがmvpのほうを
使っている(やめるか？)

---------------------------------------------------------------------------
描画順序

pglshader_draw_frame()

shadowmapping
  vbid_main / smsdr
  vbid_main2 / sm2sdr
  インスタンスデータのmvpのほうを使う
zprepass
  vbid_main zpsdr
  vbid_main2 zp2sdr
main ---- solid
  vbid_main sdr
  vbid_main2 m2sdr
lineparticle ---- solid
  cullface無効、depthtest有効、depthmask有効、blend無効
  vbid_lineparticle lpsdr
particle_bb ---- blend
  cullface無効、depthtest有効、depthmask無効、blend有効
  vbid_particle_bb prtbsdr
particle ---- blend
  cullface無効、depthtest有効、depthmask無効、blend有効
  vbid_particle spsdr
rect2d ---- blend
  cullface無効、depthtest無効、depthmask無効、blend有効
  vbid_rect2d rsdr
font ---- blend
  cullface無効、depthtest無効、depthmask無効、blend有効
  vbid_font2 f2sdr


---------------------------------------------------------------------------
テクスチャ

drawer_triangles/triangles2がdpat.pngを使っている
  sampler, sampler_tilemap, sampler_smが1, 2, 3
drawer_font2がfontを使っている
  samplerが0
glActiveTexture/glBindTextureを毎フレーム呼ぶ。各デバイスで変更前後に性能差
あるか確認。


---------------------------------------------------------------------------
scene_nodeメモリ食いすぎ

geometryデータから子ノードの変換行列を得るためにscene_nodeを使っている。
インスタンスの状態を保持するためにはscene_nodeである必要はない。
GPUに渡すインスタンスデータを作るためにprepare_instance_data_ft_rec()
でノードについて再帰的に積んでいるが、ここではsn.transしか見ていない。
sn.transの全体または一部から(必要なら何らかの変換をして)対応するバッファ
に対してappendする。
(案1)
scene_nodeはテンプレ引数なくす。
scene_node使うのはgeometryから接点情報を取る箇所だけ。
インスタンスの状態はアプリが独自に型付けて保持。
描画のためのGPUに渡すインスタンスデータを作るのはcslice{float}を渡すよう
にし、アプリが付けた型がそれを呼ぶ。
(移行手順)

1. まずアプリ定義型実装
2. GPUへのインスタンスデータ渡すところを書き換え
3. scene_nodeのテンプレ引数削除

---------------------------------------------------------------------------
アプリ定義型インタフェース

scene_nodeへのポインタを持つ。
move_stepメソッド: 
  ステップ移動
prepare_instance_dataメソッド
  自分の位置データを引数に指定してscene_nodeごとの関数ポインタを呼び出す。

---------------------------------------------------------------------------
頂点データの作り方を改良

triangles_vertex_attributesのようなものをpublicにしない。

drawerを指定して利用するvboを決定する。
  triangles, font2のように。
pgs.make_vertex_set(name, 式);
式は評価コンテキストを引数に持つようにする。
  fill, fill_smooth, poly_joint, point_jointはテンプレ引数を取るが、
  これらはdrawer?がインスタンス化する。
  gf_surface()というのを用意し、これは評価コンテキストからfillなどを
  呼び出す。 particle, particle_bbもgf_surfaceから呼び出す。
pgs.make_vertex_set("saucer",
  regular_polygon(3.0, 40,
    bump_rec(0.2, 0.5, 1, surf_flat(), surf_flat()),
    bump_rec(0.01, 0.9, 5, surf_flat(), sphere(10, surf_smooth()))));
コンテキストは、
  ptr{vertices} vptr;
  tcallable{gf_poly, {vptr, 

評価コンテキストはthreadedでなければならない。pglshaderはdrawerに対して

---------------------------------------------------------------------------
triangles_vertex_attributesのようなものをpublicにしない。

glvertex::vertices::push_polygon_distinct{tattr, split_convex}
これはtattrがpos又はpositionという名前のフィールドを持っていることを
期待している。glgeometryの中ではpoly_tがvertex_attrの配列で、vertex_attr
はpos, nor, tan, uvwのそれぞれvec3を持っている。
glvertex::vertices
  push_polygon_distinct(cslice{tattr} const& vals);
  push_point(tattr const& val);
  push_joint(node_joint const& e);

glbuffer::vertex_set(num_float_per_vertex0)
  ptr{vertices} vtxs = make_ptr{vertices}(num_float_per_vertex0);
glbuffer::vertex_buffer(num_float_per_vertex0)
  varray{ptr{vertex_set}} vs_arr;

---------------------------------------------------------------------------
シェーダ混在

特定の面だけを別シェーダで描きたいときに使う
頂点セットを作るときに複数のbo_idへfillする必要がある
シェーダごとに頂点属性は変わる
vs_id

頂点データ
vertex_buffer: 特定シェーダ向けvertex_setの集まり。これにbo_idが振られる。
  (vbidとbo_idは同じもの)
vertex_set: 特定シェーダ向け芋一個ぶんの頂点データと
  vertex_buffer中のオフセット情報。これにvs_idが振られる。
vertices: 特定シェーダ向け芋一個ぶんの頂点データ(values, elements)。

インスタンスデータ
aggregated_ibuffer: async_bufferが3つ。
async_buffer: 1フレーム1回glBufferDataでまとめて送る全インスタンスデータ。
whole_instances_type: 1フレームの全インスタンスデータ。async_bufferにコピー。
bo_instances_type: 特定シェーダ向け全インスタンスデータ。
instance_data: 特定の芋一個向けインスタンスデータ。async_buffer中のオフセット。

実現方法
- subdrawerなるものを作れるようにする。subdrawerはそれ自体用のインスタンス
  データを持たず、関連するmain_drawerのインスタンスデータを使って描画する。
- zprepass, shadowmappingは共通化すると効率良いかもしれないが後回し。
- 「このbo_idは別bo_idのインスタンスデータを使って描画せよ」
  pglshader_draw_frameのpd->draw()中、whole_instances[bo_id]を渡している
  部分、これをmain_drawerのbo_idに変換すればよい。
- subdrawerとmaindrawerは別々の頂点データを持つ。
- plshader::make_vertex_setで複数のdrawer名を指定できるようにする。

---------------------------------------------------------------------------
rigidbodyをscene_nodeと関連付ける

shapeを作る
  - そのshapeをconvex_hullであるかconcave_trianglesであるか等を指定
  - もとデータとなるvertexをjoint_idで指定

sceneのscene_objectを作る
  - sceneのトップレベルnodeからnodeのリストを得る。それらのjoint_idから
    shapeを得て、transから初期位置を得てrigidbodyを作る。


---------------------------------------------------------------------------
shadowmap

4枚シャドウマップを作る
それぞれで影キャスト元と先の距離を計算(depth値とsmposのz値との差から計算)
それぞれのシャドウマップには有効な距離の範囲がある。有効な範囲に影距離が
入っていた場合にのみそのシャドウマップから影を落とす。 <- まちがい
smposのz値は見ているピクセルのライトからの距離のdepth値
それとシャドウマップを読んだdepth値との差を、sm_distanceで掛けた値が
影とピクセルとの距離。
一つ近いシャドウマップの90%から100%の間で無効から有効に。
一つ遠いシャドウマップの90%から100%の間で有効から無効に。

近いマップを使える条件
  - 描画ピクセルとカメラの距離がマップのサイズより小さい
  - 影のさす元とカメラの距離がマップのサイズより小さい
    (shadowmapを参照したdepth値が0.5の付近にある)

---------------------------------------------------------------------------
lpの衝突判定

衝突対象の物体をbroadphaseに登録。
  dyncamicsWorldと別スレッドで判定するためには、衝突対象の物体の位置と
  大きさくらいをbtRigidBodyからコピーしておかなければならない。
全lpについて、findで衝突判定。

---------------------------------------------------------------------------

smp0	{0.0250000,0.0000000,0.0000000,0.0000000,0.0000000,0.0250000,0.0000000,0.0000000,0.0000000,0.0000000,-0.0250000,0.0000000,-0.0000000,-0.0000000,-0.0000000,1.0000000}
smp1	{0.0083333,0.0000000,0.0000000,0.0000000,0.0000000,0.0083333,0.0000000,0.0000000,0.0000000,0.0000000,-0.0083333,0.0000000,-0.0000000,-0.0000000,-0.0000000,1.0000000}

sm_projection0を掛ける: xyzそれぞれ 1.0/40.0 倍、zは負号反転
sm_projection1を掛ける: xyzそれぞれ 1.0/120.0 倍、zは負号反転

light m4        {1.0000000,0.0000000,0.0000000,0.0000000,0.0000000,1.0000000,0.0000000,0.0000000,0.0000000,0.0000000,1.0000000,0.0000000,0.0000000,-30.0000000,0.0000000,1.0000000}

light_view.inverse()を掛ける: camera_posを引く

v += "  vec3 ndelta = vary_normal * 0.02 / 40.;\n";
v += "  vec3 p = vary_position - camera_pos;\n";
v += "  vary_smpos0 = p / 40. + ndelta;\n";
v += "  vary_smpos1 = p / 120. + ndelta;\n";
v += "  vary_smpos2 = p / 360. + ndelta;\n";
v += "  vary_smpos3 = p / 1080. + ndelta;\n";

---------------------------------------------------------------------------
init_triangles_shader{1} テンプレパラメータやめる

copying instancingは止める。vertexattribdivisorかuniform instancingのどちらか。

model_matrixをuniformにするかvertexattribにしてEnableVertexAttribArrayするか



---------------------------------------------------------------------------
kinematic_object_i

- dynamic objectかどうか。dynamics_worldに登録される。
- 子オブジェクトをもつこともある
- フレームごとに自分自身の位置を移動したりする。
- 衝突したときのコールバック。
- その他全体に関わる処理(シーン切り替えなど)も実行できるようにしておく。 
- kinematic_object_factoryにmake_scene()で再帰的にkinematic_object一式を
  作成してdynamics_worldに登録される。
- prepare_instance_dataでインスタンスデータを詰めこむ。

interface scene_factory_i {
  function ptr{scene_object_i} make_scene(application_i mutable& app);
}
scene_objectはdynamics_worldを保持する。make_sceneはscene_objectの
コンストラクタを呼び、その中ではkinematic_objectをたくさん作って
dynamics_worldに登録する。

interface scene_object_i {
  function void on_motion_step(application_i mutable& app);
}
on_motion_stepは各kinematic_objectのupdate_stepを呼んでから、
dynamics_worldのmotion_stepを実行する。衝突のコールバック
on_collideが呼ばれる？

interface kinematic_object_i {
  function void update_step(scene_object_i mutable& sco);
  function void on_collide(scene_object_i mutable& sco,
    kinematic_object_i mutable& other);
}

種類毎に分けた密な配列にデータを詰め込めば効率よいはず。
全ての種類について密配列化するか、
極端にインスタンスが多い物だけにするか、
kinematic(dynamicではない)なものだけにするか。


---------------------------------------------------------------------------
collision_shapeと球を衝突判定する方法調べよ

CollisionShapeのペアに対し、そのペアを衝突判定するにふさわしいアルゴリズム
を作るのが、
btDefaultCollisionConfiguration::getCollisionAlgorithmCreateFunc(i,j) これ。
たとえばConvexHullとSphereであればbtConvexConvexAlgorithmで、これは中で
btGjkPairDetectorを毎回作って近い点を探している。
btGjkPairDetector::getClosestPoints() これ。
The ConvexHullDistance demo demonstrates direct use of btGjkPairDetector.
とのこと。

ConcaveConvexの組についてはbtConvexConcaveCollisionAlgorithm これは単独で
取り出すのは難しい？
processCollision()
concaveの各triangleに対して相手と衝突判定してるだけ？全量ではない。


---------------------------------------------------------------------------

rigid_bodyにcallbackオブジェクトを付ける。callbackオブジェクトはrigid_body
インスタンス毎のデータを持たないのであれば共有してもいい。

dynamics_worldにgrid_broadphase追加。衝突判定のみのオブジェクトの衝突判定
に使う。

swarm_iをdynamics_worldに追加できるようにする。
- swarm_i自体は多数のオブジェクトを配列として保持する。
- swarm_iはmultithreadedにする。dynamicsとは別スレで衝突判定するため。
- 各オブジェクトのデータはmodel matrixの大きさより多分小さい

各swarm_iはフレーム毎にstep()が呼ばれる。位置にデルタを加算したり、向きを
変えたりする。

grid_broadphaseには毎フレーム、rigidbodyの全インスタンスの情報をgridに
入れ、swarm_iの全インスタンスに対して衝突判定する。衝突していればswarm_i
のコールバックを呼ぶ。

grid_broadphaseの衝突判定narrow phaseは、とりあえずGJKだけ試してみる。

シーンを初期化すると、dynamic_object_iとswarm_iが複数dynamics_worldに
追加される。dynamic_object_iがdynamics_worldに追加されると、含まれる
collision_shapeとtransformの情報を見て複数かもしれないrigid_bodyが作ら
れる。dynamic_objectがdynamics_worldから削除されるときにはrigid_body
が削除される。dynamics_worldはdynamics_objectの強参照を保持する。
swarm_iについてもdynamic_objectとだいたい同じ。

threaded interface dynamic_object_i
{
  public ptr{rigid_body_i} get_rigid_body() const;
  public void on_collide();
  public void on_step(float speed);
}

multithreaded interface swarm_i
{
  public size_t size() const;
  public uint_t get(size_t idx, vec3 mutable& pos_r, float mutable& radius_r)
    const; // マスクを返す
  public void on_collide(size_t idx, dynamic_object_i const& o);
  // 消滅させるかどうか判定できるデータを各要素に持たせる必要がある。
}

swarmの衝突判定
1 dynamic_object一式をgridに登録。このときbtCollisionShapeの生ポインタも
  gridに保持しておく。これはnarrow phaseをするために必要。
2 swarmの各オブジェクトをgridで判定、相手のdynamic_objectのshapeに
  応じてnarrow phase判定。

collision_shapeにradiusを追加。grid_broadphaseに追加するのに必要
(あるいはgetAabbを使うほうがよい？)

---------------------------------------------------------------------------
bulletのNP並列化切り戻し

NP並列化関連
CMakeLists.txt
btBroadphaseProxy.h
btCollisionAlgorithm.h
btDbvtBroadphase.cpp
btDispatcher.h
btCollisionCreateFunc.h
btCollisionDispatcher.cpp
btCollisionDispatcher.h
btCompoundCollisionAlgorithm.cpp
btCompoundCompoundCollisionAlgorithm.cpp
btConvexConcaveCollisionAlgorithm.cpp
btConvexConcaveCollisionAlgorithm.h
btConvexConvexAlgorithm.cpp
btConvexConvexAlgorithm.h
btDefaultCollisionConfiguration.cpp
btDefaultCollisionConfiguration.h
btSoftBodyConcaveCollisionAlgorithm.cpp
btSoftBodyConcaveCollisionAlgorithm.h

BP高速化関連
btSimpleBroadphase.cpp
btSimpleBroadphase.h
btSequentialImpulseConstraintSolver.cpp
btDiscreteDynamicsWorld.cpp
btRigidBody.cpp
btScalar.h
btTransformUtil.h


無関係
OpenGlexampleBrowser.cpp
btOverlappingPairCache.h
btDimulationIslandManager.cpp
btAlignedAllocator.cpp
btAlignedAllocator.h
btPoolAllocator.h

---------------------------------------------------------------------------
parallax_warp

warp有効にすると、特に深さが深いときに速くなる。

// W = unused(8), Z = depth(8), Y = CPP(4) CPN(4), X = CNP(4) CNN(4)

void parallax_warp(in vec3 dir, inout vec4 tval, inout vec2 tpos,
  inout vec3 tsub)
{
  float cvt = floor((dir.x > 0.0 ? tex_val.y : tex_val.x) * 255.0 + 0.5);
  float cval = dir.y > 0.0 ? floor(cvt / 16.0) : fract(cvt / 16.0) * 16.0;
  cval = clamp(cval, 0.001, (tval.z - tsub.z) / dir.z);
    // tsubが1.0ちょうどになるのを回避するために0.001だけ動かす
  vec3 delta = dir * cval;
  vec2 npos = tpos + tsub.xy + delta.xy;
  tpos = floor(npos);
  tsub = vec3(npos - tpos, tsub.z + delta.z);
  parallax_read(tpos / tile_size, tval);
}

---------------------------------------------------------------------------
6方向hightmap

三角形をzが負からみたときの高さを計算
三角形の(x, y)座標が視点の(x, y)を含むか判定。
 ABxAP, BCxBP, CAxCPの負号が全て同じ
含むなら、平面とP(x, y)の交点となるz座標が高さとなる。
平面上のどこか一点A、視線と平面の交点P、法線ベクトルNとすると
平面の方程式: dot(P - A, N) = 0
(Px - Ax) * Nx + (Py - Ay) * Ny + (Pz - Az) * Nz = 0
(Pz - Az) * Nz = (Ax - Px) * Nx + (Ay - Py) * Ny
(Pz - Az) = ((Ax - Px) * Nx + (Ay - Py) * Ny) / Nz
Pz = ((Ax - Px) * Nx + (Ay - Py) * Ny) / Nz + Az
外積使うのは遅いので三角形の内部の点を網羅するほうがいい。
3点のAABBを調べ、x最小の点A, x最大の点Bとする。
for (px = floor(ax + 0.9999) + 0.5; px < bx; px += 1.0) {
  rat = (px - ax) / (bx - ax);
  pab = a + (b - a) * rat;
  if (px < cx) {
    rat = (px - ax) / (cx - ax);
    pacb = a + (c - a) * rat;
  } else {
    ra = (px - cx) / (bx - cx);
    pacb = c + (b - c) * rat;
  }
  y0 = pab.y;
  y1 = pacb.y;
  if (y0 < y1) { swap(y0, y1); }
  for (py = floor(y0 + 0.9999) + 0.5; py < y1; py += 1.0) {
    pz = ((ax - px) * nx + (ay - py) * ny) / nz + az;
    floor(px, py)の位置の深さがpzである
  }
}
ループの中は最低一回まわるように調整する?
px0 = floor(ax + 0.9999) + 0.5; // グリッドの中心
px1 = bx;
if (px0 >= px1) {
  px0 = (ax + bx + cx) / 3.0;
  px1 = px0 + 1.0;
}
function pair{float} calc_range(float ax, float bx)
{
  pair{float} r;
  r.first = floor(ax + 0.9999) + 0.5;
  r.second = bx;
  if (r.first >= r.second) {
    r.first = (ax + bx) / 2.0; // なるべく近いグリッド
    r.second = r.first + 1.0;
  }
  return r;
}

shapeのローカルaabbを求め、各三角形を(0,sz)にスケール。szは分割数。

衝突判定
3x2枚のheightmapのすべてについて衝突していれば衝突。
各heightmapについては、x,yのマップを引いてzが最小と最大の範囲に
はいっていれば衝突。

---------------------------------------------------------------------------

float linear_01(in float x, in float a, in float b)
{
  return clamp((x - a) / (b - a), 0.0, 1.0);
}

float linear_10(in float x, in float a, in float b)
{
  return clamp((b - x) / (b - a), 0.0, 1.0);
}

float max_vec3(in vec3 v)
{
  return max(v.x, max(v.y, v.z));
}

f += "bool n1 = all(lessThan(abs(p1),vec3(0.32,0.32,0.32))) &&";
フラグメントの位置がシャドウマップの中央1/3に入っている(カメラに近い)なら1
linear_10(max_vec3(abs(p1)), 0.28, 0.32);
f += "  abs(zval1 - 0.5) * 2.0 < zval_thr;\n";
フラグメントとキャスタの距離が閾値より近いなら1
linear_10(max_vec3(abs(zval1 - 0.5)), zval_thr * 0.8, zval_thr);
f += "float smv1 = min(1.0, sml1 + float(n1 ||";
f += "  any(greaterThanEqual(p1, vec3(1.0,1.0,1.0)))));\n";
フラグメントの位置がシャドウマップの範囲外なら1
linear_01(max_vec3(abs(p1)), 0.9, 1.0);

float smv1 = min(1.0, sml1
  + linear_10(max_vec3(abs(p1)), 0.33 * 0.9, 0.33)
  + linear_10(max_vec3((zval1 - 0.5) * 2.0, zval_thr * 0.9, zval_thr)
  + linear_01(max_vec3(abs(p1)), 0.9, 1.0));

---------------------------------------------------------------------------
box collider

radiusで判定した後にlocal aabbで判定できるようにする。
collision_shape_iにlocal_aabbを返す関数追加? 判定関数を作る？
さらに、local_aabbで判定した後にheightmapで判定できるようにする。
function bool collide(btVector3 const& pos, float ra);
  shapeのローカル座標へ変換。

各shapeにlocal判定の有無を返す関数を用意。それがtrueを返したら
local座標に変換したターゲット座標を渡してlocal判定実行。

function bool has_local_collision();
function bool local_collision(vec3 const& local_pos, float radius);

---------------------------------------------------------------------------
framebuffer

shadowmap用framebufferを作るところ。depth_textureではないケース。
GL_COLOR_ATTACHMENT0はテクスチャ、GL_DEPTH_ATTACHMENTはrenderbufferを
アタッチ。

int saved_fb;
// bindしてあるframebufferを覚えておく
glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
sfbo.fbo.generate();
glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
// colorにtexture(sm_texture)をアタッチ
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
  GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
int orig_rb;
// bindしてあるrenderbufferを覚えておく
glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
// glGenRenderbuffersでrenderbufferを作成
sfbo.depthbuf.generate();
glBindRenderbuffer(GL_RENDERBUFFER, sfbo.depthbuf.get());
// renderbuffer(depthbuf)のストレージを設定
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16,
  sfbo.sm_width, sfbo.sm_height);
// framebuffer(fbo)のdepthにrenderbuffer(depthbuf)をアタッチ
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
  GL_RENDERBUFFER, sfbo.depthbuf.get());
// bindしたrenderbufferを元に戻す
glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));

---------------------------------------------------------------------------
マテリアル

dpat: RGBとsubtexel法線パターン
pmpat: 視差マップのためのheightとclearance

float metalness;
float roughness;
vec3 color;

現状
  dpat:
    8bit: alv, avol
      tex_val.aの上4bitがavol, 下4bitがalv(0から10まで？)
      alv: 1, 3, 5, 7がLU, RU, RD, LDの四隅。2, 4が左右と上下の辺。0は傾けない。
    8bit * 3: RGB
  pmpat:
    8bit: 空き
    8bit: depth
    4bit * 4: clearance
変更後
  dpat:
    8bit: alv, avol
    8bit * 3: RGB
  pmpat:
    8bit: metalnessが1bit、roughnessが7bit (これ追加した)
    8bit: depth
    4bit * 4: clearance

dpatのpng画像
depth値とRGB値を別pngファイルにする。タイルエディタはdepth値の画像を使う？
gimpのレイヤでdepthとRGBを管理。
depth値は下位ビットから、R8段階、G8段階、B4段階
RGB値が

法線データはdepth値から計算。
計算方法:
  タイル境界を越えた位置にあるテクセルのdepthはclamp-to-edgeとする
  隣接する4つのテクセルの深さを読む
  上だけが深く3方は同じ -> 上凸
  上と左が深く2方は同じ -> 上左凸
  ..同様に全8方向
  浅いケースも同様に全8方向
  それ以外のパターンでは傾斜させない

法線を連続値にする？
計算方法:
  隣接8マスと中央との深さの差からxy方向の傾きを求め、平均する。
  法線ベクトルを8bit値の範囲に (-127から+127)
  depthと法線ベクトルは線形補間してよい。
  垂直面と水平面は区別しなくてよい。
  -> POMでよいのでは？

dpat/pmpat
64x64テクセルが16x16個、1024x1024テクセルのテクスチャが2枚。
(もっと大きくてもよい？ 性能をみて検討)
1テクセルあたりRGBA8が二つ(8byte)、計8Mbyte
タイル番号は1byteで表現可能
(横長に256個並べるか？)
default_color.png
default_depth.png

タイルパターン
タイルマップは1024x1024サイズ。(もっと大きくてもよい？)
4Gテクセル
default_tile.png

タイルの貼りかた
四角形の一番長い辺を底辺とする。
対向の辺から垂線を下ろした線分を求める。
対向の辺の、底辺から近いほうから底辺に水平に直線をひき、
垂線と交わった点を求める。
できた長方形の範囲の縦横が単純な整数比になるようにcropする。
(具体的にはあとで考える。深さ0の枠を作るため少しマージンを持たせる。)
cropした長方形の四隅にテクスチャ座標を決める。
四角形の四隅のテクスチャ座標を計算。
テクスチャ座標のaabbも4点全ての頂点データに含めておく。
(これはcropの内側かどうか判定するため。)
シェーダでは内側でなければ深さ0のdepthを返す。そのときの色はデフォルト色。

頂点データにaabb追加

---------------------------------------------------------------------------
メモ

頂点データエントリを追加するのはctx_fill()
中でbuild_context_iのfill()()
build_context_iインスタンスはpglshader::make_vertex_set()で作られる
fillerはdrawer::make_filler()で作られる
trianglesのときfillerの実体は
dgf_fill_tattr_internal{triangles_vertex_attributes}
これはpoly_tからarray{tattr}へデータをコピーし、push_polygon_distinct()
を呼ぶ。頂点データの大きさはtattrの大きさで決まる。

移行手順
- trianglesの*_vertex_attributesにuv_aabbフィールド追加。vec4型。
- dgf_fill_tattr_internalにuv_aabbをセットする処理追加。
- parallax_read()でuv_aabbの範囲かどうか見る
- tilemap()でuv_aabbの範囲かどうか見る

---------------------------------------------------------------------------
視差マップで平面より凸を許可

適用する平面より浮かせた面(5面)を作る。shadowmappingとprepassでは非表示。
四角形内座標として3次元値xyzを与える
四角形内の座標をあらわすvaryingを用意。(0,1)範囲内なら内。
テクスチャ座標の起点とオフセットを与える
parallaxのイテレートをuvw値スタートで実行、四角形から出たらdiscard
視線が法線に対して対向向きとは限らなくなる。
  ->特に変更不要と思われる

方針
- uvwのw値の従来の動作は止める
- ボーダーaabbはいらない(が、とりあえず残しておく)
- 4頂点を0,1であらわした境界判定用の頂点データ用意
- とりあえずprepassは無視して、浮かせた面を作る方向で
- 底面はボーダー色で塗る
- parallaxの始点を深さ付きで開始できるようにする
- 境界から出たらdiscard

移行手順
- uvwのw値を使わないように変更
- parallax_loop(): 始点を深さ付きで
- 浮かせた面を生成
- 境界判定用の頂点データ作る
- 境界から出たらdiscard 

parallax_loop()
引数のzをinoutに変更する

---------------------------------------------------------------------------
タイル貼り

01をx軸とする。
2から01へ垂線をおろし、01内に入っているかみる。
  01と02のcosが正なら01内なので、そのぶん0を1側にずらした位置が原点
    もし1をこえてしまっていれば貼れない
  そうでないなら0が原点
3から01へ垂線をおろし、01内に入っているか見る。
  01と13のcosが負なら01内なので、そのぶん1を0側にずらした位置がxmax
    もし0をこえてしまっていれば貼れない
  そうでないなら1がxmax
01の垂線方向、02・sin0102と03・sin0113の小さいほうがymax
原点と単位ベクトルを求めて0123を変換した座標がuv座標。

---------------------------------------------------------------------------
ブロック単位ではなくテクセル単位で整数に丸める

1. uv座標を1テクセルが1になるように変更

parallax_loop()
{
  parallax_read();
  if (tval.z == 0.0) {
    return;
  }
  for () {
    tnext_diff = parallax_next();
    if (tsub_next.z >= tval.z) {
      // horizontal
      break;
    }
    tpos += tnext_diff;
    parallax_read();
    if (tval.z < tsub.z) {
      // vertical
      break;
    }
    この時点で現在居るテクセルの境界の内側に少し入っている。
    現在居るテクセルの深さにはまだ到達していない。
    parallax_warp();
  }
}

---------------------------------------------------------------------------
シェーダ用テンプレートエンジン

<%opt 0>
<%>
<%/>
<%instance_attr model_matrix/>
<%vert_out/>

文法
- タグがない文字列はそのまま文字列リテラル
  fobar
  "fubar"
- タグをシンボルと引数に。タグ内の引数は文字列へ。
  <%foo bar baz>hoge<%/>
  (foo "bar" "baz" "hoge")
- ブロック引数無し
  <%instance_attr model_matrix/>
  (instance_attr "model_matrix")
- 引数無しのときはconsにしない
  <%hoge/>
  hoge
- タグ間に空白のみからなる文字列があったら読み飛ばす
  <%foo/>    <%bar/>
  foo bar
- タグ直後の改行とタグ直前のインデントは読み飛ばす
  <%foo>
  <%/>

意味
- シンボルは評価
- シンボルが先頭のconsは評価
- シンボルが先頭で無いconsは各要素を評価して文字列連結

union stempl_expr {
  string literal;
  ptr{stempl_expr_cons} cons;
}
struct stempl_expr_cons {
  string symbol; // 性能重視しないのでinternしなくていい
  stempl_expr args;
}

stempl if-elseif-else文
<%if> COND exprs ...<%/>
exprsの中から<%else/>を見つける。
CONDを評価し、真なら<%else/>より前を評価して返す。
そうでないなら<%else/>よりあとを評価して返す。
(if cond ... (elseif) cond ... (else) ...)

stempl bind文、set文
<%bind 変数名> ... <%/>
<%set> 変数名 値</%>

closureを許可すると循環参照作れてしまうので、コンテキストは
グローバルとローカルだけにするか

---------------------------------------------------------------------------

parallax_next: 次に接触するのがxyzどの方向かを返す。テクスチャ読まない。
parallax_read: テクスチャを読む。
parallax_warp: 

parallax_read();
for {
  parallax_next() 次にどの方向へ移動するか決める
  if (tsub_next.z >= tval.z) { break; } 先にz方向に接触(テクセル水平面)
  tsub, tpos更新
  parallax_read() 移動先のテクセルを読む
  if (tval.z < tsub.z) { break; } xy方向に接触(垂直面)
  parallax_warp() clearanceを見て複数テクセル移動
}

parallax_read()
for {
  parallax_next() 次の隣接テクセルを決める
  if (tsub_next.z >= tval.z) { break; } 先にz方向に接触(テクセル水平面)
  parallax_warp() 接触しない範囲で可能なら複数テクセル移動 readは止める
  parallax_read() 移動先のテクセルを読む
  if (tval.z < tsub.z) { break; } xy方向に接触(垂直面)
}

垂直壁のとき、影判定の始点は、最後の移動方向の反対向きのテクセルへ
移動したうえでtsubをclampする

---------------------------------------------------------------------------
voxel

voxel_read()
if (すでに接触) { return; }
for {
  voxel_next() 次の隣接ボクセルを決める
  移動
  voxel_read()
  if (接触) { break; }
}

隣接するvoxelのどの方向に移動するか決める
vec3 voxel_next(in vec3 tsub, out vec3 tsub_next, in vec3 d)
{
  vec3 r = vec3(0.0, 0.0, 0.0);
  float dzpos = float(d.z > 0.0);
  float nz = (dzpos - tsub.z) / d.z;
  vec2 xy = tsub.xy + d.xy * nz;
  if (d.z != 0.0 && in_01(xy)) {
    tsub_next = vec3(xy.x, xy.y, dzpos);
    r.z = dzpos * 2.0 - 1.0;
  }
  float dxpos = float(d.x > 0.0);
  float nx = (dxpos - tsub.x) / d.x;
  vec2 yz = tsub.yz + d.yz * nx;
  if (d.x != 0.0 && in_01(yz)) {
    tsub_next = vec3(dxpos, yz.x, yz.y);
    r.x = dxpos * 2.0 - 1.0;
  }
  float dypos = float(d.y > 0.0);
  float ny = (dypos - tsub.y) / d.y;
  vec2 zx = tsub.zx + d.zx * ny;
  tsub_next = vec3(zx.y, dypos, zx.x);
  r.y = dypos * 2.0 - 1.0;
}

bool in_01(in vec2 v)
{
  // return v.x > 0.0 && v.y > 0.0 && v.x < 1.0 && v.y < 1.0;
  return min(v.x, v.y) > 0.0 && max(v.x, v.y) < 1.0;
}

z=1またはz=0と接触する位置を計算
  tz = d.z > 0.0 ? 1.0 : 0.0
  tsub + n * d == (px, py, tz)
  tsub.z + n * d.z == tz
  n == (tz - tsub.z) / d.z
  >> p.xy = tsub.xy + d.xy * (tz - tsub.z) / d.z
p.xyが(0,1)内であればz方向に移動する。return。
同様にxとyについても接触位置を計算する

最小ブロック 8*8*8 最低64byte必要
4096*4096の、およそ平らな物体であれば 64*64*2 = 8192 ブロック程度必要。
  重複パタンが無いとすると 64 * 8192 = 524288 byte
  タイルid 32bitとすると タイルデータは 64*64*2*4 = 32768 byte
  (8*8*8ブロック、32bitタイルで16倍の圧縮率)
4096*4096*4096 の物体、非重複 8192ブロックであればタイルデータ 1048576 byte
  タイルデータ1mb パターン512k
ブロック 8*8*8 = 512 色と法線で8byte 4096byte / ブロック
  8192ブロックで32Mb
ブロック 8*8*8 = 512 色と法線は平面なら 512byteですむ
  8192ブロックで4Mb

手順と変更箇所
sampler_dpat, sampler_pmpat, sampler_tilemapはとりあえず使わない
sampler_voxpatを用意。とりあえずRGB色をいれておく。
  64*64*64くらいの3dテクスチャを作る。
trianglesのopt=1を使う
enable_normalmappingとenable_shadowmappingのブロックのあたり
頂点シェーダでvary_uvwにローカル座標系での頂点座標を渡す(positionそのまま?)
normal, tangent, binormalは接空間ではなくローカル座標系

必要なもの
- グローバル座標をローカル座標に変換する行列(モデル行列の逆行列)
  ライトとカメラの向きをローカル座標に変換したものを頂点シェーダで計算
- 3dテクスチャ

---------------------------------------------------------------------------
八分木探索

多重タイル化と比較するべし
ノードは8テクセルからなる。あるいは64=4*4*4、512=8*8*8などでもよいかも
ノードには葉フラグ、節なら子ポインタなど、葉なら色など
256*256*256の3dテクスチャRGBAなら16Mb
RGBA32Fのほうがよいかも
テクスチャは1次元でもよいかも

根となるテクスチャ位置を渡す。
現在位置を8分割のうちのどれかをしらべ、テクスチャを読む
  葉ならば空白かどうか調べ、そうでないなら終了
  空白ならば次の隣接ポイントを計算
    それがブロックの外側ならば親に戻る
    そうでないならそこへ移動
  節なら子テクスチャのオフセットをしらべ、そこへ移動

GLSLで実装するために、再帰の上限を決めてループに直す必要あり。
各レベルにおいてどの枝にいるのかを表す値を配列で持つ
  vec3 texpos[32];
    整数値を取る。テクスチャ座標(をテクスチャのサイズで乗じたもの)。
    xyz座標をそれぞれ2(64分木なら4)で割った余りがブロック内位置になる。
  int level;
    再帰のレベル。texpos[level未満]が使われる。
  vec3 curtex;
    現在見ているブロックのテクスチャ座標。2の倍数しかとらない。
    (64分木なら4の倍数)
  vec3 curpos_i;
  vec3 curpos_f;
    現在見ているブロック内位置の整数部と小数部。整数部は0,1しかとらない。
    (64分木なら0,1,2,3)

出発点となる座標を(0,1)値で与える。 curpos_i, curpos_fにセット。
出発点となるブロックをテクスチャ座標(テクスチャサイズを乗じたもの)で与える。
curtexにセット。
while (true) {
  テクスチャを読む。位置はcurtex + curpos_i(をテクスチャサイズで割ったもの)。
  if (葉) {
    色がついていればbreak。
    次の隣接ポイントを計算。
    while (true) {
      if (ブロックの外側) {
	親がなければ外側ループをbreak;
	texpos[]をpop。
	親の位置を計算しそこへ移動。
      } else {
	その隣接ポイントへ移動。
	break;
      }
    }
  } else {
    現在の curtex + curpos_i を texpos[]へpush。
    子の位置を読んだテクスチャから求め、その位置へ移動。
  }
}

bool raycast_octree(inout vec3 pos, in vec3 roottexpos, in vec3 ray,
  out vec4 value_r, out vec3 dir_r)
{
  const float texture_size = 64.0;
  const float texture_scale = 1.0 / texture_size;
  const int level_max = 32;
  vec3 texpos_arr[level_max];
    // 整数値を取る。テクスチャ座標(をテクスチャのサイズで乗じたもの)。
    // xyz座標をそれぞれ2で割った余りがブロック内位置になる。
  int level = 0;
    // 再帰レベル
  vec3 curpos_t = roottexpos;
    // 現在見ているブロックのテクスチャ座標。2の倍数しかとらない。
  vec3 curpos_i = floor(pos * 2.0);
  vec3 curpos_f = (pos * 2.0) - curpos_i;
    // 現在見ているブロック内位置の整数部と小数部。整数部は0,1しかとらない。
  vec4 value;
  vec3 dir = vec3(0.0); // 最初の位置が接触していれば0をそのまま返す
  int i;
  for (i = 0; i < 65535; ++i) {
    value = voxel_read((curpos_t + curpos_i) * texture_scale);
    int node_type = int(value.a * 255.0 + 0.5);
    if (node_type > 1) { // 色のついた葉
      while (level > 0) {
	--level;
	vec3 parent = texpos_arr[level];
	curpos_f = (curpos_i + curpos_f) * 0.5;
	curpos_t = floor(parent * 0.5) * 2.0;
	curpos_i = parent - curpos_t;
      }
      break;
    }
    if (node_type == 0) { // 空白
      curpos_f = clamp(curpos_f, 0.001, 0.999);
      dir = voxel_move(curpos_f, ray); // updates curpos_f
      int j;
      while (true) {
	vec3 curpos_i_next = curpos_i + dir;
	if (inside(curpos_i_next, 0.0, 1.0)) {
	  curpos_i = curpos_i_next;
	  break;
	}
	--level;
	if (level < 0) {
	  break;
	}
	vec3 parent = texpos_arr[level];
	curpos_f = (curpos_i + curpos_f) * 0.5;
	curpos_t = floor(parent * 0.5) * 2.0;
	curpos_i = parent - curpos_t;
      }
      if (level < 0) {
	break;
      }
      curpos_i_next += dir;
      curpos_f -= dir;
    } else { // 節 node_type == 1
      texpos_arr[level] = curpos_t + curpos_i;
      ++level;
      curpos_t = floor(value.xyz * 255.0 + 0.5) * 2.0;
      curpos_i = floor(curpos_f * 2.0);
      curpos_f = (curpos_f * 2.0) - curpos_i;
    }
  }
  pos = (curpos_i + curpos_f) * 0.5;
  if (i >= 65536 || level < 0 || level >= level_max) {
    value_r = vec(0.0);
    dir_r = vec(0.0);
    return false;
  }
  value_r = value;
  dir_r = dir;
  return true;
}

---------------------------------------------------------------------------
八分木構築

metafunction texel_value distinct_integral{uint};
metafunction node_value farray{texel_value, 8};

texel_value: 0x01000000のビットが立っていればノード参照

struct level_data {
  size_t size;                  // must be a power of 2
  varray{texel_value} values;   // size*size*size
  uint octnode_id_base;         // nodesの最初のエントリのoctnode_id
  varray{node_value} nodes;     // variable length
}

末端レベル
  valuesの各要素に色(RGBA)。
  level_dataのvaluesにそれを入れる。nodesは空。
  octnode_id_baseは0。

make_octree_one_level()
  入力と出力level_dataを引数に取る。ilevel, olevel。
  最初のoctnode_idを引数に取る。使ったぶんだけ加えて返値にする。
  octnode_id_cur;
  tree_map{node_value, texel_value} nodeset; // mappedは常にノード参照
  for x, for y, for z
    8テクセルを読む。
    もし8つとも同じ値であってその値が葉ならば、valueはその値。
      (ただし根レベルの時は例外で、葉にはしない)
    そうでないなら、8テクセルを読んでnode_valueを作り、それがnodesetに
    入っているか調べ、入っていればそのmapped値、そうでないなら新しい
    octnode_idをnodesetに入れ、そのoctnode_id値をvalueとする。
    valueをolevel.values[x,y,z]にセット。

octreeデータ作成
  一次元テクスチャ
  octnode_id_curの値 * 8がテクセルの数になるのでその大きさにリサイズ
  全レベルについて、nodesの値

make_octree_one_level(uint mutable& octnode_id_cur, level_data mutable& olevel,
  level_data const& ilevel)
{
  const sz2 = ilevel.size;
  const sz = sz2 / 2;
  olevel.size = sz;
  olevel.values.resize(sz * sz * sz, 0);
  olevel.octnode_id_base = octnode_id_cur;
  tree_map{node_value, uint} nodeset;
  for (const x: 0 .. sz) { for (const y: 0 .. sz) { for (const z: 0 .. sz) {
    node_value nvalue;
    for (const xi: 0 .. 1) { for (const yi: 0 .. 1) { for (const zi: 0 .. 1) {
      nvalue[zi * 4 + yi + 2 + xi] =
	ilevel.values[
	  (z * 2 + zi) * sz * sz +
	  (y * 2 + yi) * sz +
	  (x * 2 + xi)];
    } } }
    texel_value tvalue;
    if (sz != 1 && is_leaf_value(nvalue)) {
      tvalue = nvalue[0];
    } else if (const& m: nodeset[nvalue]) {
      tvalue = m;
    } else {
      nodeset[nvalue] = octnode_id_cur;
      tvalue = octnode_id_cur | 0x01000000U;
      ++octnode_id_cur;
    }
    olevel.values[(z * sz + y) * sz + x] = tvalue;
  } } }
  const id_base = olevel.octnode_id_base;
  olevel.nodes.resize(octnode_id_cur - id_base, node_entry());
  for (const& k, const& m: nodeset) {
    olevel.nodes[m - id_base] = k;
  }
}

----
old

非圧縮レベルをmake_octree_one_levelに適用し、その返値1が次のレベルとなる。
返値1が1*1*1サイズであるようなものまで適用したら終了。

各レベルの返値2のそれぞれについて、葉となるかどうか調べる。
  葉となる条件は、node_valueが8つとも同じ値を持っていて、かつその値(次に
  小さいレベルの返値2のインデックス)を引いた結果が葉となること。最小レベ
  ルの返値2が葉となる条件は、node_valueが8つとも同じ値を持っていること。
葉ならばその色(空白ならa=0,そうでないならa=1)を記録。
各レベルの返値2のそれぞれについて、葉でないならoctnodeを一つ割り当てる。
ただし根レベルでは葉であってもoctnodeを一つ割りあてる。octnode idが0。
(テクスチャ全体が同じ値を持つような場合に根レベルが葉になる)
(octnode割り当ては根レベルから順にやる)
octnode idの大きさのnode_value配列を作る。
各octnodeについて、node_value配列のoctnode idの位置を埋める。
値は、返値2エントリの以下のもの。
  - 葉ならばその値
  - そうでないならnode_value値をlocal idからoctnode idに変換したもの。

function void
make_octree_one_level(level_data mutable& olevel, level_data const& ilevel)
{
  const sz2 = ilevel.size;
  const sz = sz2 / 2;
  olevel.size = sz;
  olevel.values.resize(sz * sz * sz, 0);
  tree_map{node_value, uint} nodeset;
  uint local_id = 0;
  for (const x: 0 .. sz) { for (const y: 0 .. sz) { for (const z: 0 .. sz) {
    node_value nvalue;
    for (const xi: 0 .. 1) { for (const yi: 0 .. 1) { for (const zi: 0 .. 1) {
      nvalue[zi * 4 + yi + 2 + xi] =
	ilevel.values[
	  (z * 2 + zi) * sz * sz +
	  (y * 2 + yi) * sz +
	  (x * 2 + xi)];
    } } }
    if (const& m: nodeset[nvalue]) {
      nodeset[nvalue] = local_id;
      olevel.values[(z * sz + y) * sz + x] = local_id;
      ++local_id;
    } else {
      olevel.values[(z * sz + y) * sz + x] = m;
    }
  } } }
  olevel.nodes.resize(local_id, node_entry());
  for (const& k, const& m: nodeset) {
    olevel.nodes[m].nvalue = k;
  }
}

---------------------------------------------------------------------------
八分木構築retry

非圧縮レベル: 2*2*2テクセルの値をキーにして、同じ値を持つものを

metafunction node_value farray{uint, 8};
tree_map{node_value, uint} nodeset;

struct texel_value {
  bool is_reference;
  uint value; // is_referenceなら参照先のoctnode_id、そうでないなら色
}

---------------------------------------------------------------------------
八分木の一次元テクスチャ化

とりあえずRGBAのまま一次元化する。あとで小さくする。
大きくできなくて困る。
ループ回数を見てみる

---------------------------------------------------------------------------
4*4*4分木

4*4*4分木などにすると元絵のサイズに制約が出る。
2^(n*3)分木ならば元絵の幅のlog2がnの倍数でなければならない。
4*4*4分木ならば元絵の幅のlog2が2の倍数でなければならない。
元絵を2倍等すればいい。そうすれば元絵の幅は2の冪であればよい。
-> だめ。データが無駄に大きくなる。

---------------------------------------------------------------------------
空白長さ

ブロック内各ボクセルについて、隣接空白の範囲を長方形で。
長方形の取りかたは複数ありうる。
最長の軸を優先方式:
- xyz正負それぞれの方向で空白の長さを調べ、最長のものを基準とする。
- xが最長だったとする。
- 確保したxの範囲でxy最長の空白の長さを調べ、長いほうを基準とする。
- yが長かったとする。
- 確保したxyの範囲でz最長の空白の長さを調べる。
最短距離優先方式:
- xを正方向に一つ伸ばす
- xを負方向に一つ伸ばす
- yとzについても同じく


---------------------------------------------------------------------------
sponge問題

octree_bshift 1;      2*2*2 = 8分木
octree_size_l2 4;     16*16*16 = 4096ノード

block_factor = 2;
texture_size = 16 * block_factor;

prepare_texture_data_3d(7u); 128*128*128 ボクセル
convert_to_octree{1}(4); 8分木 4096ノード

convert_to_texture{1}(4)
sz_l2 = 7のはず。
sz = 128のはず
rsz = 16のはず
rsz2_l2 = 5
rsz2 = 32のはず
rtd->width = 32 16*16*16ノード、32*32*32ボクセル
data = 32768 あってる
nodes = 4546
16*16*16 = 4096ノードまでしか格納できないのであふれる

意図的に壊してフラクタルにするなら特定ノードまでで剰余を取るのがよい。

---------------------------------------------------------------------------
距離埋め込み

16*16*16 又は 8*8*8
a==0のとき空白
空白のときはrgb値には周辺の空白のaabb min/maxを書き込む。
上位4bitが-aabb_min, 下位4bitがaabb_max-1。最大16voxelまでしかskipできない。

vec3 voxel_next(inout vec3 curpos_i, inout vec3 curpos_f, in vec3 aabb_min,
 in vec3 aabb_max, in vec3 ray)
aabb_min, aabb_maxは最短で(0,0), (1,1)、最長になる

変更前:
float dzpos = float(d.z > 0.0);
float nz = (dzpos - tsub.z) / d.z;
vec2 xy = tsub.xy + d.xy * nz;
if (d.z != 0.0 && pos2_inside(xy, 0.0, 1.0)) {
  tsub = vec3(xy.x, xy.y, dzpos);
  r.z = dzpos * 2.0 - 1.0;
  return r;
}

変更後:
aabb_min += 0.001;  truncしたときに小数部がギリギリ境界手前になるように
aabb_max -= 0.001;
float dzpos = d.z > 0.0 ? aabb_max.z : aabb_min.z;
// float zdelta = dzpos - tsub.z;
// vec2 xydelta = d.xy * nz / d.z;
vec3 delta = vec3(d.xy * nz / d.z, dzpos - tsub.z);
if (d.z != 0.0 && pos2_inside(tsub.xy + delta.xy, aabb_min.xy, aabb_max.xy)) {
  vec3 diff_i = trunc(delta); // 0方向に切り捨て。GLSL1.2では使えない。
  tval += diff_i;
  tsub += delta - diff_i;
  r.z = d.z > 0.0 ? 1.0 : -1.0;
}

変更前:
if (node_type == 0) { // 空白
  curpos_f = clamp(curpos_f, 0.001, 0.999);
  dir = voxel_next(curpos_f, ray);
  while (true) {
    if (pos3_inside(curpos_i + dir, -0.5, block_factor - 0.5)) {
      break;
    }
    --level;
    if (level < 0) {
      break;
    }
    curpos_f = (curpos_i + curpos_f) * block_scale;
    vec3 parent = texpos_arr[level];
    curpos_t = floor(parent * block_scale) * block_factor;
    curpos_i = parent - curpos_t;
    // decode_coord(texpos_arr[level], curpos_t, curpos_i);
  }
  if (level < 0) {
    break;
  }
  curpos_i += dir;
  curpos_f -= dir;
} else { // 節 node_type == 1

変更後:
if (node_type == 0) { // 空白
  curpos_f = clamp(curpos_f, 0.001, 0.999);
  vec3 distval = floor(value.xyz * 255.0 + 0.5);
  vec3 dist_p = floor(distval.xyz / 16.0);
  vec3 dist_n = distval.xyz  - dist_p * 16.0;
  dir = voxel_next(curpos_i, curpos_f, 0.0001 - dist_n, 0.9999 + dist_p, ray);
  while (true) {
    if (pos3_inside(curpos_i + dir, -0.5, block_factor - 0.5)) {
      break;
    }
    --level;
    if (level < 0) {
      break;
    }
    curpos_f = (curpos_i + curpos_f) * block_scale;
    vec3 parent = texpos_arr[level];
    curpos_t = floor(parent * block_scale) * block_factor;
    curpos_i = parent - curpos_t;
    // decode_coord(texpos_arr[level], curpos_t, curpos_i);
  }
  if (level < 0) {
    break;
  }
  curpos_i += dir;
  curpos_f -= dir;
} else { // 節 node_type == 1

---------------------------------------------------------------------------
nodesのサイズ

nodesのサイズより小さくない最小の2の冪を計算。
9ならばw,h,d=3,3,3
3で割ってw,h,dをその値に。割った余りはdに加える。

---------------------------------------------------------------------------
タイル

元絵がタイル化されているときのmake_octree_one_level。
bshiftとタイルサイズが同じとする。
通常のmake_octree_one_levelでolevelを作ってからタイルマップで変換すればよい。

仮想絵のサイズ = タイルマップのサイズ * (1 << bshift)

タイルサイズは16^3。
タイル数は16^3。
タイルパターンは256^3。座標をタイルサイズで割ったものがタイル番号。
タイルパターン(256^3)とタイルマップ(256^3)の二つをbuildに渡す。
タイルマップのデータサイズ(256^3など)にタイルサイズ(16^3など)を掛けたものが
仮想絵サイズになる。
タイルマップのテクセル値はタイルパターンの番号

タイルマップの値はタイルパターンをタイルサイズで割ったサイズの座標(タイル座標)

---------------------------------------------------------------------------
めりこんだとき

案1: 裏面カリング無効、裏面がみえたときはカメラ位置からraycast開始
  裏ポリゴンにnear面が接触しているときに不可視。near面の大きさよりも、
  立方体と可視ボクセルとの距離を大きくとればおきないはず。
  描画順序によっては無駄が出る。
案2: めりこんでいるときは全面そのオブジェクトをraycast
  他のオブジェクトが内側にあるときにどうするか
案3: 表面カリング有効。裏面だけ書く。カメラが物体の内側ならばその位置を
  始点、そうでないならフラグメント位置からカメラに向かってvoxel_next
  した位置が始点。


重ね合わせ:
カメラからオブジェクトをみたときのzが一番近い点を基準にソート、手前から描画。
z-prepassやめる。遅延シェーディングもしない。
フラグメントシェーダでgl_FragDepthを書き込む。内側に入り込んだオブジェクトの
重ね合わせが正確にできるはず。

vec3 camera_local = -camera_dir * normal_matrix;
vec3 light_local = light_dir * normal_matrix;
vec3 pos = clamp(vary_position_local * 0.05 + 0.5, 0.0001, 0.9999);
vec3 campos = (camera_pos * vary_model_matrix) * 0.05 + 0.5; // FIXME: calc vsh
if (pos3_inside(campos, 0.0, 1.0)) {
  pos = campos;
} else {
  vec3 pos_i_unused;
  voxel_next(pos_i_unused, pos, vec3(0.0), vec3(1.0), -camera_local);
}


---------------------------------------------------------------------------
_3d_tmap
pattern_sz_l2: パターンデータのボクセル数
virt_sz_l2: 仮想ボクセル数
bshift: 3か4くらい
virt_sz_l2はbshiftの定数倍である必要がある
vtshift = virt_sz_l2 - bshift   仮想タイル数



---------------------------------------------------------------------------

再帰的バンプ

与えられた平面の上に複数のバンプを作る

tpat: 6方向のバンプパターンを作るxp, xn, yp, yn, zp, zn
それぞれの方向に16*16個、合計256*6個。

tmap: z=128 +- 8に板を配置

pz=0 xp方向に色がある
pz=1 xn
pz=2 yp
pz=3 yn
pz=4 zp
pz=5 zn


---------------------------------------------------------------------------
RGBAにエンコード

cpuでエンコード
平面パラメータ(a,b,c,d) ax+by+cz=d
  両辺割ってもよいのでdの絶対値は固定可能だが、abc小さくすると誤差が大きく
  なるので、両辺なるべく大きく取るほうがよい。もっとうまい表現方法はあるか？
a,b,cは(-1,1)、dは(-3,3)
dの値は4で割る
abcdを127倍?し128を加えて四捨五入。[0,255]にclamp。dは2未満にならないよう
にする。

glslでデコード
abcd = floor(val * 255.0 + 0.5) で[0,255]に戻す
  ここでdが0ならば平面パラメータは無いものとする。
128を引き、128で割る。(割らなくてもいいが)
dは4倍する。

---------------------------------------------------------------------------
法線、接平面

面(a,b,c,d): ax + by + cz = d
位置 p=(px,py,pz), 視線方向 v=(vx, vy, vz)
  接触点c=(x,y,z) c=p+tvを満たす

1. 位置pが埋まっている側かどうか調べる
  dot(abc,p)-dが正なら空白側、そうでないなら埋まっている。
  埋まっている側なら壁に接触。return。
2. 接触点を計算
  接触点c = p + tv
    where t = (d - (dot(abc, p)) / dot(abc, v)
  もしcが(0,1)の内側であればそこが接触。return。
3. そうでないなら接触していない。

面をどうやって作るか？
ボクセル内全ての頂点の凸包を作り、それぞれの面が切断する体積を求め、
最大のものを採用する

球の接平面データを作る
全体256^3ボクセル
各ボクセルでの接平面データ
1. まず球がそのボクセルの内側・外側・境界のいずれかを判定。
  一番近い頂点と遠い頂点と球の中心との距離を計算、半径と比較
  境界でなければ終了。
2. 一番遠い頂点の位置ベクトル(オブジェクト中心を原点、(-1,1)範囲)をpとする。
  p = (px,py,pz)
  接平面の法線ベクトルは n = normalize(p) に一致する。
  オブジェクト座標で計算すると
    接平面 ax+by+cz=d, 法線(a,b,c)=n は点pを通るから
    d = dot(n,p) = 球の半径
  ボクセル内座標で計算すると
    接平面 ax+by+cz=d, 法線(a,b,c)=n はボクセル内座標lpを通るから
    nx.lpx+ny.lpy+nz.lpz=d
    d = dot(n,lp)

---------------------------------------------------------------------------
仮にpolygon meshに変換したとすると

直方体一個につき12tri
16x16x16で10個の直方体とする。120tri
256*256*32タイルとする
251658240tri。2億5000万tri。
voxelデータの仮想サイズを大きくするとそこそこ遅くなる

polygon meshでは1500万triくらい出ていた。
polygon + parallax + lod と voxel でも対等くらい？
polygon + voxel が最適か。
  - オブジェクト増やしてもほとんど遅くならない
  - ディテールの自由度が高い
  - self shadow を正確に描ける

---------------------------------------------------------------------------

x, y, z を 0 から pszまで
const x1 = float(x * 2 + 1 - psz) / float(psz)
  最小値 (1 - psz) / psz == -255 / 256
  最大値 (511 - 256) / psz == +255 / 256
これがオブジェクト座標系(-1,+1)でのボクセルの中心位置
ボクセルの隅は中心から 1.0 / psz を加減算した値。

vec3 nor = make_vec3(x1, y, z1).normalize();
ボクセル中心での法線ベクトル

(x1, y1, z1).normalize() * 半径 を p=(px, py, pz) とする。
これはボクセル中心と球の中心を結ぶ直線が表面に接する点。
これをボクセルローカル座標に変換したものを lp=(lpx, lpy, lpz)とする。
ボクセル内座標で
  ax+by+cz=d, 法線(a,b,c)=nor, 点lpを通るから、
  d = dot(nor, lp) と求まる。
この平面がボクセル座標(0,1)の範囲と接触するかどうか判定。
  xyzは0..1なのでax+by+czの最小値は以下のように計算。
  axの最小値は aが負の時a, そうでないとき0
  xmi = min(a, 0), ymi = min(b, 0), zmi = min(c, 0)
  mi = xmi + ymi + zmi
  axの最大値は aが正の時a, そうでないとき0
  xmx = max(a, 0), ymx = max(b, 0), zmx = max(c, 0)
  mi <= d <= mx となったときボクセルと球面は接触する。
  d < miなら空白 mx < di なら埋まっている。

オブジェクト座標(-1,+1)からボクセルローカル座標(0,1)への変換
  ボクセルの0点 v0 = (x1, y1, z1) - (1.0, 1.0, 1.0)
  ボクセルの1点 v1 = (x1, y1, z1) + (1.0, 1.0, 1.0)
  lpx = (px - v0) * psz (=256.0) * 0.5

---------------------------------------------------------------------------

voxel_nextで読み飛ばす処理を関数に
  速度確認せよ FIXME

---------------------------------------------------------------------------

bool raycast_octree
{
  for (0 .. 128) {
    value = texture(...);
    if (色) {
      if (平面に接触) {
	if (ボクセル内で接触していない) {
	  raycast_next(...);
	  continue;
	} else { // ボクセル内で平面に接触
	  dir = 平面の法線
	}
      } else { // 壁に接触
	// dir = 壁の向き？
	// hit_wall = true;
	dir = 平面の法線
      }
      if (影処理中) {
	lstr_para = 0.0;
	break;
      }
      value_r = 物体の色
      影処理中 = true;
      ray = light;
      if (hit_wall) {
	texpos_arr pop;
      } else {
	raycast_next(...);
      }
    } else if (節) {
      texpos_arr push;
    } else { // 空白
      raycast_next(...);
    }
  }
  return hit;
}

ループの最後でraycast_next(...)を通る形に書き換えるべし。


---------------------------------------------------------------------------
表面に3dテクスチャを貼る

ctx_fill(n)
-> build_context_i#fill(true, false, n, "", poly, mp)
-> build_context_impl#fill(...)
-> fillers[n](...)
   pglshader#make_vertex_set(...)
   n番目のdrawersのfillerが実行される
    r.insert("drawer_0_triangles", make_drawer_triangles(sconf, res, 0));
    r.insert("drawer_0_triangles_alt", make_drawer_triangles(sconf, res, 1));
  n == 1ならdrawer_0_traiangles_alt
  drawer_triangles#make_fillerは make_dgf_polygon_filler
-> dgf_fill_tattr_internal
  uvwとuv_aabbに書き込んでいるが_altシェーダでは見ないのでは？
  poly_tはcslice{vertex_attr}
  vertex_attrはstruct { vec3 pos, nor, tan, uvw; }

- gf_ctx_fill(n)のかわりに、3dテクスチャのための立体を作りuvwを設定して
  gf_ctx_fillするようなgfを作る
  gf_ctx_tex3d(n) ?
- dgf_fill_tattr_internal: uvwをpoly_tのものを反映するフラグかなにかを作る
- fshでuvwをテクスチャ座標として反映させるようにする

従来のシェーダ
<%vert_in/> vec3 position;
<%vert_in/> vec3 normal;
<%vert_in/> vec3 tangent;
<%vert_in/> vec3 uvw;
<%vert_in/> vec4 uv_aabb;
tex3dで渡す情報
- 3dテクスチャを貼る座標系(接空間)への変換行列が必要
- 各頂点の接空間での座標が必要
- 各頂点のuvw座標が必要
positionで接空間の原点位置、normalとtangentとその外積で回転、uvwでテクスチャ座標

dgf_polygon_filler_tattrのoverride_uvwフラグはtriangles drawerのoptが0のとき
有効になる。
optが1のときはuv_aabbのかわりにlocal_positionを入れるか
接空間からテクスチャ座標への変換とその逆変換が必要(gl_FragDepth計算に必要)
aabb_lposのxyzにuvw原点の接空間座標、wにuvwから接空間座標へのスケールを入れる。

tex3dシェーダでの頂点属性の解釈まとめ
- position, normal, tangentにはモデル座標から接空間座標への変換を入れる
- uvwには頂点のテクスチャ座標を入れる
- uv_aabb(名前変える)に頂点のテクスチャ座標から接空間座標への変換を入れる

手順
- uv_aabb -> aabb_or_lconv
- geometry::funcs::vertex_attrにlocal_pos追加(接空間での頂点座標)
- drawer::base::dgf_fill_tattr_internalでoverride_uvwが偽のときに
  local_posからaabb_or_lconvをセット
- gf_ctx_tex3dがpos, nor, tanを接空間の原点位置と回転、uvwにテクスチャ座標、
  local_posに接空間での頂点座標を入れるように変更
- vshの変更点
  - 方針: 接空間への変換も含めてmodel matrixとする
  - uvw以外のパラメータは全頂点で共通(勿体無い？)

頂点シェーダ
in vec3 position; // オブジェクト座標系での接空間の原点座標
in vec3 normal; // オブジェクト座標系での接空間のz軸
in vec3 tangent;  // オブジェクト座標系での接空間のx軸
in vec4 aabb_or_tconv;  // テクスチャ座標から接空間への変換
in vec3 uvw;  // 頂点のテクスチャ座標
out vec3 vary_position; // グローバルでの頂点座標 --------?
out vec3 vary_normal; // グローバルでの法線
out vec3 vary_tangent; // グローバルでの接線
out vec3 vary_binormal; // グローバルでの従法線
out vec3 vary_uvw; // 頂点のテクスチャ座標
out vec3 vary_aabb_or_tconv; // テクスチャ座標から接空間への変換
out mat4 vary_model_matrix; // 
out vec3 vary_position_local; // 接空間での頂点座標
out vec3 vary_camerapos_local; // 接空間でのカメラの位置
vary_uvw = uvw; // 頂点のテクスチャ座標
vary_position_local = aabb_or_tconv.xyz + uvw * aabb_or_tconv.w;
  // 接空間での頂点座標
binormal = cross(normal, tangent); // オブジェクト座標系での接空間のy軸
mat4 tan_to_obj = mat4(
    vec4(tangent, 0.0),
    vec4(binormal, 0.0),
    vec4(normal, 0.0),
    vec4(position, 1.0)) // 接空間からオブジェクト座標系への変換
mat4 obj_to_tan = inverse(tan_to_obj);
  // 接空間からオブジェクト座標系への変換
mat4 mm = <%instance_attr_model_matrix/>;
  // モデル行列(オブジェクト座標からグローバルへの変換)
mat4 tan_to_world = mm * tan_to_obj; // 接空間からグローバルへの変換
vec4 gpos4 = tan_to_world * vec4(vary_position_local, 1.0);
  // グローバルでの頂点の座標
gl_Position = view_projection_matrix * gpos4; // gl_Position書き込み
vary_position = gpos4.xyz / gpos4.w; // グローバルでの頂点の座標
vary_model_matrix = tan_to_world;
  // グローバルから接空間への変換
vec4 cp4 = = inverse(vary_model_matrix) * camera_pos;
vary_camerapos_local = cp4.xyz / cp4.w;
  // 接空間でのカメラ位置

接空間座標sをテクスチャ座標に変換
ts = texpos.xyz + s.xyz * texscale
  texscale = 1.0 / aabb_or_tconv.w
  texpos = - aabb_or_tconv.xyz * texscale

フラグメントシェーダ
vary_aabb_or_tconv = vec4(-32.0, -32.0, -32.0, 64.0);に一旦してテスト
テクスチャ座標posを接空間座標に戻すには
lpos = vary_aabb_or_tconv.xyz + pos * vary_aabb_or_tconv.w;

vec3 tpos = vary_uvw; // テクスチャ座標
vec3 lpos = vary_aabb_or_tconv.xyz + tpos * vary_aabb_or_tconv.w; // 接空間座標

tangent spaceの意味が曖昧
- tangent vector space 接ベクトル空間。接線が成すベクトル空間。
- tangent space (2) 接線と法線と従法線で作られるベクトル空間。

頂点データの計算
入力:
  - オブジェクト座標系での各頂点の座標pos
  - 貼り付けるテクスチャのオフセットtexpos
  - テクスチャのスケールtexscale (2ならばオブジェクト座標系の1がテクスチャの2)
多角形を覆う長方形を決め、その頂点の一つを接空間の原点とする。
その座標がposition属性(オブジェクト座標系での接空間の原点座標)。
オブジェクト座標での多角形の法線がnormal属性。
オブジェクト座標での原点から次の頂点へのベクトルをnormalizeしたのがtangent属性。
外積をとったのがbinormal(属性にはセット不要)。
原点から残りの頂点へのベクトルをtangent, binormal, normalと内積をとったものが
各頂点の接空間座標xyzとなる。
各頂点のテクスチャ座標は、texpos + 接空間座標 * texscale となる。uvw属性。
1.0/texscaleをaabb_or_tconv属性のw。
-texpos/texscaleをaabb_or_tconv属性のxyz。
検算
  原点のuvw属性はtexpos。
  vary_position_local
    = aot.xyz + uvw * aot.w
    = -texpos/texscale + texpos / texscale
    = 0
  あってる。

TODO: カメラが立体の内側に入ったかどうかの判定？

geometry生成時に設定するパラメータ
- テクスチャのxyサイズは、座標との比をパラメータとして渡して計算する？
- テクスチャのzサイズはgfに引数として渡す？
- テクスチャ座標offsetはgfにパラメータとして渡す。いずれテクスチャ生成関数を
  挟めるようにする
- テクスチャ座標のaabbをシェーダに渡す必要がある。頂点属性に追加する。


whに対しdが1/32のとき。

---------------------------------------------------------------------------
ctx_tex3d

縦横高さサイズを指定し、それに合った3dテクスチャをランダムに作る。
struct tex3_param {
  uint width;
  uint height;
  uint depth;
  その他生成のためのパラメータ
}
パラメータが同一なら同じパターンが複数箇所に貼られることがある。
ジェネレータはアトラス内のオフセットを返す。

低辺: 直方体のx軸にするのをどの辺にするかを指定 (0-3)
高さ: 接線座標のz方向の大きさ
テクスチャ位置: 接線座標の原点に貼り付けるテクスチャの座標 (0,1)
テクスチャ拡大率: 接線座標の1に対するテクスチャの大きさ

---------------------------------------------------------------------------
バンプ

斜面ボクセルに壁有りと壁無しを用意する
壁有り: 埋まっている側のボクセル壁に反射する
壁無し: 斜面のみに接触？斜面の裏側から見たときは壁に反射する？

左右だけが斜面のバンプ
  __/~~~~\__
  斜面ボクセルは壁有り斜面

8方向が斜面のバンプ
  斜面ボクセルは壁無し

---------------------------------------------------------------------------

+-----*
|    /|
|   / |
|  /  |
| /   |
|/    |
*-----+
x=y
x-y=0
逆向きは x+y=1

---------------------------------------------------------------------------

vec3 v; // 視線
vec3 a; // 始点 curpos_f
vec3 mul_pt; // 拡大率
vec3 c_pt; // 中心
float rad2_pt; // 半径の2乗

a_pt = mul_pt * (a * 2.0 - 1.0); // 変換後の始点
v_pt = mul_pt * v; // 変換後の視線
len_v_pt = length(v_pt);
v_ptn = normalize(v_pt);
ac_pt = c_pt - a_pt; // ベクトルAC
len2_ac_pt = dot(ac_pt, ac_pt);
if (len2_ac_pt < rad2_pt) { return 始点が球の内側 }
ac_v = dot(ac_pt, v_ptn);
d_pt = a_pt + v_ptr * ac_v; // Cから視線に垂線を下ろした点D
cd_pt = d_pt - c_pt; // ベクトルCD
len2_cd_pt = dot(cd_pt, cd_pt); // CDの大きさの2乗
if (len2_cd_pt < rad2_pt) { 視線と球は交わらない }
len_de_pt = sqrt(rad2_pt - len2_cd_pt); // DEの大きさ
len_ae_pt = ac_v - len_de_pt; // AEの大きさ
len_ae = len_ae_pt / len_v_pt; // 逆変換したAEの大きさ
e = a + v * len_ae; // 変換前の交点

---------------------------------------------------------------------------
android pause/resume

シェーダ

テクスチャ

インスタンスデータ
aggregated_ibuffer aibuffer pglshderが保持

GL3用VAO
auto_vertexarray vtxarr  pglshaderが保持

頂点データ
vertex_buffers pglshaderが保持
vertex_buffer glbuffer.px
auto_buffer vbo_values;
auto_buffer vbo_elems;
create_vbo()でGPU側に作成
  これの後半を分離、リロードできるようにする
  auto_buffer の generateをすればよい。自動で古い値は解放される。

#define SDL_EGL_MakeCurrent_impl(BACKEND) int \
BACKEND ## _GLES_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context) \
{\
    if (window && context) { \
        return SDL_EGL_MakeCurrent(_this, ((SDL_WindowData *) window->driverdata)->egl_surface, context); \
    }\
    else {\
        return SDL_EGL_MakeCurrent(_this, NULL, NULL);\
    }\
}

#define SDL_EGL_CreateContext_impl(BACKEND) SDL_GLContext \
BACKEND ## _GLES_CreateContext(_THIS, SDL_Window * window) \
{\
    return SDL_EGL_CreateContext(_this, ((SDL_WindowData *) window->driverdata)->egl_surface);\
}

windowはnullでないからwindow->driverdata->egl_surfaceがnullになっている

---------------------------------------------------------------------------
raycast_octreeをカメラとライトで分離するほうがよいか

なぜか分離しないほうがはるかに速い。
分離してみたものを置いておく。 saved/2step-traingles.fsh

---------------------------------------------------------------------------
nvidia control panel

レンダリング前最大フレーム数を小さくするとわずかに速くなる。
遅延も小さくなるので1にするのがよいか。
それ以外の項目はすべてデフォルト。

