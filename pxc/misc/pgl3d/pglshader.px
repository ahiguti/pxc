public namespace pglshader "export-unsafe";
public import common -;
public import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
public import glm::raw;
public import io::time -;
public import exception -;
public import meta m;
public import pointer::func -;
public import GL::compat -;
public import glresource -;
public import glshader -;
public import glgeometry -;
public import glbuffer -;
public import scenenode -;
public import pglbase -;
public import intern_pool -;

public enum draw_step {
  draw_step_shadowmapping = 1,
  draw_step_prepass = 2,
  draw_step_solid = 3,
  draw_step_blend = 4
}

public interface pgldrawer_i {
  public function void prepare(pglshader mutable& pgs);
  public function void draw(draw_step step, pglshader mutable& pgs,
    varray{instances_type} mutable& bo_instances,
    projection_info const& cam_df);
}

public struct drawer_triangles() {
  public function void prepare(pglshader mutable& pgs) {
    sdr_solid.some = init_main_shader{1}(pgs.glc);
    sdr_shadow.some = init_shadowmap_shader{1}(pgs.glc);
    sdr_zp.some = init_zprepass_shader{1}(pgs.glc);
    vbid_main = pgs.intern_vbid("vbid_main");
    prepare_instance_data_cb_add(*pgs.prepare_instance, vbid_main,
      make_funcptr{prepare_instance_data_main}());
    pgs.set_vertex_buffer(vbid_main, make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{main_vertex_attributes}), false));
  }
  public function void draw(draw_step step, pglshader const& pgs,
    varray{instances_type} mutable& bo_instances,
    projection_info const& cam_df) {
    if (step == draw_step_shadowmapping) {
      glUseProgram(sdr_shadow.some->program);
      draw_instanced(*sdr_shadow.some,
	*pgs.vertex_buffers[static_cast{size_t}(vbid_main)],
	bo_instances[static_cast{size_t}(vbid_main)],
	pgs.global_ibuffer, vbid_main, 1, pgs.glc.enable_instanced,
	pgs.glc.enable_uniform_instancing);
    } else if (step == draw_step_prepass) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      glUseProgram(sdr_zp.some->program);
      glUniformMatrix4fv(pgs.zpsdr->u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      draw_instanced(*pgs.zpsdr,
	*pgs.vertex_buffers[static_cast{size_t}(vbid_main)],
	bo_instances[static_cast{size_t}(vbid_main)],
	pgs.global_ibuffer, vbid_main, 0, pgs.glc.enable_instanced,
	pgs.glc.enable_uniform_instancing);
    } else if (step == draw_step_solid) {
      const sm_view = cam_df.light.to_mat4().inverse();
      const sm_vp = cam_df.sm_projection * sm_view;
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
      mutable& sdr = *sdr_solid.some;
      glUseProgram(sdr.program);
      glUniform3fv(sdr.u_light_pos, 1, cam_df.light.position.to_crawptr());
      glUniform3fv(sdr.u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glUniform1i(sdr.u_sampler, 1);
      glUniform1i(sdr.u_sampler_tilemap, 2);
      glUniform1i(sdr.u_sampler_sm, 3);
      glUniform1f(sdr.u_light_on, 1.0f);
      glUniformMatrix4fv(sdr.u_shadowmap_vp, 1, 0, sm_vp.to_crawptr());
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0, vp.to_crawptr());
      draw_instanced(sdr,
	*pgs.vertex_buffers[static_cast{size_t}(vbid_main)],
	bo_instances[static_cast{size_t}(vbid_main)],
	pgs.global_ibuffer, vbid_main, 0, pgs.glc.enable_instanced,
	pgs.glc.enable_uniform_instancing);
    }
  }
  option{main_shader_ptr{1}} sdr_solid;
  option{zprepass_shader_ptr{1}} sdr_zp;
  option{shadowmap_shader_ptr{1}} sdr_shadow;
  vertex_buffer_id vbid_main = -1;
}

public struct drawer_triangles2() {
  public function void prepare(pglshader mutable& pgs) {
  }
  public function void draw(draw_step step, pglshader const& pgs,
    varray{instances_type} mutable& bo_instances,
    projection_info const& cam_df) {
    if (step == draw_step_shadowmapping) {
      glUseProgram(sdr_shadow.some->program);
      draw_instanced(*sdr_shadow.some,
	*pgs.vertex_buffers[static_cast{size_t}(vbid_main2)],
	bo_instances[static_cast{size_t}(vbid_main2)],
	pgs.global_ibuffer, vbid_main2, 1, false, false);
    } else if (step == draw_step_prepass) {
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      glUseProgram(sdr_zp.some->program);
      glUniformMatrix4fv(sdr_zp.some->u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      draw_instanced(*sdr_zp.some,
	*pgs.vertex_buffers[static_cast{size_t}(vbid_main2)],
	bo_instances[static_cast{size_t}(vbid_main2)],
	pgs.global_ibuffer, vbid_main2, 0, false, false);
    } else if (step == draw_step_solid) {
      const sm_view = cam_df.light.to_mat4().inverse();
      const sm_vp = cam_df.sm_projection * sm_view;
      mutable view = glm::mat4();
      view = cam_df.camera.to_mat4().inverse();
      const vp = cam_df.projection * view;
      const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
      mutable& sdr = *sdr_solid.some;
      glUseProgram(sdr.program);
      glUniform3fv(sdr.u_light_pos, 1,
	cam_df.light.position.to_crawptr());
      glUniform3fv(sdr.u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glUniform1i(sdr.u_sampler, 1);
      glUniform1i(sdr.u_sampler_tilemap, 2);
      glUniform1i(sdr.u_sampler_sm, 3);
      glUniform1f(sdr.u_light_on, 1.0f);
      glUniformMatrix4fv(sdr.u_shadowmap_vp, 1, 0, sm_vp.to_crawptr());
      glUniformMatrix4fv(sdr.u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      draw_instanced(sdr,
	*pgs.vertex_buffers[static_cast{size_t}(pgs.vbid_main2)],
	bo_instances[static_cast{size_t}(vbid_main2)],
	pgs.global_ibuffer, vbid_main2, 0, false, false);
    }
  }
  option{main_shader_ptr{0}} sdr_solid;
  option{zprepass_shader_ptr{0}} sdr_zp;
  option{shadowmap_shader_ptr{0}} sdr_shadow;
  vertex_buffer_id vbid_main2 = -1;
}

public struct
pglshader(bool gles_flag0, int glmajor0, int glminor0, bool enable_msaa0,
  int width0, int height0)
<make_vertices_i>
{
  public glconfig glc = glconfig(gles_flag0, glmajor0, glminor0,
    enable_msaa0);
  public main_shader_ptr{1} const sdr = init_main_shader{1}(glc);
  public main_shader_ptr{0} const m2sdr = init_main_shader{0}(glc);
  public shadowmap_shader_ptr{1} const smsdr = init_shadowmap_shader{1}(glc);
  public shadowmap_shader_ptr{0} const sm2sdr = init_shadowmap_shader{0}(glc);
  public zprepass_shader_ptr{1} const zpsdr = init_zprepass_shader{1}(glc);
  public zprepass_shader_ptr{0} const zp2sdr = init_zprepass_shader{0}(glc);
  public particle_shader_ptr const spsdr = init_particle_shader(glc);
  public particle_bb_shader_ptr const prtbsdr = init_particle_bb_shader(glc);
  public lineparticle_shader_ptr const lpsdr = init_lineparticle_shader(glc);
  public rect2d_shader_ptr const rsdr = init_rect2d_shader(glc);
  public font2_shader_ptr const f2sdr = init_font2_shader(glc);
  public shadowmap_fbo sfbo;
  public main_texture_info mti;
  public font_texture_info fti;
  public projection_info cam;
  public varray{ptr{vertex_buffer}} vertex_buffers;
  public instance_buffer_type global_ibuffer;
  public tptr{prepare_instance_data_cb} const prepare_instance
    = make_tptr{prepare_instance_data_cb}();
  private auto_vertexarray vtxarr;
  private tree_map{string, vertex_buffer_id} vertex_buffer_id_map;
  private intern_pool{vertex_buffer_pool_key} vbid_pool;
  public vertex_buffer_id vbid_main = -1;
  public vertex_buffer_id vbid_main2 = -1;
  public vertex_buffer_id vbid_particle = -1;
  public vertex_buffer_id vbid_particle_bb = -1;
  public vertex_buffer_id vbid_font2 = -1;
  public vertex_buffer_id vbid_lineparticle = -1;
  public vertex_buffer_id vbid_rect2d = -1;
  public function vertex_buffer_id to_vbid(cstrref const& name) const {
    return vbid_pool.to_id(name);
  }
  public function vertex_buffer_id intern_vbid(cstrref const& name) {
    return vbid_pool.intern(name);
  }
  public function void set_vertex_buffer(vertex_buffer_id vbid,
    ptr{vertex_buffer} const& p) {
    vertex_buffers.resize(static_cast{size_t}(vbid) + 1,
      make_ptr{vertex_buffer}(0u, false));
    vertex_buffers[static_cast{size_t}(vbid)] = p;
  }
  init();
  resize_screen(width0, height0);
  private function void init()
  {
    if (m::ne{is_gl3_or_gles3, 0}) {
      vtxarr.generate();
      glBindVertexArray(vtxarr.get());
      sdllog("glBindVertexArray", vtxarr.get());
    }
    if (m::eq{is_gles, 0}) {
      farray{float, 2} arr;
      float step;
      glGetFloatv(GL_POINT_SIZE_RANGE, arr.to_rawptr());
      glGetFloatv(GL_POINT_SIZE_GRANULARITY, address(step));
      sdllog("GL_POINT_SIZE_RANGE", arr, step);
    }
    init_texture(mti, fti);
    /*
    if (m::ne{is_gl3_or_gles3, 0}) {
      if (glc.enable_msaa) {
	glEnable(GL_MULTISAMPLE);
      }
    }
    */
    if (m::eq{is_gles, 0}) {
      if (!glc.is_gl3_or_gles3()) {
	glEnable(GL_POINT_SPRITE);
	sdllog("GL_POINT_SPRITE enabled");
      }
      glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
    }
    vbid_main = intern_vbid("vbid_main");
    vbid_main2 = intern_vbid("vbid_main2");
    vbid_particle = intern_vbid("vbid_particle");
    vbid_particle_bb = intern_vbid("vbid_particle_bb");
    vbid_font2 = intern_vbid("vbid_font2");
    vbid_lineparticle = intern_vbid("vbid_lineparticle");
    vbid_rect2d = intern_vbid("vbid_rect2d");
    prepare_instance_data_cb_add(*prepare_instance, vbid_main,
      make_funcptr{prepare_instance_data_main}());
    prepare_instance_data_cb_add(*prepare_instance, vbid_main2,
      make_funcptr{prepare_instance_data_main}());
    prepare_instance_data_cb_add(*prepare_instance, vbid_particle,
      make_funcptr{prepare_instance_data_particle}());
    prepare_instance_data_cb_add(*prepare_instance, vbid_particle_bb,
      make_funcptr{prepare_instance_data_default}());
    prepare_instance_data_cb_add(*prepare_instance, vbid_font2,
      make_funcptr{prepare_instance_data_font2}());
    prepare_instance_data_cb_add(*prepare_instance, vbid_lineparticle,
      make_funcptr{prepare_instance_data_lineparticle}());
    prepare_instance_data_cb_add(*prepare_instance, vbid_rect2d,
      make_funcptr{prepare_instance_data_rect2d}());
    set_vertex_buffer(vbid_main, make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{main_vertex_attributes}), false));
    set_vertex_buffer(vbid_main2, make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{main2_vertex_attributes}), false));
    set_vertex_buffer(vbid_particle, make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{particle_vertex_attr}), true));
    set_vertex_buffer(vbid_particle_bb, make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{particle_bb_vertex_attr}), false));
    set_vertex_buffer(vbid_font2, make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{font2_vertex_attributes}), true));
    set_vertex_buffer(vbid_lineparticle, make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{lineparticle_vertex_attributes}),
	false));
    set_vertex_buffer(vbid_rect2d, make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{rect2d_vertex_attributes}),
	false));
  }
  public function void prepare_vertex_buffers()
  {
    metafunction max_instance_data 2;
    const enable_copying_instancing = !glc.enable_instanced;
    for (const i, const& bo: vertex_buffers) {
      bo->create_vbo(enable_copying_instancing);
    }
  }
  public function void prepare_bo_instances(
      varray{instances_type} mutable& bo_instances) const
  {
    metafunction max_instance_data 2;
    const enable_copying_instancing = !glc.enable_instanced;
    bo_instances.resize(vertex_buffers.size(), instances_type());
    for (const i, const& bo: vertex_buffers) {
      mutable& instances = bo_instances[i];
      for (const j: 0 .. bo->vs_arr.size()) {
	instances.push_back(varray{instance_data}());
	mutable& e = instances[j];
	for (const k: 0 .. max_instance_data) {
	  e.push_back(instance_data());
	}
      }
    }
  }
  public function void prepare_node_factory(node_factory mutable& nf) const
  {
    for (size_t bo_id, const& bop: vertex_buffers) {
      for (const& n, const id: bop->vs_names) {
	joint_id_type jid;
	jid.bo_id = bo_id;
	jid.vs_id = static_cast{int}(id);
	nf.name_to_id[n] = jid;
      }
      nf.binfo.push_back(node_buffer_info());
      node_buffer_info mutable& nbi = nf.binfo[nf.binfo.size() - 1];
      for (const i, const& vsp: bop->vs_arr) {
	nbi.vs_arr.push_back(node_vs_info());
	node_vs_info mutable& nvi = nbi.vs_arr[nbi.vs_arr.size() - 1];
	for (const j, const& nj: vsp->vtxs->joints) {
	  node_joint_info nji;
	  nji.joint_id = find_joint_id_by_name(nj.joint_name);
	  nji.trans = nj.trans;
	  nvi.joints.push_back(nji);
	}
      }
    }
  }
  public function joint_id_type find_joint_id_by_name(cstrref const& name)
    const
  {
    joint_id_type scene_id;
    for (const i, const& bo: vertex_buffers) {
      if (bo->has_name(name)) {
        scene_id.bo_id = i;
        scene_id.vs_id = static_cast{int}(bo->get_id_by_name(name));
        break;
      }
    }
    return scene_id;
  }
  public function ptr{vertices} make_vertices(vertex_buffer_id bo_id,
    cstrref const& name)
  {
    return vertex_buffers[static_cast{size_t}(bo_id)]->get(name)->vtxs;
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    if (name == "main") {
      r.surface_w = mti.surface_w;
      r.surface_h = mti.surface_h;
    } else if (name == "font") {
      r.surface_w = fti.surface_w;
      r.surface_h = fti.surface_h;
      r.char_w = fti.char_w;
      r.char_h = fti.char_h;
    }
    return r;
  }
  public function void resize_screen(int width, int height)
  {
    cam.screen_width = width;
    cam.screen_height = height;
    if (m::ne{is_gles, 0}) {
      sfbo.sm_width = 1024;
      sfbo.sm_height = 1024;
    } else {
      sfbo.sm_width = width;
      sfbo.sm_height = height;
    }
    init_shadowmap_fbo(glc, sfbo);
    update_mvp(cam);
  }
}

public function varray{uint}
pglshader_draw_frame(pglshader mutable& pgs,
  varray{instances_type} mutable& bo_instances, projection_info const& cam_df)
{
  const& bos = pgs.vertex_buffers;
  /* prepare instance data */
  const sm_view = cam_df.light.to_mat4().inverse();
  const sm_vp = cam_df.sm_projection * sm_view;
  const tick1 = SDL_GetTicks();
  send_instance_data(bo_instances, pgs.global_ibuffer,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  const tick2 = SDL_GetTicks();
  /* shadowmapping shader */
  if (pgs.glc.enable_shadowmapping) {
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    /* set fb */
    glBindFramebuffer(GL_FRAMEBUFFER, pgs.sfbo.fbo.get());
    glViewport(0, 0, static_cast{GLsizei}(pgs.sfbo.sm_width),
      static_cast{GLsizei}(pgs.sfbo.sm_height));
    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthMask(1);
    if (pgs.glc.enable_depth_texture) {
      glColorMask(0, 0, 0, 0);
    } else {
      glColorMask(1, 1, 1, 1);
    }
    glDepthFunc(GL_LEQUAL);
    glDisable(GL_BLEND);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /* note: view_projection is pre-applied to model_matrix */
    /* sm */
    glUseProgram(pgs.smsdr->program);
    draw_instanced(*pgs.smsdr, *bos[static_cast{size_t}(pgs.vbid_main)],
      bo_instances[static_cast{size_t}(pgs.vbid_main)],
      pgs.global_ibuffer, pgs.vbid_main, 1, pgs.glc.enable_instanced,
      pgs.glc.enable_uniform_instancing);
    /* sm2 */
    glUseProgram(pgs.sm2sdr->program);
    draw_instanced(*pgs.sm2sdr, *bos[static_cast{size_t}(pgs.vbid_main2)],
      bo_instances[static_cast{size_t}(pgs.vbid_main2)],
      pgs.global_ibuffer, pgs.vbid_main2, 1, false, false);
    /* restore fb */
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
  glViewport(0, 0, static_cast{GLsizei}(pgs.cam.screen_width),
    static_cast{GLsizei}(pgs.cam.screen_height));
  /* z-prepass shader */
  if (pgs.glc.enable_zprepass) {
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glDepthMask(1);
    glDisable(GL_BLEND);
    glClear(GL_DEPTH_BUFFER_BIT);
    glColorMask(0, 0, 0, 0);
    mutable view = glm::mat4();
    view = cam_df.camera.to_mat4().inverse();
    const vp = cam_df.projection * view;
    /* zp */
    glUseProgram(pgs.zpsdr->program);
    glUniformMatrix4fv(pgs.zpsdr->u_view_projection_matrix, 1, 0,
      vp.to_crawptr());
    draw_instanced(*pgs.zpsdr, *bos[static_cast{size_t}(pgs.vbid_main)],
      bo_instances[static_cast{size_t}(pgs.vbid_main)],
      pgs.global_ibuffer, pgs.vbid_main, 0, pgs.glc.enable_instanced,
      pgs.glc.enable_uniform_instancing);
    /* zp2 */
    glUseProgram(pgs.zp2sdr->program);
    glUniformMatrix4fv(pgs.zp2sdr->u_view_projection_matrix, 1, 0,
      vp.to_crawptr());
    draw_instanced(*pgs.zp2sdr, *bos[static_cast{size_t}(pgs.vbid_main2)],
      bo_instances[static_cast{size_t}(pgs.vbid_main2)],
      pgs.global_ibuffer, pgs.vbid_main2, 0, false, false);
  }
  /* main or ds1 shader */
  if (true) {
    glDisable(GL_BLEND);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    if (pgs.glc.enable_zprepass) {
      glColorMask(1, 1, 1, 1);
      glDepthFunc(GL_EQUAL);
      glClear(GL_COLOR_BUFFER_BIT);
    } else {
      glDepthMask(1);
      glDepthFunc(GL_LESS);
      glColorMask(1, 1, 1, 1);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
    mutable view = glm::mat4();
    view = cam_df.camera.to_mat4().inverse();
    const vp = cam_df.projection * view;
    const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
    {
      /* main */
      glUseProgram(pgs.sdr->program);
      glUniform3fv(pgs.sdr->u_light_pos, 1,
	cam_df.light.position.to_crawptr());
      glUniform3fv(pgs.sdr->u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glUniform1i(pgs.sdr->u_sampler, 1);
      glUniform1i(pgs.sdr->u_sampler_tilemap, 2);
      glUniform1i(pgs.sdr->u_sampler_sm, 3);
      glUniform1f(pgs.sdr->u_light_on, 1.0f);
      glUniformMatrix4fv(pgs.sdr->u_shadowmap_vp, 1, 0, sm_vp.to_crawptr());
      glUniformMatrix4fv(pgs.sdr->u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      draw_instanced(*pgs.sdr, *bos[static_cast{size_t}(pgs.vbid_main)],
	bo_instances[static_cast{size_t}(pgs.vbid_main)],
	pgs.global_ibuffer, pgs.vbid_main, 0, pgs.glc.enable_instanced,
	pgs.glc.enable_uniform_instancing);
      /* main2 */
      glUseProgram(pgs.m2sdr->program);
      glUniform3fv(pgs.m2sdr->u_light_pos, 1,
	cam_df.light.position.to_crawptr());
      glUniform3fv(pgs.m2sdr->u_camera_pos, 1,
	cam_df.camera.position.to_crawptr());
      glUniform1i(pgs.m2sdr->u_sampler, 1);
      glUniform1i(pgs.m2sdr->u_sampler_tilemap, 2);
      glUniform1i(pgs.m2sdr->u_sampler_sm, 3);
      glUniform1f(pgs.m2sdr->u_light_on, 1.0f);
      glUniformMatrix4fv(pgs.m2sdr->u_shadowmap_vp, 1, 0, sm_vp.to_crawptr());
      glUniformMatrix4fv(pgs.m2sdr->u_view_projection_matrix, 1, 0,
	vp.to_crawptr());
      draw_instanced(*pgs.m2sdr, *bos[static_cast{size_t}(pgs.vbid_main2)],
	bo_instances[static_cast{size_t}(pgs.vbid_main2)],
	pgs.global_ibuffer, pgs.vbid_main2, 0, false, false);
    }
  }
  /* lineparticle */
  {
    // FIXME ??
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(1);
    /*
    */
    // glDisable(GL_DEPTH_TEST);
    // glEnable(GL_BLEND);
    glDisable(GL_BLEND);
    // glBlendFunc(GL_ONE, GL_ONE);
    mutable cam_mat = glm::mat4();
    cam_mat = cam_df.camera.to_mat4();
    const vp = cam_df.projection * (cam_mat.inverse());
    const screen_size_px = make_farray{float}(
      cast_float(cam_df.screen_width), cast_float(cam_df.screen_height));
    const screen_size_base = cast_float(
      max(cam_df.screen_width, cam_df.screen_height));
    glUseProgram(pgs.lpsdr->program);
    glUniformMatrix4fv(pgs.lpsdr->u_view_projection_matrix, 1, 0,
      vp.to_crawptr());
    glUniform2fv(pgs.lpsdr->u_screen_size_px, 1, screen_size_px.to_crawptr());
    glUniform1fv(pgs.lpsdr->u_screen_size_base, 1, caddress(screen_size_base));
    draw_instanced(*pgs.lpsdr, *bos[static_cast{size_t}(pgs.vbid_lineparticle)],
      bo_instances[static_cast{size_t}(pgs.vbid_lineparticle)],
      pgs.global_ibuffer, pgs.vbid_lineparticle, 0, pgs.glc.enable_instanced,
      pgs.glc.enable_uniform_instancing);
  }
  /* particles-bb */
  {
    glUseProgram(pgs.prtbsdr->program);
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    mutable cam_mat = glm::mat4();
    cam_mat = cam_df.camera.to_mat4();
    const vp = cam_df.projection * (cam_mat.inverse());
    glUniformMatrix4fv(pgs.prtbsdr->u_view_projection_matrix, 1, 0,
      vp.to_crawptr());
    glUniformMatrix3fv(pgs.prtbsdr->u_camera_matrix, 1, 0,
      cam_mat.to_3().to_crawptr());
    glUniform1f(pgs.prtbsdr->u_point_size_base, 0.1f);
    draw_instanced(*pgs.prtbsdr,
      *bos[static_cast{size_t}(pgs.vbid_particle_bb)],
      bo_instances[static_cast{size_t}(pgs.vbid_particle_bb)],
      pgs.global_ibuffer, pgs.vbid_particle_bb, 0,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  }
  /* particles */
  {
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    glUseProgram(pgs.spsdr->program);
    glUniform1f(pgs.spsdr->u_point_size_base,
      0.1f * static_cast{float}(max(
	cam_df.screen_width, cam_df.screen_height)));
    draw_instanced(*pgs.spsdr, *bos[static_cast{size_t}(pgs.vbid_particle)],
      bo_instances[static_cast{size_t}(pgs.vbid_particle)],
      pgs.global_ibuffer, pgs.vbid_particle, 0,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  }
  /* rect2d */
  {
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glUseProgram(pgs.rsdr->program);
    draw_instanced(*pgs.rsdr, *bos[static_cast{size_t}(pgs.vbid_rect2d)],
      bo_instances[static_cast{size_t}(pgs.vbid_rect2d)],
      pgs.global_ibuffer, pgs.vbid_rect2d, 0, pgs.glc.enable_instanced,
      pgs.glc.enable_uniform_instancing);
  }
  /* font */
  {
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    const screen_size_px = glm::make_vec2(
      static_cast{float}(cam_df.screen_width),
      static_cast{float}(cam_df.screen_height));
    glUseProgram(pgs.f2sdr->program);
    glUniform1i(pgs.f2sdr->u_sampler, 0);
    glUniform2fv(pgs.f2sdr->u_screen_size_px, 1, screen_size_px.to_crawptr());
    draw_instanced(*pgs.f2sdr, *bos[static_cast{size_t}(pgs.vbid_font2)],
      bo_instances[static_cast{size_t}(pgs.vbid_font2)],
      pgs.global_ibuffer, pgs.vbid_font2, 0, pgs.glc.enable_instanced,
      pgs.glc.enable_uniform_instancing);
  }
  finished_using_instance_data(pgs.global_ibuffer,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  return make_varray{uint}(tick1, tick2);
}

/* private */

valuetype struct
glconfig(bool is_gles0, int major0, int minor0, bool msaa0)
{
  public bool const is_gles = is_gles0;
  public int const major = major0;
  public int const minor = minor0;
  public bool enable_shadowmapping = true;
  public bool enable_shadowmapping_multisample = false;
  public bool enable_normalmapping = true;
  public bool enable_zprepass = !is_gles;
  public bool enable_msaa = msaa0;
  public bool enable_instanced = major >= 3 && use_copying_instancing == 0;
  public bool enable_uniform_instancing = enable_instanced &&
    (major < 3 || is_gles || (!is_gles && minor < 3));
  public bool enable_depth_texture = (major >= 3);
  public bool enable_sampler2dshadow = enable_depth_texture && !is_gles;
  public function bool is_gl3_or_gles3() const { return major >= 3; }
  public function bool is_gl33_or_gles3() const {
    return major >= 3 && (is_gles || minor >= 3); }
  public function strlit prepend() const {
    if (is_gles) {
      if (is_gl3_or_gles3()) {
	return "#version 300 es\nprecision highp float;\n";
      } else {
	return "precision highp float;\n";
      }
    } else {
      if (is_gl3_or_gles3()) {
	return "#version 150\n";
      } else {
	return "#version 120\n";
      }
    }
  }
  public function strlit vert_in() const {
    return is_gl3_or_gles3() ? "in " : "attribute "; }
  public function strlit vert_out() const {
    return is_gl3_or_gles3() ? "out " : "varying "; }
  public function strlit frag_in() const {
    return is_gl3_or_gles3() ? "in " : "varying "; }
  public function strlit texture2d() const {
    return is_gl3_or_gles3() ? "texture" : "texture2D"; }
  public function strlit shadow2d() const {
    return is_gl3_or_gles3() ? "texture" : "shadow2D"; }
  public function strlit fragcolor() const {
    return is_gl3_or_gles3() ? "fragcolor" : "gl_FragColor"; }
  public function strlit decl_fragcolor() const {
    return is_gl3_or_gles3() ? "out vec4 fragcolor;\n" : "\n"; }
  public function string decl_instance_id(bool shader_has_iid) const
  {
    if (use_copying_instancing != 0 && shader_has_iid) {
      return vert_in() + "float instance_id;\n";
    } else {
      return "";
    }
  }
  public function string decl_instance_attr(cstrref const& t, cstrref const& n,
      bool shader_support_instancing, bool shader_has_iid) const
  {
    if (use_copying_instancing != 0 && shader_has_iid) {
      /* shader has 'instance_id' variable */
      return "uniform " + t + " " + n + "["
	+ m::to_string{uniform_instancing_mul} + "];\n";
    } else {
      if (shader_support_instancing && enable_instanced) {
	if (enable_uniform_instancing) {
	  /* use gl_InstanceID and uniform arrays */
	  return "uniform " + t + " " + n + "["
	    + m::to_string{uniform_instancing_mul} + "];\n";
	} else {
	  /* use gl_InstanceID and glVertexAttribDivisor */
	  return vert_in() + t + " " + n + ";\n";
	}
      } else {
	return "uniform " + t + " " + n + ";\n";
      }
    }
  }
  public function string instance_attr(cstrref const& n,
    bool shader_support_instancing, bool shader_has_iid) const
  {
    if (use_copying_instancing != 0 && shader_has_iid) {
      /* shader has 'instance_id' variable */
      return n + "[int(instance_id)]";
    } else {
      if (shader_support_instancing && enable_instanced &&
	enable_uniform_instancing) {
	/* use gl_InstanceID and uniform arrays */
	return n + "[gl_InstanceID]";
      } else {
	/* use gl_InstanceID and glVertexAttribDivisor */
	/* or no instancing */
	return n;
      }
    }
  }
  public function string empty_shader_vert() const {
    return prepend() +
      "void main(void) { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); }\n"; }
  public function string empty_shader_frag() const {
    return prepend() + "void main(void) { }\n"; }
}

metafunction main_shader_ptr{instancing}
  ptr{glshader{
    main_uniforms, main_instance_attributes,
    m::cond{instancing, main_vertex_attributes, main2_vertex_attributes}}};
metafunction shadowmap_shader_ptr{instancing}
  ptr{glshader{
    shadowmap_uniforms, main_instance_attributes,
    m::cond{instancing,
      shadowmap_vertex_attributes, shadowmap2_vertex_attributes}}};
metafunction zprepass_shader_ptr{instancing}
  ptr{glshader{
    zprepass_uniforms, main_instance_attributes,
    m::cond{instancing,
      zprepass_vertex_attributes, zprepass2_vertex_attributes}}};
metafunction font2_shader_ptr
  ptr{glshader{
    font2_uniforms, font2_instance_attributes, font2_vertex_attributes}};
metafunction rect2d_shader_ptr
  ptr{glshader{
    rect2d_uniforms, rect2d_instance_attributes, rect2d_vertex_attributes}};
metafunction particle_shader_ptr
  ptr{glshader{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}};
metafunction particle_bb_shader_ptr
  ptr{glshader{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}};
metafunction lineparticle_shader_ptr
  ptr{glshader{lineparticle_uniforms, lineparticle_instance_attributes,
    lineparticle_vertex_attributes}};

threaded struct main_texture_info
{
  public uint surface_w;
  public uint surface_h;
  public auto_texture main_texture_id;
  public auto_texture tilemap_texture_id;
}

threaded struct font_texture_info
{
  public varray{uint} char_x;
  public uint char_w;
  public uint char_h;
  public uint surface_w;
  public uint surface_h;
  public auto_texture font_texture_id;
}

private function void
send_instance_data(varray{instances_type} mutable& ibs,
  instance_buffer_type mutable& gibuf, bool enable_instanced,
  bool enable_uniform_instancing)
{
  if (enable_instanced && !enable_uniform_instancing) {
    size_t offset_float = 0;
    for (const bo_id, mutable& ib: ibs) {
      for (const vs_id, mutable& vs: ib) {
	for (const i, mutable& inst: vs) {
	  mutable& arr = inst.instance_buffer;
	  inst.glbuffer_offset_float = offset_float;
	  offset_float += arr.size();
	}
      }
    }
    if (offset_float != 0) {
      mutable& cur_buf = *gibuf.get_current();
      const size_t total_size_float = offset_float;
      offset_float = 0;
      cur_buf.client_wait_sync(1000000000 * 10);
      cur_buf.map_buffer(total_size_float * 4U);
      const rawptr{float} mapped_ptr = cur_buf.mapped_ptr;
      //sdllog("mapped_ptr", mapped_ptr, total_size_float * 4U);
      for (const bo_id, mutable& ib: ibs) {
	for (const vs_id, mutable& vs: ib) {
	  for (const i, mutable& inst: vs) {
	    mutable& arr = inst.instance_buffer;
	    // if (bo_id == 3) { sdllog("font2 instance", arr); }
	    const size_t sz = arr.size();
	    const sli = rawptr_to_slice{float}(mapped_ptr + offset_float, sz);
	    for (const j: 0 .. sz) {
	      sli[j] = arr[j];
	    }
	    offset_float += sz;
	  }
	}
      }
      cur_buf.unmap_buffer();
    }
  }
}


private function void
finished_using_instance_data(instance_buffer_type mutable& gibuf,
  bool enable_instanced, bool enable_uniform_instancing)
{
  if (enable_instanced && !enable_uniform_instancing) {
    gibuf.get_current()->fence_sync();
    gibuf.switch_buffer();
  }
}

private function void
draw_instanced(glshader_i mutable& sdr, vertex_buffer const& bo,
  instances_type const& ibs,
  instance_buffer_type const& gibuf, vertex_buffer_id bo_id,
  size_t ibuf_id, bool enable_instanced, bool enable_uniform_instancing)
{
  bo.draw_pre(sdr);
  if (enable_instanced && !enable_uniform_instancing) {
    sdr.enable_instance_attrib_array(true);
    glBindBuffer(GL_ARRAY_BUFFER, gibuf.get_current()->vbo.get());
  }
  for (const vs_id: 0 .. bo.num_vs()) {
    const& instance = ibs[static_cast{size_t}(vs_id)][ibuf_id];
    const& arr = instance.instance_buffer;
    // sdllog("draw_elems", ji.bo_id, ji.vs_id, "model=", arr.size());
    if (enable_instanced && !enable_uniform_instancing) {
      if (m::ne{is_gl3_or_gles3, 0}) {
	/*
	sdllog("instancing bo", bo_id, "iattr_num_float",
	  sdr.instance_attrib_num_float());
	*/
	sdr.instance_attrib_pointer(instance.glbuffer_offset_float);
	bo.draw_elems_instanced(static_cast{size_t}(vs_id),
	  arr.size() / sdr.instance_attrib_num_float());
      }
    } else if (enable_uniform_instancing) {
      size_t const iattr_num_float = sdr.instance_attrib_num_float();
      size_t j;
      size_t const jmax = arr.size() / iattr_num_float;
      /*
      sdllog("uniforminstancing bo", bo_id, "iattr_num_float",
	iattr_num_float, jmax);
      */
      for (j = 0; j < jmax; j += uniform_instancing_mul) {
	size_t k = min((jmax - j), uniform_instancing_mul);
	sdr.instance_attrib_set_uniform(arr, j * iattr_num_float, k);
	bo.draw_elems_instanced(static_cast{size_t}(vs_id), k);
      }
      /*
      size_t const jmax = arr.size();
      sdllog("uniforminstancing bo", bo_id, "iattr_num_float",
	iattr_num_float, jmax);
      for (j = 0; j < jmax; j += iattr_num_float * uniform_instancing_mul) {
	size_t k = min((jmax - j) / iattr_num_float, uniform_instancing_mul);
	sdr.instance_attrib_set_uniform(arr, j, k);
	bo.draw_elems_instanced(static_cast{size_t}(vs_id), k);
      }
      */
    } else { /* copying instancing */
      size_t const iattr_num_float = sdr.instance_attrib_num_float();
      size_t j;
      const& be = *bo.get_by_id(static_cast{size_t}(vs_id));
      size_t const jmax = arr.size() / iattr_num_float;
      const inst_mul = be.vtxs->num_copies;
      /*
      sdllog("copyinginstancing bo", bo_id, "iattr_num_float",
	iattr_num_float, jmax);
      */
      for (j = 0; j < jmax; j += inst_mul) {
	size_t k = min((jmax - j), inst_mul);
	sdr.instance_attrib_set_uniform(arr, j * iattr_num_float, k);
	bo.draw_elems(static_cast{size_t}(vs_id), k);
      }
      /*
      size_t const jmax = arr.size();
      const inst_mul = be.vtxs->num_copies;
      sdllog("copyinginstancing bo", bo_id, "iattr_num_float",
	iattr_num_float, jmax);
      for (j = 0; j < jmax; j += iattr_num_float * inst_mul) {
	size_t k = min((jmax - j) / iattr_num_float, inst_mul);
	sdr.instance_attrib_set_uniform(arr, j, k);
	bo.draw_elems(static_cast{size_t}(vs_id), k);
      }
      */
    }
  }
  if (enable_instanced && !enable_uniform_instancing) {
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    sdr.enable_instance_attrib_array(false);
  }
  bo.draw_post(sdr);
}

function void update_mvp(projection_info mutable& cam)
{
  float const perspective_distance = 1.0;
  float const distance_max = 1000.0;
  const ssbase = max(cam.screen_height, cam.screen_width);
  const h = cast_float(cam.screen_height) / cast_float(ssbase);
  const w = cast_float(cam.screen_width) / cast_float(ssbase);
  glViewport(0, 0, static_cast{GLsizei}(cam.screen_width),
    static_cast{GLsizei}(cam.screen_height));
  glDepthMask(1);
  glColorMask(1, 1, 1, 1);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  const d = cast_float(perspective_distance);
  {
    const near = cast_float(d);
    const far = cast_float(d + distance_max);
    const left = cast_float(-w);
    const right = cast_float(w);
    const bottom = cast_float(-h);
    const top = cast_float(h);
    cam.projection = glm::frustum{float}(left, right, bottom, top, near, far);
  }
  {
    const sm_w = max(1.0, w);
    const sm_h = max(1.0, h);
    const near = cast_float(d);
    const far = cast_float(d + distance_max);
    const left = cast_float(-sm_w);
    const right = cast_float(sm_w);
    const bottom = cast_float(-sm_h);
    const top = cast_float(sm_h);
    cam.sm_projection = glm::frustum{float}(left, right, bottom, top, near,
      far);
  }
}

threaded function {t} t power_of_2(t v)
{
  mutable t r = static_cast{t}(1);
  while (r != 0 && r < v) { r <<= 1; }
  return r;
}

struct shadowmap_fbo
{
  public auto_framebuffer fbo;
  public auto_texture sm_texture;
  public int sm_width;
  public int sm_height;
  public auto_renderbuffer depthbuf;
}

function void init_shadowmap_fbo(glconfig const& glc,
  shadowmap_fbo mutable& sfbo)
{
  if (glc.enable_shadowmapping) {
    sdllog("shadowmap size", sfbo.sm_width, sfbo.sm_height);
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    /* texture */
    glActiveTexture(GL_TEXTURE3);
    sfbo.sm_texture.generate();
    glBindTexture(GL_TEXTURE_2D, sfbo.sm_texture.get());
    if (glc.enable_depth_texture) {
      sdllog("depth_texture");
      const f = glc.enable_sampler2dshadow ? GL_LINEAR : GL_NEAREST;
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, cast_int(f));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, cast_int(f));
      if (m::ne{is_gl3_or_gles3, 0}) {
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE,
	  cast_int(GL_COMPARE_REF_TO_TEXTURE));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC,
	  cast_int(GL_LEQUAL));
      }
      if (!glc.is_gles) {
	sdllog("depth_texture byte");
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT),
	  sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	  GL_UNSIGNED_BYTE, offset_to_void_cp(0));
      } else {
	if (glc.is_gl3_or_gles3()) {
	  /* ios gles3: COMPONENT16, UNSIGNED_INT */
	  sdllog("depth_texture int");
	  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT16),
	    sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	    GL_UNSIGNED_INT, offset_to_void_cp(0));
	} else {
	  /* ios gles2: COMPONENT, UNSIGNED_SHORT */
	  sdllog("depth_texture short");
	  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT),
	    sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	    GL_UNSIGNED_SHORT, offset_to_void_cp(0));
	}
      }
      sdllog("depth_texture done");
    } else {
      sdllog("no depth_texture");
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
	cast_int(GL_NEAREST));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
	cast_int(GL_NEAREST));
      sdllog("no depth_texture rbga byte");
      glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA), sfbo.sm_width,
	sfbo.sm_height, 0, GL_RGBA, GL_UNSIGNED_BYTE,
	offset_to_void_cp(0));
    }
    if (m::eq{is_gles, 0}) {
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
	cast_int(GL_CLAMP_TO_EDGE));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
	cast_int(GL_CLAMP_TO_EDGE));
    }
    /* framebuffer */
    sfbo.fbo.generate();
    glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
    if (glc.enable_depth_texture) {
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
    } else {
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
	GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
    }
    /* renderbuffer */
    if (glc.enable_depth_texture) {
      if (m::eq{is_gles, 0}) {
	glDrawBuffer(GL_NONE);
	glReadBuffer(GL_NONE);
      }
    } else {
      int orig_rb;
      glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
      /*
      sdllog("orig_rb", orig_rb);
      */
      sfbo.depthbuf.generate();
      glBindRenderbuffer(GL_RENDERBUFFER, sfbo.depthbuf.get());
      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16,
	sfbo.sm_width, sfbo.sm_height);
      glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	GL_RENDERBUFFER, sfbo.depthbuf.get());
      glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));
    }
    const e = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (e != GL_FRAMEBUFFER_COMPLETE) {
      sdllog("incomplete framebuffer", cast_int(e));
    } else {
      sdllog("complete framebuffer");
    }
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
}

function {instancing} shadowmap_shader_ptr{instancing}
init_shadowmap_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  /* note: passes mvp as model_matrix */
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", instancing != 0, true);
  v += g.vert_in() + "vec3 position;\n";
  if (!g.enable_depth_texture) {
    v += g.vert_out() + "vec4 vary_smpos;\n";
  }
  v += "void main(void) {\n";
  v += "vec4 p = " + g.instance_attr("model_matrix", instancing != 0, true);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_Position = p;\n";
  if (!g.enable_depth_texture) {
    v += "vary_smpos = p;\n";
  }
  v += "}\n";
  string f;
  if (g.enable_depth_texture) {
    f += g.empty_shader_frag();
  } else {
    f += g.prepend();
    f += g.frag_in() + "vec4 vary_smpos;\n";
    f += g.decl_fragcolor();
    f += "void main(void) {\n";
    f += "vec4 p = vary_smpos;\n";
    f += "  float pz = (p.z/p.w + 1.0) / 2.0;\n";
    f += "  float z = pz * 256.0;\n";/* [0.0, 256.0] */
    f += "  float z0 = floor(z);\n"; /* [0, 256] */
    f += "  z = (z - z0) * 256.0;\n"; /* [0.0, 256.0) */
    f += "  float z1 = floor(z);\n"; /* [0, 256) */
    f += "  z = (z - z1) * 256.0;\n"; /* [0.0, 256.0) */
    f += "  float z2 = floor(z);\n";  /* [0, 256) */
    f += g.fragcolor() + "= vec4(z0/255.0, z1/255.0, z2/255.0, 1.0);\n";
    f += "}\n";
  }
  return make_glshader_ptr{
    shadowmap_uniforms,
    main_instance_attributes,
    m::cond{instancing,
      shadowmap_vertex_attributes,
      shadowmap2_vertex_attributes}
  }(v, f, "model_matrix");
}

function {instancing} zprepass_shader_ptr{instancing}
init_zprepass_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", instancing != 0, true);
  v += g.vert_in() + "vec3 position;\n";
  v += "void main(void) {\n";
  v += "vec4 gpos4 = " + g.instance_attr("model_matrix", instancing != 0, true);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_Position = view_projection_matrix * gpos4;\n";
  v += "}\n";
  string f = g.empty_shader_frag();
  return make_glshader_ptr{
    zprepass_uniforms,
    main_instance_attributes,
    m::cond{instancing,
      zprepass_vertex_attributes,
      zprepass2_vertex_attributes}
  }(v, f, "model_matrix");
}

function string
main_or_ds1st_shader_vert(glconfig const& g, bool instancing)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat4 shadowmap_vp;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", instancing, true);
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec3 normal;\n";
  v += g.vert_in() + "vec3 tangent;\n";
  v += g.vert_in() + "vec3 uvw;\n";
  v += g.vert_out() + "vec3 vary_position;\n";
  v += g.vert_out() + "vec3 vary_normal;\n";
  v += g.vert_out() + "vec3 vary_tangent;\n";
  v += g.vert_out() + "vec3 vary_uvw;\n";
  v += g.vert_out() + "vec3 vary_binormal;\n";
  if (g.enable_shadowmapping) {
    v += g.vert_out() + "vec4 vary_smpos;\n";
  }
  v += "void main(void) {\n";
  v += "  vec4 gpos4 = " + g.instance_attr("model_matrix", instancing, true);
  v += "    * vec4(position, 1.0);\n";
  v += "  gl_Position = view_projection_matrix * gpos4;\n";
  if (g.is_gl3_or_gles3()) {
    v += "  mat3 normal_matrix = mat3("
      + g.instance_attr("model_matrix", instancing, true)
      + ");\n";
  } else {
    v += "  mat4 mm = "
      + g.instance_attr("model_matrix", instancing, true)
      + ";\n";
    v += "  mat3 normal_matrix = mat3(mm[0].xyz, mm[1].xyz, mm[2].xyz);\n";
  }
  v += "  vary_position = gpos4.xyz / gpos4.w;\n";
  v += "  vary_normal = normal_matrix * normal;\n";
  v += "  vary_tangent = normal_matrix * tangent;\n";
  v += "  vary_uvw = uvw;\n";
  v += "  vary_binormal = cross(vary_normal, vary_tangent);\n";
  if (g.enable_shadowmapping) {
    v += "  vary_smpos = shadowmap_vp * gpos4;\n";
  }
  v += "}\n";
  return v;
}

function string main_or_ds2nd_shader_frag(glconfig const& g, bool instancing)
{
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += "uniform sampler2D sampler_tilemap;\n";
  if (g.enable_sampler2dshadow) {
    f += "uniform sampler2DShadow sampler_sm;\n";
  } else {
    f += "uniform sampler2D sampler_sm;\n";
  }
  f += "uniform vec3 camera_pos;\n";
  f += "uniform vec3 light_pos;\n";
  f += "uniform float light_on;\n";
  f += "uniform mat4 shadowmap_vp;\n";
  f += g.frag_in() + "vec3 vary_position;\n";
  f += g.frag_in() + "vec3 vary_normal;\n";
  f += g.frag_in() + "vec3 vary_tangent;\n";
  f += g.frag_in() + "vec3 vary_uvw;\n";
  f += g.frag_in() + "vec3 vary_binormal;\n";
  if (g.enable_shadowmapping) {
    f += g.frag_in() + "vec4 vary_smpos;\n";
  }
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec3 light_dir = normalize(light_pos - vary_position);\n";
  f += "float light_distance = length(light_pos - vary_position);\n";
  f += "vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n";
  if (instancing) {
    f += "vec4 color_dif = vec4(0.42, 0.42, 0.42, 1.0);\n";
  } else {
    f += "vec4 color_dif = vec4(0.43, 0.42, 0.44, 1.0);\n";
  }
  f += "float mate_ambient = 0.2;\n";
  f += "float mate_specular = 0.5;\n";
  if (g.enable_shadowmapping) {
    f += "vec4 smp = vary_smpos;\n";
    f += "vec3 smpos = ((smp.xyz / smp.w) + 1.0) * 0.5;\n";
    f += "float lflag = float(int(smpos.x <= 0.0) + int(smpos.x >= 1.0)";
    f += "  + int(smpos.y <= 0.0) + int(smpos.y >= 1.0) == 0);\n";
  } else {
    f += "float lflag = 1.0;\n";
  }
  f += "float lstr = lflag;\n";
  /*
  f += "float distbr = min(3000.0 / (light_distance * light_distance), ";
  f += "  light_on);\n";
  */
  f += "float distbr = min(100.0 / light_distance , light_on);\n";
  f += "vec3 nor = vary_normal;\n";
  if (g.enable_normalmapping) {
    f += "const float tile_size = 32.0;\n";
    f += "const float tilemap_size = 128.0;\n";
    f += "const float tiletex_size = 256.0;\n";
    f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
    f += "vec2 uv_tm = floor(uv0);\n";
	  /* tilemap coordinate */
    f += "vec2 uv_tmfr = uv0 - uv_tm;\n";
	  /* coordinate inside a tile (0, 1) */
    f += "vec2 uv_ti = uv_tmfr * tile_size;\n";
    f += "vec2 uvi = floor(uv_ti);\n";
	  /* coordinate inside a tile, integral */
    f += "vec2 uvj = uv_ti - uvi;\n";
	  /* subpixel coordinate */
    f += "vec4 ti = " +  g.texture2d();
    f += "  (sampler_tilemap, uv_tm / tilemap_size);\n";
	  /* lookup the tilemap */
    f += "vec2 uv_pixel = floor(ti.xy * 255.0 + 0.5) * tile_size + uvi;\n";
	  /* tile pattern coordinate */
    f += "mate_ambient = ti.z;\n";
    f += "mate_specular = ti.w;\n";
    f += "vec4 c0 = " + g.texture2d();
    f += "  (sampler, uv_pixel / tiletex_size);\n";
	  /* lookup the tilepattern */
    f += "float alv0 = floor(c0.a * 255.0 + 0.5);\n";
    f += "float avol = floor(alv0 / 16.0);\n";
    f += "int alv = int(alv0 - avol * 16.0 + 0.5);\n";
    f += "float lt = float(uvj.y - uvj.x >= 0.0);\n";
    f += "float lb = float(uvj.y + uvj.x <= 1.0);\n";
    f += "vec4 avlv = vec4(float(alv == 1), float(alv == 3), ";
    f += "  float(alv == 5), float(alv == 7));\n";
    f += "float ut1 = dot(avlv, vec4(-lt, 1.0-lb, 1.0-lt, -lb));\n";
    f += "float vt1 = dot(avlv, vec4(lt-1.0, -lb, lt, 1.0-lb));\n";
    f += "ut1 += float(alv == 4);\n";
    f += "vt1 -= float(alv == 2);\n";
    f += "avol = (avol - 8.0) * distbr * 0.2;\n";
    f += "color += vec4(c0.xyz, 0.0) * float(alv == 10);\n";
    // f += "color_dif = vec4(c0.xyz, 0.0) * float(alv != 10);\n";
    f += "distbr *= float(alv != 10);\n";
    f += "nor += vary_tangent * ut1 * avol;\n";
    f += "nor += vary_binormal * vt1 * avol;\n";
    f += "nor = normalize(nor);\n";
  }
  f += "vec3 reflection_vec = reflect(-light_dir, nor);\n";
  f += "vec3 camera_dir = normalize(camera_pos - vary_position);\n";
  f += "float cos_angle = max(0.0, dot(camera_dir, reflection_vec));\n";
  f += "float specular = pow(cos_angle, 16.0);\n";
  f += "float diffuse = clamp(dot(light_dir, nor), 0.0, 1.0);\n";
  if (g.enable_shadowmapping) {
    if (g.enable_depth_texture) {
      if (g.enable_sampler2dshadow) {
	f += "smpos.z *= 0.9995;\n";
	if (g.enable_shadowmapping_multisample) {
	  f += "lstr = (";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(-0.0003,-0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(-0.0003,0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(0.0003,-0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(0.0003,0.0003,0.0)))";
	  if (!g.is_gl3_or_gles3()) {
	    f += ".r";
	  }
	  f += "  / 4.0;\n";
	} else {
	  f += "lstr = " + g.shadow2d() + "(sampler_sm, smpos)";
	  if (!g.is_gl3_or_gles3()) {
	    f += ".r";
	  }
	  f += ";\n";
	}
      } else {
	f += "float zval = " + g.texture2d();
	f += "   (sampler_sm, smpos.xy * lflag).x;\n";
	f += "lstr = float(smpos.z < zval * 1.0005) * lflag;\n";
      }
    } else {
      f += "vec4 smz = " + g.texture2d();
      f += "  (sampler_sm, smpos.xy * lflag);\n";
      f += "float z0 = floor(smz.r * 255.0 + 0.5);\n";
      f += "float z1 = floor(smz.g * 255.0 + 0.5);\n";
      f += "float z2 = floor(smz.b * 255.0 + 0.5);\n";
      f += "float zval = z0 * 65536.0 + z1 * 256.0 + z2;\n";
      f += "lstr = float(smpos.z * 16770000.0 < zval) * lflag;\n";
    }
    f += "color += vec4(1.0, 1.0, 1.0, 1.0)";
    f += "  * (mate_specular * specular * distbr * distbr * lstr);\n";
  }
  f += g.fragcolor() +  " = color + ";
  f += "  (color_dif * (diffuse * distbr * lstr + mate_ambient));\n";
  f += "}\n";
  return f;
}

function {instancing} main_shader_ptr{instancing}
init_main_shader(glconfig const& g)
{
  const v = main_or_ds1st_shader_vert(g, instancing != 0);
  const f = main_or_ds2nd_shader_frag(g, instancing != 0);
//sdllog("main_shader", v);
  return
    make_glshader_ptr{
      main_uniforms,
      main_instance_attributes,
      m::cond{instancing, main_vertex_attributes, main2_vertex_attributes}
    }(v, f, "model_matrix");
}

function particle_shader_ptr
init_particle_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_id(false);
  v += g.decl_instance_attr("mat4", "model_matrix", true, false);
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += "void main(void) {\n";
  v += "gl_Position = " + g.instance_attr("model_matrix", true, false);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_PointSize = point_size_base / gl_Position.w;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord * 2.0 - 1.0;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}(v, f, "model_matrix");
}

function particle_bb_shader_ptr
init_particle_bb_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_id(false);
  v += g.decl_instance_attr("mat4", "model_matrix", true, false);
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat3 camera_matrix;\n";
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec2 local_position;\n";
  v += g.vert_out() + "vec2 point_coord;\n";
  v += "void main(void) {\n";
  v += "vec4 pos = " + g.instance_attr("model_matrix", true, false);
  v += "  * vec4(position, 1.0);\n";
  v += "vec3 posb = camera_matrix";
  v += "  * vec3(local_position * point_size_base, 0.0);\n";
  v += "gl_Position = view_projection_matrix * vec4(pos.xyz + posb, 1.0);\n";
  v += "point_coord = local_position;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec2 point_coord;\n";
  f += "void main(void) {\n";
  f += "vec2 xy = point_coord;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}(v, f, "model_matrix");
}

function lineparticle_shader_ptr
init_lineparticle_shader(glconfig const& g)
{
  const has_inst = true;
  string v;
  v += g.prepend();
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat3", "idata", true, has_inst);
  /*
  v += g.decl_instance_attr("vec3", "position0", true, has_inst);
  v += g.decl_instance_attr("vec3", "position1", true, has_inst);
  v += g.decl_instance_attr("float", "point_size_base", true, has_inst);
  */
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform vec2 screen_size_px;\n";
  v += "uniform float screen_size_base;\n";
  v += g.vert_in() + "vec2 vert;\n";
  v += g.vert_out() + "vec3 vary_coord;\n";
  v += g.vert_out() + "vec2 edge;\n";
  v += "void main(void) {\n";
  v += "vec4 p0p = view_projection_matrix * vec4("
    + g.instance_attr("idata", true, has_inst) + "[0], 1.0);\n";
  v += "vec4 p1p = view_projection_matrix * vec4("
    + g.instance_attr("idata", true, has_inst) + "[1], 1.0);\n";
  v += "float pz0 = p0p.z / p0p.w;\n";
  v += "float pz1 = p1p.z / p1p.w;\n";
  v += "float pz = (pz0 + pz1) * 0.5;\n";
  v += "vec2 p0 = p0p.xy * screen_size_px / p0p.w;\n";
  v += "vec2 p1 = p1p.xy * screen_size_px / p1p.w;\n";
  v += "float is_posi = min(float(p0p.w > 0.0), float(p1p.w > 0.0));\n"; 
  v += "vec2 pvec = p1 - p0;\n"; // FIXME: must be non-zero
  v += "float plen = length(pvec);\n";
  v += "vec2 r = screen_size_base * "
    + g.instance_attr("idata", true, has_inst) + "[2].x"
    + " / vec2(p0p.w, p1p.w);\n";
  v += "float rmx = max(r[0], r[1]);\n";
  // v += "r = max(r, rmx - plen * 0.0625);\n";
  v += "r = max(r, rmx - plen * 0.5);\n";
  v += "float rp = r[0] + (r[1] - r[0]) * vert.x;\n";
  v += "vec2 qvec = normalize(vec2(-pvec.y, pvec.x)) * rp;\n";
  v += "float x_extend_0 = (vert.x - 1.0) * r[0] * 0.5 / plen;\n";
  v += "float x_extend_1 = vert.x * r[1] * 0.5 / plen;\n";
  v += "vec2 vert_ex = vec2(vert.x + x_extend_0 + x_extend_1, vert.y);\n";
  v += "vec2 vpos = p0 + mat2(pvec, qvec) * vert_ex;\n";
  v += "gl_Position = vec4(vpos * is_posi / screen_size_px, pz, 1.0);\n";
  v += "vec2 c = vec2(vert.x - 0.5, vert.y) * 2.0;\n";
  v += "float rrat = r[1] / r[0];\n";
  v += "float rrat_v = 1.0 + (rrat - 1.0) * vert.x;\n";
  v += "vary_coord = vec3(c, 1.0) * rrat_v;\n";
  v += "float edge_rat = clamp(max(r[0], r[1]) / plen, 0.125, 1.0);\n";
  v += "edge = vec2(1.0 - edge_rat, 1.0 / edge_rat);\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec3 vary_coord;\n";
  f += g.frag_in() + "vec2 edge;\n";
  f += "void main(void) {\n";
  f += "vec2 c = vary_coord.xy / vary_coord.z;\n";
  f += "c.x = max(abs(c.x) - edge.x, 0.0) * edge.y;\n";
  f += "float a = 1.0 - length(c);\n";
  f += "if (a < 0.25) { discard; };\n";
  f += g.fragcolor() + " = vec4(a * 2.0, a * 2.0, a * 4.0, 1.0);\n";
  // f += g.fragcolor() + " = vec4(1.0, 1.0, 0.0, 1.0);\n";
  f += "}\n";
  return make_glshader_ptr{lineparticle_uniforms,
    lineparticle_instance_attributes, lineparticle_vertex_attributes}
    (v, f, "");
}

function font2_shader_ptr
init_font2_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += "uniform vec2 screen_size_px;\n";
  v += g.vert_in() + "vec2 texture_size_px;\n";
  v += g.vert_in() + "vec2 texture_origin_px;\n";
  v += g.vert_in() + "vec2 char_size_px;\n";
  v += g.vert_in() + "vec2 coord_clamp;\n";
  v += g.vert_in() + "float char_point_size;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("vec4", "idata", true, true);
  v += g.vert_out() + "vec2 vary_texture_size_px;\n";
  v += g.vert_out() + "vec2 vary_texture_origin_px;\n";
  v += g.vert_out() + "vec2 vary_char_size_px;\n";
  v += g.vert_out() + "vec2 vary_coord_clamp;\n";
  v += g.vert_out() + "float vary_point_size;\n";
  v += "void main(void) {\n";
  v += "vec4 idata_i = " + g.instance_attr("idata", true, true) + ";\n";
  v += "float ch = idata_i.x;\n";
  v += "vec2 screen_pos = idata_i.zw;\n";
  v += "vec2 screen_px = ";
  v += "  floor((screen_pos + 1.0) * screen_size_px * 0.5 + 0.5);\n";
  v += "screen_px += char_point_size * 0.5;\n";
  v += "screen_pos = screen_px / screen_size_px * 2.0 - 1.0;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "gl_PointSize = char_point_size;\n";
  v += "vary_texture_size_px = texture_size_px;\n";
  v += "vary_texture_origin_px = texture_origin_px";
  v += "  + vec2(char_size_px.x * ch, 0.0);\n";
  v += "vary_char_size_px = char_size_px;\n";
  v += "vary_coord_clamp = coord_clamp;\n";
  v += "vary_point_size = char_point_size;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += g.frag_in() + "vec2 vary_texture_size_px;\n";
  f += g.frag_in() + "vec2 vary_texture_origin_px;\n";
  f += g.frag_in() + "vec2 vary_char_size_px;\n";
  f += g.frag_in() + "vec2 vary_coord_clamp;\n";
  f += g.frag_in() + "float vary_point_size;\n";
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord;\n";
  f += "if (xy.x > vary_coord_clamp.x) { discard; }\n";
  f += "vec2 pcoord = vary_point_size * xy;\n";
  f += "vec2 texcoord = (vary_texture_origin_px + pcoord)";
  f += "  / vary_texture_size_px;\n";
  f += "vec4 col = " +  g.texture2d() + "(sampler, texcoord);\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 0.0, col.a);\n";
  f += "}\n";
  return make_glshader_ptr{font2_uniforms, font2_instance_attributes,
    font2_vertex_attributes}(v, f, "idata");
}

function rect2d_shader_ptr
init_rect2d_shader(glconfig const& g)
{
  string v;
  string f;
  v += g.prepend();
  v += g.vert_in() + "vec2 vert;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("vec4", "idata", true, true);
  v += "void main(void) {\n";
  v += "vec4 idata_i = " + g.instance_attr("idata", true, true) + ";\n";
  v += "vec2 screen_pos = idata_i.xy + idata_i.zw * vert;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "}\n";
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 1.0, 0.3);\n";
  f += "}\n";
  return make_glshader_ptr{rect2d_uniforms, rect2d_instance_attributes,
    rect2d_vertex_attributes}(v, f, "idata");
}

function uint read_3_uint(cslice{uchar} const& buf, size_t o)
{
  /* FIXME: endianness */
  uint v;
  v += buf[o+2]; v *= 256;
  v += buf[o+1]; v *= 256;
  v += buf[o+0];
  return v;
}
function void write_4_uint(slice{uchar} const& buf, size_t o, uint val)
{
  /* FIXME: endianness */
  buf[o+3] = static_cast{uchar}(val >> 24);
  buf[o+2] = static_cast{uchar}(val >> 16);
  buf[o+1] = static_cast{uchar}(val >>  8);
  buf[o+0] = static_cast{uchar}(val);
}

function void
init_texture(main_texture_info mutable& mti, font_texture_info mutable& fti)
{
  metafunction SDL_Surface_Scoped scoped_nullable{SDL_FreeSurface};
  {
    /* font */
    mutable fnames = make_farray{string}(
      "mplus-1m-bold.ttf",
      // "/Library/Fonts/Tahoma.ttf",
      "/Library/Fonts/Osaka.ttf",
      "/usr/share/fonts/mplus/mplus-1m-bold.ttf",
      "/usr/share/fonts/liberation/LiberationMono-Regular.ttf");
    scoped_nullable{TTF_CloseFont} font;
    for (size_t i, mutable& fn: fnames) {
      const p = TTF_OpenFont(fn.c_str(), 18);
      sdllog("openfont", fn, p.to_size_t());
      font.reset(p);
      if (font.get() != rawptr{TTF_Font}()) {
	break;
      }
    }
    if (font.get() == rawptr{TTF_Font}()) {
      sdllog("failed to load font");
      throw runtime_error_template{"load font"}("1");
    }
    SDL_Color mutable fg;
    fg.r = 255;
    fg.g = 255;
    fg.b = 255;
    fg.a = 255;
    uint hmax = 0;
    uint wmax = 0;
    // uint wtotal = 0;
    varray{ptr{SDL_Surface_Scoped}} sur_arr;
    for (const i: 0 .. 0x60) {
      farray{uchar, 2} z;
      z[0] = static_cast{uchar}(i + 0x20);
      z[1] = 0u;
      const sur = make_ptr{SDL_Surface_Scoped}();
      sur->reset(TTF_RenderUTF8_Blended(font,
	z.range().to_crawptr().to_ccharptr(), fg));
      /* sdllog(z, sur.W(), sur.H()); */
      sur_arr.push_back(sur);
      const sur_ref = sur->get().to_slice(1);
      hmax = max(hmax, static_cast{uint}(sur_ref->h));
      wmax = max(wmax, static_cast{uint}(sur_ref->w));
    }
    SDL_Surface_Scoped sur_chars;
    sur_chars.reset(SDL_CreateRGBSurface(0,
      cast_int(power_of_2(wmax * 0x60u)),
      cast_int(power_of_2(hmax)), 32, 0, 0, 0, 0));
    sdllog("wmax, hmax", wmax, hmax);
    fti.char_x.clear();
    uint xcur = 0;
    for (const i, const ep: sur_arr) {
      const& e = *ep->get().to_slice(1);
      SDL_Rect r0;
      SDL_Rect r1;
      r0.x = 0;
      r0.y = 0;
      r0.w = e.w;
      r0.h = e.h;
      r1.x = cast_int(xcur);
      r1.y = 0;
      r1.w = r0.w;
      r1.h = r1.h;
      const v = SDL_UpperBlit(*ep, caddress(r0), sur_chars, address(r1));
      xcur += cast_uint(wmax);
      fti.char_x.push_back(xcur);
    }
    fti.char_w = wmax;
    fti.char_h = hmax;
    const& sur_chars_ref = *sur_chars.get().to_slice(1);
    fti.surface_w = static_cast{uint}(sur_chars_ref.w);
    fti.surface_h = static_cast{uint}(sur_chars_ref.h);
    /* const sur = sur_chars; */
    const sur_chars_buf = sur_chars_ref.pixels.reinterpret_cast{uchar}()
      .to_slice(static_cast{size_t}(sur_chars_ref.pitch * sur_chars_ref.h));
    // const sur_chars_buf = sur_chars.Pixels();
    for (const x: 0 .. sur_chars_ref.w) {
      for (const y: 0 .. sur_chars_ref.h) {
	const i = static_cast{size_t}((y * sur_chars_ref.w + x) * 4);
	sur_chars_buf[i+0] = 255;
	sur_chars_buf[i+1] = 255;
	sur_chars_buf[i+2] = 255;
      }
    }
    /* font texture */
    glActiveTexture(GL_TEXTURE0);
    fti.font_texture_id.generate();
    sdllog("font_texture_id", fti.font_texture_id.get());
    glBindTexture(GL_TEXTURE_2D, fti.font_texture_id.get());
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA),
      sur_chars_ref.w, sur_chars_ref.h,
      0, GL_RGBA, GL_UNSIGNED_BYTE, sur_chars_ref.pixels);
    /*
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_LINEAR));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_LINEAR));
    */
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
  }
  {
    // const sur = IMG_Load("img-c1024.jpg").some;
    SDL_Surface_Scoped sur0;
    sur0.reset(IMG_Load("dpat.png"));
    const& sur0ref = *sur0.get().to_slice(1);
    const fmtp = sur0ref.format;
    const& fmt = *sur0ref.format.to_slice(1);
    const bpp = fmt.BytesPerPixel;
    if (bpp != 4 && bpp != 3) {
      throw runtime_error_template{"img_load"}("1");
    }
    const sur0_w = static_cast{uint}(sur0ref.w);
    const sur0_h = static_cast{uint}(sur0ref.h);
    mutable tex_w = power_of_2(sur0_w);
    mutable tex_h = power_of_2(sur0_h);
    varray{uint} uibuf;
    uibuf.resize(tex_w * tex_h, 0);
    uint rmask = fmt.Rmask;
    uint gmask = fmt.Gmask;
    uint bmask = fmt.Bmask;
    uint amask = fmt.Amask;
    function uint get_shift(uint m) {
      uint r = 0;
      for (uint i: 0 .. 32) {
	if ((m & 1) != 0) {
	  break;
	}
	r += 1;
	m >>= 1;
      }
      return r;
    }
    uint rshift = get_shift(rmask);
    uint gshift = get_shift(gmask);
    uint bshift = get_shift(bmask);
    uint ashift = get_shift(amask);
    /*
    sdllog("Masks", rmask, gmask, bmask, amask, rshift, gshift, bshift,
      ashift);
    */
    const& sur0_ref = *sur0.get().to_slice(1);
    const sur0buf = sur0_ref.pixels.reinterpret_cast{uchar}()
      .to_slice(static_cast{size_t}(sur0_ref.pitch * sur0_ref.h));
    // const sur0buf = sur0_ref.Pixels();
    for (const by: 0 .. sur0_h / 64) {
      for (const iy: 0 .. 32U) {
	for (const x: 0 .. sur0_w) {
	  const o0n = ((by * 64 + iy     ) * sur0_w + x) * bpp;
	  const o0c = ((by * 64 + iy + 32) * sur0_w + x) * bpp;
	  const o1 = ((by * 32 + iy) * tex_w + x) * 4;
	  const nor0 = read_3_uint(sur0buf, o0n);
	  const col0 = read_3_uint(sur0buf, o0c);
	  uint norr = (nor0 >> rshift) & 0xffU;
	  uint norg = (nor0 >> gshift) & 0xffU;
	  uint norb = (nor0 >> bshift) & 0xffU;
	  const nor = (norr << 16) | (norg << 8) | norb;
	  uint colr = (col0 >> rshift) & 0xffU;
	  uint colg = (col0 >> gshift) & 0xffU;
	  uint colb = (col0 >> bshift) & 0xffU;
	  const col = (colb << 16) | (colg << 8) | colr;
	  uint val; /* avol for higher 4bits, alv for lower 4bits */
	  if (nor == 0xff0000) {
	    val = 0x91; /* convex left-upper */
	  } else if (nor == 0x00ff00) {
	    val = 0x92; /* convex upper, or concave lower */
	  } else if (nor == 0xffff00) {
	    val = 0x93; /* convex right-upper */
	  } else if (nor == 0x0000ff) {
	    val = 0x94; /* convex right, or concave left */
	  } else if (nor == 0xff00ff) {
	    val = 0x95; /* convex right-lower */
	  } else if (nor == 0x00ffff) {
	    val = 0x72; /* convex lower, or concave upper */
	  } else if (nor == 0xffffff) {
	    val = 0x97; /* convex left-lower */
	  } else if (nor == 0x808080) {
	    val = 0x74; /* convex left, or concave right */
	  } else if (nor == 0xc04040) {
	    val = 0x71; /* concave left-upper */
	  } else if (nor == 0xc0c040) {
	    val = 0x73; /* concave right-upper */
	  } else if (nor == 0xc040c0) {
	    val = 0x75; /* concave right-lower */
	  } else if (nor == 0xc0c0c0) {
	    val = 0x77; /* concave left-lower */
	  } else if (nor == 0x8080c0) {
	    val = 0x0a; /* emission */
	  }
	  uibuf[(by * 32 + iy) * tex_w + x] = (val << 24) | col;
	}
      }
    }
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE1);
    mti.main_texture_id.generate();
    glBindTexture(GL_TEXTURE_2D, mti.main_texture_id.get());
    /*
    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, cast_int(GL_TRUE));
    */
    int mipmap_level = 0;
    while (true) {
      glTexImage2D(GL_TEXTURE_2D, mipmap_level, cast_int(mode),
	cast_int(tex_w), cast_int(tex_h),
	0, mode, GL_UNSIGNED_BYTE, uibuf.to_crawptr().to_cvoidptr());
      const tex_w_prev = tex_w;
      const tex_h_prev = tex_h;
      tex_w /= 2;
      tex_h /= 2;
      // if (tex_w == 0 || tex_h == 0 || mipmap_level >= 5) {
      if (tex_w == 0 || tex_h == 0 || mipmap_level >= 0) {
	break;
      }
      ++mipmap_level;
      for (const y: 0 .. tex_h) {
	for (const x: 0 .. tex_w) {
	  farray{uint, 4} v;
	  v[0] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 0)];
	  v[1] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 1)];
	  v[2] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 0)];
	  v[3] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 1)];
	  uint mutable val_b;
	  uint mutable val_g;
	  uint mutable val_r;
	  size_t opaque_count = 0;
	  for (size_t j: 0 .. 4) {
	    val_b += (v[j] >> 16) & 0xff;
	    val_g += (v[j] >>  8) & 0xff;
	    val_r += (v[j] >>  0) & 0xff;
	    if (((v[j] >> 24) & 0x0f) == 10) { ++opaque_count; }
	  }
	  val_b /= 4;
	  val_g /= 4;
	  val_r /= 4;
	  const val_a = opaque_count > 0 ? 10U : (v[0] >> 24) & 0xff; // TODO
	  /*
	  uibuf[y * tex_w + x] = (val_a << 24) +
	    (val_b << 16) + (val_g << 8) + (val_r << 0);
	  uibuf[y * tex_w + x] = v[0];
	  */
	}
      }
    }
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(mipmap_level > 0 ? GL_NEAREST_MIPMAP_NEAREST : GL_NEAREST));
    mti.surface_w = tex_w;
    mti.surface_h = tex_h;
    if (m::ne{is_gl3_or_gles3, 0}) {
      if (mipmap_level != 0) {
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, mipmap_level);
      }
    }
  }
  {
    /* tile map */
    SDL_Surface_Scoped sur1;
    sur1.reset(SDL_CreateRGBSurface(0, 128, 128, 32, 0, 0, 0, 0));
    const& sur1_ref = *sur1.get().to_slice(1);
    const sur1buf = sur1_ref.pixels.reinterpret_cast{uchar}()
      .to_slice(static_cast{size_t}(sur1_ref.pitch * sur1_ref.h));
    const sur1_w = static_cast{uint}(sur1_ref.w);
    const sur1_h = static_cast{uint}(sur1_ref.h);
    // const sur1buf = sur1.Pixels();
    const rnd = make_rand_generator(333U);
    for (const y: 0 .. sur1_h) {
      for (const x: 0 .. sur1_w) {
	const o1 = (y * sur1_w + x) * 4;
	const v0 = rnd->generate() / 65536;
	const v1 = v0 % 8;
	const v2 = (v0 / 8) % 8;
	const uint specular_ambient = 0xff60;
	if (x == 0 && y == 0) {
	  write_4_uint(sur1buf, o1, specular_ambient << 16);
	} else {
	  write_4_uint(sur1buf, o1, (v1 % 8) | specular_ambient << 16);
	}
      }
    }
    sdllog("sur1buf", sur1_w, sur1_h);
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE2);
    mti.tilemap_texture_id.generate();
    glBindTexture(GL_TEXTURE_2D, mti.tilemap_texture_id.get());
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(mode),
      cast_int(sur1_ref.w), cast_int(sur1_ref.h),
      0, mode, GL_UNSIGNED_BYTE, sur1buf.to_crawptr().to_cvoidptr());
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
  }
}

private threaded function {t} void
buffer_append(varray{float} mutable& arr, t const& v)
{
  if (m::eq{t, float}) {
    arr.push_back(v);
  } else if (m::or{
    m::eq{t, glm::vec2},
    m::eq{t, glm::vec3},
    m::eq{t, glm::vec4},
    m::eq{t, glm::mat2},
    m::eq{t, glm::mat3},
    m::eq{t, glm::mat4}}) {
    arr.append(v.to_cslice());
  } else {
    expand (sym: m::field_names{t})
    {
      buffer_append(arr, v.sym);
    }
  }
}

private threaded function void prepare_instance_data_default(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  buffer_append(ibarr[0].instance_buffer, sn.trans);
}

private threaded function void prepare_instance_data_main(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  buffer_append(ibarr[0].instance_buffer, sn.trans); /* model matrix */
  const smvp = ncd.shadowmapping_vp * sn.trans;
  buffer_append(ibarr[1].instance_buffer, smvp); /* shadowmapping mvp */
}

private threaded function void prepare_instance_data_particle(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  const mvp = ncd.vp * sn.trans;
  buffer_append(ibarr[0].instance_buffer, mvp);
}

private threaded function void prepare_instance_data_lineparticle(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  const sli = sn.trans.to_cslice();
  ibarr[0].instance_buffer.append(sli[0 .. 9]);
}

private threaded function void prepare_instance_data_rect2d(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  const sli = sn.trans.to_cslice();
  ibarr[0].instance_buffer.append(sli[0 .. 4]);
}

private threaded function void prepare_instance_data_font2(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  varray{instance_data} mutable& ibarr)
{
  const sli = sn.trans.to_cslice();
  ibarr[0].instance_buffer.append(sli[0 .. 4]);
}

private threaded function void prepare_instance_data_ft_rec(
  scene_node{node_data} const& sn, node_common_data mutable& ncd,
  cslice{prepare_instance_data_funcptr} const& ftable,
  varray{instances_type} mutable& ibs)
{
  const bo_id = sn.joint_id.bo_id;
  const vs_id = sn.joint_id.vs_id;
  if (bo_id >= 0 && vs_id >= 0) {
    ++ncd.stat_num_objects;
    mutable& ibarr = ibs[bo_id][static_cast{size_t}(vs_id)];
    ftable[bo_id](sn, ncd, ibarr);
  }
  for (const i, const& snp: sn.children) {
    prepare_instance_data_ft_rec(*snp, ncd, ftable, ibs);
  }
}

private metafunction prepare_instance_data_funcptr
  pointer::func::funcptr_for_function{prepare_instance_data_default};

private multithreaded struct prepare_instance_data_cb
<prepare_instance_data_i>
{
  public varray{prepare_instance_data_funcptr} func_table;
  public function void prepare_instance_data(scene_node{node_data} const& sn,
    node_common_data mutable& ncd, varray{instances_type} mutable& ibs)
  {
    prepare_instance_data_ft_rec(sn, ncd, func_table, ibs);
  }
}

private threaded function void prepare_instance_data_cb_add(
  prepare_instance_data_cb mutable& picb, vertex_buffer_id vbid,
  prepare_instance_data_funcptr const& fp)
{
  size_t i = static_cast{size_t}(vbid);
  if (picb.func_table.size() <= i) {
    picb.func_table.resize(i + 1,
      make_funcptr{prepare_instance_data_default}());
  }
  picb.func_table[i] = fp;
}

