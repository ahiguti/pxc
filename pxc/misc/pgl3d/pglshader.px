public namespace pglshader "export-unsafe";
public import common -;
public import pointer::raw -;
public import numeric::fpmath -;
public import SDL2 -;
public import SDL2::Image -;
public import SDL2::TTF -;
public import GL::glm glm;
public import GL::compat -;
public import io::time -;
public import io::environ -;
public import exception -;
public import meta m;
public import text::string::positional -;

public import glresource -;
public import glshader -;
public import glgeometry -;
public import glbuffer -;
public import glnode -;

public struct sdlcontext()
{
  private SDL_Init init_object = SDL_Init(SDL_INIT_VIDEO);
  public int init_w = 128;
  public int init_h = 128;
  public bool enable_msaa = false;
  public bool gles_flag = false;
  public int glmajor;
  public int glminor;
  public int vsync = 1;
  public option{ptr{SDL_Window}} sdl_window;
  private option{ptr{SDL_GLContext}} sdl_glcontext;
  init();
  function void init()
  {
    const num_modes = SDL_GetNumDisplayModes(0);
    for (int i: 0 .. num_modes) {
      SDL_DisplayMode mode;
      SDL_GetDisplayMode(0, i, mode);
      if (mode.w * mode.h > init_w * init_h) {
	// init_w = mode.w;
	// init_h = mode.h;
      }
      if (mode.w * mode.h < init_w * init_h) {
	// init_w = mode.w;
	// init_h = mode.h;
      }
      sdllog(string_join{" "}("displaymode", mode.w, mode.h));
    }
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);

    if (enable_msaa) {
      SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
      SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);
    }
    mutable wflags = SDL_WINDOW_OPENGL;
    wflags |= SDL_WINDOW_RESIZABLE;
    wflags |= SDL_WINDOW_ALLOW_HIGHDPI;
    /*
    wflags |= SDL_WINDOW_FULLSCREEN;
     */
    mutable vsync = 1;
    if (get_option("-f") == "1") { wflags |= SDL_WINDOW_FULLSCREEN; }
    if (get_option("-v") == "1") { vsync = 0; }
    if (get_option("-h") == "1") { wflags &= ~SDL_WINDOW_ALLOW_HIGHDPI; }
    if (m::ne{is_gles, 0}) {
      wflags |= SDL_WINDOW_FULLSCREEN | SDL_WINDOW_BORDERLESS;
    }

    sdllog(string_join{" "}("create_window", init_w, init_h));
    sdl_window = SDL_CreateWindow("PGL3D", 0, 0, init_w, init_h, wflags);
    const wnd = sdl_window.some;
    if (m::eq{is_gles, 0}) {
      /* try opengl 3.3 */
      SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
      SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
      SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
      SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK,
       SDL_GL_CONTEXT_PROFILE_CORE);
      glmajor = 3;
      glminor = 3;
      gles_flag = false;
    } else {
      /* opengles 2.0 */
      SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
      SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
      glmajor = 2;
      glminor = 0;
      gles_flag = true;
    }
    mutable glctx = SDL_GL_CreateContext(wnd);
    if (m::eq{is_gles, 0}) {
      const verstr = cubptr_to_string(glGetString_nocheck(GL_VERSION));
      if (verstr.empty()) {
	/* fallback to opengl 2.1 */
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
	glctx = SDL_GL_CreateContext(wnd);
	glmajor = 2;
	glminor = 1;
      }
    }
    sdl_glcontext = glctx;
    SDL_GL_GetDrawableSize(wnd, init_w, init_h);
    sdllog(string_join{" "}("drawable size", init_w, init_h));
    sdllog(string_join{" "}("GL_VERSION",
      cubptr_to_string(glGetString(GL_VERSION))));
    /*
    println("GL_EXTENSIONS", cubptr_to_string(glGetString(GL_EXTENSIONS)));
    */
    /*
    int num_ext;
    glGetIntegerv(GL_NUM_EXTENSIONS, address(num_ext));
    for (int i: 0 .. num_ext) {
      println("GL_EXTENSION", cubptr_to_string(glGetStringi(GL_EXTENSIONS,
	static_cast{uint}(i))));
    }
    */
  }
}

valuetype struct
glconfig(bool is_gles0, int major0, int minor0, bool msaa0)
{
  public bool const is_gles = is_gles0;
  public int const major = major0;
  public int const minor = minor0;
  public bool enable_shadowmapping = true;
  public bool enable_normalmapping = true;
  public bool enable_deferred = false;
  public bool enable_zprepass = !is_gles && !enable_deferred;
  public bool enable_msaa = msaa0;
  public bool enable_instanced = major >= 3; //  && !is_gles;
  public bool enable_depth_texture = !is_android;
  public bool enable_sampler2dshadow = enable_depth_texture && !is_gles;
  public function bool is_gl3() const { return major >= 3 && !is_gles; }
  public function strlit prepend() const {
    return is_gles ? "precision highp float;\n" :
	   is_gl3() ? "#version 150\n" :
	   "#version 120\n"; }
  public function strlit vert_in() const {
    return is_gl3() ? "in " : "attribute "; }
  public function strlit vert_out() const {
    return is_gl3() ? "out " : "varying "; }
  public function strlit frag_in() const {
    return is_gl3() ? "in " : "varying "; }
  public function strlit texture2d() const {
    return is_gl3() ? "texture" : "texture2D"; }
  public function strlit shadow2d() const {
    return is_gl3() ? "texture" : "shadow2D"; }
  public function strlit fragcolor() const {
    return is_gl3() ? "fragcolor" : "gl_FragColor"; }
  public function strlit decl_fragcolor() const {
    return is_gl3() ? "out vec4 fragcolor;\n" : "\n"; }
  public function string empty_shader_vert() const {
    return prepend() +
      "void main(void) { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); }\n"; }
  public function string empty_shader_frag() const {
    return prepend() + "void main(void) { }\n"; }
}

tsvaluetype struct main_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 model_matrix;
  public int sampler;
  public int sampler_tilemap;
  public int sampler_sm;
  public glm::vec3 camera_pos;
  public glm::vec3 light_pos;
  public float light_on;
  public glm::mat4 shadowmap_vp;
}

public tsvaluetype struct main_vertex_attributes
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
}

tsvaluetype struct main_instance_attributes
{
  public glm::mat4 model_matrix;
  public function main_instance_attributes apply(scene_node const& sn) const
  {
    main_instance_attributes r;
    r.model_matrix = model_matrix * sn.trans;
    return r;
  }
}

tsvaluetype struct ds1st_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 model_matrix;
}

tsvaluetype struct ds1st_vertex_attributes
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec3 tangent;
  public glm::vec3 uvw;
}

tsvaluetype struct ds2nd_uniforms
{
  public int sampler;
  public int sampler_tilemap;
  public int sampler_sm;
  public int sampler_ds0;
  public int sampler_ds1;
  public int sampler_ds2;
  public int sampler_ds3;
  public glm::vec3 camera_pos;
  public glm::vec3 light_pos;
  public float light_on;
  public glm::mat4 shadowmap_vp;
}

tsvaluetype struct ds2nd_vertex_attributes
{
  public glm::vec2 position;
}

tsvaluetype struct zprepass_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 model_matrix;
}

tsvaluetype struct zprepass_vertex_attributes
{
  public glm::vec3 position;
}

tsvaluetype struct shadowmap_uniforms
{
  public glm::mat4 shadowmap_vp;
  public glm::mat4 model_matrix;
    /* use as mvp when instanced rendering is disabled */
}

tsvaluetype struct shadowmap_vertex_attributes
{
  public glm::vec3 position;
}

tsvaluetype struct font_uniforms
{
  public int sampler;
}

tsvaluetype struct font_instance_attributes
{
  public function font_instance_attributes apply(scene_node const& sn) const
  {
    font_instance_attributes r;
    return r;
  }
}

tsvaluetype struct font_vertex_attributes
{
  public glm::vec2 pos;
  public glm::vec2 uvpos;
}

tsvaluetype struct particle_uniforms
{
  public glm::mat4 model_matrix; /* use as mvp */
  public float point_size_base;
}

tsvaluetype struct particle_instance_attributes
{
  public glm::mat4 model_matrix;
  public function main_instance_attributes apply(scene_node const& sn) const
  {
    main_instance_attributes r;
    r.model_matrix = model_matrix * sn.trans;
    return r;
  }
}

tsvaluetype struct particle_vertex_attributes
{
  public glm::vec3 position;
}

tsvaluetype struct particle_bb_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 model_matrix;
  public glm::mat4 camera_matrix;
  public float point_size_base;
}

tsvaluetype struct particle_bb_vertex_attributes
{
  public glm::vec3 position;
  public glm::vec2 local_position;
}

metafunction main_shader_ptr
  ptr{shader{
    main_uniforms, main_instance_attributes, main_vertex_attributes}};
metafunction shadowmap_shader_ptr
  ptr{shader{
    shadowmap_uniforms, main_instance_attributes,
    shadowmap_vertex_attributes}};
metafunction zprepass_shader_ptr
  ptr{shader{
    zprepass_uniforms, main_instance_attributes, zprepass_vertex_attributes}};
metafunction ds1st_shader_ptr
  ptr{shader{
    ds1st_uniforms, main_instance_attributes, ds1st_vertex_attributes}};
metafunction ds2nd_shader_ptr
  ptr{shader{ds2nd_uniforms, main_instance_attributes,
    ds2nd_vertex_attributes}};
metafunction font_shader_ptr
  ptr{shader{
    font_uniforms, font_instance_attributes, font_vertex_attributes}};
metafunction particle_shader_ptr
  ptr{shader{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}};
metafunction particle_bb_shader_ptr
  ptr{shader{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}};

threaded struct main_texture_info
{
  public uint surface_w;
  public uint surface_h;
  public auto_texture main_texture_id;
  public auto_texture tilemap_texture_id;
}

threaded struct font_texture_info
{
  public varray{uint} char_x;
  public uint char_h;
  public uint surface_w;
  public uint surface_h;
  public auto_texture font_texture_id;
  public auto_buffer text_vbo;
}

public valuetype struct position_angle
{
  public glm::vec3 position;
  public glm::quat angle;
  public function glm::mat4 to_mat4() const
  {
    return glm::mat4().translate(position) * angle.to_mat4();
  }
  public function void translate_relative(glm::vec3 const& v)
  {
    position += angle.to_mat3() * v;
  }
  public function void rotate_angle_axis(float a, float x, float y, float z)
  {
    angle *= glm::make_quat_angle_axis(a, x, y, z);
  }
  public function void normalize()
  {
    angle.normalize();
  }
}

struct
projection_info()
{
  public glm::mat4 projection;
  public position_angle camera;
  public int screen_width;
  public int screen_height;
  public bool proj_light;
  public shadowmap_fbo sm;
  public glm::mat4 sm_projection;
  public position_angle light;
  public float light_on = 1.0;
  public float const distance_max = 1000.0;
}

public function uint draw_frame(pglshader mutable& pgs,
  cslice{ptr{buffer_object}} const& bos, ptr{scene_node} const& sn,
  cstrref const& mess)
{
  /* shadowmap view and view-projection matrix */
  const sm_view = pgs.cam.light.to_mat4().inverse();
  const sm_vp = pgs.cam.sm_projection * sm_view;
  /* shadowmapping shader */
  if (pgs.glc.enable_shadowmapping) {
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    glUseProgram(pgs.smsdr->program);
    glBindFramebuffer(GL_FRAMEBUFFER, pgs.sfbo.fbo.get());
    glViewport(0, 0, static_cast{GLsizei}(pgs.sfbo.sm_width),
      static_cast{GLsizei}(pgs.sfbo.sm_height));
    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    if (pgs.glc.enable_depth_texture) {
      glColorMask(0, 0, 0, 0);
    } else {
      glColorMask(1, 1, 1, 1);
    }
    glDepthFunc(GL_LEQUAL);
    glDisable(GL_BLEND);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    {
      if (pgs.glc.enable_instanced) {
	sn->instances_set_data(bos, 0, main_instance_attributes(),
	  pgs.glc.enable_instanced);
	glUniformMatrix4fv(pgs.smsdr->u_shadowmap_vp, 1, 0, sm_vp.crawptr());
	sn->draw_instanced({pgs.smsdr, unit(), unit()}, bos,
	  pgs.glc.enable_instanced);
      } else {
	/* note: view_projection is pre-applied to model_matrix */
	main_instance_attributes miattr;
	miattr.model_matrix = sm_vp;
	sn->instances_set_data(bos, 0, miattr, pgs.glc.enable_instanced);
	sn->draw_instanced({pgs.smsdr, unit(), unit()}, bos,
	  pgs.glc.enable_instanced);
	/* prepare model_matrix for the main shader */
	sn->instances_set_data(bos, 0, main_instance_attributes(),
	  pgs.glc.enable_instanced);
      }
    }
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  } else {
    /* no shadow-mapping. prepare model_matrix for the main shader. */
    sn->instances_set_data(bos, 0, main_instance_attributes(),
      pgs.glc.enable_instanced);
  }
  glViewport(0, 0, static_cast{GLsizei}(pgs.cam.screen_width),
    static_cast{GLsizei}(pgs.cam.screen_height));
  /* z-prepass shader */
  if (pgs.glc.enable_zprepass) {
    glUseProgram(pgs.zpsdr->program);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glDepthMask(1);
    glDisable(GL_BLEND);
    glClear(GL_DEPTH_BUFFER_BIT);
    glColorMask(0, 0, 0, 0);
    mutable view = glm::mat4();
    if (pgs.cam.proj_light) {
      view = pgs.cam.light.to_mat4().inverse();
    } else {
      view = pgs.cam.camera.to_mat4().inverse();
    }
    const vp = pgs.cam.projection * view;
    glUniformMatrix4fv(pgs.zpsdr->u_view_projection_matrix, 1, 0,
      vp.crawptr());
    sn->draw_instanced({pgs.zpsdr, unit(), unit()}, bos,
      pgs.glc.enable_instanced);
  }
  // uint const tick_shadowmapping_shader = SDL_GetTicks();
  /* main or ds1 shader */
  if (true) {
    int saved_fb;
    if (pgs.glc.enable_deferred) {
      glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
      glBindFramebuffer(GL_FRAMEBUFFER, pgs.dsfbo.fbo.get());
      glViewport(0, 0, static_cast{GLsizei}(pgs.dsfbo.ds_width),
	static_cast{GLsizei}(pgs.dsfbo.ds_height));
      glUseProgram(pgs.ds1sdr->program);
    } else {
      glUseProgram(pgs.sdr->program);
    }
    glDisable(GL_BLEND);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    if (pgs.glc.enable_zprepass) {
      glColorMask(1, 1, 1, 1);
      glDepthFunc(GL_EQUAL);
      glClear(GL_COLOR_BUFFER_BIT);
    } else {
      glDepthMask(1);
      glDepthFunc(GL_LESS);
      glColorMask(1, 1, 1, 1);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
    if (pgs.glc.enable_deferred) {
      /* noop */
    } else {
      glUniform3fv(pgs.sdr->u_light_pos, 1, pgs.cam.light.position.crawptr());
      glUniform3fv(pgs.sdr->u_camera_pos, 1, pgs.cam.camera.position.crawptr());
    }
    mutable view = glm::mat4();
    if (pgs.cam.proj_light) {
      view = pgs.cam.light.to_mat4().inverse();
    } else {
      view = pgs.cam.camera.to_mat4().inverse();
    }
    const vp = pgs.cam.projection * view;
    const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
    if (pgs.glc.enable_deferred) {
      glUniformMatrix4fv(pgs.ds1sdr->u_view_projection_matrix, 1, 0,
	vp.crawptr());
    } else {
      glUniform1i(pgs.sdr->u_sampler, 1);
      glUniform1i(pgs.sdr->u_sampler_tilemap, 2);
      glUniform1i(pgs.sdr->u_sampler_sm, 3);
      glUniform1f(pgs.sdr->u_light_on, pgs.cam.light_on);
      glUniformMatrix4fv(pgs.sdr->u_shadowmap_vp, 1, 0, sm_vp.crawptr());
      glUniformMatrix4fv(pgs.sdr->u_view_projection_matrix, 1, 0,
	vp.crawptr());
    }
    if (pgs.glc.enable_deferred) {
      sn->draw_instanced({pgs.ds1sdr, unit(), unit()}, bos,
	pgs.glc.enable_instanced);
    } else {
      sn->draw_instanced({pgs.sdr, unit(), unit()}, bos,
	pgs.glc.enable_instanced);
    }
    if (pgs.glc.enable_deferred) {
      glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
    }
  }
  /* ds2 */
  if (false) {
  if (pgs.glc.enable_deferred) {
    glUseProgram(pgs.ds2sdr->program);
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_BLEND);
    glUniform3fv(pgs.ds2sdr->u_light_pos, 1, pgs.cam.light.position.crawptr());
    glUniform3fv(pgs.ds2sdr->u_camera_pos, 1,
	pgs.cam.camera.position.crawptr());
    glUniformMatrix4fv(pgs.ds2sdr->u_shadowmap_vp, 1, 0, sm_vp.crawptr());
    glUniform1i(pgs.ds2sdr->u_sampler, 1);
    glUniform1i(pgs.ds2sdr->u_sampler_tilemap, 2);
    glUniform1i(pgs.ds2sdr->u_sampler_sm, 3);
    glUniform1i(pgs.ds2sdr->u_sampler_ds0, 4);
    glUniform1i(pgs.ds2sdr->u_sampler_ds1, 5);
    glUniform1i(pgs.ds2sdr->u_sampler_ds2, 6);
    glUniform1i(pgs.ds2sdr->u_sampler_ds3, 7);
    glUniform1f(pgs.ds2sdr->u_light_on, pgs.cam.light_on);
    glBindBuffer(GL_ARRAY_BUFFER, pgs.dsfbo.ds_vbo.get());
    const vattr_position = cast_uint(pgs.ds2sdr->v_position);
    glEnableVertexAttribArray(vattr_position);
    glVertexAttribPointer(vattr_position, 2, GL_FLOAT, 0, 0,
      offset_to_void_cp(0));
    glDrawArrays(GL_TRIANGLE_FAN, 0, cast_int(4));
    glDisableVertexAttribArray(vattr_position);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
  }
  }
  /* particles-bb */
  {
    mutable cam_mat = glm::mat4();
    if (pgs.cam.proj_light) {
      cam_mat = pgs.cam.light.to_mat4();
    } else {
      cam_mat = pgs.cam.camera.to_mat4();
    }
    const vp = pgs.cam.projection * (cam_mat.inverse());
    sn->instances_set_data(bos, 2, particle_instance_attributes(),
      pgs.glc.enable_instanced);
    glUseProgram(pgs.prtbsdr->program);
    glUniformMatrix4fv(pgs.prtbsdr->u_view_projection_matrix, 1, 0,
      vp.crawptr());
    glUniformMatrix3fv(pgs.prtbsdr->u_camera_matrix, 1, 0,
      cam_mat.to_3().crawptr());
    glUniform1f(pgs.prtbsdr->u_point_size_base, 0.1f);
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    sn->draw_instanced({unit(), unit(), pgs.prtbsdr}, bos,
      pgs.glc.enable_instanced);
  }
  /* particles */
  {
    mutable view = glm::mat4();
    if (pgs.cam.proj_light) {
      view = pgs.cam.light.to_mat4().inverse();
    } else {
      view = pgs.cam.camera.to_mat4().inverse();
    }
    const vp = pgs.cam.projection * view;
    /* vp pre-applied */
    particle_instance_attributes piattr;
    piattr.model_matrix = vp;
    sn->instances_set_data(bos, 1, piattr, pgs.glc.enable_instanced);
    glUseProgram(pgs.spsdr->program);
    glUniform1f(pgs.spsdr->u_point_size_base,
      0.1f * static_cast{float}(pgs.cam.screen_width));
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    sn->draw_instanced({unit(), pgs.spsdr, unit()}, bos,
      pgs.glc.enable_instanced);
  }
  /* panel */
  glUseProgram(pgs.psdr->program);
  glDisable(GL_CULL_FACE);
  glDisable(GL_DEPTH_TEST);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glUniform1i(pgs.psdr->u_sampler, 0);
  //println("panel sampler", pgs.psdr->u_sampler);
  varray{float} xyuv;
  uint cur_x = 0;
  uint cur_y = 0;
  for (size_t i, const ch: mess) {
    if (ch < 0x20) {
      continue;
    }
    const tx0 = (ch > 0x20) ? pgs.fti.char_x[ch - 0x20 - 1] : 0;
    const tx1 = pgs.fti.char_x[ch - 0x20];
    const ty0 = pgs.fti.char_h;
    const ty1 = 0;
    const tw = tx1 - tx0;
    const th = pgs.fti.char_h;
    const x0 = cast_float(cur_x) * 2.0f
      / cast_float(pgs.cam.screen_width) - 1.0f;
    const y0 = cast_float(cur_y) * 2.0f
      / cast_float(pgs.cam.screen_height) - 1.0f;
    const x1 = cast_float(cur_x + tw) * 2.0f
      / cast_float(pgs.cam.screen_width) - 1.0f;
    const y1 = cast_float(cur_y + th) * 2.0f
      / cast_float(pgs.cam.screen_height) - 1.0f;
    const u0 = cast_float(tx0) / cast_float(pgs.fti.surface_w);
    const v0 = cast_float(ty0) / cast_float(pgs.fti.surface_h);
    const u1 = cast_float(tx1) / cast_float(pgs.fti.surface_w);
    const v1 = 0.0f;
    xyuv.push_back(x0);
    xyuv.push_back(y0);
    xyuv.push_back(u0);
    xyuv.push_back(v0);
    xyuv.push_back(x0);
    xyuv.push_back(y1);
    xyuv.push_back(u0);
    xyuv.push_back(v1);
    xyuv.push_back(x1);
    xyuv.push_back(y0);
    xyuv.push_back(u1);
    xyuv.push_back(v0);
    xyuv.push_back(x1);
    xyuv.push_back(y0);
    xyuv.push_back(u1);
    xyuv.push_back(v0);
    xyuv.push_back(x0);
    xyuv.push_back(y1);
    xyuv.push_back(u0);
    xyuv.push_back(v1);
    xyuv.push_back(x1);
    xyuv.push_back(y1);
    xyuv.push_back(u1);
    xyuv.push_back(v1);
    cur_x += tw;
  }
  if (xyuv.size() > 0) {
    const lpp = cast_uint(pgs.psdr->v_pos);
    const lpu = cast_uint(pgs.psdr->v_uvpos);
    // println("text_vbo", pgs.fti.text_vbo.get(), lpp, lpu);
    glBindBuffer(GL_ARRAY_BUFFER, pgs.fti.text_vbo.get());
    glBufferData(GL_ARRAY_BUFFER,
      static_cast{GLsizeiptr}(xyuv.size()) * 4,
      xyuv.crawptr().void(), GL_STREAM_DRAW);
    glEnableVertexAttribArray(lpp);
    glEnableVertexAttribArray(lpu);
    glVertexAttribPointer(lpp, 2, GL_FLOAT, 0, 16, offset_to_void_cp(0));
    glVertexAttribPointer(lpu, 2, GL_FLOAT, 0, 16, offset_to_void_cp(8));
    glDrawArrays(GL_TRIANGLES, 0, cast_int(xyuv.size() / 4));
    glDisableVertexAttribArray(lpp);
    glDisableVertexAttribArray(lpu);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
  }
  return 0; // tick_shadowmapping_shader;
}

function void update_mvp(projection_info mutable& cam)
{
  float const perspective_distance = 1.0;
  const h = cast_float(cam.screen_height)
    / cast_float(cam.screen_width);
  glViewport(0, 0, static_cast{GLsizei}(cam.screen_width),
    static_cast{GLsizei}(cam.screen_height));
  const d = cast_float(perspective_distance);
  {
    const near = cast_float(d);
    const far = cast_float(d + cam.distance_max);
    const left = cast_float(-1.0);
    const right = cast_float(1.0);
    const bottom = cast_float(-h);
    const top = cast_float(h);
    cam.projection = glm::frustum{float}(left, right, bottom, top, near, far);
  }
  {
    const sm_h = max(1.0, h);
    const near = cast_float(d);
    const far = cast_float(d + cam.distance_max);
    const left = cast_float(-1.0);
    const right = cast_float(1.0);
    const bottom = cast_float(-sm_h);
    const top = cast_float(sm_h);
    cam.sm_projection = glm::frustum{float}(left, right, bottom, top, near,
      far);
  }
}

threaded function {t} t power_of_2(t v)
{
  mutable t r = static_cast{t}(1);
  while (r != 0 && r < v) { r <<= 1; }
  return r;
}

struct shadowmap_fbo
{
  public auto_framebuffer fbo;
  public auto_texture sm_texture;
  public int sm_width;
  public int sm_height;
  public auto_renderbuffer depthbuf;
}

function void init_shadowmap_fbo(glconfig const& glc,
  shadowmap_fbo mutable& sfbo)
{
  if (glc.enable_shadowmapping) {
    sdllog(string_join{" "}("shadowmap", sfbo.sm_width, sfbo.sm_height));
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    /* texture */
    glActiveTexture(GL_TEXTURE3);
    sfbo.sm_texture.generate();
    glBindTexture(GL_TEXTURE_2D, sfbo.sm_texture.get());
    if (glc.enable_depth_texture) {
      const f = glc.enable_sampler2dshadow ? GL_LINEAR : GL_NEAREST;
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, cast_int(f));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, cast_int(f));
      if (m::ne{is_gl3, 0}) {
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE,
	  cast_int(GL_COMPARE_REF_TO_TEXTURE));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC,
	  cast_int(GL_LEQUAL));
      }
      if (!glc.is_gles) {
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT),
	  sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	  GL_UNSIGNED_BYTE, offset_to_void_cp(0));
      } else {
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT),
	  sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	  GL_UNSIGNED_SHORT, offset_to_void_cp(0));
      }
    } else {
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
	cast_int(GL_NEAREST));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
	cast_int(GL_NEAREST));
      glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA), sfbo.sm_width,
	sfbo.sm_height, 0, GL_RGBA, GL_UNSIGNED_BYTE,
	offset_to_void_cp(0));
    }
    if (m::eq{is_gles, 0}) {
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
	cast_int(GL_CLAMP_TO_EDGE));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
	cast_int(GL_CLAMP_TO_EDGE));
    }
    /* framebuffer */
    sfbo.fbo.generate();
    glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
    if (glc.enable_depth_texture) {
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
    } else {
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
	GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
    }
    /* renderbuffer */
    if (glc.enable_depth_texture) {
      if (m::eq{is_gles, 0}) {
	glDrawBuffer(GL_NONE);
	glReadBuffer(GL_NONE);
      }
    } else {
      int orig_rb;
      glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
      /*
      println("orig_rb", orig_rb);
      */
      sfbo.depthbuf.generate();
      glBindRenderbuffer(GL_RENDERBUFFER, sfbo.depthbuf.get());
      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16,
	sfbo.sm_width, sfbo.sm_height);
      glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	GL_RENDERBUFFER, sfbo.depthbuf.get());
      glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));
    }
    const e = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (e != GL_FRAMEBUFFER_COMPLETE) {
      println("incomplete framebuffer", cast_int(e));
    } else {
      println("complete framebuffer");
    }
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
}

struct deferred_shading_fbo
{
  public auto_framebuffer fbo;
  public varray{ptr{auto_texture}} ds_texture; /* 4 */
  public int ds_width;
  public int ds_height;
  public auto_renderbuffer depthbuf;
  public auto_buffer ds_vbo;
}

function void
init_deferred_shading_fbo(glconfig const& glc,
  deferred_shading_fbo mutable& dsfbo)
{
  if (m::ne{is_gl3, 0}) {
    if (glc.enable_deferred) {
      sdllog(string_join{" "}("deferred_fbo"));
      int saved_fb;
      glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
      /* texture */
      dsfbo.ds_texture.clear();
      for (size_t i: 0 .. 4) {
	const tx = make_ptr{auto_texture}();
	tx->generate();
	glActiveTexture(static_cast{GLenum}(static_cast{size_t}(
	  GL_TEXTURE4) + i));
	glBindTexture(GL_TEXTURE_2D, tx->get());
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGB32F), dsfbo.ds_width,
	  dsfbo.ds_height, 0, GL_RGB, GL_FLOAT, offset_to_void_cp(0));
	/*
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA), dsfbo.ds_width,
	  dsfbo.ds_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, offset_to_void_cp(0));
	*/
	println("tex2d", i, tx->get(), dsfbo.ds_width, dsfbo.ds_height);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
	  cast_int(GL_NEAREST));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
	  cast_int(GL_NEAREST));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
	  cast_int(GL_CLAMP_TO_EDGE));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
	  cast_int(GL_CLAMP_TO_EDGE));
	dsfbo.ds_texture.push_back(tx);
      }
      /* framebuffer */
      dsfbo.fbo.generate();
      glBindFramebuffer(GL_FRAMEBUFFER, dsfbo.fbo.get());
      for (const i, const tx: dsfbo.ds_texture) {
	glFramebufferTexture2D(GL_FRAMEBUFFER,
	  static_cast{GLenum}(static_cast{size_t}(GL_COLOR_ATTACHMENT0) + i),
	  GL_TEXTURE_2D, tx->get(), 0);
	println("frametex2d", i, tx);
      }
      /* renderbuffer */
      {
	int orig_rb;
	glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
	println("orig_rb", orig_rb);
	dsfbo.depthbuf.generate();
	glBindRenderbuffer(GL_RENDERBUFFER, dsfbo.depthbuf.get());
	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT,
	  dsfbo.ds_width, dsfbo.ds_height);
	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	  GL_RENDERBUFFER, dsfbo.depthbuf.get());
	glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));
      }
      const bufs = make_farray{GLenum}(
	GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1,
	GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3);
      glDrawBuffers(4, bufs.crawptr());
      const e = glCheckFramebufferStatus(GL_FRAMEBUFFER);
      if (e != GL_FRAMEBUFFER_COMPLETE) {
	println("dsfbo: incomplete framebuffer", cast_int(e));
      } else {
	println("dsfbo: complete framebuffer");
      }
      glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
      /* vbo */
      if (dsfbo.ds_vbo.get() == 0) {
	dsfbo.ds_vbo.generate();
	if (dsfbo.ds_vbo.get() == 0) {
	  throw runtime_error_template{"ds_vbo"}("1");
	}
	glBindBuffer(GL_ARRAY_BUFFER, dsfbo.ds_vbo.get());
	const pvals = make_farray{float}(
	  -1.0, -1.0,
	   1.0, -1.0,
	   1.0,  1.0,
	  -1.0,  1.0);
	glBufferData(GL_ARRAY_BUFFER,
	  static_cast{GLsizeiptr}(pvals.size()) * 4,
	  pvals.crawptr().void(), GL_STATIC_DRAW);
      }
    }
  }
}

function shadowmap_shader_ptr
init_shadowmap_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  if (g.enable_instanced) {
    v += "uniform mat4 shadowmap_vp;\n";
    v += g.vert_in() + "mat4 model_matrix;\n";
  } else {
    /* note: passes mvp as model_matrix */
    v += "uniform mat4 model_matrix;\n";
  }
  v += g.vert_in() + "vec3 position;\n";
  if (!g.enable_depth_texture) {
    v += g.vert_out() + "vec4 vary_smpos;\n";
  }
  v += "void main(void) {\n";
  if (g.enable_instanced) {
    v += "vec4 p = shadowmap_vp * (model_matrix * vec4(position, 1.0));\n";
  } else {
    v += "vec4 p = model_matrix * vec4(position, 1.0);\n";
  }
  v += "gl_Position = p;\n";
  if (!g.enable_depth_texture) {
    v += "vary_smpos = p;\n";
  }
  v += "}\n";
  string f;
  if (g.enable_depth_texture) {
    f += g.empty_shader_frag();
  } else {
    f += g.prepend();
    f += g.frag_in() + "vec4 vary_smpos;\n";
    f += g.decl_fragcolor();
    f += "void main(void) {\n";
    f += "vec4 p = vary_smpos;\n";
    f += "  float pz = (p.z/p.w + 1.0) / 2.0;\n";
    f += "  float z = pz * 256.0;\n";/* [0.0, 256.0] */
    f += "  float z0 = floor(z);\n"; /* [0, 256] */
    f += "  z = (z - z0) * 256.0;\n"; /* [0.0, 256.0) */
    f += "  float z1 = floor(z);\n"; /* [0, 256) */
    f += "  z = (z - z1) * 256.0;\n"; /* [0.0, 256.0) */
    f += "  float z2 = floor(z);\n";  /* [0, 256) */
    f += g.fragcolor() + "= vec4(z0/255.0, z1/255.0, z2/255.0, 1.0);\n";
    f += "}\n";
  }
  /*
  println("VERT:", v);
  println("FRAG:", f);
  */
  return make_shader_ptr{shadowmap_uniforms, main_instance_attributes,
    shadowmap_vertex_attributes}(v, f, "model_matrix");
}

function zprepass_shader_ptr
init_zprepass_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  if (g.enable_instanced) {
    v += g.vert_in() + "mat4 model_matrix;\n";
  } else {
    v += "uniform mat4 model_matrix;\n";
  }
  v += g.vert_in() + "vec3 position;\n";
  v += "void main(void) {\n";
  v += "vec4 gpos4 = model_matrix * vec4(position, 1.0);\n";
  v += "gl_Position = view_projection_matrix * gpos4;\n";
  v += "}\n";
  string f = g.empty_shader_frag();
  return make_shader_ptr{zprepass_uniforms, main_instance_attributes,
    zprepass_vertex_attributes}(v, f, "model_matrix");
}

function ds1st_shader_ptr
init_ds1st_shader(glconfig const g)
{
  const v = g.enable_deferred
    ? main_or_ds1st_shader_vert(g) : g.empty_shader_vert();
  string f;
  if (g.enable_deferred) {
    f += g.prepend();
    f += g.frag_in() + "vec3 vary_position;\n";
    f += g.frag_in() + "vec3 vary_normal;\n";
    f += g.frag_in() + "vec3 vary_tangent;\n";
    f += g.frag_in() + "vec3 vary_uvw;\n";
    if (g.is_gl3()) {
      f += "out vec3 ds_data[4];\n";
      f += "void main(void) {\n";
      f += "ds_data[0] = vary_position;\n";
      f += "ds_data[1] = vary_normal;\n";
      f += "ds_data[2] = vary_tangent;\n";
      f += "ds_data[3] = vary_uvw;\n";
      f += "}\n";
    } else {
      f += "void main(void) {\n";
      f += "gl_FragData[0].xyz = vary_position;\n";
      f += "gl_FragData[1].xyz = vary_normal;\n";
      f += "gl_FragData[2].xyz = vary_tangent;\n";
      f += "gl_FragData[3].xyz = vary_uvw;\n";
      f += "}\n";
    }
  } else {
    f += g.empty_shader_frag();
  }
  return make_shader_ptr{ds1st_uniforms, main_instance_attributes,
    ds1st_vertex_attributes}(v, f, "model_matrix");
}

function ds2nd_shader_ptr
init_ds2nd_shader(glconfig const& g)
{
  string v;
  if (g.enable_deferred) {
    v += g.prepend();
    v += g.vert_in() +  "vec2 position;\n";
    v += g.vert_out() + "vec2 vary_ds_coord;\n";
    v += "void main(void) {\n";
    v += "gl_Position = vec4(position, 0.5, 1.0);\n";
    v += "vary_ds_coord = (position + 1.0) * 0.5;\n";
    v += "}\n";
  } else {
    v += g.empty_shader_vert();
  }
  const f = g.enable_deferred
    ? main_or_ds2nd_shader_frag(g) : g.empty_shader_frag();
  return make_shader_ptr{ds2nd_uniforms, main_instance_attributes,
    ds2nd_vertex_attributes}(v, f, "");
}

function string
main_or_ds1st_shader_vert(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat4 shadowmap_vp;\n";
  if (g.enable_instanced) {
    v += g.vert_in() + "mat4 model_matrix;\n";
  } else {
    v += "uniform mat4 model_matrix;\n";
  }
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec3 normal;\n";
  v += g.vert_in() + "vec3 tangent;\n";
  v += g.vert_in() + "vec3 uvw;\n";
  v += g.vert_out() + "vec3 vary_position;\n";
  v += g.vert_out() + "vec3 vary_normal;\n";
  v += g.vert_out() + "vec3 vary_tangent;\n";
  v += g.vert_out() + "vec3 vary_uvw;\n";
  if (!g.enable_deferred) {
    v += g.vert_out() + "vec3 vary_binormal;\n";
    if (g.enable_shadowmapping) {
      v += g.vert_out() + "vec4 vary_smpos;\n";
    }
  }
  v += "void main(void) {\n";
  v += "  vec4 gpos4 = model_matrix * vec4(position, 1.0);\n";
  v += "  gl_Position = view_projection_matrix * gpos4;\n";
  if (g.is_gl3()) {
    v += "  mat3 normal_matrix = mat3(model_matrix);\n";
  } else {
    v += "  mat3 normal_matrix = mat3(model_matrix[0].xyz, ";
    v += "    model_matrix[1].xyz, model_matrix[2].xyz);\n";
  }
  v += "  vary_position = gpos4.xyz / gpos4.w;\n";
  v += "  vary_normal = normal_matrix * normal;\n";
  v += "  vary_tangent = normal_matrix * tangent;\n";
  v += "  vary_uvw = uvw;\n";
  if (!g.enable_deferred) {
    v += "  vary_binormal = cross(vary_normal, vary_tangent);\n";
    if (g.enable_shadowmapping) {
      v += "  vary_smpos = shadowmap_vp * gpos4;\n";
    }
  }
  v += "}\n";
  return v;
}

function string main_or_ds2nd_shader_frag(glconfig const& g)
{
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += "uniform sampler2D sampler_tilemap;\n";
  if (g.enable_sampler2dshadow) {
    f += "uniform sampler2DShadow sampler_sm;\n";
  } else {
    f += "uniform sampler2D sampler_sm;\n";
  }
  f += "uniform vec3 camera_pos;\n";
  f += "uniform vec3 light_pos;\n";
  f += "uniform float light_on;\n";
  f += "uniform mat4 shadowmap_vp;\n";
  if (g.enable_deferred) {
    f += "uniform sampler2D sampler_ds0;\n";
    f += "uniform sampler2D sampler_ds1;\n";
    f += "uniform sampler2D sampler_ds2;\n";
    f += "uniform sampler2D sampler_ds3;\n";
    f += g.frag_in() + "vec2 vary_ds_coord;\n";
  } else {
    f += g.frag_in() + "vec3 vary_position;\n";
    f += g.frag_in() + "vec3 vary_normal;\n";
    f += g.frag_in() + "vec3 vary_tangent;\n";
    f += g.frag_in() + "vec3 vary_uvw;\n";
    f += g.frag_in() + "vec3 vary_binormal;\n";
    if (g.enable_shadowmapping) {
      f += g.frag_in() + "vec4 vary_smpos;\n";
    }
  }
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  if (g.enable_deferred) {
    f += "vec3 vary_position = ";
    f += g.texture2d() + "(sampler_ds0, vary_ds_coord).xyz;\n";
    f += "vec3 vary_normal = ";
    f += g.texture2d() + "(sampler_ds1, vary_ds_coord).xyz;\n";
    f += "vec3 vary_tangent = ";
    f += g.texture2d() + "(sampler_ds2, vary_ds_coord).xyz;\n";
    f += "vec3 vary_uvw = ";
    f += g.texture2d() + "(sampler_ds3, vary_ds_coord).xyz;\n";
    f += "vec3 vary_binormal = cross(vary_normal, vary_tangent);\n";
    if (g.enable_shadowmapping) {
      f += "vec4 vary_smpos = shadowmap_vp * vec4(vary_position, 1.0);\n";
    }
  }
  f += "vec3 light_dir = normalize(light_pos - vary_position);\n";
  f += "float light_distance = length(light_pos - vary_position);\n";
  f += "vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n";
  f += "vec4 color_dif = vec4(0.3, 0.3, 0.3, 1.0);\n";
  f += "float mate_ambient = 0.2;\n";
  f += "float mate_specular = 1.0;\n";
  if (g.enable_shadowmapping) {
    f += "vec4 smp = vary_smpos;\n";
    f += "vec3 smpos = ((smp.xyz / smp.w) + 1.0) * 0.5;\n";
    f += "float lflag = float(int(smpos.x <= 0.0) + int(smpos.x >= 1.0)";
    f += "  + int(smpos.y <= 0.0) + int(smpos.y >= 1.0) == 0);\n";
  } else {
    f += "float lflag = 1.0;\n";
  }
  f += "float lstr = lflag;\n";
  f += "float distbr = min(3000.0 / (light_distance * light_distance), ";
  f += "  light_on);\n";
  f += "vec3 nor = vary_normal;\n";
  if (g.enable_normalmapping) {
    f += "const float tile_size = 32.0;\n";
    f += "const float tilemap_size = 128.0;\n";
    f += "const float tiletex_size = 256.0;\n";
    f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
    f += "vec2 uv_tm = floor(uv0);\n";
	  /* tilemap coordinate */
    f += "vec2 uv_tmfr = uv0 - uv_tm;\n";
	  /* coordinate inside a tile (0, 1) */
    f += "vec2 uv_ti = uv_tmfr * tile_size;\n";
    f += "vec2 uvi = floor(uv_ti);\n";
	  /* coordinate inside a tile, integral */
    f += "vec2 uvj = uv_ti - uvi;\n";
	  /* subpixel coordinate */
    f += "vec4 ti = " +  g.texture2d();
    f += "  (sampler_tilemap, uv_tm / tilemap_size);\n";
	  /* lookup the tilemap */
    f += "vec2 uv_pixel = floor(ti.xy * 255.0 + 0.5) * tile_size + uvi;\n";
	  /* tile pattern coordinate */
    f += "mate_ambient = ti.z;\n";
    f += "mate_specular = ti.w;\n";
    f += "vec4 c0 = " + g.texture2d();
    f += "  (sampler, uv_pixel / tiletex_size);\n";
	  /* lookup the tilepattern */
    f += "float alv0 = floor(c0.a * 255.0 + 0.5);\n";
    f += "float avol = floor(alv0 / 16.0);\n";
    f += "int alv = int(alv0 - avol * 16.0);\n";
    f += "float lt = float(uvj.y - uvj.x >= 0.0);\n";
    f += "float lb = float(uvj.y + uvj.x <= 1.0);\n";
    f += "vec4 avlv = vec4(float(alv == 1), float(alv == 3), ";
    f += "  float(alv == 5), float(alv == 7));\n";
    f += "float ut1 = dot(avlv, vec4(-lt, 1.0-lb, 1.0-lt, -lb));\n";
    f += "float vt1 = dot(avlv, vec4(lt-1.0, -lb, lt, 1.0-lb));\n";
    f += "ut1 += float(alv == 4);\n";
    f += "vt1 -= float(alv == 2);\n";
    f += "avol = (avol - 8.0) * distbr * 0.2;\n";
    f += "color += vec4(c0.xyz, 0.0) * float(alv == 10);\n";
    f += "color_dif = vec4(c0.xyz, 0.0) * float(alv != 10);\n";
    f += "distbr *= float(alv != 10);\n";
    f += "nor += vary_tangent * ut1 * avol;\n";
    f += "nor += vary_binormal * vt1 * avol;\n";
    f += "nor = normalize(nor);\n";
  }
  f += "vec3 reflection_vec = reflect(-light_dir, nor);\n";
  f += "vec3 camera_dir = normalize(camera_pos - vary_position);\n";
  f += "float cos_angle = max(0.0, dot(camera_dir, reflection_vec));\n";
  f += "float specular = pow(cos_angle, 16.0);\n";
  f += "float diffuse = clamp(dot(light_dir, nor), 0.0, 1.0);\n";
  if (g.enable_shadowmapping) {
    if (g.enable_depth_texture) {
      if (g.enable_sampler2dshadow) {
	f += "smpos.z *= 0.9995;\n";
	f += "lstr = (";
	f += g.shadow2d() + "(sampler_sm, smpos+vec3(-0.0003,-0.0003,0.0)) +";
	f += g.shadow2d() + "(sampler_sm, smpos+vec3(-0.0003,0.0003,0.0)) +";
	f += g.shadow2d() + "(sampler_sm, smpos+vec3(0.0003,-0.0003,0.0)) +";
	f += g.shadow2d() + "(sampler_sm, smpos+vec3(0.0003,0.0003,0.0)))";
	if (!g.is_gl3()) {
	  f += ".r";
	}
	f += "  / 4.0;\n";
      } else {
	f += "float zval = " + g.texture2d();
	f += "   (sampler_sm, smpos.xy * lflag).x;\n";
	f += "lstr = float(smpos.z < zval * 1.0005) * lflag;\n";
      }
    } else {
      f += "vec4 smz = " + g.texture2d();
      f += "  (sampler_sm, smpos.xy * lflag);\n";
      f += "float z0 = floor(smz.r * 255.0 + 0.5);\n";
      f += "float z1 = floor(smz.g * 255.0 + 0.5);\n";
      f += "float z2 = floor(smz.b * 255.0 + 0.5);\n";
      f += "float zval = z0 * 65536.0 + z1 * 256.0 + z2;\n";
      f += "lstr = float(smpos.z * 16770000.0 < zval) * lflag;\n";
    }
    f += "color += (vec4(1.0, 1.0, 1.0, 1.0) * mate_specular ";
    f += "  * specular) * distbr * lstr;\n";
  }
  f += g.fragcolor() +  " = color + ";
  f += "  (color_dif * (diffuse * distbr * lstr + mate_ambient));\n";
  f += "}\n";
  return f;
}

function main_shader_ptr
init_main_shader(glconfig const& g)
{
  const v = g.enable_deferred
    ? g.empty_shader_vert() : main_or_ds1st_shader_vert(g);
  const f = g.enable_deferred
    ? g.empty_shader_frag() : main_or_ds2nd_shader_frag(g);
  return
    make_shader_ptr{main_uniforms, main_instance_attributes,
      main_vertex_attributes}(v, f, "model_matrix");
}

function particle_shader_ptr
init_particle_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  if (g.enable_instanced) {
    v += g.vert_in() + "mat4 model_matrix;\n";
  } else {
    v += "uniform mat4 model_matrix;\n";
  }
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  // v += g.vert_out() + "float debug_w;\n";
  v += "void main(void) {\n";
  v += "gl_Position = model_matrix * vec4(position, 1.0);\n";
  v += "gl_PointSize = point_size_base / gl_Position.w;\n";
  // v += "debug_w = gl_Position.w;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  // f += g.frag_in() + "float debug_w;\n";
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord * 2.0 - 1.0;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  // f += "if (debug_w < 1.0) { b = 1.0; }\n";
  f += g.fragcolor() + " = vec4(b, b, b, 1.0);\n";
  f += "}\n";
  return make_shader_ptr{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}(v, f, "model_matrix");
}

function particle_bb_shader_ptr
init_particle_bb_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  if (g.enable_instanced) {
    v += g.vert_in() + "mat4 model_matrix;\n";
  } else {
    v += "uniform mat4 model_matrix;\n";
  }
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat3 camera_matrix;\n";
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec2 local_position;\n";
  v += g.vert_out() + "vec2 point_coord;\n";
  v += "void main(void) {\n";
  v += "vec4 pos = model_matrix * vec4(position, 1.0);\n";
  v += "vec3 posb = camera_matrix";
  v += "  * vec3(local_position * point_size_base, 0.0);\n";
  v += "gl_Position = view_projection_matrix * vec4(pos.xyz + posb, 1.0);\n";
  v += "point_coord = local_position;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec2 point_coord;\n";
  f += "void main(void) {\n";
  f += "vec2 xy = point_coord;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b, b, b, 1.0);\n";
  f += "}\n";
  return make_shader_ptr{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}(v, f, "model_matrix");
}

function font_shader_ptr
init_font_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += g.vert_in() + "vec2 pos;\n";
  v += g.vert_in() + "vec2 uvpos;\n";
  v += g.vert_out() + "vec2 texcoord;\n";
  v += "void main(void) {\n";
  v += "gl_Position = vec4(pos, 0.0, 1.0);\n";
  v += "texcoord = uvpos;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += g.frag_in() + "vec2 texcoord;\n";
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec4 col = " +  g.texture2d() + "(sampler, texcoord);\n";
  f += "col.a *= 0.5;\n";
  f += g.fragcolor() + " = col;\n";
  f += "}\n";
  return make_shader_ptr{font_uniforms, font_instance_attributes,
    font_vertex_attributes}(v, f, "");
}

function uint read_3_uint(cslice{uchar} const& buf, size_t o)
{
  /* FIXME: endianness */
  uint v;
  v += buf[o+2]; v *= 256;
  v += buf[o+1]; v *= 256;
  v += buf[o+0];
  return v;
}
function void write_4_uint(slice{uchar} const& buf, size_t o, uint val)
{
  /* FIXME: endianness */
  buf[o+3] = static_cast{uchar}(val >> 24);
  buf[o+2] = static_cast{uchar}(val >> 16);
  buf[o+1] = static_cast{uchar}(val >>  8);
  buf[o+0] = static_cast{uchar}(val);
}

function void
init_texture(main_texture_info mutable& mti, font_texture_info mutable& fti)
{
  {
    /* font */
    const fnames = make_farray{string}(
      "LiberationMono-Bold.ttf",
      "/Library/Fonts/Osaka.ttf",
      "/usr/share/fonts/liberation/LiberationMono-Bold.ttf");
    option{ptr{TTF_Font}} font;
    for (size_t i, const& fn: fnames) {
      font = TTF_OpenFont(fn, 16);
      if (case font.some) {
	break;
      }
    }
    SDL_Color mutable fg;
    fg.r = 255;
    fg.g = 255;
    fg.b = 255;
    fg.a = 255;
    uint hmax = 0;
    uint wtotal = 0;
    varray{ptr{SDL_Surface}} sur_arr;
    for (const i: 0 .. 0x60) {
      farray{uchar, 1} z;
      z[0] = static_cast{uchar}(i + 0x20);
      const sur = TTF_RenderUTF8_Blended(font.some, z, fg).some;
      /* println(z, sur.W(), sur.H()); */
      sur_arr.push_back(sur);
      hmax = max(hmax, sur.H());
      wtotal += sur.W();
    }
    const sur_chars = SDL_CreateRGBSurface(
      cast_int(power_of_2(wtotal)),
      cast_int(power_of_2(hmax)), 32, 0, 0, 0, 0).some;
    println("wtotal, hmax", wtotal, hmax);
    fti.char_x.clear();
    uint xcur = 0;
    for (const i, const e: sur_arr) {
      SDL_Rect r0;
      SDL_Rect r1;
      r0.x = 0;
      r0.y = 0;
      r0.w = cast_int(e.W());
      r0.h = cast_int(e.H());
      r1.x = cast_int(xcur);
      r1.y = 0;
      r1.w = r0.w;
      r1.h = r1.h;
      const v = SDL_BlitSurface(e, r0, sur_chars, r1);
      xcur += cast_uint(r1.w);
      fti.char_x.push_back(xcur);
    }
    fti.char_h = hmax;
    fti.surface_w = sur_chars.W();
    fti.surface_h = sur_chars.H();
    const sur = sur_chars;
    const sur_chars_buf = sur_chars.Pixels();
    for (const x: 0 .. sur_chars.W()) {
      for (const y: 0 .. sur_chars.H()) {
	const i = (y * sur_chars.W() + x) * 4;
	sur_chars_buf[i+0] = 255;
	sur_chars_buf[i+1] = 255;
	sur_chars_buf[i+2] = 255;
      }
    }
    /* font texture */
    glActiveTexture(GL_TEXTURE0);
    fti.font_texture_id.generate();
    println("font_texture_id", fti.font_texture_id.get());
    glBindTexture(GL_TEXTURE_2D, fti.font_texture_id.get());
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA),
      cast_int(sur.W()), cast_int(sur.H()),
      0, GL_RGBA, GL_UNSIGNED_BYTE, sur.Pixels().crawptr().void());
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
    fti.text_vbo.generate();
    if (fti.text_vbo.get() == 0) {
      throw runtime_error_template{"text_vbo"}("1");
    }
  }
  {
    // const sur = IMG_Load("img-c1024.jpg").some;
    const sur0 = IMG_Load("dpat.png").some;
    const bpp = sur0.BytesPerPixel();
    if (bpp != 4 && bpp != 3) {
      throw runtime_error_template{"img_load"}("1");
    }
    const sur0_w = sur0.W();
    const sur0_h = sur0.H();
    mutable tex_w = power_of_2(sur0_w);
    mutable tex_h = power_of_2(sur0_h);
    varray{uint} uibuf;
    uibuf.resize(tex_w * tex_h, 0);
    uint rmask;
    uint gmask;
    uint bmask;
    uint amask;
    sur0.Masks(rmask, gmask, bmask, amask);
    function uint get_shift(uint m) {
      uint r = 0;
      for (uint i: 0 .. 32) {
	if ((m & 1) != 0) {
	  break;
	}
	r += 1;
	m >>= 1;
      }
      return r;
    }
    uint rshift = get_shift(rmask);
    uint gshift = get_shift(gmask);
    uint bshift = get_shift(bmask);
    uint ashift = get_shift(amask);
    /*
    println("Masks", rmask, gmask, bmask, amask, rshift, gshift, bshift,
      ashift);
    */
    const sur0buf = sur0.Pixels();
    for (const by: 0 .. sur0_h / 64) {
      for (const iy: 0 .. 32U) {
	for (const x: 0 .. sur0_w) {
	  const o0n = ((by * 64 + iy     ) * sur0_w + x) * bpp;
	  const o0c = ((by * 64 + iy + 32) * sur0_w + x) * bpp;
	  const o1 = ((by * 32 + iy) * tex_w + x) * 4;
	  const nor0 = read_3_uint(sur0buf, o0n);
	  const col0 = read_3_uint(sur0buf, o0c);
	  uint norr = (nor0 >> rshift) & 0xffU;
	  uint norg = (nor0 >> gshift) & 0xffU;
	  uint norb = (nor0 >> bshift) & 0xffU;
	  const nor = (norr << 16) | (norg << 8) | norb;
	  uint colr = (col0 >> rshift) & 0xffU;
	  uint colg = (col0 >> gshift) & 0xffU;
	  uint colb = (col0 >> bshift) & 0xffU;
	  const col = (colb << 16) | (colg << 8) | colr;
	  uint val; /* avol for higher 4bits, alv for lower 4bits */
	  if (nor == 0xff0000) {
	    val = 0x91; /* convex left-upper */
	  } else if (nor == 0x00ff00) {
	    val = 0x92; /* convex upper, or concave lower */
	  } else if (nor == 0xffff00) {
	    val = 0x93; /* convex right-upper */
	  } else if (nor == 0x0000ff) {
	    val = 0x94; /* convex right, or concave left */
	  } else if (nor == 0xff00ff) {
	    val = 0x95; /* convex right-lower */
	  } else if (nor == 0x00ffff) {
	    val = 0x72; /* convex lower, or concave upper */
	  } else if (nor == 0xffffff) {
	    val = 0x97; /* convex left-lower */
	  } else if (nor == 0x808080) {
	    val = 0x74; /* convex left, or concave right */
	  } else if (nor == 0xc04040) {
	    val = 0x71; /* concave left-upper */
	  } else if (nor == 0xc0c040) {
	    val = 0x73; /* concave right-upper */
	  } else if (nor == 0xc040c0) {
	    val = 0x75; /* concave right-lower */
	  } else if (nor == 0xc0c0c0) {
	    val = 0x77; /* concave left-lower */
	  } else if (nor == 0x8080c0) {
	    val = 0x0a; /* emission */
	  }
	  uibuf[(by * 32 + iy) * tex_w + x] = (val << 24) | col;
	}
      }
    }
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE1);
    mti.main_texture_id.generate();
    glBindTexture(GL_TEXTURE_2D, mti.main_texture_id.get());
    /*
    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, cast_int(GL_TRUE));
    */
    int mipmap_level = 0;
    while (true) {
      glTexImage2D(GL_TEXTURE_2D, mipmap_level, cast_int(mode),
	cast_int(tex_w), cast_int(tex_h),
	0, mode, GL_UNSIGNED_BYTE, uibuf.crawptr().void());
      const tex_w_prev = tex_w;
      const tex_h_prev = tex_h;
      tex_w /= 2;
      tex_h /= 2;
      // if (tex_w == 0 || tex_h == 0 || mipmap_level >= 5) {
      if (tex_w == 0 || tex_h == 0 || mipmap_level >= 0) {
	break;
      }
      ++mipmap_level;
      for (const y: 0 .. tex_h) {
	for (const x: 0 .. tex_w) {
	  farray{uint, 4} v;
	  v[0] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 0)];
	  v[1] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 1)];
	  v[2] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 0)];
	  v[3] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 1)];
	  uint mutable val_b;
	  uint mutable val_g;
	  uint mutable val_r;
	  size_t opaque_count = 0;
	  for (size_t j: 0 .. 4) {
	    val_b += (v[j] >> 16) & 0xff;
	    val_g += (v[j] >>  8) & 0xff;
	    val_r += (v[j] >>  0) & 0xff;
	    if (((v[j] >> 24) & 0x0f) == 10) { ++opaque_count; }
	  }
	  val_b /= 4;
	  val_g /= 4;
	  val_r /= 4;
	  const val_a = opaque_count > 0 ? 10U : (v[0] >> 24) & 0xff; // TODO
	  /*
	  uibuf[y * tex_w + x] = (val_a << 24) +
	    (val_b << 16) + (val_g << 8) + (val_r << 0);
	  uibuf[y * tex_w + x] = v[0];
	  */
	}
      }
    }
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(mipmap_level > 0 ? GL_NEAREST_MIPMAP_NEAREST : GL_NEAREST));
    mti.surface_w = tex_w;
    mti.surface_h = tex_h;
    if (m::ne{is_gl3, 0}) {
      if (mipmap_level != 0) {
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, mipmap_level);
      }
    }
  }
  {
    /* tile map */
    const sur1 = SDL_CreateRGBSurface(128, 128, 32, 0, 0, 0, 0).some;
    const sur1_w = sur1.W();	
    const sur1_h = sur1.H();	
    const sur1buf = sur1.Pixels();
    const rnd = make_rand_generator(333U);
    for (const y: 0 .. sur1_h) {
      for (const x: 0 .. sur1_w) {
	const o1 = (y * sur1_w + x) * 4;
	const v0 = rnd->generate() / 65536;
	const v1 = v0 % 8;
	const v2 = (v0 / 8) % 8;
	const uint specular_ambient = 0xff60;
	if (x == 0 && y == 0) {
	  write_4_uint(sur1buf, o1, specular_ambient << 16);
	} else {
	  write_4_uint(sur1buf, o1, (v1 % 8) | specular_ambient << 16);
	}
      }
    }
    println("sur1buf", sur1_w, sur1_h);
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE2);
    mti.tilemap_texture_id.generate();
    glBindTexture(GL_TEXTURE_2D, mti.tilemap_texture_id.get());
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(mode),
      cast_int(sur1.W()), cast_int(sur1.H()),
      0, mode, GL_UNSIGNED_BYTE, sur1.Pixels().crawptr().void());
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
  }
}

public function void sdllog(cstrref const& mess)
{
  SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, mess);
}

public struct
pglshader(bool gles_flag0, int glmajor0, int glminor0, bool enable_msaa0,
  int width0, int height0)
{
  public glconfig glc = glconfig(gles_flag0, glmajor0, glminor0,
    enable_msaa0);
  public main_shader_ptr const sdr = init_main_shader(glc);
  public shadowmap_shader_ptr const smsdr = init_shadowmap_shader(glc);
  public zprepass_shader_ptr const zpsdr = init_zprepass_shader(glc);
  public ds1st_shader_ptr const ds1sdr = init_ds1st_shader(glc);
  public ds2nd_shader_ptr const ds2sdr = init_ds2nd_shader(glc);
  public particle_shader_ptr const spsdr = init_particle_shader(glc);
  public particle_bb_shader_ptr const prtbsdr = init_particle_bb_shader(glc);
  public font_shader_ptr const psdr = init_font_shader(glc);
  public shadowmap_fbo sfbo;
  public deferred_shading_fbo dsfbo;
  public main_texture_info mti;
  public font_texture_info fti;
  public projection_info cam;
  private auto_vertexarray vtxarr;
  init();
  reshape(width0, height0);
  private function void init()
  {
    if (m::ne{is_gl3, 0}) {
      vtxarr.generate();
      glBindVertexArray(vtxarr.get());
      println("glBindVertexArray", vtxarr.get());
    }
    if (m::eq{is_gles, 0}) {
      farray{float, 2} arr;
      float step;
      glGetFloatv(GL_POINT_SIZE_RANGE, arr.rawptr());
      glGetFloatv(GL_POINT_SIZE_GRANULARITY, address(step));
      println("GL_POINT_SIZE_RANGE", arr, step);
    }
    init_texture(mti, fti);
    if (m::ne{is_gl3, 0}) {
      if (glc.enable_msaa) {
	glEnable(GL_MULTISAMPLE);
      }
    }
    if (m::eq{is_gles, 0}) {
      if (!glc.is_gl3()) {
	glEnable(GL_POINT_SPRITE);
	println("GL_POINT_SPRITE enabled");
      }
      glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
    }
  }
  public function void reshape(int width, int height)
  {
    cam.screen_width = width;
    cam.screen_height = height;
    if (m::ne{is_gles, 0}) {
      sfbo.sm_width = 1024;
      sfbo.sm_height = 1024;
    } else {
      sfbo.sm_width = width;
      sfbo.sm_height = height;
    }
    init_shadowmap_fbo(glc, sfbo);
    dsfbo.ds_width = width;
    dsfbo.ds_height = height;
    init_deferred_shading_fbo(glc, dsfbo);
    update_mvp(cam);
  }
}

