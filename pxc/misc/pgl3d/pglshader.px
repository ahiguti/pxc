public namespace pglshader "export-unsafe";
public import common -;
public import pointer::raw -;
public import numeric::fpmath -;
public import SDL2 -;
public import SDL2::Image -;
public import SDL2::TTF -;
public import GL::glm glm;
public import GL::compat -;
public import io::time -;
public import io::environ -;
public import exception -;
public import meta m;
public import text::string::positional -;

public import glresource -;
public import glshader -;
public import glgeometry -;
public import glbuffer -;
public import glnode -;

public struct sdlcontext()
{
  private SDL_Init init_object = SDL_Init(SDL_INIT_VIDEO);
  public int init_w = 128;
  public int init_h = 128;
  public bool enable_msaa = false;
  public bool gles_flag = false;
  public int glmajor;
  public int glminor;
  public int vsync = 1;
  public option{ptr{SDL_Window}} sdl_window;
  private option{ptr{SDL_GLContext}} sdl_glcontext;
  init();
  function void init()
  {
    const num_modes = SDL_GetNumDisplayModes(0);
    for (int i: 0 .. num_modes) {
      SDL_DisplayMode mode;
      SDL_GetDisplayMode(0, i, mode);
      if (mode.w * mode.h > init_w * init_h) {
	// init_w = mode.w;
	// init_h = mode.h;
      }
      if (mode.w * mode.h < init_w * init_h) {
	// init_w = mode.w;
	// init_h = mode.h;
      }
      sdllog(string_join{" "}("displaymode", mode.w, mode.h));
    }
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);

    if (enable_msaa) {
      SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
      SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);
    }
    mutable wflags = SDL_WINDOW_OPENGL;
    wflags |= SDL_WINDOW_RESIZABLE;
    wflags |= SDL_WINDOW_ALLOW_HIGHDPI;
    /*
    wflags |= SDL_WINDOW_FULLSCREEN;
     */
    mutable vsync = 1;
    if (get_option("-f") == "1") { wflags |= SDL_WINDOW_FULLSCREEN; }
    if (get_option("-v") == "1") { vsync = 0; }
    if (get_option("-h") == "1") { wflags &= ~SDL_WINDOW_ALLOW_HIGHDPI; }
    if (m::ne{is_gles, 0}) {
      wflags |= SDL_WINDOW_FULLSCREEN | SDL_WINDOW_BORDERLESS;
    }

    sdllog(string_join{" "}("create_window", init_w, init_h));
    sdl_window = SDL_CreateWindow("PGL3D", 0, 0, init_w, init_h, wflags);
    const wnd = sdl_window.some;
// FIXME: 3.3 -> 3.2 -> 2.1
    if (m::eq{is_gles, 0}) {
      /* try opengl 3.3 */
      SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
      SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
      // SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
      SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);
      SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK,
       SDL_GL_CONTEXT_PROFILE_CORE);
      glmajor = 3;
      glminor = 3;
      // glminor = 2;
      gles_flag = false;
    } else {
      if (m::ne{is_android, 0}) {
	/* android: opengles 2.0 */
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
	glmajor = 2;
	glminor = 0;
      } else {
	/* ios: opengles 3.0 */
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
	glmajor = 3;
	glminor = 0;
      }
      gles_flag = true;
    }
    mutable glctx = SDL_GL_CreateContext(wnd);
    const verstr = cubptr_to_string(glGetString_nocheck(GL_VERSION));
    if (verstr.empty()) {
      if (m::eq{is_gles, 0}) {
	/* fallback to opengl 2.1 */
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
	glctx = SDL_GL_CreateContext(wnd);
	glmajor = 2;
	glminor = 1;
      } else {
	/* fallback to opengles 2.0 */
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
	glctx = SDL_GL_CreateContext(wnd);
	glmajor = 2;
	glminor = 0;
      }
    }
    sdl_glcontext = glctx;
    SDL_GL_GetDrawableSize(wnd, init_w, init_h);
    sdllog(string_join{" "}("drawable size", init_w, init_h));
    sdllog(string_join{" "}("GL_VERSION",
      cubptr_to_string(glGetString(GL_VERSION))));
    /*
    println("GL_EXTENSIONS", cubptr_to_string(glGetString(GL_EXTENSIONS)));
    */
    /*
    int num_ext;
    glGetIntegerv(GL_NUM_EXTENSIONS, address(num_ext));
    for (int i: 0 .. num_ext) {
      println("GL_EXTENSION", cubptr_to_string(glGetStringi(GL_EXTENSIONS,
	static_cast{uint}(i))));
    }
    */
  }
}

valuetype struct
glconfig(bool is_gles0, int major0, int minor0, bool msaa0)
{
  public bool const is_gles = is_gles0;
  public int const major = major0;
  public int const minor = minor0;
  public bool enable_shadowmapping = true;
  public bool enable_shadowmapping_multisample = false;
  public bool enable_normalmapping = true;
  public bool enable_deferred = false;
  public bool enable_zprepass = !is_gles && !enable_deferred;
  public bool enable_msaa = msaa0;
  public bool enable_instanced = false; // major >= 3;
  public bool enable_uniform_instancing = enable_instanced &&
    // (is_gles || minor < 3 || true);
    (is_gles || minor < 3);
  // public bool enable_uniform_instancing = enable_instanced;
  public bool enable_depth_texture = !is_android;
  public bool enable_sampler2dshadow = enable_depth_texture && !is_gles;
  //public function bool is_gl3() const { return major >= 3 && !is_gles; }
  public function bool is_gl3_or_gles3() const { return major >= 3; }
  public function bool is_gl33_or_gles3() const {
    return major >= 3 && (is_gles || minor >= 3); }
  public function strlit prepend() const {
    if (is_gles) {
      if (is_gl3_or_gles3()) {
	return "#version 300 es\nprecision highp float;\n";
      } else {
	return "precision highp float;\n";
      }
    } else {
      if (is_gl3_or_gles3()) {
	return "#version 150\n";
      } else {
	return "#version 120\n";
      }
    }
    /*
    return is_gles ? "precision highp float;\n" :
	   is_gl3() ? "#version 150\n" :
	   "#version 120\n"; }
    */
  }
  public function strlit vert_in() const {
    return is_gl3_or_gles3() ? "in " : "attribute "; }
  public function strlit vert_out() const {
    return is_gl3_or_gles3() ? "out " : "varying "; }
  public function strlit frag_in() const {
    return is_gl3_or_gles3() ? "in " : "varying "; }
  public function strlit texture2d() const {
    return is_gl3_or_gles3() ? "texture" : "texture2D"; }
  public function strlit shadow2d() const {
    return is_gl3_or_gles3() ? "texture" : "shadow2D"; }
  public function strlit fragcolor() const {
    return is_gl3_or_gles3() ? "fragcolor" : "gl_FragColor"; }
  public function strlit decl_fragcolor() const {
    return is_gl3_or_gles3() ? "out vec4 fragcolor;\n" : "\n"; }
  public function string decl_instance_id(bool has_iid) const {
    if (use_copying_instancing != 0 && has_iid) {
      return vert_in() + "float instance_id;\n";
    } else {
      return "";
    }
  }
  public function string decl_instance_attr(cstrref const& t, cstrref const& n,
      bool has_iid)
    const {
    if (use_copying_instancing != 0 && has_iid) {
      return "uniform " + t + " " + n + "["
	+ m::to_string{uniform_instancing_mul} + "];\n";
    } else {
      if (enable_instanced) {
	if (enable_uniform_instancing) {
	  return "uniform " + t + " " + n + "["
	    + m::to_string{uniform_instancing_mul} + "];\n";
	} else {
	  return vert_in() + t + " " + n + ";\n";
	}
      } else {
	return "uniform " + t + " " + n + ";\n";
      }
    }
  }
  public function string instance_attr(cstrref const& n, bool has_iid) const {
    if (use_copying_instancing != 0 && has_iid) {
      return n + "[int(instance_id)]";
    } else {
      if (enable_instanced && enable_uniform_instancing) {
	return n + "[gl_InstanceID]";
      } else {
	return n;
      }
    }
  }
  public function string empty_shader_vert() const {
    return prepend() +
      "void main(void) { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); }\n"; }
  public function string empty_shader_frag() const {
    return prepend() + "void main(void) { }\n"; }
}

tsvaluetype struct main_uniforms
{
  public glm::mat4 view_projection_matrix;
  public int sampler;
  public int sampler_tilemap;
  public int sampler_sm;
  public glm::vec3 camera_pos;
  public glm::vec3 light_pos;
  public float light_on;
  public glm::mat4 shadowmap_vp;
}

expand (sym: m::seq{use_copying_instancing}) {
  public tsvaluetype struct main_vertex_attributes
  {
    public float instance_id;
    public glm::vec3 position;
    public glm::vec3 normal;
    public glm::vec3 tangent;
    public glm::vec3 uvw;
  }
  tsvaluetype struct ds1st_vertex_attributes
  {
    public float instance_id;
    public glm::vec3 position;
    public glm::vec3 normal;
    public glm::vec3 tangent;
    public glm::vec3 uvw;
  }
  tsvaluetype struct zprepass_vertex_attributes
  {
    public float instance_id;
    public glm::vec3 position;
  }
  tsvaluetype struct shadowmap_vertex_attributes
  {
    public float instance_id;
    public glm::vec3 position;
  }
}

expand (sym: m::seq{m::not{use_copying_instancing}}) {
  public tsvaluetype struct main_vertex_attributes
  {
    public glm::vec3 position;
    public glm::vec3 normal;
    public glm::vec3 tangent;
    public glm::vec3 uvw;
  }
  tsvaluetype struct ds1st_vertex_attributes
  {
    public glm::vec3 position;
    public glm::vec3 normal;
    public glm::vec3 tangent;
    public glm::vec3 uvw;
  }
  tsvaluetype struct zprepass_vertex_attributes
  {
    public glm::vec3 position;
  }
  tsvaluetype struct shadowmap_vertex_attributes
  {
    public glm::vec3 position;
  }
}

tsvaluetype struct main_instance_attributes
{
  public glm::mat4 model_matrix;
}

tsvaluetype struct ds1st_uniforms
{
  public glm::mat4 view_projection_matrix;
}

tsvaluetype struct ds2nd_uniforms
{
  public int sampler;
  public int sampler_tilemap;
  public int sampler_sm;
  public int sampler_ds0;
  public int sampler_ds1;
  public int sampler_ds2;
  public int sampler_ds3;
  public glm::vec3 camera_pos;
  public glm::vec3 light_pos;
  public float light_on;
  public glm::mat4 shadowmap_vp;
}

tsvaluetype struct ds2nd_vertex_attributes
{
  public glm::vec2 position;
}

tsvaluetype struct zprepass_uniforms
{
  public glm::mat4 view_projection_matrix;
}

tsvaluetype struct shadowmap_uniforms
{
  public glm::mat4 shadowmap_vp;
}

tsvaluetype struct font_uniforms
{
  public int sampler;
}

tsvaluetype struct font_instance_attributes
{
}

tsvaluetype struct font_vertex_attributes
{
  public glm::vec2 pos;
  public glm::vec2 uvpos;
}

tsvaluetype struct font2_uniforms
{
  public glm::vec2 screen_size_px;
  public float pixel_to_screen;
  public int sampler;
}

tsvaluetype struct font2_instance_attributes
{
  public glm::mat4 idata;
}

public tsvaluetype struct font2_vertex_attributes
{
  public glm::vec2 texture_size_px;
  public glm::vec2 texture_origin_px;
  public glm::vec2 char_size_px;
  public glm::vec2 coord_clamp;
  public float char_px;
  public float char_point_size;
  public float text_index;
}

tsvaluetype struct particle_uniforms
{
  public float point_size_base;
}

tsvaluetype struct particle_instance_attributes
{
  public glm::mat4 model_matrix; /* vp applied */
}

tsvaluetype struct particle_vertex_attributes
{
  public glm::vec3 position;
}

tsvaluetype struct particle_bb_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 camera_matrix;
  public float point_size_base;
}

tsvaluetype struct particle_bb_vertex_attributes
{
  public glm::vec3 position;
  public glm::vec2 local_position;
}

public tsvaluetype struct lineparticle_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::vec2 screen_size_px;
}

public tsvaluetype struct lineparticle_vertex_attributes
{
  public glm::vec2 vert;
}

public tsvaluetype struct lineparticle_instance_attributes
{
  public glm::vec3 position0;
  public glm::vec3 position1;
  public float point_size_base;
}

metafunction main_shader_ptr
  ptr{shader{
    main_uniforms, main_instance_attributes, main_vertex_attributes}};
metafunction shadowmap_shader_ptr
  ptr{shader{
    shadowmap_uniforms, main_instance_attributes,
    shadowmap_vertex_attributes}};
metafunction zprepass_shader_ptr
  ptr{shader{
    zprepass_uniforms, main_instance_attributes, zprepass_vertex_attributes}};
metafunction ds1st_shader_ptr
  ptr{shader{
    ds1st_uniforms, main_instance_attributes, ds1st_vertex_attributes}};
metafunction ds2nd_shader_ptr
  ptr{shader{ds2nd_uniforms, main_instance_attributes,
    ds2nd_vertex_attributes}};
metafunction font2_shader_ptr
  ptr{shader{
    font2_uniforms, font2_instance_attributes, font2_vertex_attributes}};
metafunction particle_shader_ptr
  ptr{shader{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}};
metafunction particle_bb_shader_ptr
  ptr{shader{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}};
metafunction lineparticle_shader_ptr
  ptr{shader{lineparticle_uniforms, lineparticle_instance_attributes,
    lineparticle_vertex_attributes}};

threaded struct main_texture_info
{
  public uint surface_w;
  public uint surface_h;
  public auto_texture main_texture_id;
  public auto_texture tilemap_texture_id;
}

threaded struct font_texture_info
{
  public varray{uint} char_x;
  public uint char_w;
  public uint char_h;
  public uint surface_w;
  public uint surface_h;
  public auto_texture font_texture_id;
  public auto_buffer text_vbo;
}

public valuetype struct position_angle
{
  public glm::vec3 position;
  public glm::quat angle;
  public function glm::mat4 to_mat4() const
  {
    return glm::mat4().translate(position) * angle.to_mat4();
  }
  public function void translate_relative(glm::vec3 const& v)
  {
    position += angle.to_mat3() * v;
  }
  public function void rotate_angle_axis(float a, float x, float y, float z)
  {
    angle *= glm::make_quat_angle_axis(a, x, y, z);
  }
  public function void normalize()
  {
    angle.normalize();
  }
}

struct
projection_info()
{
  public glm::mat4 projection;
  public position_angle camera;
  public int screen_width;
  public int screen_height;
  public bool proj_light;
  public shadowmap_fbo sm;
  public glm::mat4 sm_projection;
  public position_angle light;
  public float light_on = 1.0;
  public float const distance_max = 1000.0;
}

private struct node_common_data
{
  public glm::mat4 shadowmapping_vp;
  public glm::mat4 vp;
}

private function {tsn} void
prepare_instance_data(tsn const& sn, node_common_data const& ncd,
  cslice{ptr{vertex_buffer}} const& bos)
{
  const bo_id = sn.joint_id.bo_id;
  const vs_id = sn.joint_id.vs_id;
  if (bo_id >= 0 && vs_id >= 0) {
    const& bo = bos[bo_id];
    const& ibarr = bo->instances[static_cast{size_t}(vs_id)];
    if (bo_id == 1) {
      /* particle */
      const mvp = ncd.vp * sn.trans;
      buffer_append(ibarr[0]->instance_buffer, mvp);
    } else if (bo_id == 4) {
      /* lineparticle */
      const sli = sn.trans.cslice();
      lineparticle_instance_attributes v;
      v.position0 = glm::make_vec3(sli[0], sli[1], sli[2]);
      v.position1 = glm::make_vec3(sli[3], sli[4], sli[5]);
      v.point_size_base = sli[6];
      buffer_append(ibarr[0]->instance_buffer, v);
    } else {
      /* ibuf_id == 0 for model matrix */
      buffer_append(ibarr[0]->instance_buffer, sn.trans);
      if (bo_id == 0) {
	/* ibuf_id == 1 for shadowmapping mvp */
	const smvp = ncd.shadowmapping_vp * sn.trans;
	buffer_append(ibarr[1]->instance_buffer, smvp);
      }
    }
  }
  for (const i, const& snp: sn.children) {
    prepare_instance_data(*snp, ncd, bos);
  }
}

public function {tsn} varray{uint}
draw_frame(pglshader mutable& pgs, tsn const& sn, cstrref const& mess)
{
  const& bos = pgs.vertex_buffers;
  /* prepare instance data */
  const sm_view = pgs.cam.light.to_mat4().inverse();
  const sm_vp = pgs.cam.sm_projection * sm_view;
  {
    for (const i, const& bo: bos) {
      bo->clear_instances();
    }
    const vp = pgs.cam.projection * pgs.cam.camera.to_mat4().inverse();
    /* shadowmap view and view-projection matrix */
    node_common_data ncd;
    ncd.shadowmapping_vp = sm_vp;
    ncd.vp = vp;
    prepare_instance_data(sn, ncd, bos);
  }
  const tick1 = SDL_GetTicks();
  sn.send_instance_data(bos, pgs.global_ibuffer,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  const tick2 = SDL_GetTicks();
  /* shadowmapping shader */
  if (pgs.glc.enable_shadowmapping) {
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    glUseProgram(pgs.smsdr->program);
    glBindFramebuffer(GL_FRAMEBUFFER, pgs.sfbo.fbo.get());
    glViewport(0, 0, static_cast{GLsizei}(pgs.sfbo.sm_width),
      static_cast{GLsizei}(pgs.sfbo.sm_height));
    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthMask(1);
    if (pgs.glc.enable_depth_texture) {
      glColorMask(0, 0, 0, 0);
    } else {
      glColorMask(1, 1, 1, 1);
    }
    glDepthFunc(GL_LEQUAL);
    glDisable(GL_BLEND);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /* note: view_projection is pre-applied to model_matrix */
    sn.draw_instanced(*pgs.smsdr, *bos[0], pgs.global_ibuffer,
	0, 1, pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
  glViewport(0, 0, static_cast{GLsizei}(pgs.cam.screen_width),
    static_cast{GLsizei}(pgs.cam.screen_height));
  /* z-prepass shader */
  if (pgs.glc.enable_zprepass) {
    glUseProgram(pgs.zpsdr->program);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glDepthMask(1);
    glDisable(GL_BLEND);
    glClear(GL_DEPTH_BUFFER_BIT);
    glColorMask(0, 0, 0, 0);
    mutable view = glm::mat4();
    if (pgs.cam.proj_light) {
      view = pgs.cam.light.to_mat4().inverse();
    } else {
      view = pgs.cam.camera.to_mat4().inverse();
    }
    const vp = pgs.cam.projection * view;
    glUniformMatrix4fv(pgs.zpsdr->u_view_projection_matrix, 1, 0,
      vp.crawptr());
    sn.draw_instanced(*pgs.zpsdr, *bos[0], pgs.global_ibuffer,
	0, 0, pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  }
  /* main or ds1 shader */
  if (true) {
    int saved_fb;
    if (pgs.glc.enable_deferred) {
      glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
      glBindFramebuffer(GL_FRAMEBUFFER, pgs.dsfbo.fbo.get());
      glViewport(0, 0, static_cast{GLsizei}(pgs.dsfbo.ds_width),
	static_cast{GLsizei}(pgs.dsfbo.ds_height));
      glUseProgram(pgs.ds1sdr->program);
    } else {
      glUseProgram(pgs.sdr->program);
    }
    glDisable(GL_BLEND);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    if (pgs.glc.enable_zprepass) {
      glColorMask(1, 1, 1, 1);
      glDepthFunc(GL_EQUAL);
      glClear(GL_COLOR_BUFFER_BIT);
    } else {
      glDepthMask(1);
      glDepthFunc(GL_LESS);
      glColorMask(1, 1, 1, 1);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
    if (pgs.glc.enable_deferred) {
      /* noop */
    } else {
      glUniform3fv(pgs.sdr->u_light_pos, 1, pgs.cam.light.position.crawptr());
      glUniform3fv(pgs.sdr->u_camera_pos, 1, pgs.cam.camera.position.crawptr());
    }
    mutable view = glm::mat4();
    if (pgs.cam.proj_light) {
      view = pgs.cam.light.to_mat4().inverse();
    } else {
      view = pgs.cam.camera.to_mat4().inverse();
    }
    const vp = pgs.cam.projection * view;
    const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
    if (pgs.glc.enable_deferred) {
      glUniformMatrix4fv(pgs.ds1sdr->u_view_projection_matrix, 1, 0,
	vp.crawptr());
    } else {
      glUniform1i(pgs.sdr->u_sampler, 1);
      glUniform1i(pgs.sdr->u_sampler_tilemap, 2);
      glUniform1i(pgs.sdr->u_sampler_sm, 3);
      glUniform1f(pgs.sdr->u_light_on, pgs.cam.light_on);
      glUniformMatrix4fv(pgs.sdr->u_shadowmap_vp, 1, 0, sm_vp.crawptr());
      glUniformMatrix4fv(pgs.sdr->u_view_projection_matrix, 1, 0,
	vp.crawptr());
    }
    if (pgs.glc.enable_deferred) {
      sn.draw_instanced(*pgs.ds1sdr, *bos[0],
	  pgs.global_ibuffer, 0, 0,
	  pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
    } else {
      sn.draw_instanced(*pgs.sdr, *bos[0], pgs.global_ibuffer,
	  0, 0, pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
    }
    if (pgs.glc.enable_deferred) {
      glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
    }
  }
  /* ds2 */
  if (pgs.glc.enable_deferred) {
    glUseProgram(pgs.ds2sdr->program);
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_BLEND);
    glUniform3fv(pgs.ds2sdr->u_light_pos, 1, pgs.cam.light.position.crawptr());
    glUniform3fv(pgs.ds2sdr->u_camera_pos, 1,
	pgs.cam.camera.position.crawptr());
    glUniformMatrix4fv(pgs.ds2sdr->u_shadowmap_vp, 1, 0, sm_vp.crawptr());
    glUniform1i(pgs.ds2sdr->u_sampler, 1);
    glUniform1i(pgs.ds2sdr->u_sampler_tilemap, 2);
    glUniform1i(pgs.ds2sdr->u_sampler_sm, 3);
    glUniform1i(pgs.ds2sdr->u_sampler_ds0, 4);
    glUniform1i(pgs.ds2sdr->u_sampler_ds1, 5);
    glUniform1i(pgs.ds2sdr->u_sampler_ds2, 6);
    glUniform1i(pgs.ds2sdr->u_sampler_ds3, 7);
    glUniform1f(pgs.ds2sdr->u_light_on, pgs.cam.light_on);
    glBindBuffer(GL_ARRAY_BUFFER, pgs.dsfbo.ds_vbo.get());
    const vattr_position = cast_uint(pgs.ds2sdr->v_position);
    glEnableVertexAttribArray(vattr_position);
    glVertexAttribPointer(vattr_position, 2, GL_FLOAT, 0, 0,
      offset_to_void_cp(0));
    glDrawArrays(GL_TRIANGLE_FAN, 0, cast_int(4));
    glDisableVertexAttribArray(vattr_position);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
  }
  /* particles-bb */
  {
    mutable cam_mat = glm::mat4();
    if (pgs.cam.proj_light) {
      cam_mat = pgs.cam.light.to_mat4();
    } else {
      cam_mat = pgs.cam.camera.to_mat4();
    }
    const vp = pgs.cam.projection * (cam_mat.inverse());
    glUseProgram(pgs.prtbsdr->program);
    glUniformMatrix4fv(pgs.prtbsdr->u_view_projection_matrix, 1, 0,
      vp.crawptr());
    glUniformMatrix3fv(pgs.prtbsdr->u_camera_matrix, 1, 0,
      cam_mat.to_3().crawptr());
    glUniform1f(pgs.prtbsdr->u_point_size_base, 0.1f);
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    sn.draw_instanced(*pgs.prtbsdr, *bos[2],
	pgs.global_ibuffer, 2, 0,
	pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  }
  /* particles */
  {
    glUseProgram(pgs.spsdr->program);
    glUniform1f(pgs.spsdr->u_point_size_base,
      0.1f * static_cast{float}(pgs.cam.screen_width));
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    sn.draw_instanced(*pgs.spsdr, *bos[1], pgs.global_ibuffer,
	1, 0, pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  }
  /* lineparticle */
  {
// FIXME
    mutable cam_mat = glm::mat4();
    if (pgs.cam.proj_light) {
      cam_mat = pgs.cam.light.to_mat4();
    } else {
      cam_mat = pgs.cam.camera.to_mat4();
    }
    const vp = pgs.cam.projection * (cam_mat.inverse());
    glUseProgram(pgs.lpsdr->program);
    glUniformMatrix4fv(pgs.lpsdr->u_view_projection_matrix, 1, 0,
      vp.crawptr());
    const screen_size_px = make_farray{float}(
      cast_float(pgs.cam.screen_width), cast_float(pgs.cam.screen_height));
    glUniform2fv(pgs.lpsdr->u_screen_size_px, 1, screen_size_px.crawptr());
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(0);
    /*
    */
    // glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    sn.draw_instanced(*pgs.lpsdr, *bos[4], pgs.global_ibuffer,
	4, 0, pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  }
  /* font */
  {
    glUseProgram(pgs.f2sdr->program);
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glUniform1f(pgs.f2sdr->u_pixel_to_screen,
      2.0f / static_cast{float}(pgs.cam.screen_width));
    glUniform1i(pgs.f2sdr->u_sampler, 0);
    const screen_size_px = glm::make_vec2(
      static_cast{float}(pgs.cam.screen_width),
      static_cast{float}(pgs.cam.screen_height));
    glUniform2fv(pgs.f2sdr->u_screen_size_px, 1, screen_size_px.crawptr());
//println("bos3");
    sn.draw_instanced(*pgs.f2sdr, *bos[3], pgs.global_ibuffer,
	3, 0, pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  }
  sn.finished_using_instance_data(bos, pgs.global_ibuffer,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
  return make_varray{uint}(tick1, tick2);
}

function void update_mvp(projection_info mutable& cam)
{
  float const perspective_distance = 1.0;
  const h = cast_float(cam.screen_height)
    / cast_float(cam.screen_width);
  glViewport(0, 0, static_cast{GLsizei}(cam.screen_width),
    static_cast{GLsizei}(cam.screen_height));
  const d = cast_float(perspective_distance);
  {
    const near = cast_float(d);
    const far = cast_float(d + cam.distance_max);
    const left = cast_float(-1.0);
    const right = cast_float(1.0);
    const bottom = cast_float(-h);
    const top = cast_float(h);
    cam.projection = glm::frustum{float}(left, right, bottom, top, near, far);
  }
  {
    const sm_h = max(1.0, h);
    const near = cast_float(d);
    const far = cast_float(d + cam.distance_max);
    const left = cast_float(-1.0);
    const right = cast_float(1.0);
    const bottom = cast_float(-sm_h);
    const top = cast_float(sm_h);
    cam.sm_projection = glm::frustum{float}(left, right, bottom, top, near,
      far);
  }
}

threaded function {t} t power_of_2(t v)
{
  mutable t r = static_cast{t}(1);
  while (r != 0 && r < v) { r <<= 1; }
  return r;
}

struct shadowmap_fbo
{
  public auto_framebuffer fbo;
  public auto_texture sm_texture;
  public int sm_width;
  public int sm_height;
  public auto_renderbuffer depthbuf;
}

function void init_shadowmap_fbo(glconfig const& glc,
  shadowmap_fbo mutable& sfbo)
{
  if (glc.enable_shadowmapping) {
    sdllog(string_join{" "}("shadowmap", sfbo.sm_width, sfbo.sm_height));
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    /* texture */
    glActiveTexture(GL_TEXTURE3);
    sfbo.sm_texture.generate();
    glBindTexture(GL_TEXTURE_2D, sfbo.sm_texture.get());
    if (glc.enable_depth_texture) {
      println("depth_texture");
      const f = glc.enable_sampler2dshadow ? GL_LINEAR : GL_NEAREST;
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, cast_int(f));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, cast_int(f));
      if (m::ne{is_gl3_or_gles3, 0}) {
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE,
	  cast_int(GL_COMPARE_REF_TO_TEXTURE));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC,
	  cast_int(GL_LEQUAL));
      }
      if (!glc.is_gles) {
	println("depth_texture byte");
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT),
	  sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	  GL_UNSIGNED_BYTE, offset_to_void_cp(0));
      } else {
	if (glc.is_gl3_or_gles3()) {
	  /* ios gles3: COMPONENT16, UNSIGNED_INT */
	  println("depth_texture int");
	  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT16),
	    sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	    GL_UNSIGNED_INT, offset_to_void_cp(0));
	} else {
	  /* ios gles2: COMPONENT, UNSIGNED_SHORT */
	  println("depth_texture short");
	  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT),
	    sfbo.sm_width, sfbo.sm_height, 0, GL_DEPTH_COMPONENT,
	    GL_UNSIGNED_SHORT, offset_to_void_cp(0));
	}
      }
      println("depth_texture done");
    } else {
      println("no depth_texture");
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
	cast_int(GL_NEAREST));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
	cast_int(GL_NEAREST));
      println("no depth_texture rbga byte");
      glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA), sfbo.sm_width,
	sfbo.sm_height, 0, GL_RGBA, GL_UNSIGNED_BYTE,
	offset_to_void_cp(0));
    }
    if (m::eq{is_gles, 0}) {
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
	cast_int(GL_CLAMP_TO_EDGE));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
	cast_int(GL_CLAMP_TO_EDGE));
    }
    /* framebuffer */
    sfbo.fbo.generate();
    glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
    if (glc.enable_depth_texture) {
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
    } else {
      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
	GL_TEXTURE_2D, sfbo.sm_texture.get(), 0);
    }
    /* renderbuffer */
    if (glc.enable_depth_texture) {
      if (m::eq{is_gles, 0}) {
	glDrawBuffer(GL_NONE);
	glReadBuffer(GL_NONE);
      }
    } else {
      int orig_rb;
      glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
      /*
      println("orig_rb", orig_rb);
      */
      sfbo.depthbuf.generate();
      glBindRenderbuffer(GL_RENDERBUFFER, sfbo.depthbuf.get());
      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16,
	sfbo.sm_width, sfbo.sm_height);
      glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	GL_RENDERBUFFER, sfbo.depthbuf.get());
      glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));
    }
    const e = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (e != GL_FRAMEBUFFER_COMPLETE) {
      println("incomplete framebuffer", cast_int(e));
    } else {
      println("complete framebuffer");
    }
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
}

struct deferred_shading_fbo
{
  public auto_framebuffer fbo;
  public varray{ptr{auto_texture}} ds_texture; /* 4 */
  public int ds_width;
  public int ds_height;
  public auto_renderbuffer depthbuf;
  public auto_buffer ds_vbo;
}

function void
init_deferred_shading_fbo(glconfig const& glc,
  deferred_shading_fbo mutable& dsfbo)
{
  if (m::ne{is_gl3_or_gles3, 0}) {
    if (glc.enable_deferred) {
      sdllog(string_join{" "}("deferred_fbo"));
      int saved_fb;
      glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
      /* texture */
      dsfbo.ds_texture.clear();
      for (size_t i: 0 .. 4) {
	const tx = make_ptr{auto_texture}();
	tx->generate();
	glActiveTexture(static_cast{GLenum}(static_cast{size_t}(
	  GL_TEXTURE4) + i));
	glBindTexture(GL_TEXTURE_2D, tx->get());
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGB32F), dsfbo.ds_width,
	  dsfbo.ds_height, 0, GL_RGB, GL_FLOAT, offset_to_void_cp(0));
	/*
	glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA), dsfbo.ds_width,
	  dsfbo.ds_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, offset_to_void_cp(0));
	*/
	println("tex2d", i, tx->get(), dsfbo.ds_width, dsfbo.ds_height);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
	  cast_int(GL_NEAREST));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
	  cast_int(GL_NEAREST));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
	  cast_int(GL_CLAMP_TO_EDGE));
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
	  cast_int(GL_CLAMP_TO_EDGE));
	dsfbo.ds_texture.push_back(tx);
      }
      /* framebuffer */
      dsfbo.fbo.generate();
      glBindFramebuffer(GL_FRAMEBUFFER, dsfbo.fbo.get());
      for (const i, const tx: dsfbo.ds_texture) {
	glFramebufferTexture2D(GL_FRAMEBUFFER,
	  static_cast{GLenum}(static_cast{size_t}(GL_COLOR_ATTACHMENT0) + i),
	  GL_TEXTURE_2D, tx->get(), 0);
	println("frametex2d", i, tx);
      }
      /* renderbuffer */
      {
	int orig_rb;
	glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
	println("orig_rb", orig_rb);
	dsfbo.depthbuf.generate();
	glBindRenderbuffer(GL_RENDERBUFFER, dsfbo.depthbuf.get());
	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT,
	  dsfbo.ds_width, dsfbo.ds_height);
	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
	  GL_RENDERBUFFER, dsfbo.depthbuf.get());
	glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));
      }
      const bufs = make_farray{GLenum}(
	GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1,
	GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3);
      glDrawBuffers(4, bufs.crawptr());
      const e = glCheckFramebufferStatus(GL_FRAMEBUFFER);
      if (e != GL_FRAMEBUFFER_COMPLETE) {
	println("dsfbo: incomplete framebuffer", cast_int(e));
      } else {
	println("dsfbo: complete framebuffer");
      }
      glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
      /* vbo */
      if (dsfbo.ds_vbo.get() == 0) {
	dsfbo.ds_vbo.generate();
	if (dsfbo.ds_vbo.get() == 0) {
	  throw runtime_error_template{"ds_vbo"}("1");
	}
	glBindBuffer(GL_ARRAY_BUFFER, dsfbo.ds_vbo.get());
	const pvals = make_farray{float}(
	  -1.0, -1.0,
	   1.0, -1.0,
	   1.0,  1.0,
	  -1.0,  1.0);
	glBufferData(GL_ARRAY_BUFFER,
	  static_cast{GLsizeiptr}(pvals.size()) * 4,
	  pvals.crawptr().void(), GL_STATIC_DRAW);
      }
    }
  }
}

function shadowmap_shader_ptr
init_shadowmap_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  /* note: passes mvp as model_matrix */
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", true);
  v += g.vert_in() + "vec3 position;\n";
  if (!g.enable_depth_texture) {
    v += g.vert_out() + "vec4 vary_smpos;\n";
  }
  v += "void main(void) {\n";
  v += "vec4 p = " + g.instance_attr("model_matrix", true);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_Position = p;\n";
  if (!g.enable_depth_texture) {
    v += "vary_smpos = p;\n";
  }
  v += "}\n";
  string f;
  if (g.enable_depth_texture) {
    f += g.empty_shader_frag();
  } else {
    f += g.prepend();
    f += g.frag_in() + "vec4 vary_smpos;\n";
    f += g.decl_fragcolor();
    f += "void main(void) {\n";
    f += "vec4 p = vary_smpos;\n";
    f += "  float pz = (p.z/p.w + 1.0) / 2.0;\n";
    f += "  float z = pz * 256.0;\n";/* [0.0, 256.0] */
    f += "  float z0 = floor(z);\n"; /* [0, 256] */
    f += "  z = (z - z0) * 256.0;\n"; /* [0.0, 256.0) */
    f += "  float z1 = floor(z);\n"; /* [0, 256) */
    f += "  z = (z - z1) * 256.0;\n"; /* [0.0, 256.0) */
    f += "  float z2 = floor(z);\n";  /* [0, 256) */
    f += g.fragcolor() + "= vec4(z0/255.0, z1/255.0, z2/255.0, 1.0);\n";
    f += "}\n";
  }
  return make_shader_ptr{shadowmap_uniforms, main_instance_attributes,
    shadowmap_vertex_attributes}(v, f, "model_matrix");
}

function zprepass_shader_ptr
init_zprepass_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", true);
  v += g.vert_in() + "vec3 position;\n";
  v += "void main(void) {\n";
  v += "vec4 gpos4 = " + g.instance_attr("model_matrix", true);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_Position = view_projection_matrix * gpos4;\n";
  v += "}\n";
  string f = g.empty_shader_frag();
  return make_shader_ptr{zprepass_uniforms, main_instance_attributes,
    zprepass_vertex_attributes}(v, f, "model_matrix");
}

function ds1st_shader_ptr
init_ds1st_shader(glconfig const g)
{
  const v = g.enable_deferred
    ? main_or_ds1st_shader_vert(g) : g.empty_shader_vert();
  string f;
  if (g.enable_deferred) {
    f += g.prepend();
    f += g.frag_in() + "vec3 vary_position;\n";
    f += g.frag_in() + "vec3 vary_normal;\n";
    f += g.frag_in() + "vec3 vary_tangent;\n";
    f += g.frag_in() + "vec3 vary_uvw;\n";
    if (g.is_gl3_or_gles3()) {
      f += "out vec3 ds_data[4];\n";
      f += "void main(void) {\n";
      f += "ds_data[0] = vary_position;\n";
      f += "ds_data[1] = vary_normal;\n";
      f += "ds_data[2] = vary_tangent;\n";
      f += "ds_data[3] = vary_uvw;\n";
      f += "}\n";
    } else {
      f += "void main(void) {\n";
      f += "gl_FragData[0].xyz = vary_position;\n";
      f += "gl_FragData[1].xyz = vary_normal;\n";
      f += "gl_FragData[2].xyz = vary_tangent;\n";
      f += "gl_FragData[3].xyz = vary_uvw;\n";
      f += "}\n";
    }
  } else {
    f += g.empty_shader_frag();
  }
  return make_shader_ptr{ds1st_uniforms, main_instance_attributes,
    ds1st_vertex_attributes}(v, f, "model_matrix");
}

function ds2nd_shader_ptr
init_ds2nd_shader(glconfig const& g)
{
  string v;
  if (g.enable_deferred) {
    v += g.prepend();
    v += g.vert_in() +  "vec2 position;\n";
    v += g.vert_out() + "vec2 vary_ds_coord;\n";
    v += "void main(void) {\n";
    v += "gl_Position = vec4(position, 0.5, 1.0);\n";
    v += "vary_ds_coord = (position + 1.0) * 0.5;\n";
    v += "}\n";
  } else {
    v += g.empty_shader_vert();
  }
  const f = g.enable_deferred
    ? main_or_ds2nd_shader_frag(g) : g.empty_shader_frag();
  return make_shader_ptr{ds2nd_uniforms, main_instance_attributes,
    ds2nd_vertex_attributes}(v, f, "");
}

function string
main_or_ds1st_shader_vert(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat4 shadowmap_vp;\n";
  v += g.decl_instance_id(true);
  v += g.decl_instance_attr("mat4", "model_matrix", true);
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec3 normal;\n";
  v += g.vert_in() + "vec3 tangent;\n";
  v += g.vert_in() + "vec3 uvw;\n";
  v += g.vert_out() + "vec3 vary_position;\n";
  v += g.vert_out() + "vec3 vary_normal;\n";
  v += g.vert_out() + "vec3 vary_tangent;\n";
  v += g.vert_out() + "vec3 vary_uvw;\n";
  if (!g.enable_deferred) {
    v += g.vert_out() + "vec3 vary_binormal;\n";
    if (g.enable_shadowmapping) {
      v += g.vert_out() + "vec4 vary_smpos;\n";
    }
  }
  v += "void main(void) {\n";
  v += "  vec4 gpos4 = " + g.instance_attr("model_matrix", true);
  v += "    * vec4(position, 1.0);\n";
  v += "  gl_Position = view_projection_matrix * gpos4;\n";
  if (g.is_gl3_or_gles3()) {
    v += "  mat3 normal_matrix = mat3(" + g.instance_attr("model_matrix", true)
      + ");\n";
  } else {
    v += "  mat4 mm = " + g.instance_attr("model_matrix", true) + ";\n";
    v += "  mat3 normal_matrix = mat3(mm[0].xyz, mm[1].xyz, mm[2].xyz);\n";
  }
  v += "  vary_position = gpos4.xyz / gpos4.w;\n";
  v += "  vary_normal = normal_matrix * normal;\n";
  v += "  vary_tangent = normal_matrix * tangent;\n";
  v += "  vary_uvw = uvw;\n";
  if (!g.enable_deferred) {
    v += "  vary_binormal = cross(vary_normal, vary_tangent);\n";
    if (g.enable_shadowmapping) {
      v += "  vary_smpos = shadowmap_vp * gpos4;\n";
    }
  }
  v += "}\n";
  return v;
}

function string main_or_ds2nd_shader_frag(glconfig const& g)
{
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += "uniform sampler2D sampler_tilemap;\n";
  if (g.enable_sampler2dshadow) {
    f += "uniform sampler2DShadow sampler_sm;\n";
  } else {
    f += "uniform sampler2D sampler_sm;\n";
  }
  f += "uniform vec3 camera_pos;\n";
  f += "uniform vec3 light_pos;\n";
  f += "uniform float light_on;\n";
  f += "uniform mat4 shadowmap_vp;\n";
  if (g.enable_deferred) {
    f += "uniform sampler2D sampler_ds0;\n";
    f += "uniform sampler2D sampler_ds1;\n";
    f += "uniform sampler2D sampler_ds2;\n";
    f += "uniform sampler2D sampler_ds3;\n";
    f += g.frag_in() + "vec2 vary_ds_coord;\n";
  } else {
    f += g.frag_in() + "vec3 vary_position;\n";
    f += g.frag_in() + "vec3 vary_normal;\n";
    f += g.frag_in() + "vec3 vary_tangent;\n";
    f += g.frag_in() + "vec3 vary_uvw;\n";
    f += g.frag_in() + "vec3 vary_binormal;\n";
    if (g.enable_shadowmapping) {
      f += g.frag_in() + "vec4 vary_smpos;\n";
    }
  }
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  if (g.enable_deferred) {
    f += "vec3 vary_position = ";
    f += g.texture2d() + "(sampler_ds0, vary_ds_coord).xyz;\n";
    f += "vec3 vary_normal = ";
    f += g.texture2d() + "(sampler_ds1, vary_ds_coord).xyz;\n";
    f += "vec3 vary_tangent = ";
    f += g.texture2d() + "(sampler_ds2, vary_ds_coord).xyz;\n";
    f += "vec3 vary_uvw = ";
    f += g.texture2d() + "(sampler_ds3, vary_ds_coord).xyz;\n";
    f += "vec3 vary_binormal = cross(vary_normal, vary_tangent);\n";
    if (g.enable_shadowmapping) {
      f += "vec4 vary_smpos = shadowmap_vp * vec4(vary_position, 1.0);\n";
    }
  }
  f += "vec3 light_dir = normalize(light_pos - vary_position);\n";
  f += "float light_distance = length(light_pos - vary_position);\n";
  f += "vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n";
  f += "vec4 color_dif = vec4(0.3, 0.3, 0.3, 1.0);\n";
  f += "float mate_ambient = 0.2;\n";
  f += "float mate_specular = 1.0;\n";
  if (g.enable_shadowmapping) {
    f += "vec4 smp = vary_smpos;\n";
    f += "vec3 smpos = ((smp.xyz / smp.w) + 1.0) * 0.5;\n";
    f += "float lflag = float(int(smpos.x <= 0.0) + int(smpos.x >= 1.0)";
    f += "  + int(smpos.y <= 0.0) + int(smpos.y >= 1.0) == 0);\n";
  } else {
    f += "float lflag = 1.0;\n";
  }
  f += "float lstr = lflag;\n";
  f += "float distbr = min(3000.0 / (light_distance * light_distance), ";
  f += "  light_on);\n";
  f += "vec3 nor = vary_normal;\n";
  if (g.enable_normalmapping) {
    f += "const float tile_size = 32.0;\n";
    f += "const float tilemap_size = 128.0;\n";
    f += "const float tiletex_size = 256.0;\n";
    f += "vec2 uv0 = vary_uvw.xy / vary_uvw.z;\n";
    f += "vec2 uv_tm = floor(uv0);\n";
	  /* tilemap coordinate */
    f += "vec2 uv_tmfr = uv0 - uv_tm;\n";
	  /* coordinate inside a tile (0, 1) */
    f += "vec2 uv_ti = uv_tmfr * tile_size;\n";
    f += "vec2 uvi = floor(uv_ti);\n";
	  /* coordinate inside a tile, integral */
    f += "vec2 uvj = uv_ti - uvi;\n";
	  /* subpixel coordinate */
    f += "vec4 ti = " +  g.texture2d();
    f += "  (sampler_tilemap, uv_tm / tilemap_size);\n";
	  /* lookup the tilemap */
    f += "vec2 uv_pixel = floor(ti.xy * 255.0 + 0.5) * tile_size + uvi;\n";
	  /* tile pattern coordinate */
    f += "mate_ambient = ti.z;\n";
    f += "mate_specular = ti.w;\n";
    f += "vec4 c0 = " + g.texture2d();
    f += "  (sampler, uv_pixel / tiletex_size);\n";
	  /* lookup the tilepattern */
    f += "float alv0 = floor(c0.a * 255.0 + 0.5);\n";
    f += "float avol = floor(alv0 / 16.0);\n";
    f += "int alv = int(alv0 - avol * 16.0);\n";
    f += "float lt = float(uvj.y - uvj.x >= 0.0);\n";
    f += "float lb = float(uvj.y + uvj.x <= 1.0);\n";
    f += "vec4 avlv = vec4(float(alv == 1), float(alv == 3), ";
    f += "  float(alv == 5), float(alv == 7));\n";
    f += "float ut1 = dot(avlv, vec4(-lt, 1.0-lb, 1.0-lt, -lb));\n";
    f += "float vt1 = dot(avlv, vec4(lt-1.0, -lb, lt, 1.0-lb));\n";
    f += "ut1 += float(alv == 4);\n";
    f += "vt1 -= float(alv == 2);\n";
    f += "avol = (avol - 8.0) * distbr * 0.2;\n";
    f += "color += vec4(c0.xyz, 0.0) * float(alv == 10);\n";
    f += "color_dif = vec4(c0.xyz, 0.0) * float(alv != 10);\n";
    f += "distbr *= float(alv != 10);\n";
    f += "nor += vary_tangent * ut1 * avol;\n";
    f += "nor += vary_binormal * vt1 * avol;\n";
    f += "nor = normalize(nor);\n";
  }
  f += "vec3 reflection_vec = reflect(-light_dir, nor);\n";
  f += "vec3 camera_dir = normalize(camera_pos - vary_position);\n";
  f += "float cos_angle = max(0.0, dot(camera_dir, reflection_vec));\n";
  f += "float specular = pow(cos_angle, 16.0);\n";
  f += "float diffuse = clamp(dot(light_dir, nor), 0.0, 1.0);\n";
  if (g.enable_shadowmapping) {
    if (g.enable_depth_texture) {
      if (g.enable_sampler2dshadow) {
	f += "smpos.z *= 0.9995;\n";
	if (g.enable_shadowmapping_multisample) {
	  f += "lstr = (";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(-0.0003,-0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(-0.0003,0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(0.0003,-0.0003,0.0)) +";
	  f += g.shadow2d() + "(sampler_sm, smpos+vec3(0.0003,0.0003,0.0)))";
	  if (!g.is_gl3_or_gles3()) {
	    f += ".r";
	  }
	  f += "  / 4.0;\n";
	} else {
	  f += "lstr = " + g.shadow2d() + "(sampler_sm, smpos)";
	  if (!g.is_gl3_or_gles3()) {
	    f += ".r";
	  }
	  f += ";\n";
	}
      } else {
	f += "float zval = " + g.texture2d();
	f += "   (sampler_sm, smpos.xy * lflag).x;\n";
	f += "lstr = float(smpos.z < zval * 1.0005) * lflag;\n";
      }
    } else {
      f += "vec4 smz = " + g.texture2d();
      f += "  (sampler_sm, smpos.xy * lflag);\n";
      f += "float z0 = floor(smz.r * 255.0 + 0.5);\n";
      f += "float z1 = floor(smz.g * 255.0 + 0.5);\n";
      f += "float z2 = floor(smz.b * 255.0 + 0.5);\n";
      f += "float zval = z0 * 65536.0 + z1 * 256.0 + z2;\n";
      f += "lstr = float(smpos.z * 16770000.0 < zval) * lflag;\n";
    }
    f += "color += (vec4(1.0, 1.0, 1.0, 1.0) * mate_specular ";
    f += "  * specular) * distbr * lstr;\n";
  }
  f += g.fragcolor() +  " = color + ";
  f += "  (color_dif * (diffuse * distbr * lstr + mate_ambient));\n";
  f += "}\n";
  return f;
}

function main_shader_ptr
init_main_shader(glconfig const& g)
{
  const v = g.enable_deferred
    ? g.empty_shader_vert() : main_or_ds1st_shader_vert(g);
  const f = g.enable_deferred
    ? g.empty_shader_frag() : main_or_ds2nd_shader_frag(g);
debug_log("main_shader", v);
  return
    make_shader_ptr{main_uniforms, main_instance_attributes,
      main_vertex_attributes}(v, f, "model_matrix");
}

function particle_shader_ptr
init_particle_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_id(false);
  v += g.decl_instance_attr("mat4", "model_matrix", false);
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += "void main(void) {\n";
  v += "gl_Position = " + g.instance_attr("model_matrix", false);
  v += "  * vec4(position, 1.0);\n";
  v += "gl_PointSize = point_size_base / gl_Position.w;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord * 2.0 - 1.0;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_shader_ptr{particle_uniforms, particle_instance_attributes,
    particle_vertex_attributes}(v, f, "model_matrix");
}

function particle_bb_shader_ptr
init_particle_bb_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_id(false);
  v += g.decl_instance_attr("mat4", "model_matrix", false);
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform mat3 camera_matrix;\n";
  v += "uniform float point_size_base;\n";
  v += g.vert_in() + "vec3 position;\n";
  v += g.vert_in() + "vec2 local_position;\n";
  v += g.vert_out() + "vec2 point_coord;\n";
  v += "void main(void) {\n";
  v += "vec4 pos = " + g.instance_attr("model_matrix", false);
  v += "  * vec4(position, 1.0);\n";
  v += "vec3 posb = camera_matrix";
  v += "  * vec3(local_position * point_size_base, 0.0);\n";
  v += "gl_Position = view_projection_matrix * vec4(pos.xyz + posb, 1.0);\n";
  v += "point_coord = local_position;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec2 point_coord;\n";
  f += "void main(void) {\n";
  f += "vec2 xy = point_coord;\n";
  f += "float d = dot(xy, xy);\n";
  f += "float b = max(0.0, 1.0 - d);\n";
  f += g.fragcolor() + " = vec4(b * 2.0, b * 4.0, b * 10.0, 1.0);\n";
  f += "}\n";
  return make_shader_ptr{particle_bb_uniforms, particle_instance_attributes,
    particle_bb_vertex_attributes}(v, f, "model_matrix");
}

function lineparticle_shader_ptr
init_lineparticle_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += g.decl_instance_id(false);
  v += g.decl_instance_attr("vec3", "position0", false);
  v += g.decl_instance_attr("vec3", "position1", false);
  v += g.decl_instance_attr("float", "point_size_base", false);
  v += "uniform mat4 view_projection_matrix;\n";
  v += "uniform vec2 screen_size_px;\n";
  v += g.vert_in() + "vec2 vert;\n";
  v += g.vert_out() + "vec3 vary_coord;\n";
  v += "void main(void) {\n";
  v += "vec4 p0p = view_projection_matrix * vec4("
    + g.instance_attr("position0", false) + ", 1.0);\n";
  v += "vec4 p1p = view_projection_matrix * vec4("
    + g.instance_attr("position1", false) + ", 1.0);\n";
  v += "vec2 p0 = p0p.xy * screen_size_px / p0p.w;\n";
  v += "vec2 p1 = p1p.xy * screen_size_px / p1p.w;\n";
  v += "vec2 pvec = p1 - p0;\n";
  v += "float plen = length(pvec);\n";
  v += "vec2 r = screen_size_px.x * "
    + g.instance_attr("point_size_base", false) + " / vec2(p0p.w, p1p.w);\n";
  v += "float rmx = max(r.x, r.y);\n";
  // v += "r = max(r, rmx - plen * 0.5);\n";
  v += "float rp = r.x + (r.y - r.x) * vert.x;\n";
  v += "vec2 qvec = normalize(vec2(-pvec.y, pvec.x)) * rp;\n";
  v += "float vx0 = (vert.x - 1.0) * r.x / plen;\n";
  v += "float vx1 = vert.x * r.y / plen;\n";
  v += "vec2 vert_m = vec2(vert.x + vx0 + vx1, vert.y);\n";
  v += "vec2 vpos = p0 + mat2(pvec, qvec) * vert_m;\n";
  v += "float pz0 = p0p.z / p0p.w;\n";
  v += "float pz1 = p1p.z / p1p.w;\n";
  v += "float pz = (pz0 + pz1) * 0.5;\n";
  v += "gl_Position = vec4(vpos / screen_size_px, pz, 1.0);\n";
  v += "vec2 c = vec2(vert.x - 0.5, vert.y) * 2.0;\n";
  v += "float rrat = r.y / r.x;\n";
  v += "float rrat_v = 1.0 + (rrat - 1.0) * vert.x;\n";
  v += "vary_coord = vec3(c, 1.0) * rrat_v;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += g.decl_fragcolor();
  f += g.frag_in() + "vec3 vary_coord;\n";
  f += "void main(void) {\n";
  f += "vec2 c = vary_coord.xy / vary_coord.z;\n";
  f += "float a = 1.0 - length(c);\n";
  f += g.fragcolor() + " = vec4(a * 2.0, a * 3.0, a * 4.0, 1.0);\n";
  f += "}\n";
  return make_shader_ptr{lineparticle_uniforms,
    lineparticle_instance_attributes, lineparticle_vertex_attributes}
    (v, f, "");
}

function font2_shader_ptr
init_font2_shader(glconfig const& g)
{
  string v;
  v += g.prepend();
  v += "uniform vec2 screen_size_px;\n";
  v += g.vert_in() + "vec2 texture_size_px;\n";
  v += g.vert_in() + "vec2 texture_origin_px;\n";
  v += g.vert_in() + "vec2 char_size_px;\n";
  v += g.vert_in() + "vec2 coord_clamp;\n";
  v += g.vert_in() + "float char_point_size;\n";
  v += g.vert_in() + "float text_index;\n";
  v += g.decl_instance_id(false);
  v += g.decl_instance_attr("mat4", "idata", false);
  v += g.vert_out() + "vec2 vary_texture_size_px;\n";
  v += g.vert_out() + "vec2 vary_texture_origin_px;\n";
  v += g.vert_out() + "vec2 vary_char_size_px;\n";
  v += g.vert_out() + "vec2 vary_coord_clamp;\n";
  v += g.vert_out() + "float vary_point_size;\n";
  v += "void main(void) {\n";
  v += "float idx_i_f = floor(text_index / 4.0);\n";
  v += "int idx_i = int(idx_i_f);\n";
  v += "int idx_j = int(text_index - idx_i_f * 4.0);\n";
  /* workaround for adreno gpu bug: split x[i][j] into xi = x[i] and xi[j] */
  v += "vec4 idata_i = " + g.instance_attr("idata", false) + "[idx_i];\n";
  v += "float ch = idata_i[idx_j];\n";
  v += "vec2 screen_pos = " + g.instance_attr("idata", false) + "[3].zw;\n";
  v += "vec2 screen_px = ";
  v += "  floor((screen_pos + 1.0) * screen_size_px * 0.5 + 0.5);\n";
  v += "screen_px += char_point_size * 0.5;\n";
  v += "screen_px.x += char_size_px.x * text_index;\n";
  v += "screen_pos = screen_px / screen_size_px * 2.0 - 1.0;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "gl_PointSize = char_point_size;\n";
  v += "vary_texture_size_px = texture_size_px;\n";
  v += "vary_texture_origin_px = texture_origin_px";
  v += "  + vec2(char_size_px.x * ch, 0.0);\n";
  v += "vary_char_size_px = char_size_px;\n";
  v += "vary_coord_clamp = coord_clamp;\n";
  v += "vary_point_size = char_point_size;\n";
  v += "}\n";
  string f;
  f += g.prepend();
  f += "uniform sampler2D sampler;\n";
  f += g.frag_in() + "vec2 vary_texture_size_px;\n";
  f += g.frag_in() + "vec2 vary_texture_origin_px;\n";
  f += g.frag_in() + "vec2 vary_char_size_px;\n";
  f += g.frag_in() + "vec2 vary_coord_clamp;\n";
  f += g.frag_in() + "float vary_point_size;\n";
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += "vec2 xy = gl_PointCoord;\n";
  f += "if (xy.x > vary_coord_clamp.x) { discard; }\n";
  f += "vec2 pcoord = vary_point_size * xy;\n";
  f += "vec2 texcoord = (vary_texture_origin_px + pcoord)";
  f += "  / vary_texture_size_px;\n";
  f += "vec4 col = " +  g.texture2d() + "(sampler, texcoord);\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 1.0, col.a);\n";
  f += "}\n";
  return make_shader_ptr{font2_uniforms, font2_instance_attributes,
    font2_vertex_attributes}(v, f, "idata");
}

function uint read_3_uint(cslice{uchar} const& buf, size_t o)
{
  /* FIXME: endianness */
  uint v;
  v += buf[o+2]; v *= 256;
  v += buf[o+1]; v *= 256;
  v += buf[o+0];
  return v;
}
function void write_4_uint(slice{uchar} const& buf, size_t o, uint val)
{
  /* FIXME: endianness */
  buf[o+3] = static_cast{uchar}(val >> 24);
  buf[o+2] = static_cast{uchar}(val >> 16);
  buf[o+1] = static_cast{uchar}(val >>  8);
  buf[o+0] = static_cast{uchar}(val);
}

function void
init_texture(main_texture_info mutable& mti, font_texture_info mutable& fti)
{
  {
    /* font */
    const fnames = make_farray{string}(
      "mplus-1m-bold.ttf",
      "/Library/Fonts/Osaka.ttf",
      "/usr/share/fonts/mplus/mplus-1m-bold.ttf",
      "/usr/share/fonts/liberation/LiberationMono-Regular.ttf");
    option{ptr{TTF_Font}} font;
    for (size_t i, const& fn: fnames) {
      font = TTF_OpenFont(fn, 30);
      if (case font.some) {
	break;
      }
    }
    SDL_Color mutable fg;
    fg.r = 255;
    fg.g = 255;
    fg.b = 255;
    fg.a = 255;
    uint hmax = 0;
    uint wmax = 0;
    // uint wtotal = 0;
    varray{ptr{SDL_Surface}} sur_arr;
    for (const i: 0 .. 0x60) {
      farray{uchar, 1} z;
      z[0] = static_cast{uchar}(i + 0x20);
      const sur = TTF_RenderUTF8_Blended(font.some, z, fg).some;
      /* println(z, sur.W(), sur.H()); */
      sur_arr.push_back(sur);
      hmax = max(hmax, sur.H());
      wmax = max(wmax, sur.W());
    }
    const sur_chars = SDL_CreateRGBSurface(
      cast_int(power_of_2(wmax * 0x60)),
      cast_int(power_of_2(hmax)), 32, 0, 0, 0, 0).some;
    println("wmax, hmax", wmax, hmax);
    fti.char_x.clear();
    uint xcur = 0;
    for (const i, const e: sur_arr) {
      SDL_Rect r0;
      SDL_Rect r1;
      r0.x = 0;
      r0.y = 0;
      r0.w = cast_int(e.W());
      r0.h = cast_int(e.H());
      r1.x = cast_int(xcur);
      r1.y = 0;
      r1.w = r0.w;
      r1.h = r1.h;
      const v = SDL_BlitSurface(e, r0, sur_chars, r1);
      xcur += cast_uint(wmax);
      fti.char_x.push_back(xcur);
    }
    fti.char_w = wmax;
    fti.char_h = hmax;
    fti.surface_w = sur_chars.W();
    fti.surface_h = sur_chars.H();
    const sur = sur_chars;
    const sur_chars_buf = sur_chars.Pixels();
    for (const x: 0 .. sur_chars.W()) {
      for (const y: 0 .. sur_chars.H()) {
	const i = (y * sur_chars.W() + x) * 4;
	sur_chars_buf[i+0] = 255;
	sur_chars_buf[i+1] = 255;
	sur_chars_buf[i+2] = 255;
      }
    }
    /* font texture */
    glActiveTexture(GL_TEXTURE0);
    fti.font_texture_id.generate();
    println("font_texture_id", fti.font_texture_id.get());
    glBindTexture(GL_TEXTURE_2D, fti.font_texture_id.get());
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA),
      cast_int(sur.W()), cast_int(sur.H()),
      0, GL_RGBA, GL_UNSIGNED_BYTE, sur.Pixels().crawptr().void());
    /*
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_LINEAR));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_LINEAR));
    */
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
    /*
    */
    fti.text_vbo.generate();
    if (fti.text_vbo.get() == 0) {
      throw runtime_error_template{"text_vbo"}("1");
    }
  }
  {
    // const sur = IMG_Load("img-c1024.jpg").some;
    const sur0 = IMG_Load("dpat.png").some;
    const bpp = sur0.BytesPerPixel();
    if (bpp != 4 && bpp != 3) {
      throw runtime_error_template{"img_load"}("1");
    }
    const sur0_w = sur0.W();
    const sur0_h = sur0.H();
    mutable tex_w = power_of_2(sur0_w);
    mutable tex_h = power_of_2(sur0_h);
    varray{uint} uibuf;
    uibuf.resize(tex_w * tex_h, 0);
    uint rmask;
    uint gmask;
    uint bmask;
    uint amask;
    sur0.Masks(rmask, gmask, bmask, amask);
    function uint get_shift(uint m) {
      uint r = 0;
      for (uint i: 0 .. 32) {
	if ((m & 1) != 0) {
	  break;
	}
	r += 1;
	m >>= 1;
      }
      return r;
    }
    uint rshift = get_shift(rmask);
    uint gshift = get_shift(gmask);
    uint bshift = get_shift(bmask);
    uint ashift = get_shift(amask);
    /*
    println("Masks", rmask, gmask, bmask, amask, rshift, gshift, bshift,
      ashift);
    */
    const sur0buf = sur0.Pixels();
    for (const by: 0 .. sur0_h / 64) {
      for (const iy: 0 .. 32U) {
	for (const x: 0 .. sur0_w) {
	  const o0n = ((by * 64 + iy     ) * sur0_w + x) * bpp;
	  const o0c = ((by * 64 + iy + 32) * sur0_w + x) * bpp;
	  const o1 = ((by * 32 + iy) * tex_w + x) * 4;
	  const nor0 = read_3_uint(sur0buf, o0n);
	  const col0 = read_3_uint(sur0buf, o0c);
	  uint norr = (nor0 >> rshift) & 0xffU;
	  uint norg = (nor0 >> gshift) & 0xffU;
	  uint norb = (nor0 >> bshift) & 0xffU;
	  const nor = (norr << 16) | (norg << 8) | norb;
	  uint colr = (col0 >> rshift) & 0xffU;
	  uint colg = (col0 >> gshift) & 0xffU;
	  uint colb = (col0 >> bshift) & 0xffU;
	  const col = (colb << 16) | (colg << 8) | colr;
	  uint val; /* avol for higher 4bits, alv for lower 4bits */
	  if (nor == 0xff0000) {
	    val = 0x91; /* convex left-upper */
	  } else if (nor == 0x00ff00) {
	    val = 0x92; /* convex upper, or concave lower */
	  } else if (nor == 0xffff00) {
	    val = 0x93; /* convex right-upper */
	  } else if (nor == 0x0000ff) {
	    val = 0x94; /* convex right, or concave left */
	  } else if (nor == 0xff00ff) {
	    val = 0x95; /* convex right-lower */
	  } else if (nor == 0x00ffff) {
	    val = 0x72; /* convex lower, or concave upper */
	  } else if (nor == 0xffffff) {
	    val = 0x97; /* convex left-lower */
	  } else if (nor == 0x808080) {
	    val = 0x74; /* convex left, or concave right */
	  } else if (nor == 0xc04040) {
	    val = 0x71; /* concave left-upper */
	  } else if (nor == 0xc0c040) {
	    val = 0x73; /* concave right-upper */
	  } else if (nor == 0xc040c0) {
	    val = 0x75; /* concave right-lower */
	  } else if (nor == 0xc0c0c0) {
	    val = 0x77; /* concave left-lower */
	  } else if (nor == 0x8080c0) {
	    val = 0x0a; /* emission */
	  }
	  uibuf[(by * 32 + iy) * tex_w + x] = (val << 24) | col;
	}
      }
    }
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE1);
    mti.main_texture_id.generate();
    glBindTexture(GL_TEXTURE_2D, mti.main_texture_id.get());
    /*
    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, cast_int(GL_TRUE));
    */
    int mipmap_level = 0;
    while (true) {
      glTexImage2D(GL_TEXTURE_2D, mipmap_level, cast_int(mode),
	cast_int(tex_w), cast_int(tex_h),
	0, mode, GL_UNSIGNED_BYTE, uibuf.crawptr().void());
      const tex_w_prev = tex_w;
      const tex_h_prev = tex_h;
      tex_w /= 2;
      tex_h /= 2;
      // if (tex_w == 0 || tex_h == 0 || mipmap_level >= 5) {
      if (tex_w == 0 || tex_h == 0 || mipmap_level >= 0) {
	break;
      }
      ++mipmap_level;
      for (const y: 0 .. tex_h) {
	for (const x: 0 .. tex_w) {
	  farray{uint, 4} v;
	  v[0] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 0)];
	  v[1] = uibuf[(y * 2 + 0) * tex_w_prev + (x * 2 + 1)];
	  v[2] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 0)];
	  v[3] = uibuf[(y * 2 + 1) * tex_w_prev + (x * 2 + 1)];
	  uint mutable val_b;
	  uint mutable val_g;
	  uint mutable val_r;
	  size_t opaque_count = 0;
	  for (size_t j: 0 .. 4) {
	    val_b += (v[j] >> 16) & 0xff;
	    val_g += (v[j] >>  8) & 0xff;
	    val_r += (v[j] >>  0) & 0xff;
	    if (((v[j] >> 24) & 0x0f) == 10) { ++opaque_count; }
	  }
	  val_b /= 4;
	  val_g /= 4;
	  val_r /= 4;
	  const val_a = opaque_count > 0 ? 10U : (v[0] >> 24) & 0xff; // TODO
	  /*
	  uibuf[y * tex_w + x] = (val_a << 24) +
	    (val_b << 16) + (val_g << 8) + (val_r << 0);
	  uibuf[y * tex_w + x] = v[0];
	  */
	}
      }
    }
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(mipmap_level > 0 ? GL_NEAREST_MIPMAP_NEAREST : GL_NEAREST));
    mti.surface_w = tex_w;
    mti.surface_h = tex_h;
    if (m::ne{is_gl3_or_gles3, 0}) {
      if (mipmap_level != 0) {
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, mipmap_level);
      }
    }
  }
  {
    /* tile map */
    const sur1 = SDL_CreateRGBSurface(128, 128, 32, 0, 0, 0, 0).some;
    const sur1_w = sur1.W();	
    const sur1_h = sur1.H();	
    const sur1buf = sur1.Pixels();
    const rnd = make_rand_generator(333U);
    for (const y: 0 .. sur1_h) {
      for (const x: 0 .. sur1_w) {
	const o1 = (y * sur1_w + x) * 4;
	const v0 = rnd->generate() / 65536;
	const v1 = v0 % 8;
	const v2 = (v0 / 8) % 8;
	const uint specular_ambient = 0xff60;
	if (x == 0 && y == 0) {
	  write_4_uint(sur1buf, o1, specular_ambient << 16);
	} else {
	  write_4_uint(sur1buf, o1, (v1 % 8) | specular_ambient << 16);
	}
      }
    }
    println("sur1buf", sur1_w, sur1_h);
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE2);
    mti.tilemap_texture_id.generate();
    glBindTexture(GL_TEXTURE_2D, mti.tilemap_texture_id.get());
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(mode),
      cast_int(sur1.W()), cast_int(sur1.H()),
      0, mode, GL_UNSIGNED_BYTE, sur1.Pixels().crawptr().void());
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
  }
}

public function void sdllog(cstrref const& mess)
{
  SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, mess);
}

public struct
pglshader(bool gles_flag0, int glmajor0, int glminor0, bool enable_msaa0,
  int width0, int height0)
{
  public glconfig glc = glconfig(gles_flag0, glmajor0, glminor0,
    enable_msaa0);
  public main_shader_ptr const sdr = init_main_shader(glc);
  public shadowmap_shader_ptr const smsdr = init_shadowmap_shader(glc);
  public zprepass_shader_ptr const zpsdr = init_zprepass_shader(glc);
  public ds1st_shader_ptr const ds1sdr = init_ds1st_shader(glc);
  public ds2nd_shader_ptr const ds2sdr = init_ds2nd_shader(glc);
  public particle_shader_ptr const spsdr = init_particle_shader(glc);
  public particle_bb_shader_ptr const prtbsdr = init_particle_bb_shader(glc);
  public lineparticle_shader_ptr const lpsdr = init_lineparticle_shader(glc);
  public font2_shader_ptr const f2sdr = init_font2_shader(glc);
  public shadowmap_fbo sfbo;
  public deferred_shading_fbo dsfbo;
  public main_texture_info mti;
  public font_texture_info fti;
  public projection_info cam;
  public varray{ptr{vertex_buffer}} vertex_buffers;
  private auto_vertexarray vtxarr;
  public instance_buffer_type global_ibuffer;
  init();
  resize_screen(width0, height0);
  private function void init()
  {
    if (m::ne{is_gl3_or_gles3, 0}) {
      vtxarr.generate();
      glBindVertexArray(vtxarr.get());
      println("glBindVertexArray", vtxarr.get());
    }
    /*
    if (m::ne{is_gl3_or_gles3, 0}) {
      global_ibuffer.vbo_inst.generate();
    }
    */
    if (m::eq{is_gles, 0}) {
      farray{float, 2} arr;
      float step;
      glGetFloatv(GL_POINT_SIZE_RANGE, arr.rawptr());
      glGetFloatv(GL_POINT_SIZE_GRANULARITY, address(step));
      println("GL_POINT_SIZE_RANGE", arr, step);
    }
    init_texture(mti, fti);
    /*
    if (m::ne{is_gl3_or_gles3, 0}) {
      if (glc.enable_msaa) {
	glEnable(GL_MULTISAMPLE);
      }
    }
    */
    if (m::eq{is_gles, 0}) {
      if (!glc.is_gl3_or_gles3()) {
	glEnable(GL_POINT_SPRITE);
	println("GL_POINT_SPRITE enabled");
      }
      glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
    }
    vertex_buffers.push_back(make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{main_vertex_attributes}), false));
    vertex_buffers.push_back(make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{particle_vertex_attr}), true));
    vertex_buffers.push_back(make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{particle_bb_vertex_attr}), false));
    vertex_buffers.push_back(make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{font2_vertex_attributes}), true));
    vertex_buffers.push_back(make_ptr{vertex_buffer}
      (static_cast{size_t}(num_float_struct{lineparticle_vertex_attributes}),
	false));
  }
  public function void prepare_vertex_buffers()
  {
    const enable_copying_instancing = !glc.enable_instanced;
    for (const i, const& bo: vertex_buffers) {
      bo->create_vbo(enable_copying_instancing);
    }
  }
  public function joint_id_type find_joint_id_by_name(cstrref const& name)
  {
    joint_id_type scene_id;
    for (const i, const& bo: vertex_buffers) {
      if (bo->has_name(name)) {
        scene_id.bo_id = i;
        scene_id.vs_id = static_cast{int}(bo->get_id_by_name(name));
        break;
      }
    }
    return scene_id;
  }
  public function ptr{vertices} make_vertices(size_t bo_id,
    cstrref const& name)
  {
    return vertex_buffers[bo_id]->get(name)->vtxs;
  }
  public function {tnodedata, tinit} ptr{scene_node{tnodedata}}
  make_node(joint_id_type const& scene_id, glm::mat4 const& trans)
  {
    return instantiate_scene{tnodedata, tinit}(vertex_buffers, scene_id,
      trans);
  }
  public function void resize_screen(int width, int height)
  {
    cam.screen_width = width;
    cam.screen_height = height;
    if (m::ne{is_gles, 0}) {
      sfbo.sm_width = 1024;
      sfbo.sm_height = 1024;
    } else {
      sfbo.sm_width = width;
      sfbo.sm_height = height;
    }
    init_shadowmap_fbo(glc, sfbo);
    dsfbo.ds_width = width;
    dsfbo.ds_height = height;
    init_deferred_shading_fbo(glc, dsfbo);
    update_mvp(cam);
  }
}

