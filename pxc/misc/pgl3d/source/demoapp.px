public namespace demoapp;
public import common -;
public import exception -;
public import numeric::fpmath -;
public import pointer::raw -;
public import meta m;
public import glm;
public import text::positional -;
public import io::time -;
public import fundamental::mainloop -;
public import pgl3d::engine::application -;
public import pgl3d::engine::mainloop -;
public import pgl3d::engine::util -;
public import pgl3d::engine::platform -;
public import pgl3d::engine::input_control -;
public import pgl3d::engine::pglconfig -;
public import pgl3d::engine::nvidia_optimus_switch;
public import pgl3d::opengl::glvertex -;
public import pgl3d::texture::texture -;
public import pgl3d::texture::voxel_surface -;
public import pgl3d::geometry::funcs -;
public import pgl3d::drawer::drawer -;
public import pgl3d::physics::collision_shape -;
public import pgl3d::physics::collision_voxel -;
public import pgl3d::physics::dynamics_world -;
public import pgl3d::sdl::sdlutil -;
public import pgl3d::geometry::wfobj -;
public import io::environ;
public import debug_helper -;
public import pgl3d::aux::d3axim -;
public import pgl3d::aux::enumerate_device -; // FIXME
public import pgl3d::aux::motion_controller -;

// public import pgl3d::texture::generator -;
// public import pgl3d::numeric::interpolation -; // FIXME
public import demoapp::texture::triangles_texture -; // FIXME

// public import pgl3d::bullet_test -;
// public import KnightModel -; // FIXME
// public import pgl3d::grid_broadphase -; // FIXME
// FIXME: projection_infoではなくscreen_infoだけ渡すように
// public import pushtest -;

// FIXME
if (false) {
  function float distr(float alpha, float cos_n_h)
  {
    const alpha2 = alpha * alpha;
    float den = cos_n_h * cos_n_h * (alpha2 - 1.0f) + 1.0f;
    float distr = alpha2 / (3.141592f * den * den);
    return distr;
  }
  float alpha = 0.0;
  for (; alpha <= 5.0; alpha = alpha + 0.1f) {
    float d = distr(alpha, 1.0f);
    float d2 = distr(alpha, 0.98f);
    float d3 = distr(alpha, 0.9f);
    debug_log(alpha, d, d2, d3);
  }
}

load_filesystem_async{app_main}("/persist"); // emscripten

public function void app_main()
{
  set_debug_log_file("var/demoapp.log");
  set_debug_timestamp(true);

  // debug_helper::dump_modules();
  // debug_helper::dump_backtrace();
  string config_fn = "res/pgl3d.cnf";
  if (io::environ::argv.size() > 1) {
    config_fn = io::environ::argv[1];
  }
  debug_log("config_fn", config_fn);
  /*
  if (true) {
    ulonglong x = 893682657u;
    debug_log("ulong x", x);
    x <<= 5u;
    debug_log("ulong x", x);
    x >>= 5u;
    debug_log("ulong x", x);
  }
  */
  if (false) {
    // FIXME
    /*
    const points = make_varray{float}(0.0, 1.0, 3.0, 1.0, 0.0);
    const spl = cubic_b_spline(points, 0.0f, 1.0f);
    for (const i: 0 .. 9) {
      float x = static_cast{float}(i) * 0.5f;
      float y = spl(x);
      debug_log("spl", x, y);
    }
    */
    /*
    texture_data tex;
    tex.set_size_l2(5u, 5u, 5u);
    generate_rand_spline(make_rand_generator(999123u), tex, 16);
    debug_log("generate_rand_spline done");
    */
    return;
  }
  if (false) {
    const rnd = make_rand_generator(99987124u);
    string s = "";
    for (const i: 0 .. 16u) {
      uint v = (rnd->generate() >> 20u) & 0x0fu;
      s += "," + to_string(v);
    }
    debug_log("s=", s);
  }
  pgl3d::engine::mainloop::mainloop(make_ptr{demoapp_application}(),
    config_fn);
}

public struct demoapp_application()
  <pgl3d_application>
{	
  public app_demoapp app;
  public function varray{ptr{pgldrawer_export_i}} on_init_drawstep(
    shader_config const& conf, drawer_shared const& ds)
  {
    debug_log("init_drawstep");
    app.sconf.some = make_ptr{shader_config}(conf);
    const r = init_drawsteps(app, conf, ds);
    app.option_value2 = static_cast{float}(
      conf.conf.get("option_value2", -1, -1, 9));
      // edit modeでは0にしないとカーソルが見えないので注意(miplevel)
    debug_log("init_drawstep done");
    const ser_name = conf.conf.get("motion_serial", string(), string(),
      string());
    if (!ser_name.empty()) {
      varray{device_info} devs;
      enumerate_device(devs);
      for (const i, const e: devs) {
        if (e.port_name[0u .. 3u] == "COM") {
          debug_log("device", e);
          if (e.name == ser_name) {
            debug_log("found serial");
            const port_str = e.port_name[3u .. e.port_name.size()];
            const port_num = from_string{uint}(port_str);
            app.mctrl.some = make_ptr{motion_controller_serial}(port_num);
            break;
          }
        }
      }
    }
    return r;
  }
  public function void on_build_vertices(make_vertices_i mutable& mvx)
  {
    debug_log("build_vertices");
    build_vertices(app, mvx);
    debug_log("build_vertices done");
    prepare_vbids(app.scene_shared->rdi, mvx, app.raycast_layer);
    app.scene_shared->tvt.some = app.tvt;
    app.scene_shared->tup.some = app.tup;
  }
  public function void on_event(SDL_Event const& ev, app_ctrl_i mutable& actrl,
    float speed)
  {
    handle_event(app, actrl, ev, speed);
  }
  public function void on_joystick_changed(cslice{joystick_info} const& ji)
  {
    app.player_joystick.axes.resize(6, 0);
    app.player_joystick.buttons.resize(15, false);
    app.player_joystick.hats.resize(0, 0);
  }
  public function void on_scankeys(cslice{uchar} const& keys,
    cslice{joystick_state} const& joysticks, float speed)
  {
    app.modmask = 0;
    if (keys[static_cast{uint}(SDL_SCANCODE_LSHIFT)] != 0) {
      app.modmask |= 1;
    }
    if (keys[static_cast{uint}(SDL_SCANCODE_RSHIFT)] != 0) {
      app.modmask |= 2;
    }
    if (keys[static_cast{uint}(SDL_SCANCODE_LCTRL)] != 0) {
      app.modmask |= 4;
    }
    if (keys[static_cast{uint}(SDL_SCANCODE_RCTRL)] != 0) {
      app.modmask |= 8;
    }
    handle_keys(app, keys, joysticks, speed);
    // debug_log("joy", joy_axes, "btn", joy_buttons);
  }
  public function tptr{pgl3d_scene_shared} get_scene_shared()
  {
    return app.scene_shared;
  }
  public function void on_frame()
  {
    // debug_log("app on_frame");
    mutable& tup = *app.tup;
    // debug_log("app on_frame 1");
    for (const i, const& e: tup) {
      // debug_log("tup", e.pos, e.value);
      if (case app.edit_mode.some) {
	app.edit_mode.some->modify_tmap(e.pos, e.value);
      }
    }
    // debug_log("app on_frame 2");
    tup.clear();
    // debug_log("app on_frame 3");
    if (case app.edit_mode.some) {
      // const t0 = sdl_get_ticks();
      app.edit_mode.some->on_frame(*app.proj_pm);
      // const t1 = sdl_get_ticks();
      // if (t0 != t1) {
      //   debug_log("(no)edit_mode on frame", t1 - t0);
      // }
    }
    // debug_log("app on_frame done");
  }
  public function void on_motion_pre()
  {
    // motion threadからmain threadへ情報を移動する際に呼ばれる。
    // ssはロックされた状態で呼ばれるのでアクセスしても待たされない。
    // projection_infoをproj_pmからmotion threadへコピーする
    mutable& pj = app.scene_shared->pj_drawing_frame;
    pj = *app.proj_pm;
  }
  public function void on_motion_post()
  {
    // motion threadからmain threadへ情報を移動する際に呼ばれる。
    // ssはロックされた状態で呼ばれるのでアクセスしても待たされない。
    // proj_dfをmotion threadのpj_drawing_frameからコピーする
    const& pj = app.scene_shared->pj_drawing_frame;
    *app.proj_df = pj;
    app.dp_fxaa->option_value = 0.0; // pj.option_value;
    app.dp_blur->option_value = 0.0; // pj.option_value;
    app.dp_ssao->option_value = pj.option_value;
    /*
    *app.pviewport_main = glm::make_uvec2(
      static_cast{uint}(pj.display_width),
      static_cast{uint}(pj.display_height));
    *app.pviewport_sm = glm::make_uvec2(
      static_cast{uint}(pj.shadowmap_size),
      static_cast{uint}(pj.shadowmap_size));
    */
  }
  private uint axi_addr;
  public function void on_draw_finished()
  {
    if (!app.capt_data->empty()) {
      if (app.axim.is_valid()) {
        {
          mutable& d = *app.capt_data;
          for (uint y: 719 .. 720) {
            for (uint x: 0 .. 1280) {
              const addr = y * 1280 + x;
              d[addr * 2] = 255;
              d[addr * 2 + 1] = 255;
            }
          }
        }
        // debug_log("axi read pre");
        varray{uchar} buf;
        app.axim.axi_read(0x44a00000, 4u, buf);
          // vsyncを待ちバッファのアドレスを得る
        // debug_log("axi read post", buf.size());
        if (buf.size() != 4) {
          axi_addr = 0x18000000;
        } else {
          uint addr =
            (buf[3] << 24u) | (buf[2] << 16u) | (buf[1] << 8u) | buf[0];
          axi_addr = addr;
        }
        // debug_log("addr", axi_addr);
        if (axi_addr != 0) {
          app.axim.axi_write(axi_addr, *app.capt_data);
        }
      }
    }
  }
}

private multithreaded struct raycast_object()
{
  public joint_id_type joint_id;
  public float radius = 1.0f; // 物体の外接球の半径
  public glm::mat4 model_matrix = mat4_identity();
  public glm::vec3 relative_pos; // カメラからみた座標
  public bool near_flag;
}

private multithreaded struct raycast_drawers_info()
{
  public varray{vbid_t} subdrawer_vbids;
  public vbid_t subdrawer_vbid_min;
  public vbid_t subdrawer_vbid_max;
  public tree_map{string, joint_id_type} name_to_joint_id;
  public tree_map{joint_id_type, float} vs_radius;
}

private multithreaded struct raycast_objects()
{
  // raycastシェーダのために必要なフレーム毎の処理をするための構造体
  public float haov_tan = 0.0f; // カメラの半画角のtangent
  public glm::vec2 dv_xz;
  public glm::vec2 du_xz;
  public varray{raycast_object} objects;
  public tree_multimap{float, uint} nearest_objects;
  public function void set_perspective(perspective const& pers)
  {
    const w = pers.width;
    const h = pers.height;
    haov_tan = sqrt(w * w + h * h) / fabs(pers.near);
      // 半画角のtangent
    dv_xz = glm::make_vec2(haov_tan, 1.0f).normalize();
      // 円錐がy=0に接する半直線(x,zともに正のがわ)の単位ベクトル
    du_xz = glm::make_vec2(dv_xz.y, -dv_xz.x);
      // dvから時計回りに90度。右下方向。
  }
  public function void clear_objects()
  {
    objects.clear();
    nearest_objects.clear();
  }
  public function bool push_object(raycast_drawers_info const& rdi,
    projection_info const& cam, scene_node const& sn)
  {
    raycast_object obj;
    obj.joint_id = sn.joint_id;
    if (const& rad: rdi.vs_radius[sn.joint_id]) {
      obj.radius = rad;
    } else {
      debug_log("raycast_objects: push_object: unknown join_id", sn.joint_id);
    }
    const& trns = sn.trans.value;
    obj.model_matrix = trns;
    if (obj.radius < 10.0f) {
      // 小さいオブジェクトはnearestには入れない
      objects.push_back(obj);
      return true;
    }
    const& s = trns.to_cslice();
    // debug_log("trans", s);
    const pos = glm::make_vec4(s[12], s[13], s[14], 1.0f);
    const relpos = cam.view * pos;
    obj.relative_pos = glm::make_vec3(relpos.x, relpos.y, -relpos.z);
    // 視錐台に接するかどうかを大雑把に判定する
    // 相対位置relposをxy平面上で回転させてy=0に下ろした点Bのxz座標を計算
    // zを反転させ、手前を負値にする。
    const relpos_xz = glm::make_vec2(relpos.x, relpos.y);
    const posb_xz = glm::make_vec2(glm::length(relpos_xz), -relpos.z);
    // 円錐に垂線を下す
    const b_dv = glm::dot(posb_xz, dv_xz); // 右上
    const b_du = glm::dot(posb_xz, du_xz); // 右下
    const dist_b = b_dv > 0.0f ? b_du : glm::length(posb_xz); 
      // 円錐の正の部分とrelposとの距離
    if (dist_b > obj.radius) {
      /*
      debug_log("cull rel", obj.relative_pos, "dist", dist_b, "rad",
        obj.radius, sn.joint_id);
      */
      return false;
    }
    /*
    debug_log("show rel", obj.relative_pos, "dist", dist_b, "rad",
      obj.radius, sn.joint_id);
    */
    uint i = static_cast{uint}(objects.size());
    objects.push_back(obj);
    nearest_objects.insert(posb_xz.y, i);
    return true;
  }
  public function void prepare_instances(node_common_data mutable& ncd,
    raycast_drawers_info const& rdi,
    cslice{prepare_instance_data_funcptr} const& ftable,
    whole_instances_type mutable& whole_instances)
  {
    scene_node mutable sn = scene_node(joint_id_type(), mat4_identity());
    uint const ndr = static_cast{uint}(
      rdi.subdrawer_vbid_max - rdi.subdrawer_vbid_min) + 1;
    threaded function void extend_whole_instances(vbid_t vbid, vsid_t vsid)
    {
      if (whole_instances.size() <= static_cast{size_t}(vbid)) {
	whole_instances.resize(static_cast{size_t}(vbid) + 1,
	  bo_instances_type());
      }
      mutable& boi = whole_instances[vbid];
      if (boi.size() <= static_cast{size_t}(vsid)) {
	boi.resize(static_cast{size_t}(vsid) + 1, instance_data());
      }
    }

    // 近くて大きいオブジェクトを、先に描画するsubdrawer向けインスタンス
    // リストに入れる。近くて大きいsubdrawer-1個のオブジェクトはそれぞれ
    // 固有のsubdrawerで順に描画される。残りのオブジェクトは同じsubdrawer
    // でまとめて描画される。
    size_t cur = rdi.subdrawer_vbids.size() - 1;
    for (float z, const& idx: nearest_objects) {
      mutable& obj = objects[idx];
      obj.near_flag = true;
      const vbid_t vbid = rdi.subdrawer_vbids[cur];
      const vsid_t vsid = obj.joint_id.vsid;
      sn.joint_id.vbid = vbid;
      sn.joint_id.vsid = vsid;
      sn.trans.value = obj.model_matrix;
      if (vbid != vbid_invalid() && vsid != vsid_invalid()) {
	/*
	debug_log("prepare_instance_data_ft_rec near instance vbid=", vbid,
	  "vsid=", vsid, "cur=", cur, "z=", z);
	*/
	extend_whole_instances(vbid, vsid);
	mutable& idata = whole_instances[vbid][vsid];
	ftable[vbid](sn, ncd, idata);
	// debug_log("inserted idata", idata.instance_buffer.size());
      }
      // ssubtype=1は小さいオブジェクト用。
      // ssubtype>1は大きいオブジェクト用で、large_shadow=0のとき影は差さない。
      if (cur > 2) {
	--cur;
      }
    }
    // 小さいオブジェクトはssubtype=1のdrawerで書く。影を差す。
    cur = 1;
    for (const i, const& obj: objects) {
      if (obj.near_flag) {
	continue;
      }
      const vbid_t vbid = rdi.subdrawer_vbids[cur];
      const vsid_t vsid = obj.joint_id.vsid;
      sn.joint_id.vbid = vbid;
      sn.joint_id.vsid = vsid;
      sn.trans.value = obj.model_matrix;
      if (vbid != vbid_invalid() && vsid != vsid_invalid()) {
	/*
	debug_log("prepare_instance_data_ft_rec far instance vbid=", vbid,
	  "vsid=", vsid, "cur=", cur);
	*/
	extend_whole_instances(vbid, vsid);
	mutable& idata = whole_instances[vbid][vsid];
	ftable[vbid](sn, ncd, idata);
	// debug_log("inserted idata", idata.instance_buffer.size());
      }
    }
  }
}

private function void prepare_vbids(raycast_drawers_info mutable& rdi,
  make_vertices_i mutable& pgs, int raycast_layer)
{
  rdi.subdrawer_vbids.clear();
  rdi.subdrawer_vbid_min = 0;
  rdi.subdrawer_vbid_max = 0;
  uint const num_subdrawers = static_cast{uint}(raycast_layer);
  for (uint i : 0 .. num_subdrawers) {
    string s = "vbid_triangles_1_" + to_string(i);
    const vbid = pgs.get_vbid(s);
    if (vbid == vbid_invalid()) {
      break;
    }
    debug_log("prepare_vbids: found", s, vbid);
    rdi.subdrawer_vbids.push_back(vbid);
    if (i == 0u) {
      rdi.subdrawer_vbid_min = vbid;
      rdi.subdrawer_vbid_max = vbid;
    } else {
      rdi.subdrawer_vbid_min = min(rdi.subdrawer_vbid_min, vbid);
      rdi.subdrawer_vbid_max = max(rdi.subdrawer_vbid_max, vbid);
    }
    debug_log("subdrawer vbid_min_max", rdi.subdrawer_vbid_min,
      rdi.subdrawer_vbid_max);
  }
  if (static_cast{size_t}(rdi.subdrawer_vbid_max
    - rdi.subdrawer_vbid_min + 1) != rdi.subdrawer_vbids.size()) {
    // 連続したvbidでなければならない。順序はどうてもいい。
    // そうなるためには、drawerの生成順を気にしなければならない。
    // 理不尽な制約なので、できれば修正する。
    debug_log("failed to get subdrawer_vbids");
    throw runtime_error_template{"subdrawer_vbids"}("1");
  }
  debug_log("prepare_vbids: ", rdi.subdrawer_vbids.size());
  rdi.name_to_joint_id = pgs.get_name_to_joint_id();
  rdi.vs_radius.clear();
  for (const& name, const& joint_id: rdi.name_to_joint_id) {
    cptr{vertices} const vtxs = pgs.get_nonempty_vertices(name);
    const& p = vtxs->positions;
    float radius = 0.0f;
    for (size_t i : 0 .. p.size() / 3) {
      const oi = i * 3;
      const vec = glm::make_vec3(p[oi], p[oi+1], p[oi+2]);
      radius = max(radius, glm::length(vec));
    }
    debug_log("shape", name, joint_id, radius);
    rdi.vs_radius[joint_id] = radius;
  }
}

private struct camera_state {
  public input_control_target player;
  public glm::vec2 light;
}

private struct app_demoapp()
{
  public tptr{demoapp_scene_shared} const scene_shared
    = make_tptr{demoapp_scene_shared}(io::system);
  public option{ptr{shader_config}} sconf;
  public ptr{projection_info} proj_df = make_ptr{projection_info}();
    // drawing frame
  public ptr{projection_info} proj_pm = make_ptr{projection_info}();
    // pre-motion frame
  public ptr{drawer_fxaa_params} dp_fxaa = make_ptr{drawer_fxaa_params}();
  public ptr{drawer_ssao_params} dp_ssao = make_ptr{drawer_ssao_params}(
    proj_df);
  public ptr{drawer_blur_params} dp_blur = make_ptr{drawer_blur_params}();
  public ptr{glm::uvec2} pviewport_main = make_ptr{glm::uvec2}();
  public ptr{glm::uvec2} pviewport_sm = make_ptr{glm::uvec2}();
  public input_control_target player;
  public joystick_state player_joystick;
  public input_control ictl = input_control(io::system);
  public int scene_next;
  public float light_on = 0.0f;
  public glm::vec2 light = glm::make_vec2(0.1f, 0.2f);
  public float exposure = 1.414f;
  public float option_value = 0.0f;
  public float option_value2 = -1.0f;
  public string_map app_commands;
  public string app_status_message;
  // public varray{bool} prev_joy_buttons;
  public option{ptr{edit_mode_i}} edit_mode;
  public bool raycast_cull_front = false;
  public int raycast_layer = 0;
  public bool enable_dbgui = false;
  public textures_ptr const txs = make_textures_ptr();
  public tptr{tiled_voxel_texture} const tvt
    = make_tptr{tiled_voxel_texture}();
  public tptr{texture_updates} const tup = make_tptr{texture_updates}();
  public tptr{texture_updates} const tup_swap = make_tptr{texture_updates}();
  public pgl3d::engine::util::rand_generator rand_gen
    = pgl3d::engine::util::rand_generator(1u);
  public uint modmask; // shift, meta
  public glm::mat4 edit_mode_trans = mat4_identity();
  public vertex_attr edit_mode_vattr;
  public ptr{varray{uchar}} capt_data = make_ptr{varray{uchar}}();
  public ftd3_aximaster axim;
  public option{ptr{motion_controller_serial}} mctrl;
  init();
  private function void init() {
    string s;
    if (sdl_load_file("/build/camera_state.raw", s)) {
      camera_state st = from_string{camera_state}(s);
      player = st.player;
      light = st.light;
    } else {
      // player.position = glm::make_vec3(0.0, 0.0, -40.0);
      // player.angle = glm::make_quat_wxyz(0.70711, 0.70711, 0.0, 0.0);
      player.position = glm::make_vec3(0.0, 0.0, 40.0);
      player.angle = glm::make_quat_wxyz(1.0, 0.0, 0.0, 0.0);
    }
    if (axim.is_valid()) {
      debug_log("d3axim is available");
    } else {
      debug_log("d3axim is not available");
    }
  }
}

public tsvaluetype enum collision_shape_e {
  collision_shape_e_sphere = 0,
  collision_shape_e_box = 1,
  collision_shape_e_convex_hull = 2,
  collision_shape_e_concave = 3,
  collision_shape_e_voxel = 4,
}

public multithreaded struct
collision_shape_data(string const& name0, joint_id_type joint_id0,
  float mass0, collision_shape_e shape0, varray{float} const& values0,
  varray{vertex_attr} const& vattrs0, varray{uint} const& elements0,
  tptr{tiled_voxel_texture} const& tvt0)
{
  public string name = name0;
  public joint_id_type joint_id = joint_id0;
  public float mass = mass0;
  public collision_shape_e shape = shape0;
  public varray{float} values = values0;
  public varray{vertex_attr} vattrs = vattrs0;
  public varray{uint} elements = elements0;
  public tptr{tiled_voxel_texture} tvt = tvt0;
}

public metafunction collision_shape_data_array
  varray{tcptr{collision_shape_data}};

public multithreaded struct demoapp_scene_shared(io const& sys0)
  <pgl3d_scene_shared>
{
  public position_angle posang;
  public glm::vec3 pos_delta;
  public int scene_next;
  public int raycast_layer;
  public bool engine_status = true;
  public float light_on;
  public glm::vec2 light;
  public float exposure = 2.0f;
  public float option_value = 0.0f;
  public float option_value2 = -1.0f;
  public texture_info default_font_texture_info;
  public string_map app_commands;
  public string app_status_message;
  public io::io sys = sys0;
  public raycast_drawers_info rdi;
  public option{tptr{tiled_voxel_texture}} tvt;
  public option{tptr{texture_updates}} tup;
  public collision_shape_data_array shapes;
  public projection_info pj_drawing_frame;
    // motion stepで書き込み、motion swapでこれをdrawerに渡す
  function ptr{pgl3d_scene} make_scene(node_factory const& nodefac) {
    return make_ptr{demoapp_scene}(nodefac, shapes, tvt.some, tup.some, sys);
  }
}

private threaded function double get_time(io::io const& sys)
{
  const t = sys.high_resolution_timer();
  const d = sys.high_resolution_timer_frequency();
  return static_cast{double}(t) / static_cast{double}(d);
}

private threaded function float time_diff(double t0, double t1)
{
  return static_cast{float}(t1 - t0);
}

public threaded struct demoapp_scene(node_factory const& nodefac0,
  collision_shape_data_array const& shapes0,
  tptr{tiled_voxel_texture} const& tvt0, tptr{texture_updates} const& tup0,
  io::io const& sys0)
  <pgl3d_scene>
{
  public scene_control sctl = scene_control(nodefac0, shapes0, tvt0, tup0);
  public io::io sys = sys0;
  public string timings;
  public raycast_objects robjs;
  private function void update_camera_light(position_angle mutable& camera,
    position_angle mutable& light, glm::vec2 const& light_val)
  {
    light.position = camera.position + glm::make_vec3(0.0, 0.0, 0.0);
    light.angle = (
      glm::make_quat_angle_axis(-3.14f * light_val.x, 1.0, 0.0, 0.0) *
      glm::make_quat_angle_axis(-3.14f * light_val.y, 0.0, 1.0, 0.0))
      .normalize();
  }
  public function void on_motion_step(float frame_speed,
    cstrref const& status_message,
    cslice{prepare_instance_data_funcptr} const& ftable,
    whole_instances_type mutable& whole_instances,
    pgl3d_scene_shared mutable& ss)
  {
    const t0 = get_time(sys);
    mutable& dss = downcast_mutable{demoapp_scene_shared}(ss);
    // const t0 = io::debug_system().gettimeofday_double();
    projection_info mutable& pj = dss.pj_drawing_frame;
    pj.camera = dss.posang;
    update_camera_light(pj.camera, pj.light, dss.light);
    pj.view = pj.camera.to_mat4().inverse();
    pj.view_projection = pj.projection * pj.view;
    pj.exposure = dss.exposure;
    pj.option_value = dss.option_value;
    pj.option_value2 = dss.option_value2;
    // dss.pj_drawing_frame = pj; // これを介してmainスレッドのdrawersに反映
    const sm_view = pj.light.to_mat4().inverse();
    // const sm_vp = pj.sm_projection * sm_view;
    const& vp = pj.view_projection;
    node_common_data ncd;
    // ncd.shadowmapping_vp = sm_vp; // FIXME: remove: unused
    ncd.vp = vp;
    scene_control_update_buttons(sctl, sctl.node_buttons);
    size_t swarm_total = 0;
    for (const i, const& lpb: sctl.lpbullet_swarms) {
      swarm_total += lpb->size();
    }
    {
      farray{string, 2} msg;
      msg[0] = string_join{" "}("O:", sctl.sco.dworld.rigid_bodies_size(),
	swarm_total, status_message, "T:", timings);
      if (!dss.engine_status) {
	msg[0] = "RELOADING SHADER FAILED";
      }
      // debug_log("app_status_message", dss.app_status_message); // FIXME
      msg[1] = dss.app_status_message;
      scene_control_set_message(sctl, sctl.node_status_message, msg,
	0, 0,
	dss.default_font_texture_info.char_w,
	dss.default_font_texture_info.char_h,
	static_cast{float}(pj.virt_width),
	static_cast{float}(pj.virt_height));
    }
    const t1 = get_time(sys);
    robjs.set_perspective(pj.camera_pers);
    robjs.clear_objects();
    scene_control_step(sctl, dss, robjs, pj, frame_speed, ncd, ftable,
      whole_instances);
      // 物理エンジンを使ったオブジェクトの移動とインスタンス出力。
    robjs.prepare_instances(ncd, dss.rdi, ftable, whole_instances);
      // raycastシェーダの重ね合わせを決定してインスタンス出力
    const t2 = get_time(sys);
    prepare_instance_data_ft_rec(ncd, sctl.node_status_message, ftable,
      whole_instances);
      // node_status_messageのインスタンス出力
    const t3 = get_time(sys);
    prepare_instance_data_ft_rec(ncd, sctl.node_buttons, ftable,
      whole_instances);
      // node_buttonsのインスタンス出力
    const t4 = get_time(sys);
    prepare_instance_data_lp(ncd, ftable, whole_instances);
      // lpのインスタンス出力
    const t5 = get_time(sys);
    timings = string_join{" "}(
      time_diff(t0, t1),
      time_diff(t1, t2),
      time_diff(t2, t5));
    // debug_log("timings", timings);
  }
  private function size_t prepare_instance_data_ft_rec(
    node_common_data mutable& ncd,
    scene_node const& sn,
    cslice{prepare_instance_data_funcptr} const& ftable,
    whole_instances_type mutable& whole_instances)
  {
    size_t r = 0;
    const& vbid = sn.joint_id.vbid;
    const& vsid = sn.joint_id.vsid;
    if (vbid != vbid_invalid() && vsid != vsid_invalid()) {
      ++r;
      mutable& idata = whole_instances[vbid][vsid];
      // debug_log("prepare_instance_data_ft_rec instance vbid=", vbid);
      ftable[vbid](sn, ncd, idata);
    }
    for (const i, const& snp: sn.children) {
      r += prepare_instance_data_ft_rec(ncd, snp, ftable, whole_instances);
    }
    return r;
  }
  private function void prepare_instance_data_lp(
    node_common_data mutable& ncd,
    cslice{prepare_instance_data_funcptr} const& ftable,
    whole_instances_type mutable& whole_instances)
  {
    // FIXME: 
    const vbid = sctl.joint_id_lp.vbid;
    const vsid = sctl.joint_id_lp.vsid;
    mutable& idata = whole_instances[vbid][vsid];
    for (const k, const& lpbsw: sctl.lpbullet_swarms) {
      const& lparr = lpbsw->lparr;
      for (const i, const& lpb: lparr) {
	const sli = lpb.value.crange();
	idata.instance_buffer.append(sli[0 .. 9]);
      }
    }
  }
}

function void save_state(app_demoapp const& app)
{
  camera_state st;
  st.player = app.player;
  st.light = app.light;
  const s = to_string(st);
  debug_log("save", s);
  sdl_save_file("/build/camera_state.raw", s);
}

function bool update_window_geometry(app_demoapp mutable& app,
  glm::uvec2 const& drsz, glm::uvec2 const& wsz)
{
  const& glc = *app.sconf.some;
  mutable& cam = *app.proj_df;
  if (
    cam.display_width == static_cast{int}(drsz.x) &&
    cam.display_height == static_cast{int}(drsz.y) &&
    cam.window_width == static_cast{int}(wsz.x) &&
    cam.window_height == static_cast{int}(wsz.y))
  {
    sdl_log("display geometry not changed");
    return false;
  }
  const virt_scale = glc.conf.get("virt_scale", 1.0f, 0.125f, 16.0f);
  const virt_width = static_cast{int}(static_cast{float}(drsz.x)
    / virt_scale);
  const virt_height = static_cast{int}(static_cast{float}(drsz.y)
    / virt_scale);
  const sm_size = glc.shadowmap_resolution;
  sdl_log("disp size", drsz.x, drsz.y);
  sdl_log("virt size", virt_width, virt_height);
  cam.virt_width = virt_width;
  cam.virt_height = virt_height;
  cam.display_width = static_cast{int}(drsz.x);
  cam.display_height = static_cast{int}(drsz.y);
  cam.window_width = static_cast{int}(wsz.x);
  cam.window_height = static_cast{int}(wsz.y);
  cam.shadowmap_size = sm_size;
  *app.pviewport_main = glm::make_uvec2(
    static_cast{uint}(cam.display_width),
    static_cast{uint}(cam.display_height));
  *app.pviewport_sm = glm::make_uvec2(
    static_cast{uint}(cam.shadowmap_size),
    static_cast{uint}(cam.shadowmap_size));
  // update mvp
  float const perspective_near =
    glc.conf.get("perspective_near", 1.0f, 0.001f, 100.0f);
  float const perspective_far =
    glc.conf.get("perspective_far", 10000.0f, 10.0f, 1000000.0f);
  float const perspective_wh =
    glc.conf.get("perspective_wh", 1.0f, 0.001f, 100.0f);
  const ssbase = max(cam.virt_height, cam.virt_width);
  const h = perspective_wh * cast_float(cam.virt_height)
    / cast_float(ssbase);
  const w = perspective_wh * cast_float(cam.virt_width)
    / cast_float(ssbase);
  {
    // camera projection
    const near = perspective_near;
    const far = perspective_far;
    const left = cast_float(-w);
    const right = cast_float(w);
    const bottom = cast_float(-h);
    const top = cast_float(h);
    cam.camera_pers.near = near;
    cam.camera_pers.far = far;
    cam.camera_pers.width = w;
    cam.camera_pers.height = h;
    cam.projection = glm::frustum(left, right, bottom, top, near, far);
  }
  {
    // shadowmap projection
    function void set_sm(glm::mat4 mutable& dst, float di)
    {
      const far = di * 1.0f;
      const near = di * -1.0f;
      const left = -di;
      const right = di;
      const bottom = -di;
      const top = di;
      dst = glm::ortho(left, right, bottom, top, near, far);
    }
    float far = glc.shadowmap_distance;
    for (const i: 0 .. static_cast{size_t}(glc.num_shadowmaps)) {
      set_sm(cam.sm_projection[i], far);
      far *= glc.shadowmap_scale;
    }
    // debug_log("smp0", cam.sm_projection[0].to_cslice());
    // debug_log("smp1", cam.sm_projection[1].to_cslice());
  }
  *app.proj_pm = cam; // update proj_pm also
  return true;
}

function void handle_event(app_demoapp mutable& app, app_ctrl_i mutable& actrl,
  SDL_Event const& ev, float frame_speed)
{
  const etype = ev.type;
  if (etype == SDL_WINDOWEVENT) {
    //if (ev.window.event == SDL_WINDOWEVENT_RESIZED) {
      if (update_window_geometry(app, actrl.get_drawable_size(),
        actrl.get_window_size())) {
        actrl.geometry_changed();
        debug_log("WINDOWEVENT");
      }
    //}
  } else if (etype == SDL_MOUSEBUTTONDOWN) {
    const& pj = *app.proj_pm;
    const bx = cast_float(ev.button.x) / cast_float(pj.window_width);
    const by = cast_float(ev.button.y) / cast_float(pj.window_height);
    debug_log("down", bx, by, ev.button.x, ev.button.y,
      pj.window_width, pj.window_height);
    if (bx < 0.1 && by < 0.1) {
      app.scene_next = 1;
      debug_log("next", app.scene_next);
      return;
    } else if (bx > 0.9 && by > 0.9) {
      app.exposure *= 2.0;
      if (app.exposure > 16.0f) {
	app.exposure = 1.0f / 16.0f;
      }
      return;
    } else if (bx > 0.9 && by < 0.1) {
      app.option_value = static_cast{float}(
	(static_cast{int}(app.option_value) + 1) % 8);
      debug_log("option_value", app.option_value);
      return;
    }
  } else if (etype == SDL_FINGERDOWN) {
    if (ev.tfinger.x < 0.1 && ev.tfinger.y < 0.1) {
      app.scene_next = 1;
      return;
    } else if (ev.tfinger.x > 0.9 && ev.tfinger.y > 0.9) {
      app.app_commands["scene_pause"] = "1";
      // app.light_on = app.light_on > 0.5f ? 0.0f : 1.0f;
      return;
    } else if (ev.tfinger.x < 0.1 && ev.tfinger.y > 0.9) {
      app.exposure *= 2.0;
      if (app.exposure > 16.0f) {
	app.exposure = 1.0f / 16.0f;
      }
      return;
    } else if (ev.tfinger.x > 0.9 && ev.tfinger.y < 0.1) {
      app.option_value = static_cast{float}(
	(static_cast{int}(app.option_value) + 1) % 8);
      debug_log("option_value", app.option_value);
      return;
    }
  } else if (etype == SDL_KEYDOWN) {
    if (case app.edit_mode.some) {
      app.edit_mode.some->set_camera_angle(app.player.angle);
      glm::vec3 cursor_move;
      app.edit_mode.some->on_key_pressed(
	static_cast{int}(ev.key.keysym.scancode), app.modmask, cursor_move,
	app.app_status_message);
      // debug_log("keydown stmsg", app.app_status_message);
      // debug_log("cursor_move", cursor_move);
      const glm::vec3 m =
	cursor_move * app.edit_mode_vattr.aabb_or_tconv.w;
	// 接線空間座標に変換
      mutable mo0 = app.edit_mode_trans * glm::make_vec4(
	0.0f, 0.0f, 0.0f, 1.0f);
      mutable mo1 = app.edit_mode_trans * glm::make_vec4(
	m.x, m.y, m.z, 1.0f);
	// オブジェクト座標に変換
      mo0 /= mo0.w;
      mo1 /= mo1.w;
      const mo = mo1 - mo0;
      // edit_modeに使うsceneではオブジェクト座標がそのままグローバル座標
      app.player.position += glm::make_vec3(mo.x, mo.y, mo.z);
    }
    // sdl_log("KEYDOWN event", static_cast{int}(ev.key.keysym.scancode));
    if (const ed: app.edit_mode.some) {
      if (ed->is_textinput_mode()) {
        return;
      }
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_TAB) {
      if ((app.modmask & 1) == 1) {
        app.scene_next = -1;
      } else {
        app.scene_next = 1;
      }
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F11) {
      actrl.set_param("fullscreen", "1");
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F5) {
      actrl.set_param("reload", "1");
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F7) {
      actrl.set_param("dummy_flip", "1");
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F8) {
      app.exposure *= 0.5;
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F9) {
      app.exposure *= 2.0;
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F10) {
      actrl.set_param("vsync", "1");
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_E) {
      app.app_commands["throw"] = "1";
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_Q) {
      app.light_on = app.light_on > 0.5f ? 0.0f : 1.0f;
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F1) {
      actrl.set_param("scene_pause", "1");
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F2) {
      app.option_value = static_cast{float}(
	(static_cast{int}(app.option_value) + 2) % 8);
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F3) {
      app.option_value = static_cast{float}(
	static_cast{int}(app.option_value) ^ 1);
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F4) {
      if ((app.modmask & 1) != 0) {
	app.option_value2 = -1.0;
      } else {
	app.option_value2 = static_cast{float}(
	  (static_cast{int}(app.option_value2) + 2) % 10 - 1);
      }
      debug_log("option_value2", app.option_value2);
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_F12) {
      save_state(app);
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_PAGEDOWN) {
      if ((app.modmask & 1) != 0) {
	app.light.y -= 0.01f;
      } else {
	app.light.x -= 0.01f;
      }
      return;
    }
    if (ev.key.keysym.scancode == SDL_SCANCODE_PAGEUP) {
      if ((app.modmask & 1) != 0) {
	app.light.y += 0.01f;
      } else {
	app.light.x += 0.01f;
      }
      return;
    }
    // debug_log("key", static_cast{int}(ev.key.keysym.scancode));
  } else if (etype == SDL_TEXTINPUT) {
/*
    const sli = ev.text.text.to_cslice().to_crawptr().to_cslice(32);
    const len = find_mapped(sli, 0, 0);
    const s = string(sli[0 .. len]);
*/
    if (const edit_mode: app.edit_mode.some) {
      edit_mode->on_textinput(sdl_textevent_text(ev.text),
        app.app_status_message);
      // debug_log("ti stmsg", app.app_status_message);
    }
  } else if (etype == SDL_WINDOWEVENT &&
    ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) {
    app.scene_shared->engine_status = ev.window.data1 != 0;
  }
  const& proj = *app.proj_pm;
  const virt_sz = glm::make_uvec2(static_cast{uint}(proj.virt_width),
    static_cast{uint}(proj.virt_height));
  app.ictl.handle_event(ev, frame_speed, virt_sz, app.app_commands);
}

function void update_joystick(app_demoapp mutable& app,
  cslice{joystick_state} const& joysticks)
{
  // TODO: マップできるようにする
  if (joysticks.empty()) {
    return;
  }
  const& ji = joysticks[0];
  if (ji.hats.size() == 0) {
    app.player_joystick = ji;
    return;
  } else if (ji.hats.size() >= 1 && ji.buttons.size() >= 16 &&
    ji.axes.size() >= 6) {
    mutable& axes = app.player_joystick.axes;
    mutable& btns = app.player_joystick.buttons;
    axes[0] = ji.axes[0];
    axes[1] = ji.axes[1];
    axes[2] = ji.axes[3];
    axes[3] = ji.axes[4];
    axes[4] = 0;
    axes[5] = 0;
    btns[0] = (ji.hats[0] & 1) != 0;
    btns[1] = (ji.hats[0] & 4) != 0;
    btns[2] = (ji.hats[0] & 8) != 0;
    btns[3] = (ji.hats[0] & 2) != 0;
    btns[4] = ji.buttons[11];
    btns[5] = ji.buttons[15];
    btns[6] = ji.buttons[13];
    btns[7] = ji.buttons[14];
    btns[8] = ji.buttons[6];
    btns[9] = ji.buttons[7];
    btns[10] = ji.buttons[0];
    btns[11] = ji.buttons[1];
    btns[12] = ji.buttons[3];
    btns[13] = ji.buttons[4];
    btns[14] = ji.buttons[16];
  }
  // debug_log(joysticks);
}

function void handle_keys(app_demoapp mutable& app, cslice{uchar} const& keys,
  cslice{joystick_state} const& joysticks, float frame_speed)
{
  bool no_move = false;
  if (const em: app.edit_mode.some) {
    if (em->is_textinput_mode()) {
      no_move = true;
    }
  }
  if (!no_move) {
    update_joystick(app, joysticks);
    app.ictl.handle_keys(app.player, keys, app.player_joystick, frame_speed,
      app.app_commands);
  }
  if (app.axim.is_valid()) {
    // ラグ確認のためft601経由でLED点灯する
    const kleft = app.ictl.get_key(keys, SDL_SCANCODE_LEFT) != 0u;
    const kright = app.ictl.get_key(keys, SDL_SCANCODE_RIGHT) != 0u;
    farray{uchar, 4} buf;
    buf[0] |= static_cast{uchar}(kleft ? 1u : 0u);
    buf[0] |= static_cast{uchar}(kright ? 2u : 0u);
    buf[1] = buf[0];
    buf[2] = buf[0];
    buf[3] = buf[0];
    app.axim.axi_write(0x44a00000, buf);
  }
  glm::quat mctrl_angle = glm::make_quat_wxyz(1.0, 0.0, 0.0, 0.0);
  if (const& mctrl: app.mctrl.some) {
    mctrl_angle = mctrl->get_current_value().conjugate();
  }
  /*
  if (app.ictl.get_button(buttons, 10) != 0) {
    app.app_commands["throw"] = "1";
  }
  if (app.ictl.get_button(buttons, 4) != 0 &&
    app.ictl.get_button(app.prev_joy_buttons, 4) == 0) {
    app.scene_next = 1;
  }
  */
  glm::quat camera_rel = glm::make_quat_wxyz(1.0, 0.0, 0.0, 0.0);
  /*
  {
    const rnd_x = static_cast{double}(app.rand_gen.generate() >> 16u)
      / 65536.0 - 0.5;
    const rnd_y = static_cast{double}(app.rand_gen.generate() >> 16u)
      / 65536.0 - 0.5;
    camera_rel *= glm::make_quat_angle_axis(
      static_cast{float}(rnd_x) * 3.14159f / 16384.0f, 1.0, 0.0, 0.0);
    camera_rel *= glm::make_quat_angle_axis(
      static_cast{float}(rnd_y) * 3.14159f / 16384.0f, 1.0, 0.0, 0.0);
  }
  */
  /*
  const cam_ax0 = app.ictl.get_axis(axes, 3);
  const cam_ax1 = app.ictl.get_axis(axes, 2);
  if (cam_ax0 != 0.0f || cam_ax1 != 0.0f) {
    camera_rel *= glm::make_quat_angle_axis(
      app.ictl.get_axis(axes, 3) * -3.14159f / 2.0f, 1.0, 0.0, 0.0);
    camera_rel *= glm::make_quat_angle_axis(
      app.ictl.get_axis(axes, 2) * -3.14159f / 2.0f, 0.0, 1.0, 0.0);
  }
  */
  app.ictl.action_step(app.player, app.player.pos_delta, frame_speed);
  {
    mutable& ss = *app.scene_shared;
    ss.light_on = app.light_on;
    ss.light = app.light;
    ss.exposure = sqrt(app.exposure); // 半段単位
    ss.option_value = app.option_value;
    ss.option_value2 = app.option_value2;
    ss.scene_next = app.scene_next;
    ss.posang.position = app.player.position;
    ss.posang.angle = app.player.angle * mctrl_angle * camera_rel;
    ss.pos_delta = app.player.pos_delta;
    ss.app_commands.swap(app.app_commands);
    ss.app_status_message = app.app_status_message;
    app.scene_next = 0;
    // sdl_log("posang = ", ss.posang);
  }
  app.app_commands.clear();
  // app.prev_joy_buttons = buttons;
}

private function varray{ptr{pgldrawer_export_i}} init_drawsteps(
  app_demoapp mutable& app, shader_config const& sconf,
  drawer_shared const& ds)
{
  app.raycast_cull_front = sconf.conf.get("raycast_cull_front", 0, 0, 1) != 0;
  app.raycast_layer = sconf.conf.get("raycast_layer", 15, 0, 63);
    // 0のときソートしない
  app.enable_dbgui = sconf.conf.get("enable_dbgui", 0, 0, 1) != 0;
  app.scene_shared->raycast_layer = app.raycast_layer;

  prepare_triangles_texture_data(sconf.conf, app.txs, app.tvt);
  *ds.textures = *app.txs;
  *ds.tvt = *app.tvt;

  // レンダリングパスを組み立てる
  metafunction drawer_ptr ptr{pgldrawer_export_i};
  varray{drawer_ptr} r;
  varray{drawer_ptr} solid;
  varray{varray{drawer_ptr}} shadow;
  varray{drawer_ptr} zpre;
  const shadowmap_name = "sm";
  const num_shadowmaps = sconf.num_shadowmaps;
  make_drawstep_triangles_surface(sconf, ds, app.proj_df, shadowmap_name,
    num_shadowmaps, solid, shadow, zpre);
  make_drawstep_raycast(sconf, ds, app.proj_df, shadowmap_name,
    sconf.num_shadowmaps, app.raycast_layer, solid, shadow, zpre);
  for (int i: 0 .. num_shadowmaps) {
    r.push_back(make_drawstep_setfb(sconf, ds, app.pviewport_sm,
      app.pviewport_sm, shadowmap_name + to_string(i), true,
      make_varray{string}(),
      "GL_DEPTH_COMPONENT"));
      // set shadowmap framebuffer i
    r.append(shadow[static_cast{size_t}(i)]); // draw shadow
  }
  r.push_back(make_drawstep_setfb(sconf, ds, app.pviewport_main,
    app.pviewport_main,
    "col1", true, make_varray{string}("GL_RGBA"), "GL_DEPTH_COMPONENT"));
    // set color+depth framebuffer
  r.push_back(make_drawstep_chgmode(sconf, ds, "zprepass"));
  r.append(zpre); // draw solid z-prepass
  r.push_back(make_drawstep_chgmode(sconf, ds, "solid"));
  r.append(solid); // draw solid color
  r.push_back(make_drawstep_lineparticle(sconf, ds, app.proj_df));
    // draw solid
  r.push_back(make_drawstep_skybox(sconf, ds, app.proj_df)); // draw solid
  r.push_back(make_drawstep_chgmode(sconf, ds, "blend"));
  r.push_back(make_drawstep_particle(sconf, ds, app.pviewport_main));
  r.push_back(make_drawstep_particle_bb(sconf, ds, app.proj_df));
  r.push_back(make_drawstep_setfb(sconf, ds, app.pviewport_main,
    app.pviewport_main,
    "col0", true, make_varray{string}("GL_RGBA"), "GL_DEPTH_COMPONENT"));
    // set color+depth framebuffer
  r.push_back(make_drawstep_ssao(sconf, ds, app.dp_ssao, "col1"));
    // col1からcol0へssaoフィルタ実行
  r.push_back(make_drawstep_setfb(sconf, ds, app.pviewport_main,
    app.pviewport_main,
    "col1", false, make_varray{string}("GL_RGBA"), "GL_DEPTH_COMPONENT"));
    // col1再利用
  r.push_back(make_drawstep_fxaa(sconf, ds, app.dp_fxaa, "col0"));
    // col0からcol1へfxaaフィルタ実行
  if (sconf.conf.get("capture_filter", 0, 0, 1) != 0) {
    debug_log("enable capture filter");
    r.push_back(make_drawstep_setfb(sconf, ds, app.pviewport_main,
      app.pviewport_main,
      "col0", false, make_varray{string}("GL_RGBA"), "GL_DEPTH_COMPONENT"));
      // col0再利用
    r.push_back(make_drawstep_blur(sconf, ds, app.dp_blur, "col1"));
      // col1からcol0へblurフィルタ実行
    r.push_back(make_drawstep_chgmode(sconf, ds, "blend"));
    r.push_back(make_drawstep_rect2d(sconf, ds));
    r.push_back(make_drawstep_font2(sconf, ds, app.pviewport_main));
    r.push_back(make_drawstep_setfb(sconf, ds, app.pviewport_main,
      app.pviewport_main,
      "col1", false, make_varray{string}("GL_RGBA"), "GL_DEPTH_COMPONENT"));
      // col1再利用
    r.push_back(make_drawstep_chgmode(sconf, ds, "solid"));
    r.push_back(make_drawstep_capture(sconf, ds, app.pviewport_main,
      app.capt_data, "col0"));
      // col0からcol1へcaptureフィルタ実行
    r.push_back(make_drawstep_setfb(sconf, ds, app.pviewport_main,
      app.pviewport_main,
      "", false, make_varray{string}(), "")); // set toplevel framebuffer
    r.push_back(make_drawstep_passthrough(sconf, ds, "col0"));
      // col0からtoplevelへpassthroughフィルタ実行
  } else {
    debug_log("disable capture filter");
    r.push_back(make_drawstep_setfb(sconf, ds, app.pviewport_main,
      app.pviewport_main,
      "", true, make_varray{string}(), "")); // set toplevel framebuffer
    r.push_back(make_drawstep_blur(sconf, ds, app.dp_blur, "col1"));
      // col1からtoplevelへblurフィルタ実行
    r.push_back(make_drawstep_chgmode(sconf, ds, "blend"));
    r.push_back(make_drawstep_rect2d(sconf, ds));
    r.push_back(make_drawstep_font2(sconf, ds, app.pviewport_main));
  }
  for (const i, const& p: r) {
    if (const em: p->get_edit_mode().some) {
      app.edit_mode.some = em;
    }
  }
  return r;
}

private function void build_vertices(app_demoapp mutable& app,
  make_vertices_i mutable& pgs)
{
  const& voxtmap = app.tvt->tmap_edit->data_pri[0];
  const voxtmap_size = map{glm::vec3, static_cast{float, uint}}(
    voxtmap.get_size_uvec3());
  const voxtmap_size_max = fold_list{max}(0.0f, voxtmap_size);
  const voxtmap_whd = voxtmap_size / voxtmap_size_max;
  /*
  const voxtmap_whd_max = static_cast{float}(
    max(max(voxtmap.get_width(), voxtmap.get_height()),
    voxtmap.get_depth()));
  const voxtmap_whd = glm::make_vec3(
    static_cast{float}(voxtmap.get_width()) / voxtmap_whd_max,
    static_cast{float}(voxtmap.get_height()) / voxtmap_whd_max,
    static_cast{float}(voxtmap.get_depth()) / voxtmap_whd_max);
  */
  /*
  bitarray3 otb = tilemap_external(voxtmap);
  bitarray3 itb = tilemap_internal(voxtmap);
  */
  /*
  uint const zmax = 1u << otb.d_l2;
  for (const z: zmax / 32 .. zmax) {
    for (const y: 0 .. (1u << otb.h_l2)) {
      for (const x: 0 .. (1u << otb.w_l2)) {
	otb.set(x, y, z, false);
	itb.set(x, y, z, false);
      }
    }
  }
  */
  /*
  debug_log("otb", otb.get_width_l2(), otb.get_height_l2(),
    otb.get_depth_l2());
  debug_log("itb", itb.get_width_l2(), itb.get_height_l2(),
    itb.get_depth_l2());
  otb = bitarray3_resize{operator::or}(otb);
  // otb = bitarray3_resize{operator::or}(otb);
  // otb = bitarray3_resize{operator::or}(otb);
  itb = bitarray3_resize{operator::and}(itb);
  // itb = bitarray3_resize{operator::and}(itb);
  // itb = bitarray3_resize{operator::and}(itb);
  */
  /*
  bitarray3 otb;
  otb.w_l2 = 1;
  otb.h_l2 = 1;
  otb.d_l2 = 1;
  otb.data.resize(8, false);
  otb.set(0, 0, 0, true);
  otb.set(1, 1, 1, true);
  */
  /*
  if (false) {
    for (const z: 0 .. 16u) {
      debug_log("z=", z);
      for (const y: 0 .. 16u) {
	string s;
	for (const x: 0 .. 16u) {
	  bool v = itb.get(x, y, z);
	  s += (v ? "1" : "0");
	}
	debug_log("", s);
      }
    }
  }
  */
  /*
  varray{varray{glm::vec3}} oquads = get_surface_quads(otb);
  varray{varray{glm::vec3}} iquads = get_surface_quads(itb);
  {
    function {t} t clamp(t x, t mi, t mx) {
      return x < mi ? mi : x > mx ? mx : x;
    }
    float tex3d_0 = 0.00001f;
    float tex3d_x = voxtmap_whd.x - 0.00001f;
    float tex3d_y = voxtmap_whd.y - 0.00001f;
    float tex3d_z = voxtmap_whd.z - 0.00001f;
    for (const i, mutable& q: oquads) {
      for (const j, mutable& p: q) {
	p = glm::make_vec3(
	  clamp(p.x, tex3d_0, tex3d_x),
	  clamp(p.y, tex3d_0, tex3d_y),
	  clamp(p.z, tex3d_0, tex3d_z));
      }
    }
    for (const i, mutable& q: iquads) {
      for (const j, mutable& p: q) {
	p = glm::make_vec3(
	  clamp(p.x, tex3d_0, tex3d_x),
	  clamp(p.y, tex3d_0, tex3d_y),
	  clamp(p.z, tex3d_0, tex3d_z));
      }
    }
  }
  debug_log("quads:", oquads.size());
  */

  /* import */
  const objs = make_farray{string}(
      "parts"
      // "al",
      // "cessna",
      // "skyscraper",
      // "airboat"
      );
  const tr0_0 = make_varray{string}("vbid_triangles_0_0");
      // ポリゴンをparallax mappingで描画 (stype==0, ssubtype==0)
  const tr1_0 = make_varray{string}("vbid_triangles_1_0");
  /*
  const tr1_0 = make_varray{string}(
    "vbid_triangles_1_0",
    "vbid_triangles_2_0");
      // 直方体をvoxel raycastingで描画 (stype==1, ssubtypeはあとで増やす)
      // stype==2は現在使っていない?
  */
  /*
  const tr1_1 = make_varray{string}(
    "vbid_triangles_1_1");
  const tr1_2 = make_varray{string}(
    "vbid_triangles_1_2");
  */
  const parti = make_varray{string}("vbid_particle");
  const parti_bb = make_varray{string}("vbid_particle_bb");
  for (const i, const name: objs) {
    string fn = name + ".obj";
    sdl_log("load", fn);
    string fcontent;
    sdl_load_file(fn, fcontent);
    const wfobjp = wfobject_read(fcontent);
    for (const j, mutable& v: wfobjp->v) {
      // v *= 10.0f;
    }
    for (const k, const g: wfobjp->groups) {
      pgs.make_vertex_set(tr0_0, name,
	import_wfobj(*wfobjp, *g, ctx_fill(0)));
    }
  }
  sdl_log("load prebuild");
  pgs.make_vertex_set(tr1_0, "empty-scene", hole());
  mutable rnd = make_rand_generator(1U);
  mutable m = mat4_identity();
  mutable m0 = m;
  mutable m1 = m;
  float box_size = 32.0f;
  debug_log("init m,m0,m1", m.to_farray(), m0.to_farray(), m1.to_farray());
  // float box_size = 1.0f;
  m = mat4_identity()
    .translate(glm::make_vec3(0.0, 0.0, box_size * 2.0f));
  m0 = mat4_identity()
    .rotate(to_radians(45.0), glm::make_vec3(0.0, 0.0, 1.0));
  m1 = mat4_identity()
    .translate(glm::make_vec3(0.0, 0.0, box_size * (-1.0f)))
    .rotate(to_radians(45.0), glm::make_vec3(0.0, 0.0, 1.0));
  debug_log("m,m0,m1", m.to_farray(), m0.to_farray(), m1.to_farray());
  const mi = glm::make_vec3(0.0, 0.0, 0.0);
  const mx = voxtmap_whd;
  float small_box_size = 1.0f;
  glm::mat4 small_m1 = mat4_identity()
    .translate(glm::make_vec3(0.0, 0.0, small_box_size * (-1.0f)))
    .rotate(to_radians(45.0), glm::make_vec3(0.0, 0.0, 1.0));
  debug_log("make box");
  pgs.make_vertex_set(tr1_0, "box", cuboid_tex3d(mi, mx, glm::vec3(), 32.0f));
  /*
  pgs.make_vertex_set(tr1_0, "box",
    regular_polygon(1.4142f * box_size, 4,
      apply(m0, hole()),
      apply(m0,
	ctx_tex3d(0, 0, mi, mx))));
  */
  debug_log("make box_opt1");
  pgs.make_vertex_set(tr1_0, "box_opt1",
    regular_polygon(1.4142f * box_size, 4,
      apply(m0, hole()),
      apply(m0,
	ctx_tex3d(0, 0, mi, mx))));
  // (80, 0, 35), (16, 21, 2) 全体は(2048x2048x64)
  // const tmi = glm::make_vec3(80.0f, 0.0f, 35.0f);
  // const tsz = glm::make_vec3(16.0f, 21.0f, 2.0f);
  // (59,20,49) - (59,0,63), min(59,0,49), sz(1, 21, 15)
  const tmi = glm::make_vec3(59.0f, 0.0f, 49.0f);
  const tsz = glm::make_vec3(1.0f, 21.0f, 15.0f);
  const smallmi = tmi / voxtmap_size_max; // map{glm::vec3, operator::div}(tmi, voxtmap_size);
  const smallmx = (tmi + tsz) / voxtmap_size_max; // map{glm::vec3, operator::div}(tmi + tsz, voxtmap_size);
  debug_log("make smallbox");
  pgs.make_vertex_set(tr1_0, "smallbox", cuboid_tex3d(smallmi, smallmx,
    glm::vec3(), 1.0f));
  /*
  pgs.make_vertex_set(tr1_0, "smallbox",
    regular_polygon(1.4142f * small_box_size, 4,
      apply(small_m1,
	ctx_tex3d(0, 0, smallmi, smallmx)),
      hole()));
  */
  pgs.make_vertex_set(tr1_0, "mstex3d",
    regular_polygon(300.0f, 100,
      apply(m1,
	bump_rec(1.0, 1.0, 16,
	  lid(
	    ctx_tex3d(1, 0, mi, mx),
	    bump_rec(0.01, 1.0, 1,
	      hole(),
	      hole()
	    )
	  ),
	  hole()
	)
      ),
      hole()
    )
  );
/*
  pgs.make_vertex_set(tr1_0, "mstex3d",
    regular_polygon(300.0f, 100,
      apply(m1,
	bump_rec(1.0, 1.0, 16,
	  lid(
	    ctx_tex3d(1, 0, mi, mx),
	    bump_rec(0.01, 1.0, 1,
	      ctx_fill(0),
	      ctx_tex3d(1, 0, mi, mx)
	    )
	  ),
	  hole()
	)
      ),
      hole()
    )
  );
*/
  m = mat4_identity()
    .translate(glm::make_vec3(0.0, 0.0, 64.0));
  m1 = mat4_identity()
    .translate(glm::make_vec3(0.0, 0.0, -32.0))
    .rotate(to_radians(45.0), glm::make_vec3(0.0, 0.0, 1.0));
  pgs.make_vertex_set(tr0_0, "box50",
    regular_polygon(1.4142f * 50.0f, 4,
      apply(m1,
	bump_apply(m, true, ctx_fill(0), ctx_fill(0))),
      apply(m1,
	ctx_fill(0))));
  pgs.make_vertex_set(tr0_0, "saucer",
    regular_polygon(15.0, 40,
      bump_rec(10.8, 0.5, 1, ctx_fill(0), ctx_fill(0)),
      bump_rec(0.05, 0.9, 5,
	ctx_fill(0),
	sphere(10, ctx_fill_smooth(0)))));
  pgs.make_vertex_set(tr0_0, "saucer-multi",
    regular_polygon(1.0, 3,
      bump_rec(1.0, 1.0, 1, ctx_poly_joint("saucer"), hole()),
      hole()));
  pgs.make_vertex_set(tr0_0, "block-multi",
    regular_polygon(600.0, 4,
      rectangle_split(9, 8, ctx_poly_joint("block")),
      hole()));
  {
    const m1 = mat4_identity().rotate(to_radians(90.0),
	glm::make_vec3(1.0, 0.0, 0.0));
    const m2 = mat4_identity().rotate(to_radians(-90.0),
	glm::make_vec3(1.0, 0.0, 0.0));
    pgs.make_vertex_set(tr0_0, "block-smtest",
      regular_polygon(3.0, 4,
	ctx_poly_joint("box"),
	apply(m1, bump_rec(1.0, 1.0, 1, hole(), ctx_poly_joint("block")))));
  }
  {
    const m1 = mat4_identity().rotate(to_radians(90.0),
	glm::make_vec3(1.0, 0.0, 0.0));
    const m2 = mat4_identity().rotate(to_radians(-90.0),
	glm::make_vec3(1.0, 0.0, 0.0));
    pgs.make_vertex_set(tr0_0, "box-depth",
      regular_polygon(3.0, 4,
	ctx_poly_joint("box"),
	apply(m1, bump_rec(1.0, 1.0, 1, hole(), ctx_poly_joint("box_opt1")))));
  }
  rnd = make_rand_generator(1U);
  pgs.make_vertex_set(tr0_0, "block",
    regular_polygon(30.0, 4,
      rotate_local(glm::make_quat_angle_axis(to_radians(45.0),
	0.0, 0.0, 1.0),
	rectangle_split(30, 30,
	// rectangle_split(1, 1,
	// rectangle_split(4, 4,
	  rand_bump(1, 0.8, 0.4, 0.4, 0.4, 0.4, 2.0, 2.0, rnd,
	    ctx_fill(0), ctx_fill(0), ctx_fill(0)))),
      rotate_local(glm::make_quat_angle_axis(to_radians(-45.0),
	0.0, 0.0, 1.0),
	bump_rec(0.5, 1.0, 1, ctx_fill(0), ctx_fill(0)))));
  rnd = make_rand_generator(1U);
  pgs.make_vertex_set(tr0_0, "nest",
    regular_polygon(50.0, 4,
      rotate_local(glm::make_quat_angle_axis(to_radians(45.0), 0.0, 0.0, 1.0),
	bump_rec(0.03, 1.0, 1, ctx_fill(0),
	  rand_bump2(100, 0.5, 0.2, 0.8, 0.05, 0.05, 0.5, 0.5, rnd,
	    ctx_fill(0),
	    rand_bump2(30, 10.0, 0.1, 0.2, 0.1, 0.2, 0.2, 0.5, rnd,
	      ctx_fill(0), ctx_fill(0), ctx_fill(0)),
	    ctx_fill(0)))),
      rotate_local(glm::make_quat_angle_axis(to_radians(45.0), 0.0, 0.0, 1.0),
	bump_rec(0.03, 1.0, 1, ctx_fill(0),
	  rand_bump2(100, 0.5, 0.2, 0.8, 0.05, 0.05, 0.5, 0.5, rnd,
	    ctx_fill(0),
	    rand_bump2(30, 10.0, 0.1, 0.2, 0.1, 0.2, 0.2, 0.5, rnd,
	      ctx_fill(0), ctx_fill(0), ctx_fill(0)),
	    ctx_fill(0))))));
  m = mat4_identity()
    .translate(glm::make_vec3(100.0, 100.0, 100.0))
    .rotate(to_radians(30.0), glm::make_vec3(0.0, 0.0, 1.0));
  pgs.make_vertex_set(tr0_0, "nest-multi",
    regular_polygon(600.0, 4,
      bump_apply(m, true, hole(),
	bump_rec_seq(0.2, 1.0, 5, hole(),
	  rectangle_split(10, 10, ctx_poly_joint("nest")))),
      hole()));
  m = mat4_identity()
    .translate(glm::make_vec3(0.0, 0.0, 1.0))
    .rotate(to_radians(10.0), glm::make_vec3(0.0, 0.0, 1.0));
  pgs.make_vertex_set(tr0_0, "bullet",
    regular_polygon(1.0, 6,
      bump_apply(m, true, ctx_fill(0), ctx_fill(0)),
      bump_apply(m, true, ctx_fill(0), ctx_fill(0))));
  // 60fps, macosx/linux mbp gt750m
  pgs.make_vertex_set(tr0_0, "bullet-multi",
    regular_polygon(600.0, 4,
      rectangle_split(170, 170, ctx_poly_joint("bullet")),
      hole()));
  m = mat4_identity()
    .translate(glm::make_vec3(0.0, 0.0, 1.0))
    .rotate(10.0, glm::make_vec3(0.0, 0.0, 1.0)); // FIXME: to_radians?
  pgs.make_vertex_set(tr0_0, "bullet2",
    regular_polygon(1.0, 5,
      bump_rec(2.3, 0.8, 1, ctx_fill(0), ctx_fill(0)),
      bump_rec(3.1, 0.8, 1, ctx_fill(0), ctx_fill(0))));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi",
    rand_sphere(200.0, 37000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "block-multi2",
    rand_sphere(500.0, 300, false, true, rnd,
      ctx_point_joint("block")));
  pgs.make_vertex_set(tr0_0, "box-multi",
    rand_sphere(300.0, 500, false, true, rnd,
      ctx_point_joint("box")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2",
    rand_sphere(200.0, 20000, false, true, rnd,
      ctx_point_joint("bullet2")));
  {
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s1",
    rand_sphere(200.0, 2000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s2",
    rand_sphere(200.0, 3000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s3",
    rand_sphere(200.0, 4000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s4",
    rand_sphere(200.0, 5000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s5",
    rand_sphere(200.0, 6000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s6",
    rand_sphere(200.0, 7000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s7",
    rand_sphere(200.0, 8000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s8",
    rand_sphere(200.0, 9000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s9",
    rand_sphere(200.0, 10000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s10",
    rand_sphere(200.0, 11000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s11",
    rand_sphere(200.0, 12000, false, true, rnd,
      ctx_point_joint("bullet2")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi2s12",
    rand_sphere(200.0, 13000, false, true, rnd,
      ctx_point_joint("bullet2")));
  }
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "bullet2-multi3",
    rand_sphere(50.0, 1000, false, true, rnd,
      ctx_point_joint("bullet2")));
  pgs.make_vertex_set(tr0_0, "bullet-multi-2",
    regular_polygon(600.0, 4,
      rectangle_split(80, 80, ctx_poly_joint("bullet")),
      hole()));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "saucer-multi3",
    rand_sphere(200.0, 200, false, true, rnd,
      ctx_point_joint("saucer")));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(tr0_0, "ab-multi3",
    rand_sphere(100.0, 100, false, true, rnd,
      ctx_point_joint("airboat")));
  rnd = make_rand_generator(1U);
  pgs.make_vertex_set(parti, "particle",
    rand_sphere(1.0, 100, true, true, rnd, ctx_fill(0)));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(parti, "particle-multi",
    rand_sphere(60.0, 10000, true, true, rnd,
      ctx_point_joint("particle")));
  rnd = make_rand_generator(1U);
  pgs.make_vertex_set(parti, "particle-bb",
    rand_sphere(1.0, 100, true, true, rnd, ctx_fill(0)));
  rnd = make_rand_generator(991U);
  pgs.make_vertex_set(parti_bb, "particle-bb-multi",
    rand_sphere(60.0, 10000, true, true, rnd,
      ctx_point_joint("particle-bb")));
  pgs.make_vertex_set(parti_bb, "mixed",
    regular_polygon(1.0, 5,
      bump_rec(1.0, 10.0, 1, hole(), ctx_poly_joint("saucer")),
      ctx_poly_joint("particle-bb")));
  /* for prepass test */
  pgs.make_vertex_set(tr0_0, "plane-multi-1",
    regular_polygon(100.0, 4,
      bump_rec_seq(0.1, 1.0, 10, hole(), ctx_poly_joint("box")),
      hole()));
  pgs.make_vertex_set(tr0_0, "plane-multi-2",
    regular_polygon(100.0, 4,
      bump_rec_seq(0.1, 1.0, 10, hole(), backside(ctx_poly_joint("box"))),
      hole()));
  /* for dynamics test */
  pgs.make_vertex_set(tr0_0, "rigidbody-multi",
    regular_polygon(100.0, 4,
      rectangle_split(10, 10, ctx_poly_joint("box")),
      hole()));
  /* for shadowmapping test */
  /*
  {
    float scale = 10.0;
    const& sli = KnightModel::vertices.to_cslice();
    const& elems = KnightModel::indices.to_cslice();
    varray{float} verts;
    debug_log("knight: ", sli.size(), elems.size());
    for (const i: 0 .. sli.size()) {
      const& p = sli[i].position.to_cslice();
      for (const j, const& v: p) {
	verts.push_back(v * scale);
      }
      verts.append(sli[i].normal.to_cslice());
    }
    size_t nfpv = 6; // position and normal
    pgs.make_vertex_set_by_triangles("vbid_triangles_0_0", "knight", verts,
      nfpv, elems);
    pgs.make_vertex_set(tr0_0, "knight-multi",
      regular_polygon(600.0, 4,
	rectangle_split(50, 50, ctx_poly_joint("knight")),
	hole()));
  }
  */

  /* save default font metrics */
  app.scene_shared->default_font_texture_info = pgs.get_texture_info("font");

  /* save edit_mode transform */
  {
    const vp = pgs.get_nonempty_vertices("box");
    const& vattrs = vp->vertex_attrs;
    const& vattr = vattrs[0];
    debug_log("edit_mode transform", vattr);
    const& tan = vattr.tan;
    const& nor = vattr.nor;
    const bnr = glm::cross(nor, tan);
    const& pos = vattr.pos;
    const glm::mat4 tan_to_obj = glm::make_mat4(
      tan.x, tan.y, tan.z, 0.0f,
      bnr.x, bnr.y, bnr.z, 0.0f,
      nor.x, nor.y, nor.z, 0.0f,
      pos.x, pos.y, pos.z, 1.0f);
      // 接線空間からオブジェクト座標系への変換
    app.edit_mode_trans = tan_to_obj;
    app.edit_mode_vattr = vattr;
  }

  /* save shapes for physics engine */
  function void shapes_add(cstrref const& name, float mass,
    collision_shape_e shape)
  {
    const vp = pgs.get_nonempty_vertices(name);
    const& p = vp->positions;
    const& va = vp->vertex_attrs;
    const& elems = vp->elements;
    app.scene_shared->shapes.push_back(make_tptr{collision_shape_data}(
      name, pgs.get_joint_id(name), mass, shape, p, va, elems, app.tvt));
  }
  function void shapes_add_convex(cstrref const& name, float mass)
  {
    shapes_add(name, mass, collision_shape_e_convex_hull);
  }
  function void shapes_add_sphere(cstrref const& name, float mass)
  {
    shapes_add(name, mass, collision_shape_e_sphere);
  }
  function void shapes_add_concave(cstrref const& name, float mass)
  {
    shapes_add(name, mass, collision_shape_e_concave);
  }
  function void shapes_add_voxel(cstrref const& name, float mass)
  {
    shapes_add(name, mass, collision_shape_e_voxel);
  }
  shapes_add_voxel("box", -32768.0f);
  shapes_add_sphere("box_opt1", 32768.0f);
  shapes_add_sphere("smallbox", 1.0f);
  shapes_add_sphere("mstex3d", 1000.0f);
  shapes_add_sphere("nest", 1000.0f);
  shapes_add_sphere("box50", 50.0f);
  shapes_add_sphere("bullet2", 2.0f);
  // shapes_add_sphere("bullet2", 1.0f);
  shapes_add_sphere("bullet", 2.0f);
  shapes_add_sphere("saucer", 10.0f);
  // shapes_add_concave("block", 0.0f);
  shapes_add_convex("block", 100.0f);
  // shapes_add_convex("knight", 10.0f);
  shapes_add_sphere("particle", 1.0f);
  shapes_add_sphere("particle-bb", 1.0f);
}

function varray{float} reduce_vertices(cslice{float} const& shape, float delta)
{
  varray{float} a;
  for (size_t i : 0 .. shape.size() / 3) {
    const oi = i * 3;
    const vec = glm::make_vec3(shape[oi], shape[oi+1], shape[oi+2]);
    size_t j = 0;
    const asz = a.size() / 3;
    for (j = 0; j < asz; ++j) {
      const oj = j * 3;
      const dx = a[oj    ] - vec.x;
      const dy = a[oj + 1] - vec.y;
      const dz = a[oj + 2] - vec.z;
      if (fabs(dx) + fabs(dy) + fabs(dz) < delta) {
	break;
      }
    }
    if (j == asz) {
      a.append(vec.to_cslice());
    }
  }
  return a;
}

metafunction node scene_node;

threaded function node make_node()
{
  return scene_node(joint_id_type(), mat4_identity());
}

tsvaluetype struct lpbullet_data {
  public farray{float, 9} value;
  public function glm::vec3 get_pos0() const {
    return glm::make_vec3(value[0], value[1], value[2]);
  }
  public function glm::vec3 get_pos1() const {
    return glm::make_vec3(value[3], value[4], value[5]);
  }
  public function float get_size() const {
    return value[6];
  }
  public function float get_step() const {
    return value[7];
  }
  public function float get_step_limit() const {
    return value[8];
  }
  public function void set_pos0(glm::vec3 const& v) {
    value[0] = v.x;
    value[1] = v.y;
    value[2] = v.z;
  }
  public function void set_pos1(glm::vec3 const& v) {
    value[3] = v.x;
    value[4] = v.y;
    value[5] = v.z;
  }
  public function void set_size(float v) {
    value[6] = v;
  }
  public function void set_step(float v) {
    value[7] = v;
  }
  public function void set_step_limit(float v) {
    value[8] = v;
  }
}

threaded struct
collision_shape_ptr(ptr{collision_shape_i} const& ptr0, float mass0)
{
  public ptr{collision_shape_i} shape_ptr = ptr0;
  public float mass = mass0;
}

threaded struct
scene_objects(collision_shape_data_array const& shape0, size_t num_split0,
  tptr{tiled_voxel_texture} const& tvt0, tptr{texture_updates} const& tup0)
{
  public dynamics_world dworld = dynamics_world(num_split0, tvt0->tmap_edit,
    tup0);
  public tree_map{string, collision_shape_ptr} shapes_by_name;
  public tree_map{joint_id_type, collision_shape_ptr} shapes_by_id;
  public tree_map{string, joint_id_type} name_to_joint_id;
  add_collision_shapes(shape0);
  public function void clear_objects() 
  {
    dworld.clear();
    dworld.set_gravity(0.0f, 0.0f, 0.0f);
  }
  public function void
  add_collision_shapes(collision_shape_data_array const& sa)
  {
    for (const i, const& val: sa) {
      add_collision_shape(*val);
    }
  }
  private function void
  add_collision_shape(collision_shape_data const& sh)
  {
    const& name = sh.name;
    const& joint_id = sh.joint_id;
    name_to_joint_id.insert(name, joint_id);
    const& v = sh.values;
    const& va = sh.vattrs;
    const& e = sh.elements;
    const mass = sh.mass;
    threaded function ptr{collision_shape_i} get_shape() {
      if (sh.shape == collision_shape_e_sphere) {
	return make_sphere_shape(v, e);
      } else if (sh.shape == collision_shape_e_box) {
	return make_box_shape(v, e);
      } else if (sh.shape == collision_shape_e_convex_hull) {
	return make_convex_hull_shape(v, e);
      } else if (sh.shape == collision_shape_e_concave) {
	return make_triangle_mesh_shape(v, e);
      } else if (sh.shape == collision_shape_e_voxel) {
	return make_voxel_shape(va, e);
      } else {
	throw runtime_error_template{"get_shape"}("1");
      }
    }
    add_collision_shape_one(name, joint_id, get_shape(), mass);
  }
  private function void add_collision_shape_one(string const& name,
    joint_id_type const& id, ptr{collision_shape_i} const& sh,
    float mass)
  {
    const csp = collision_shape_ptr(sh, mass);
    shapes_by_name.insert(name, csp);
    shapes_by_id.insert(id, csp);
  }
  public function option{ptr{rigid_body_i}} add_collision_object(
    scene_node const& sn)
  {
    option{ptr{rigid_body_i}} r;
    if (sn.joint_id.vsid < 0) {
      return r;
    }
    if (const& shape: shapes_by_id[sn.joint_id]) {
      const& t = sn.trans.value.to_cslice();
      const rb = make_rigid_body(sn.joint_id, shape.shape_ptr, shape.mass, t);
      dworld.add_rigid_body(rb);
      r.some = rb;
      return r;
    }
    return r;
  }
}

multithreaded struct
lpbullet_swarm <swarm_i>
{
  public varray{lpbullet_data} lparr;
  public function size_t size() const { return lparr.size(); }
  public function uint get(size_t i, glm::vec3 mutable& pos_r,
    float mutable& radius_r) const
  {
    const& o = lparr[i];
    pos_r = (o.get_pos0() + o.get_pos1()) * 0.5f;
    radius_r = 1.5f;
    return o.get_step() > 5.0f ? 0xffffffffU : 0U;
  }
  public function void on_collide(size_t i, size_t o)
  {
    mutable& lpb = lparr[i];
    lpb.set_step(lpb.get_step_limit());
  }
  public function void on_step(float speed)
  {
    for (const i, mutable& lpb: lparr) {
      mutable vec0 = lpb.get_pos0();
      mutable vec1 = lpb.get_pos1();
      const vd = vec1 - vec0;
      vec0 += vd * speed / 4.0f;
      vec1 += vd * speed / 4.0f;
      const step = lpb.get_step() + speed;
      const slim = lpb.get_step_limit();
      const sz = min(1.0f, (slim - step) / 20.0f);
      lpb.set_pos0(vec0);
      lpb.set_pos1(vec1);
      lpb.set_size(0.25f * sz);
      lpb.set_step(step);
    }
    threaded function bool lp_is_finished(lpbullet_data const& lpb)
    {
      return lpb.get_step() > lpb.get_step_limit();
    }
    erase_cond{lp_is_finished}(lparr);
  }
}

threaded struct
scene_control(node_factory const& nfac,
  collision_shape_data_array const& shapes0,
  tptr{tiled_voxel_texture} const& tvt0, tptr{texture_updates} const& tup0)
{
  public size_t const num_split = 3;
  public node_factory nodefac = nfac;
  public bool scene_paused = false;
  public float prev_spawn = 0.0;
  public joint_id_type joint_id_lp =
    nodefac.get_joint_id_by_name("lineparticle");
  public joint_id_type joint_id_font =
    nodefac.get_joint_id_by_name("default_font");
  public joint_id_type joint_id_rect2d =
    nodefac.get_joint_id_by_name("rect2d");
  public joint_id_type joint_id_dbgui =
    nodefac.get_joint_id_by_name_notrw("dbgui");
  public joint_id_type joint_id_dbgui2 =
    nodefac.get_joint_id_by_name_notrw("dbgui2");
  public size_t cur_scene = 0;
  public varray{tptr{lpbullet_swarm}} lpbullet_swarms;
  // public varray{lpbullet_data} lpbullet;
  public node mutable node_scene = make_node();
  public node mutable node_status_message = make_node();
  public node mutable node_buttons = make_node();
  public scene_objects sco = scene_objects(shapes0, num_split, tvt0, tup0);
  public darray{string} const scene_names = make_darray{string}(
    // "untitled", "saucer", "saucer-multi", "block-multi", "block",
    // "ab-multi", "ab-multi3", "skyscraper",
    // "al", "cessna", "skyscraper", "airboat",
    /*
    "parts",
    */
    // "knight-multi",
    "empty-scene",
    "box",
    "box-multi",
    "box-depth",
    "plane-multi-1",
    "plane-multi-2",
    "box_opt1",
    "mstex3d",
    "rigidbody-multi",
    "block-smtest",
    "block-multi",
    "saucer-multi",
    "bullet2-multi2s1",
    "bullet2-multi2s2",
    "bullet2-multi2s3",
    "bullet2-multi2s4",
    "bullet2-multi2s5",
    "bullet2-multi2s6",
    "bullet2-multi2s7",
    // "bullet2-multi2s8",
    // "bullet2-multi2s9",
    // "bullet2-multi2s10",
    // "bullet2-multi2s11",
    // "bullet2-multi2s12",
    "nest",
    "nest-multi",
    "saucer",
    "block-multi2",
    /*
    "bullet2-multi",
    "bullet-multi", "saucer-multi3",
    */
    "particle", "particle-multi",
    "particle-bb", "particle-bb-multi"
    );
  init();
  private function void init()
  {
    for (const i: 0 .. num_split) {
      lpbullet_swarms.push_back(make_tptr{lpbullet_swarm}());
    }
    node_scene = instantiate_cur_scene();
  }
  private function node instantiate_cur_scene()
  {
    const name = scene_names[cur_scene];
    mutable r = nodefac.make_node_by_name(name, mat4_identity());
    sco.clear_objects();
    for (const i, const& lpbsw: lpbullet_swarms) {
      sco.dworld.add_swarm(lpbsw, i);
    }
    if (r.children.empty()) {
      sco.add_collision_object(r);
    } else {
      mutable rnd = make_rand_generator(1U);
      /*
      if (cur_scene == 0) {
	const ch = r.children[1];
	const rb = sco.add_collision_object(ch).some;
	rb->apply_central_impulse(1.0f, 0.0f, 0.0f);
      } else
      */
      {
	for (const i, const& ch: r.children) {
	  const rb = sco.add_collision_object(ch).some;
	  rb->apply_torque_impulse(
	    rnd->generate_float() * 10.0f - 5.0f,
	    rnd->generate_float() * 10.0f - 5.0f,
	    rnd->generate_float() * 10.0f - 5.0f);
	  rb->apply_central_impulse(
	    rnd->generate_float() * 10.0f - 5.0f,
	    rnd->generate_float() * 10.0f - 5.0f,
	    rnd->generate_float() * 10.0f - 5.0f);
	}
      }
    }
    return r;
  }
  public function void scene_next(int v)
  {
    cur_scene = static_cast{size_t}(
      static_cast{int}(cur_scene + scene_names.size()) + v)
      % scene_names.size();
    node_scene = instantiate_cur_scene();
  }
}

threaded function void
scene_control_set_message(scene_control mutable& sctl,
  scene_node mutable& sn_text,
  cslice{string} const& msg, uint x, uint y, uint font_width, uint font_height,
  float screen_w, float screen_h)
{
  {
    const x0 = x;
    mutable& nd = sn_text;
    size_t n;
    for (const i, const& s: msg) {
      n += s.size();
    }
    while (nd.children.size() < n) {
      const p = scene_node(sctl.joint_id_font, mat4_identity());
      nd.children.push_back(p);
    }
    if (nd.children.size() > n) {
      nd.children.erase(n, nd.children.size());
    }
    size_t mi;
    size_t mj;
    for (const k, mutable& p: nd.children) {
      const& sli = p.trans.value.to_slice();
      while (mj >= msg[mi].size() && mi < msg.size()) {
	y += font_height;
	++mi;
	mj = 0;
	x = x0;
      }
      if (mi >= msg.size()) {
	break;
      }
      sli[0] = static_cast{float}((msg[mi][mj] & 0x7f) - 0x20);
      sli[1] = msg[mi][mj] >= 0x80 ? 1.0f : 0.0f; // 反転フラグ
      sli[2] = (static_cast{float}(x) / screen_w) * 2.0f - 1.0f;
      sli[3] = (static_cast{float}(y) / screen_h) * 2.0f - 1.0f;
      x += font_width;
      ++mj;
    }
  }
}

threaded function void
scene_control_update_buttons(scene_control mutable& sctl,
  scene_node mutable& sn_buttons)
{
  /* box */
  mutable& nd = sn_buttons;
  /*
  if (nd.children.size() < 1) {
    mutable p = scene_node(sctl.joint_id_rect2d, mat4_identity());
    const& sli = p.trans.value.to_slice();
    sli[0] = -0.99f;
    sli[1] = 0.81f;
    sli[2] = 0.18f;
    sli[3] = 0.18f;
    nd.children.push_back(p);
  }
  */
  if (sctl.joint_id_dbgui.vbid != vbid_invalid()) { // dbgui is enabled
    if (nd.children.size() < 2) {
      mutable p = scene_node(sctl.joint_id_dbgui, mat4_identity());
      // dbgui 左下
      const& sli = p.trans.value.to_slice();
      sli[0] = -0.9f;
      sli[1] = -0.9f;
      sli[2] = 0.9f;
      sli[3] = 0.9f;
      nd.children.push_back(p);
    }
    if (nd.children.size() < 3) {
      mutable p = scene_node(sctl.joint_id_dbgui2, mat4_identity());
      // dbgui2 全面に描画
      const& sli = p.trans.value.to_slice();
      sli[0] = -1.0f;
      sli[1] = -1.0f;
      sli[2] = 2.0f;
      sli[3] = 2.0f;
      nd.children.push_back(p);
    }
  }
}

threaded function void
scene_control_step(scene_control mutable& sctl,
  demoapp_scene_shared const& ss, raycast_objects mutable& robjs,
  projection_info const& pjinfo,
  float frame_speed, node_common_data mutable& ncd,
  cslice{prepare_instance_data_funcptr} const& ftable,
  whole_instances_type mutable& whole_instances)
{
  if (ss.scene_next != 0) {
    sctl.scene_next(ss.scene_next);
  }
  const speed = frame_speed;
  // mutable& snode = *sctl.snode;
  threaded function void step_lp()
  {
    for (const i, const& lpbsw: sctl.lpbullet_swarms) {
      lpbsw->on_step(speed);
    }
  }
  threaded function void spawn_lp_one(glm::mat4 const& m, float steplim,
    float length)
  {
    // size_t const lim = is_gles != 0 ? 20000U : 200000U;
    size_t const lim = static_cast{size_t}(300000U)
      / sctl.lpbullet_swarms.size();
    size_t min_n = lim;
    size_t min_lpsw = sctl.lpbullet_swarms.size();
    for (const i, const& lpbsw: sctl.lpbullet_swarms) {
      if (lpbsw->size() < min_n) {
	min_lpsw = i;
	min_n = lpbsw->size();
      }
    }
    if (min_n >= lim) {
      return;
    }
    {
      lpbullet_data lpb;
      const& s = m.to_cslice();
      const pos = glm::make_vec3(s[12], s[13], s[14]);
      const rot = m.to_3();
      const dir = rot * glm::make_vec3(0.0f, 0.0f, -1.5f);
      const p0 = pos + dir * 2.0f;
      const p1 = pos + dir * (2.0f + length);
      lpb.set_pos0(p0);
      lpb.set_pos1(p1);
      lpb.set_size(0.25f);
      lpb.set_step(0.0f);
      lpb.set_step_limit(steplim);
      sctl.lpbullet_swarms[min_lpsw]->lparr.push_back(lpb);
    }
    return;
  }
  scene_node sn_work = make_node();
  threaded function void prepare_one(scene_node const& sn)
  {
    const vbid = sn.joint_id.vbid;
    const vsid = sn.joint_id.vsid;
    if (vbid != vbid_invalid() && vsid != vsid_invalid()) {
      if (ss.raycast_layer != 0 && vbid >= ss.rdi.subdrawer_vbid_min &&
	vbid <= ss.rdi.subdrawer_vbid_max) {
	// debug_log("scene_control_step push robj vbid=", vbid);
	if (robjs.push_object(ss.rdi, pjinfo, sn)) {
	  // robjsにpushされた。あとでソートしてからインスタンス生成する。
	  return;
	}
      }
      mutable& idata = whole_instances[vbid][vsid];
      // debug_log("scene_control_step prepare_one vbid,vsid=", vbid, vsid);
      ftable[vbid](sn, ncd, idata);
    }
  }
  threaded function void step_snobj_dynamics(bool spawn_obj, bool spawn_lp_flag)
  {
    const physics_fps = 60;
    const timestep = 1.0f / static_cast{float}(physics_fps);
    const timestep_inv = static_cast{float}(physics_fps);
    if (!sctl.scene_paused) {
      if (spawn_obj) {
	const a = ss.posang.angle * glm::make_vec3(0.0f, 0.0f, -1.0f);
	mutable posang = ss.posang;
	posang.position += a * 0.1f;
	scene_node cnode = scene_node(
	  sctl.sco.name_to_joint_id["smallbox"], posang.to_mat4());
	const& pos_delta = ss.pos_delta;
	const rb = sctl.sco.add_collision_object(cnode).some;
	// debug_log("pos_delta", pos_delta);
	rb->set_linear_velocity(
	  pos_delta.x * timestep_inv,
	  pos_delta.y * timestep_inv,
	  pos_delta.z * timestep_inv);
	  // playerの速度を初速にする
	rb->apply_central_impulse(a.x, a.y, a.z);
	  // 向いている方向にさらにimpulseを加える
	// debug_log("spawn_obj", sctl.sco.dworld.objects_size());
      }
    }
    sctl.sco.dworld.step_simulation(sctl.scene_paused, speed * timestep, 1,
      speed * timestep);
    {
      // 大オブジェクトに小オブジェクトが衝突した。とりあえず小オブジェクト
      // を消すようにしておく。後で修正。 TODO
      varray{ptr{rigid_body_i}} rb_to_remove;
      threaded function void remove_if(size_t i, ptr{rigid_body_i} const& obj)
      {
	if (obj->get_collide()) {
	  rb_to_remove.push_back(obj);
	}
      }
      sctl.sco.dworld.rigid_bodies_foreach{remove_if}();
      for (const i, const& rb: rb_to_remove) {
	sctl.sco.dworld.remove_rigid_body(rb);
      }
    }
    scene_node cursn = scene_node(joint_id_type(), mat4_identity());
    threaded function void step_obj(size_t i, ptr{rigid_body_i} const& obj)
    {
      cursn.joint_id = obj->get_joint_id();
      obj->get_world_transform_mat4(cursn.trans.value);
      prepare_one(cursn);
      if (!sctl.scene_paused && spawn_lp_flag) {
	spawn_lp_one(cursn.trans.value, 200.0f, 1.0f);
      }
    }
    sctl.sco.dworld.rigid_bodies_foreach{step_obj}();
    if (sctl.scene_paused && spawn_lp_flag) {
      mutable posang = ss.posang;
      posang.position += posang.angle * glm::make_vec3(0.0f, 5.0f, -5.0f);
      posang.angle *= glm::make_quat_angle_axis(to_radians(-90.0f),
	1.0f, 0.0f, 0.0f);
      const m = posang.to_mat4();
      spawn_lp_one(m, 10000.0f, 0.1f);
    }
  }
  step_lp(); /* lineparticle */
  bool spawn_lp_flag = false;
  {
    sctl.prev_spawn += speed;
    if (sctl.prev_spawn > 3.0) {
      spawn_lp_flag = ss.light_on != 0.0f;
      sctl.prev_spawn -= 3.0;
    }
  }
  if (const& v: ss.app_commands["scene_pause"]) {
    sctl.scene_paused = !sctl.scene_paused;
  }
  {
    bool spawn_obj_flag = false;
    if (const& v: ss.app_commands["throw"]) {
      spawn_obj_flag = true;
    }
    step_snobj_dynamics(spawn_obj_flag, spawn_lp_flag);
  }
}

