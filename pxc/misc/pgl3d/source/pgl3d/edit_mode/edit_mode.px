private threaded namespace pgl3d::edit_mode::edit_mode "use-unsafe";
public import common -;
public import meta m;
private import pgl3d::edit_mode::base -;
private import sdl2::api_types -;
private import sdl2::api_functions -;
private import text::serialize::compact_pod -;
private import pgl3d::texture::copy_data -;
private import pgl3d::texture::generator -;
private import pgl3d::edit_mode::procedural -;
private import pgl3d::edit_mode::vecutil -;
private import pgl3d::edit_mode::texutil -;
private import pgl3d::edit_mode::tiled_voxel_texture -;
private import pgl3d::edit_mode::tiled_texture_edit_view -;
private import pgl3d::edit_mode::edit_mode_texture -;
private import pgl3d::edit_mode::sync_gl -;

private metafunction save_dir "/build/saved/";

public struct edit_mode(ptr{edit_mode_texture} const& emt0)
<edit_mode_i>
{
  private struct edit_state {
    public ttev_state ttev;
    public glm::ivec3 cdir;
  }
  private ptr{edit_mode_texture} emt = emt0;
  private ptr{tiled_texture_edit_view} const ttev =
    make_ptr{tiled_texture_edit_view}(emt0);
  private texture_data const tile = emt->vox.voxtile;
  private projection_info prj;
  private copy_data_type copy_data;
  private ptr{rand_generator} rndp = make_rand_generator(123u);
  private ptr{rand_generator} rndp_saved = rndp;
  private int gen_test_param = 0;
  /*
  private uvec3 copy_size;
  private texture_data copy_data;
  private texture_data copy_data_sec;
  */
  private glm::ivec3 cdir = glm::make_ivec3(1, 1, 1);
  private edit_params_mode_t edit_params_mode;
  private color_param edit_color_param;
  private plane_param edit_plane_param;
  private sphere_param edit_sphere_param;
  private bool mark_set;
  private bool copied;
  private glm::uvec3 find_empty_cur; // 空のタイルを探すのに使う
  private string message;
  private SDL_Scancode prev_key; // 同じキーを繰り返したかどうか判定するのに使う
  private uint prev_modmask;
  private uint prev_key_repeat;
  private bool console_mode;
  private string console_text;
  private size_t console_text_cursor;
  init();
  private function void init()
  {
    /*
    debug_log("edit_mode", "voxtmap",
      texture_data_get_size(emt->vox.tmap_pri[0]));
    */
    string buf;
    {
      sdl_load_file("/build/edit_selection.ser", buf);
      if (!buf.empty()) {
        copy_data = copy_data_type_compat_deserialize(buf);
      }
    }
    {
      edit_state est;
      sdl_load_file("/build/edit_state.raw", buf);
      if (!buf.empty()) {
        est = from_string_compact_pod{edit_state}(buf);
        ttev->set_state(est.ttev);
        cdir = est.cdir;
      }
    }
    update_cursor_color();
  }
  private function void save_state()
  {
    debug_log("edit_mode: save");
    edit_state est;
    est.ttev = ttev->get_state();
    est.cdir = cdir;
    sdl_save_file("/build/edit_state.raw", to_string_compact_pod(est));
    const tsz = emt->vox.tmap_edit->data_pri[0].get_size_uvec3();
    const sz = map{uvec3, integral_log2{uint}}(tsz);
    {
      string fn = "/build/edit_2_" + to_string(sz.x) + "_"
        + to_string(sz.y) + "_" + to_string(sz.z) + ".raw";
      sdl_save_file(fn, to_string_compact_pod(emt->vox));
    }
    {
      string fn = "/build/edit_selection.ser";
      sdl_save_file(fn, to_string(copy_data));
    }
    {
      texture_edit const& tpat = *emt->vox.tpat_edit;
      string fn = "/build/edit_common_tpat.raw";
      sdl_save_file(fn, to_string_compact_pod(tpat));
    }
    {
      texture_reshaped const& tmpri = emt->vox.tmap_edit->data_pri[0];
      texture_reshaped tmpri_cpy;
      tmpri_cpy.set_size_l2(6u, 6u, 6u);
      texture_data_copy_range(tmpri_cpy, uvec3(), tmpri, uvec3(),
        make_uvec3(64u, 64u, 64u));
      sdl_save_file("/build/edit_common_tmpri.raw",
        to_string_compact_pod(tmpri_cpy));
      texture_reshaped const& tmsec = emt->vox.tmap_edit->data_sec[0];
      texture_reshaped tmsec_cpy;
      tmsec_cpy.set_size_l2(6u, 6u, 6u);
      texture_data_copy_range(tmsec_cpy, uvec3(), tmsec, uvec3(),
        make_uvec3(64u, 64u, 64u));
      sdl_save_file("/build/edit_common_tmsec.raw",
        to_string_compact_pod(tmsec_cpy));
    }
    message = "edit_mode: saved";
  }
  public function void set_camera_angle(glm::quat const& angle)
  {
  }
  private function void update_cursor_color()
  {
    uint c =
      edit_params_mode == edit_params_mode_none ? 0xffffffffu :
      edit_params_mode == edit_params_mode_color ? 0xffff0000u :
      edit_params_mode == edit_params_mode_plane ? 0xffffff00u :
      edit_params_mode == edit_params_mode_sphere_1 ? 0xffff00ffu :
      0xff0000ffu;
    ttev->set_cursor_color(c, 0xffc08040);
    // debug_log("update_cursor_color", c);
  }
  public function string get_console_text() const
  {
    string r = console_text;
    if (console_text_cursor >= console_text.size()) {
      r.push_back(0x20 | 0x80);
    } else {
      r[console_text_cursor] |= 0x80;
    }
    return "> " + r;
  }
  public function void on_textinput(string const& s, string mutable& msg_r)
  {
    if (console_text_cursor >= console_text.size()) {
      console_text += s;
    } else {
      const r = console_text[0 .. console_text_cursor] + s
        + console_text[console_text_cursor .. console_text.size()];
      console_text = r;
    }
    console_text_cursor += s.size();
    // debug_log("on_textinput: ", s, console_text);
    msg_r = get_console_text();
  }
  public function bool is_textinput_mode() const
  {
    return console_mode;
  }
  private function void execute_console_command()
  {
    varray{string} toks;
    string_split{' '}(console_text, toks);
    if (toks.empty()) {
      return;
    }
    const& cmd = toks[0];
    if (cmd == "save" && toks.size() == 2) {
      const fn = save_dir + toks[1];
      sdl_save_file(fn, to_string(copy_data));
      debug_log("saved", fn);
    } else if (cmd == "load" && toks.size() == 2) {
      string buf;
      const fn = save_dir + toks[1];
      sdl_load_file(fn, buf);
      if (!buf.empty()) {
        copy_data = copy_data_type_compat_deserialize(buf);
        /*
        const fst = ttev->get_cursor_pos().first;
        const snd = to_uvec3(map{ivec3, max}(
          to_ivec3(fst)
          + to_ivec3(copy_data.copy_size)
          - make_ivec3(1, 1, 1)
          - to_ivec3(copy_data.cursor_offset), ivec3()));
        */
        mark_set = true;
        copied = true;
        // debug_log("cursor", fst, snd);
        glm::vec3 cursor_move_r;
        move_cursor(0, 0, 0, cursor_move_r);
        /*
        ttev->set_cursor_pos(fst, snd);
        */
        debug_log("loaded", fn);
      } else {
        debug_log("failed to load", fn);
      }
    } else {
      debug_log("unrecognized command", toks);
    }
  }
  public function void on_key_pressed(int scancode, uint modmask,
    glm::vec3 mutable& cursor_move_r, string mutable& msg_r)
  {
    message = "";
    cursor_move_r = glm::vec3();
    SDL_Scancode key = static_cast{SDL_Scancode}(scancode);
    prev_key_repeat = (prev_key == key && prev_modmask == modmask)
      ? prev_key_repeat + 1u : 0u;
    prev_key = key;
    prev_modmask = modmask;
    const mod_shift = (modmask & 1) == 1;
    const mod_rshift = (modmask & 2) == 2;
    const mod_ctrl = (modmask & 4) == 4;
    const mod_rctrl = (modmask & 8) == 8;
    const mod_cs = (modmask & 5) == 5;
    const mod_rcs = (modmask & 10) == 10;
    const cursor_spd = mod_shift ? 16 : 1;
    if (console_mode) {
      if (key == SDL_SCANCODE_ESCAPE || key == SDL_SCANCODE_RETURN) {
        if (key == SDL_SCANCODE_RETURN) {
          execute_console_command();
        }
        console_mode = false;
        SDL_StopTextInput();
        console_text = string();
        console_text_cursor = 0;
        msg_r = string();
        return;
      }
      if (key == SDL_SCANCODE_BACKSPACE) {
        if (console_text_cursor > 0) {
          // debug_log("cur,txt", console_text_cursor, console_text);
          const s = console_text[0 .. console_text_cursor - 1u] +
            console_text[console_text_cursor .. console_text.size()];
          console_text = s;
          --console_text_cursor;
        }
      } else if (key == SDL_SCANCODE_LEFT) {
        if (console_text_cursor > 0) {
          --console_text_cursor;
        }
      } else if (key == SDL_SCANCODE_RIGHT) {
        if (console_text_cursor < console_text.size()) {
          ++console_text_cursor;
        }
      }
      msg_r = get_console_text();
      return;
    }
    if (key == SDL_SCANCODE_ESCAPE) {
      console_mode = true;
      SDL_StartTextInput();
      console_text = string();
      console_text_cursor = 0;
      msg_r = get_console_text();
      return;
    } else if (key == SDL_SCANCODE_F5 || key == SDL_SCANCODE_F12) {
      emt->vox.update_mipmap();
      sync_gl_mipmap_all(*emt);
      if (key == SDL_SCANCODE_F12) {
        save_state();
      }
    } else if (key == SDL_SCANCODE_1) {
      if (mod_shift) {
        change_fill_type(edit_fill_type_blank, mod_ctrl, prev_key_repeat);
      } else {
        edit_params_mode = edit_params_mode_none;
        update_cursor_color();
        // message = "exiting edit-params mode";
      }
    } else if (key == SDL_SCANCODE_2) {
      if (mod_shift) {
        change_fill_type(edit_fill_type_wall, mod_ctrl, prev_key_repeat);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_color;
      update_cursor_color();
      // message = "entering edit-color mode";
    } else if (key == SDL_SCANCODE_3) {
      if (mod_shift) {
        change_fill_type(edit_fill_type_plane, mod_ctrl, prev_key_repeat);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_plane;
      update_cursor_color();
      // message = "entering edit-plane-params mode";
    } else if (key == SDL_SCANCODE_4) {
      if (mod_shift) {
        change_fill_type(edit_fill_type_sphere, mod_ctrl, prev_key_repeat);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_sphere_1;
      update_cursor_color();
      // message = "entering edit-sphere-center-distance mode";
    } else if (key == SDL_SCANCODE_9) {
      if (mod_shift) {
        gen_test_param = min(gen_test_param + 1, 15);
        *rndp = *rndp_saved;
      } else if (mod_ctrl) {
        gen_test_param = max(gen_test_param - 1, -15);
        *rndp = *rndp_saved;
      }
      debug_log("gen_test_param", gen_test_param);
      *rndp_saved = *rndp;
      gen_test();
    }
    if (edit_params_mode == edit_params_mode_none) {
      // パラメータ変更モードでは無い場合。カーソル移動やコピペなどの
      // 操作を処理する。
      if (key == SDL_SCANCODE_MINUS) {
        set_space();
      } else if (key == SDL_SCANCODE_C) {
        copy_value();
      } else if (key == SDL_SCANCODE_V) {
        merge_mode const mmod =
          mod_ctrl ? merge_mode_or_ori() : merge_mode_opaque();
        paste_value(mod_shift ? 0x02u : 0xffu, mmod);
          // mod_shiftなら色だけ貼り付け
      } else if (key == SDL_SCANCODE_COMMA) {
        if (mod_shift) {
          shrink_range();
        }
      } else if (key == SDL_SCANCODE_PERIOD) {
        if (mod_shift) {
          scale_range();
        }
      } else if (key == SDL_SCANCODE_I) {
        if (mod_ctrl) {
          select_contiguous();
        } else if (mod_shift) {
          swap_cursor();
        } else {
          set_mark();
        }
      } else if (key == SDL_SCANCODE_H) {
        if (mod_rcs) {
          cdir.x = -cdir.x;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          if (ssz.y == ssz.z) {
            rotate_range(glm::make_imat3(1, 0, 0, 0, 0, -1, 0, 1, 0));
          } else {
            debug_log("ssz.y != ssz.z");
          }
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(-1, 0, 0, 0, 1, 0, 0, 0, 1));
        } else {
          move_cursor(-cdir.x * cursor_spd, 0, 0, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_L) {
        if (mod_rcs) {
          cdir.x = -cdir.x;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          if (ssz.y == ssz.z) {
            rotate_range(glm::make_imat3(1, 0, 0, 0, 0, 1, 0, -1, 0));
          } else {
            debug_log("ssz.y != ssz.z");
          }
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(-1, 0, 0, 0, 1, 0, 0, 0, 1));
        } else {
          move_cursor(cdir.x * cursor_spd, 0, 0, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_J) {
        if (mod_rcs) {
          cdir.y = -cdir.y;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          if (ssz.z == ssz.x) {
            rotate_range(glm::make_imat3(0, 0, 1, 0, 1, 0, -1, 0, 0));
          } else {
            debug_log("ssz.z != ssz.x");
          }
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(1, 0, 0, 0, -1, 0, 0, 0, 1));
        } else {
          move_cursor(0, -cdir.y * cursor_spd, 0, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_K) {
        if (mod_rcs) {
          cdir.y = -cdir.y;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          if (ssz.z == ssz.x) {
            rotate_range(glm::make_imat3(0, 0, -1, 0, 1, 0, 1, 0, 0));
          } else {
            debug_log("ssz.z != ssz.x");
          }
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(1, 0, 0, 0, -1, 0, 0, 0, 1));
        } else {
          move_cursor(0, cdir.y * cursor_spd, 0, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_N) {
        if (mod_rcs) {
          cdir.z = -cdir.z;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          if (ssz.x == ssz.y) {
            rotate_range(glm::make_imat3(0, -1, 0, 1, 0, 0, 0, 0, 1));
          } else {
            debug_log("ssz.x != ssz.y");
          }
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(1, 0, 0, 0, 1, 0, 0, 0, -1));
        } else {
          move_cursor(0, 0, -cdir.z * cursor_spd, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_P) {
        if (mod_rcs) {
          cdir.z = -cdir.z;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          if (ssz.x == ssz.y) {
            rotate_range(glm::make_imat3(0, 1, 0, -1, 0, 0, 0, 0, 1));
          } else {
            debug_log("ssz.x != ssz.y");
          }
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(1, 0, 0, 0, 1, 0, 0, 0, -1));
        } else {
          move_cursor(0, 0, cdir.z * cursor_spd, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_0) {
        if (get_cursor_tpat()) {
          if (mod_shift) {
            convert_to_tmap();
          } else {
            set_cursor_tpat(false);
          }
        } else {
          if (mod_shift) {
            convert_to_tpat();
          } else {
            if (is_cur_tmap_node_reference()) {
              set_cursor_tpat(true);
            }
          }
        }
      }
    } else {
      // パラメータ変更モードの場合。それぞれのモードに応じて動作は変わる。
      if (key == SDL_SCANCODE_H) {
        set_param(cdir.x > 0 ? 0 : 1, modmask);
      } else if (key == SDL_SCANCODE_L) {
        set_param(cdir.x > 0 ? 1 : 0, modmask);
      } else if (key == SDL_SCANCODE_J) {
        set_param(cdir.y > 0 ? 2 : 3, modmask);
      } else if (key == SDL_SCANCODE_K) {
        set_param(cdir.y > 0 ? 3 : 2, modmask);
      } else if (key == SDL_SCANCODE_N) {
        set_param(cdir.z > 0 ? 4 : 5, modmask);
      } else if (key == SDL_SCANCODE_P) {
        set_param(cdir.z > 0 ? 5 : 4, modmask);
      } else if (key == SDL_SCANCODE_COMMA) {
        set_param(6, modmask);
      } else if (key == SDL_SCANCODE_PERIOD) {
        set_param(7, modmask);
      } else if (key == SDL_SCANCODE_SLASH) {
        set_param(8, modmask);
      }
      ttev->cursor_flick_hide();
    }
    // debug_log("scancode", scancode);
    if (message.empty()) {
      message = "cursor " + to_string(ttev->get_cursor_pos().first);
      if (mark_set) {
        message += " " + to_string(to_ivec3(
          ttev->get_cursor_pos().second - ttev->get_cursor_pos().first));
      }
      if (edit_params_mode == edit_params_mode_color) {
        message += " [color params]";
      } else if (edit_params_mode == edit_params_mode_plane) {
        message += " [plane params]";
      } else if (edit_params_mode == edit_params_mode_sphere_1) {
        message += " [sphere params]";
      }
      size_t mlv = 0u;
      if (prj.option_value2 >= 0.0) {
        mlv = static_cast{size_t}(prj.option_value2);
      }
      size_t mlpat;
      size_t mlmap;
      const vs = get_cur_value(texture_value_index_secondary, mlv, mlpat,
        mlmap);
      const vp = get_cur_value(texture_value_index_primary, mlv, mlpat, mlmap);
      if (is_space_voxel(vp)) {
        const dv = get_dist_3d(vp);
        message += " space " + to_string(dv) + " mip " + to_string(mlpat)
          + " " + to_string(mlmap);
      } else if (is_node_reference(vp)) {
        const rp = decode_noderef_param(vp);
        message += " ref " + to_string(rp);
      } else if (is_filled(vp)) {
        message += " filled";
      } else if (is_plane_node(vp)) {
        const pp = decode_plane_node(vp);
        message += " plane " + to_string(pp);
      } else if (is_sphere_node(vp)) {
        const sp = decode_sphere_node(vp);
        message += " sphere " + to_string(sp);
      }
      if (!is_space_voxel(vp) && !is_node_reference(vp)) {
        const cp = decode_color_param(vs);
        message += " " + to_string(cp);
      }
    }
    msg_r = message;
  }
  private function void select_contiguous()
  {
  }
  private function void set_mark()
  {
    mark_set = !mark_set;
    if (!mark_set) {
      copied = false;
    }
    const cur = ttev->get_cursor_pos();
    ttev->set_cursor_pos(cur.first, cur.first);
    /*
    if (mark_set) {
      message = "edit_mode: set mark";
    } else {
      message = "edit_mode: reset mark";
    }
    */
  }
  private function void swap_cursor()
  {
    const cur = ttev->get_cursor_pos();
    ttev->set_cursor_pos(cur.second, cur.first);
  }
  private function void move_cursor(int x, int y, int z,
    glm::vec3 mutable& cursor_move_r)
  {
    mutable cur = ttev->get_cursor_pos();
    const old_pos = to_ivec3(cur.first);
    mutable pos = old_pos;
    pos += make_ivec3(x, y, z);
    pos = ttev->clamp_cursor_pos(pos);
    cur.first = to_uvec3(pos);
    if (copied) {
      mutable cpos = cur.first;
      const coff = copy_data.cursor_offset;
      const cmx = to_ivec3(copy_data.copy_size) - make_ivec3(1, 1, 1);
      ivec3 scur;
      scur.x = (coff.x == 0) ? cmx.x : -cmx.x;
      scur.y = (coff.y == 0) ? cmx.y : -cmx.y;
      scur.z = (coff.z == 0) ? cmx.z : -cmx.z;
      mutable spos = to_ivec3(cpos) + scur;
      spos = map{ivec3, max}(spos, make_ivec3(0, 0, 0));
      cur.second = to_uvec3(spos);
    } else if (!mark_set) {
      cur.second = cur.first;
    }
    ttev->set_cursor_pos(cur.first, cur.second);
    {
      // テクスチャ座標でのカーソル移動量を計算
      cursor_move_r = to_vec3(
        to_ivec3(ttev->get_cursor_pos().first) - old_pos);
      const tms_max = fold_list{max}(1u, ttev->tmap_size);
      cursor_move_r /= static_cast{float}(tms_max);
      if (get_cursor_tpat()) {
        const ts_max = fold_list{max}(1u, ttev->tile_size);
        cursor_move_r /= static_cast{float}(ts_max);
      }
    }
    {
      // 乱数のシードをカーソル位置から初期化
      uint v = (cur.first.x << 16u) | (cur.first.y << 8u) | (cur.first.z);
      rndp = make_rand_generator(v);
    }
  }
  private function bool get_cursor_tpat() const
  {
    return ttev->get_cursor_tpat();
  }
  private function void set_cursor_tpat(bool tpat)
  {
    if (tpat && !get_cursor_tpat()) {
      const tppos = cur_tpat_base();
      ttev->set_tpat_cursor_pos(tppos, tppos);
    }
    ttev->set_cursor_tpat(tpat);
    /*
    if (tpat) {
      message = "edit_mode: pattern edit mode";
    } else {
      message = "edit_mode: map edit mode";
    }
    */
  }
  private function void set_param(int v, uint modmask)
  {
    const uchar mult = static_cast{uchar}(((modmask & 1) != 0 )? 16u : 1u);
    const use_plane = (modmask & 1) != 0;
    if (edit_params_mode == edit_params_mode_color) {
      set_param_color(v, mult);
    } else if (edit_params_mode == edit_params_mode_plane) {
      set_param_plane(v);
    } else if (edit_params_mode == edit_params_mode_sphere_1) {
      set_param_sphere_1(v, modmask);
    }
  }
  private function void set_param_color(int v, uchar mult)
  {
    mutable& p = edit_color_param;
    function void inc(uint mutable& v) {
      v = (v + mult < 255u) ? v + mult : 255u;
    }
    function void dec(uint mutable& v) {
      v = (v > mult) ? v - mult : 0u;
    }
    if (v == 0) {
      dec(p.rgb.r);
    } else if (v == 1) {
      inc(p.rgb.r);
    } else if (v == 2) {
      dec(p.rgb.g);
    } else if (v == 3) {
      inc(p.rgb.g);
    } else if (v == 4) {
      dec(p.rgb.b);
    } else if (v == 5) {
      inc(p.rgb.b);
    } else if (v == 6) {
      inc(p.roughness);
      p.roughness &= 0x0fu;
    } else if (v == 7) {
      if (p.emission != 0) {
        p.emission = 0;
        p.metalness = 1;
      } else if (p.metalness != 0) {
        p.emission = 0;
        p.metalness = 0;
      } else {
        p.emission = 1;
        p.metalness = 0;
      }
    }
    // debug_log("color_param", p);
    fill_range_color(p, false);
    // message = "edit_mode: set color " + to_string(p);
  }
  private function void set_param_plane(int v)
  {
    mutable& p = edit_plane_param;
    if (v == 0) {
      p.nor.x -= 1;
    } else if (v == 1) {
      p.nor.x += 1;
    } else if (v == 2) {
      p.nor.y -= 1;
    } else if (v == 3) {
      p.nor.y += 1;
    } else if (v == 4) {
      p.nor.z -= 1;
    } else if (v == 5) {
      p.nor.z += 1;
    } else if (v == 6) {
      p.dist -= 1;
    } else if (v == 7) {
      p.dist += 1;
    }
    p.clamp_param();
    fill_range_plane(p, false);
    // message = "edit_mode: set plane params " + to_string(p);
  }
  private function void set_param_sphere_1(int v, uint modifier)
  {
    mutable& p = edit_sphere_param;
    if ((modifier & 1) == 0) {
      if (v == 0) {
        p.center.x -= 1;
      } else if (v == 1) {
        p.center.x += 1;
      } else if (v == 2) {
        p.center.y -= 1;
      } else if (v == 3) {
        p.center.y += 1;
      } else if (v == 4) {
        p.center.z -= 1;
      } else if (v == 5) {
        p.center.z += 1;
      } else if (v == 6) {
        p.dist = p.dist > 1 ? p.dist - 1 : 1;
      } else if (v == 7) {
        p.dist = p.dist < 63 ? p.dist + 1 : 63;
      } else if (v == 8) {
        p.ura = !p.ura;
      }
    } else {
      if (v == 0) {
        p.scale.x = p.scale.x > 0 ? p.scale.x - 1 : 0;
      } else if (v == 1) {
        p.scale.x = p.scale.x < 3 ? p.scale.x + 1 : 3;
      } else if (v == 2) {
        p.scale.y = p.scale.y > 0 ? p.scale.y - 1 : 0;
      } else if (v == 3) {
        p.scale.y = p.scale.y < 3 ? p.scale.y + 1 : 3;
      } else if (v == 4) {
        p.scale.z = p.scale.z > 0 ? p.scale.z - 1 : 0;
      } else if (v == 5) {
        p.scale.z = p.scale.z < 3 ? p.scale.z + 1 : 3;
      }
    }
    fill_range_sphere(p, false, modifier);
    // FIXME?
    message = "edit_mode: set sphere center/dist params " + to_string(p);
  }
  private function void copy_value()
  {
    const cur = ttev->get_cursor_range();
    copy_data.copy_size = cur.second;
    copy_data.cursor_offset = ttev->get_cursor_pos().first - cur.first;
    debug_log("copy_value: cursor_offset", copy_data.cursor_offset);
    const sz_l2 = map{uvec3, integral_log2{uint}}(copy_data.copy_size);
    for (const i, mutable& tex: copy_data.tex) {
      tex.set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    }
    ttev->edit_copy_range(cur.first, cur.second, copy_data.tex[0],
      copy_data.tex[1], uvec3());
    mark_set = true;
    copied = true;
    // message = "edit_mode: copy value " + to_string(copy_data.copy_size);
  }
  private function void paste_value(uint index_mask, merge_mode const& mmod)
  {
    const cpos = ttev->get_cursor_pos().first;
    // ペースト先の領域を計算
    const mi_0 = to_ivec3(cpos) - to_ivec3(copy_data.cursor_offset);
    const mx_0 = mi_0 + to_ivec3(copy_data.copy_size) - make_ivec3(1, 1, 1);
    // ペースト先の領域をclamp
    const mi = ttev->clamp_cursor_pos(mi_0);
    const mx = ttev->clamp_cursor_pos(mx_0);
    const sz = mx - mi + make_ivec3(1, 1, 1);
    // ペースト元の領域を計算
    const cd_mi = mi - mi_0;
    /*
    debug_log("paste_value: cpos,mi_0,mx_0,mi,mx,sz,cd_mi", cpos,
      mi_0, mx_0, mi, mx, sz, cd_mi);
    */
    ttev->edit_paste_range(to_uvec3(mi), to_uvec3(sz), copy_data.tex[0],
      copy_data.tex[1], to_uvec3(cd_mi), index_mask, mmod);
    // message = "edit_mode: paste value " + to_string(sz);
  }
  private function void convert_to_tmap()
  {
    // TODO
  }
  private function void convert_to_tpat()
  {
    // debug_log("convert_to_tpat");
    if (get_cursor_tpat()) {
      // debug_log("convert_to_tpat: 0");
      return;
    }
    const cur = ttev->get_cursor_pos().first;
    const v = ttev->tmap_edit_get(cur, texture_value_index_primary, 0u);
    if (is_node_reference(v)) {
      // debug_log("convert_to_tpat: 1");
      return;
    }
    const nv = find_empty_tpat();
    if (!is_node_reference(nv)) {
      // debug_log("convert_to_tpat: 2");
      return;
    }
    // debug_log("find", to_hexstring(nv));
    ttev->set_cursor_pos(cur, cur);
    // debug_log("convert_to_tpat: cursor:", ttev->get_cursor_pos());
    copy_value(); // tmapの一個のボクセルをコピー
    // debug_log("convert_to_tpat: copy_data:", copy_data, ttev->get_cursor_pos());
    ttev->tmap_edit_set(cur, texture_value_index_primary, nv);
    // debug_log("convert_to_tpat: cursor1:", ttev->get_cursor_pos());
    set_cursor_tpat(true);
    // debug_log("convert_to_tpat: cursor2:", ttev->get_cursor_pos());
    paste_value(0xffu, merge_mode_opaque());
    // debug_log("convert_to_tpat: cursor3:", ttev->get_cursor_pos());
    const tsz = ttev->tile_size;
    while (copy_data.copy_size.x < tsz.x) {
      // debug_log("convert_to_tpat: copy_size", copy_data.copy_size);
      scale_range();
    }
    // debug_log("convert_to_tpat: yy", copied);
    // set_mark(); // マークをリセット
    // debug_log("convert_to_tpat: finished", copied);
    // debug_log("convert_to_tpat: 3");
  }
  private function texel_value find_empty_tpat()
  {
    const p0 = find_empty_cur;
    mutable p = p0;
    const tsz = ttev->tile_size;
    const tpsz = map{uvec3, operator::div}(ttev->tpat_size, tsz);
    while (true) {
      if (++p.x >= tpsz.x) {
        p.x = 0;
        if (++p.y >= tpsz.y) {
          p.y = 0;
          if (++p.z >= tpsz.z) {
            p.z = 0;
          }
        }
      }
      if (p == p0) {
        break;
      }
      const pbase = map{uvec3, operator::mul}(p, tsz);
      bool is_space = true;
      for (const z: 0 .. tsz.z) {
        for (const y: 0 .. tsz.y) {
          for (const x: 0 .. tsz.x) {
            const cp = make_uvec3(pbase.x + x, pbase.y + y, pbase.z + z);
            const cv = ttev->tpat_edit_get(cp, texture_value_index_primary,
              0u);
            is_space &= is_space_voxel(cv);
          }
        }
      }
      // debug_log("find_empty_tpat", p, is_space);
      if (is_space) {
        find_empty_cur = p;
        return make_node_reference((p.z << 16) | (p.y << 8) | (p.x << 0));
      }
    }
    return make_space_voxel();
  }
  private function void shrink_range()
  {
    {
      // 選択領域のサイズが2の倍数でなかったときの処理
      const cp = ttev->get_cursor_pos();
      mutable cd = to_ivec3(cp.second) - to_ivec3(cp.first);
      if (cd.x == 0 || cd.y == 0 || cd.z == 0) {
        return;
      }
      function void trunc_if_even(int mutable& v) {
        if (v % 2 == 0) {
          v += (v < 0) ? 1 : -1;
        }
      }
      trunc_if_even(cd.x);
      trunc_if_even(cd.y);
      trunc_if_even(cd.z);
      const cpm = to_uvec3(to_ivec3(cp.first) + cd);
      ttev->set_cursor_pos(cp.first, cp.second);
    }
    {
      // 縮小処理
      copy_value();
      const oszl2 = copy_data.tex[0].get_size_l2_uvec3();
      texture_data dpri;
      texture_data daux;
      dpri.set_size_l2(oszl2.x, oszl2.y, oszl2.z);
      daux.set_size_l2(oszl2.x, oszl2.y, oszl2.z);
      const sz = copy_data.copy_size / 2u;
      ivec3 dbase;
      dbase.x = (copy_data.cursor_offset.x == 0) ? 0 : si(sz.x);
      dbase.y = (copy_data.cursor_offset.y == 0) ? 0 : si(sz.y);
      dbase.z = (copy_data.cursor_offset.z == 0) ? 0 : si(sz.z);
      for (const z: 0 .. sz.z) {
        for (const y: 0 .. sz.y) {
          for (const x: 0 .. sz.x) {
            const p = make_ivec3(si(x), si(y), si(z));
            texel_value dpri_v;
            texel_value dsec_v;
            shrink_voxel_value(false, copy_data.tex[0], copy_data.tex[1],
              dpri_v, dsec_v, p);
            dpri.set(ui(p.x + dbase.x), ui(p.y + dbase.y), ui(p.z + dbase.z),
              dpri_v);
            daux.set(ui(p.x + dbase.x), ui(p.y + dbase.y), ui(p.z + dbase.z),
              dsec_v);
          }
        }
      }
      copy_data.tex[0] = dpri;
      copy_data.tex[1] = daux;
      paste_value(0xffu, merge_mode_opaque());
    }
    {
      // 選択領域を縮小
      const cp = ttev->get_cursor_pos();
      mutable cd = to_ivec3(cp.second) - to_ivec3(cp.first);
      cd /= 2;
      const cpm = to_ivec3(cp.first) + cd;
      ttev->set_cursor_pos(cp.first, to_uvec3(cpm));
      copy_value();
    }
  }
  private function void scale_range()
  {
    // debug_log("scale_range: p0: copy_data:", copy_data, ttev->get_cursor_pos());
    copy_value();
    // debug_log("scale_range: p1: copy_data:", copy_data, ttev->get_cursor_pos());
    texture_data spri;
    texture_data saux;
    const szl2 = copy_data.tex[0].get_size_l2_uvec3() + make_uvec3(1, 1, 1);
    spri.set_size_l2(szl2.x, szl2.y, szl2.z);
    saux.set_size_l2(szl2.x, szl2.y, szl2.z);
    const sz = copy_data.copy_size;
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
        for (const x: 0 .. sz.x) {
          scale_voxel_value(copy_data.tex[0].get(x, y, z),
            copy_data.tex[1].get(x, y, z), spri, saux,
            si(x * 2), si(y * 2), si(z * 2));
        }
      }
    }
    copy_data.tex[0] = spri;
    copy_data.tex[1] = saux;
    copy_data.copy_size *= 2u;
    mutable& o = copy_data.cursor_offset;
    o *= 2u;
    if (o.x != 0u) { o.x += 1u; }
    if (o.y != 0u) { o.y += 1u; }
    if (o.z != 0u) { o.z += 1u; }
    // debug_log("scale_range: 0: copy_data:", copy_data, ttev->get_cursor_pos());
    paste_value(0xffu, merge_mode_opaque());
    // debug_log("scale_range: 1: copy_data:", copy_data, ttev->get_cursor_pos());
    // 選択領域を広げたので反映させるためにmove_cursorを呼ぶ
    glm::vec3 cursor_move_r;
    move_cursor(0, 0, 0, cursor_move_r);
    // debug_log("scale_range: 2: copy_data:", copy_data, ttev->get_cursor_pos());
  }
  private function void rotate_range(imat3 const& m)
  {
    copy_value();
    const spri = copy_data.tex[0]; // copy
    // debug_log("tex[0]", copy_data.tex[0]);
    // debug_log("spri", spri);
    const saux = copy_data.tex[1]; // copy
    const sz = copy_data.copy_size;
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
        for (const x: 0 .. sz.x) {
          const vp = rotate_voxel_value(m, spri.get(x, y, z));
          const va = saux.get(x, y, z);
          const p = rotate_offset(m, glm::make_ivec3(si(x), si(y), si(z)), sz);
          // debug_log("rotate_range", x, y, z, p, vp, va);
          const up = to_uvec3(p);
          if (lt_all_uvec3(up, sz)) {
            copy_data.tex[0].set(ui(p.x), ui(p.y), ui(p.z), vp);
            copy_data.tex[1].set(ui(p.x), ui(p.y), ui(p.z), va);
          }
        }
      }
    }
    paste_value(0xffu, merge_mode_opaque());
  }
  private function uint rotate_voxel_value(imat3 const& m, uint v)
  {
    //debug_log("rotate_voxel_value", to_hexstring(v), is_node_reference(v));
    if (is_plane_node(v)) {
      mutable pp = decode_plane_node(v);
      pp.nor = m * pp.nor;
      v = encode_plane_node(pp);
    } else if (is_sphere_node(v)) {
      mutable sp = decode_sphere_node(v);
      sp.center = m * sp.center;
      sp.scale = map{ivec3, abs}(m * sp.scale);
      v = encode_sphere_node(sp);
    } else if (is_node_reference(v)) {
      mutable rp = decode_noderef_param(v);
      // debug_log("old rp:", rp, "mat:", rp.get_imat3().to_cslice());
      // debug_log("rot mat:", m.to_cslice());
      const rm = rp.get_imat3();
        // これはシェーダがtmatの座標からtpatの座標に変換する際に適用する変換
        // なので、表示の際にはtpatデータに対してこれの逆変換が適用されたパタン
        // が表示されることになる
      const& s = m.to_cslice();
      const m_trans = make_imat3(
        s[0], s[3], s[6],
        s[1], s[4], s[7],
        s[2], s[5], s[8]);
      rp.set_imat3(rm * m_trans);
      // debug_log("mod rp:", rp, "mat:", rp.get_imat3().to_cslice());
      v = encode_noderef_param(rp);
    } else if (is_space_voxel(v)) {
      v = 0u;
    }
    return v;
  }
  private function void set_space()
  {
    if (!ttev->get_cursor_tpat()) {
      // tmapの広範囲を更新するのが遅いので1回でfillする処理にする。
      // ただしfixed pattern areaを書き換えてしまうので注意。
      const m = ttev->get_tmap_cursor_pos();
      const mi = map{uvec3, min}(m.first, m.second);
      const mx = map{uvec3, max}(m.first, m.second);
      debug_log("set_space tmap", m);
      const sz = mx - mi + make_uvec3(1, 1, 1);
      ttev->tmap_edit_fill_range(mi, sz, 0, 0);
      debug_log("set_space tmap done", m);
    } else {
      set_cur_value(texture_value_index_primary, 0u);
      set_cur_value(texture_value_index_secondary, 0u);
    }
    // message = "edit_mode: erased";
  }
  private function void reset_edit_params()
  {
    copy_value();
    const cur = ttev->get_cursor_range();
    const sz = cur.second;
    bool has_plane = false;
    bool has_sphere = false;
    plane_param pp;
    sphere_param sp;
    color_param cp;
    cp.rgb.r = 128;
    cp.rgb.g = 128;
    cp.rgb.b = 128;
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
        for (const x: 0 .. sz.x) {
          const v = copy_data.tex[0].get(x, y, z);
          if (is_plane_node(v)) {
            pp = decode_plane_node(v);
            const offset = make_ivec3(si(x*2+1), si(y*2+1), si(z*2+1))
              - to_ivec3(sz);
            pp.dist += dot_int(pp.nor, offset);
            has_plane = true;
          } else if (is_sphere_node(v)) {
            sp = decode_sphere_node(v);
            const offset2 = make_ivec3(
              si(x * 2 + 1), si(y * 2 + 1), si(z * 2 + 1))
              - to_ivec3(sz); // offset値の2倍
            sp.center += map{ivec3, operator::mul}(offset2, sp.scale) / 2;
            has_sphere = true;
          }
          if (!is_space_voxel(v) && !is_node_reference(v)) {
            cp = decode_color_param(copy_data.tex[1].get(x, y, z));
            debug_log("reset_edit_params: color", cp, to_hexstring(v));
          }
        }
      }
    }
    if (has_plane) {
      edit_plane_param = pp;
    } else if (has_sphere) {
      edit_sphere_param = sp;
    }
    edit_color_param = cp;
    // debug_log("reset_edit_params", copy_data);
  }
  private function void change_fill_type(edit_fill_type_t edit_fill_type,
    bool mod_ctrl, uint repeat)
  {
    if (edit_fill_type == edit_fill_type_wall) {
      fill_range_value(255u << 24u, 0x00808080u, true);
      message = "change fill type: filled";
    } else if (edit_fill_type == edit_fill_type_plane) {
      edit_plane_param = make_plane_param_from_cursor(mod_ctrl, repeat);
      fill_range_plane(edit_plane_param, true);
      message = "change fill type: plane";
    } else if (edit_fill_type == edit_fill_type_sphere) {
      edit_sphere_param = sphere_param();
      fill_range_sphere(edit_sphere_param, true, 0u);
      message = "change fill type: sphere";
    } else {
      fill_range_value(0u, 0u, true);
    }
    // debug_log("new fill type", edit_fill_type);
  }
  private function plane_param make_plane_param_from_cursor(bool mod_ctrl,
    uint repeat) const
  {
    const cursor = ttev->get_cursor_pos();
    mutable cdir = to_ivec3(cursor.first) - to_ivec3(cursor.second);
    // サイズは各軸+1。ただし終点と始点が一致するときはむきがわからない
    cdir.x += cdir.x >= 0 ? 1 : -1;
    cdir.y += cdir.y >= 0 ? 1 : -1;
    cdir.z += cdir.z >= 0 ? 1 : -1;
    return make_plane_param_dir(cdir, !mod_ctrl, repeat);
  }
  private function {f} void fill_range_func(bool clear_pri, bool clear_sec)
  {
    const cur = ttev->get_cursor_range();
    debug_log("fill_range: cursor=", cur, clear_pri, clear_sec);
    if (clear_pri || clear_sec) {
      copy_value();
    }
    const sz_l2 = map{uvec3, integral_log2{uint}}(copy_data.copy_size);
    if (clear_pri) {
      copy_data.tex[0].set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    }
    if (clear_sec) {
      copy_data.tex[1].set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    }
    for (const z: 0 .. copy_data.copy_size.z) {
      for (const y: 0 .. copy_data.copy_size.y) {
        for (const x: 0 .. copy_data.copy_size.x) {
          f(copy_data, x, y, z);
        }
      }
    }
    paste_value(0xffu, merge_mode_opaque());
  }
  private function void fill_range_value(uint v_pri, uint v_sec, bool set_sec)
  {
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      if (set_sec) {
        data.tex[1].set(x, y, z, v_sec);
      } else {
        // 変更前が空白だったときはset_secが偽でもaux値をセットする
        const ov = data.tex[0].get(x, y, z);
        if (is_node_reference(ov) || is_space_voxel(ov)) {
          data.tex[1].set(x, y, z, v_sec);
        }
      }
      data.tex[0].set(x, y, z, v_pri);
    }
    fill_range_func{ffunc}(false, set_sec);
  }
  private function void fill_range_color(color_param const& p, bool clear)
  {
    const value = encode_color_param(p);
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex[0].get(x, y, z);
      if (is_node_reference(ov) || is_space_voxel(ov)) {
        return;
      }
      data.tex[1].set(x, y, z, value);
    }
    fill_range_func{ffunc}(false, clear);
  }
  private function void fill_range_plane(plane_param const& p, bool clear)
  {
    const cur = ttev->get_cursor_range();
    const copy_size = cur.second;
    debug_log("fill_range_plane", copy_size);
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex[0].get(x, y, z);
      if (is_node_reference(ov) || is_sphere_node(ov)) {
        return;
      }
      // pがテクスチャエントリに収まるかどうかはわからない。収まらないときは
      // なるべく近いパラメータが使われる。
      const v = make_plane_node(p, make_ivec3(
        si(x * 2 + 1) - si(copy_size.x),
        si(y * 2 + 1) - si(copy_size.y),
        si(z * 2 + 1) - si(copy_size.z)),
        1);
      data.tex[0].set(x, y, z, v);
      if (clear) {
        data.tex[1].set(x, y, z, 0x00808080u);
      }
    }
    fill_range_func{ffunc}(clear, false);
  }
  private function void fill_range_sphere(sphere_param const& p, bool clear,
    uint modifier)
  {
    const cur = ttev->get_cursor_range();
    const copy_size = cur.second;
    /*
    const center = map{uvec3, operator::div}(copy_size, make_uvec3(2, 2, 2));
    */
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex[0].get(x, y, z);
      if (is_node_reference(ov) /* || is_plane_node(ov) */) {
        return;
      }
      const v = make_sphere_node(p, make_ivec3(
        si(x * 2 + 1) - si(copy_size.x),
        si(y * 2 + 1) - si(copy_size.y),
        si(z * 2 + 1) - si(copy_size.z)),
        1, modifier);
      /*
      const v = make_sphere_node(p, make_ivec3(
        si(x) - si(center.x),
        si(y) - si(center.y),
        si(z) - si(center.z)),
        2, modifier);
      */
      data.tex[0].set(x, y, z, v);
      if (clear) {
        data.tex[1].set(x, y, z, 0x00808080u);
      }
    }
    fill_range_func{ffunc}(clear, false);
  }
  private function uvec3 cur_tpat_base() const
  {
    const v = get_cur_tmap(texture_value_index_primary, 0u);
    debug_log("cur_tpat_base:", to_hexstring(v));
    if (!is_node_reference(v)) {
      return glm::uvec3();
    }
    const z = (v >> 16u) & 0x3f;
    const y = (v >>  8u) & 0x3f;
    const x = (v >>  0u) & 0x3f;
    const p = make_uvec3(x, y, z);
    debug_log("cur_tpat_base:", p);
    return map{uvec3, operator::mul}(p, ttev->tile_size);
  }
  private function uint get_cur_value(texture_value_index_e idx,
    size_t miplevel, size_t mutable& mlpat_r, size_t mutable mlmap_r) const
  {
    size_t tile_size_log2 = integral_log2(ttev->tile_size.x);
    const mlpat = miplevel;
    const mlmap = miplevel < tile_size_log2 ?
      size_t() : miplevel - tile_size_log2;
    mlpat_r = mlpat;
    mlmap_r = mlmap;
    return ttev->get_cursor_tpat() ?
      get_cur_tpat(idx, mlpat) : get_cur_tmap(idx, mlmap);
  }
  private function void set_cur_value(texture_value_index_e idx, uint value)
  {
    if (ttev->get_cursor_tpat()) {
      set_cur_tpat(idx, value);
    } else {
      set_cur_tmap(idx, value);
    }
  }
  private function uint get_cur_tmap(texture_value_index_e idx,
    size_t miplevel) const
  {
    const mp = ttev->get_tmap_cursor_pos().first;
    return ttev->tmap_edit_get(mp, idx, miplevel);
  }
  private function void set_cur_tmap(texture_value_index_e idx, uint value)
  {
    // 範囲が大きいと超遅いので注意
    const m = ttev->get_tmap_cursor_pos();
    const mi = map{uvec3, min}(m.first, m.second);
    const mx = map{uvec3, max}(m.first, m.second);
    debug_log("set_cur_tmap", m);
    for (const z: mi.z .. mx.z + 1) {
      for (const y: mi.y .. mx.y + 1) {
        for (const x: mi.x .. mx.x + 1) {
          // debug_log("set_cur_tmap", x, y, z, value);
          ttev->tmap_edit_set(make_uvec3(x, y, z), idx, value);
        }
      }
    }
    debug_log("set_cur_tmap done", m);
  }
  private function uint get_cur_tpat(texture_value_index_e idx,
    size_t miplevel) const
  {
    return ttev->tpat_edit_get(get_cur_tpat_center(), idx, miplevel);
  }
  private function void set_cur_tpat(texture_value_index_e idx, uint value)
  {
    if (idx == texture_value_index_primary && is_node_reference(value)) {
      value = 0u;
    }
    return ttev->tpat_edit_set(get_cur_tpat_center(), idx, value);
  }
  private function uvec3 get_cur_tpat_center() const
  {
    return map{uvec3, operator::div}(
      ttev->get_tpat_cursor_pos().first + ttev->get_tpat_cursor_pos().second,
      make_uvec3(2, 2, 2));
  }
  private function uvec3 get_cur_tmap_center() const
  {
    return map{uvec3, operator::div}(
      ttev->get_tmap_cursor_pos().first + ttev->get_tmap_cursor_pos().second,
      make_uvec3(2, 2, 2));
  }
  private function bool is_cur_tmap_node_reference() const
  {
    return is_node_reference(get_cur_tmap(texture_value_index_primary, 0u));
  }
  private function uvec3 cur_tpat_index() const
  {
    return ttev->get_tpat_cursor_pos().first;
  }
  public function void on_frame(projection_info const& prj0)
  {
    prj = prj0;
    ttev->cursor_flick();
  }
  public function void modify_tmap(uvec3 const& pos, uint value)
  {
    ttev->tmap_edit_set(pos, texture_value_index_primary, value);
  }
  private function void gen_test()
  {
    // テスト中
    debug_log("gen_test");
    const cur = ttev->get_cursor_range();
    const copy_size = cur.second;
    copy_value();
    {
      pgen_context ctx = pgen_context(rndp);
      swap(ctx.tex[0], copy_data.tex[0]);
      swap(ctx.tex[1], copy_data.tex[1]);
      texture_reshaped tex;
      mutable& c = ctx;
      tex.set_size_l2(
        c.tex[0].get_width_l2(),
        c.tex[0].get_height_l2(),
        c.tex[0].get_depth_l2());
      generate_rand_spline(rndp, tex, copy_size, 20,
        static_cast{float}(gen_test_param) / 15.0f);
      for (uint z: 0 .. copy_size.z) {
        for (uint y: 0 .. copy_size.y) {
          for (uint x: 0 .. copy_size.x) {
            if (tex.get(x, y, z) != 0u) {
              c.tex[0].set(x, y, z, make_filled_voxel());
              c.tex[1].set(x, y, z, 0x00808080u);
            } else {
              c.tex[0].set(x, y, z, make_space_voxel());
              c.tex[1].set(x, y, z, 0x0u);
            }
          }
        }
      }
      spline_postprocess(ctx);
      swap(ctx.tex[0], copy_data.tex[0]);
      swap(ctx.tex[1], copy_data.tex[1]);
    }
    /*
    {
      pgen_context ctx = pgen_context(rndp);
      swap(ctx.tex[0], copy_data.tex[0]);
      swap(ctx.tex[1], copy_data.tex[1]);
      pgen_range(uvec3(), copy_size, ctx);
      swap(ctx.tex[0], copy_data.tex[0]);
      swap(ctx.tex[1], copy_data.tex[1]);
    }
    */
    /*
    gen_split_range_div(copy_data.tex[0], copy_data.tex[1], uvec3(),
      copy_size, make_uvec3(5u, 3u, 3u));
    */
    //debug_log("dbg cursor", ttev->get_cursor_range());
    /*
    gen_millefeuille(copy_data.tex[0], copy_data.tex[1], uvec3(),
      copy_size);
    */
    /*
    {
      const sz = copy_size;
      gen_frag1(copy_data.tex[0], copy_data.tex[1], uvec3(), sz,
        to_ivec3(sz), make_ivec3(2, 0, 2), min(sz.x, sz.z));
    }
    */
    //debug_log("dbg cursor", ttev->get_cursor_range());
    paste_value(0xff, merge_mode_opaque());
    //debug_log("dbg cursor", ttev->get_cursor_range());
    copied = false;
  }
}

// edit_mode.px
private enum edit_params_mode_t {
  edit_params_mode_none = 0,
  edit_params_mode_color = 1,
  edit_params_mode_plane = 2,
  edit_params_mode_sphere_1 = 3,
}

// edit_mode.px
private enum edit_fill_type_t {
  edit_fill_type_blank = 0,
  edit_fill_type_wall = 1,
  edit_fill_type_plane = 2,
  edit_fill_type_sphere = 3,
}

private function void
sync_gl_mipmap_all(edit_mode_texture mutable& emt)
{
  for (const i: 1 .. emt.vox.tpat_edit->data_pri.size()) {
    texture_data_sync_gl(emt.vox.tpat_edit->data_pri[i], si(i), uvec3(),
      emt.vox.tpat_edit->data_pri[i].get_size_uvec3(), emt.glt_voxtpat);
    texture_data_sync_gl(emt.vox.tpat_edit->data_sec[i], si(i), uvec3(),
      emt.vox.tpat_edit->data_sec[i].get_size_uvec3(), emt.glt_voxtpax);
  }
  for (const i: 1 .. emt.vox.tmap_edit->data_pri.size()) {
    texture_data_sync_gl(emt.vox.tmap_edit->data_pri[i], si(i), uvec3(),
      emt.vox.tmap_edit->data_pri[i].get_size_uvec3(), emt.glt_voxtmap);
    texture_data_sync_gl(emt.vox.tmap_edit->data_sec[i], si(i), uvec3(),
      emt.vox.tmap_edit->data_sec[i].get_size_uvec3(), emt.glt_voxtmax);
  }
}

