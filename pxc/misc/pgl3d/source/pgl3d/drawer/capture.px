private threaded namespace pgl3d::drawer::capture "export-unsafe";
public import common -;
public import pgl3d::drawer::base -;
public import meta m;

private tsvaluetype struct capture_vertex_attributes()
{
  public glm::vec2 vert;
}

private tsvaluetype struct capture_instance_attributes()
{
}

private tsvaluetype struct capture_uniforms()
{
  public int sampler_tex;
  public glm::vec2 pixel_delta;
  public glm::vec2 framebuffer_size;
}

public struct drawer_capture(shader_config const& glc,
  drawer_shared const& ds, string const& src_fbname0,
  ptr{varray{uchar}} const& capt_data0)
<drawstep_i>
{
  metafunction tattr capture_vertex_attributes;
  string const src_fbname = src_fbname0;
  option{cptr{gl_framebuffer}} srcfbo;
  ptr{gl_framebuffer} ppfbo2 = make_ptr{gl_framebuffer}();
  capture_shader_ptr sdr_re = init_capture_shader(glc, true /* FIXME */);
  capture_shader_ptr sdr_re2 = init_capture_shader(glc, true);
  int screen_width;
  int screen_height;
  ptr{varray{uchar}} capt_data = capt_data0;
  vbid_t const vbid_capture = ds.vbid_pool->intern("vbid_generic_filter");
  init(ds);
  function void init(drawer_shared const& ds) {
    const respool = pointer_downcast{ptr{resource_pool}}(ds.gl_resources);
    if (!src_fbname.empty()) {
      srcfbo.some = *respool->framebuffers.equal_range(src_fbname);
    }
  }
  public function vbid_t get_vbid() const { return vbid_capture; }
  public function vbid_t get_instances_vbid() const { return vbid_capture; }
  public function vbid_t get_vertices_vbid() const { return vbid_capture; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_default}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, false);
  }
  public function string builtin_vertex_set_name() const {
    return "generic_filter"; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const
  {
    farray{vertex_attr, 4} dummy_vattr;
    farray{capture_vertex_attributes, 4} vs;
    vs[0].vert = glm::make_vec2(-1.0, -1.0);
    vs[1].vert = glm::make_vec2( 1.0, -1.0);
    vs[2].vert = glm::make_vec2( 1.0,  1.0);
    vs[3].vert = glm::make_vec2(-1.0,  1.0);
    vptr->push_polygon_distinct{capture_vertex_attributes, 0}(dummy_vattr, vs);
  }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void resize_screen(shader_config const& glc, int width,
    int height)
  {
    screen_width = width;
    screen_height = height;
    ppfbo2->width = width;
    ppfbo2->height = height;
    init_postprocess_fbo(glc, false, *ppfbo2, GL_RG);
    debug_log("capture", width, height);
  }
  public function bool reload_shaders(shader_config const& glc)
  {
    return true;
  }
  public function void draw_drawstep(draw_data mutable& ddata)
  {
    // ppfbo2に対して描画する。
    int saved_fb = 0;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    {
      const pixel_delta = glm::make_vec2(
        1.0f / static_cast{float}(ppfbo2->width),
        1.0f / static_cast{float}(ppfbo2->height));
      const framebuffer_size = glm::make_vec2(
        static_cast{float}(ppfbo2->width),
        static_cast{float}(ppfbo2->height));
      glBindFramebuffer(GL_FRAMEBUFFER, ppfbo2->fbo.get());
      glViewport(0, 0, static_cast{GLsizei}(ppfbo2->width),
        static_cast{GLsizei}(ppfbo2->height));
      glDisable(GL_DEPTH_TEST);
      glDepthMask(0);
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, srcfbo.some->texture_color.get());
      mutable& sdr = *sdr_re2;
      glUseProgram(sdr.program);
      glUniform1i(sdr.u_sampler_tex, 0);
      glUniform2fv(sdr.u_pixel_delta, 1, pixel_delta.to_crawptr());
      glUniform2fv(sdr.u_framebuffer_size, 1,
        framebuffer_size.to_crawptr());
      const& bo = *ddata.vertex_buffers[get_vertices_vbid()];
      bo.draw(0, sdr);
      size_t sz = static_cast{size_t}(ppfbo2->width * ppfbo2->height * 2);
      if (capt_data->size() != sz) {
        capt_data->resize(sz, 0u);
      }
      glReadPixels(0, 0, ppfbo2->width, ppfbo2->height, GL_RG,
        GL_UNSIGNED_BYTE, capt_data->to_rawptr().to_voidptr());
      // sdl_save_file("readpixels.dmp", *capt_data);
    }
    // debug_log("glreadpixels done"); // FIXME
    // フレームバッファを戻しviewportの大きさを元に戻す
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
    glViewport(0, 0, static_cast{GLsizei}(srcfbo.some->width),
      static_cast{GLsizei}(srcfbo.some->height));
  }
  public function option{ptr{edit_mode_i}} get_edit_mode() const
  {
    return option{ptr{edit_mode_i}}();
  }
}

metafunction capture_shader_ptr
  ptr{glshader{
    capture_uniforms, capture_instance_attributes, capture_vertex_attributes}};

function capture_shader_ptr
init_capture_shader(shader_config const& g, bool capt)
{
  tree_map{string, string} bnd;
  const v = load_shader_program(g, bnd,
    capt ? "capture.vsh" : "passthrough.vsh");
  const f = load_shader_program(g, bnd,
    capt ? "capture.fsh" : "passthrough.fsh");
  return make_glshader_ptr{capture_uniforms, capture_instance_attributes,
    capture_vertex_attributes}(v, f, "", g.debug_level,
    capt ? "capture" : "pass");
}

