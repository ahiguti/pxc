private threaded namespace pgl3d::drawer::edit_mode "export-unsafe";
public import common -;
public import meta m;
public import pgl3d::drawer::base -;
public import glm -;
public import SDL2::api_types -;
public import text::serialize::compact_pod -;
public import pgl3d::texture::voxel -;

metafunction texture_data_mip varray{ptr{texture_data}};

public struct edit_mode_texture()
{
  public ptr{texture_data} voxtile = make_ptr{texture_data}();
  public texture_data_mip voxtmap_mip;
  public texture_data_mip voxtmax_mip;
  public texture_data_mip voxtpat_mip;
  public texture_data_mip voxtpax_mip;
  public ptr{gl_texture} glt_voxtmap = make_ptr{gl_texture}();
  public ptr{gl_texture} glt_voxtmax = make_ptr{gl_texture}();
  public ptr{gl_texture} glt_voxtpat = make_ptr{gl_texture}();
  public ptr{gl_texture} glt_voxtpax = make_ptr{gl_texture}();
}

metafunction ui static_cast{uint}; 
metafunction si static_cast{int}; 
metafunction to_ivec3 map{ivec3, static_cast{int, uint}};
metafunction to_uvec3 map{uvec3, static_cast{uint, int}};

private function uvec3 texture_data_get_size(texture_data const& td)
{
  return make_uvec3(td.get_width(), td.get_height(), td.get_depth());
}

private function void texture_data_copy_range(texture_data mutable& dest,
  uvec3 const& dpos, texture_data const& src, uvec3 const& spos,
  uvec3 const& sz)
{
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	const v = src.get(spos.x + x, spos.y + y, spos.z + z);
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

private function void texture_data_fill_range(texture_data mutable& dest,
  uvec3 const& dpos, uvec3 const& sz, uint v)
{
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

private function dist_3d
dist_3d_grid_limit(int x, int y, int z, uvec3 const& grid_mask)
{
  /* grid内に収めるために距離をどれだけまで制限すればよいのか計算 */
  dist_3d r;
  if (grid_mask.x == 0) {
    r.xp = 15;
    r.xn = 15;
    r.yp = 15;
    r.yn = 15;
    r.zp = 15;
    r.zn = 15;
    return r;
  }
  const pos = make_uvec3(ui(x), ui(y), ui(z));
  const nl = map{uvec3, operator::and}(pos, grid_mask);
  const pl = grid_mask - nl;
  r.xp = si(pl.x);
  r.xn = si(nl.x);
  r.yp = si(pl.y);
  r.yn = si(nl.y);
  r.zp = si(pl.z);
  r.zn = si(nl.z);
  return r;
}


private function void
texture_data_clear_range_recalc_distance_quick(texture_data mutable& dest,
  uvec3 const& dpos, uvec3 const& sz, uvec3 const& grid)
{
  /* 指定領域を空白にし、最適ではないが距離をセットする。 */
  const grid_mask = grid - make_uvec3(1, 1, 1);
  // debug_log("tdcrrdq grid", grid);
  ivec3 const mi = to_ivec3(dpos);
  ivec3 const mx = mi + to_ivec3(sz) - make_ivec3(1, 1, 1);
  for (int z: mi.z .. mx.z + 1) {
    for (int y: mi.y .. mx.y + 1) {
      for (int x: mi.x .. mx.x + 1) {
	dist_3d dv;
	dv.xp = mx.x - x;
	dv.xn = x - mi.x;
	dv.yp = mx.y - y;
	dv.yn = y - mi.y;
	dv.zp = mx.z - z;
	dv.zn = z - mi.z;
	dv = map{dist_3d, min}(dv, dist_3d_grid_limit(x, y, z, grid_mask));
	const wv = dist_3d_to_texel_value(dv);
	dest.set(ui(x), ui(y), ui(z), wv);
      }
    }
  }
}

private function pair{ivec3, ivec3}
texture_data_fill_range_recalc_distance_quick(texture_data mutable& dest,
  uvec3 const& dpos, uvec3 const& sz, uint v)
{
  /* 領域を塗りつぶし、最適ではないが距離を更新する。 */
  texture_data_fill_range(dest, dpos, sz, v);
  ivec3 const dposi_mi = to_ivec3(dpos);
  ivec3 const dposi_mx = dposi_mi + to_ivec3(sz) - make_ivec3(1, 1, 1);
  ivec3 const mi = map{ivec3, max}(dposi_mi - make_ivec3(15, 15, 15),
    make_ivec3(0, 0, 0));
  ivec3 const mx = map{ivec3, min}(dposi_mx + make_ivec3(15, 15, 15),
    to_ivec3(texture_data_get_size(dest)) - make_ivec3(1, 1, 1));
  // debug_log("recalc", dposi_mi, dposi_mx);
  for (int z: mi.z .. mx.z + 1) {
    for (int y: mi.y .. mx.y + 1) {
      for (int x: mi.x .. mx.x + 1) {
	const v = dest.get(ui(x), ui(y), ui(z));
	if (!is_space_voxel(v)) {
	  continue;
	}
	dist_3d dv = get_dist_3d(v);
	// debug_log("recalc pre", make_ivec3(x, y, z), dv);
	if (dposi_mi.x > x) {
	  dv.xp = min(dv.xp, dposi_mi.x - x - 1);
	} else if (dposi_mx.x < x) {
	  dv.xn = min(dv.xn, x - dposi_mx.x - 1);
	}
	if (dposi_mi.y > y) {
	  dv.yp = min(dv.yp, dposi_mi.y - y - 1);
	} else if (dposi_mx.y < y) {
	  dv.yn = min(dv.yn, y - dposi_mx.y - 1);
	}
	if (dposi_mi.z > z) {
	  dv.zp = min(dv.zp, dposi_mi.z - z - 1);
	} else if (dposi_mx.z < z) {
	  dv.zn = min(dv.zn, z - dposi_mx.z - 1);
	}
	const wv = dist_3d_to_texel_value(dv);
	if (v != wv) {
	  // debug_log("recalc mod", make_ivec3(x, y, z), dv);
	  dest.set(ui(x), ui(y), ui(z), wv);
	}
      }
    }
  }
  return pair{ivec3, ivec3}(mi, mx);
}

private function void
texture_data_copy_range_merge_distance(texture_data mutable& dest,
  uvec3 const& dpos, texture_data const& src, uvec3 const& spos,
  uvec3 const& sz)
{
  /* 領域を複写し、距離は更新前後の値をマージする。 */
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	mutable v = src.get(spos.x + x, spos.y + y, spos.z + z);
	if (is_space_voxel(v)) {
	  const v1 = dest.get(dpos.x + x, dpos.y + y, dpos.z + z);
	  const dv0 = get_dist_3d(v);
	  const dv1 = get_dist_3d(v1);
	  const dv = map{dist_3d, min}(dv0, dv1);
	  v = dist_3d_to_texel_value(dv);
	}
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

private function void
texture_data_sync_gl(texture_data const& tex, uvec3 const& spos,
  uvec3 const& sz, ptr{gl_texture} const& gltex)
{
  mutable buf = darray{uint}(static_cast{size_t}(sz.x * sz.y * sz.z), 0u);
  uint i;
  for (const z: 0 .. sz.z) {
    for (const y: 0 .. sz.y) {
      for (const x: 0 .. sz.x) {
	buf[i] = tex.get(spos.x + x, spos.y + y, spos.z + z);
	++i;
      }
    }
  }
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_3D, gltex->texture_id.get());
  glTexSubImage3D(GL_TEXTURE_3D, 0, si(spos.x), si(spos.y), si(spos.z),
    si(sz.x), si(sz.y), si(sz.z), GL_RGBA, GL_UNSIGNED_BYTE,
    buf.to_crawptr().to_cvoidptr());
}

private struct modified_range
{
  private uvec3 modified_pos;
  private uvec3 modified_sz;
  public function pair{uvec3, uvec3} get_modified(bool reset_flag)
  {
    const r = pair{uvec3, uvec3}(modified_pos, modified_sz);
    if (reset_flag) {
      modified_pos = uvec3();
      modified_sz = uvec3();
    }
    return r;
  }
  public function void set_modified(ivec3 mi, ivec3 mx)
  {
    if (modified_sz.x != 0) {
      mi = map{ivec3, min}(to_ivec3(modified_pos), mi);
      mx = map{ivec3, max}(
	to_ivec3(modified_pos + modified_sz - make_uvec3(1, 1, 1)), mx);
    }
    modified_pos = to_uvec3(mi);
    modified_sz = to_uvec3(mx + make_ivec3(1, 1, 1) - mi);
  }
}

private function bool lt_all_uvec3(uvec3 const& a, uvec3 const& b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

private function bool le_all_uvec3(uvec3 const& a, uvec3 const& b)
{
  return a.x <= b.x && a.y <= b.y && a.z <= b.z;
}

private struct texture_edit(texture_data_mip const& data0,
  texture_data_mip const& data_aux0, texture_data const& grid0)
{
  /* 更新可能なテクスチャを保持するクラス。更新されたら最適な距離を
   * 再計算する。*/
  private texture_data_mip const data = data0;
  private ptr{texture_data} const data_0 = data[0];
  private texture_data_mip const data_aux = data_aux0;
  private ptr{texture_data} const data_aux_0 = data_aux[0];
  private texture_data grid_work = grid0;
  private uvec3 const data_size = texture_data_get_size(*data_0);
  private uvec3 const grid_size = texture_data_get_size(grid_work);
  private modified_range modified;
  public function cptr{texture_data} get_texture_data() const
  {
    return data_0;
  }
  public function cptr{texture_data} get_aux_texture_data() const
  {
    return data_aux_0;
  }
  public function pair{uvec3, uvec3} get_modified(bool reset_flag)
  {
    return modified.get_modified(reset_flag);
  }
  public function uint get(uvec3 const& pos)
  {
    if (!lt_all_uvec3(pos, data_size)) {
      return 0u;
    }
    return data_0->get(pos.x, pos.y, pos.z);
  }
  public function void set(uvec3 const& pos, uint v)
  {
    if (!lt_all_uvec3(pos, data_size)) {
      return;
    }
    // debug_log("texture_edit::set", pos, v);
    v = is_space_voxel(v) ? 0u : v;
    const prev = data_0->get(pos.x, pos.y, pos.z);
    data_0->set(pos.x, pos.y, pos.z, v);
    recalc_distance_range(pos, make_uvec3(1, 1, 1), v == 0);
  }
  public function void fill_range(uvec3 const& dpos, uvec3 const& sz, uint v)
  {
    if (!lt_all_uvec3(dpos, data_size)) {
      return;
    }
    v = is_space_voxel(v) ? 0u : v;
    texture_data_fill_range(*data_0, dpos, sz, v);
    recalc_distance_range(dpos, sz, v == 0);
  }
  public function void copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, uvec3 const& dpos) const
  {
    if (!lt_all_uvec3(spos, data_size) ||
      !le_all_uvec3(dpos + sz, texture_data_get_size(dest))) {
      return;
    }
    // debug_log("copy_range", spos, sz, dpos);
    texture_data_copy_range(dest, dpos, *data_0, spos, sz);
  }
  public function void paste_range(uvec3 const& dpos, uvec3 const& sz,
    texture_data const& src, uvec3 const& spos)
  {
    if (!lt_all_uvec3(dpos, data_size) ||
      !le_all_uvec3(spos + sz, texture_data_get_size(src))) {
      return;
    }
    // debug_log("paste_range", spos, sz, dpos);
    texture_data_copy_range(*data_0, dpos, src, spos, sz);
    recalc_distance_range(dpos, sz, false);
  }
  private function void recalc_distance_range(uvec3 const& pos,
    uvec3 const& sz, bool clear_flag)
  {
    /* 領域の更新に伴う距離の更新をおこなう。領域が全て空白になったと
     * わかっている場合はclear_flagを真にしてよい。*/
    ivec3 mod_mi = to_ivec3(pos);
    ivec3 mod_mx = mod_mi + to_ivec3(sz) - make_ivec3(1, 1, 1);
    if (grid_size.x == 1) {
      debug_log("recalc_distance_range nogrid");
      update_distance(true, *data_0, mod_mi, mod_mx, clear_flag);
      modified.set_modified(mod_mi, mod_mx);
    } else {
      ivec3 mod_mi_g = map{ivec3, operator::div}(mod_mi, to_ivec3(grid_size));
      ivec3 mod_mx_g = map{ivec3, operator::div}(mod_mx, to_ivec3(grid_size));
      for (const z: mod_mi_g.z .. mod_mx_g.z + 1) {
	for (const y: mod_mi_g.y .. mod_mx_g.y + 1) {
	  for (const x: mod_mi_g.x .. mod_mx_g.x + 1) {
	    const p = map{uvec3, operator::mul}(
	      make_uvec3(ui(x), ui(y), ui(z)),
	      grid_size);
	    debug_log("recalc_distance_range grid", x, y, z);
	    texture_data_copy_range(grid_work, uvec3(), *data_0, p, grid_size);
	    set_distance(true, grid_work);
	    texture_data_copy_range(*data_0, p, grid_work, uvec3(), grid_size);
	  }
	}
      }
      modified.set_modified(
	map{ivec3, operator::mul}(mod_mi_g, to_ivec3(grid_size)),
	map{ivec3, operator::mul}(mod_mx_g + make_ivec3(1, 1, 1),
	  to_ivec3(grid_size))
	- make_ivec3(1, 1, 1));
    }
  }
}

function texture_data_mip copy_mip(texture_data_mip const& data)
{
  texture_data_mip r;
  for (const i, const& e: data) {
    ptr{texture_data} p = make_ptr{texture_data}(*e);
    r.push_back(p);
  }
  return r;
}

private struct texture_edit_view(texture_data_mip const& data0,
  texture_data_mip const& data_aux0, texture_data const& grid0)
{
  /* texture_edit_viewはtexture_editに加えて、カーソルの表示と、
   * カーソルより大きなz位置を非表示にする機能を追加したもの
   */
  private ptr{texture_edit} current_edit =
    make_ptr{texture_edit}(data0, data_aux0, grid0);
  private texture_data_mip current_view = copy_mip(data0);
  private ptr{texture_data} current_view_0 = current_view[0];
  private texture_data_mip current_view_aux = copy_mip(data_aux0);
  private ptr{texture_data} current_view_aux_0 = current_view_aux[0];
  private texture_data grid = grid0;
  private uvec3 const grid_size = texture_data_get_size(grid);
  private uint cursor_color_0 = 0xffffffff;
  private uint cursor_color_1 = 0xff00ffff;
  private uvec3 cursor_0 = make_uvec3(0, 0, current_view_0->get_depth() - 1);
  private uvec3 cursor_1 = make_uvec3(0, 0, current_view_0->get_depth() - 1);
  private modified_range modified;
  private uvec3 const tex_sz = texture_data_get_size(*current_view_0);
  private function bool has_grid() const
  {
    return grid.get_width() > 1;
  }
  private function uvec3 get_cursor_mi() const
  {
    return map{uvec3, min}(cursor_0, cursor_1);
  }
  private function uvec3 get_cursor_mx() const
  {
    return map{uvec3, max}(cursor_0, cursor_1);
  }
  public function uvec3 clamp(uvec3 v) const
  {
    v = map{uvec3, min}(v, tex_sz - make_uvec3(1, 1, 1));
    return v;
  }
  public function cptr{texture_data} get_edit() const
  {
    return current_edit->get_texture_data();
  }
  public function cptr{texture_data} get_edit_aux() const
  {
    return current_edit->get_aux_texture_data();
  }
  public function cptr{texture_data} get_view() const
  {
    return current_view_0;
  }
  public function cptr{texture_data} get_view_aux() const
  {
    return current_view_aux_0;
  }
  public function pair{uvec3, uvec3} get_view_modified(bool reset_flag) {
    return modified.get_modified(reset_flag);
  }
  public function void set_cursor_color(uint c0, uint c1)
  {
    if (c0 == cursor_color_0 && c1 == cursor_color_1) {
      return;
    }
    const c0_rgb = c0 & 0x00ffffffu;
    const c1_rgb = c1 & 0x00ffffffu;
    if (c0 == 0) {
      c1 = 0;
      /* editから書き戻すだけ。周囲15まで広げた領域を書き戻す */
      /* mx.zだけは15まで広げない */
      const mi = map{ivec3, max}(
	to_ivec3(get_cursor_mi()) - make_ivec3(15, 15, 15),
	make_ivec3(0, 0, 0));
      const mx = map{ivec3, min}(
	to_ivec3(get_cursor_mx()) + make_ivec3(15, 15, 0),
	to_ivec3(tex_sz - make_uvec3(1, 1, 1)));
      const sz = mx + make_ivec3(1, 1, 1) - mi;
      // debug_log("scc cr", mi, mi, sz);
      texture_data_copy_range(*current_view_0, to_uvec3(mi),
	*get_edit(), to_uvec3(mi), to_uvec3(sz));
      /* auxはカーソル位置の1個だけを描き戻す */
      current_view_aux_0->set(cursor_0.x, cursor_0.y, cursor_0.z,
	get_edit_aux()->get(cursor_0.x, cursor_0.y, cursor_0.z));
      modified.set_modified(mi, mx);
    } else {
      const sz = get_cursor_mx() + make_uvec3(1, 1, 1) - get_cursor_mi();
      // debug_log("rrdq", sz);
      /* 領域にc1色をセットし周囲の距離を更新する */
      const mimx = texture_data_fill_range_recalc_distance_quick(
	*current_view_0, get_cursor_mi(), sz, c1);
      /* auxには領域にc1のrgbをセット */
      texture_data_fill_range(*current_view_aux_0, get_cursor_mi(), sz,
	c1_rgb);
      /* cursor_0だけはc0色をセット */
      current_view_0->set(cursor_0.x, cursor_0.y, cursor_0.z, c0);
      current_view_aux_0->set(cursor_0.x, cursor_0.y, cursor_0.z, c0_rgb);
      modified.set_modified(mimx.first, mimx.second);
    }
    cursor_color_0 = c0;
    cursor_color_1 = c1;
  }
  public function void set_cursor_pos(uvec3 c0, uvec3 c1)
  {
    const saved_cursor_color_0 = cursor_color_0;
    const saved_cursor_color_1 = cursor_color_1;
    if (cursor_color_0 != 0) {
      set_cursor_color(0, 0);
    }
    c0 = clamp(c0);
    c1 = clamp(c1);
    const mx = map{uvec3, max}(c0, c1);
    const mi = map{uvec3, min}(c0, c1);
    const cursor_mx = get_cursor_mx();
    uint const prev_z = cursor_mx.z;
    uint const next_z = mx.z;
    // debug_log("view set_cursor_pos", has_grid(), saved_cursor_color, c0);
    if (prev_z > next_z) {
      /* 以前よりも小さいzまでクリアする */
      const zmi = next_z + 1;
      const zmx = min(prev_z + 15, tex_sz.z - 1);
	/* prev_z + 15までの領域は距離を更新 */
      const zdiff = prev_z - next_z;
      texture_data_clear_range_recalc_distance_quick(*current_view_0,
	make_uvec3(0, 0, zmi), make_uvec3(tex_sz.x, tex_sz.y, zmx + 1 - zmi),
	grid_size);
      modified.set_modified(make_ivec3(0, 0, si(zmi)),
	make_ivec3(si(tex_sz.x) - 1, si(tex_sz.y) - 1, si(zmx)));
    } else if (prev_z < next_z) {
      /* 以前よりも大きいzまで書き戻す */
      // debug_log("scp cr", prev_z + 1, prev_z + 1, next_z - prev_z);
      texture_data_copy_range(*current_view_0, make_uvec3(0, 0, prev_z + 1),
	*get_edit(), make_uvec3(0, 0, prev_z + 1),
	make_uvec3(tex_sz.x, tex_sz.y, next_z - prev_z));
      const zmi = next_z + 1;
      const zmx = min(next_z + 15, tex_sz.z - 1);
	/* next_z + 15までの領域は距離を更新 */
      texture_data_clear_range_recalc_distance_quick(*current_view_0,
	make_uvec3(0, 0, zmi), make_uvec3(tex_sz.x, tex_sz.y, zmx + 1 - zmi),
	grid_size);
      modified.set_modified(make_ivec3(0, 0, si(prev_z) + 1), 
	make_ivec3(si(tex_sz.x) - 1, si(tex_sz.y) - 1, si(zmx)));
    }
    cursor_0 = c0;
    cursor_1 = c1;
    if (saved_cursor_color_0 != 0) {
      set_cursor_color(saved_cursor_color_0, saved_cursor_color_1);
    }
  }
  public function uint edit_get(uvec3 const& pos) const
  {
    return current_edit->get(pos);
  }
  public function void edit_set(uvec3 const& pos, uint v)
  {
    current_edit->set(pos, v);
    merge_edit_view();
  }
  public function void edit_fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v)
  {
    current_edit->fill_range(dpos, sz, v);
    merge_edit_view();
  }
  public function void edit_copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, uvec3 const& dpos) const
  {
    current_edit->copy_range(spos, sz, dest, dpos);
  }
  public function void edit_paste_range(uvec3 const& dpos, uvec3 const& sz,
    texture_data const& src, uvec3 const& spos)
  {
    current_edit->paste_range(dpos, sz, src, spos);
    merge_edit_view();
  }
  private function void merge_edit_view()
  {
    /* editの更新された領域をviewに反映させる */
    mutable edit_mod = current_edit->get_modified(true);
    if (edit_mod.second.x == 0) {
      return;
    }
    const cursor_mx_z = get_cursor_mx().z;
    if (edit_mod.first.z > cursor_mx_z) {
      return; // カーソルより上の位置のみ変更があった
    }
    const mod_z = min(cursor_mx_z + 1 - edit_mod.first.z, edit_mod.second.z);
    edit_mod.second.z = mod_z;
    // debug_log("mev crmd");
    texture_data_copy_range_merge_distance(*current_view_0, edit_mod.first,
      *get_edit(), edit_mod.first, edit_mod.second);
    modified.set_modified(to_ivec3(edit_mod.first),
      to_ivec3(edit_mod.first + edit_mod.second - make_uvec3(1, 1, 1)));
  }
}

private struct ttev_state {
  public int cursor_flick;
  public uint cursor_color_0;
  public uint cursor_color_1;
  public bool cursor_tpat;
  public uvec3 cursor_tpat_0;
  public uvec3 cursor_tpat_1;
  public uvec3 cursor_tmap_0;
  public uvec3 cursor_tmap_1;
}

private struct
tiled_texture_edit_view(ptr{edit_mode_texture} const& emt0)
/*
texture_data const& tmap0, texture_data const& tpat0,
texture_data const& tile0, ptr{gl_texture} const& gltm0,
ptr{gl_texture} const& gltp0)
*/
{
  private ptr{edit_mode_texture} const emt = emt0;
  public uvec3 const tmap_size = emt->voxtmap_mip[0]->get_size_uvec3();
  public uvec3 const tpat_size = emt->voxtpat_mip[0]->get_size_uvec3();
  public uvec3 const tile_size = emt->voxtile->get_size_uvec3();
  private texture_edit_view tev_tmap = texture_edit_view(
    emt->voxtmap_mip, emt->voxtmax_mip, texture_data());
  private texture_edit_view tev_tpat = texture_edit_view(
    emt->voxtpat_mip, emt->voxtpax_mip, *emt->voxtile);
  private ptr{gl_texture} const gl_tmap = emt->glt_voxtmap;
  private ptr{gl_texture} const gl_tmap_aux = emt->glt_voxtmax;
  private ptr{gl_texture} const gl_tpat = emt->glt_voxtpat;
  private ptr{gl_texture} const gl_tpat_aux = emt->glt_voxtpax;
  private ttev_state state;
  init();
  /*
  public function cptr{texture_data} get_tmap() const
  {
    return tev_tmap.get_edit();
  }
  public function cptr{texture_data} get_tpat() const
  {
    return tev_tpat.get_edit();
  }
  */
  private function void init()
  {
    // debug_log("tmap0 size", texture_data_get_size(tmap0));
    state.cursor_flick = 0;
    state.cursor_color_0 = 0xffffffffu;
    state.cursor_color_1 = 0xff00ffffu;
    state.cursor_tpat = false;
    state.cursor_tmap_0 = make_uvec3(0, 0, tmap_size.z - 1u);
    state.cursor_tmap_1 = state.cursor_tmap_0;
    state.cursor_tpat_0 = make_uvec3(0, 0, tpat_size.z - 1u);
    state.cursor_tpat_1 = state.cursor_tpat_0;
  }
  public function ttev_state get_state() const
  {
    return state;
  }
  public function void set_state(ttev_state const& nst)
  {
    const mc = make_uvec3(0, 0, tmap_size.z - 1u);
    set_tmap_cursor_pos(mc, mc);
    const pc = make_uvec3(0, 0, tpat_size.z - 1u);
    set_tpat_cursor_pos(pc, pc);
    set_cursor_color(nst.cursor_color_0, nst.cursor_color_1);
    set_cursor_tpat(nst.cursor_tpat);
    set_tmap_cursor_pos(nst.cursor_tmap_0, nst.cursor_tmap_1);
    set_tpat_cursor_pos(nst.cursor_tpat_0, nst.cursor_tpat_1);
  }
  public function bool get_cursor_tpat() const
  {
    return state.cursor_tpat;
  }
  public function pair{uint, uint} get_cursor_color() const
  {
    return pair{uint, uint}(state.cursor_color_0, state.cursor_color_1);
  }
  public function pair{uvec3, uvec3} get_cursor_pos() const
  {
    return state.cursor_tpat ? get_tpat_cursor_pos() : get_tmap_cursor_pos();
  }
  public function pair{uvec3, uvec3} get_tmap_cursor_pos() const
  {
    return pair{uvec3, uvec3}(state.cursor_tmap_0, state.cursor_tmap_1);
  }
  public function pair{uvec3, uvec3} get_tpat_cursor_pos() const
  {
    return pair{uvec3, uvec3}(state.cursor_tpat_0, state.cursor_tpat_1);
  }
  public function pair{uvec3, uvec3} get_cursor_range() const
  {
    return state.cursor_tpat
      ? get_tpat_cursor_range() : get_tmap_cursor_range();
  }
  public function pair{uvec3, uvec3} get_tmap_cursor_range() const
  {
    const mi = map{uvec3, min}(state.cursor_tmap_0, state.cursor_tmap_1);
    const mx = map{uvec3, max}(state.cursor_tmap_0, state.cursor_tmap_1);
    return pair{uvec3, uvec3}(mi, mx + make_uvec3(1, 1, 1) - mi);
  }
  public function pair{uvec3, uvec3} get_tpat_cursor_range() const
  {
    const mi = map{uvec3, min}(state.cursor_tpat_0, state.cursor_tpat_1);
    const mx = map{uvec3, max}(state.cursor_tpat_0, state.cursor_tpat_1);
    return pair{uvec3, uvec3}(mi, mx + make_uvec3(1, 1, 1) - mi);
  }
  public function uint tmap_edit_get(uvec3 const& pos) const
  {
    return tev_tmap.edit_get(pos);
  }
  public function uint tpat_edit_get(uvec3 const& pos) const
  {
    return tev_tpat.edit_get(pos);
  }
  public function void reset_cursor_flick()
  {
    reset_cursor_flick_nosyncgl();
    sync_gl();
  }
  public function void cursor_flick()
  {
    if (++state.cursor_flick >= 60) {
      state.cursor_flick = 0;
    }
    view_update_cursor_color();
    sync_gl();
  }
  public function void set_cursor_tpat(bool ctpat)
  {
    if (!(ctpat ^ state.cursor_tpat)) { // FIXME: boolの等値判定ができない
      return;
    }
    reset_cursor_flick_nosyncgl();
    if (ctpat) {
      tev_tpat.set_cursor_pos(state.cursor_tpat_0, state.cursor_tpat_1);
    } else {
      tev_tpat.set_cursor_pos(make_uvec3(0, 0, tpat_size.z - 1),
	make_uvec3(0, 0, tpat_size.z - 1));
    }
    state.cursor_tpat = ctpat;
    cursor_flick();
  }
  public function void set_cursor_color(uint c0, uint c1)
  {
    reset_cursor_flick_nosyncgl();
    state.cursor_color_0 = c0;
    state.cursor_color_1 = c1;
    cursor_flick();
  }
  public function void set_tmap_cursor_pos(uvec3 c0, uvec3 c1)
  {
    reset_cursor_flick_nosyncgl();
    // debug_log("set_tmap_cursor_pos", c0);
    c0 = tev_tmap.clamp(c0);
    // debug_log("set_tmap_cursor_pos ->", c0);
    c1 = tev_tmap.clamp(c1);
    state.cursor_tmap_0 = c0;
    state.cursor_tmap_1 = c1;
    tev_tmap.set_cursor_pos(c0, c1);
    cursor_flick();
  }
  public function void set_tpat_cursor_pos(uvec3 c0, uvec3 c1)
  {
    reset_cursor_flick_nosyncgl();
    c0 = tev_tpat.clamp(c0);
    c1 = tev_tpat.clamp(c1);
    state.cursor_tpat_0 = c0;
    state.cursor_tpat_1 = c1;
    tev_tpat.set_cursor_pos(c0, c1);
    cursor_flick();
  }
  public function void set_cursor_pos(uvec3 c0, uvec3 c1)
  {
    if (state.cursor_tpat) {
      set_tpat_cursor_pos(c0, c1);
    } else {
      set_tmap_cursor_pos(c0, c1);
    }
  }
  public function void tmap_edit_set(uvec3 const& pos, uint v)
  {
    const tmap_fixed = map{uvec3, operator::div}(tpat_size, tile_size);
    if (le_all_uvec3(pos, tmap_fixed)) {
      /* パターンが固定されている領域 */
      debug_log("tmap_edit_set: fixed area", pos);
      return;
    }
    reset_cursor_flick_nosyncgl();
    tev_tmap.edit_set(pos, v);
    cursor_flick();
  }
  public function void tpat_edit_set(uvec3 const& pos, uint v)
  {
    reset_cursor_flick_nosyncgl();
    tev_tpat.edit_set(pos, v);
    cursor_flick();
  }
  public function void edit_fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v)
  {
    if (get_cursor_tpat()) {
      tpat_edit_fill_range(dpos, sz, v);
    } else {
      tmap_edit_fill_range(dpos, sz, v);
    }
  }
  public function void tmap_edit_fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v)
  {
    reset_cursor_flick_nosyncgl();
    tev_tmap.edit_fill_range(dpos, sz, v);
    cursor_flick();
  }
  public function void tpat_edit_fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v)
  {
    reset_cursor_flick_nosyncgl();
    tev_tpat.edit_fill_range(dpos, sz, v);
    cursor_flick();
  }
  public function void edit_copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, uvec3 const& dpos)
  {
    if (get_cursor_tpat()) {
      tpat_edit_copy_range(spos, sz, dest, dpos);
    } else {
      tmap_edit_copy_range(spos, sz, dest, dpos);
    }
  }
  public function void tmap_edit_copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, uvec3 const& dpos)
  {
    tev_tmap.edit_copy_range(spos, sz, dest, dpos);
  }
  public function void tpat_edit_copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, uvec3 const& dpos)
  {
    tev_tpat.edit_copy_range(spos, sz, dest, dpos);
  }
  public function void edit_paste_range(uvec3 const& dpos,
    uvec3 const& sz, texture_data const& src, uvec3 const& spos)
  {
    if (get_cursor_tpat()) {
      tpat_edit_paste_range(dpos, sz, src, spos);
    } else {
      tmap_edit_paste_range(dpos, sz, src, spos);
    }
  }
  public function void tmap_edit_paste_range(uvec3 const& dpos,
    uvec3 const& sz, texture_data const& src, uvec3 const& spos)
  {
    reset_cursor_flick_nosyncgl();
    tev_tmap.edit_paste_range(dpos, sz, src, spos);
    cursor_flick();
  }
  public function void tpat_edit_paste_range(uvec3 const& dpos,
    uvec3 const& sz, texture_data const& src, uvec3 const& spos)
  {
    reset_cursor_flick_nosyncgl();
    tev_tpat.edit_paste_range(dpos, sz, src, spos);
    cursor_flick();
  }
  private function bool cursor_shown() const
  {
    return state.cursor_flick > 1 && state.cursor_flick < 30;
  }
  private function void reset_cursor_flick_nosyncgl()
  {
    if (!cursor_shown()) {
      state.cursor_flick = 0;
      return;
    }
    state.cursor_flick = 0;
    view_update_cursor_color();
  }
  private function void view_update_cursor_color()
  {
    if (state.cursor_tpat) {
      if (cursor_shown()) {
	tev_tpat.set_cursor_color(state.cursor_color_0, state.cursor_color_1);
      } else {
	tev_tpat.set_cursor_color(0, 0);
      }
    } else {
      if (cursor_shown()) {
	tev_tmap.set_cursor_color(state.cursor_color_0, state.cursor_color_1);
      } else {
	tev_tmap.set_cursor_color(0, 0);
      }
    }
  }
  private function void sync_gl()
  {
    pair{uvec3, uvec3} tmmod = tev_tmap.get_view_modified(true);
    if (tmmod.second.x != 0u) {
      // debug_log("sync tmmod", tmmod);
      texture_data_sync_gl(*tev_tmap.get_view(), tmmod.first, tmmod.second,
	gl_tmap);
      texture_data_sync_gl(*tev_tmap.get_view_aux(), tmmod.first, tmmod.second,
	gl_tmap_aux);
    }
    pair{uvec3, uvec3} tpmod = tev_tpat.get_view_modified(true);
    if (tpmod.second.x != 0u) {
      // debug_log("sync tpmod", tmmod);
      texture_data_sync_gl(*tev_tpat.get_view(), tpmod.first, tpmod.second,
	gl_tpat);
      texture_data_sync_gl(*tev_tpat.get_view_aux(), tpmod.first, tpmod.second,
	gl_tpat_aux);
    }
  }
}

public struct edit_mode(ptr{edit_mode_texture} const& emt0)
<edit_mode_i>
{
  private ptr{edit_mode_texture} emt = emt0;
  private ptr{tiled_texture_edit_view} const ttev =
    make_ptr{tiled_texture_edit_view}(emt0);
  private texture_data const tile = *emt->voxtile;
  private uint copy_single;
  private uvec3 copy_size;
  private texture_data copy_data;
  private uint edit_fill_type; // 0空白 1壁 2平面 3球面
  private int edit_params_mode;
  private plane_param edit_plane_param;
  private sphere_param edit_sphere_param;
  private bool mark_set;
  init();
  private function void init()
  {
    debug_log("edit_mode", "voxtmap",
      texture_data_get_size(*emt->voxtmap_mip[0]));
    string buf;
    ttev_state stat;
    sdl_load_file("c:/build/edit_state.raw", buf);
    if (!buf.empty()) {
      stat = from_string_compact_pod{ttev_state}(buf);
      ttev->set_state(stat);
    }
    update_cursor_color();
  }
  private function void save_state()
  {
    debug_log("edit_mode: save");
    const stat = ttev->get_state();
    const buf = to_string_compact_pod(stat);
    sdl_save_file("c:/build/edit_state.raw", buf);
    save_texture_data_array_raw("c:/build/edit_voxtmap_mip.raw",
      emt->voxtmap_mip);
    save_texture_data_array_raw("c:/build/edit_voxtmax_mip.raw",
      emt->voxtmax_mip);
    save_texture_data_array_raw("c:/build/edit_voxtpat_mip.raw",
      emt->voxtpat_mip);
    save_texture_data_array_raw("c:/build/edit_voxtpax_mip.raw",
      emt->voxtpax_mip);
    /*
    save_texture_data_raw("c:/build/voxtmap_edit.raw", *ttev->get_tmap());
    save_texture_data_raw("c:/build/voxtpat_edit.raw", *ttev->get_tpat());
    */
  }
  public function void set_camera_angle(glm::quat const& angle)
  {
  }
  private function void update_cursor_color()
  {
    uint c =
      edit_params_mode == 0 ? 0xffffffffu :
      edit_params_mode == 1 ? 0xffffff00u : 0xffff00ffu;
    ttev->set_cursor_color(c, 0xff00ffff);
  }
  public function void on_key_pressed(int scancode)
  {
    SDL_Scancode key = static_cast{SDL_Scancode}(scancode);
    if (key == SDL_SCANCODE_F12) {
      save_state();
    } else if (key == SDL_SCANCODE_KP_ENTER) {
      reset_edit_fill_type();
      if (edit_fill_type == 0 || edit_fill_type == 1) {
	edit_params_mode = 0;
      } else if (edit_fill_type == 2) {
	edit_params_mode = (edit_params_mode + 1) % 2;
      } else if (edit_fill_type == 3) {
	edit_params_mode = (edit_params_mode + 1) % 3;
      }
      update_cursor_color();
    }
    if (edit_params_mode == 0) {
      if (key == SDL_SCANCODE_KP_MINUS) {
	set_space();
      } else if (key == SDL_SCANCODE_KP_PLUS) {
	change_fill_type();
      } else if (key == SDL_SCANCODE_C) {
	copy_value();
      } else if (key == SDL_SCANCODE_V) {
	paste_value();
      } else if (key == SDL_SCANCODE_I) {
	set_mark();
      } else if (key == SDL_SCANCODE_KP_4) {
	move_cursor(-1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_6) {
	move_cursor(1, 0, 0);
      } else if (key == SDL_SCANCODE_KP_2) {
	move_cursor(0, -1, 0);
      } else if (key == SDL_SCANCODE_KP_8) {
	move_cursor(0, 1, 0);
      } else if (key == SDL_SCANCODE_KP_5) {
	move_cursor(0, 0, -1);
      } else if (key == SDL_SCANCODE_KP_0) {
	move_cursor(0, 0, 1);
      } else if (key == SDL_SCANCODE_KP_7) {
	if (is_cur_tmap_node_reference()) {
	  set_cursor_tpat(true);
	}
      } else if (key == SDL_SCANCODE_KP_9) {
	set_cursor_tpat(false);
      }
    } else {
      if (key == SDL_SCANCODE_KP_4) {
	set_param(0);
      } else if (key == SDL_SCANCODE_KP_6) {
	set_param(1);
      } else if (key == SDL_SCANCODE_KP_2) {
	set_param(2);
      } else if (key == SDL_SCANCODE_KP_8) {
	set_param(3);
      } else if (key == SDL_SCANCODE_KP_5) {
	set_param(4);
      } else if (key == SDL_SCANCODE_KP_0) {
	set_param(5);
      } else if (key == SDL_SCANCODE_KP_7) {
	set_param(6);
      } else if (key == SDL_SCANCODE_KP_9) {
	set_param(7);
      }
    }
    // debug_log("scancode", scancode);
  }
  private function void set_mark()
  {
    mark_set = !mark_set;
    const cur = ttev->get_cursor_pos();
    ttev->set_cursor_pos(cur.first, cur.first);
  }
  private function void move_cursor(int x, int y, int z)
  {
    mutable cur = ttev->get_cursor_pos();
    mutable pos = to_ivec3(cur.first);
    pos += make_ivec3(x, y, z);
    pos = map{ivec3, max}(pos, make_ivec3(0, 0, 0));
    cur.first = to_uvec3(pos);
    if (!mark_set) {
      cur.second = cur.first;
    }
    ttev->set_cursor_pos(cur.first, cur.second);
      // 最大値は中でclipされる
  }
  private function bool get_cursor_tpat() const
  {
    return ttev->get_cursor_tpat();
  }
  private function void set_cursor_tpat(bool tpat)
  {
    if (tpat && !get_cursor_tpat()) {
      const tppos = cur_tpat_base();
      ttev->set_tpat_cursor_pos(tppos, tppos);
    }
    ttev->set_cursor_tpat(tpat);
  }
  private function void set_param(int v)
  {
    if (edit_fill_type == 2) {
      set_param_plane(v);
    } else if (edit_fill_type == 3) {
      if (edit_params_mode == 1) {
	set_param_sphere_1(v);
      } else if (edit_params_mode == 2) {
	set_param_sphere_2(v);
      }
    }
  }
  private function void set_param_plane(int v)
  {
    mutable& p = edit_plane_param;
    if (v == 0) {
      p.nor.x -= 1;
    } else if (v == 1) {
      p.nor.x += 1;
    } else if (v == 2) {
      p.nor.y -= 1;
    } else if (v == 3) {
      p.nor.y += 1;
    } else if (v == 4) {
      p.nor.z -= 1;
    } else if (v == 5) {
      p.nor.z += 1;
    } else if (v == 6) {
      p.dist -= 1;
    } else if (v == 7) {
      p.dist += 1;
    }
    fill_range_plane(p, false);
  }
  private function void set_param_sphere_1(int v)
  {
    mutable& p = edit_sphere_param;
    if (v == 0) {
      p.center.x -= 1;
    } else if (v == 1) {
      p.center.x += 1;
    } else if (v == 2) {
      p.center.y -= 1;
    } else if (v == 3) {
      p.center.y += 1;
    } else if (v == 4) {
      p.center.z -= 1;
    } else if (v == 5) {
      p.center.z += 1;
    } else if (v == 6) {
      p.dist = p.dist > 1 ? p.dist - 1 : 1;
    } else if (v == 7) {
      p.dist = p.dist < 63 ? p.dist + 1 : 63;
    }
    fill_range_sphere(p, false);
  }
  private function void set_param_sphere_2(int v)
  {
    mutable& p = edit_sphere_param;
    if (v == 0) {
      p.scale.x = p.scale.x > 0 ? p.scale.x - 1 : 0;
    } else if (v == 1) {
      p.scale.x = p.scale.x < 3 ? p.scale.x + 1 : 3;
    } else if (v == 2) {
      p.scale.y = p.scale.y > 0 ? p.scale.y - 1 : 0;
    } else if (v == 3) {
      p.scale.y = p.scale.y < 3 ? p.scale.y + 1 : 3;
    } else if (v == 4) {
      p.scale.z = p.scale.z > 0 ? p.scale.z - 1 : 0;
    } else if (v == 5) {
      p.scale.z = p.scale.z < 3 ? p.scale.z + 1 : 3;
    }
    fill_range_sphere(p, false);
  }
  private function void copy_value()
  {
    const cur = ttev->get_cursor_range();
    copy_size = cur.second;
    const copy_size_l2 = map{uvec3, integral_log2{uint}}(copy_size);
    copy_data.set_size_l2(copy_size_l2.x, copy_size_l2.y, copy_size_l2.z);
    // debug_log("copy_size", copy_size, texture_data_get_size(copy_data));
    ttev->edit_copy_range(cur.first, cur.second, copy_data, uvec3());
  }
  private function void paste_value()
  {
    mutable cur = ttev->get_cursor_range();
    cur.second = copy_size;
    ttev->edit_paste_range(cur.first, cur.second, copy_data, uvec3());
  }
  private function void set_space()
  {
    set_cur_value(0u);
  }
  private function void reset_edit_fill_type()
  {
    copy_value();
    const cur = ttev->get_cursor_range();
    const sz = cur.second;
    const hsz = map{uvec3, operator::div}(sz, make_uvec3(2, 2, 2));
    bool has_plane = false;
    bool has_sphere = false;
    plane_param pp;
    sphere_param sp;
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
	for (const x: 0 .. sz.x) {
	  const v = copy_data.get(x, y, z);
	  if (is_plane_node(v)) {
	    pp = decode_plane_node(v);
	    const offset = make_ivec3(si(x), si(y), si(z)) - to_ivec3(hsz);
	    pp.dist += dot_int(pp.nor, offset) * 2;
	    has_plane = true;
	  } else if (is_sphere_node(v)) {
	    sp = decode_sphere_node(v);
	    const offset = make_ivec3(si(x), si(y), si(z)) - to_ivec3(hsz);
	    sp.center += map{ivec3, operator::mul}(offset, sp.scale);
	    has_sphere = true;
	  }
	}
      }
    }
    if (has_plane) {
      edit_fill_type = 2;
      edit_plane_param = pp;
    } else if (has_sphere) {
      edit_fill_type = 3;
      edit_sphere_param = sp;
    } else {
      edit_fill_type = 0;
    }
  }
  private function void change_fill_type()
  {
    edit_fill_type = (edit_fill_type + 1) % 4;
    if (edit_fill_type == 0) {
      fill_range(0u);
    } else if (edit_fill_type == 1) {
      fill_range(255u << 24u);
    } else if (edit_fill_type == 2) {
      edit_plane_param = plane_param();
      fill_range_plane(edit_plane_param, true);
    } else if (edit_fill_type == 3) {
      edit_sphere_param = sphere_param();
      fill_range_sphere(edit_sphere_param, true);
    }
  }
  private function void fill_range(uint v)
  {
    const cur = ttev->get_cursor_range();
    copy_size = cur.second;
    const copy_size_l2 = map{uvec3, integral_log2{uint}}(copy_size);
    copy_data.set_size_l2(copy_size_l2.x, copy_size_l2.y, copy_size_l2.z);
    const center = map{uvec3, operator::div}(copy_size, make_uvec3(2, 2, 2));
    for (const z: 0 .. copy_size.z) {
      for (const y: 0 .. copy_size.y) {
	for (const x: 0 .. copy_size.x) {
	  copy_data.set(x, y, z, v);
	}
      }
    }
    ttev->edit_paste_range(cur.first, cur.second, copy_data, uvec3());
  }
  private function void fill_range_plane(plane_param const& p, bool clear)
  {
    const cur = ttev->get_cursor_range();
    if (clear) {
      copy_size = cur.second;
      const copy_size_l2 = map{uvec3, integral_log2{uint}}(copy_size);
      copy_data.set_size_l2(copy_size_l2.x, copy_size_l2.y, copy_size_l2.z);
    }
    const center = map{uvec3, operator::div}(copy_size, make_uvec3(2, 2, 2));
    for (const z: 0 .. copy_size.z) {
      for (const y: 0 .. copy_size.y) {
	for (const x: 0 .. copy_size.x) {
	  const ov = copy_data.get(x, y, z);
	  if (is_node_reference(ov) || is_sphere_node(ov)) {
	    continue;
	  }
	  const v = make_plane_node(p.nor, p.dist, make_ivec3(
	    si(x) - si(center.x),
	    si(y) - si(center.y),
	    si(z) - si(center.z)));
	  copy_data.set(x, y, z, v);
	}
      }
    }
    ttev->edit_paste_range(cur.first, cur.second, copy_data, uvec3());
  }
  private function void fill_range_sphere(sphere_param const& p, bool clear)
  {
    const cur = ttev->get_cursor_range();
    if (clear) {
      copy_size = cur.second;
      const copy_size_l2 = map{uvec3, integral_log2{uint}}(copy_size);
      copy_data.set_size_l2(copy_size_l2.x, copy_size_l2.y, copy_size_l2.z);
    }
    const center = map{uvec3, operator::div}(copy_size, make_uvec3(2, 2, 2));
    for (const z: 0 .. copy_size.z) {
      for (const y: 0 .. copy_size.y) {
	for (const x: 0 .. copy_size.x) {
	  const ov = copy_data.get(x, y, z);
	  if (is_node_reference(ov) || is_plane_node(ov)) {
	    continue;
	  }
	  const v = make_sphere_node(p, make_ivec3(
	    si(x) - si(center.x),
	    si(y) - si(center.y),
	    si(z) - si(center.z)));
	  copy_data.set(x, y, z, v);
	}
      }
    }
    ttev->edit_paste_range(cur.first, cur.second, copy_data, uvec3());
  }
  private function uvec3 cur_tpat_base() const
  {
    const v = get_cur_tmap();
    if (!is_node_reference(v)) {
      return glm::uvec3();
    }
    const z = (v >> 16u) & 0xff;
    const y = (v >>  8u) & 0xff;
    const x = (v >>  0u) & 0xff;
    const p = make_uvec3(x, y, z);
    return map{uvec3, operator::mul}(p, ttev->tile_size);
  }
  private function uint get_cur_value() const
  {
    return ttev->get_cursor_tpat() ? get_cur_tpat() : get_cur_tmap();
  }
  private function void set_cur_value(uint value)
  {
    if (ttev->get_cursor_tpat()) {
      set_cur_tpat(value);
    } else {
      set_cur_tmap(value);
    }
  }
  private function uint get_cur_tmap() const
  {
    const mp = ttev->get_tmap_cursor_pos().first;
    return ttev->tmap_edit_get(mp);
  }
  private function void set_cur_tmap(uint value)
  {
    const m = ttev->get_tmap_cursor_pos();
    const mi = map{uvec3, min}(m.first, m.second);
    const mx = map{uvec3, max}(m.first, m.second);
    // debug_log("set_cur_tmap", m);
    for (const z: mi.z .. mx.z + 1) {
      for (const y: mi.y .. mx.y + 1) {
	for (const x: mi.x .. mx.x + 1) {
	  // debug_log("set_cur_tmap", x, y, z, value);
	  ttev->tmap_edit_set(make_uvec3(x, y, z), value);
	}
      }
    }
  }
  private function uint get_cur_tpat() const
  {
    return ttev->tpat_edit_get(get_cur_tpat_center());
  }
  private function void set_cur_tpat(uint value)
  {
    if (is_node_reference(value)) {
      return; // ignore
    }
    return ttev->tpat_edit_set(get_cur_tpat_center(), value);
  }
  private function uvec3 get_cur_tpat_center() const
  {
    return map{uvec3, operator::div}(
      ttev->get_tpat_cursor_pos().first + ttev->get_tpat_cursor_pos().second,
      make_uvec3(2, 2, 2));
  }
  private function uvec3 get_cur_tmap_center() const
  {
    return map{uvec3, operator::div}(
      ttev->get_tmap_cursor_pos().first + ttev->get_tmap_cursor_pos().second,
      make_uvec3(2, 2, 2));
  }
  private function bool is_cur_tmap_node_reference() const
  {
    return is_node_reference(get_cur_tmap());
  }
  private function uvec3 cur_tpat_index() const
  {
    return ttev->get_tpat_cursor_pos().first;
  }
  public function void on_frame()
  {
    ttev->cursor_flick();
  }
}

private threaded function uint encode_plane_node(ivec3 const& n, int d)
{
  if (n.x < -7 || n.x > 7 || n.y < -7 || n.y > 7 || n.z < -7 || n.z > 7) {
    return 0u;
  }
  if (n.x == 0 && n.y == 0 && n.z == 0) {
    return 0u;
  }
  if (d < -48 || d > 48) {
    return 0u;
  }
  const r = ui(n.x + 8) << 4u;
  const g = ui(n.y + 8) << 4u;
  const b = ui(n.z + 8) << 4u;
  const a = ui(d + 208);
  const v = (a << 24u) | (b << 16u) | (g << 8u) | r;
  return v;
}

private threaded function uint make_plane_node(ivec3 const& nor, int d,
  ivec3 const& offset)
{
  const d1 = d - dot_int(nor, offset) * 2;
    // offsetが0のボクセルの距離パラメタがdのとき、その平面がoffsetだけ
    // 移動した位置のボクセルを切断するような距離パラメタはd1になる
  const drange = abs(nor.x) + abs(nor.y) + abs(nor.z);
    // ax+by+czの(x,y,z)が-1,+1の範囲での最小最大は-drange,+drange
  // debug_log("plane_node pre", nor, d, offset, d1, drange);
  if (d1 <= -drange) {
    return 255u << 24u; // d1が小さすぎるので壁
  }
  if (d1 >= drange) {
    return 0u; // d1が大きすぎるので空白
  }
  // debug_log("plane_node", nor, d, offset, d1, drange);
  return encode_plane_node(nor, d1);
}

private threaded function int dot_int(ivec3 const& a, ivec3 const& b)
{
  return a.x * b.x + a.y * b.y + a.z * b.z;
}

private threaded function {t} t abs(t x)
{
  return x < t() ? -x : x;
}

valuetype struct plane_param()
{
  public int dist = 0;
  public ivec3 nor = make_ivec3(-1, -1, -1);
}

threaded function plane_param decode_plane_node(uint v)
{
  plane_param p;
  if (!is_plane_node(v)) {
    return p;
  }
  int a = si(v >> 24u);
  int r = si(v & 0xffu);
  int g = si((v >> 8u) & 0xffu);
  int b = si((v >> 16u) & 0xffu);
  p.dist = si(a) - 208;
  p.nor.x = ((r >> 4u) & 0x0fu) - 8;
  p.nor.y = ((g >> 4u) & 0x0fu) - 8;
  p.nor.z = ((b >> 4u) & 0x0fu) - 8;
  return p;
}

valuetype struct sphere_param()
{
  public int dist = 1;
  public ivec3 center;
  public ivec3 scale = make_ivec3(2, 2, 2);
}

threaded function uint make_sphere_node(sphere_param const& p,
  ivec3 const& offset)
{
  // const c = p.center - (offset + offset);
  const c = p.center - map{ivec3, operator::mul}(offset, p.scale);
  /* 球の内側なら負, 境界上なら0, 外側なら正 */
  threaded function int collision(ivec3 const pos)
  {
    // posはシェーダでは0.5までの範囲。この関数は1までの範囲なので2倍された値。
    const a_pt = map{ivec3, operator::mul}(p.scale, pos);
      // シェーダのa_vtの二倍の値
    const c_pt = c + c; // シェーダのc_vtの二倍の値
    const ac_pt = c_pt - a_pt;
    const len2_ac_pt = dot_int(ac_pt, ac_pt); // シェーダのlen_2_ac_ptの4倍
    return len2_ac_pt - p.dist * p.dist * 4;
  }
  bool has_nega = false;
  bool has_posi = false;
  for (int z: -1 .. 2) {
    for (int y: -1 .. 2) {
      for (int x: -1 .. 2) {
	const ivec3 pos = make_ivec3(x, y, z);
	const v = collision(pos);
	has_nega |= v < 0; // 球の中心からの距離がdistより小さい
	has_posi |= v > 0; // 球の中心からの距離がdistより大きい
      }
    }
  }
  if (has_posi && (has_nega || pos3_inside_eq(c, -1, 1))) {
    sphere_param p1 = p;
    p1.center = c;
    // debug_log("msn sph", p, offset);
    return encode_sphere_node(p1);
  } else if (has_posi) {
    return 0u;
  } else {
    // debug_log("msn wall", p, offset);
    return 255u << 24u; // 壁
  }
}

threaded function {t, tv} bool pos3_inside_eq(t const p, tv mi, tv mx)
{
  return
    p.x >= mi && p.x <= mx &&
    p.y >= mi && p.y <= mx &&
    p.z >= mi && p.z <= mx;
}

threaded function uint encode_sphere_node(sphere_param const& p)
{
  debug_log("encode_sphere", p);
  int node_type = p.dist + 1;
  if (node_type < 1 || node_type > 159) {
    return 0u;
  }
  if (p.center.x < -31 || p.center.x > 31 ||
      p.center.y < -31 || p.center.y > 31 ||
      p.center.z < -31 || p.center.z > 31) {
    return 0u;
  }
  if (p.scale.x < 0 || p.scale.x > 3 ||
      p.scale.y < 0 || p.scale.y > 3 ||
      p.scale.z < 0 || p.scale.z > 3) {
    return 0u;
  }
  ivec3 rgb = map{ivec3, operator::mul}(p.scale, make_ivec3(64, 64, 64))
    + p.center + make_ivec3(32, 32, 32);
  uint r = ui(rgb.x);
  uint g = ui(rgb.y);
  uint b = ui(rgb.z);
  uint a = ui(node_type);
  const v = (a << 24u) | (b << 16u) | (g << 8u) | r;
  return v;
}

threaded function sphere_param decode_sphere_node(uint v)
{
  sphere_param p;
  if (!is_sphere_node(v)) {
    return p;
  }
  int a = si(v >> 24u);
  int r = si(v & 0xffu);
  int g = si((v >> 8u) & 0xffu);
  int b = si((v >> 16u) & 0xffu);
  p.scale = make_ivec3(r >> 6, g >> 6, b >> 6);
  p.center = make_ivec3((r & 0x3f) - 32, (g & 0x3f) - 32, (b & 0x3f) - 32);
  p.dist = a - 1;
  // sp_scaleは座標aを(-0.5,0.5)から何倍に拡大するか
  //   rgbの上位2bit
  // sp_centerは球の中心座標でa*sp_scaleと比較
  //   rgbの下位6bitから32を引く
  // radiusは半径
  //   (node_type - 1)
  return p;
}

