private threaded namespace pgl3d::drawer::edit_mode "export-unsafe";
public import common -;
public import meta m;
public import pgl3d::drawer::base -;
public import glm -;
public import SDL2::api_types -;
public import text::serialize::compact_pod -;
public import pgl3d::texture::voxel -;
public import pgl3d::texture::editable_voxel -;

metafunction texture_data_mip_v0 varray{ptr{texture_data}};

metafunction ui static_cast{uint};
metafunction si static_cast{int};

private struct tiled_voxel_texture_v0()
{
  // 古いバージョンのフォーマット
  public texture_data voxtile;
  public texture_data_mip_v0 tmap_pri;
  public texture_data_mip_v0 tmap_sec;
  public texture_data_mip_v0 tpat_pri;
  public texture_data_mip_v0 tpat_sec;
}

public function void
tiled_voxel_texture_load_file(tiled_voxel_texture mutable& vox,
  cstrref const& fname, cstrref const& fname_v0)
{
  string buf;
  bool load_v0 = false;
    // trueなら古いバージョンのバイナリデータをデシリアライズする
  sdl_load_file(fname, buf);
  debug_log("load voxel texture", fname, buf.size());
  if (buf.empty() && !fname_v0.empty()) {
    sdl_load_file(fname, buf);
    debug_log("load voxel texture", fname, buf.size());
    load_v0 = true;
  }
  if (!buf.empty()) {
    if (load_v0) {
      const v0 = from_string_compact_pod{tiled_voxel_texture_v0}(buf);
      vox.voxtile = v0.voxtile;
      const tmsz = (*v0.tmap_pri[0]).get_size_uvec3();
      const tpsz = (*v0.tpat_pri[0]).get_size_uvec3();
      const gridsz = vox.voxtile.get_size_uvec3();
      const nogridsz = make_uvec3(1u, 1u, 1u);
      vox.tmap_edit = make_tptr{texture_edit}();
      vox.tpat_edit = make_tptr{texture_edit}();
      vox.tmap_edit->data_size = tmsz;
      vox.tmap_edit->grid_size = nogridsz;
      vox.tpat_edit->data_size = tpsz;
      vox.tpat_edit->grid_size = gridsz;
      function void conv_one(texture_data_mip_v0 const& src,
	texture_data_mip mutable& dest)
      {
	for (const i, const& t: src) {
	  dest.push_back(*t);
	}
      }
      conv_one(v0.tmap_pri, vox.tmap_edit->data_pri);
      conv_one(v0.tmap_sec, vox.tmap_edit->data_sec);
      conv_one(v0.tpat_pri, vox.tpat_edit->data_pri);
      conv_one(v0.tpat_sec, vox.tpat_edit->data_sec);
    } else {
      vox = from_string_compact_pod{tiled_voxel_texture}(buf);
    }
  }
}

public function void
tiled_voxel_texture_save_file(tiled_voxel_texture const& vox,
  cstrref const& fname)
{
  sdl_save_file(fname, to_string_compact_pod(vox));
}

// voxel.px
private threaded function void
texture_data_copy_range(texture_data mutable& dest,
  uvec3 const& dpos, texture_data const& src, uvec3 const& spos,
  uvec3 const& sz)
{
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	const v = src.get(spos.x + x, spos.y + y, spos.z + z);
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

// voxel.px
private threaded function void
texture_data_fill_range(texture_data mutable& dest,
  uvec3 const& dpos, uvec3 const& sz, uint v)
{
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

private function dist_3d
dist_3d_grid_limit(int x, int y, int z, uvec3 const& grid_mask)
{
  /* grid内に収めるために距離をどれだけまで制限すればよいのか計算 */
  dist_3d r;
  if (grid_mask.x == 0) {
    r.xp = 15;
    r.xn = 15;
    r.yp = 15;
    r.yn = 15;
    r.zp = 15;
    r.zn = 15;
    return r;
  }
  const pos = make_uvec3(ui(x), ui(y), ui(z));
  const nl = map{uvec3, operator::and}(pos, grid_mask);
  const pl = grid_mask - nl;
  r.xp = si(pl.x);
  r.xn = si(nl.x);
  r.yp = si(pl.y);
  r.yn = si(nl.y);
  r.zp = si(pl.z);
  r.zn = si(nl.z);
  return r;
}


private function void
texture_data_clear_range_recalc_distance_quick(texture_data mutable& dest,
  uvec3 const& dpos, uvec3 const& sz, uvec3 const& grid)
{
  /* 指定領域を空白にし、最適ではないが距離をセットする。 */
  const grid_mask = grid - make_uvec3(1, 1, 1);
  // debug_log("tdcrrdq grid", grid);
  ivec3 const mi = to_ivec3(dpos);
  ivec3 const mx = mi + to_ivec3(sz) - make_ivec3(1, 1, 1);
  for (int z: mi.z .. mx.z + 1) {
    for (int y: mi.y .. mx.y + 1) {
      for (int x: mi.x .. mx.x + 1) {
	dist_3d dv;
	dv.xp = mx.x - x;
	dv.xn = x - mi.x;
	dv.yp = mx.y - y;
	dv.yn = y - mi.y;
	dv.zp = mx.z - z;
	dv.zn = z - mi.z;
	dv = map{dist_3d, min}(dv, dist_3d_grid_limit(x, y, z, grid_mask));
	const wv = dist_3d_to_texel_value(dv);
	dest.set(ui(x), ui(y), ui(z), wv);
      }
    }
  }
}

private threaded function pair{ivec3, ivec3}
texture_data_fill_range_recalc_distance_quick(texture_data mutable& dest,
  uvec3 const& dpos, uvec3 const& sz, uint v)
{
  /* 領域を塗りつぶし、最適ではないが距離を更新する。 */
  texture_data_fill_range(dest, dpos, sz, v);
  ivec3 const dposi_mi = to_ivec3(dpos);
  ivec3 const dposi_mx = dposi_mi + to_ivec3(sz) - make_ivec3(1, 1, 1);
  ivec3 const mi = map{ivec3, max}(dposi_mi - make_ivec3(15, 15, 15),
    make_ivec3(0, 0, 0));
  ivec3 const mx = map{ivec3, min}(dposi_mx + make_ivec3(15, 15, 15),
    to_ivec3(dest.get_size_uvec3()) - make_ivec3(1, 1, 1));
  // debug_log("recalc", dposi_mi, dposi_mx);
  for (int z: mi.z .. mx.z + 1) {
    for (int y: mi.y .. mx.y + 1) {
      for (int x: mi.x .. mx.x + 1) {
	const v = dest.get(ui(x), ui(y), ui(z));
	if (!is_space_voxel(v)) {
	  continue;
	}
	dist_3d dv = get_dist_3d(v);
	// debug_log("recalc pre", make_ivec3(x, y, z), dv);
	if (dposi_mi.x > x) {
	  dv.xp = min(dv.xp, dposi_mi.x - x - 1);
	} else if (dposi_mx.x < x) {
	  dv.xn = min(dv.xn, x - dposi_mx.x - 1);
	}
	if (dposi_mi.y > y) {
	  dv.yp = min(dv.yp, dposi_mi.y - y - 1);
	} else if (dposi_mx.y < y) {
	  dv.yn = min(dv.yn, y - dposi_mx.y - 1);
	}
	if (dposi_mi.z > z) {
	  dv.zp = min(dv.zp, dposi_mi.z - z - 1);
	} else if (dposi_mx.z < z) {
	  dv.zn = min(dv.zn, z - dposi_mx.z - 1);
	}
	const wv = dist_3d_to_texel_value(dv);
	if (v != wv) {
	  // debug_log("recalc mod", make_ivec3(x, y, z), dv);
	  dest.set(ui(x), ui(y), ui(z), wv);
	}
      }
    }
  }
  return pair{ivec3, ivec3}(mi, mx);
}

private function void
texture_data_copy_range_merge_distance(texture_data mutable& dest,
  uvec3 const& dpos, texture_data const& src, uvec3 const& spos,
  uvec3 const& sz)
{
  /* 領域を複写し、距離は更新前後の値をマージする。 */
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	mutable v = src.get(spos.x + x, spos.y + y, spos.z + z);
	if (is_space_voxel(v)) {
	  const v1 = dest.get(dpos.x + x, dpos.y + y, dpos.z + z);
	  const dv0 = get_dist_3d(v);
	  const dv1 = get_dist_3d(v1);
	  const dv = map{dist_3d, min}(dv0, dv1);
	  v = dist_3d_to_texel_value(dv);
	}
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

private function void
texture_data_sync_gl(texture_data const& tex, int level, uvec3 const& spos,
  uvec3 const& sz, ptr{gl_texture} const& gltex)
{
  mutable buf = darray{uint}(static_cast{size_t}(sz.x * sz.y * sz.z), 0u);
    /* TODO: 毎回ヒープ割り当てするのをやめる */
  uint i;
  for (const z: 0 .. sz.z) {
    for (const y: 0 .. sz.y) {
      for (const x: 0 .. sz.x) {
	buf[i] = tex.get(spos.x + x, spos.y + y, spos.z + z);
	++i;
      }
    }
  }
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_3D, gltex->texture_id.get());
  glTexSubImage3D(GL_TEXTURE_3D, level, si(spos.x), si(spos.y), si(spos.z),
    si(sz.x), si(sz.y), si(sz.z), GL_RGBA, GL_UNSIGNED_BYTE,
    buf.to_crawptr().to_cvoidptr());
}

private function void
texture_data_mip_sync_gl(texture_data const& tex0,
  texture_data_mip const& mip, uvec3 const& spos, uvec3 const& sz,
  ptr{gl_texture} const& gltex)
{
  /* miplevel0だけtex0、残りはmip[i]をgltextureに書き込む */
  uvec3 pos_a = spos;
  uvec3 pos_b = spos + sz;
  for (const i, const& tex: mip) {
    uvec3 const msz = pos_b - pos_a;
    // debug_log("mip", i, pos_a, pos_b, msz);
    if (i == 0) {
      texture_data_sync_gl(tex0, si(i), pos_a, msz, gltex);
    } else {
      texture_data_sync_gl(tex, si(i), pos_a, msz, gltex);
    }
    pos_a = pos_a + make_uvec3(1u, 1u, 1u);
    pos_b = pos_b + make_uvec3(1u, 1u, 1u);
    pos_a = map{uvec3, operator::div}(pos_a, make_uvec3(2u, 2u, 2u));
    pos_b = map{uvec3, operator::div}(pos_b, make_uvec3(2u, 2u, 2u));
  }
}

/*
private multithreaded struct modified_range
{
  private uvec3 modified_pos;
  private uvec3 modified_sz;
  public function pair{uvec3, uvec3} get_modified(bool reset_flag)
  {
    const r = pair{uvec3, uvec3}(modified_pos, modified_sz);
    if (reset_flag) {
      modified_pos = uvec3();
      modified_sz = uvec3();
    }
    return r;
  }
  public function void set_modified(ivec3 mi, ivec3 mx)
  {
    if (modified_sz.x != 0) {
      mi = map{ivec3, min}(to_ivec3(modified_pos), mi);
      mx = map{ivec3, max}(
	to_ivec3(modified_pos + modified_sz - make_uvec3(1, 1, 1)), mx);
    }
    modified_pos = to_uvec3(mi);
    modified_sz = to_uvec3(mx + make_ivec3(1, 1, 1) - mi);
  }
}
*/

// vecutil.px
private threaded function bool lt_all_uvec3(uvec3 const& a, uvec3 const& b)
{
  return a.x < b.x && a.y < b.y && a.z < b.z;
}

// vecutil.px
private threaded function bool le_all_uvec3(uvec3 const& a, uvec3 const& b)
{
  return a.x <= b.x && a.y <= b.y && a.z <= b.z;
}

private struct texture_edit_view(tptr{texture_edit} const edit)
{
  /* texture_edit_viewはtexture_editに加えて、カーソルの表示と、
   * カーソルより大きなz位置を非表示にする機能を追加したもの
   */
  public tptr{texture_edit} current_edit = edit;
  public texture_data tview_pri = current_edit->data_pri[0]; // copy
  public texture_data tview_sec = current_edit->data_sec[0]; // copy
  /*
  public texture_data_mip current_view = current_edit->data_pri; // copy
  public texture_data_mip current_view_sec = current_edit->data_sec; // copy
  */
  private texture_data grid = current_edit->grid; // copy
  private uvec3 const grid_size = grid.get_size_uvec3();
  private uint cursor_color_0 = 0xffffffff;
  private uint cursor_color_1 = 0xff00ffff;
  private uvec3 cursor_0 = make_uvec3(0, 0, tview_pri.get_depth() - 1);
  private uvec3 cursor_1 = make_uvec3(0, 0, tview_pri.get_depth() - 1);
  private modified_range modified;
  private uvec3 const tex_sz = tview_pri.get_size_uvec3();
  private function bool has_grid() const
  {
    return grid.get_width() > 1;
  }
  private function uvec3 get_cursor() const
  {
    return cursor_0;
  }
  private function uvec3 get_cursor_mi() const
  {
    return map{uvec3, min}(cursor_0, cursor_1);
  }
  private function uvec3 get_cursor_mx() const
  {
    return map{uvec3, max}(cursor_0, cursor_1);
  }
  public function uvec3 clamp(uvec3 v) const
  {
    v = map{uvec3, min}(v, tex_sz - make_uvec3(1, 1, 1));
    return v;
  }
  public function pair{uvec3, uvec3} get_view_modified(bool reset_flag) {
    return modified.get_modified(reset_flag);
  }
  public function void set_cursor_color(uint c0, uint c1)
  {
    if (c0 == cursor_color_0 && c1 == cursor_color_1) {
      return;
    }
    const c0_rgb = c0 & 0x00ffffffu;
    const c1_rgb = c1 & 0x00ffffffu;
    if (c0 == 0) {
      c1 = 0;
      /* editから書き戻すだけ。周囲15まで広げた領域を書き戻す */
      /* mx.zだけは15まで広げない */
      {
	const mi = map{ivec3, max}(
	  to_ivec3(get_cursor_mi()) - make_ivec3(15, 15, 15),
	  make_ivec3(0, 0, 0));
	const mx = map{ivec3, min}(
	  to_ivec3(get_cursor_mx()) + make_ivec3(15, 15, 0),
	  to_ivec3(tex_sz - make_uvec3(1, 1, 1)));
	const sz = mx + make_ivec3(1, 1, 1) - mi;
	// debug_log("scc cr", mi, mi, sz);
	texture_data_copy_range(tview_pri, to_uvec3(mi),
	  current_edit->data_pri[0], to_uvec3(mi), to_uvec3(sz));
	modified.set_modified(mi, mx);
      }
      /* auxはカーソルの領域だけを書き戻す */
      {
	const mi = map{ivec3, max}(
	  to_ivec3(get_cursor_mi()),
	  make_ivec3(0, 0, 0));
	const mx = map{ivec3, min}(
	  to_ivec3(get_cursor_mx()),
	  to_ivec3(tex_sz - make_uvec3(1, 1, 1)));
	const sz = mx + make_ivec3(1, 1, 1) - mi;
	texture_data_copy_range(tview_sec, to_uvec3(mi),
	  current_edit->data_sec[0], to_uvec3(mi), to_uvec3(sz));
      }
      /*
      current_view_sec_0->set(cursor_0.x, cursor_0.y, cursor_0.z,
	get_edit_sec()->get(cursor_0.x, cursor_0.y, cursor_0.z));
      */
    } else {
      const sz = get_cursor_mx() + make_uvec3(1, 1, 1) - get_cursor_mi();
      // debug_log("rrdq", sz);
      /* 領域にc1色をセットし周囲の距離を更新する */
      const mimx = texture_data_fill_range_recalc_distance_quick(
	tview_pri, get_cursor_mi(), sz, c1);
      /* secには領域にc1のrgbをセット */
      texture_data_fill_range(tview_sec, get_cursor_mi(), sz,
	c1_rgb);
      /* cursor_0だけはc0色をセット */
      tview_pri.set(cursor_0.x, cursor_0.y, cursor_0.z, c0);
      tview_sec.set(cursor_0.x, cursor_0.y, cursor_0.z, c0_rgb);
      modified.set_modified(mimx.first, mimx.second);
    }
    cursor_color_0 = c0;
    cursor_color_1 = c1;
  }
  public function void set_cursor_pos(uvec3 c0, uvec3 c1)
  {
    const saved_cursor_color_0 = cursor_color_0;
    const saved_cursor_color_1 = cursor_color_1;
    if (cursor_color_0 != 0) {
      set_cursor_color(0, 0);
    }
    c0 = clamp(c0);
    c1 = clamp(c1);
    const mx = map{uvec3, max}(c0, c1);
    const mi = map{uvec3, min}(c0, c1);
    const cursor_mx = get_cursor_mx();
    uint const prev_z = cursor_mx.z;
    uint const next_z = mx.z;
    uint const blk_size = 64u;
    const prev_blk = map{uvec3, operator::div}(get_cursor(),
      make_uvec3(blk_size, blk_size, blk_size));
    const next_blk = map{uvec3, operator::div}(c0,
      make_uvec3(blk_size, blk_size, blk_size));
    const prev_blk_base = map{uvec3, operator::mul}(prev_blk,
      make_uvec3(blk_size, blk_size, blk_size));
    const next_blk_base = map{uvec3, operator::mul}(next_blk,
      make_uvec3(blk_size, blk_size, blk_size));
    // debug_log("view set_cursor_pos", has_grid(), saved_cursor_color, c0);
    if (prev_blk != next_blk) {
      /* まず古いブロックの穴を埋め戻す */
      {
	const rx = prev_blk_base.x;
	const ry = prev_blk_base.y;
	texture_data_copy_range(tview_pri,
	  make_uvec3(rx, ry, prev_z + 1), current_edit->data_pri[0],
	  make_uvec3(rx, ry, prev_z + 1),
	  make_uvec3(blk_size, blk_size, tex_sz.z - prev_z - 1));
	texture_data_copy_range(tview_sec,
	  make_uvec3(rx, ry, prev_z + 1), current_edit->data_sec[0],
	  make_uvec3(rx, ry, prev_z + 1),
	  make_uvec3(blk_size, blk_size, tex_sz.z - prev_z - 1));
	modified.set_modified(make_ivec3(si(rx), si(ry), si(prev_z + 1)), 
	  make_ivec3(si(rx + blk_size) - 1, si(ry + blk_size) - 1,
	    si(tex_sz.z) - 1));
      }
      /* 新しいブロックに穴をあける*/
      {
	const rx = next_blk_base.x;
	const ry = next_blk_base.y;
	const zmi = next_z + 1;
	const zmx = tex_sz.z - 1;
	texture_data_clear_range_recalc_distance_quick(tview_pri,
	  make_uvec3(rx, ry, zmi),
	  make_uvec3(blk_size, blk_size, zmx + 1 - zmi),
	  grid_size);
	texture_data_fill_range(tview_sec,
	  make_uvec3(rx, ry, zmi),
	  make_uvec3(blk_size, blk_size, zmx + 1 - zmi),
	  0u);
	modified.set_modified(make_ivec3(si(rx), si(ry), si(zmi)),
	  make_ivec3(si(rx + blk_size) - 1, si(ry + blk_size) - 1, si(zmx)));
      }
    } else if (prev_z > next_z) {
      /* zが小さくなった。新しいzより大きい範囲をクリアする */
      const zmi = next_z + 1;
      const zmx = min(prev_z + 15, tex_sz.z - 1);
	/* prev_z + 15までの空白領域は距離を更新 */
      const rx = next_blk_base.x;
      const ry = next_blk_base.y;
      texture_data_clear_range_recalc_distance_quick(tview_pri,
	make_uvec3(rx, ry, zmi), make_uvec3(blk_size, blk_size, zmx + 1 - zmi),
	grid_size);
      texture_data_fill_range(tview_sec,
	make_uvec3(rx, ry, zmi), make_uvec3(blk_size, blk_size, zmx + 1 - zmi),
	0u);
      modified.set_modified(make_ivec3(si(rx), si(ry), si(zmi)),
	make_ivec3(si(rx + blk_size) - 1, si(ry + blk_size) - 1, si(zmx)));
    } else if (prev_z < next_z) {
      /* zが大きくなった。新しいzより小さい範囲を書き戻す。 */
      // debug_log("scp cr", prev_z + 1, prev_z + 1, next_z - prev_z);
      const rx = prev_blk_base.x;
      const ry = prev_blk_base.y;
      texture_data_copy_range(tview_pri,
	make_uvec3(rx, ry, prev_z + 1),
	current_edit->data_pri[0], make_uvec3(rx, ry, prev_z + 1),
	make_uvec3(blk_size, blk_size, next_z - prev_z));
      texture_data_copy_range(tview_sec,
	make_uvec3(rx, ry, prev_z + 1), current_edit->data_sec[0],
	make_uvec3(rx, ry, prev_z + 1),
	make_uvec3(blk_size, blk_size, next_z - prev_z));
      const zmi = next_z + 1;
      const zmx = min(next_z + 15, tex_sz.z - 1);
	/* next_z + 15までの空白領域は距離を更新 */
      texture_data_clear_range_recalc_distance_quick(tview_pri,
	make_uvec3(rx, ry, zmi), make_uvec3(blk_size, blk_size, zmx + 1 - zmi),
	grid_size);
      modified.set_modified(make_ivec3(si(rx), si(ry), si(prev_z) + 1), 
	make_ivec3(si(rx + blk_size) - 1, si(ry + blk_size) - 1, si(zmx)));
    }
    cursor_0 = c0;
    cursor_1 = c1;
    if (saved_cursor_color_0 != 0) {
      set_cursor_color(saved_cursor_color_0, saved_cursor_color_1);
    }
  }
  public function uint edit_get(uvec3 const& pos, texture_value_index_e idx,
    size_t miplevel)
    const
  {
    return current_edit->get_mip(pos, idx, miplevel);
  }
  public function void edit_set(uvec3 const& pos, texture_value_index_e idx,
    uint v)
  {
    current_edit->set(pos, idx, v);
    merge_edit_view();
  }
  public function void edit_fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v, uint v_sec)
  {
    current_edit->fill_range(dpos, sz, v, v_sec);
    merge_edit_view();
  }
  public function void edit_copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, texture_data mutable& dest_sec,
    uvec3 const& dpos) const
  {
    current_edit->copy_range(spos, sz, dest, dest_sec, dpos);
  }
  public function void edit_paste_range(uvec3 const& dpos, uvec3 const& sz,
    texture_data const& src, texture_data const& src_sec, uvec3 const& spos,
    uint index_mask)
  {
    current_edit->paste_range(dpos, sz, src, src_sec, spos, index_mask);
    merge_edit_view();
  }
  private function void merge_edit_view()
  {
    /* editの更新された領域をviewに反映させる */
    mutable edit_mod = current_edit->get_modified(true);
    if (edit_mod.second.x == 0) {
      return;
    }
    /* 一旦穴を塞ぐためカーソルをz最大に移動 */
    const c0 = cursor_0;
    const c1 = cursor_1;
    const c0_0 = make_uvec3(c0.x, c0.y, tex_sz.z - 1);
    set_cursor_pos(c0_0, c1);
    texture_data_copy_range_merge_distance(tview_pri, edit_mod.first,
      current_edit->data_pri[0], edit_mod.first, edit_mod.second);
    texture_data_copy_range(tview_sec, edit_mod.first,
      current_edit->data_sec[0], edit_mod.first, edit_mod.second);
    modified.set_modified(to_ivec3(edit_mod.first),
      to_ivec3(edit_mod.first + edit_mod.second - make_uvec3(1, 1, 1)));
    /* カーソルを元の位置に戻す */
    set_cursor_pos(c0, c1);
  }
}

private struct ttev_state {
  public int cursor_flick;
  public uint cursor_color_0;
  public uint cursor_color_1;
  public bool cursor_tpat;
  public uvec3 cursor_tpat_0;
  public uvec3 cursor_tpat_1;
  public uvec3 cursor_tmap_0;
  public uvec3 cursor_tmap_1;
}

private struct
tiled_texture_edit_view(ptr{edit_mode_texture} const& emt0)
/*
texture_data const& tmap0, texture_data const& tpat0,
texture_data const& tile0, ptr{gl_texture} const& gltm0,
ptr{gl_texture} const& gltp0)
*/
{
  private ptr{edit_mode_texture} const emt = emt0;
  public uvec3 const tmap_size =
    emt->vox.tmap_edit->data_pri[0].get_size_uvec3();
  public uvec3 const tpat_size =
    emt->vox.tpat_edit->data_pri[0].get_size_uvec3();
  public uvec3 const tile_size = emt->vox.voxtile.get_size_uvec3();
  private texture_edit_view tev_tmap = texture_edit_view(
    emt->vox.tmap_edit);
  private texture_edit_view tev_tpat = texture_edit_view(
    emt->vox.tpat_edit);
  private ptr{gl_texture} const gl_tmap = emt->glt_voxtmap;
  private ptr{gl_texture} const gl_tmap_sec = emt->glt_voxtmax;
  private ptr{gl_texture} const gl_tpat = emt->glt_voxtpat;
  private ptr{gl_texture} const gl_tpat_sec = emt->glt_voxtpax;
  private ttev_state state;
  init();
  /*
  public function cptr{texture_data} get_tmap() const
  {
    return tev_tmap.get_edit();
  }
  public function cptr{texture_data} get_tpat() const
  {
    return tev_tpat.get_edit();
  }
  */
  private function void init()
  {
    // debug_log("tmap0 size", texture_data_get_size(tmap0));
    state.cursor_flick = 0;
    state.cursor_color_0 = 0xffffffffu;
    state.cursor_color_1 = 0xff00ffffu;
    state.cursor_tpat = false;
    state.cursor_tmap_0 = make_uvec3(0, 0, tmap_size.z - 1u);
    state.cursor_tmap_1 = state.cursor_tmap_0;
    state.cursor_tpat_0 = make_uvec3(0, 0, tpat_size.z - 1u);
    state.cursor_tpat_1 = state.cursor_tpat_0;
  }
  public function ttev_state get_state() const
  {
    return state;
  }
  public function void set_state(ttev_state const& nst)
  {
    set_cursor_color(0u, 0u);
    set_tmap_cursor_pos(nst.cursor_tmap_0, nst.cursor_tmap_0);
    set_cursor_tpat(false);
  }
  public function bool get_cursor_tpat() const
  {
    return state.cursor_tpat;
  }
  public function pair{uint, uint} get_cursor_color() const
  {
    return pair{uint, uint}(state.cursor_color_0, state.cursor_color_1);
  }
  public function pair{uvec3, uvec3} get_cursor_pos() const
  {
    // プライマリ、セカンダリのカーソル位置を返す
    return state.cursor_tpat ? get_tpat_cursor_pos() : get_tmap_cursor_pos();
  }
  public function pair{uvec3, uvec3} get_tmap_cursor_pos() const
  {
    return pair{uvec3, uvec3}(state.cursor_tmap_0, state.cursor_tmap_1);
  }
  public function pair{uvec3, uvec3} get_tpat_cursor_pos() const
  {
    return pair{uvec3, uvec3}(state.cursor_tpat_0, state.cursor_tpat_1);
  }
  public function pair{uvec3, uvec3} get_cursor_range() const
  {
    // カーソル範囲の始点と大きさを返す
    return state.cursor_tpat
      ? get_tpat_cursor_range() : get_tmap_cursor_range();
  }
  public function pair{uvec3, uvec3} get_tmap_cursor_range() const
  {
    const mi = map{uvec3, min}(state.cursor_tmap_0, state.cursor_tmap_1);
    const mx = map{uvec3, max}(state.cursor_tmap_0, state.cursor_tmap_1);
    return pair{uvec3, uvec3}(mi, mx + make_uvec3(1, 1, 1) - mi);
  }
  public function pair{uvec3, uvec3} get_tpat_cursor_range() const
  {
    const mi = map{uvec3, min}(state.cursor_tpat_0, state.cursor_tpat_1);
    const mx = map{uvec3, max}(state.cursor_tpat_0, state.cursor_tpat_1);
    return pair{uvec3, uvec3}(mi, mx + make_uvec3(1, 1, 1) - mi);
  }
  public function uint tmap_edit_get(uvec3 const& pos,
    texture_value_index_e idx, size_t miplevel) const
  {
    return tev_tmap.edit_get(pos, idx, miplevel);
  }
  public function uint tpat_edit_get(uvec3 const& pos,
    texture_value_index_e idx, size_t miplevel) const
  {
    return tev_tpat.edit_get(pos, idx, miplevel);
  }
  public function void reset_cursor_flick()
  {
    reset_cursor_flick_nosyncgl();
    sync_gl();
  }
  public function void cursor_flick()
  {
    if (++state.cursor_flick >= 60) {
      state.cursor_flick = 0;
    }
    view_update_cursor_color();
    sync_gl();
  }
  public function void cursor_flick_hide()
  {
    state.cursor_flick = 30;
    view_update_cursor_color();
    sync_gl();
  }
  public function void set_cursor_tpat(bool ctpat)
  {
    if (ctpat == state.cursor_tpat) {
      return;
    }
    reset_cursor_flick_nosyncgl();
    if (ctpat) {
      tev_tpat.set_cursor_pos(state.cursor_tpat_0, state.cursor_tpat_1);
    } else {
      tev_tpat.set_cursor_pos(make_uvec3(0, 0, tpat_size.z - 1),
	make_uvec3(0, 0, tpat_size.z - 1));
    }
    state.cursor_tpat = ctpat;
    cursor_flick();
  }
  public function void set_cursor_color(uint c0, uint c1)
  {
    reset_cursor_flick_nosyncgl();
    state.cursor_color_0 = c0;
    state.cursor_color_1 = c1;
    cursor_flick();
  }
  public function void set_tmap_cursor_pos(uvec3 c0, uvec3 c1)
  {
    reset_cursor_flick_nosyncgl();
    // debug_log("set_tmap_cursor_pos", c0);
    c0 = tev_tmap.clamp(c0);
    // debug_log("set_tmap_cursor_pos ->", c0);
    c1 = tev_tmap.clamp(c1);
    state.cursor_tmap_0 = c0;
    state.cursor_tmap_1 = c1;
    tev_tmap.set_cursor_pos(c0, c1);
    cursor_flick();
  }
  public function void set_tpat_cursor_pos(uvec3 c0, uvec3 c1)
  {
    reset_cursor_flick_nosyncgl();
    c0 = tev_tpat.clamp(c0);
    c1 = tev_tpat.clamp(c1);
    state.cursor_tpat_0 = c0;
    state.cursor_tpat_1 = c1;
    tev_tpat.set_cursor_pos(c0, c1);
    cursor_flick();
  }
  public function ivec3 clamp_cursor_pos(ivec3 pos)
  {
    const upos = to_uvec3(map{ivec3, max}(pos, ivec3()));
    if (state.cursor_tpat) {
      return to_ivec3(tev_tpat.clamp(upos));
    } else {
      return to_ivec3(tev_tmap.clamp(upos));
    }
  }
  public function void set_cursor_pos(uvec3 c0, uvec3 c1)
  {
    if (state.cursor_tpat) {
      set_tpat_cursor_pos(c0, c1);
    } else {
      set_tmap_cursor_pos(c0, c1);
    }
  }
  public function void tmap_edit_set(uvec3 const& pos,
    texture_value_index_e idx, uint v)
  {
    const tmap_fixed = map{uvec3, operator::div}(tpat_size, tile_size);
    if (le_all_uvec3(pos, tmap_fixed)) {
      /* パターンが固定されている領域 */
      debug_log("tmap_edit_set: fixed area", pos);
      return;
    }
    reset_cursor_flick_nosyncgl();
    tev_tmap.edit_set(pos, idx, v);
    cursor_flick();
  }
  public function void tpat_edit_set(uvec3 const& pos,
    texture_value_index_e idx, uint v)
  {
    reset_cursor_flick_nosyncgl();
    tev_tpat.edit_set(pos, idx, v);
    cursor_flick();
  }
  public function void edit_fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v, uint v_sec)
  {
    if (get_cursor_tpat()) {
      tpat_edit_fill_range(dpos, sz, v, v_sec);
    } else {
      tmap_edit_fill_range(dpos, sz, v, v_sec);
    }
  }
  public function void tmap_edit_fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v, uint v_sec)
  {
    reset_cursor_flick_nosyncgl();
    tev_tmap.edit_fill_range(dpos, sz, v, v_sec);
    cursor_flick();
  }
  public function void tpat_edit_fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v, uint v_sec)
  {
    reset_cursor_flick_nosyncgl();
    tev_tpat.edit_fill_range(dpos, sz, v, v_sec);
    cursor_flick();
  }
  public function void edit_copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, texture_data mutable& dest_sec,
    uvec3 const& dpos)
  {
    if (get_cursor_tpat()) {
      tpat_edit_copy_range(spos, sz, dest, dest_sec, dpos);
    } else {
      tmap_edit_copy_range(spos, sz, dest, dest_sec, dpos);
    }
  }
  public function void tmap_edit_copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, texture_data mutable& dest_sec,
    uvec3 const& dpos)
  {
    tev_tmap.edit_copy_range(spos, sz, dest, dest_sec, dpos);
  }
  public function void tpat_edit_copy_range(uvec3 const& spos, uvec3 const& sz,
    texture_data mutable& dest, texture_data mutable& dest_sec,
    uvec3 const& dpos)
  {
    tev_tpat.edit_copy_range(spos, sz, dest, dest_sec, dpos);
  }
  public function void edit_paste_range(uvec3 const& dpos,
    uvec3 const& sz, texture_data const& src, texture_data const& src_sec,
    uvec3 const& spos, uint index_mask)
  {
    if (get_cursor_tpat()) {
      tpat_edit_paste_range(dpos, sz, src, src_sec, spos, index_mask);
    } else {
      tmap_edit_paste_range(dpos, sz, src, src_sec, spos, index_mask);
    }
  }
  public function void tmap_edit_paste_range(uvec3 const& dpos,
    uvec3 const& sz, texture_data const& src, texture_data const& src_sec,
    uvec3 const& spos, uint index_mask)
  {
    reset_cursor_flick_nosyncgl();
    tev_tmap.edit_paste_range(dpos, sz, src, src_sec, spos, index_mask);
    cursor_flick();
  }
  public function void tpat_edit_paste_range(uvec3 const& dpos,
    uvec3 const& sz, texture_data const& src, texture_data const& src_sec,
    uvec3 const& spos, uint index_mask)
  {
    reset_cursor_flick_nosyncgl();
    tev_tpat.edit_paste_range(dpos, sz, src, src_sec, spos, index_mask);
    cursor_flick();
  }
  private function bool cursor_shown() const
  {
    return state.cursor_flick > 0 && state.cursor_flick < 30;
  }
  private function void reset_cursor_flick_nosyncgl()
  {
    if (!cursor_shown()) {
      state.cursor_flick = 0;
      return;
    }
    state.cursor_flick = 0;
    view_update_cursor_color();
  }
  private function void view_update_cursor_color()
  {
    if (state.cursor_tpat) {
      if (cursor_shown()) {
	tev_tpat.set_cursor_color(state.cursor_color_0, state.cursor_color_1);
      } else {
	tev_tpat.set_cursor_color(0, 0);
      }
    } else {
      if (cursor_shown()) {
	tev_tmap.set_cursor_color(state.cursor_color_0, state.cursor_color_1);
      } else {
	tev_tmap.set_cursor_color(0, 0);
      }
    }
  }
  private function void sync_gl()
  {
    pair{uvec3, uvec3} tmmod = tev_tmap.get_view_modified(true);
    if (tmmod.second.x != 0u) {
      // debug_log("sync tmmod", tmmod);
      texture_data_mip_sync_gl(tev_tmap.tview_pri,
	tev_tmap.current_edit->data_pri, tmmod.first,
	tmmod.second, gl_tmap);
      texture_data_mip_sync_gl(tev_tmap.tview_sec,
	tev_tmap.current_edit->data_sec, tmmod.first,
	tmmod.second, gl_tmap_sec);
    }
    pair{uvec3, uvec3} tpmod = tev_tpat.get_view_modified(true);
    if (tpmod.second.x != 0u) {
      // debug_log("sync tpmod", tmmod);
      texture_data_mip_sync_gl(tev_tpat.tview_pri,
	tev_tpat.current_edit->data_pri, tpmod.first,
	tpmod.second, gl_tpat);
      texture_data_mip_sync_gl(tev_tpat.tview_sec,
	tev_tpat.current_edit->data_sec, tpmod.first,
	tpmod.second, gl_tpat_sec);
    }
  }
}

private function void shrink_voxel_value(texture_data const& spri,
  texture_data const& ssec, texel_value mutable& dpri,
  texel_value mutable& dsec, ivec3 const& p)
{
  uint count_ref;
  uint count_color;
  uint count_plane;
  uint count_sphere;
  plane_param pp;
  sphere_param sp;
  color_param cp;
  const x0 = p.x;
  const y0 = p.y;
  const z0 = p.z;
  for (const z: 0 .. 2) {
    for (const y: 0 .. 2) {
      for (const x: 0 .. 2) {
	const offset = make_ivec3(x * 2 - 1, y * 2 - 1, z * 2 - 1);
	const v = spri.get(ui(x0 * 2 + x), ui(y0 * 2 + y), ui(z0 * 2 + z));
	const vs = ssec.get(ui(x0 * 2 + x), ui(y0 * 2 + y), ui(z0 * 2 + z));
	if (is_space_voxel(v)) {
	  continue;
	} else if (is_node_reference(v)) {
	  ++count_ref;
	} else if (is_filled(v)) {
	} else if (is_plane_node(v)) {
	  mutable p = decode_plane_node(v);
	  // debug_log("p", p);
	  p.dist += dot_int(p.nor, offset);
	  p.dist /= 2;
	  count_plane = 1;
	  // debug_log("mod p", p);
	  pp = p;
	} else if (is_sphere_node(v)) {
	  mutable p = decode_sphere_node(v);
	  p.center += map{ivec3, operator::mul}(offset, p.scale) / 2;
	  p.center /= 2;
	  p.dist /= 2;
	  count_sphere = 1;
	  sp = p;
	}
	++count_color;
	cp += decode_color_param(vs);
      }
    }
  }
  uint nv;
  if (count_plane > 0) {
    // pp /= count_plane;
    nv = make_plane_node(pp, ivec3(), 1);
  } else if (count_sphere > 0) {
    sp /= count_sphere;
    nv = make_sphere_node(sp, ivec3(), 1, 0u);
  } else {
    nv = make_filled_voxel();
  }
  // debug_log("set", x0, y0, z0);
  if (count_color > 0) {
    cp /= count_color;
    uint nc = encode_color_param(cp);
    dpri = nv;
    dsec = nc;
    /*
    dpri.set(ui(x0 + b.x), ui(y0 + b.y), ui(z0 + b.z), nv);
    dsec.set(ui(x0 + b.x), ui(y0 + b.y), ui(z0 + b.z), nc);
    */
  } else {
    dpri = 0u;
    dsec = 0u;
    /*
    dpri.set(ui(x0 + b.x), ui(y0 + b.y), ui(z0 + b.z), 0u);
    dsec.set(ui(x0 + b.x), ui(y0 + b.y), ui(z0 + b.z), 0u);
    */
  }
}

private function void scale_voxel_value(uint v_pri, uint v_sec,
  texture_data mutable& tex_pri, texture_data mutable& tex_sec,
  int x0, int y0, int z0)
{
  for (const z: 0 .. 2) {
    for (const y: 0 .. 2) {
      for (const x: 0 .. 2) {
	uint cv = v_pri;
	if (is_plane_node(v_pri)) {
	  mutable p = decode_plane_node(v_pri);
	  p.dist = p.dist * 2;
	  cv = make_plane_node(p, make_ivec3(
	    x * 2 - 1,
	    y * 2 - 1,
	    z * 2 - 1),
	    1);
	} else if (is_sphere_node(v_pri)) {
	  mutable p = decode_sphere_node(v_pri);
	  p.dist = p.dist * 2;
	  p.center = p.center * 2;
	  cv = make_sphere_node(p, make_ivec3(
	    x * 2 - 1,
	    y * 2 - 1,
	    z * 2 - 1),
	    1, 0u);
	}
	tex_pri.set(ui(x0 + x), ui(y0 + y), ui(z0 + z), cv);
	tex_sec.set(ui(x0 + x), ui(y0 + y), ui(z0 + z), v_sec);
      }
    }
  }
}

public function void
tiled_voxel_texture_update_mipmap(tiled_voxel_texture const& vox)
{
  debug_log("update_mipmap_all begin");
  const bool enable_short_circuit = true; // FIXME?
  function void update_mipmap_one(texture_data mutable& pri0,
    texture_data mutable& sec0, texture_data mutable& pri1,
    texture_data mutable& sec1)
  {
    const sz = pri0.get_size_l2_uvec3();
    if (sz.x == 0u || sz.y == 0u || sz.z == 0u) {
      debug_log("insane pri0", sz);
    }
    pri1.set_size_l2(sz.x - 1u, sz.y - 1u, sz.z - 1u);
    sec1.set_size_l2(sz.x - 1u, sz.y - 1u, sz.z - 1u);
    for (const z: 0 .. pri1.get_depth()) {
      for (const y: 0 .. pri1.get_height()) {
	for (const x: 0 .. pri1.get_width()) {
	  ivec3 p = make_ivec3(si(x), si(y), si(z));
	  texel_value dpri_v;
	  texel_value dsec_v;
	  shrink_voxel_value(pri0, sec0, dpri_v, dsec_v, p);
	  if (!is_space_voxel(dpri_v)) {
	    dpri_v = make_filled_voxel();
	  }
	  pri1.set(ui(p.x), ui(p.y), ui(p.z), dpri_v);
	  sec1.set(ui(p.x), ui(p.y), ui(p.z), dsec_v);
	}
      }
    }
  }
  // tpatのmipmap更新
  const pat_mip_num = vox.voxtile.get_width_l2() + 1;
    // タイルサイズが16なら16,8,4,2,1の5枚
  while (vox.tpat_edit->data_pri.size() < pat_mip_num) {
    vox.tpat_edit->data_pri.push_back(texture_data());
  }
  while (vox.tpat_edit->data_sec.size() < pat_mip_num) {
    vox.tpat_edit->data_sec.push_back(texture_data());
  }
  vox.tpat_edit->data_pri.resize(pat_mip_num, texture_data());
  vox.tpat_edit->data_sec.resize(pat_mip_num, texture_data());
  for (const i: 1 .. vox.tpat_edit->data_pri.size()) {
    mutable& tpri = vox.tpat_edit->data_pri;
    mutable& tsec = vox.tpat_edit->data_sec;
    update_mipmap_one(tpri[i - 1], tsec[i - 1], tpri[i], tsec[i]);
    set_distance(enable_short_circuit, tpri[i]);
    debug_log("update_mipmap_all tpat", i);
  }
  // tmapのmiplevel==0の代替となるテクスチャの作成
  texture_data pri0 = vox.tmap_edit->data_pri[0]; // copy
  texture_data sec0 = vox.tmap_edit->data_sec[0]; // copy
  for (const z: 0 .. pri0.get_depth()) {
    for (const y: 0 .. pri0.get_height()) {
      for (const x: 0 .. pri0.get_width()) {
	mutable vpri = pri0.get(x, y, z);
	mutable vsec = sec0.get(x, y, z);
	if (is_node_reference(vpri)) {
	  const p = make_uvec3((vpri >> 0u) & 0xffu, (vpri >> 8u) & 0xffu,
	    (vpri >> 16u) & 0xffu);
	  vpri = vox.tpat_edit->data_pri[pat_mip_num - 1].get(
	    p.x, p.y, p.z);
	  vsec = vox.tpat_edit->data_sec[pat_mip_num - 1].get(
	    p.x, p.y, p.z);
	}
	pri0.set(x, y, z, vpri);
	sec0.set(x, y, z, vsec);
      }
    }
  }
  // tmapのmiplevel==1の更新
  update_mipmap_one(pri0, sec0, vox.tmap_edit->data_pri[1],
    vox.tmap_edit->data_sec[1]);
  set_distance(enable_short_circuit, vox.tmap_edit->data_pri[1]);
  debug_log("update_mipmap_all tmap", 1);
  // tmapのmiplevel==2以降の更新
  for (const i: 2 .. vox.tmap_edit->data_pri.size()) {
    debug_log("update_mipmap_all tmap", i);
    mutable& tpri = vox.tmap_edit->data_pri;
    mutable& tsec = vox.tmap_edit->data_sec;
    update_mipmap_one(tpri[i - 1], tsec[i - 1], tpri[i], tsec[i]);
    set_distance(enable_short_circuit, tpri[i]);
  }
  debug_log("update_mipmap_all end");
}

private function void sync_gl_mipmap_all(edit_mode_texture mutable& emt)
{
  for (const i: 1 .. emt.vox.tpat_edit->data_pri.size()) {
    texture_data_sync_gl(emt.vox.tpat_edit->data_pri[i], si(i), uvec3(),
      emt.vox.tpat_edit->data_pri[i].get_size_uvec3(), emt.glt_voxtpat);
    texture_data_sync_gl(emt.vox.tpat_edit->data_sec[i], si(i), uvec3(),
      emt.vox.tpat_edit->data_sec[i].get_size_uvec3(), emt.glt_voxtpax);
  }
  for (const i: 1 .. emt.vox.tmap_edit->data_pri.size()) {
    texture_data_sync_gl(emt.vox.tmap_edit->data_pri[i], si(i), uvec3(),
      emt.vox.tmap_edit->data_pri[i].get_size_uvec3(), emt.glt_voxtmap);
    texture_data_sync_gl(emt.vox.tmap_edit->data_sec[i], si(i), uvec3(),
      emt.vox.tmap_edit->data_sec[i].get_size_uvec3(), emt.glt_voxtmax);
  }
}

private function ivec3 rotate_offset(imat3 const& m, ivec3 const& v,
  uvec3 const& sz)
{
  const isz = to_ivec3(sz) - glm::make_ivec3(1, 1, 1);
  const vs = v * 2 - isz;
  const vm = m * vs + isz;
  const r = map{glm::ivec3, operator::div}(vm, glm::make_ivec3(2, 2, 2));
  // debug_log("rotate", sz, v, r);
  return r;
}

private enum edit_params_mode_t {
  edit_params_mode_none = 0,
  edit_params_mode_color = 1,
  edit_params_mode_plane = 2,
  edit_params_mode_sphere_1 = 3,
}

private enum edit_fill_type_t {
  edit_fill_type_blank = 0,
  edit_fill_type_wall = 1,
  edit_fill_type_plane = 2,
  edit_fill_type_sphere = 3,
}

private struct copy_data_type {
  public texture_data tex_pri;
  public texture_data tex_sec;
  public uvec3 copy_size; // can be smaller than tex_pri.
  public uvec3 cursor_offset;
}

private struct edit_state {
  public ttev_state ttev;
  public glm::ivec3 cdir;
}

public struct noedit_mode(ptr{edit_mode_texture} const& emt0)
<edit_mode_i>
{
  // edit_modeが無効のときのedit_mode_i実装。view無しでeditを直接glの
  // テクスチャに反映させる。
  private ptr{edit_mode_texture} emt = emt0;
    // emt->voxがtiled_voxel_texture
    // emt->vox.tmap_editとemt->vox.tpat_editがtptr{texture_edit}
    // emt->glt_voxtmapなどがptr{gl_texture}
  private tptr{texture_edit} tmap_edit = emt->vox.tmap_edit;
  private tptr{texture_edit} tpat_edit = emt->vox.tpat_edit;
  private ptr{gl_texture} glt_tmap_pri = emt->glt_voxtmap;
  private ptr{gl_texture} glt_tmap_sec = emt->glt_voxtmax;
  private ptr{gl_texture} glt_tpat_pri = emt->glt_voxtpat;
  private ptr{gl_texture} glt_tpat_sec = emt->glt_voxtpax;
  public function void on_key_pressed(int scancode, uint modmask,
    glm::vec3 mutable& cursor_move_r, string mutable& msg_r)
  {
  }
  public function void set_camera_angle(glm::quat const& angle)
  {
  }
  public function void on_frame(projection_info const& prj)
  {
    // debug_log("noedit on_frame");
    sync_gl();
  }
  public function void modify_tmap(glm::uvec3 const& pos, uint value)
  {
    // TODO: 範囲を一括して更新する手段を用意
    tmap_edit->set(pos, texture_value_index_primary, value);
    // debug_log("noedit modify_tmap");
  }
  private function void sync_gl()
  {
    mutable& tme = *tmap_edit;
    mutable& tpe = *tpat_edit;
    pair{uvec3, uvec3} tmmod = tme.get_modified(true);
    if (tmmod.second.x != 0u) {
      // debug_log("noedit sync tmmod", tmmod);
      texture_data_mip_sync_gl(tme.data_pri[0], tme.data_pri,
	tmmod.first, tmmod.second, glt_tmap_pri);
      texture_data_mip_sync_gl(tme.data_sec[0], tme.data_sec,
	tmmod.first, tmmod.second, glt_tmap_sec);
    }
    pair{uvec3, uvec3} tpmod = tpe.get_modified(true);
    if (tpmod.second.x != 0u) {
      // debug_log("noedit sync tpmod", tmmod);
      texture_data_mip_sync_gl(tpe.data_pri[0], tpe.data_pri,
	tpmod.first, tpmod.second, glt_tpat_pri);
      texture_data_mip_sync_gl(tpe.data_sec[0], tpe.data_sec,
	tpmod.first, tpmod.second, glt_tpat_sec);
    }
  }
}

public struct edit_mode(ptr{edit_mode_texture} const& emt0)
<edit_mode_i>
{
  private ptr{edit_mode_texture} emt = emt0;
  private ptr{tiled_texture_edit_view} const ttev =
    make_ptr{tiled_texture_edit_view}(emt0);
  private texture_data const tile = emt->vox.voxtile;
  private projection_info prj;
  private copy_data_type copy_data;
  /*
  private uvec3 copy_size;
  private texture_data copy_data;
  private texture_data copy_data_sec;
  */
  private glm::ivec3 cdir = glm::make_ivec3(1, 1, 1);
  private edit_params_mode_t edit_params_mode;
  private color_param edit_color_param;
  private plane_param edit_plane_param;
  private sphere_param edit_sphere_param;
  private bool mark_set;
  private bool copied;
  private glm::uvec3 find_empty_cur; // 空のタイルを探すのに使う
  private string message;
  init();
  private function void init()
  {
    /*
    debug_log("edit_mode", "voxtmap",
      texture_data_get_size(emt->vox.tmap_pri[0]));
    */
    string buf;
    edit_state est;
    sdl_load_file("/build/edit_state.raw", buf);
    if (!buf.empty()) {
      est = from_string_compact_pod{edit_state}(buf);
      ttev->set_state(est.ttev);
      cdir = est.cdir;
    }
    update_cursor_color();
  }
  private function void save_state()
  {
    debug_log("edit_mode: save");
    edit_state est;
    est.ttev = ttev->get_state();
    est.cdir = cdir;
    sdl_save_file("/build/edit_state.raw", to_string_compact_pod(est));
    const tsz = emt->vox.tmap_edit->data_pri[0].get_size_uvec3();
    const sz = map{uvec3, integral_log2{uint}}(tsz);
    {
      string fn = "/build/edit_2_" + to_string(sz.x) + "_"
	+ to_string(sz.y) + "_" + to_string(sz.z) + ".raw";
      sdl_save_file(fn, to_string_compact_pod(emt->vox));
    }
    {
      texture_edit const& tpat = *emt->vox.tpat_edit;
      string fn = "/build/edit_common_tpat.raw";
      sdl_save_file(fn, to_string_compact_pod(tpat));
    }
    {
      texture_data const& tmpri = emt->vox.tmap_edit->data_pri[0];
      texture_data tmpri_cpy;
      tmpri_cpy.set_size_l2(6u, 6u, 6u);
      texture_data_copy_range(tmpri_cpy, uvec3(), tmpri, uvec3(),
	make_uvec3(64u, 64u, 64u));
      sdl_save_file("/build/edit_common_tmpri.raw",
	to_string_compact_pod(tmpri_cpy));
      texture_data const& tmsec = emt->vox.tmap_edit->data_sec[0];
      texture_data tmsec_cpy;
      tmsec_cpy.set_size_l2(6u, 6u, 6u);
      texture_data_copy_range(tmsec_cpy, uvec3(), tmsec, uvec3(),
	make_uvec3(64u, 64u, 64u));
      sdl_save_file("/build/edit_common_tmsec.raw",
	to_string_compact_pod(tmsec_cpy));
    }
    message = "edit_mode: saved";
  }
  public function void set_camera_angle(glm::quat const& angle)
  {
  }
  private function void update_cursor_color()
  {
    uint c =
      edit_params_mode == edit_params_mode_none ? 0xffffffffu :
      edit_params_mode == edit_params_mode_color ? 0xffff0000u :
      edit_params_mode == edit_params_mode_plane ? 0xffffff00u :
      edit_params_mode == edit_params_mode_sphere_1 ? 0xffff00ffu :
      0xff0000ffu;
    ttev->set_cursor_color(c, 0xffc08040);
    // debug_log("update_cursor_color", c);
  }
  public function void on_key_pressed(int scancode, uint modmask,
    glm::vec3 mutable& cursor_move_r, string mutable& msg_r)
  {
    message = "";
    cursor_move_r = glm::vec3();
    SDL_Scancode key = static_cast{SDL_Scancode}(scancode);
    const mod_shift = (modmask & 15) == 1;
    const mod_rshift = (modmask & 15) == 2;
    const mod_ctrl = (modmask & 15) == 4;
    const mod_rctrl = (modmask & 15) == 8;
    const mod_cs = (modmask & 15) == 5;
    const mod_rcs = (modmask & 15) == 10;
    const cursor_spd = mod_shift ? 16 : 1;
    if (key == SDL_SCANCODE_F12) {
      save_state();
    } else if (key == SDL_SCANCODE_F5) {
      tiled_voxel_texture_update_mipmap(emt->vox);
      sync_gl_mipmap_all(*emt);
    } else if (key == SDL_SCANCODE_1) {
      if (mod_shift) {
	change_fill_type(edit_fill_type_blank);
      } else {
	edit_params_mode = edit_params_mode_none;
	update_cursor_color();
	// message = "exiting edit-params mode";
      }
    } else if (key == SDL_SCANCODE_2) {
      if (mod_shift) {
	change_fill_type(edit_fill_type_wall);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_color;
      update_cursor_color();
      // message = "entering edit-color mode";
    } else if (key == SDL_SCANCODE_3) {
      if (mod_shift) {
	change_fill_type(edit_fill_type_plane);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_plane;
      update_cursor_color();
      // message = "entering edit-plane-params mode";
    } else if (key == SDL_SCANCODE_4) {
      if (mod_shift) {
	change_fill_type(edit_fill_type_sphere);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_sphere_1;
      update_cursor_color();
      // message = "entering edit-sphere-center-distance mode";
    }
    if (edit_params_mode == edit_params_mode_none) {
      // パラメータ変更モードでは無い場合。カーソル移動やコピペなどの
      // 操作を処理する。
      if (key == SDL_SCANCODE_MINUS) {
	set_space();
      } else if (key == SDL_SCANCODE_C) {
	copy_value();
      } else if (key == SDL_SCANCODE_V) {
	paste_value(mod_shift ? 0x02u : 0xffu); // mod_shiftなら色だけ貼り付け
      } else if (key == SDL_SCANCODE_COMMA) {
	if (mod_shift) {
	  shrink_range();
	}
      } else if (key == SDL_SCANCODE_PERIOD) {
	if (mod_shift) {
	  scale_range();
	}
      } else if (key == SDL_SCANCODE_I) {
	if (mod_shift) {
	  swap_cursor();
	} else {
	  set_mark();
	}
      } else if (key == SDL_SCANCODE_H) {
	if (mod_rcs) {
	  cdir.x = -cdir.x;
	} else if (mod_ctrl) {
	  rotate_range(glm::make_imat3(-1, 0, 0, 0, 1, 0, 0, 0, 1));
	} else if (mod_cs) {
	  const ssz = ttev->get_cursor_range().second;
	  if (ssz.y == ssz.z) {
	    rotate_range(glm::make_imat3(1, 0, 0, 0, 0, -1, 0, 1, 0));
	  }
	} else {
	  move_cursor(-cdir.x * cursor_spd, 0, 0, cursor_move_r);
	}
      } else if (key == SDL_SCANCODE_L) {
	if (mod_rcs) {
	  cdir.x = -cdir.x;
	} else if (mod_ctrl) {
	  rotate_range(glm::make_imat3(-1, 0, 0, 0, 1, 0, 0, 0, 1));
	} else if (mod_cs) {
	  const ssz = ttev->get_cursor_range().second;
	  if (ssz.y == ssz.z) {
	    rotate_range(glm::make_imat3(1, 0, 0, 0, 0, 1, 0, -1, 0));
	  }
	} else {
	  move_cursor(cdir.x * cursor_spd, 0, 0, cursor_move_r);
	}
      } else if (key == SDL_SCANCODE_J) {
	if (mod_rcs) {
	  cdir.y = -cdir.y;
	} else if (mod_ctrl) {
	  rotate_range(glm::make_imat3(1, 0, 0, 0, -1, 0, 0, 0, 1));
	} else if (mod_cs) {
	  const ssz = ttev->get_cursor_range().second;
	  if (ssz.z == ssz.x) {
	    rotate_range(glm::make_imat3(0, 0, 1, 0, 1, 0, -1, 0, 0));
	  }
	} else {
	  move_cursor(0, -cdir.y * cursor_spd, 0, cursor_move_r);
	}
      } else if (key == SDL_SCANCODE_K) {
	if (mod_rcs) {
	  cdir.y = -cdir.y;
	} else if (mod_ctrl) {
	  rotate_range(glm::make_imat3(1, 0, 0, 0, -1, 0, 0, 0, 1));
	} else if (mod_cs) {
	  const ssz = ttev->get_cursor_range().second;
	  if (ssz.z == ssz.x) {
	    rotate_range(glm::make_imat3(0, 0, -1, 0, 1, 0, 1, 0, 0));
	  }
	} else {
	  move_cursor(0, cdir.y * cursor_spd, 0, cursor_move_r);
	}
      } else if (key == SDL_SCANCODE_N) {
	if (mod_rcs) {
	  cdir.z = -cdir.z;
	} else if (mod_ctrl) {
	  rotate_range(glm::make_imat3(1, 0, 0, 0, 1, 0, 0, 0, -1));
	} else if (mod_cs) {
	  const ssz = ttev->get_cursor_range().second;
	  if (ssz.x == ssz.y) {
	    rotate_range(glm::make_imat3(0, -1, 0, 1, 0, 0, 0, 0, 1));
	  }
	} else {
	  move_cursor(0, 0, -cdir.z * cursor_spd, cursor_move_r);
	}
      } else if (key == SDL_SCANCODE_P) {
	if (mod_rcs) {
	  cdir.z = -cdir.z;
	} else if (mod_ctrl) {
	  rotate_range(glm::make_imat3(1, 0, 0, 0, 1, 0, 0, 0, -1));
	} else if (mod_cs) {
	  const ssz = ttev->get_cursor_range().second;
	  if (ssz.x == ssz.y) {
	    rotate_range(glm::make_imat3(0, 1, 0, -1, 0, 0, 0, 0, 1));
	  }
	} else {
	  move_cursor(0, 0, cdir.z * cursor_spd, cursor_move_r);
	}
      } else if (key == SDL_SCANCODE_0) {
	if (get_cursor_tpat()) {
	  if (mod_shift) {
	    convert_to_tmap();
	  } else {
	    set_cursor_tpat(false);
	  }
	} else {
	  if (mod_shift) {
	    convert_to_tpat();
	  } else {
	    if (is_cur_tmap_node_reference()) {
	      set_cursor_tpat(true);
	    }
	  }
	}
      }
    } else {
      // パラメータ変更モードの場合。それぞれのモードに応じて動作は変わる。
      if (key == SDL_SCANCODE_H) {
	set_param(cdir.x > 0 ? 0 : 1, modmask);
      } else if (key == SDL_SCANCODE_L) {
	set_param(cdir.x > 0 ? 1 : 0, modmask);
      } else if (key == SDL_SCANCODE_J) {
	set_param(cdir.y > 0 ? 2 : 3, modmask);
      } else if (key == SDL_SCANCODE_K) {
	set_param(cdir.y > 0 ? 3 : 2, modmask);
      } else if (key == SDL_SCANCODE_N) {
	set_param(cdir.z > 0 ? 4 : 5, modmask);
      } else if (key == SDL_SCANCODE_P) {
	set_param(cdir.z > 0 ? 5 : 4, modmask);
      } else if (key == SDL_SCANCODE_COMMA) {
	set_param(6, modmask);
      } else if (key == SDL_SCANCODE_PERIOD) {
	set_param(7, modmask);
      }
      ttev->cursor_flick_hide();
    }
    // debug_log("scancode", scancode);
    if (message.empty()) {
      message = "cursor " + to_string(ttev->get_cursor_pos().first);
      if (mark_set) {
	message += " " + to_string(to_ivec3(
	  ttev->get_cursor_pos().second - ttev->get_cursor_pos().first));
      }
      if (edit_params_mode == edit_params_mode_color) {
	message += " [color params]";
      } else if (edit_params_mode == edit_params_mode_plane) {
	message += " [plane params]";
      } else if (edit_params_mode == edit_params_mode_sphere_1) {
	message += " [sphere params]";
      }
      size_t mlv = 0u;
      if (prj.option_value2 >= 0.0) {
	mlv = static_cast{size_t}(prj.option_value2);
      }
      size_t mlpat;
      size_t mlmap;
      const vs = get_cur_value(texture_value_index_secondary, mlv, mlpat,
	mlmap);
      const vp = get_cur_value(texture_value_index_primary, mlv, mlpat, mlmap);
      if (is_space_voxel(vp)) {
	const dv = get_dist_3d(vp);
	message += " space " + to_string(dv) + " mip " + to_string(mlpat)
	  + " " + to_string(mlmap);
      } else if (is_node_reference(vp)) {
	const rv = get_node_reference(vp);
	message += " ref " + to_hexstring(rv);
      } else if (is_filled(vp)) {
	message += " filled";
      } else if (is_plane_node(vp)) {
	const pp = decode_plane_node(vp);
	message += " plane " + to_string(pp);
      } else if (is_sphere_node(vp)) {
	const sp = decode_sphere_node(vp);
	message += " sphere " + to_string(sp);
      }
      if (!is_space_voxel(vp) && !is_node_reference(vp)) {
	const cp = decode_color_param(vs);
	message += " " + to_string(cp);
      }
    }
    msg_r = message;
  }
  private function void set_mark()
  {
    mark_set = !mark_set;
    if (!mark_set) {
      copied = false;
    }
    const cur = ttev->get_cursor_pos();
    ttev->set_cursor_pos(cur.first, cur.first);
    /*
    if (mark_set) {
      message = "edit_mode: set mark";
    } else {
      message = "edit_mode: reset mark";
    }
    */
  }
  private function void swap_cursor()
  {
    const cur = ttev->get_cursor_pos();
    ttev->set_cursor_pos(cur.second, cur.first);
  }
  private function void move_cursor(int x, int y, int z,
    glm::vec3 mutable& cursor_move_r)
  {
    mutable cur = ttev->get_cursor_pos();
    const old_pos = to_ivec3(cur.first);
    mutable pos = old_pos;
    pos += make_ivec3(x, y, z);
    pos = ttev->clamp_cursor_pos(pos);
    cur.first = to_uvec3(pos);
    if (copied) {
      mutable cpos = cur.first;
      const coff = copy_data.cursor_offset;
      const cmx = to_ivec3(copy_data.copy_size) - make_ivec3(1, 1, 1);
      ivec3 scur;
      scur.x = (coff.x == 0) ? cmx.x : -cmx.x;
      scur.y = (coff.y == 0) ? cmx.y : -cmx.y;
      scur.z = (coff.z == 0) ? cmx.z : -cmx.z;
      mutable spos = to_ivec3(cpos) + scur;
      spos = map{ivec3, max}(spos, make_ivec3(0, 0, 0));
      cur.second = to_uvec3(spos);
    } else if (!mark_set) {
      cur.second = cur.first;
    }
    ttev->set_cursor_pos(cur.first, cur.second);
    {
      // テクスチャ座標でのカーソル移動量を計算
      cursor_move_r = to_vec3(
	to_ivec3(ttev->get_cursor_pos().first) - old_pos);
      const tms_max = fold_list{max}(1u, ttev->tmap_size);
      cursor_move_r /= static_cast{float}(tms_max);
      if (get_cursor_tpat()) {
	const ts_max = fold_list{max}(1u, ttev->tile_size);
	cursor_move_r /= static_cast{float}(ts_max);
      }
    }
  }
  private function bool get_cursor_tpat() const
  {
    return ttev->get_cursor_tpat();
  }
  private function void set_cursor_tpat(bool tpat)
  {
    if (tpat && !get_cursor_tpat()) {
      const tppos = cur_tpat_base();
      ttev->set_tpat_cursor_pos(tppos, tppos);
    }
    ttev->set_cursor_tpat(tpat);
    /*
    if (tpat) {
      message = "edit_mode: pattern edit mode";
    } else {
      message = "edit_mode: map edit mode";
    }
    */
  }
  private function void set_param(int v, uint modmask)
  {
    const uchar mult = static_cast{uchar}(((modmask & 1) != 0 )? 16u : 1u);
    const use_plane = (modmask & 1) != 0;
    if (edit_params_mode == edit_params_mode_color) {
      set_param_color(v, mult);
    } else if (edit_params_mode == edit_params_mode_plane) {
      set_param_plane(v);
    } else if (edit_params_mode == edit_params_mode_sphere_1) {
      set_param_sphere_1(v, modmask);
    }
  }
  private function void set_param_color(int v, uchar mult)
  {
    mutable& p = edit_color_param;
    function void inc(uint mutable& v) {
      v = (v + mult < 255u) ? v + mult : 255u;
    }
    function void dec(uint mutable& v) {
      v = (v > mult) ? v - mult : 0u;
    }
    if (v == 0) {
      dec(p.rgb.r);
    } else if (v == 1) {
      inc(p.rgb.r);
    } else if (v == 2) {
      dec(p.rgb.g);
    } else if (v == 3) {
      inc(p.rgb.g);
    } else if (v == 4) {
      dec(p.rgb.b);
    } else if (v == 5) {
      inc(p.rgb.b);
    } else if (v == 6) {
      inc(p.roughness);
      p.roughness &= 0x0fu;
    } else if (v == 7) {
      if (p.emission != 0) {
	p.emission = 0;
	p.metalness = 1;
      } else if (p.metalness != 0) {
	p.emission = 0;
	p.metalness = 0;
      } else {
	p.emission = 1;
	p.metalness = 0;
      }
    }
    // debug_log("color_param", p);
    fill_range_color(p, false);
    // message = "edit_mode: set color " + to_string(p);
  }
  private function void set_param_plane(int v)
  {
    mutable& p = edit_plane_param;
    if (v == 0) {
      p.nor.x -= 1;
    } else if (v == 1) {
      p.nor.x += 1;
    } else if (v == 2) {
      p.nor.y -= 1;
    } else if (v == 3) {
      p.nor.y += 1;
    } else if (v == 4) {
      p.nor.z -= 1;
    } else if (v == 5) {
      p.nor.z += 1;
    } else if (v == 6) {
      p.dist -= 1;
    } else if (v == 7) {
      p.dist += 1;
    }
    p.clamp_param();
    fill_range_plane(p, false);
    // message = "edit_mode: set plane params " + to_string(p);
  }
  private function void set_param_sphere_1(int v, uint modifier)
  {
    mutable& p = edit_sphere_param;
    if ((modifier & 1) == 0) {
      if (v == 0) {
	p.center.x -= 1;
      } else if (v == 1) {
	p.center.x += 1;
      } else if (v == 2) {
	p.center.y -= 1;
      } else if (v == 3) {
	p.center.y += 1;
      } else if (v == 4) {
	p.center.z -= 1;
      } else if (v == 5) {
	p.center.z += 1;
      } else if (v == 6) {
	p.dist = p.dist > 1 ? p.dist - 1 : 1;
      } else if (v == 7) {
	p.dist = p.dist < 63 ? p.dist + 1 : 63;
      }
    } else {
      if (v == 0) {
	p.scale.x = p.scale.x > 0 ? p.scale.x - 1 : 0;
      } else if (v == 1) {
	p.scale.x = p.scale.x < 3 ? p.scale.x + 1 : 3;
      } else if (v == 2) {
	p.scale.y = p.scale.y > 0 ? p.scale.y - 1 : 0;
      } else if (v == 3) {
	p.scale.y = p.scale.y < 3 ? p.scale.y + 1 : 3;
      } else if (v == 4) {
	p.scale.z = p.scale.z > 0 ? p.scale.z - 1 : 0;
      } else if (v == 5) {
	p.scale.z = p.scale.z < 3 ? p.scale.z + 1 : 3;
      }
    }
    fill_range_sphere(p, false, modifier);
    // FIXME?
    message = "edit_mode: set sphere center/dist params " + to_string(p);
  }
  private function void copy_value()
  {
    const cur = ttev->get_cursor_range();
    copy_data.copy_size = cur.second;
    copy_data.cursor_offset = ttev->get_cursor_pos().first - cur.first;
    debug_log("copy_value: cursor_offset", copy_data.cursor_offset);
    const sz_l2 = map{uvec3, integral_log2{uint}}(copy_data.copy_size);
    copy_data.tex_pri.set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    copy_data.tex_sec.set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    ttev->edit_copy_range(cur.first, cur.second, copy_data.tex_pri,
      copy_data.tex_sec, uvec3());
    mark_set = true;
    copied = true;
    // message = "edit_mode: copy value " + to_string(copy_data.copy_size);
  }
  private function void paste_value(uint index_mask)
  {
    const cpos = ttev->get_cursor_pos().first;
    // ペースト先の領域を計算
    const mi_0 = to_ivec3(cpos) - to_ivec3(copy_data.cursor_offset);
    const mx_0 = mi_0 + to_ivec3(copy_data.copy_size) - make_ivec3(1, 1, 1);
    // ペースト先の領域をclamp
    const mi = ttev->clamp_cursor_pos(mi_0);
    const mx = ttev->clamp_cursor_pos(mx_0);
    const sz = mx - mi + make_ivec3(1, 1, 1);
    // ペースト元の領域を計算
    const cd_mi = mi - mi_0;
    /*
    debug_log("paste_value: cpos,mi_0,mx_0,mi,mx,sz,cd_mi", cpos,
      mi_0, mx_0, mi, mx, sz, cd_mi);
    */
    ttev->edit_paste_range(to_uvec3(mi), to_uvec3(sz), copy_data.tex_pri,
      copy_data.tex_sec, to_uvec3(cd_mi), index_mask);
    // message = "edit_mode: paste value " + to_string(sz);
  }
  private function void convert_to_tmap()
  {
    // TODO
  }
  private function void convert_to_tpat()
  {
    // debug_log("convert_to_tpat");
    if (get_cursor_tpat()) {
      // debug_log("convert_to_tpat: 0");
      return;
    }
    const cur = ttev->get_cursor_pos().first;
    const v = ttev->tmap_edit_get(cur, texture_value_index_primary, 0u);
    if (is_node_reference(v)) {
      // debug_log("convert_to_tpat: 1");
      return;
    }
    const nv = find_empty_tpat();
    if (!is_node_reference(nv)) {
      // debug_log("convert_to_tpat: 2");
      return;
    }
    // debug_log("find", to_hexstring(nv));
    ttev->set_cursor_pos(cur, cur);
    // debug_log("convert_to_tpat: cursor:", ttev->get_cursor_pos());
    copy_value(); // tmapの一個のボクセルをコピー
    // debug_log("convert_to_tpat: copy_data:", copy_data, ttev->get_cursor_pos());
    ttev->tmap_edit_set(cur, texture_value_index_primary, nv);
    // debug_log("convert_to_tpat: cursor1:", ttev->get_cursor_pos());
    set_cursor_tpat(true);
    // debug_log("convert_to_tpat: cursor2:", ttev->get_cursor_pos());
    paste_value(0xffu);
    // debug_log("convert_to_tpat: cursor3:", ttev->get_cursor_pos());
    const tsz = ttev->tile_size;
    while (copy_data.copy_size.x < tsz.x) {
      // debug_log("convert_to_tpat: copy_size", copy_data.copy_size);
      scale_range();
    }
    // debug_log("convert_to_tpat: yy", copied);
    // set_mark(); // マークをリセット
    // debug_log("convert_to_tpat: finished", copied);
    // debug_log("convert_to_tpat: 3");
  }
  private function texel_value find_empty_tpat()
  {
    const p0 = find_empty_cur;
    mutable p = p0;
    const tsz = ttev->tile_size;
    const tpsz = map{uvec3, operator::div}(ttev->tpat_size, tsz);
    while (true) {
      if (++p.x >= tpsz.x) {
	p.x = 0;
	if (++p.y >= tpsz.y) {
	  p.y = 0;
	  if (++p.z >= tpsz.z) {
	    p.z = 0;
	  }
	}
      }
      if (p == p0) {
	break;
      }
      const pbase = map{uvec3, operator::mul}(p, tsz);
      bool is_space = true;
      for (const z: 0 .. tsz.z) {
	for (const y: 0 .. tsz.y) {
	  for (const x: 0 .. tsz.x) {
	    const cp = make_uvec3(pbase.x + x, pbase.y + y, pbase.z + z);
	    const cv = ttev->tpat_edit_get(cp, texture_value_index_primary,
	      0u);
	    is_space &= is_space_voxel(cv);
	  }
	}
      }
      // debug_log("find_empty_tpat", p, is_space);
      if (is_space) {
	find_empty_cur = p;
	return make_node_reference((p.z << 16) | (p.y << 8) | (p.x << 0));
      }
    }
    return make_space_voxel();
  }
  private function void shrink_range()
  {
    {
      // 選択領域のサイズが2の倍数でなかったときの処理
      const cp = ttev->get_cursor_pos();
      mutable cd = to_ivec3(cp.second) - to_ivec3(cp.first);
      if (cd.x == 0 || cd.y == 0 || cd.z == 0) {
	return;
      }
      function void trunc_if_even(int mutable& v) {
	if (v % 2 == 0) {
	  v += (v < 0) ? 1 : -1;
	}
      }
      trunc_if_even(cd.x);
      trunc_if_even(cd.y);
      trunc_if_even(cd.z);
      const cpm = to_uvec3(to_ivec3(cp.first) + cd);
      ttev->set_cursor_pos(cp.first, cp.second);
    }
    {
      // 縮小処理
      copy_value();
      const oszl2 = copy_data.tex_pri.get_size_l2_uvec3();
      texture_data dpri;
      texture_data daux;
      dpri.set_size_l2(oszl2.x, oszl2.y, oszl2.z);
      daux.set_size_l2(oszl2.x, oszl2.y, oszl2.z);
      const sz = copy_data.copy_size / 2u;
      ivec3 dbase;
      dbase.x = (copy_data.cursor_offset.x == 0) ? 0 : si(sz.x);
      dbase.y = (copy_data.cursor_offset.y == 0) ? 0 : si(sz.y);
      dbase.z = (copy_data.cursor_offset.z == 0) ? 0 : si(sz.z);
      for (const z: 0 .. sz.z) {
	for (const y: 0 .. sz.y) {
	  for (const x: 0 .. sz.x) {
	    const p = make_ivec3(si(x), si(y), si(z));
	    texel_value dpri_v;
	    texel_value dsec_v;
	    shrink_voxel_value(copy_data.tex_pri, copy_data.tex_sec,
	      dpri_v, dsec_v, p);
	    dpri.set(ui(p.x + dbase.x), ui(p.y + dbase.y), ui(p.z + dbase.z),
	      dpri_v);
	    daux.set(ui(p.x + dbase.x), ui(p.y + dbase.y), ui(p.z + dbase.z),
	      dsec_v);
	  }
	}
      }
      copy_data.tex_pri = dpri;
      copy_data.tex_sec = daux;
      paste_value(0xffu);
    }
    {
      // 選択領域を縮小
      const cp = ttev->get_cursor_pos();
      mutable cd = to_ivec3(cp.second) - to_ivec3(cp.first);
      cd /= 2;
      const cpm = to_ivec3(cp.first) + cd;
      ttev->set_cursor_pos(cp.first, to_uvec3(cpm));
      copy_value();
    }
  }
  private function void scale_range()
  {
    // debug_log("scale_range: p0: copy_data:", copy_data, ttev->get_cursor_pos());
    copy_value();
    // debug_log("scale_range: p1: copy_data:", copy_data, ttev->get_cursor_pos());
    texture_data spri;
    texture_data saux;
    const szl2 = copy_data.tex_pri.get_size_l2_uvec3() + make_uvec3(1, 1, 1);
    spri.set_size_l2(szl2.x, szl2.y, szl2.z);
    saux.set_size_l2(szl2.x, szl2.y, szl2.z);
    const sz = copy_data.copy_size;
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
	for (const x: 0 .. sz.x) {
	  scale_voxel_value(copy_data.tex_pri.get(x, y, z),
	    copy_data.tex_sec.get(x, y, z), spri, saux,
	    si(x * 2), si(y * 2), si(z * 2));
	}
      }
    }
    copy_data.tex_pri = spri;
    copy_data.tex_sec = saux;
    copy_data.copy_size *= 2u;
    mutable& o = copy_data.cursor_offset;
    o *= 2u;
    if (o.x != 0u) { o.x += 1u; }
    if (o.y != 0u) { o.y += 1u; }
    if (o.z != 0u) { o.z += 1u; }
    // debug_log("scale_range: 0: copy_data:", copy_data, ttev->get_cursor_pos());
    paste_value(0xffu);
    // debug_log("scale_range: 1: copy_data:", copy_data, ttev->get_cursor_pos());
    // 選択領域を広げたので反映させるためにmove_cursorを呼ぶ
    glm::vec3 cursor_move_r;
    move_cursor(0, 0, 0, cursor_move_r);
    // debug_log("scale_range: 2: copy_data:", copy_data, ttev->get_cursor_pos());
  }
  private function void rotate_range(imat3 const& m)
  {
    copy_value();
    const spri = copy_data.tex_pri; // copy
    // debug_log("tex_pri", copy_data.tex_pri);
    // debug_log("spri", spri);
    const saux = copy_data.tex_sec; // copy
    const sz = copy_data.copy_size;
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
	for (const x: 0 .. sz.x) {
	  const vp = rotate_voxel_value(m, spri.get(x, y, z));
	  const va = saux.get(x, y, z);
	  const p = rotate_offset(m, glm::make_ivec3(si(x), si(y), si(z)), sz);
	  // debug_log("rotate_range", x, y, z, p, vp, va);
	  const up = to_uvec3(p);
	  if (lt_all_uvec3(up, sz)) {
	    copy_data.tex_pri.set(ui(p.x), ui(p.y), ui(p.z), vp);
	    copy_data.tex_sec.set(ui(p.x), ui(p.y), ui(p.z), va);
	  }
	}
      }
    }
    paste_value(0xffu);
  }
  private function uint rotate_voxel_value(imat3 const& m, uint v)
  {
    if (is_plane_node(v)) {
      mutable pp = decode_plane_node(v);
      pp.nor = m * pp.nor;
      v = encode_plane_node(pp);
    } else if (is_sphere_node(v)) {
      mutable sp = decode_sphere_node(v);
      sp.center = m * sp.center;
      sp.scale = map{ivec3, abs}(m * sp.scale);
      v = encode_sphere_node(sp);
    } else if (is_space_voxel(v)) {
      v = 0u;
    }
    return v;
  }
  private function void set_space()
  {
    set_cur_value(texture_value_index_primary, 0u);
    set_cur_value(texture_value_index_secondary, 0u);
    // message = "edit_mode: erased";
  }
  private function void reset_edit_params()
  {
    copy_value();
    const cur = ttev->get_cursor_range();
    const sz = cur.second;
    const hsz = map{uvec3, operator::div}(sz, make_uvec3(2, 2, 2));
    bool has_plane = false;
    bool has_sphere = false;
    plane_param pp;
    sphere_param sp;
    color_param cp;
    cp.rgb.r = 128;
    cp.rgb.g = 128;
    cp.rgb.b = 128;
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
	for (const x: 0 .. sz.x) {
	  const v = copy_data.tex_pri.get(x, y, z);
	  if (is_plane_node(v)) {
	    pp = decode_plane_node(v);
	    const offset = make_ivec3(si(x), si(y), si(z)) - to_ivec3(hsz);
	    pp.dist += dot_int(pp.nor, offset) * 2;
	    has_plane = true;
	  } else if (is_sphere_node(v)) {
	    sp = decode_sphere_node(v);
	    const offset = make_ivec3(si(x), si(y), si(z)) - to_ivec3(hsz);
	    sp.center += map{ivec3, operator::mul}(offset, sp.scale);
	    has_sphere = true;
	  }
	  if (!is_space_voxel(v) && !is_node_reference(v)) {
	    cp = decode_color_param(copy_data.tex_sec.get(x, y, z));
	    debug_log("reset_edit_params: color", cp, to_hexstring(v));
	  }
	}
      }
    }
    if (has_plane) {
      edit_plane_param = pp;
    } else if (has_sphere) {
      edit_sphere_param = sp;
    }
    edit_color_param = cp;
    // debug_log("reset_edit_params", copy_data);
  }
  private function void change_fill_type(edit_fill_type_t edit_fill_type)
  {
    if (edit_fill_type == edit_fill_type_wall) {
      fill_range_value(255u << 24u, 0x00808080u, false);
      message = "change fill type: filled";
    } else if (edit_fill_type == edit_fill_type_plane) {
      edit_plane_param = plane_param();
      fill_range_plane(edit_plane_param, true);
      message = "change fill type: plane";
    } else if (edit_fill_type == edit_fill_type_sphere) {
      edit_sphere_param = sphere_param();
      fill_range_sphere(edit_sphere_param, true, 0u);
      message = "change fill type: sphere";
    } else {
      fill_range_value(0u, 0u, true);
    }
    // debug_log("new fill type", edit_fill_type);
  }
  private function {f} void fill_range_func(bool clear_pri, bool clear_sec)
  {
    const cur = ttev->get_cursor_range();
    if (clear_pri || clear_sec) {
      copy_value();
    }
    const sz_l2 = map{uvec3, integral_log2{uint}}(copy_data.copy_size);
    if (clear_pri) {
      copy_data.tex_pri.set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    }
    if (clear_sec) {
      copy_data.tex_sec.set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    }
    for (const z: 0 .. copy_data.copy_size.z) {
      for (const y: 0 .. copy_data.copy_size.y) {
	for (const x: 0 .. copy_data.copy_size.x) {
	  f(copy_data, x, y, z);
	}
      }
    }
    paste_value(0xffu);
  }
  private function void fill_range_value(uint v_pri, uint v_sec, bool set_sec)
  {
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      if (set_sec) {
	data.tex_sec.set(x, y, z, v_sec);
      } else {
	// 変更前が空白だったときはset_secが偽でもaux値をセットする
	const ov = data.tex_pri.get(x, y, z);
	if (is_node_reference(ov) || is_space_voxel(ov)) {
	  data.tex_sec.set(x, y, z, v_sec);
	}
      }
      data.tex_pri.set(x, y, z, v_pri);
    }
    fill_range_func{ffunc}(false, set_sec);
  }
  private function void fill_range_color(color_param const& p, bool clear)
  {
    const value = encode_color_param(p);
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex_pri.get(x, y, z);
      if (is_node_reference(ov) || is_space_voxel(ov)) {
	return;
      }
      data.tex_sec.set(x, y, z, value);
    }
    fill_range_func{ffunc}(false, clear);
  }
  private function void fill_range_plane(plane_param const& p, bool clear)
  {
    const cur = ttev->get_cursor_range();
    const copy_size = cur.second;
    const center = map{uvec3, operator::div}(copy_size, make_uvec3(2, 2, 2));
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex_pri.get(x, y, z);
      if (is_node_reference(ov) || is_sphere_node(ov)) {
	return;
      }
      const v = make_plane_node(p, make_ivec3(
	si(x) - si(center.x),
	si(y) - si(center.y),
	si(z) - si(center.z)),
	2);
      data.tex_pri.set(x, y, z, v);
      if (clear) {
	data.tex_sec.set(x, y, z, 0x00808080u);
      }
    }
    fill_range_func{ffunc}(clear, false);
  }
  private function void fill_range_sphere(sphere_param const& p, bool clear,
    uint modifier)
  {
    const cur = ttev->get_cursor_range();
    const copy_size = cur.second;
    const center = map{uvec3, operator::div}(copy_size, make_uvec3(2, 2, 2));
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex_pri.get(x, y, z);
      if (is_node_reference(ov) /* || is_plane_node(ov) */) {
	return;
      }
      const v = make_sphere_node(p, make_ivec3(
	si(x) - si(center.x),
	si(y) - si(center.y),
	si(z) - si(center.z)),
	2, modifier);
      data.tex_pri.set(x, y, z, v);
      if (clear) {
	data.tex_sec.set(x, y, z, 0x00808080u);
      }
    }
    fill_range_func{ffunc}(clear, false);
  }
  private function uvec3 cur_tpat_base() const
  {
    const v = get_cur_tmap(texture_value_index_primary, 0u);
    debug_log("cur_tpat_base:", to_hexstring(v));
    if (!is_node_reference(v)) {
      return glm::uvec3();
    }
    const z = (v >> 16u) & 0xff;
    const y = (v >>  8u) & 0xff;
    const x = (v >>  0u) & 0xff;
    const p = make_uvec3(x, y, z);
    debug_log("cur_tpat_base:", p);
    return map{uvec3, operator::mul}(p, ttev->tile_size);
  }
  private function uint get_cur_value(texture_value_index_e idx,
    size_t miplevel, size_t mutable& mlpat_r, size_t mutable mlmap_r) const
  {
    size_t tile_size_log2 = integral_log2(ttev->tile_size.x);
    const mlpat = miplevel;
    const mlmap = miplevel < tile_size_log2 ?
      size_t() : miplevel - tile_size_log2;
    mlpat_r = mlpat;
    mlmap_r = mlmap;
    return ttev->get_cursor_tpat() ?
      get_cur_tpat(idx, mlpat) : get_cur_tmap(idx, mlmap);
  }
  private function void set_cur_value(texture_value_index_e idx, uint value)
  {
    if (ttev->get_cursor_tpat()) {
      set_cur_tpat(idx, value);
    } else {
      set_cur_tmap(idx, value);
    }
  }
  private function uint get_cur_tmap(texture_value_index_e idx,
    size_t miplevel) const
  {
    const mp = ttev->get_tmap_cursor_pos().first;
    return ttev->tmap_edit_get(mp, idx, miplevel);
  }
  private function void set_cur_tmap(texture_value_index_e idx, uint value)
  {
    const m = ttev->get_tmap_cursor_pos();
    const mi = map{uvec3, min}(m.first, m.second);
    const mx = map{uvec3, max}(m.first, m.second);
    // debug_log("set_cur_tmap", m);
    for (const z: mi.z .. mx.z + 1) {
      for (const y: mi.y .. mx.y + 1) {
	for (const x: mi.x .. mx.x + 1) {
	  // debug_log("set_cur_tmap", x, y, z, value);
	  ttev->tmap_edit_set(make_uvec3(x, y, z), idx, value);
	}
      }
    }
  }
  private function uint get_cur_tpat(texture_value_index_e idx,
    size_t miplevel) const
  {
    return ttev->tpat_edit_get(get_cur_tpat_center(), idx, miplevel);
  }
  private function void set_cur_tpat(texture_value_index_e idx, uint value)
  {
    if (idx == texture_value_index_primary && is_node_reference(value)) {
      value = 0u;
    }
    return ttev->tpat_edit_set(get_cur_tpat_center(), idx, value);
  }
  private function uvec3 get_cur_tpat_center() const
  {
    return map{uvec3, operator::div}(
      ttev->get_tpat_cursor_pos().first + ttev->get_tpat_cursor_pos().second,
      make_uvec3(2, 2, 2));
  }
  private function uvec3 get_cur_tmap_center() const
  {
    return map{uvec3, operator::div}(
      ttev->get_tmap_cursor_pos().first + ttev->get_tmap_cursor_pos().second,
      make_uvec3(2, 2, 2));
  }
  private function bool is_cur_tmap_node_reference() const
  {
    return is_node_reference(get_cur_tmap(texture_value_index_primary, 0u));
  }
  private function uvec3 cur_tpat_index() const
  {
    return ttev->get_tpat_cursor_pos().first;
  }
  public function void on_frame(projection_info const& prj0)
  {
    prj = prj0;
    ttev->cursor_flick();
  }
  public function void modify_tmap(uvec3 const& pos, uint value)
  {
    ttev->tmap_edit_set(pos, texture_value_index_primary, value);
  }
}

