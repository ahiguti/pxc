private threaded namespace pgl3d::drawer::setfb "export-unsafe";
public import common -;
public import pgl3d::drawer::base -;
public import meta m;

private struct setfb_attributes { }

private function void get_color_format(string const& s, GLenum mutable& ifmt,
  GLenum mutable& efmt, GLenum mutable& etyp)
{
  if (s == "") {
    ifmt = GL_NONE;
    efmt = GL_NONE;
    etyp = GL_NONE;
  } else if (s == "GL_RGBA") {
    ifmt = GL_RGBA;
    efmt = GL_RGBA;
    etyp = GL_UNSIGNED_INT;
  } else if (s == "GL_RGB") {
    ifmt = GL_RGB;
    efmt = GL_RGBA;
    etyp = GL_UNSIGNED_INT;
  } else if (s == "GL_RG") {
    ifmt = GL_RG;
    efmt = GL_RG;
    etyp = GL_UNSIGNED_SHORT;
  } else if (s == "GL_RED") {
    ifmt = GL_RED;
    efmt = GL_RED;
    etyp = GL_UNSIGNED_BYTE;
  } else {
    throw runtime_error_template{"color_format"}(s);
  }
}

private function void get_depth_format(string const& s, GLenum mutable& ifmt,
  GLenum mutable& efmt, GLenum mutable& etyp)
{
  if (s == "") {
    ifmt = GL_NONE;
    efmt = GL_NONE;
    etyp = GL_NONE;
  } else if (s == "GL_DEPTH_COMPONENT") {
    ifmt = GL_DEPTH_COMPONENT;
    efmt = GL_DEPTH_COMPONENT;
    etyp = GL_UNSIGNED_INT;
  } else if (s == "GL_DEPTH_COMPONENT16") {
    ifmt = GL_DEPTH_COMPONENT;
    efmt = GL_DEPTH_COMPONENT;
    etyp = GL_UNSIGNED_INT;
  } else {
    throw runtime_error_template{"depth_format"}(s);
  }
}

public struct drawer_setfb(shader_config const& glc,
  drawer_shared const& ds, ptr{glm::uvec2} const& src_size0,
  ptr{glm::uvec2} const& dst_size0, string const& fbname0, bool owner_flag0,
  string const& color_fmt0, string const& depth_fmt0)
<drawstep_i>
{
  /* draw()されるとフレームバッファをbindする。owner_flagが真ならフレーム
   * バッファを作成する。fbnameが空ならtoplevel fbをbindする。
   */
  ptr{glm::uvec2} const src_size = src_size0;
  ptr{glm::uvec2} const dst_size = dst_size0;
  string const fbname = fbname0;
  bool const enable_depth_texture = glc.enable_depth_texture;
  bool const owner_flag = owner_flag0;
  bool color_tex = false;
  bool depth_tex = false;
  GLenum color_ifmt;
  GLenum color_efmt;
  GLenum color_etyp;
  GLenum depth_ifmt;
  GLenum depth_efmt;
  GLenum depth_etyp;
  option{ptr{gl_framebuffer}} fbo_own;
  option{cptr{gl_framebuffer}} fbo;
  public function vbid_t get_vbid() const { return vbid_invalid(); }
  public function vbid_t get_instances_vbid() const { return vbid_invalid(); }
  public function vbid_t get_vertices_vbid() const { return vbid_invalid(); }
  init(ds, color_fmt0, depth_fmt0);
  function void init(drawer_shared const& ds, string const& color_fmt0,
    string const& depth_fmt0)
  {
    get_color_format(color_fmt0, color_ifmt, color_efmt, color_etyp);
    get_depth_format(depth_fmt0, depth_ifmt, depth_efmt, depth_etyp);
    color_tex = (color_ifmt != GL_NONE);
    depth_tex = (depth_ifmt != GL_NONE);
    if (fbname.empty()) {
      return;
    }
    const res = pointer_downcast{ptr{resource_pool}}(ds.gl_resources);
    if (const& fb: res->framebuffers[fbname]) {
      fbo.some = fb;
      debug_log("setfb: found frambuffer", fbname);
    } else {
      fbo_own.some = make_ptr{gl_framebuffer}();
      fbo.some = fbo_own.some;
      res->framebuffers.insert(fbname, fbo.some);
      debug_log("setfb: created frambuffer", fbname);
    }
  }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_default}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{setfb_attributes}(false, false);
  }
  public function string builtin_vertex_set_name() const { return string(); }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const { }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void resize_screen(shader_config const& glc)
  {
    if (fbname.empty()) {
      return;
    }
    if (owner_flag) {
      fbo_own.some->width = static_cast{int}(src_size->x);
      fbo_own.some->height = static_cast{int}(src_size->y);
      if (color_tex) {
        init_color_fbo(glc, *fbo_own.some, color_ifmt, color_efmt,
          color_etyp, depth_ifmt, depth_efmt, depth_etyp);
        debug_log("setfb color fbo");
      } else {
        init_shadowmap_fbo(glc, *fbo_own.some);
        debug_log("setfb shadowmap fbo");
      }
      debug_log("setfb", fbo_own.some->width, fbo_own.some->height);
    }
  }
  public function bool reload_shaders(shader_config const& glc)
  {
    return true;
  }
  public function void draw_drawstep(draw_data mutable& ddata)
  {
    if (fbname.empty()) {
      glBindFramebuffer(GL_FRAMEBUFFER, ddata.toplevel_fb);
      ddata.cur_target_fb.none = unit();
    } else if (!color_tex) {
      glBindFramebuffer(GL_FRAMEBUFFER, fbo.some->fbo.get());
      // debug_log("setfb: depth-only fb");
      glEnable(GL_CULL_FACE);
      /* glCullFace(GL_FRONT); */
      glEnable(GL_DEPTH_TEST);
      glDepthMask(1);
      if (enable_depth_texture) {
	glColorMask(0, 0, 0, 0);
      } else {
	glColorMask(1, 1, 1, 1); // TODO: 1,1,0,0 when enable_vsm ?
      }
      glDepthFunc(GL_LEQUAL);
      glDisable(GL_BLEND);
      if (owner_flag) {
        if (!enable_depth_texture) {
          glClearColor(1.0, 1.0, 1.0, 1.0);
        }
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      }
      ddata.cur_target_fb.some = fbo.some;
    } else {
      glBindFramebuffer(GL_FRAMEBUFFER, fbo.some->fbo.get());
      if (depth_tex) {
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LEQUAL); // LESSのほうがよい？
        glDepthMask(1);
      }
      glDisable(GL_BLEND);
      if (owner_flag) {
        glClear(GL_DEPTH_BUFFER_BIT);
      }
      ddata.cur_target_fb.some = fbo.some;
      // debug_log("setfb: color fb");
    }
    const& viewport = *dst_size;
    glViewport(0, 0, static_cast{GLsizei}(viewport.x),
      static_cast{GLsizei}(viewport.y));
  }
  public function option{ptr{edit_mode_i}} get_edit_mode() const
  {
    return option{ptr{edit_mode_i}}();
  }
}

