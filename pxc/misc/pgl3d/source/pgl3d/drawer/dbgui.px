private threaded namespace pgl3d::drawer::dbgui "export-unsafe";
public import common -;
public import pgl3d::drawer::base -;
public import meta m;

private tsvaluetype struct dbgui_vertex_attributes()
{
  public glm::vec2 vert;
}

private tsvaluetype struct dbgui_instance_attributes()
{
  public glm::vec4 idata; // x0, y0, dx, dy
}

private tsvaluetype struct dbgui_uniforms()
{
  public int sampler_sm; // array
}

public struct drawer_dbgui(shader_config const& glc0,
  drawer_shared const& ds)
<pgldrawer_i>
{
  shader_config const glc = glc0;
  metafunction tattr dbgui_vertex_attributes;
  option{dbgui_shader_ptr} sdr_di;
  init();
  private function void init()
  {
    reload_shaders();
  }
  public function string get_vbid_name() const { return "vbid_dbgui"; }
  public function string get_instances_vbid_name() const {
    return "vbid_dbgui"; }
  public function string get_vertices_vbid_name() const {
    return "vbid_dbgui"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_dbgui}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, false);
  }
  public function string builtin_vertex_set_name() const { return "dbgui"; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const
  {
    farray{vertex_attr, 4} dummy_vattr;
    farray{dbgui_vertex_attributes, 4} vs;
    vs[0].vert = glm::make_vec2(0.0, 0.0);
    vs[1].vert = glm::make_vec2(1.0, 0.0);
    vs[2].vert = glm::make_vec2(1.0, 1.0);
    vs[3].vert = glm::make_vec2(0.0, 1.0);
    vptr->push_polygon_distinct{dbgui_vertex_attributes, 0}(dummy_vattr, vs);
  }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void resize_screen(shader_config const& glc, int width,
    int height)
  { 
  }
  public function bool reload_shaders()
  {
    option{dbgui_shader_ptr} s0;
    try {
      s0.some = init_dbgui_shader(glc);
    } catch (runtime_error ex) {
      debug_log("reload failed: " + ex.message());
      return false;
    }
    sdr_di.some = s0.some;
    return true;
  }
  public function uint get_postprocess_framebuffer(draw_step step) const
  {
    return 0U;
  }
  public function bool has_step(draw_step step) const
  {
    return step == draw_step_hud;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vbid_t vbid,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (step == draw_step_hud) {
      glDisable(GL_DEPTH_TEST);
      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
      mutable& sdr = *sdr_di.some;
      glUseProgram(sdr.program);
      darrayst{int} sampler_smarr = darrayst{int}(
	    static_cast{size_t}(glc.num_shadowmaps), 0);
      for (const i: 0 .. glc.num_shadowmaps) {
	glActiveTexture(static_cast{GLenum}(
	  static_cast{int}(GL_TEXTURE8) + i));
	glBindTexture(GL_TEXTURE_2D, smtex_arr[static_cast{size_t}(i)]);
	sampler_smarr[static_cast{size_t}(i)] = 8 + i;
      }
      glUniform1iv(sdr.u_sampler_sm, glc.num_shadowmaps,
	caddress(sampler_smarr[0]));
      aibuf.draw(sdr, bo, bo_ib, vbid, glc.enable_instanced,
	glc.enable_uniform_instancing);
    }
  }
  public function option{ptr{edit_mode_i}} get_edit_mode() const
  {
    return option{ptr{edit_mode_i}}();
  }
}

metafunction dbgui_shader_ptr
  ptr{glshader{
    dbgui_uniforms, dbgui_instance_attributes, dbgui_vertex_attributes}};

function dbgui_shader_ptr
init_dbgui_shader(shader_config const& g)
{
  tree_map{string, string} bnd;
  bnd["smsz"] = g.num_shadowmaps_str();
  bnd["shdowmap_resolution"] = to_string(g.shadowmap_resolution);
  const v = load_shader_program(g, bnd, "dbgui.vsh");
  const f = load_shader_program(g, bnd, "dbgui.fsh");
  return make_glshader_ptr{dbgui_uniforms, dbgui_instance_attributes,
    dbgui_vertex_attributes}(v, f, "idata", g.debug_level, "dbgui");
  /*
  string v;
  string f;
  v += g.prepend();
  v += g.vert_in() + "vec2 vert;\n";
  v += g.decl_instance_attr("vec4", "idata");
  v += "void main(void) {\n";
  v += "vec4 idata_i = " + g.instance_attr("idata") + ";\n";
  v += "vec2 screen_pos = idata_i.xy + idata_i.zw * vert;\n";
  v += "gl_Position = vec4(screen_pos, 0.0, 1.0);\n";
  v += "}\n";
  f += g.prepend();
  f += g.decl_fragcolor();
  f += "void main(void) {\n";
  f += g.fragcolor() + " = vec4(1.0, 1.0, 1.0, 0.3);\n";
  f += "}\n";
  return make_glshader_ptr{dbgui_uniforms, dbgui_instance_attributes,
    dbgui_vertex_attributes}(v, f, "idata", g.debug_level, "dbgui");
  */
}

private threaded function void prepare_instance_data_dbgui(
  scene_node const& sn, node_common_data mutable& ncd,
  instance_data mutable& idata)
{
  const sli = sn.trans.value.to_cslice();
  idata.instance_buffer.append(sli[0 .. 4]);
}

