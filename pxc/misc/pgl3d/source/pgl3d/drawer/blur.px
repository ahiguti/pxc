private threaded namespace pgl3d::drawer::blur "export-unsafe";
public import common -;
public import pgl3d::drawer::base -;
public import meta m;

private tsvaluetype struct blur_vertex_attributes()
{
  public glm::vec2 vert;
}

private tsvaluetype struct blur_instance_attributes()
{
}

private tsvaluetype struct blur_uniforms()
{
  public glm::vec2 pixel_delta;
  public int sampler_tex;
  public int sampler_tex_depth;
  public float option_value;
}

public struct drawer_blur(shader_config const& glc,
  drawer_shared const& ds)
<pgldrawer_i>
{
  metafunction tattr blur_vertex_attributes;
  public gl_framebuffer ppfbo;
  public gl_framebuffer sppfbo;
  bool const enable_bokeh = glc.conf.get("bokeh", 1, 0, 1) != 0;
  bool const enable_bilinear = glc.conf.get("blur_bilinear", 0, 0, 1) != 0;
  bool const enable_shadow_blur = glc.conf.get("blur_shadow", 1, 0, 1) != 0;
  blur_shader_ptr sdr_re = init_blur_shader(glc, enable_bokeh);
  public function string get_vbid_name() const { return "vbid_blur"; }
  public function string get_instances_vbid_name() const {
    return "vbid_blur"; }
  public function string get_vertices_vbid_name() const {
    return "vbid_blur"; }
  public function prepare_instance_data_funcptr
  get_prepare_instance_data_funcptr() const {
    return make_tfuncptr{prepare_instance_data_default}();
  }
  public function ptr{vertex_buffer} make_vertex_buffer() const {
    return make_tattr_vertex_buffer{tattr}(false, false);
  }
  public function string builtin_vertex_set_name() const { return "blur"; }
  public function void make_builtin_vertex_sets(ptr{vertices} const& vptr)
    const
  {
    farray{vertex_attr, 4} dummy_vattr;
    farray{blur_vertex_attributes, 4} vs;
    vs[0].vert = glm::make_vec2(-1.0, -1.0);
    vs[1].vert = glm::make_vec2( 1.0, -1.0);
    vs[2].vert = glm::make_vec2( 1.0,  1.0);
    vs[3].vert = glm::make_vec2(-1.0,  1.0);
    vptr->push_polygon_distinct{blur_vertex_attributes, 0}(dummy_vattr, vs);
  }
  public function dgf_filler make_filler(ptr{vertices} const& vptr) const
  {
    return make_dgf_noop(vptr);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    return texture_info();
  }
  public function void resize_screen(shader_config const& glc, int width,
    int height)
  {
    ppfbo.width = width;
    ppfbo.height = height;
    init_postprocess_fbo(glc, enable_bokeh, ppfbo);
    if (enable_bilinear) {
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, ppfbo.texture0.get());
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
	static_cast{int}(GL_LINEAR));
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
	static_cast{int}(GL_LINEAR));
    }
    if (enable_shadow_blur) {
      sppfbo.width = glc.shadowmap_resolution;
      sppfbo.height = glc.shadowmap_resolution;
      init_shadowmap_fbo(glc, sppfbo);
    }
    debug_log("blur", width, height);
  }
  public function bool reload_shaders()
  {
    return true;
  }
  public function uint get_postprocess_framebuffer(draw_step step) const
  {
    if (step == draw_step_postprocess) {
      return ppfbo.fbo.get();
    } else if (step == draw_step_shadow_pp) {
      return sppfbo.fbo.get();
    }
    return 0U;
  }
  public function bool has_step(draw_step step) const
  {
    if (step == draw_step_postprocess) {
      return true;
    }
    if (step == draw_step_shadow_pp) {
      return enable_shadow_blur;
    }
    return false;
  }
  public function void draw(draw_step step, size_t iter,
    vertex_buffer const& bo, bo_instances_type const& bo_ib,
    aggregated_ibuffer const& aibuf, vbid_t vbid,
    shader_config const& glc, projection_info const& cam_df,
    cslice{GLuint} const& smtex_arr)
  {
    if (step == draw_step_postprocess) {
      // debug_log("blur draw");
      glDisable(GL_DEPTH_TEST);
      glDepthMask(0);
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, ppfbo.texture0.get());
      if (enable_bokeh) {
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, ppfbo.texture1.get());
      }
      mutable& sdr = *sdr_re;
      glUseProgram(sdr.program);
      glUniform1i(sdr.u_sampler_tex, 0);
      glUniform1i(sdr.u_sampler_tex_depth, 1);
      const pixel_delta = glm::make_vec2(
	1.0f / static_cast{float}(ppfbo.width),
	1.0f / static_cast{float}(ppfbo.height));
      // debug_log("delta", pixel_delta);
      glUniform2fv(sdr.u_pixel_delta, 1, pixel_delta.to_crawptr());
      mutable opval = static_cast{int}(cam_df.option_value);
      opval %= 2;
      glUniform1f(sdr.u_option_value, static_cast{float}(opval));
      bo.draw(0, sdr);
    } else if (step == draw_step_shadow_pp) {
      //debug_log("blur shadow_pp", sppfbo.width, sppfbo.height);
      glDisable(GL_DEPTH_TEST);
      glDepthMask(0);
      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D, sppfbo.texture0.get());
      mutable& sdr = *sdr_re;
      glUseProgram(sdr.program);
      glUniform1i(sdr.u_sampler_tex, 0);
      const pixel_delta = glm::make_vec2(
	1.0f / static_cast{float}(sppfbo.width),
	1.0f / static_cast{float}(sppfbo.height));
      // debug_log("delta", pixel_delta);
      glUniform2fv(sdr.u_pixel_delta, 1, pixel_delta.to_crawptr());
      int const opval = 0;
      /*
      mutable opval = static_cast{int}(cam_df.option_value);
      opval %= 2;
      opval = 0;
      */
      glUniform1f(sdr.u_option_value, static_cast{float}(opval));
      bo.draw(0, sdr);
    }
  }
  public function option{ptr{edit_mode_i}} get_edit_mode() const
  {
    return option{ptr{edit_mode_i}}();
  }
}

metafunction blur_shader_ptr
  ptr{glshader{
    blur_uniforms, blur_instance_attributes, blur_vertex_attributes}};

function blur_shader_ptr
init_blur_shader(shader_config const& g, bool enable_bokeh)
{
  tree_map{string, string} bnd;
  bnd["blur_param"] = to_string(g.conf.get("blur_param", 0.7, 0.334, 1.0));
  bnd["enable_bokeh"] = enable_bokeh ? "1" : "0";
  const v = load_shader_program(g, bnd, "blur.vsh");
  const f = load_shader_program(g, bnd, "blur.fsh");
  return make_glshader_ptr{blur_uniforms, blur_instance_attributes,
    blur_vertex_attributes}(v, f, "", g.debug_level, "blur");
}

