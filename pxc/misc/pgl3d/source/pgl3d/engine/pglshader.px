private namespace pgl3d::engine::pglshader "export-unsafe";
public import common -;
public import pointer::raw -;
public import pointer::raw_unsafe -;
public import numeric::fpmath -;
public import glm;
public import glm::raw;
public import io::time -;
public import exception -;
public import meta m;
public import pointer::tfuncptr -;
public import opengl::compat -;
public import pgl3d::geometry::funcs -;
public import pgl3d::opengl::glresource -;
public import pgl3d::opengl::glshader -;
public import pgl3d::opengl::glbuffer -;
public import pgl3d::opengl::shader_config -;
public import pgl3d::opengl::aggregated_ibuffer -;
public import pgl3d::opengl::resource_pool -;
public import pgl3d::opengl::framebuffer -;
public import pgl3d::drawer::base -;
public import pgl3d::engine::pglbase -;
public import pgl3d::engine::intern_pool -;

public struct vertex_buffer_pool_key { }

public struct
pglshader(shader_config const& sconf0, ptr{resource_pool} const& respool0,
  varray{ptr{pgldrawer_export_i}} const& drawers0, int width0,
  int height0)
<make_vertices_i>
{
  public shader_config const glc = sconf0;
  public ptr{resource_pool} const respool = respool0;
  public tree_map{string, size_t} drawer_names = get_drawer_names(drawers0);
    // 名前からdrawersのオフセットを返す
  public varray{ptr{pgldrawer_i}} drawers = downcast_drawers(drawers0);
    // 全drawerを保持する
  public varray{size_t} drawers_shadow_pp;
    // shadow_ppステップを持つようなdrawerの一覧
  public varray{size_t} drawers_postprocess;
    // drawer_postprocessステップを持つようなdrawerの一覧
  public varray{vbid_t} drawer_vbids;
    // drawerのオフセットからそのdrawerのvbidを返す
  public varray{vbid_t} drawer_instances_vbids;
    // drawerのオフセットからそのdrawerのinstances vbidを返す
  public varray{vbid_t} drawer_vertices_vbids;
    // drawerのオフセットからそのdrawerのvertices vbidを返す
  public varray{ptr{gl_framebuffer}} sfbo_array;
  public projection_info cam;
  public varray{ptr{vertex_buffer}} vertex_buffers;
    // 全vertex_bufferを保持する。vbidで引く。
  public aggregated_ibuffer agg_ibuffer;
  public tptr{pidf_table} const pidft = make_tptr{pidf_table}();
  public ptr{varray{uchar}} const debug_ext_display = make_ptr{varray{uchar}}();
  private auto_vertexarray vtxarr;
  private tree_map{string, vbid_t} vbid_map;
  private intern_pool{vertex_buffer_pool_key} vbid_pool;
  init();
  resize_screen(width0, height0, width0, height0);
  /*
  public function vbid to_vbid(cstrref const& name) const {
    return vbid_pool.to_id(name);
  }
  */
  public function vbid_t intern_vbid(cstrref const& name) {
    const r = vbid_pool.intern(name);
    sdl_log("intern ", name, r);
    return static_cast{vbid_t}(r);
  }
  public function void set_vertex_buffer(vbid_t vbid,
    ptr{vertex_buffer} const& p) {
    vertex_buffers.resize(vbid + 1u,
      make_ptr{vertex_buffer}(0u, false, false));
    vertex_buffers[vbid] = p;
  }
  private function void init()
  {
    sdl_log("pglshader init");
    /*
    {
      int val;
      glGetIntegerv(GL_DEPTH_BITS, address(val));
      sdl_log("depth bits", val);
    }
    */
    if (m::ne{is_gl3_or_gles3, 0}) {
      vtxarr.generate();
      glBindVertexArray(vtxarr.get());
      sdl_log("glBindVertexArray", vtxarr.get());
    }
    if (m::eq{is_gles, 0}) {
      farray{float, 2} arr;
      float step;
      glGetFloatv(GL_POINT_SIZE_RANGE, arr.to_rawptr());
      glGetFloatv(GL_POINT_SIZE_GRANULARITY, address(step));
      sdl_log("GL_POINT_SIZE_RANGE", arr, step);
    }
    if (m::and{is_gl3_or_gles3, m::not{is_gles}}) {
      if (glc.enable_msaa != 0) {
	glEnable(GL_MULTISAMPLE);
      }
    }
    /*
    */
    if (m::eq{is_gles, 0}) {
      if (!glc.is_gl3_or_gles3()) {
	glEnable(GL_POINT_SPRITE);
	sdl_log("GL_POINT_SPRITE enabled");
      }
      glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
    }
    drawer_vbids.resize(drawers.size(), 0);
    drawer_instances_vbids.resize(drawers.size(), 0);
    drawer_vertices_vbids.resize(drawers.size(), 0);
    for (const i, const& pd: drawers) {
      drawer_vbids[i] = intern_vbid(pd->get_vbid_name());
      debug_log(i, "drawer_vbids", drawer_vbids[i], pd->get_vbid_name());
      drawer_instances_vbids[i] = intern_vbid(pd->get_instances_vbid_name());
      debug_log(i, "drawer_instances_vbids", drawer_instances_vbids[i],
	pd->get_instances_vbid_name());
      drawer_vertices_vbids[i] = intern_vbid(pd->get_vertices_vbid_name());
      debug_log(i, "drawer_vertices_vbids", drawer_vertices_vbids[i],
	pd->get_vertices_vbid_name());
      size_t j = drawer_vbids[i];
      /*
      if (vbid_to_drawer_one.size() <= j) {
	vbid_to_drawer_one.resize(j + 1, 0);
      }
      vbid_to_drawer_one[j] = i;
      */
      {
	mutable& pidftv = *pidft;
	if (pidftv.size() <= j) {
	  pidftv.resize(j + 1, make_tfuncptr{prepare_instance_data_noop}());
	}
	pidftv[j] = pd->get_prepare_instance_data_funcptr();
      }
      set_vertex_buffer(drawer_vbids[i], pd->make_vertex_buffer());
    }
    if (sfbo_array.empty()) {
      for (size_t i: 0 .. static_cast{size_t}(glc.num_shadowmaps)) {
	sfbo_array.push_back(make_ptr{gl_framebuffer}());
      }
    }
    for (const i, const& pd: drawers) {
      if (pd->has_step(draw_step_shadow_pp)) {
	drawers_shadow_pp.push_back(i);
      }
    }
    for (const i, const& pd: drawers) {
      if (pd->has_step(draw_step_postprocess)) {
	drawers_postprocess.push_back(i);
      }
    }
    sdl_log("pglshader init done");
  }
  public function void prepare(whole_instances_type mutable& whole_instances_r,
    node_factory mutable& nfac_r)
  {
    prepare_builtin_vertex_sets();
    prepare_vertex_buffers();
    prepare_whole_instances(whole_instances_r);
    prepare_node_factory(nfac_r);
  }
  private function void prepare_builtin_vertex_sets()
  {
    for (const i, const& pd: drawers) {
      const name = pd->builtin_vertex_set_name();
      if (name.empty()) {
	continue;
      }
      const vbid = drawer_vbids[i];
      const vtx = make_vertices(vbid, name);
      pd->make_builtin_vertex_sets(vtx);
    }
  }
  private function void prepare_vertex_buffers()
  {
    for (const i, const& bo: vertex_buffers) {
      bo->create_vbo();
    }
  }
  private function void prepare_whole_instances(
    whole_instances_type mutable& whole_instances) const
  {
    whole_instances.resize(vertex_buffers.size(), bo_instances_type());
    for (const i, const& bo: vertex_buffers) {
      mutable& instances = whole_instances[i];
      for (const j: 0 .. bo->vs_arr.size()) {
	instances.push_back(instance_data());
      }
    }
  }
  private function void prepare_node_factory(node_factory mutable& nf) const
  {
    for (const vbid, const& bop: vertex_buffers) {
      for (const& n, const id: bop->vs_names) {
	if (bop->is_sub_drawer) {
	  // sub_drawer vbid must not used for joint_id
	  debug_log("is_sub_drawer skipped", n, "vbid=", vbid);
	  continue;
	}
	joint_id_type jid;
	jid.vbid = static_cast{vbid_t}(vbid);
	jid.vsid = id;
	mutable& ent = nf.name_to_id[n];
	if (ent.vbid != vbid_invalid()) {
	  debug_log("warning: duplicated node name", n, ent, jid);
	}
	ent = jid;
	// nf.name_to_id[n] = jid;
      }
      nf.binfo.push_back(node_buffer_info());
      node_buffer_info mutable& nbi = nf.binfo[nf.binfo.size() - 1];
      for (const i, const& vsp: bop->vs_arr) {
	nbi.vs_arr.push_back(node_vs_info());
	node_vs_info mutable& nvi = nbi.vs_arr[nbi.vs_arr.size() - 1];
	for (const j, const& nj: vsp->vtxs->joints) {
	  node_joint_info nji;
	  nji.joint_id = find_joint_id_by_name(nj.joint_name);
	  nji.trans = nj.trans;
	  nvi.joints.push_back(nji);
	}
      }
    }
  }
  public function joint_id_type find_joint_id_by_name(cstrref const& name)
    const
  {
    joint_id_type scene_id;
    for (const i, const& bo: vertex_buffers) {
      // sub-drawer vbid must not used for joint_id
      if (!bo->is_sub_drawer && bo->has_name(name)) {
        scene_id.vbid = static_cast{vbid_t}(i);
        scene_id.vsid = bo->get_id_by_name(name);
        break;
      }
    }
    return scene_id;
  }
  public function cptr{vertices} get_nonempty_vertices(cstrref const& name)
    const
  {
    joint_id_type scene_id;
    for (const i, const& bo: vertex_buffers) {
      // allow sub-drawer vbid
      if (bo->has_name(name)) {
        scene_id.vbid = static_cast{vbid_t}(i);
        scene_id.vsid = bo->get_id_by_name(name);
	if (!vertex_buffers[scene_id.vbid]->get_vertices(scene_id.vsid)
	    ->vertex_values.empty()) {
	  break;
	}
      }
    }
    /*
    joint_id_type jid = find_joint_id_by_name(name);
    */
    return vertex_buffers[scene_id.vbid]
      ->get_vertices(scene_id.vsid);
  }
  public function joint_id_type get_joint_id(cstrref const& name) const {
    return find_joint_id_by_name(name);
  }
  public function tree_map{string, joint_id_type} get_name_to_joint_id() const
  {
    tree_map{string, joint_id_type} r;
    for (const vbid, const& vb: vertex_buffers) {
      for (const& vsname, const vsid: vb->vs_names) {
	joint_id_type jid;
	jid.vbid = static_cast{vbid_t}(vbid);
	jid.vsid = vsid;
	r.insert(vsname, jid);
      }
    }
    return r;
  }
  public function ptr{vertices} make_vertices(vbid_t vbid,
    cstrref const& name)
  {
    // debug_log("make_vertices", name, vbid);
    return vertex_buffers[vbid]->make_if(name)->vtxs;
  }
  public function void make_vertex_set(cslice{string} const& dr_names,
    cstrref const& shape_name, gf_poly const& expr)
  {
    // make vertex set by geometry expression
    // TODO: dr_names[0]はsubdrawerであってはならず、残りはsubdrawer
    // でなければならない。さもないと頂点セットの名前からvsidを引くとき
    // の一意性がなくなる。
    // TODO: shape_nameは未使用のものでなくてはならない。
    varray{ptr{vertices}} vptrs;
    // varray{ptr{vertices}} vptrs_cpy;
    varray{dgf_filler} fillers;
    for (const i, const& dr_name: dr_names) {
      size_t dr_id = *drawer_names.equal_range(dr_name);
      const vbid = drawer_vbids[dr_id];
      ptr{vertices} vptr = make_vertices(vbid, shape_name);
      dgf_filler filler = drawers[dr_id]->make_filler(vptr);
      vptrs.push_back(vptr);
      // vptrs_cpy.push_back(vptr);
      fillers.push_back(filler);
    }
    // debug_log("make_vertex_set", shape_name);
    ptr{build_context_i} ctx = make_ptr{build_context_impl}(vptrs, fillers);
    expr(*ctx, poly_t(), mesh_index());
    /*
    for (const i, const& p: vptrs_cpy) {
      debug_log("make_vertex_set", shape_name, *p);
    }
    */
  }
  public function void make_vertex_set_by_triangles(string const& dr_name,
    cstrref const& shape_name, cslice{vertex_attr} const& vattrs,
    cslice{float} const& verts, size_t nfpv, cslice{uint} const& elems)
  {
    size_t dr_id = *drawer_names.equal_range(dr_name);
    const vbid = drawer_vbids[dr_id];
    ptr{vertices} vptr = make_vertices(vbid, shape_name);
    vptr->set_triangles(vattrs, verts, nfpv, elems);
  }
  public function texture_info get_texture_info(cstrref const& name) const
  {
    texture_info r;
    for (const i, const& pd: drawers) {
      const vbid = drawer_vbids[i];
      r = pd->get_texture_info(name);
      if (r.surface_w != 0) {
	break;
      }
    }
    return r;
  }
  public function vbid_t get_vbid(cstrref const& name) const
  {
    if (vbid_pool.exists(name)) {
      return static_cast{vbid_t}(vbid_pool.to_id(name));
    } else {
      return vbid_invalid();
    }
  }
  public function void resize_screen(int disp_width, int disp_height,
    int w_width, int w_height)
  {
    const virt_scale = glc.conf.get("virt_scale", 1.0f, 0.125f, 16.0f);
    const virt_width = static_cast{int}(static_cast{float}(disp_width)
      / virt_scale);
    const virt_height = static_cast{int}(static_cast{float}(disp_height)
      / virt_scale);
    const sm_size = glc.shadowmap_resolution;
    sdl_log("disp size", disp_width, disp_height);
    sdl_log("virt size", virt_width, virt_height);
    cam.virt_width = virt_width;
    cam.virt_height = virt_height;
    cam.display_width = disp_width;
    cam.display_height = disp_height;
    cam.window_width = w_width;
    cam.window_height = w_height;
    cam.shadowmap_size = sm_size;
    for (size_t i: 0 .. sfbo_array.size()) {
      mutable& sfbo = *sfbo_array[i];
      if (m::ne{is_gles, 0}) {
	sfbo.width = sm_size;
	sfbo.height = sm_size;
      } else {
	sfbo.width = sm_size;
	sfbo.height = sm_size;
      }
      init_shadowmap_fbo(glc, sfbo);
    }
    for (const i, const& pd: drawers) {
      pd->resize_screen(glc, virt_width, virt_height);
    }
    update_mvp(glc, cam);
  }
  public function bool reload_shaders()
  {
    bool r = true;
    for (const i, const& pd: drawers) {
      bool x = pd->reload_shaders();
      r = r && x;
    }
    return r;
  }
}

public function varray{uint}
pglshader_draw_frame(pglshader mutable& pgs,
  whole_instances_type mutable& whole_instances, projection_info const& cam_df)
{
  return pglshader_draw_frame_internal(false, pgs, whole_instances, cam_df);
}

public function varray{uint}
pglshader_draw_frame_lastpass(pglshader mutable& pgs,
  whole_instances_type mutable& whole_instances, projection_info const& cam_df)
{
  return pglshader_draw_frame_internal(true, pgs, whole_instances, cam_df);
}

public function void
pglshader_frame_begin(pglshader mutable& pgs,
  whole_instances_type mutable& whole_instances)
{
  pgs.agg_ibuffer.frame_begin(whole_instances,
      pgs.glc.enable_instanced, pgs.glc.enable_uniform_instancing);
}

public function void
pglshader_frame_end(pglshader mutable& pgs)
{
  pgs.agg_ibuffer.frame_end(pgs.glc.enable_instanced,
    pgs.glc.enable_uniform_instancing);
}

function varray{uint}
pglshader_draw_frame_internal(bool lastpass, pglshader mutable& pgs,
  whole_instances_type mutable& whole_instances, projection_info const& cam_df)
{
  // lastpassが真なら、ディスプレイ直近のフレームバッファからの描画のみを
  // 実行する。これはdummy_flipのために使う。それ以外の描画ではlastpassは偽。
  const tick1 = SDL_GetTicks();
  uint tick2;
  int saved_fb = 0;
  const& bos = pgs.vertex_buffers;
  /* shadowmapping shader */
  darrayst{GLuint} smtex_arr = darrayst{GLuint}(pgs.sfbo_array.size(), 0U);
  for (size_t iter: 0 .. pgs.sfbo_array.size()) {
    smtex_arr[iter] = pgs.sfbo_array[iter]->texture0.get();
  }
  if (!lastpass) {
    if (pgs.glc.enable_shadowmapping) {
      glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
      for (size_t iter: 0 .. pgs.sfbo_array.size()) {
	/*
	glDisable(GL_CULL_FACE);
	*/
	glEnable(GL_CULL_FACE);
	/*
	glCullFace(GL_FRONT);
	*/
	glEnable(GL_DEPTH_TEST);
	glDepthMask(1);
	if (pgs.glc.enable_depth_texture) {
	  glColorMask(0, 0, 0, 0);
	} else {
	  // FIXME: 1,1,0,0 when enable_vsm ?
	  glColorMask(1, 1, 1, 1);
	}
	glDepthFunc(GL_LEQUAL);
	glDisable(GL_BLEND);
	/* set fb */
	const& sfbo = *pgs.sfbo_array[iter];
	if (!pgs.drawers_shadow_pp.empty()) {
	  glBindFramebuffer(GL_FRAMEBUFFER,
	    pgs.drawers[pgs.drawers_shadow_pp[0]]
	      ->get_postprocess_framebuffer(draw_step_shadow_pp));
	} else {
	  glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
	}
	if (!pgs.glc.enable_depth_texture) {
	  glClearColor(1.0, 1.0, 1.0, 1.0);
	}
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glViewport(0, 0, static_cast{GLsizei}(sfbo.width),
	  static_cast{GLsizei}(sfbo.height));
	// shadow
	/* note: view_projection is pre-applied to model_matrix */
	for (const i, const& pd: pgs.drawers) {
	  const vert_vbid = pgs.drawer_vertices_vbids[i];
	  const inst_vbid = pgs.drawer_instances_vbids[i];
	  pd->draw(draw_step_shadowmapping, iter,
	    *bos[vert_vbid],
	    whole_instances[inst_vbid], pgs.agg_ibuffer,
	    inst_vbid, pgs.glc, cam_df, smtex_arr);
	}
	// shadow postprocess
	if (!pgs.drawers_shadow_pp.empty()) {
	  size_t n = pgs.drawers_shadow_pp.size();
	  size_t i;
	  for (i = 0; i < n; ++i) {
	    if (i < n - 1) {
	      const fb = pgs.drawers[pgs.drawers_shadow_pp[i + 1]]
		->get_postprocess_framebuffer(draw_step_shadow_pp);
	      glBindFramebuffer(GL_FRAMEBUFFER, fb);
	    } else {
	      glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo.get());
	    }
	    const j = pgs.drawers_shadow_pp[i];
	    const& pd = pgs.drawers[j];
	    const vert_vbid = pgs.drawer_vertices_vbids[j];
	    const inst_vbid = pgs.drawer_instances_vbids[j];
	    pd->draw(draw_step_shadow_pp, 0,
	      *bos[vert_vbid],
	      whole_instances[inst_vbid], pgs.agg_ibuffer,
	      inst_vbid, pgs.glc, cam_df, smtex_arr);
	  }
	}
      }
      /* restore fb */
      glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
    }
    if (!pgs.drawers_postprocess.empty()) {
      // postprocess処理があるならば、その最初の処理のフレームバッファ
      // に書き込む
      glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
      glBindFramebuffer(GL_FRAMEBUFFER,
	pgs.drawers[pgs.drawers_postprocess[0]]
	  ->get_postprocess_framebuffer(draw_step_postprocess));
      glViewport(0, 0, static_cast{GLsizei}(pgs.cam.virt_width),
	static_cast{GLsizei}(pgs.cam.virt_height));
    } else {
      // postprocess処理が無いので既定のフレームバッファに書き込む
      glViewport(0, 0, static_cast{GLsizei}(pgs.cam.display_width),
	static_cast{GLsizei}(pgs.cam.display_height));
    }
    /* clear depth buffer */
    {
      glEnable(GL_DEPTH_TEST);
      glDepthFunc(GL_LESS);
      glDepthMask(1);
      glDisable(GL_BLEND);
      glClear(GL_DEPTH_BUFFER_BIT);
    }
    /* z-prepass shader */
    if (pgs.glc.enable_zprepass) {
      glDisable(GL_CULL_FACE);
      // glCullFace(GL_BACK);
      glColorMask(0, 0, 0, 0);
      for (const i, const& pd: pgs.drawers) {
	const vert_vbid = pgs.drawer_vertices_vbids[i];
	const inst_vbid = pgs.drawer_instances_vbids[i];
	pd->draw(draw_step_zprepass, 0,
	  *bos[vert_vbid],
	  whole_instances[inst_vbid], pgs.agg_ibuffer,
	  inst_vbid, pgs.glc, cam_df, smtex_arr);
      }
    }
    tick2 = SDL_GetTicks();
    /* solid */
    {
      glDisable(GL_BLEND);
      glEnable(GL_CULL_FACE);
      // glDisable(GL_CULL_FACE);
      glCullFace(GL_BACK);
      glEnable(GL_DEPTH_TEST);
      if (pgs.glc.enable_zprepass) {
	// glDepthMask(0); // TODO: disable depth mask
	glDepthFunc(GL_LEQUAL);
      } else {
	glDepthFunc(GL_LESS);
      }
      glColorMask(1, 1, 1, 1);
      for (const i, const& pd: pgs.drawers) {
	const vert_vbid = pgs.drawer_vertices_vbids[i];
	const inst_vbid = pgs.drawer_instances_vbids[i];
	// debug_log("solid drawer vert_vbid", vert_vbid, "inst_vbid",
	//   inst_vbid);
	pd->draw(draw_step_solid, 0,
	  *bos[vert_vbid],
	  whole_instances[inst_vbid], pgs.agg_ibuffer,
	  inst_vbid, pgs.glc, cam_df, smtex_arr);
      }
    }
    /* blend */
    {
      glDisable(GL_CULL_FACE);
      glEnable(GL_DEPTH_TEST);
      glDepthFunc(GL_LEQUAL);
      glDepthMask(0);
      glEnable(GL_BLEND);
      glBlendFunc(GL_ONE, GL_ONE);
      for (const i, const& pd: pgs.drawers) {
	const vert_vbid = pgs.drawer_vertices_vbids[i];
	const inst_vbid = pgs.drawer_instances_vbids[i];
	pd->draw(draw_step_blend, 0,
	  *bos[vert_vbid],
	  whole_instances[inst_vbid], pgs.agg_ibuffer,
	  inst_vbid, pgs.glc, cam_df, smtex_arr);
      }
    }
  }
  if (!pgs.drawers_postprocess.empty()) {
    size_t n = pgs.drawers_postprocess.size();
    size_t i = 0;
    if (lastpass) {
      i = n - 1;
    }
    for (; i < n; ++i) {
      uint fb = static_cast{uint}(saved_fb);
      if (i < n - 1) {
	fb = pgs.drawers[pgs.drawers_postprocess[i + 1]]
	  ->get_postprocess_framebuffer(draw_step_postprocess);
      } else {
	glViewport(0, 0, static_cast{GLsizei}(pgs.cam.display_width),
	  static_cast{GLsizei}(pgs.cam.display_height));
      }
      glBindFramebuffer(GL_FRAMEBUFFER, fb);
      const j = pgs.drawers_postprocess[i];
      const& pd = pgs.drawers[j];
      const vert_vbid = pgs.drawer_vertices_vbids[j];
      const inst_vbid = pgs.drawer_instances_vbids[j];
      pd->draw(draw_step_postprocess, 0,
	*bos[vert_vbid],
	whole_instances[inst_vbid], pgs.agg_ibuffer,
	inst_vbid, pgs.glc, cam_df, smtex_arr);
    }
  }
  /* hud */
  {
    glDisable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDepthMask(0);
    glEnable(GL_BLEND);
    glBlendFunc(GL_ONE, GL_ONE);
    for (const i, const& pd: pgs.drawers) {
      const vert_vbid = pgs.drawer_vertices_vbids[i];
      const inst_vbid = pgs.drawer_instances_vbids[i];
      pd->draw(draw_step_hud, 0,
	*bos[vert_vbid],
	whole_instances[inst_vbid], pgs.agg_ibuffer,
	inst_vbid, pgs.glc, cam_df, smtex_arr);
    }
  }
  if (false) {
    // FIXME: debug ext_display
    mutable& buf = *(pgs.debug_ext_display);
    const w = static_cast{GLsizei}(pgs.cam.display_width);
    const h = static_cast{GLsizei}(pgs.cam.display_height);
    if (static_cast{GLsizei}(buf.size()) < w * h * 4) {
      buf.resize(static_cast{size_t}(w * h * 4), 0u);
    }
    glReadPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE,
      buf.to_rawptr().to_voidptr());
    // debug_log("debug ext_display");
  }
  return make_varray{uint}(tick1, tick2);
}

/* private */

private function tree_map{string, size_t}
get_drawer_names(varray{ptr{pgldrawer_export_i}} const& drawers)
{
  tree_map{string, size_t} r;
  for (const i: 0 .. drawers.size()) {
    const e = pointer_downcast{ptr{pgldrawer_i}}(drawers[i]);
    const k = e->get_vbid_name();
    r[k] = i;
  }
  return r;
}

private function varray{ptr{pgldrawer_i}}
downcast_drawers(varray{ptr{pgldrawer_export_i}} const& drawers)
{
  varray{ptr{pgldrawer_i}} r;
  for (const i, const& e: drawers) {
    r.push_back(pointer_downcast{ptr{pgldrawer_i}}(e));
  }
  return r;
}

private threaded struct
build_context_impl(varray{ptr{vertices}} mutable& vptrs0,
  varray{dgf_filler} mutable& fillers0)
  <build_context_i>
{
  public varray{ptr{vertices}} vptrs;
  public varray{dgf_filler} fillers;
  vptrs.swap(vptrs0);
  fillers.swap(fillers0);
  function void fill(bool flat_flag, bool polyjoint, size_t n,
    string const& joint_name, poly_t const& poly, mesh_index const& mp) const
  {
    if (joint_name.empty()) {
      // debug_log("fill n=", n);
      fillers[n](flat_flag, poly, mp);
    } else if (polyjoint) {
      // debug_log("polyjoint n=", joint_name);
      for (const i, const& vptr: vptrs) {
	dgf_poly_joint_internal(vptr, joint_name, poly, mp);
      }
    } else {
      // debug_log("pointjoint n=", joint_name);
      for (const i, const& vptr: vptrs) {
	dgf_point_joint_internal(vptr, joint_name, poly, mp);
      }
    }
  }
}

private threaded function void
dgf_poly_joint_internal(ptr{vertices} const& vptr, string const& joint_name,
  poly_t const& poly, mesh_index const& mp)
{
  // calculates normal/tangent from poly
  if (poly.size() < 1) { return; }
  node_joint e;
  e.trans = poly_trans(poly);
  e.joint_name = joint_name;
  vptr->push_joint(e);
}

private threaded function void
dgf_point_joint_internal(ptr{vertices} const& vptr, string const& joint_name,
  poly_t const& poly, mesh_index const& mp)
{
  if (poly.size() < 1) { return; }
  const p = poly[0].pos;
  const ex = poly[0].nor.normalize();
  const ey = poly[0].tan.normalize();
  const ez = glm::cross(ex, ey);
  node_joint e;
  e.trans = glm::make_mat4(
    ex.x, ex.y, ex.z,  0.0,
    ey.x, ey.y, ey.z,  0.0,
    ez.x, ez.y, ez.z,  0.0,
     p.x,  p.y,  p.z,  1.0);
  e.joint_name = joint_name;
  vptr->push_joint(e);
}

function void
update_mvp(shader_config const& glc, projection_info mutable& cam)
{
  float const perspective_near =
    glc.conf.get("perspective_near", 1.0f, 0.001f, 100.0f);
  float const perspective_far =
    glc.conf.get("perspective_far", 10000.0f, 10.0f, 1000000.0f);
  float const perspective_wh =
    glc.conf.get("perspective_wh", 1.0f, 0.001f, 100.0f);
  const ssbase = max(cam.virt_height, cam.virt_width);
  const h = perspective_wh * cast_float(cam.virt_height)
    / cast_float(ssbase);
  const w = perspective_wh * cast_float(cam.virt_width)
    / cast_float(ssbase);
  glViewport(0, 0, static_cast{GLsizei}(cam.virt_width),
    static_cast{GLsizei}(cam.virt_height));
  glDepthMask(1);
  glColorMask(1, 1, 1, 1);
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  {
    // camera projection
    const near = perspective_near;
    const far = perspective_far;
    const left = cast_float(-w);
    const right = cast_float(w);
    const bottom = cast_float(-h);
    const top = cast_float(h);
    cam.camera_pers.near = near;
    cam.camera_pers.far = far;
    cam.camera_pers.width = w;
    cam.camera_pers.height = h;
    cam.projection = glm::frustum{float}(left, right, bottom, top, near, far);
  }
  {
    // shadowmap projection
    const sm_w = 1.0f;
    const sm_h = 1.0f;
    function void set_sm(glm::mat4 mutable& dst, float di)
    {
      // const far = di;
      // const near = -di;
      const far = di * 1.0f;
      const near = di * -1.0f;
      const left = -di;
      const right = di;
      const bottom = -di;
      const top = di;
      dst = glm::ortho{float}(left, right, bottom, top, near, far);
    }
    float far = glc.shadowmap_distance;
    for (const i: 0 .. static_cast{size_t}(glc.num_shadowmaps)) {
      set_sm(cam.sm_projection[i], far);
      far *= glc.shadowmap_scale;
    }
    // debug_log("smp0", cam.sm_projection[0].to_cslice());
    // debug_log("smp1", cam.sm_projection[1].to_cslice());
  }
}

