public threaded namespace pgl3d::texture::editable_voxel "use-unsafe";
public import common -;
public import meta m;
public import glm -;
public import sdl2::api_types -;
public import text::serialize::compact_pod -;
public import pgl3d::texture::texture -;
public import pgl3d::texture::voxel -;
public import pgl3d::engine::util -;
public import pgl3d::sdl::sdlutil -;
public import pointer::tfuncptr -;

public metafunction texture_reshaped array3_pot{varray{uint}, 0};
  // TODO: test reshape
public metafunction texture_dist_dirty array3_pot{varray{uchar}, 0};
public metafunction texture_data_mip varray{texture_reshaped};

public tsvaluetype enum texture_value_index_e
{
  texture_value_index_primary = 0,
  texture_value_index_secondary = 1,
}

public multithreaded struct modified_range
{
  private uvec3 merged_modified_pos;
  private uvec3 merged_modified_sz;
  private varray{pair{ivec3, ivec3}} modified_arr;
  public function pair{uvec3, uvec3} get_modified_merged(bool reset_flag)
  {
    const r = pair{uvec3, uvec3}(merged_modified_pos, merged_modified_sz);
    if (reset_flag) {
      reset();
    }
    return r;
  }
  public function varray{pair{ivec3, ivec3}}
  get_modified_array(bool reset_flag)
  {
    const r = modified_arr;
    if (reset_flag) {
      reset();
    }
    return r;
  }
  private function void reset()
  {
    merged_modified_pos = uvec3();
    merged_modified_sz = uvec3();
    modified_arr.clear();
  }
  public function void set_modified(ivec3 mi, ivec3 mx)
  {
    modified_arr.push_back(pair(mi, mx));
    if (merged_modified_sz.x != 0) {
      mi = map{ivec3, min}(to_ivec3(merged_modified_pos), mi);
      mx = map{ivec3, max}(
        to_ivec3(
          merged_modified_pos +
          merged_modified_sz -
          make_uvec3(1, 1, 1)),
        mx);
    }
    merged_modified_pos = to_uvec3(mi);
    merged_modified_sz = to_uvec3(mx + make_ivec3(1, 1, 1) - mi);
  }
}

private threaded function uint
merge_mode_f_opaque(uint ov, uint v)
{
  return v;
}

private threaded function uint
merge_mode_f_or_ori(uint ov, uint v)
{
  return is_space_voxel(ov) ? v : ov;
}

public metafunction merge_mode
pointer::tfuncptr::tfuncptr_matching_function{merge_mode_f_opaque};
public metafunction merge_mode_opaque
pointer::tfuncptr::make_tfuncptr{merge_mode_f_opaque};
public metafunction merge_mode_or_ori
pointer::tfuncptr::make_tfuncptr{merge_mode_f_or_ori};

public multithreaded struct
texture_edit()
{
  /* 更新可能なボクセルデータのテクスチャを保持するクラス。更新されたら
   * raycast用の「埋め込み距離」を再計算する。*/
  public texture_data_mip data_pri;
  public texture_data_mip data_sec;
  public texture_data grid;
  public uvec3 data_size;
  public uvec3 grid_size = make_uvec3(1u, 1u, 1u);
    // タイルパターンのときのグリッドサイズを指定する。
    // タイルマップのときは(1,1,1)にする。
  private texture_data grid_work;
  private modified_range modified;
  public function pair{uvec3, uvec3} get_modified_merged(bool reset_flag)
  {
    return modified.get_modified_merged(reset_flag);
  }
  public function varray{pair{ivec3, ivec3}}
  get_modified_array(bool reset_flag)
  {
    return modified.get_modified_array(reset_flag);
  }
  public function uint get_mip(uvec3 pos, texture_value_index_e idx,
    size_t miplevel)
  {
    if (miplevel >= data_pri.size()) {
      miplevel = data_pri.size() - 1;
    }
    if (!lt_all_uvec3(pos, data_size)) {
      return 0u;
    }
    pos.x >>= static_cast{uint}(miplevel);
    pos.y >>= static_cast{uint}(miplevel);
    pos.z >>= static_cast{uint}(miplevel);
    if (idx == texture_value_index_primary) {
      return data_pri[miplevel].get(pos.x, pos.y, pos.z);
    } else {
      return data_sec[miplevel].get(pos.x, pos.y, pos.z);
    }
  }
  public function uint get(uvec3 const& pos, texture_value_index_e idx)
  {
    return get_mip(pos, idx, 0u);
  }
  private function void set_space_mip(size_t miplevel, uvec3 const& pos)
  {
    data_pri[miplevel].set(pos.x, pos.y, pos.z, 0u);
    if (miplevel + 1 >= data_pri.size()) {
      return;
    }
    const p2 = make_uvec3((pos.x / 2) * 2, (pos.y / 2) * 2, (pos.z / 2) * 2);
    bool is_space = true;
    for (const z: 0 .. 2u) {
      for (const y: 0 .. 2u) {
        for (const x: 0 .. 2u) {
          const v = data_pri[miplevel].get(p2.x + x, p2.y + y, p2.z + z);
          is_space &= is_space_voxel(v);
        }
      }
    }
    if (is_space) {
      const p = make_uvec3(pos.x / 2, pos.y / 2, pos.z / 2);
      set_space_mip(miplevel + 1, p);
    }
  }
  public function void set(uvec3 const& pos, texture_value_index_e idx, uint v)
  {
    if (!lt_all_uvec3(pos, data_size)) {
      return;
    }
    // debug_log("texture_edit set", pos);
    v = (idx == texture_value_index_primary && is_space_voxel(v)) ? 0u : v;
    if (idx == texture_value_index_primary) {
      if (v == 0) {
        // 空白にする。mipmapも必要なら更新する
        set_space_mip(0, pos);
      } else {
        data_pri[0].set(pos.x, pos.y, pos.z, v);
      }
    } else {
      data_sec[0].set(pos.x, pos.y, pos.z, v);
    }
    if (idx == texture_value_index_primary) {
      recalc_distance_range(pos, make_uvec3(1, 1, 1), v == 0);
    }
  }
  public function void fill_range(uvec3 const& dpos, uvec3 const& sz,
    uint v_pri, uint v_sec)
  {
    if (!lt_all_uvec3(dpos, data_size)) {
      return;
    }
    v_pri = is_space_voxel(v_pri) ? 0u : v_pri;
    v_sec = is_space_voxel(v_pri) ? 0u : v_sec;
    texture_data_fill_range(data_pri[0], dpos, sz, v_pri);
    texture_data_fill_range(data_sec[0], dpos, sz, v_sec);
    debug_log("fill_range", dpos, sz);
    recalc_distance_range(dpos, sz, v_pri == 0u);
  }
  public function {t} void copy_range(uvec3 const& spos, uvec3 sz,
    t mutable& dest, t mutable& dest_aux, uvec3 const& dpos) const
  {
    sz = clamp_size(data_pri[0], spos, sz);
    sz = clamp_size(dest, dpos, sz);
    if (empty_range(sz)) {
      return;
    }
    debug_log("copy_range", spos, sz, dpos);
    texture_data_copy_range(dest, dpos, data_pri[0], spos, sz);
    texture_data_copy_range(dest_aux, dpos, data_sec[0], spos, sz);
  }
  public function {t} void paste_range(uvec3 const& dpos, uvec3 sz,
    t const& src, t const& src_aux, uvec3 const& spos, uint index_mask,
    merge_mode const& mmod)
  {
    sz = clamp_size(src, spos, sz);
    sz = clamp_size(data_pri[0], dpos, sz);
    if (empty_range(sz)) {
      return;
    }
    // debug_log("paste_range", spos, sz, dpos);
    bool shape_modified = false;
    if ((index_mask & 1u) != 0) {
      // pri
      shape_modified = texture_data_copy_range_check_modified(data_pri[0],
	dpos, src, spos, sz, mmod);
    }
    if ((index_mask & 2u) != 0) {
      // sec
      texture_data_copy_range_secondary(data_pri[0], data_sec[0], dpos,
	src_aux, spos, sz);
    }
    if (shape_modified) {
      recalc_distance_range(dpos, sz, false);
    } else {
      modified.set_modified(to_ivec3(dpos),
	to_ivec3(dpos + sz - make_uvec3(1, 1, 1)));
    }
  }
  private function void recalc_distance_range(uvec3 const& pos,
    uvec3 const& sz, bool clear_flag)
  {
    /* 領域の更新に伴う距離の更新をおこなう。領域が全て空白になったと
     * わかっている場合はclear_flagを真にしてよい。*/
    // debug_log("recalc_distance_range", pos, sz, clear_flag);
    ivec3 mod_mi = to_ivec3(pos);
    ivec3 mod_mx = mod_mi + to_ivec3(sz) - make_ivec3(1, 1, 1);
    if (grid_size.x == 1) {
      // debug_log("recalc_distance_range nogrid", mod_mi, mod_mx); // FIXME
      if (clear_flag) {
        /* 遅すぎるので更新しない。うまい実装があるか? */
        /* update_distance(true, data_pri[0], mod_mi, mod_mx, clear_flag); */
        modified.set_modified(mod_mi, mod_mx);
      } else {
        update_distance(true, data_pri[0], mod_mi, mod_mx, clear_flag);
        modified.set_modified(mod_mi, mod_mx);
      }
    } else {
      // debug_log("recalc_distance_range grid");
      if (grid_work.get_width_l2() == 0u) {
	grid_work.set_size_l2(
	  integral_log2(grid_size.x), 
	  integral_log2(grid_size.y), 
	  integral_log2(grid_size.z));
      }
      ivec3 mod_mi_g = map{ivec3, operator::div}(mod_mi, to_ivec3(grid_size));
      ivec3 mod_mx_g = map{ivec3, operator::div}(mod_mx, to_ivec3(grid_size));
      for (const z: mod_mi_g.z .. mod_mx_g.z + 1) {
	for (const y: mod_mi_g.y .. mod_mx_g.y + 1) {
	  for (const x: mod_mi_g.x .. mod_mx_g.x + 1) {
	    const p = map{uvec3, operator::mul}(
	      make_uvec3(ui(x), ui(y), ui(z)),
	      grid_size);
	    // debug_log("recalc_distance_range grid", x, y, z);
	    texture_data_copy_range(grid_work, uvec3(), data_pri[0], p,
	      grid_size);
	    set_distance(true, grid_work);
	    texture_data_copy_range(data_pri[0], p, grid_work, uvec3(),
	      grid_size);
	  }
	}
      }
      modified.set_modified(
	map{ivec3, operator::mul}(mod_mi_g, to_ivec3(grid_size)),
	map{ivec3, operator::mul}(mod_mx_g + make_ivec3(1, 1, 1),
	  to_ivec3(grid_size))
	- make_ivec3(1, 1, 1));
    }
  }
}

public multithreaded struct
texture_update()
{
  // テクスチャ更新の情報をスレッド越しに渡すための構造体。詳細後でつめる。
  public glm::uvec3 pos;
  public uint value;
}

public metafunction texture_updates varray{texture_update};

/* private */

metafunction ui static_cast{uint}; 
metafunction si static_cast{int}; 

private threaded function {t0, t1} bool texture_data_copy_range_check_modified(
  t0 mutable& dest,
  uvec3 const& dpos, t1 const& src, uvec3 const& spos,
  uvec3 const& sz, merge_mode const& mmod)
{
  bool modified = false;
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	const v = src.get(spos.x + x, spos.y + y, spos.z + z);
	const ov = dest.get(dpos.x + x, dpos.y + y, dpos.z + z);
        const nv = mmod(ov, v);
	modified |= (ov != nv);
	dest.set(dpos.x + x, dpos.y + y, dpos.z + z, nv);
      }
    }
  }
  return modified;
}

private threaded function {t0, t1} void texture_data_copy_range_secondary(
  t0 const& dest_pri, t0 mutable& dest_sec,
  uvec3 const& dpos, t1 const& src_sec, uvec3 const& spos,
  uvec3 const& sz)
{
  for (uint z: 0 .. sz.z) {
    for (uint y: 0 .. sz.y) {
      for (uint x: 0 .. sz.x) {
	const ov = dest_pri.get(dpos.x + x, dpos.y + y, dpos.z + z);
	if (is_space_voxel(ov) || is_node_reference(ov)) {
	  continue;
	}
	const v = src_sec.get(spos.x + x, spos.y + y, spos.z + z);
	dest_sec.set(dpos.x + x, dpos.y + y, dpos.z + z, v);
      }
    }
  }
}

// vecutil.px
private threaded function bool lt_all_uvec3(uvec3 const& a, uvec3 const& b)
{
  return map{monoid_and{bool}, operator::lt}(a, b);
  // return a.x < b.x && a.y < b.y && a.z < b.z;
}

// vecutil.px
private threaded function bool le_all_uvec3(uvec3 const& a, uvec3 const& b)
{
  return map{monoid_and{bool}, operator::le}(a, b);
  // return a.x <= b.x && a.y <= b.y && a.z <= b.z;
}

private threaded function bool empty_range(uvec3 const& a)
{
  return a.x == 0 || a.y == 0 || a.z == 0;
}

private threaded function {t} uvec3
clamp_size(t const& data, uvec3 const& pos, uvec3 const& sz)
{
  const tsz = data.get_size_uvec3();
  if (!lt_all_uvec3(pos, tsz)) {
    return uvec3();
  }
  const trem = tsz - pos;
  return map{uvec3, min}(trem, sz);
}

