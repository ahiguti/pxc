public threaded namespace pgl3d::texture::generator;
public import common -;
public import numeric::fpmath -;
public import pgl3d::numeric::interpolation -;
public import pgl3d::texture::texture -;
public import pgl3d::engine::util -;
public import glm -;
public import meta m;

metafunction enable_dbg 0;

metafunction dbg m::cond{enable_dbg, debug_log, no_operation};

metafunction ui static_cast{uint};
metafunction si static_cast{int};

public function {t} void
generate_rand_spline(ptr{rand_generator} const& rndp,
  t mutable& tex, uvec3 const& texsz, int split, float thr_param)
{
  function ptr{cubic_b_spline} gen_spline(float center, float scale)
  {
    int rnd_rep = 2; // 大きいと正規分布に近づく
    varray{float} points;
    points.push_back(-3.0f);
    points.push_back(0.0f);
    for (int i: 2 .. split - 1) {
      float v;
      for (int j: 0 .. rnd_rep) {
        v += static_cast{float}(rndp->generate())
          / static_cast{float}(0x80000000u);
      }
      v /= static_cast{float}(rnd_rep);
      float ia = static_cast{float}(i * 2 - split) / static_cast{float}(split);
      ia = ia - center;
      // ia = center + ia;
      ia = 1.0f - ia * ia;
      v *= ia * scale;
      points.push_back(v);
    }
    points.push_back(0.0f);
    points.push_back(-3.0f);
    float step = 2.0f / static_cast{float}(split);
    dbg("gen_spline", points, "step=", step);
    return make_ptr{cubic_b_spline}(points, -1.0f, step);
  }
  const sx = gen_spline(0.8f, 1.0f);
  const sy = gen_spline(0.2f, 1.0f);
  const sz = gen_spline(0.0f, 1.0f);
  // const st = gen_spline(0.3f);
  int xsz = static_cast{int}(texsz.x);
  int ysz = static_cast{int}(texsz.y);
  int zsz = static_cast{int}(texsz.z);
  varray{float} buf;
  buf.resize(static_cast{size_t}(xsz * ysz * zsz), 0.0f);
  function void set(int x, int y, int z, float v)
  {
    if (x >= xsz || y >= ysz || z >= zsz ||
        x < 0 || y < 0 || z < 0) {
      dbg("invalid index: ", x, y, z);
      return;
    }
    buf[static_cast{size_t}((z * ysz + y) * xsz + x)] = v;
  }
  function float get(int x, int y, int z)
  {
    if (x >= xsz || y >= ysz || z >= zsz ||
        x < 0 || y < 0 || z < 0) {
      dbg("invalid index: ", x, y, z);
      return 0.0f;
    }
    return buf[static_cast{size_t}((z * ysz + y) * xsz + x)];
  }
  float mi = +99999.0f;
  float mx = -99999.0f;
  for (int z: 0 .. zsz) {
    for (int y: 0 .. ysz) {
      for (int x: 0 .. xsz) {
        float xf = xsz == 1 ? 0.0f :
          static_cast{float}(x * 2 - xsz + 1)
          / static_cast{float}(xsz - 1);
        float yf = ysz == 1 ? 0.0f :
          static_cast{float}(y * 2 - ysz + 1)
          / static_cast{float}(ysz - 1);
        float zf = zsz == 1 ? 0.0f :
          static_cast{float}(z * 2 - zsz + 1)
          / static_cast{float}(zsz - 1);
        dbg("z=", z, "zf=", zf, "pz=", (*sz)(zf));
        float v = 0.0f;
        v += ((*sx)(xf) + (*sx)(-xf)) * 0.5f; // * (0.5f + xf * xf * 0.5f);
        v += (*sy)(yf); // * (0.2f + yf * yf * 0.5f);
        v += (*sz)(zf); // * (0.2f + zf * zf * 0.5f);
        // v += (((zf*0.2f+0.1f)*yf*0.3f+0.1f)*zf+0.2f)*yf+0.2f;
        /*
        v *= smooth_bump(xf * 0.6);
        v *= smooth_bump(yf * 0.6);
        v *= smooth_bump(zf * 0.6);
          */
        set(x, y, z, v);
        mi = min(mi, v);
        mx = max(mx, v);
        // dbg(xf, yf, zf, v, smooth_bump(xf * 2.5));
      }
    }
  }
  dbg("min", mi, "max", mx);
  mi = max(mi, 0.0f);
  dbg("min", mi, "max", mx);
  /*
  for (int z: 0 .. zsz) {
    for (int y: 0 .. ysz) {
      for (int x: 0 .. xsz) {
        float v = get(x, y, z);
        tex.set(ui(x), ui(y), ui(z), v > th ? 1u : 0u);
      }
    }
  }
  */
  for (int z: 0 .. zsz) {
    dbg("z=", z);
    for (int y: 0 .. ysz) {
      string s = "[";
      for (int x: 0 .. xsz) {
        float xf = xsz == 1 ? 0.0f :
          static_cast{float}(x * 2 - xsz + 1)
          / static_cast{float}(xsz - 1);
        float yf = ysz == 1 ? 0.0f :
          static_cast{float}(y * 2 - ysz + 1)
          / static_cast{float}(ysz - 1);
        float zf = zsz == 1 ? 0.0f :
          static_cast{float}(z * 2 - zsz + 1)
          / static_cast{float}(zsz - 1);
        float v = get(x, y, z);
        float rat = 0.5f + thr_coefficient(xf, yf, zf) * 0.5f;
        // float rat = 1.0f - ((*st)(xf) + (*st)(yf) + (*st)(zf)) * 0.5f;
        rat += thr_param;
        rat = min(max(rat, 0.0), 1.0);
        float th = mi * (1.0f - rat) + mx * rat;
        if (v > th) {
          tex.set(ui(x), ui(y), ui(z), 1u);
          s += "*";
        } else {
          tex.set(ui(x), ui(y), ui(z), 0u);
          s += " ";
        }
      }
      s += "]";
      dbg(s);
    }
  }
}

private function float smooth_bump(float x)
{
  float d = 1.0f - x * x;
  if (d <= 0.0f) {
    return 0.0f;
  }
  float v = exp(-1.0f / d);
  return v;
}

private function float thr_coefficient(float x, float y, float z)
{
  float v = max(max(fabs(x), fabs(y)), fabs(z));
  // float v = fabs(x) + fabs(y) + fabs(z);
  v = min(v, 1.0);
  return pow(x, 2.0f);
}

