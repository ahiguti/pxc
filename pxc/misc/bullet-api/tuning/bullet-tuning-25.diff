diff -bur bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btBroadphaseProxy.h ../bullet/src/BulletCollision/BroadphaseCollision/btBroadphaseProxy.h
--- bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btBroadphaseProxy.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/BroadphaseCollision/btBroadphaseProxy.h	2015-08-18 13:32:46.000000000 +0900
@@ -20,6 +20,9 @@
 #include "LinearMath/btVector3.h"
 #include "LinearMath/btAlignedAllocator.h"
 
+#include <array>
+
+#define BT_DISPATCHER_NUM_THREADS 3
 
 /// btDispatcher uses these types
 /// IMPORTANT NOTE:The types are ordered polyhedral, implicit convex and concave
@@ -190,6 +193,7 @@
 	m_pProxy0(0),
 		m_pProxy1(0),
 		m_algorithm(0),
+		m_curThreadId(-1),
 		m_internalInfo1(0)
 	{
 	}
@@ -200,6 +204,7 @@
 		:		m_pProxy0(other.m_pProxy0),
 				m_pProxy1(other.m_pProxy1),
 				m_algorithm(other.m_algorithm),
+				m_curThreadId(-1),
 				m_internalInfo1(other.m_internalInfo1)
 	{
 	}
@@ -227,6 +232,7 @@
 	btBroadphaseProxy* m_pProxy1;
 	
 	mutable btCollisionAlgorithm* m_algorithm;
+	int m_curThreadId;
 	union { void* m_internalInfo1; int m_internalTmpValue;};//don't use this data, it will be removed in future version.
 
 };
diff -bur bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h ../bullet/src/BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h
--- bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h	2015-08-18 12:56:53.000000000 +0900
@@ -36,13 +36,13 @@
 		m_manifold(0)
 	{
 	}
-	btCollisionAlgorithmConstructionInfo(btDispatcher* dispatcher,int temp)
+	btCollisionAlgorithmConstructionInfo(volatile btDispatcher* dispatcher,int temp)
 		:m_dispatcher1(dispatcher)
 	{
 		(void)temp;
 	}
 
-	btDispatcher*	m_dispatcher1;
+	volatile btDispatcher*	m_dispatcher1;
 	btPersistentManifold*	m_manifold;
 
 //	int	getDispatcherId();
@@ -57,7 +57,7 @@
 
 protected:
 
-	btDispatcher*	m_dispatcher;
+	volatile btDispatcher*	m_dispatcher;
 
 protected:
 //	int	getDispatcherId();
diff -bur bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btDbvtBroadphase.cpp ../bullet/src/BulletCollision/BroadphaseCollision/btDbvtBroadphase.cpp
--- bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btDbvtBroadphase.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/BroadphaseCollision/btDbvtBroadphase.cpp	2015-08-18 12:56:53.000000000 +0900
@@ -433,7 +433,7 @@
 		btBroadphasePair previousPair;
 		previousPair.m_pProxy0 = 0;
 		previousPair.m_pProxy1 = 0;
-		previousPair.m_algorithm = 0;
+		previousPair.m_algorithm = { };
 		
 		
 		for (i=0;i<overlappingPairArray.size();i++)
diff -bur bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btDispatcher.h ../bullet/src/BulletCollision/BroadphaseCollision/btDispatcher.h
--- bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btDispatcher.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/BroadphaseCollision/btDispatcher.h	2015-08-18 14:34:49.000000000 +0900
@@ -46,7 +46,8 @@
 		m_useEpa(true),
 		m_allowedCcdPenetration(btScalar(0.04)),
 		m_useConvexConservativeDistanceUtil(false),
-		m_convexConservativeDistanceThreshold(0.0f)
+		m_convexConservativeDistanceThreshold(0.0f),
+		m_curThread(0)
 	{
 
 	}
@@ -62,6 +63,7 @@
 	btScalar	m_allowedCcdPenetration;
 	bool		m_useConvexConservativeDistanceUtil;
 	btScalar	m_convexConservativeDistanceThreshold;
+	int		m_curThread;
 };
 
 ///The btDispatcher interface class can be used in combination with broadphase to dispatch calculations for overlapping pairs.
@@ -73,15 +75,15 @@
 public:
 	virtual ~btDispatcher() ;
 
-	virtual btCollisionAlgorithm* findAlgorithm(const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,btPersistentManifold* sharedManifold=0) = 0;
+	virtual btCollisionAlgorithm* findAlgorithm(const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,btPersistentManifold* sharedManifold=0) volatile = 0;
 
-	virtual btPersistentManifold*	getNewManifold(const btCollisionObject* b0,const btCollisionObject* b1)=0;
+	virtual btPersistentManifold*	getNewManifold(const btCollisionObject* b0,const btCollisionObject* b1) volatile = 0;
 
-	virtual void releaseManifold(btPersistentManifold* manifold)=0;
+	virtual void releaseManifold(btPersistentManifold* manifold) volatile = 0;
 
-	virtual void clearManifold(btPersistentManifold* manifold)=0;
+	virtual void clearManifold(btPersistentManifold* manifold) volatile = 0;
 
-	virtual bool	needsCollision(const btCollisionObject* body0,const btCollisionObject* body1) = 0;
+	virtual bool	needsCollision(const btCollisionObject* body0,const btCollisionObject* body1) volatile = 0;
 
 	virtual bool	needsResponse(const btCollisionObject* body0,const btCollisionObject* body1)=0;
 
@@ -97,9 +99,9 @@
 
 	virtual	const btPoolAllocator*	getInternalManifoldPool() const = 0;
 
-	virtual	void* allocateCollisionAlgorithm(int size)  = 0;
+	virtual	void* allocateCollisionAlgorithm(int size) volatile = 0;
 
-	virtual	void freeCollisionAlgorithm(void* ptr) = 0;
+	virtual	void freeCollisionAlgorithm(void* ptr) volatile = 0;
 
 };
 
diff -bur bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btOverlappingPairCache.cpp ../bullet/src/BulletCollision/BroadphaseCollision/btOverlappingPairCache.cpp
--- bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btOverlappingPairCache.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/BroadphaseCollision/btOverlappingPairCache.cpp	2015-09-04 05:06:23.000000000 +0900
@@ -286,6 +286,7 @@
 	btBroadphasePair* pair = internalFindPair(proxy0, proxy1, hash);
 	if (pair == NULL)
 	{
+//printf("rem notf %d %d\n", proxy0->m_uniqueId, proxy1->m_uniqueId);
 		return 0;
 	}
 
diff -bur bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btSimpleBroadphase.cpp ../bullet/src/BulletCollision/BroadphaseCollision/btSimpleBroadphase.cpp
--- bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btSimpleBroadphase.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/BroadphaseCollision/btSimpleBroadphase.cpp	2015-09-05 00:57:58.000000000 +0900
@@ -41,7 +41,11 @@
 btSimpleBroadphase::btSimpleBroadphase(int maxProxies, btOverlappingPairCache* overlappingPairCache)
 	:m_pairCache(overlappingPairCache),
 	m_ownsPairCache(false),
-	m_invalidPair(0)
+	m_invalidPair(0),
+	m_splitLog2(5),
+	m_split(1U << m_splitLog2),
+	m_meshSize(5.0f),
+	m_meshSizeInv(1.0f / m_meshSize)
 {
 
 	if (!overlappingPairCache)
@@ -70,6 +74,8 @@
 	
 	}
 
+	m_posToFilling.resize(m_split * m_split * m_split, fillingNone());
+
 }
 
 btSimpleBroadphase::~btSimpleBroadphase()
@@ -212,6 +218,8 @@
 
 void	btSimpleBroadphase::calculateOverlappingPairs(btDispatcher* dispatcher)
 {
+	int aabbSizeCnt = 0;
+	btVector3 aabbSizeSum(0.0f, 0.0f, 0.0f);
 	//first check for new overlapping pairs
 	int i,j;
 	if (m_numHandles >= 0)
@@ -225,37 +233,77 @@
 				continue;
 			}
 			new_largest_index = i;
-			for (j=i+1; j <= m_LastHandleIndex; j++)
+			aabbSizeSum += proxy0->m_aabbMax;
+			aabbSizeSum -= proxy0->m_aabbMin;
+			aabbSizeCnt += 1;
+		}
+		// update mesh size
+		if (aabbSizeCnt > 0) {
+			m_meshSize = (aabbSizeSum[0] + aabbSizeSum[1] + aabbSizeSum[2]) / (aabbSizeCnt * 1);
+			m_meshSizeInv = 1.0f / m_meshSize;
+//printf("new mesh size %f %d\n", m_meshSize, aabbSizeCnt);
+		}
+		for (i=0; i <= new_largest_index; i++)
 			{
-				btSimpleBroadphaseProxy* proxy1 = &m_pHandles[j];
-				btAssert(proxy0 != proxy1);
-				if(!proxy1->m_clientObject)
+			btSimpleBroadphaseProxy* proxy0 = &m_pHandles[i];
+			if(!proxy0->m_clientObject)
 				{
 					continue;
 				}
-
-				btSimpleBroadphaseProxy* p0 = getSimpleProxyFromProxy(proxy0);
-				btSimpleBroadphaseProxy* p1 = getSimpleProxyFromProxy(proxy1);
-
-				if (aabbOverlap(p0,p1))
-				{
-					if ( !m_pairCache->findPair(proxy0,proxy1))
-					{
-						m_pairCache->addOverlappingPair(proxy0,proxy1);
-					}
-				} else
-				{
-					if (!m_pairCache->hasDeferredRemoval())
-					{
-						if ( m_pairCache->findPair(proxy0,proxy1))
-						{
-							m_pairCache->removeOverlappingPair(proxy0,proxy1,dispatcher);
+			addFilling(i, proxy0->m_aabbMin, proxy0->m_aabbMax);
 						}
+
+		pairsType::iterator iter;
+		for (iter = m_pairs.begin(); iter != m_pairs.end(); ++iter) {
+		  	iter->second = false;
+		}
+
+		size_t chkcnt = 0;
+		j = m_fillings.size();
+		while (j > 0) {
+		  	--j;
+		  	btFillingEntry const& jfilling = m_fillings[j];
+			unsigned jid = jfilling.m_colId;
+			btSimpleBroadphaseProxy *jproxy = &m_pHandles[jid];
+			unsigned k = jfilling.m_nextFilling;
+			while (k != fillingNone()) {
+			  	btFillingEntry const& kfilling = m_fillings[k];
+				unsigned kid = kfilling.m_colId;
+				btSimpleBroadphaseProxy *kproxy = &m_pHandles[kid];
+				++chkcnt;
+				if (aabbOverlap(jproxy, kproxy)) {
+				  	std::pair<int, int> key(jproxy->m_uniqueId, kproxy->m_uniqueId);
+					pairsType::iterator fi = m_pairs.find(key);
+					if (fi == m_pairs.end()) {
+						m_pairs.insert(std::make_pair(key, true));
+						m_pairCache->addOverlappingPair(jproxy, kproxy);
+						//printf("add %d %d\n", jproxy->m_uniqueId, kproxy->m_uniqueId);
+					} else {
+					  	fi->second = true;
+					}
+				}
+				k = kfilling.m_nextFilling;
 					}
 				}
+
+		iter = m_pairs.begin();
+		while (iter != m_pairs.end()) {
+		  	if (!iter->second) {
+			  	btSimpleBroadphaseProxy *base = (btSimpleBroadphaseProxy *)m_pHandlesRawPtr;
+			  	btSimpleBroadphaseProxy *proxy0 = base + iter->first.first - 2;
+			  	btSimpleBroadphaseProxy *proxy1 = base + iter->first.second - 2;
+				m_pairCache->removeOverlappingPair(proxy0, proxy1, dispatcher);
+				// printf("rem %d %d %d %d\n", iter->first.first, iter->first.second, proxy0->m_uniqueId, proxy1->m_uniqueId);
+			  	m_pairs.erase(iter++);
+			} else {
+			  	iter++;
 			}
 		}
 
+//		printf("fillings=%zu pairs=%zu cache=%zu chkcnt=%zu\n", m_fillings.size(), m_pairs.size(), m_pairCache->getOverlappingPairArray().size(), chkcnt);
+
+		clearFillings();
+
 		m_LastHandleIndex = new_largest_index;
 
 		if (m_ownsPairCache && m_pairCache->hasDeferredRemoval())
@@ -347,3 +395,60 @@
 {
 	//not yet
 }
+
+void btSimpleBroadphase::addFilling(unsigned colId, const btVector3& aabbMin, const btVector3& aabbMax)
+{
+  	unsigned x0 = quantizeGeom(aabbMin[0]);
+  	unsigned x1 = quantizeGeom(aabbMax[0]);
+	if (x1 - x0 >= m_split) {
+//printf("x0,x1,d %u %u %u\n", x0, x1, x1 - x0);
+		x1 = x0 + m_split - 1;
+	}
+	x0 &= splitMask();
+	x1 &= splitMask();
+  	unsigned y0 = quantizeGeom(aabbMin[1]);
+  	unsigned y1 = quantizeGeom(aabbMax[1]);
+	if (y1 - y0 >= m_split) {
+//printf("y0,y1,d %u %u %u\n", y0, y1, y1 - y0);
+		y1 = y0 + m_split - 1;
+	}
+	y0 &= splitMask();
+	y1 &= splitMask();
+  	unsigned z0 = quantizeGeom(aabbMin[2]);
+  	unsigned z1 = quantizeGeom(aabbMax[2]);
+	if (z1 - z0 >= m_split) {
+//printf("z0,z1,d %u %u %u\n", z0, z1, z1 - z0);
+		z1 = z0 + m_split - 1;
+	}
+	z0 &= splitMask();
+	z1 &= splitMask();
+	unsigned x = x0;
+	while (true) {
+		unsigned y = y0;
+		while (true) {
+			unsigned z = z0;
+			while (true) {
+			  	addFillingOne(colId,
+					(x << (m_splitLog2 + m_splitLog2)) +
+					(y << (m_splitLog2)) +
+					(z));
+				if (z == z1) { break; }
+				z = (z + 1) & splitMask();
+			}
+			if (y == y1) { break; }
+			y = (y + 1) & splitMask();
+		}
+		if (x == x1) { break; }
+		x = (x + 1) & splitMask();
+	}
+}
+
+void btSimpleBroadphase::clearFillings()
+{
+  	for (unsigned i = 0; i < m_fillings.size(); ++i) {
+	  	unsigned pos = m_fillings[i].m_pos;
+		m_posToFilling[pos] = fillingNone();
+	}
+	m_fillings.clear();
+}
+
diff -bur bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btSimpleBroadphase.h ../bullet/src/BulletCollision/BroadphaseCollision/btSimpleBroadphase.h
--- bullet3-2.83.5/src/BulletCollision/BroadphaseCollision/btSimpleBroadphase.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/BroadphaseCollision/btSimpleBroadphase.h	2015-09-04 15:47:32.000000000 +0900
@@ -19,6 +19,8 @@
 
 #include "btOverlappingPairCache.h"
 
+#include <vector>
+#include <map>
 
 struct btSimpleBroadphaseProxy : public btBroadphaseProxy
 {
@@ -60,6 +62,23 @@
 	void* m_pHandlesRawPtr;
 	int		m_firstFreeHandle;		// free handles list
 	
+	struct btFillingEntry {
+	  	unsigned	m_pos;
+		unsigned	m_nextFilling;
+		unsigned	m_colId;
+		btFillingEntry(unsigned pos0 = 0, unsigned nextFilling0 = static_cast<unsigned>(-1), unsigned colId0 = 0)
+		  	: m_pos(pos0), m_nextFilling(nextFilling0), m_colId(colId0) { }
+	};
+
+	std::vector<unsigned>	m_posToFilling;
+	std::vector<btFillingEntry>	m_fillings;
+	typedef std::map<std::pair<int, int>, bool> pairsType;
+	pairsType	m_pairs;
+	const unsigned	m_splitLog2;
+	const unsigned	m_split;
+	float	m_meshSize;
+	float	m_meshSizeInv;
+	
 	int allocHandle()
 	{
 		btAssert(m_numHandles < m_maxHandles);
@@ -114,6 +133,27 @@
 
 	void	validate();
 
+	static inline unsigned fillingNone() { return static_cast<unsigned>(-1); }
+
+	inline unsigned splitMask() const { return m_split - 1; }
+
+	inline void addFillingOne(unsigned colId, unsigned pos) {
+	  	unsigned fillingIndex = m_fillings.size();
+		unsigned next = m_posToFilling[pos];
+		m_posToFilling[pos] = fillingIndex;
+		m_fillings.emplace_back(pos, next, colId);
+	}
+
+	inline unsigned quantizeGeom(float val) {
+	  	float v = floor(val * m_meshSizeInv);
+		unsigned ri = static_cast<int>(v);
+		return ri;
+	}
+
+	void addFilling(unsigned colId, const btVector3& aabbMin, const btVector3& aabbMax);
+
+	void clearFillings();
+
 protected:
 
 
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCollisionCreateFunc.h ../bullet/src/BulletCollision/CollisionDispatch/btCollisionCreateFunc.h
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCollisionCreateFunc.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btCollisionCreateFunc.h	2015-08-18 14:41:18.000000000 +0900
@@ -16,12 +16,24 @@
 #ifndef BT_COLLISION_CREATE_FUNC
 #define BT_COLLISION_CREATE_FUNC
 
+#include <array>
+
 #include "LinearMath/btAlignedObjectArray.h"
 class btCollisionAlgorithm;
 class btCollisionObject;
 struct btCollisionObjectWrapper;
 struct btCollisionAlgorithmConstructionInfo;
 
+#define BT_DISPATCH_NUM_THREADS 3
+
+#include "BulletCollision/NarrowPhaseCollision/btVoronoiSimplexSolver.h"
+
+class btSimplexSolverInterface;
+class btConvexPenetrationDepthSolver;
+
+typedef std::array<btSimplexSolverInterface*,BT_DISPATCH_NUM_THREADS> btThrSimplexSolvers;
+typedef std::array<btConvexPenetrationDepthSolver*,BT_DISPATCH_NUM_THREADS> btThrPdSolvers;
+
 ///Used by the btCollisionDispatcher to register and create instances for btCollisionAlgorithm
 struct btCollisionAlgorithmCreateFunc
 {
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCollisionDispatcher.cpp ../bullet/src/BulletCollision/CollisionDispatch/btCollisionDispatcher.cpp
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCollisionDispatcher.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btCollisionDispatcher.cpp	2015-09-05 00:54:48.000000000 +0900
@@ -26,9 +26,53 @@
 #include "LinearMath/btPoolAllocator.h"
 #include "BulletCollision/CollisionDispatch/btCollisionConfiguration.h"
 #include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"
+#include "BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h"
 
 int gNumManifold = 0;
 
+#if defined(_MSC_VER)
+thread_local int tls_thread_id;
+#elif defined(__APPLE__)
+#include <TargetConditionals.h>
+#if TARGET_OS_IPHONE
+#define BT_USE_PTHREAD_GETSPECIFIC
+pthread_key_t tls_key;
+#else
+__thread int tls_thread_id;
+#endif
+#else
+__thread int tls_thread_id;
+#endif
+
+static void init_tls()
+{
+#ifdef BT_USE_PTHREAD_GETSPECIFIC
+    static bool initialized = false;
+    if (initialized) {
+        return;
+    }
+    pthread_key_create(&tls_key, nullptr);
+#endif
+}
+
+void set_tls_thread_id(int v)
+{
+#ifdef BT_USE_PTHREAD_GETSPECIFIC
+    pthread_setspecific(tls_key, (void *)v);
+#else
+    tls_thread_id = v;
+#endif
+}
+
+int get_tls_thread_id()
+{
+#ifdef BT_USE_PTHREAD_GETSPECIFIC
+    return (size_t)pthread_getspecific(tls_key);
+#else
+    return tls_thread_id;
+#endif
+}
+
 #ifdef BT_DEBUG
 #include <stdio.h>
 #endif
@@ -40,6 +84,8 @@
 {
 	int i;
 
+    init_tls();
+
 	setNearCallback(defaultNearCallback);
 	
 	m_collisionAlgorithmPoolAllocator = collisionConfiguration->getCollisionAlgorithmPool();
@@ -55,7 +101,44 @@
 		}
 	}
 	
+    set_tls_thread_id(0);
 	
+	int num_threads = BT_DISPATCHER_NUM_THREADS;
+printf("bullet collisiondispatch %d threads\n", num_threads);
+	m_perThreadData.resize(num_threads);
+	for (int k = 0; k < num_threads; ++k) {
+		auto& td = m_perThreadData[k];
+		auto p = new btDefaultCollisionConfiguration();
+		td.m_threadCC = p;
+#if 0
+		for (i=0;i<MAX_BROADPHASE_COLLISION_TYPES;i++)
+		{
+			for (int j=0;j<MAX_BROADPHASE_COLLISION_TYPES;j++)
+			{
+				td.m_threadDoubleDispatch[i][j] = p->getCollisionAlgorithmCreateFunc(i,j);
+			}
+		}
+#endif
+	}
+	m_workerInfo.resize(num_threads);
+	for (int k = 0; k < num_threads; ++k) {
+		std::thread thr([&](int id) {
+			this->workerThreadMain(id);
+		}, k);
+		m_workerThreads.push_back(std::move(thr));
+	}
+}
+
+btCollisionDispatcher::~btCollisionDispatcher()
+{
+	for (auto& thr: m_workerThreads) {
+		m_finished = true;
+		m_cond.notify_all();
+		thr.join();
+	}
+	for (auto& td: m_perThreadData) {
+		delete td.m_threadCC;
+	}
 }
 
 
@@ -64,12 +147,11 @@
 	m_doubleDispatch[proxyType0][proxyType1] = createFunc;
 }
 
-btCollisionDispatcher::~btCollisionDispatcher()
+btPersistentManifold*	btCollisionDispatcher::getNewManifold(const btCollisionObject* body0,const btCollisionObject* body1) volatile
 {
-}
+	btCollisionDispatcher *const locked_this = const_cast<btCollisionDispatcher *>(this);
+	std::lock_guard<std::mutex> grd(locked_this->m_mutex);
 
-btPersistentManifold*	btCollisionDispatcher::getNewManifold(const btCollisionObject* body0,const btCollisionObject* body1) 
-{ 
 	gNumManifold++;
 	
 	//btAssert(gNumManifold < 65535);
@@ -78,7 +160,7 @@
 
 	//optional relative contact breaking threshold, turned on by default (use setDispatcherFlags to switch off feature for improved performance)
 	
-	btScalar contactBreakingThreshold =  (m_dispatcherFlags & btCollisionDispatcher::CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD) ? 
+	btScalar contactBreakingThreshold =  (locked_this->m_dispatcherFlags & btCollisionDispatcher::CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD) ? 
 		btMin(body0->getCollisionShape()->getContactBreakingThreshold(gContactBreakingThreshold) , body1->getCollisionShape()->getContactBreakingThreshold(gContactBreakingThreshold))
 		: gContactBreakingThreshold ;
 
@@ -86,9 +168,9 @@
 		
  	void* mem = 0;
 	
-	if (m_persistentManifoldPoolAllocator->getFreeCount())
+	if (locked_this->m_persistentManifoldPoolAllocator->getFreeCount())
 	{
-		mem = m_persistentManifoldPoolAllocator->allocate(sizeof(btPersistentManifold));
+		mem = locked_this->m_persistentManifoldPoolAllocator->allocate(sizeof(btPersistentManifold));
 	} else
 	{
 		//we got a pool memory overflow, by default we fallback to dynamically allocate memory. If we require a contiguous contact pool then assert.
@@ -103,20 +185,22 @@
 		}
 	}
 	btPersistentManifold* manifold = new(mem) btPersistentManifold (body0,body1,0,contactBreakingThreshold,contactProcessingThreshold);
-	manifold->m_index1a = m_manifoldsPtr.size();
-	m_manifoldsPtr.push_back(manifold);
+	manifold->m_index1a = locked_this->m_manifoldsPtr.size();
+	locked_this->m_manifoldsPtr.push_back(manifold);
 
 	return manifold;
 }
 
-void btCollisionDispatcher::clearManifold(btPersistentManifold* manifold)
+void btCollisionDispatcher::clearManifold(btPersistentManifold* manifold) volatile
 {
 	manifold->clearManifold();
 }
 
 	
-void btCollisionDispatcher::releaseManifold(btPersistentManifold* manifold)
+void btCollisionDispatcher::releaseManifold(btPersistentManifold* manifold) volatile
 {
+	btCollisionDispatcher *const locked_this = const_cast<btCollisionDispatcher *>(this);
+	std::lock_guard<std::mutex> grd(locked_this->m_mutex);
 	
 	gNumManifold--;
 
@@ -124,10 +208,10 @@
 	clearManifold(manifold);
 
 	int findIndex = manifold->m_index1a;
-	btAssert(findIndex < m_manifoldsPtr.size());
-	m_manifoldsPtr.swap(findIndex,m_manifoldsPtr.size()-1);
-	m_manifoldsPtr[findIndex]->m_index1a = findIndex;
-	m_manifoldsPtr.pop_back();
+	btAssert(findIndex < locked_this->m_manifoldsPtr.size());
+	locked_this->m_manifoldsPtr.swap(findIndex,locked_this->m_manifoldsPtr.size()-1);
+	locked_this->m_manifoldsPtr[findIndex]->m_index1a = findIndex;
+	locked_this->m_manifoldsPtr.pop_back();
 
 	manifold->~btPersistentManifold();
 	if (m_persistentManifoldPoolAllocator->validPtr(manifold))
@@ -140,16 +224,15 @@
 	
 }
 
-	
-
-btCollisionAlgorithm* btCollisionDispatcher::findAlgorithm(const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,btPersistentManifold* sharedManifold)
+btCollisionAlgorithm* btCollisionDispatcher::findAlgorithm(const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,btPersistentManifold* sharedManifold) volatile
 {
+	btCollisionDispatcher *const locked_this = const_cast<btCollisionDispatcher *>(this); // no need to lock
 	
 	btCollisionAlgorithmConstructionInfo ci;
 
 	ci.m_dispatcher1 = this;
 	ci.m_manifold = sharedManifold;
-	btCollisionAlgorithm* algo = m_doubleDispatch[body0Wrap->getCollisionShape()->getShapeType()][body1Wrap->getCollisionShape()->getShapeType()]->CreateCollisionAlgorithm(ci,body0Wrap,body1Wrap);
+	btCollisionAlgorithm* algo = locked_this->m_doubleDispatch[body0Wrap->getCollisionShape()->getShapeType()][body1Wrap->getCollisionShape()->getShapeType()]->CreateCollisionAlgorithm(ci,body0Wrap,body1Wrap);
 
 	return algo;
 }
@@ -168,7 +251,7 @@
 	return hasResponse;
 }
 
-bool	btCollisionDispatcher::needsCollision(const btCollisionObject* body0,const btCollisionObject* body1)
+bool	btCollisionDispatcher::needsCollision(const btCollisionObject* body0,const btCollisionObject* body1) volatile
 {
 	btAssert(body0);
 	btAssert(body1);
@@ -227,21 +310,146 @@
 
 	virtual bool	processOverlap(btBroadphasePair& pair)
 	{
-		(*m_dispatcher->getNearCallback())(pair,*m_dispatcher,m_dispatchInfo);
+		(*m_dispatcher->getNearCallback())(pair,*m_dispatcher,m_dispatchInfo, 0);
 
 		return false;
 	}
 };
 
+#ifdef _MSC_VER
+#include <windows.h>
+#else
+#include <sys/time.h>
+#endif
 
+static double gettime()
+{
+#ifdef _MSC_VER
+	LARGE_INTEGER v = {};
+	if (!QueryPerformanceCounter(&v)) {
+		return 0;
+	}
+	LARGE_INTEGER v1 = {};
+	if (!QueryPerformanceFrequency(&v1)) {
+		return 0;
+	}
+	return double(v.QuadPart) / double(v1.QuadPart);
+#else
+	::timeval tv = {};
+	::gettimeofday(&tv, 0);
+	return double(tv.tv_sec) + double(tv.tv_usec) / 1000000.0;
+#endif
+}
+
+void	btCollisionDispatcher::workerThreadMain(int id)
+{
+	set_tls_thread_id(id);
+//printf("worker main %d\n", id);
+	while (true) {
+		{
+			std::unique_lock<std::mutex> lck(m_mutex);
+			if (m_finished) {
+				break;
+			}
+			auto const& wi = m_workerInfo[id];
+			if (wi.done) {
+//printf("worker wait %d\n", id);				
+				m_cond.wait(lck);
+				continue;
+			}
+		}
+//printf("worker start %d\n", id);				
+		auto& wi = m_workerInfo[id];
+		const auto& nearCallback = (*this->getNearCallback());
+		auto curDispatchInfo = *m_dispatchInfo;
+		curDispatchInfo.m_curThread = id;
+		for (int i = wi.start; i < wi.end; ++i) {
+			auto& pair = (*m_pairArray)[i];
+			nearCallback(pair, *this, curDispatchInfo, id);
+		}
+		{
+			std::unique_lock<std::mutex> lck(m_mutex);
+			wi.done = true;
+//printf("worker done %d\n", id);				
+		}
+		m_cond.notify_all();
+	}
+}
 
 void	btCollisionDispatcher::dispatchAllCollisionPairs(btOverlappingPairCache* pairCache,const btDispatcherInfo& dispatchInfo,btDispatcher* dispatcher) 
 {
 	//m_blockedForChanges = true;
 
+#if 0
 	btCollisionPairCallback	collisionCallback(dispatchInfo,this);
 
 	pairCache->processAllOverlappingPairs(&collisionCallback,dispatcher);
+#endif
+	double t0 = gettime();
+	btBroadphasePairArray& arr = pairCache->getOverlappingPairArray();
+#if 0
+	const auto& nearCallback = (*this->getNearCallback());
+	for (int i = 0; i < arr.size(); ++i) {
+		auto& pair = arr[i];
+		nearCallback(pair, *this, dispatchInfo);
+	}
+#endif
+#if 0
+	{
+		const auto& nearCallback = (*this->getNearCallback());
+		m_pairArray = &arr;
+		m_dispatchInfo = &dispatchInfo;
+		int nthr = m_workerThreads.size();
+		int blksz = arr.size() / nthr;
+		int cur = 0;
+		for (int i = 0; i < nthr; ++i) {
+			auto& wi = m_workerInfo[i];
+			wi.start = cur;
+			cur += blksz;
+			wi.end = (i + 1 == nthr) ? arr.size() : cur;
+			auto curDispatchInfo = *m_dispatchInfo;
+			curDispatchInfo.m_curThread = i;
+			for (int j = wi.start; j < wi.end; ++j) {
+				auto& pair = arr[j];
+				nearCallback(pair, *this, curDispatchInfo, i);
+			}
+		}
+	}
+#endif	
+#if 1
+	{
+		std::unique_lock<std::mutex> lck(m_mutex);
+		m_pairArray = &arr;
+		m_dispatchInfo = &dispatchInfo;
+		int nthr = m_workerThreads.size();
+		int blksz = arr.size() / nthr;
+		int cur = 0;
+		for (int i = 0; i < nthr; ++i) {
+			auto& wi = m_workerInfo[i];
+			wi.start = cur;
+			cur += blksz;
+			wi.end = (i + 1 == nthr) ? arr.size() : cur;
+			wi.done = false;
+		}
+		m_cond.notify_all();
+	}
+	{
+		std::unique_lock<std::mutex> lck(m_mutex);
+		while (true) {
+			bool done = true;
+			for (int i = 0; i < m_workerThreads.size(); ++i) {
+				auto& wi = m_workerInfo[i];
+				done &= wi.done;
+			}
+			if (done) {
+				break;
+			}
+			m_cond.wait(lck);
+		}
+	}
+#endif
+	double t1 = gettime();
+//printf("arr=%d %f\n", arr.size(), t1 - t0);
 
 	//m_blockedForChanges = false;
 
@@ -251,7 +459,7 @@
 
 
 //by default, Bullet will use this near callback
-void btCollisionDispatcher::defaultNearCallback(btBroadphasePair& collisionPair, btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo)
+void btCollisionDispatcher::defaultNearCallback(btBroadphasePair& collisionPair, volatile btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo, int thread_id)
 {
 		btCollisionObject* colObj0 = (btCollisionObject*)collisionPair.m_pProxy0->m_clientObject;
 		btCollisionObject* colObj1 = (btCollisionObject*)collisionPair.m_pProxy1->m_clientObject;
@@ -261,11 +469,12 @@
 			btCollisionObjectWrapper obj0Wrap(0,colObj0->getCollisionShape(),colObj0,colObj0->getWorldTransform(),-1,-1);
 			btCollisionObjectWrapper obj1Wrap(0,colObj1->getCollisionShape(),colObj1,colObj1->getWorldTransform(),-1,-1);
 
+			collisionPair.m_curThreadId = thread_id;
 
 			//dispatcher will keep algorithms persistent in the collision pair
 			if (!collisionPair.m_algorithm)
 			{
-				collisionPair.m_algorithm = dispatcher.findAlgorithm(&obj0Wrap,&obj1Wrap);
+				collisionPair.m_algorithm = dispatcher.findAlgorithm(&obj0Wrap,&obj1Wrap, nullptr);
 			}
 
 			if (collisionPair.m_algorithm)
@@ -291,22 +500,28 @@
 }
 
 
-void* btCollisionDispatcher::allocateCollisionAlgorithm(int size)
+void* btCollisionDispatcher::allocateCollisionAlgorithm(int size) volatile
 {
-	if (m_collisionAlgorithmPoolAllocator->getFreeCount())
+	btCollisionDispatcher *const locked_this = const_cast<btCollisionDispatcher *>(this);
+	std::lock_guard<std::mutex> grd(locked_this->m_mutex);
+
+	if (locked_this->m_collisionAlgorithmPoolAllocator->getFreeCount())
 	{
-		return m_collisionAlgorithmPoolAllocator->allocate(size);
+		return locked_this->m_collisionAlgorithmPoolAllocator->allocate(size);
 	}
 	
 	//warn user for overflow?
 	return	btAlignedAlloc(static_cast<size_t>(size), 16);
 }
 
-void btCollisionDispatcher::freeCollisionAlgorithm(void* ptr)
+void btCollisionDispatcher::freeCollisionAlgorithm(void* ptr) volatile
 {
-	if (m_collisionAlgorithmPoolAllocator->validPtr(ptr))
+	btCollisionDispatcher *const locked_this = const_cast<btCollisionDispatcher *>(this);
+	std::lock_guard<std::mutex> grd(locked_this->m_mutex);
+
+	if (locked_this->m_collisionAlgorithmPoolAllocator->validPtr(ptr))
 	{
-		m_collisionAlgorithmPoolAllocator->freeMemory(ptr);
+		locked_this->m_collisionAlgorithmPoolAllocator->freeMemory(ptr);
 	} else
 	{
 		btAlignedFree(ptr);
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCollisionDispatcher.h ../bullet/src/BulletCollision/CollisionDispatch/btCollisionDispatcher.h
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCollisionDispatcher.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btCollisionDispatcher.h	2015-08-18 13:52:44.000000000 +0900
@@ -24,6 +24,11 @@
 #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
 #include "LinearMath/btAlignedObjectArray.h"
 
+#include <thread>
+#include <mutex>
+#include <condition_variable>
+#include <vector>
+
 class btIDebugDraw;
 class btOverlappingPairCache;
 class btPoolAllocator;
@@ -35,8 +40,9 @@
 
 class btCollisionDispatcher;
 ///user can override this nearcallback for collision filtering and more finegrained control over collision detection
-typedef void (*btNearCallback)(btBroadphasePair& collisionPair, btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo);
+typedef void (*btNearCallback)(btBroadphasePair& collisionPair, volatile btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo, int thread_id);
 
+int get_tls_thread_id();
 
 ///btCollisionDispatcher supports algorithms that handle ConvexConvex and ConvexConcave collision pairs.
 ///Time of Impact, Closest Points and Penetration Depth.
@@ -108,16 +114,16 @@
 
 	virtual ~btCollisionDispatcher();
 
-	virtual btPersistentManifold*	getNewManifold(const btCollisionObject* b0,const btCollisionObject* b1);
+	virtual btPersistentManifold*	getNewManifold(const btCollisionObject* b0,const btCollisionObject* b1) volatile;
 	
-	virtual void releaseManifold(btPersistentManifold* manifold);
+	virtual void releaseManifold(btPersistentManifold* manifold) volatile;
 
 
-	virtual void clearManifold(btPersistentManifold* manifold);
+	virtual void clearManifold(btPersistentManifold* manifold) volatile;
 
-	btCollisionAlgorithm* findAlgorithm(const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,btPersistentManifold* sharedManifold = 0);
+	btCollisionAlgorithm* findAlgorithm(const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,btPersistentManifold* sharedManifold=0) volatile;
 		
-	virtual bool	needsCollision(const btCollisionObject* body0,const btCollisionObject* body1);
+	virtual bool	needsCollision(const btCollisionObject* body0,const btCollisionObject* body1) volatile;
 	
 	virtual bool	needsResponse(const btCollisionObject* body0,const btCollisionObject* body1);
 	
@@ -134,11 +140,11 @@
 	}
 
 	//by default, Bullet will use this near callback
-	static void  defaultNearCallback(btBroadphasePair& collisionPair, btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo);
+	static void  defaultNearCallback(btBroadphasePair& collisionPair, volatile btCollisionDispatcher& dispatcher, const btDispatcherInfo& dispatchInfo, int thread_id);
 
-	virtual	void* allocateCollisionAlgorithm(int size);
+	virtual	void* allocateCollisionAlgorithm(int size) volatile;
 
-	virtual	void freeCollisionAlgorithm(void* ptr);
+	virtual	void freeCollisionAlgorithm(void* ptr) volatile;
 
 	btCollisionConfiguration*	getCollisionConfiguration()
 	{
@@ -165,6 +171,27 @@
 		return m_persistentManifoldPoolAllocator;
 	}
 
+private:
+	struct workerInfo {
+		int start = 0;
+		int end = 0;
+		bool done = true;
+	};
+	struct perThreadData {
+		btCollisionConfiguration *m_threadCC = 0;
+		btCollisionAlgorithmCreateFunc* m_threadDoubleDispatch[MAX_BROADPHASE_COLLISION_TYPES][MAX_BROADPHASE_COLLISION_TYPES] = { };
+	};
+	std::vector<std::thread> m_workerThreads;
+	std::vector<workerInfo> m_workerInfo;
+	std::vector<perThreadData> m_perThreadData;
+	mutable std::mutex m_mutex;
+	mutable std::condition_variable m_cond;
+	btAlignedObjectArray<btBroadphasePair> *m_pairArray = 0;
+	const btDispatcherInfo *m_dispatchInfo = 0;
+	bool m_finished = false;
+	
+	void workerThreadMain(int id);
+
 };
 
 #endif //BT_COLLISION__DISPATCHER_H
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCompoundCollisionAlgorithm.cpp ../bullet/src/BulletCollision/CollisionDispatch/btCompoundCollisionAlgorithm.cpp
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCompoundCollisionAlgorithm.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btCompoundCollisionAlgorithm.cpp	2015-08-18 13:55:31.000000000 +0900
@@ -99,13 +99,13 @@
 
 	const btCollisionObjectWrapper* m_compoundColObjWrap;
 	const btCollisionObjectWrapper* m_otherObjWrap;
-	btDispatcher* m_dispatcher;
+	volatile btDispatcher* m_dispatcher;
 	const btDispatcherInfo& m_dispatchInfo;
 	btManifoldResult*	m_resultOut;
 	btCollisionAlgorithm**	m_childCollisionAlgorithms;
 	btPersistentManifold*	m_sharedManifold;
 	
-	btCompoundLeafCallback (const btCollisionObjectWrapper* compoundObjWrap,const btCollisionObjectWrapper* otherObjWrap,btDispatcher* dispatcher,const btDispatcherInfo& dispatchInfo,btManifoldResult*	resultOut,btCollisionAlgorithm**	childCollisionAlgorithms,btPersistentManifold*	sharedManifold)
+	btCompoundLeafCallback (const btCollisionObjectWrapper* compoundObjWrap,const btCollisionObjectWrapper* otherObjWrap,volatile btDispatcher* dispatcher,const btDispatcherInfo& dispatchInfo,btManifoldResult*	resultOut,btCollisionAlgorithm**	childCollisionAlgorithms,btPersistentManifold*	sharedManifold)
 		:m_compoundColObjWrap(compoundObjWrap),m_otherObjWrap(otherObjWrap),m_dispatcher(dispatcher),m_dispatchInfo(dispatchInfo),m_resultOut(resultOut),
 		m_childCollisionAlgorithms(childCollisionAlgorithms),
 		m_sharedManifold(sharedManifold)
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.cpp ../bullet/src/BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.cpp
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.cpp	2015-08-18 14:00:45.000000000 +0900
@@ -96,7 +96,7 @@
 
 	const btCollisionObjectWrapper* m_compound0ColObjWrap;
 	const btCollisionObjectWrapper* m_compound1ColObjWrap;
-	btDispatcher* m_dispatcher;
+	btDispatcher volatile* m_dispatcher;
 	const btDispatcherInfo& m_dispatchInfo;
 	btManifoldResult*	m_resultOut;
 	
@@ -107,7 +107,7 @@
 	
 	btCompoundCompoundLeafCallback (const btCollisionObjectWrapper* compound1ObjWrap,
 									const btCollisionObjectWrapper* compound0ObjWrap,
-									btDispatcher* dispatcher,
+									btDispatcher volatile* dispatcher,
 									const btDispatcherInfo& dispatchInfo,
 									btManifoldResult*	resultOut,
 									btHashedSimplePairCache* childAlgorithmsCache,
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.cpp ../bullet/src/BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.cpp
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.cpp	2015-08-18 12:56:53.000000000 +0900
@@ -47,7 +47,7 @@
 }
 
 
-btConvexTriangleCallback::btConvexTriangleCallback(btDispatcher*  dispatcher,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,bool isSwapped):
+btConvexTriangleCallback::btConvexTriangleCallback(volatile btDispatcher*  dispatcher,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,bool isSwapped):
 	  m_dispatcher(dispatcher),
 	m_dispatchInfoPtr(0)
 {
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.h ../bullet/src/BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.h
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btConvexConcaveCollisionAlgorithm.h	2015-08-18 12:56:53.000000000 +0900
@@ -36,7 +36,7 @@
 
 
 	btManifoldResult* m_resultOut;
-	btDispatcher*	m_dispatcher;
+	volatile btDispatcher*	m_dispatcher;
 	const btDispatcherInfo* m_dispatchInfoPtr;
 	btScalar m_collisionMarginTriangle;
 	
@@ -45,7 +45,7 @@
 	
 	btPersistentManifold*	m_manifoldPtr;
 
-	btConvexTriangleCallback(btDispatcher* dispatcher,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,bool isSwapped);
+	btConvexTriangleCallback(volatile btDispatcher* dispatcher,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,bool isSwapped);
 
 	void	setTimeStepAndCounters(btScalar collisionMarginTriangle,const btDispatcherInfo& dispatchInfo,const btCollisionObjectWrapper* convexBodyWrap, const btCollisionObjectWrapper* triBodyWrap, btManifoldResult* resultOut);
 
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.cpp ../bullet/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.cpp
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.cpp	2015-08-18 14:35:24.000000000 +0900
@@ -179,7 +179,7 @@
 
 
 
-btConvexConvexAlgorithm::CreateFunc::CreateFunc(btSimplexSolverInterface*			simplexSolver, btConvexPenetrationDepthSolver* pdSolver)
+btConvexConvexAlgorithm::CreateFunc::CreateFunc(btThrSimplexSolvers*			simplexSolver, btThrPdSolvers* pdSolver)
 {
 	m_numPerturbationIterations = 0;
 	m_minimumPointsPerturbationThreshold = 3;
@@ -191,7 +191,7 @@
 { 
 }
 
-btConvexConvexAlgorithm::btConvexConvexAlgorithm(btPersistentManifold* mf,const btCollisionAlgorithmConstructionInfo& ci,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver* pdSolver,int numPerturbationIterations, int minimumPointsPerturbationThreshold)
+btConvexConvexAlgorithm::btConvexConvexAlgorithm(btPersistentManifold* mf,const btCollisionAlgorithmConstructionInfo& ci,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,btThrSimplexSolvers* simplexSolver, btThrPdSolvers* pdSolver,int numPerturbationIterations, int minimumPointsPerturbationThreshold)
 : btActivatingCollisionAlgorithm(ci,body0Wrap,body1Wrap),
 m_simplexSolver(simplexSolver),
 m_pdSolver(pdSolver),
@@ -350,7 +350,7 @@
 	
 	btGjkPairDetector::ClosestPointInput input;
 
-	btGjkPairDetector	gjkPairDetector(min0,min1,m_simplexSolver,m_pdSolver);
+	btGjkPairDetector	gjkPairDetector(min0,min1,(*m_simplexSolver)[dispatchInfo.m_curThread],(*m_pdSolver)[dispatchInfo.m_curThread]);
 	//TODO: if (dispatchInfo.m_useContinuous)
 	gjkPairDetector.setMinkowskiA(min0);
 	gjkPairDetector.setMinkowskiB(min1);
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.h ../bullet/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.h
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btConvexConvexAlgorithm.h	2015-08-18 14:31:11.000000000 +0900
@@ -42,8 +42,8 @@
 #ifdef USE_SEPDISTANCE_UTIL2
 	btConvexSeparatingDistanceUtil	m_sepDistance;
 #endif
-	btSimplexSolverInterface*		m_simplexSolver;
-	btConvexPenetrationDepthSolver* m_pdSolver;
+	btThrSimplexSolvers*		m_simplexSolver;
+	btThrPdSolvers* m_pdSolver;
 
 	
 	bool	m_ownManifold;
@@ -59,7 +59,7 @@
 
 public:
 
-	btConvexConvexAlgorithm(btPersistentManifold* mf,const btCollisionAlgorithmConstructionInfo& ci,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap, btSimplexSolverInterface* simplexSolver, btConvexPenetrationDepthSolver* pdSolver, int numPerturbationIterations, int minimumPointsPerturbationThreshold);
+	btConvexConvexAlgorithm(btPersistentManifold* mf,const btCollisionAlgorithmConstructionInfo& ci,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap, btThrSimplexSolvers* simplexSolver, btThrPdSolvers* pdSolver, int numPerturbationIterations, int minimumPointsPerturbationThreshold);
 
 	virtual ~btConvexConvexAlgorithm();
 
@@ -86,12 +86,12 @@
 	struct CreateFunc :public 	btCollisionAlgorithmCreateFunc
 	{
 
-		btConvexPenetrationDepthSolver*		m_pdSolver;
-		btSimplexSolverInterface*			m_simplexSolver;
+		btThrPdSolvers*		m_pdSolver;
+		btThrSimplexSolvers*			m_simplexSolver;
 		int m_numPerturbationIterations;
 		int m_minimumPointsPerturbationThreshold;
 
-		CreateFunc(btSimplexSolverInterface*			simplexSolver, btConvexPenetrationDepthSolver* pdSolver);
+		CreateFunc(btThrSimplexSolvers*			simplexSolver, btThrPdSolvers* pdSolver);
 		
 		virtual ~CreateFunc();
 
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.cpp ../bullet/src/BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.cpp
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.cpp	2015-08-18 14:36:00.000000000 +0900
@@ -44,22 +44,27 @@
 //btDefaultCollisionConfiguration::btDefaultCollisionConfiguration(btStackAlloc*	stackAlloc,btPoolAllocator*	persistentManifoldPool,btPoolAllocator*	collisionAlgorithmPool)
 {
 
-	void* mem = btAlignedAlloc(sizeof(btVoronoiSimplexSolver),16);
-	m_simplexSolver = new (mem)btVoronoiSimplexSolver();
+	void *mem = 0;
+	for (auto& ss: m_simplexSolver) {
+		mem = btAlignedAlloc(sizeof(btVoronoiSimplexSolver),16);
+		ss = new (mem)btVoronoiSimplexSolver();
+	}
 
+	for (auto& ps: m_pdSolver) {
 	if (constructionInfo.m_useEpaPenetrationAlgorithm)
 	{
 		mem = btAlignedAlloc(sizeof(btGjkEpaPenetrationDepthSolver),16);
-		m_pdSolver = new (mem)btGjkEpaPenetrationDepthSolver;
+			ps = new (mem)btGjkEpaPenetrationDepthSolver;
 	}else
 	{
 		mem = btAlignedAlloc(sizeof(btMinkowskiPenetrationDepthSolver),16);
-		m_pdSolver = new (mem)btMinkowskiPenetrationDepthSolver;
+			ps = new (mem)btMinkowskiPenetrationDepthSolver;
+		}
 	}
 	
 	//default CreationFunctions, filling the m_doubleDispatch table
 	mem = btAlignedAlloc(sizeof(btConvexConvexAlgorithm::CreateFunc),16);
-	m_convexConvexCreateFunc = new(mem) btConvexConvexAlgorithm::CreateFunc(m_simplexSolver,m_pdSolver);
+	m_convexConvexCreateFunc = new(mem) btConvexConvexAlgorithm::CreateFunc(&m_simplexSolver,&m_pdSolver);
 	mem = btAlignedAlloc(sizeof(btConvexConcaveCollisionAlgorithm::CreateFunc),16);
 	m_convexConcaveCreateFunc = new (mem)btConvexConcaveCollisionAlgorithm::CreateFunc;
 	mem = btAlignedAlloc(sizeof(btConvexConcaveCollisionAlgorithm::CreateFunc),16);
@@ -192,13 +197,15 @@
 	m_planeConvexCF->~btCollisionAlgorithmCreateFunc();
 	btAlignedFree( m_planeConvexCF);
 
-	m_simplexSolver->~btVoronoiSimplexSolver();
-	btAlignedFree(m_simplexSolver);
-
-	m_pdSolver->~btConvexPenetrationDepthSolver();
-	
-	btAlignedFree(m_pdSolver);
+	for (auto& ss: m_simplexSolver) {
+		ss->~btVoronoiSimplexSolver();
+		btAlignedFree(ss);
+	}
 
+	for (auto& ps: m_pdSolver) {
+		ps->~btConvexPenetrationDepthSolver();
+		btAlignedFree(ps);
+	}
 
 }
 
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h ../bullet/src/BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h	2015-08-18 14:41:03.000000000 +0900
@@ -16,6 +16,11 @@
 #ifndef BT_DEFAULT_COLLISION_CONFIGURATION
 #define BT_DEFAULT_COLLISION_CONFIGURATION
 
+#include <array>
+
+#define BT_DISPATCHER_NUM_THREADS 3
+
+#include "btCollisionCreateFunc.h"
 #include "btCollisionConfiguration.h"
 class btVoronoiSimplexSolver;
 class btConvexPenetrationDepthSolver;
@@ -41,7 +46,6 @@
 };
 
 
-
 ///btCollisionConfiguration allows to configure Bullet collision detection
 ///stack allocator, pool memory allocators
 ///@todo: describe the meaning
@@ -61,8 +65,8 @@
 	bool	m_ownsCollisionAlgorithmPool;
 
 	//default simplex/penetration depth solvers
-	btVoronoiSimplexSolver*	m_simplexSolver;
-	btConvexPenetrationDepthSolver*	m_pdSolver;
+	btThrSimplexSolvers	m_simplexSolver;
+	btThrPdSolvers	m_pdSolver;
 	
 	//default CreationFunctions, filling the m_doubleDispatch table
 	btCollisionAlgorithmCreateFunc*	m_convexConvexCreateFunc;
@@ -102,9 +106,12 @@
 	}
 
 
-	virtual	btVoronoiSimplexSolver*	getSimplexSolver()
+	virtual	btSimplexSolverInterface*	getSimplexSolver(int thread_id)
 	{
-		return m_simplexSolver;
+		if (thread_id < 0 || thread_id >= BT_DISPATCHER_NUM_THREADS) {
+			abort();
+		}
+		return m_simplexSolver[thread_id];
 	}
 
 
diff -bur bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btSimulationIslandManager.cpp ../bullet/src/BulletCollision/CollisionDispatch/btSimulationIslandManager.cpp
--- bullet3-2.83.5/src/BulletCollision/CollisionDispatch/btSimulationIslandManager.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletCollision/CollisionDispatch/btSimulationIslandManager.cpp	2015-09-05 00:54:29.000000000 +0900
@@ -392,10 +392,12 @@
 		
 
 	//	printf("Start Islands\n");
+//printf("Start Islands\n");
 
 		//traverse the simulation islands, and call the solver, unless all objects are sleeping/deactivated
 		for ( startIslandIndex=0;startIslandIndex<numElem;startIslandIndex = endIslandIndex)
 		{
+//printf("Island %d\n", startIslandIndex);
 			int islandId = getUnionFind().getElement(startIslandIndex).m_id;
 
 
@@ -410,7 +412,6 @@
 									islandSleeping = false;
 					}
 	                
-
 			//find the accompanying contact manifold for this islandId
 			int numIslandManifolds = 0;
 			btPersistentManifold** startManifold = 0;
@@ -431,11 +432,13 @@
 				}
 
 			}
+//printf("Island active %d\n", startIslandIndex);
+
 
 			if (!islandSleeping)
 			{
 				callback->processIsland(&m_islandBodies[0],m_islandBodies.size(),startManifold,numIslandManifolds, islandId);
-	//			printf("Island callback of size:%d bodies, %d manifolds\n",islandBodies.size(),numIslandManifolds);
+//printf("Island callback of size:%d bodies, %d manifolds\n",m_islandBodies.size(),numIslandManifolds);
 			}
 			
 			if (numIslandManifolds)
diff -bur bullet3-2.83.5/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.cpp ../bullet/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.cpp
--- bullet3-2.83.5/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.cpp	2015-09-06 02:56:00.000000000 +0900
@@ -1261,6 +1261,7 @@
 
 
 	for (int i=0;i<numBodies;i++)
+	if (0)
 	{
 		int bodyId = getOrInitSolverBody(*bodies[i],infoGlobal.m_timeStep);
 
diff -bur bullet3-2.83.5/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.cpp ../bullet/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.cpp
--- bullet3-2.83.5/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.cpp	2015-09-06 14:46:00.000000000 +0900
@@ -481,7 +481,8 @@
 	}
 
 	///apply gravity, predict motion
-	predictUnconstraintMotion(timeStep);
+// FIXME: skip only when possible
+	//predictUnconstraintMotion(timeStep);
 
 	btDispatcherInfo& dispatchInfo = getDispatchInfo();
 
@@ -490,7 +491,8 @@
 	dispatchInfo.m_debugDraw = getDebugDrawer();
 
 
-    createPredictiveContacts(timeStep);
+// FIXME: skip only when possible
+//    createPredictiveContacts(timeStep);
 
 	///perform collision detection
 	performDiscreteCollisionDetection();
@@ -514,7 +516,7 @@
 	///update vehicle simulation
 	updateActions(timeStep);
 
-	updateActivationState( timeStep );
+	// updateActivationState( timeStep );
 
 	if(0 != m_internalTickCallback) {
 		(*m_internalTickCallback)(this, timeStep);
@@ -1128,7 +1130,7 @@
 	for ( int i=0;i<m_nonStaticRigidBodies.size();i++)
 	{
 		btRigidBody* body = m_nonStaticRigidBodies[i];
-		if (!body->isStaticOrKinematicObject())
+		if (!body->isStaticOrKinematicObject() && body->isActive())
 		{
 			//don't integrate/update velocities here, it happens in the constraint solver
 
diff -bur bullet3-2.83.5/src/BulletDynamics/Dynamics/btRigidBody.cpp ../bullet/src/BulletDynamics/Dynamics/btRigidBody.cpp
--- bullet3-2.83.5/src/BulletDynamics/Dynamics/btRigidBody.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletDynamics/Dynamics/btRigidBody.cpp	2015-09-06 01:52:48.000000000 +0900
@@ -166,7 +166,9 @@
 	m_linearVelocity *= GEN_clamped((btScalar(1.) - timeStep * m_linearDamping), (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
 	m_angularVelocity *= GEN_clamped((btScalar(1.) - timeStep * m_angularDamping), (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
 #else
+	if (m_linearDamping != 0.0)
 	m_linearVelocity *= btPow(btScalar(1)-m_linearDamping, timeStep);
+	if (m_angularDamping != 0.0)
 	m_angularVelocity *= btPow(btScalar(1)-m_angularDamping, timeStep);
 #endif
 
diff -bur bullet3-2.83.5/src/BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.cpp ../bullet/src/BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.cpp
--- bullet3-2.83.5/src/BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.cpp	2015-08-18 12:56:53.000000000 +0900
@@ -49,7 +49,7 @@
 
 
 
-btSoftBodyTriangleCallback::btSoftBodyTriangleCallback(btDispatcher*  dispatcher,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,bool isSwapped):
+btSoftBodyTriangleCallback::btSoftBodyTriangleCallback(volatile btDispatcher*  dispatcher,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,bool isSwapped):
 m_dispatcher(dispatcher),
 m_dispatchInfoPtr(0)
 {
diff -bur bullet3-2.83.5/src/BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.h ../bullet/src/BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.h
--- bullet3-2.83.5/src/BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/BulletSoftBody/btSoftBodyConcaveCollisionAlgorithm.h	2015-08-18 12:56:53.000000000 +0900
@@ -72,7 +72,7 @@
 
 	btManifoldResult* m_resultOut;
 
-	btDispatcher*	m_dispatcher;
+	volatile btDispatcher*	m_dispatcher;
 	const btDispatcherInfo* m_dispatchInfoPtr;
 	btScalar m_collisionMarginTriangle;
 
@@ -83,7 +83,7 @@
 
 	//	btPersistentManifold*	m_manifoldPtr;
 
-	btSoftBodyTriangleCallback(btDispatcher* dispatcher,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,bool isSwapped);
+	btSoftBodyTriangleCallback(volatile btDispatcher* dispatcher,const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap,bool isSwapped);
 
 	void	setTimeStepAndCounters(btScalar collisionMarginTriangle,const btCollisionObjectWrapper* triObjWrap,const btDispatcherInfo& dispatchInfo,btManifoldResult* resultOut);
 
diff -bur bullet3-2.83.5/src/LinearMath/btAlignedAllocator.cpp ../bullet/src/LinearMath/btAlignedAllocator.cpp
--- bullet3-2.83.5/src/LinearMath/btAlignedAllocator.cpp	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/LinearMath/btAlignedAllocator.cpp	2015-08-18 12:56:53.000000000 +0900
@@ -104,6 +104,56 @@
   sFreeFunc = freeFunc ? freeFunc : btFreeDefault;
 }
 
+#ifdef BT_CHECK_ALLOC
+
+#include <mutex>
+#include <map>
+#include <string.h>
+
+std::mutex check_alloc_mutex;
+struct check_alloc_ent { int tag = 0; int sz = 0; };
+typedef std::map<size_t, check_alloc_ent> check_alloc_map_type;
+check_alloc_map_type check_alloc_map;
+
+void check_alloc_alloc(void *p, size_t sz, int tag)
+{
+fprintf(stderr, "check_alloc_alloc %p %zu %d\n", p, sz, tag);
+	size_t v = (size_t)p;
+	std::lock_guard<std::mutex> lck(check_alloc_mutex);
+	if (check_alloc_map.find(v) != check_alloc_map.end()) {
+		fprintf(stderr, "err check_alloc_alloc %p %d ex=%d\n", p, tag,
+			check_alloc_map[v].tag);
+		abort();
+	}
+	check_alloc_ent e;
+	e.tag = tag;
+	e.sz = sz;
+	check_alloc_map[v] = e;
+}
+
+void check_alloc_free(void *p, int tag)
+{
+fprintf(stderr, "check_alloc_free %p %d\n", p, tag);
+	if (p == 0) {
+		return;
+	}
+	size_t v = (size_t)p;
+	std::lock_guard<std::mutex> lck(check_alloc_mutex);
+	if (check_alloc_map.find(v) == check_alloc_map.end()) {
+		fprintf(stderr, "err check_alloc_free %p", p, tag);
+		abort();
+	}
+	if (check_alloc_map[v].tag != tag) {
+		fprintf(stderr, "err check_alloc_free %p %d ex=%d", p, tag,
+			check_alloc_map[v].tag);
+		abort();
+	}
+	memset(p, 0, check_alloc_map[v].sz);
+	check_alloc_map.erase(v);
+}
+
+#endif
+
 #ifdef BT_DEBUG_MEMORY_ALLOCATIONS
 //this generic allocator provides the total allocated number of bytes
 #include <stdio.h>
@@ -131,11 +181,13 @@
 
  int* ptr = (int*)ret;
  *ptr = 12;
+check_alloc_alloc(ret, size, 1);
  return (ret);
 }
 
 void    btAlignedFreeInternal   (void* ptr,int line,char* filename)
 {
+check_alloc_free(ptr, 1);
 
  void* real;
  gNumAlignedFree++;
@@ -162,6 +214,7 @@
 	void* ptr;
 	ptr = sAlignedAllocFunc(size, alignment);
 //	printf("btAlignedAllocInternal %d, %x\n",size,ptr);
+check_alloc_alloc(ptr, size, 2);
 	return ptr;
 }
 
@@ -171,6 +224,7 @@
 	{
 		return;
 	}
+check_alloc_free(ptr, 2);
 
 	gNumAlignedFree++;
 //	printf("btAlignedFreeInternal %x\n",ptr);
diff -bur bullet3-2.83.5/src/LinearMath/btAlignedAllocator.h ../bullet/src/LinearMath/btAlignedAllocator.h
--- bullet3-2.83.5/src/LinearMath/btAlignedAllocator.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/LinearMath/btAlignedAllocator.h	2015-08-18 16:09:22.000000000 +0900
@@ -101,7 +101,15 @@
 	friend bool operator==( const self_type & , const self_type & ) { return true; }
 };
 
+#undef BT_CHECK_ALLOC
 
+#ifdef BT_CHECK_ALLOC
+void check_alloc_alloc(void *p, size_t sz, int tag);
+void check_alloc_free(void *p, int tag);
+#else
+#define check_alloc_alloc(p, sz, tag)
+#define check_alloc_free(p, tag)
+#endif
 
 #endif //BT_ALIGNED_ALLOCATOR
 
diff -bur bullet3-2.83.5/src/LinearMath/btPoolAllocator.h ../bullet/src/LinearMath/btPoolAllocator.h
--- bullet3-2.83.5/src/LinearMath/btPoolAllocator.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/LinearMath/btPoolAllocator.h	2015-08-18 12:56:53.000000000 +0900
@@ -76,6 +76,7 @@
         void* result = m_firstFree;
         m_firstFree = *(void**)m_firstFree;
         --m_freeCount;
+if (result != m_pool) check_alloc_alloc(result, size, 2);
         return result;
 	}
 
@@ -92,6 +93,7 @@
 
 	void	freeMemory(void* ptr)
 	{
+if (ptr != m_pool) check_alloc_free(ptr, 2);
 		 if (ptr) {
             btAssert((unsigned char*)ptr >= m_pool && (unsigned char*)ptr < m_pool + m_maxElements * m_elemSize);
 
diff -bur bullet3-2.83.5/src/LinearMath/btScalar.h ../bullet/src/LinearMath/btScalar.h
--- bullet3-2.83.5/src/LinearMath/btScalar.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/LinearMath/btScalar.h	2015-09-06 00:57:31.000000000 +0900
@@ -92,7 +92,7 @@
 			//with relatively little performance gain
 			//If you are not embedded Bullet data in your classes, or make sure that you align those classes on 16-byte boundaries
 			//you can manually enable this line or set it in the build system for a bit of performance gain (a few percent, dependent on usage)
-			//#define BT_USE_SSE_IN_API
+			#define BT_USE_SSE_IN_API
 			#endif //BT_USE_SSE
 			#include <emmintrin.h>
 #endif
diff -bur bullet3-2.83.5/src/LinearMath/btTransformUtil.h ../bullet/src/LinearMath/btTransformUtil.h
--- bullet3-2.83.5/src/LinearMath/btTransformUtil.h	2015-06-06 06:47:51.000000000 +0900
+++ ../bullet/src/LinearMath/btTransformUtil.h	2015-09-06 07:19:51.000000000 +0900
@@ -43,7 +43,7 @@
 	static void integrateTransform(const btTransform& curTrans,const btVector3& linvel,const btVector3& angvel,btScalar timeStep,btTransform& predictedTransform)
 	{
 		predictedTransform.setOrigin(curTrans.getOrigin() + linvel * timeStep);
-//	#define QUATERNION_DERIVATIVE
+	#define QUATERNION_DERIVATIVE
 	#ifdef QUATERNION_DERIVATIVE
 		btQuaternion predictedOrn = curTrans.getRotation();
 		predictedOrn += (angvel * predictedOrn) * (timeStep * btScalar(0.5));
