public namespace bullet_api "export-unsafe";
public import common -;
public import bullet_base -;
public import container::raw -;
public metafunction BvhSubtreeInfoArray btAlignedObjectArray_btBvhSubtreeInfo;
public metafunction IndexedMeshArray btAlignedObjectArray_btIndexedMesh;
public tsvaluetype struct extern "::PHY_ScalarType" "extenum" PHY_ScalarType { }
public extern "PHY_FLOAT" PHY_ScalarType PHY_FLOAT;
public extern "PHY_DOUBLE" PHY_ScalarType PHY_DOUBLE;
public extern "PHY_INTEGER" PHY_ScalarType PHY_INTEGER;
public extern "PHY_SHORT" PHY_ScalarType PHY_SHORT;
public extern "PHY_FIXEDPOINT88" PHY_ScalarType PHY_FIXEDPOINT88;
public extern "PHY_UCHAR" PHY_ScalarType PHY_UCHAR;
public metafunction QuantizedNodeArray btAlignedObjectArray_btQuantizedBvhNode;
public threaded struct extern "::bt32BitAxisSweep3" "nodefault" bt32BitAxisSweep3(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, uint maxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator)  {
  public metafunction __base__ {btAxisSweep3Internal_unsigned_int};
}
public tsvaluetype struct extern "::bt6DofFlags" "extenum" bt6DofFlags { }
public extern "BT_6DOF_FLAGS_CFM_NORM" bt6DofFlags BT_6DOF_FLAGS_CFM_NORM;
public extern "BT_6DOF_FLAGS_CFM_STOP" bt6DofFlags BT_6DOF_FLAGS_CFM_STOP;
public extern "BT_6DOF_FLAGS_ERP_STOP" bt6DofFlags BT_6DOF_FLAGS_ERP_STOP;
public threaded struct extern "::btActionInterface" "noncopyable" btActionInterface {
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld, btScalar deltaTimeStep);
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer);
}
public threaded struct extern "::btActivatingCollisionAlgorithm" "nodefault" btActivatingCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci)  {
  public metafunction __base__ {btCollisionAlgorithm};
}
public metafunction btAlignedAllocFunc meta::list{rptr{void}, size_t, int};
public threaded struct extern "::btAlignedAllocator<btActionInterface*, 16u>" btAlignedAllocator_btActionInterface_p_16u {
  public function extern "address" rptr{rptr{btActionInterface}} address(rptr{btActionInterface} mutable& ref) const;
  public function extern "address" crptr{rptr{btActionInterface}} address1(rptr{btActionInterface} const& ref) const;
  public function extern "allocate" rptr{rptr{btActionInterface}} allocate(size_type n, rptr{crptr{rptr{btActionInterface}}} hint);
  public function extern "construct" void construct(rptr{rptr{btActionInterface}} ptr, rptr{btActionInterface} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btActionInterface}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btActionInterface}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btBroadphaseInterface*, 16u>" btAlignedAllocator_btBroadphaseInterface_p_16u {
  public function extern "address" rptr{rptr{btBroadphaseInterface}} address(rptr{btBroadphaseInterface} mutable& ref) const;
  public function extern "address" crptr{rptr{btBroadphaseInterface}} address1(rptr{btBroadphaseInterface} const& ref) const;
  public function extern "allocate" rptr{rptr{btBroadphaseInterface}} allocate(size_type n, rptr{crptr{rptr{btBroadphaseInterface}}} hint);
  public function extern "construct" void construct(rptr{rptr{btBroadphaseInterface}} ptr, rptr{btBroadphaseInterface} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btBroadphaseInterface}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btBroadphaseInterface}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btBroadphasePair, 16u>" btAlignedAllocator_btBroadphasePair_16u {
  public function extern "address" rptr{btBroadphasePair} address(btBroadphasePair mutable& ref) const;
  public function extern "address" crptr{btBroadphasePair} address1(btBroadphasePair const& ref) const;
  public function extern "allocate" rptr{btBroadphasePair} allocate(size_type n, rptr{crptr{btBroadphasePair}} hint);
  public function extern "construct" void construct(rptr{btBroadphasePair} ptr, btBroadphasePair const& value);
  public function extern "deallocate" void deallocate(rptr{btBroadphasePair} ptr);
  public function extern "destroy" void destroy(rptr{btBroadphasePair} ptr);
}
public threaded struct extern "::btAlignedAllocator<btBvhSubtreeInfo, 16u>" btAlignedAllocator_btBvhSubtreeInfo_16u {
  public function extern "address" rptr{btBvhSubtreeInfo} address(btBvhSubtreeInfo mutable& ref) const;
  public function extern "address" crptr{btBvhSubtreeInfo} address1(btBvhSubtreeInfo const& ref) const;
  public function extern "allocate" rptr{btBvhSubtreeInfo} allocate(size_type n, rptr{crptr{btBvhSubtreeInfo}} hint);
  public function extern "construct" void construct(rptr{btBvhSubtreeInfo} ptr, btBvhSubtreeInfo const& value);
  public function extern "deallocate" void deallocate(rptr{btBvhSubtreeInfo} ptr);
  public function extern "destroy" void destroy(rptr{btBvhSubtreeInfo} ptr);
}
public threaded struct extern "::btAlignedAllocator<btChunk*, 16u>" btAlignedAllocator_btChunk_p_16u {
  public function extern "address" rptr{rptr{btChunk}} address(rptr{btChunk} mutable& ref) const;
  public function extern "address" crptr{rptr{btChunk}} address1(rptr{btChunk} const& ref) const;
  public function extern "allocate" rptr{rptr{btChunk}} allocate(size_type n, rptr{crptr{rptr{btChunk}}} hint);
  public function extern "construct" void construct(rptr{rptr{btChunk}} ptr, rptr{btChunk} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btChunk}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btChunk}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btCollisionObject const*, 16u>" btAlignedAllocator_btCollisionObject_const_p_16u {
  public function extern "address" rptr{crptr{btCollisionObject}} address(crptr{btCollisionObject} mutable& ref) const;
  public function extern "address" crptr{crptr{btCollisionObject}} address1(crptr{btCollisionObject} const& ref) const;
  public function extern "allocate" rptr{crptr{btCollisionObject}} allocate(size_type n, rptr{crptr{crptr{btCollisionObject}}} hint);
  public function extern "construct" void construct(rptr{crptr{btCollisionObject}} ptr, crptr{btCollisionObject} const& value);
  public function extern "deallocate" void deallocate(rptr{crptr{btCollisionObject}} ptr);
  public function extern "destroy" void destroy(rptr{crptr{btCollisionObject}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btCollisionObject*, 16u>" btAlignedAllocator_btCollisionObject_p_16u {
  public function extern "address" rptr{rptr{btCollisionObject}} address(rptr{btCollisionObject} mutable& ref) const;
  public function extern "address" crptr{rptr{btCollisionObject}} address1(rptr{btCollisionObject} const& ref) const;
  public function extern "allocate" rptr{rptr{btCollisionObject}} allocate(size_type n, rptr{crptr{rptr{btCollisionObject}}} hint);
  public function extern "construct" void construct(rptr{rptr{btCollisionObject}} ptr, rptr{btCollisionObject} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btCollisionObject}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btCollisionObject}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btCollisionShape*, 16u>" btAlignedAllocator_btCollisionShape_p_16u {
  public function extern "address" rptr{rptr{btCollisionShape}} address(rptr{btCollisionShape} mutable& ref) const;
  public function extern "address" crptr{rptr{btCollisionShape}} address1(rptr{btCollisionShape} const& ref) const;
  public function extern "allocate" rptr{rptr{btCollisionShape}} allocate(size_type n, rptr{crptr{rptr{btCollisionShape}}} hint);
  public function extern "construct" void construct(rptr{rptr{btCollisionShape}} ptr, rptr{btCollisionShape} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btCollisionShape}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btCollisionShape}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btCompoundShapeChild, 16u>" btAlignedAllocator_btCompoundShapeChild_16u {
  public function extern "address" rptr{btCompoundShapeChild} address(btCompoundShapeChild mutable& ref) const;
  public function extern "address" crptr{btCompoundShapeChild} address1(btCompoundShapeChild const& ref) const;
  public function extern "allocate" rptr{btCompoundShapeChild} allocate(size_type n, rptr{crptr{btCompoundShapeChild}} hint);
  public function extern "construct" void construct(rptr{btCompoundShapeChild} ptr, btCompoundShapeChild const& value);
  public function extern "deallocate" void deallocate(rptr{btCompoundShapeChild} ptr);
  public function extern "destroy" void destroy(rptr{btCompoundShapeChild} ptr);
}
public threaded struct extern "::btAlignedAllocator<btDbvtNode const*, 16u>" btAlignedAllocator_btDbvtNode_const_p_16u {
  public function extern "address" rptr{crptr{btDbvtNode}} address(crptr{btDbvtNode} mutable& ref) const;
  public function extern "address" crptr{crptr{btDbvtNode}} address1(crptr{btDbvtNode} const& ref) const;
  public function extern "allocate" rptr{crptr{btDbvtNode}} allocate(size_type n, rptr{crptr{crptr{btDbvtNode}}} hint);
  public function extern "construct" void construct(rptr{crptr{btDbvtNode}} ptr, crptr{btDbvtNode} const& value);
  public function extern "deallocate" void deallocate(rptr{crptr{btDbvtNode}} ptr);
  public function extern "destroy" void destroy(rptr{crptr{btDbvtNode}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNN, 16u>" btAlignedAllocator_btDbvt_sStkNN_16u {
  public function extern "address" rptr{btDbvt_sStkNN} address(btDbvt_sStkNN mutable& ref) const;
  public function extern "address" crptr{btDbvt_sStkNN} address1(btDbvt_sStkNN const& ref) const;
  public function extern "allocate" rptr{btDbvt_sStkNN} allocate(size_type n, rptr{crptr{btDbvt_sStkNN}} hint);
  public function extern "construct" void construct(rptr{btDbvt_sStkNN} ptr, btDbvt_sStkNN const& value);
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNN} ptr);
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNN} ptr);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNPS, 16u>" btAlignedAllocator_btDbvt_sStkNPS_16u {
  public function extern "address" rptr{btDbvt_sStkNPS} address(btDbvt_sStkNPS mutable& ref) const;
  public function extern "address" crptr{btDbvt_sStkNPS} address1(btDbvt_sStkNPS const& ref) const;
  public function extern "allocate" rptr{btDbvt_sStkNPS} allocate(size_type n, rptr{crptr{btDbvt_sStkNPS}} hint);
  public function extern "construct" void construct(rptr{btDbvt_sStkNPS} ptr, btDbvt_sStkNPS const& value);
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNPS} ptr);
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNPS} ptr);
}
public threaded struct extern "::btAlignedAllocator<btDbvt::sStkNP, 16u>" btAlignedAllocator_btDbvt_sStkNP_16u {
  public function extern "address" rptr{btDbvt_sStkNP} address(btDbvt_sStkNP mutable& ref) const;
  public function extern "address" crptr{btDbvt_sStkNP} address1(btDbvt_sStkNP const& ref) const;
  public function extern "allocate" rptr{btDbvt_sStkNP} allocate(size_type n, rptr{crptr{btDbvt_sStkNP}} hint);
  public function extern "construct" void construct(rptr{btDbvt_sStkNP} ptr, btDbvt_sStkNP const& value);
  public function extern "deallocate" void deallocate(rptr{btDbvt_sStkNP} ptr);
  public function extern "destroy" void destroy(rptr{btDbvt_sStkNP} ptr);
}
public threaded struct extern "::btAlignedAllocator<btHashInt, 16u>" btAlignedAllocator_btHashInt_16u {
  public function extern "address" rptr{btHashInt} address(btHashInt mutable& ref) const;
  public function extern "address" crptr{btHashInt} address1(btHashInt const& ref) const;
  public function extern "allocate" rptr{btHashInt} allocate(size_type n, rptr{crptr{btHashInt}} hint);
  public function extern "construct" void construct(rptr{btHashInt} ptr, btHashInt const& value);
  public function extern "deallocate" void deallocate(rptr{btHashInt} ptr);
  public function extern "destroy" void destroy(rptr{btHashInt} ptr);
}
public threaded struct extern "::btAlignedAllocator<btHashPtr, 16u>" btAlignedAllocator_btHashPtr_16u {
  public function extern "address" rptr{btHashPtr} address(btHashPtr mutable& ref) const;
  public function extern "address" crptr{btHashPtr} address1(btHashPtr const& ref) const;
  public function extern "allocate" rptr{btHashPtr} allocate(size_type n, rptr{crptr{btHashPtr}} hint);
  public function extern "construct" void construct(rptr{btHashPtr} ptr, btHashPtr const& value);
  public function extern "deallocate" void deallocate(rptr{btHashPtr} ptr);
  public function extern "destroy" void destroy(rptr{btHashPtr} ptr);
}
public threaded struct extern "::btAlignedAllocator<btHashString, 16u>" btAlignedAllocator_btHashString_16u {
  public function extern "address" rptr{btHashString} address(btHashString mutable& ref) const;
  public function extern "address" crptr{btHashString} address1(btHashString const& ref) const;
  public function extern "allocate" rptr{btHashString} allocate(size_type n, rptr{crptr{btHashString}} hint);
  public function extern "construct" void construct(rptr{btHashString} ptr, btHashString const& value);
  public function extern "deallocate" void deallocate(rptr{btHashString} ptr);
  public function extern "destroy" void destroy(rptr{btHashString} ptr);
}
public threaded struct extern "::btAlignedAllocator<btIndexedMesh, 16u>" btAlignedAllocator_btIndexedMesh_16u {
  public function extern "address" rptr{btIndexedMesh} address(btIndexedMesh mutable& ref) const;
  public function extern "address" crptr{btIndexedMesh} address1(btIndexedMesh const& ref) const;
  public function extern "allocate" rptr{btIndexedMesh} allocate(size_type n, rptr{crptr{btIndexedMesh}} hint);
  public function extern "construct" void construct(rptr{btIndexedMesh} ptr, btIndexedMesh const& value);
  public function extern "deallocate" void deallocate(rptr{btIndexedMesh} ptr);
  public function extern "destroy" void destroy(rptr{btIndexedMesh} ptr);
}
public threaded struct extern "::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy*, 16u>" btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16u {
  public function extern "address" rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} address(rptr{btMultiSapBroadphase_btBridgeProxy} mutable& ref) const;
  public function extern "address" crptr{rptr{btMultiSapBroadphase_btBridgeProxy}} address1(rptr{btMultiSapBroadphase_btBridgeProxy} const& ref) const;
  public function extern "allocate" rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} allocate(size_type n, rptr{crptr{rptr{btMultiSapBroadphase_btBridgeProxy}}} hint);
  public function extern "construct" void construct(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr, rptr{btMultiSapBroadphase_btBridgeProxy} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btMultiSapBroadphase_btBridgeProxy}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy*, 16u>" btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16u {
  public function extern "address" rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} address(rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& ref) const;
  public function extern "address" crptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} address1(rptr{btMultiSapBroadphase_btMultiSapProxy} const& ref) const;
  public function extern "allocate" rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} allocate(size_type n, rptr{crptr{rptr{btMultiSapBroadphase_btMultiSapProxy}}} hint);
  public function extern "construct" void construct(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr, rptr{btMultiSapBroadphase_btMultiSapProxy} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btOptimizedBvhNode, 16u>" btAlignedAllocator_btOptimizedBvhNode_16u {
  public function extern "address" rptr{btOptimizedBvhNode} address(btOptimizedBvhNode mutable& ref) const;
  public function extern "address" crptr{btOptimizedBvhNode} address1(btOptimizedBvhNode const& ref) const;
  public function extern "allocate" rptr{btOptimizedBvhNode} allocate(size_type n, rptr{crptr{btOptimizedBvhNode}} hint);
  public function extern "construct" void construct(rptr{btOptimizedBvhNode} ptr, btOptimizedBvhNode const& value);
  public function extern "deallocate" void deallocate(rptr{btOptimizedBvhNode} ptr);
  public function extern "destroy" void destroy(rptr{btOptimizedBvhNode} ptr);
}
public threaded struct extern "::btAlignedAllocator<btPersistentManifold*, 16u>" btAlignedAllocator_btPersistentManifold_p_16u {
  public function extern "address" rptr{rptr{btPersistentManifold}} address(rptr{btPersistentManifold} mutable& ref) const;
  public function extern "address" crptr{rptr{btPersistentManifold}} address1(rptr{btPersistentManifold} const& ref) const;
  public function extern "allocate" rptr{rptr{btPersistentManifold}} allocate(size_type n, rptr{crptr{rptr{btPersistentManifold}}} hint);
  public function extern "construct" void construct(rptr{rptr{btPersistentManifold}} ptr, rptr{btPersistentManifold} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btPersistentManifold}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btPersistentManifold}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btPointerUid, 16u>" btAlignedAllocator_btPointerUid_16u {
  public function extern "address" rptr{btPointerUid} address(btPointerUid mutable& ref) const;
  public function extern "address" crptr{btPointerUid} address1(btPointerUid const& ref) const;
  public function extern "allocate" rptr{btPointerUid} allocate(size_type n, rptr{crptr{btPointerUid}} hint);
  public function extern "construct" void construct(rptr{btPointerUid} ptr, btPointerUid const& value);
  public function extern "deallocate" void deallocate(rptr{btPointerUid} ptr);
  public function extern "destroy" void destroy(rptr{btPointerUid} ptr);
}
public threaded struct extern "::btAlignedAllocator<btQuantizedBvhNode, 16u>" btAlignedAllocator_btQuantizedBvhNode_16u {
  public function extern "address" rptr{btQuantizedBvhNode} address(btQuantizedBvhNode mutable& ref) const;
  public function extern "address" crptr{btQuantizedBvhNode} address1(btQuantizedBvhNode const& ref) const;
  public function extern "allocate" rptr{btQuantizedBvhNode} allocate(size_type n, rptr{crptr{btQuantizedBvhNode}} hint);
  public function extern "construct" void construct(rptr{btQuantizedBvhNode} ptr, btQuantizedBvhNode const& value);
  public function extern "deallocate" void deallocate(rptr{btQuantizedBvhNode} ptr);
  public function extern "destroy" void destroy(rptr{btQuantizedBvhNode} ptr);
}
public threaded struct extern "::btAlignedAllocator<btRigidBody*, 16u>" btAlignedAllocator_btRigidBody_p_16u {
  public function extern "address" rptr{rptr{btRigidBody}} address(rptr{btRigidBody} mutable& ref) const;
  public function extern "address" crptr{rptr{btRigidBody}} address1(rptr{btRigidBody} const& ref) const;
  public function extern "allocate" rptr{rptr{btRigidBody}} allocate(size_type n, rptr{crptr{rptr{btRigidBody}}} hint);
  public function extern "construct" void construct(rptr{rptr{btRigidBody}} ptr, rptr{btRigidBody} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btRigidBody}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btRigidBody}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btSolverBody, 16u>" btAlignedAllocator_btSolverBody_16u {
  public function extern "address" rptr{btSolverBody} address(btSolverBody mutable& ref) const;
  public function extern "address" crptr{btSolverBody} address1(btSolverBody const& ref) const;
  public function extern "allocate" rptr{btSolverBody} allocate(size_type n, rptr{crptr{btSolverBody}} hint);
  public function extern "construct" void construct(rptr{btSolverBody} ptr, btSolverBody const& value);
  public function extern "deallocate" void deallocate(rptr{btSolverBody} ptr);
  public function extern "destroy" void destroy(rptr{btSolverBody} ptr);
}
public threaded struct extern "::btAlignedAllocator<btSolverConstraint, 16u>" btAlignedAllocator_btSolverConstraint_16u {
  public function extern "address" rptr{btSolverConstraint} address(btSolverConstraint mutable& ref) const;
  public function extern "address" crptr{btSolverConstraint} address1(btSolverConstraint const& ref) const;
  public function extern "allocate" rptr{btSolverConstraint} allocate(size_type n, rptr{crptr{btSolverConstraint}} hint);
  public function extern "construct" void construct(rptr{btSolverConstraint} ptr, btSolverConstraint const& value);
  public function extern "deallocate" void deallocate(rptr{btSolverConstraint} ptr);
  public function extern "destroy" void destroy(rptr{btSolverConstraint} ptr);
}
public threaded struct extern "::btAlignedAllocator<btTriangleInfo, 16u>" btAlignedAllocator_btTriangleInfo_16u {
  public function extern "address" rptr{btTriangleInfo} address(btTriangleInfo mutable& ref) const;
  public function extern "address" crptr{btTriangleInfo} address1(btTriangleInfo const& ref) const;
  public function extern "allocate" rptr{btTriangleInfo} allocate(size_type n, rptr{crptr{btTriangleInfo}} hint);
  public function extern "construct" void construct(rptr{btTriangleInfo} ptr, btTriangleInfo const& value);
  public function extern "deallocate" void deallocate(rptr{btTriangleInfo} ptr);
  public function extern "destroy" void destroy(rptr{btTriangleInfo} ptr);
}
public threaded struct extern "::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16u>" btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16u {
  public function extern "address" rptr{btTypedConstraint_btConstraintInfo1} address(btTypedConstraint_btConstraintInfo1 mutable& ref) const;
  public function extern "address" crptr{btTypedConstraint_btConstraintInfo1} address1(btTypedConstraint_btConstraintInfo1 const& ref) const;
  public function extern "allocate" rptr{btTypedConstraint_btConstraintInfo1} allocate(size_type n, rptr{crptr{btTypedConstraint_btConstraintInfo1}} hint);
  public function extern "construct" void construct(rptr{btTypedConstraint_btConstraintInfo1} ptr, btTypedConstraint_btConstraintInfo1 const& value);
  public function extern "deallocate" void deallocate(rptr{btTypedConstraint_btConstraintInfo1} ptr);
  public function extern "destroy" void destroy(rptr{btTypedConstraint_btConstraintInfo1} ptr);
}
public threaded struct extern "::btAlignedAllocator<btTypedConstraint*, 16u>" btAlignedAllocator_btTypedConstraint_p_16u {
  public function extern "address" rptr{rptr{btTypedConstraint}} address(rptr{btTypedConstraint} mutable& ref) const;
  public function extern "address" crptr{rptr{btTypedConstraint}} address1(rptr{btTypedConstraint} const& ref) const;
  public function extern "allocate" rptr{rptr{btTypedConstraint}} allocate(size_type n, rptr{crptr{rptr{btTypedConstraint}}} hint);
  public function extern "construct" void construct(rptr{rptr{btTypedConstraint}} ptr, rptr{btTypedConstraint} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{btTypedConstraint}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{btTypedConstraint}} ptr);
}
public threaded struct extern "::btAlignedAllocator<btVector3, 16u>" btAlignedAllocator_btVector3_16u {
  public function extern "address" rptr{btVector3} address(btVector3 mutable& ref) const;
  public function extern "address" crptr{btVector3} address1(btVector3 const& ref) const;
  public function extern "allocate" rptr{btVector3} allocate(size_type n, rptr{crptr{btVector3}} hint);
  public function extern "construct" void construct(rptr{btVector3} ptr, btVector3 const& value);
  public function extern "deallocate" void deallocate(rptr{btVector3} ptr);
  public function extern "destroy" void destroy(rptr{btVector3} ptr);
}
public threaded struct extern "::btAlignedAllocator<btWheelInfo, 16u>" btAlignedAllocator_btWheelInfo_16u {
  public function extern "address" rptr{btWheelInfo} address(btWheelInfo mutable& ref) const;
  public function extern "address" crptr{btWheelInfo} address1(btWheelInfo const& ref) const;
  public function extern "allocate" rptr{btWheelInfo} allocate(size_type n, rptr{crptr{btWheelInfo}} hint);
  public function extern "construct" void construct(rptr{btWheelInfo} ptr, btWheelInfo const& value);
  public function extern "deallocate" void deallocate(rptr{btWheelInfo} ptr);
  public function extern "destroy" void destroy(rptr{btWheelInfo} ptr);
}
public threaded struct extern "::btAlignedAllocator<char const*, 16u>" btAlignedAllocator_char_const_p_16u {
  public function extern "address" rptr{crptr{char}} address(crptr{char} mutable& ref) const;
  public function extern "address" crptr{crptr{char}} address1(crptr{char} const& ref) const;
  public function extern "allocate" rptr{crptr{char}} allocate(size_type n, rptr{crptr{crptr{char}}} hint);
  public function extern "construct" void construct(rptr{crptr{char}} ptr, crptr{char} const& value);
  public function extern "deallocate" void deallocate(rptr{crptr{char}} ptr);
  public function extern "destroy" void destroy(rptr{crptr{char}} ptr);
}
public threaded struct extern "::btAlignedAllocator<char*, 16u>" btAlignedAllocator_char_p_16u {
  public function extern "address" rptr{rptr{char}} address(rptr{char} mutable& ref) const;
  public function extern "address" crptr{rptr{char}} address1(rptr{char} const& ref) const;
  public function extern "allocate" rptr{rptr{char}} allocate(size_type n, rptr{crptr{rptr{char}}} hint);
  public function extern "construct" void construct(rptr{rptr{char}} ptr, rptr{char} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{char}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{char}} ptr);
}
public threaded struct extern "::btAlignedAllocator<float, 16u>" btAlignedAllocator_float_16u {
  public function extern "address" rptr{float} address(float mutable& ref) const;
  public function extern "address" crptr{float} address1(float const& ref) const;
  public function extern "allocate" rptr{float} allocate(size_type n, rptr{crptr{float}} hint);
  public function extern "construct" void construct(rptr{float} ptr, float const& value);
  public function extern "deallocate" void deallocate(rptr{float} ptr);
  public function extern "destroy" void destroy(rptr{float} ptr);
}
public threaded struct extern "::btAlignedAllocator<int, 16u>" btAlignedAllocator_int_16u {
  public function extern "address" rptr{int} address(int mutable& ref) const;
  public function extern "address" crptr{int} address1(int const& ref) const;
  public function extern "allocate" rptr{int} allocate(size_type n, rptr{crptr{int}} hint);
  public function extern "construct" void construct(rptr{int} ptr, int const& value);
  public function extern "deallocate" void deallocate(rptr{int} ptr);
  public function extern "destroy" void destroy(rptr{int} ptr);
}
public threaded struct extern "::btAlignedAllocator<short, 16u>" btAlignedAllocator_short_16u {
  public function extern "address" rptr{short} address(short mutable& ref) const;
  public function extern "address" crptr{short} address1(short const& ref) const;
  public function extern "allocate" rptr{short} allocate(size_type n, rptr{crptr{short}} hint);
  public function extern "construct" void construct(rptr{short} ptr, short const& value);
  public function extern "deallocate" void deallocate(rptr{short} ptr);
  public function extern "destroy" void destroy(rptr{short} ptr);
}
public threaded struct extern "::btAlignedAllocator<short*, 16u>" btAlignedAllocator_short_p_16u {
  public function extern "address" rptr{rptr{short}} address(rptr{short} mutable& ref) const;
  public function extern "address" crptr{rptr{short}} address1(rptr{short} const& ref) const;
  public function extern "allocate" rptr{rptr{short}} allocate(size_type n, rptr{crptr{rptr{short}}} hint);
  public function extern "construct" void construct(rptr{rptr{short}} ptr, rptr{short} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{short}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{short}} ptr);
}
public threaded struct extern "::btAlignedAllocator<unsigned int, 16u>" btAlignedAllocator_unsigned_int_16u {
  public function extern "address" rptr{uint} address(uint mutable& ref) const;
  public function extern "address" crptr{uint} address1(uint const& ref) const;
  public function extern "allocate" rptr{uint} allocate(size_type n, rptr{crptr{uint}} hint);
  public function extern "construct" void construct(rptr{uint} ptr, uint const& value);
  public function extern "deallocate" void deallocate(rptr{uint} ptr);
  public function extern "destroy" void destroy(rptr{uint} ptr);
}
public threaded struct extern "::btAlignedAllocator<unsigned short, 16u>" btAlignedAllocator_unsigned_short_16u {
  public function extern "address" rptr{ushort} address(ushort mutable& ref) const;
  public function extern "address" crptr{ushort} address1(ushort const& ref) const;
  public function extern "allocate" rptr{ushort} allocate(size_type n, rptr{crptr{ushort}} hint);
  public function extern "construct" void construct(rptr{ushort} ptr, ushort const& value);
  public function extern "deallocate" void deallocate(rptr{ushort} ptr);
  public function extern "destroy" void destroy(rptr{ushort} ptr);
}
public threaded struct extern "::btAlignedAllocator<void*, 16u>" btAlignedAllocator_void_p_16u {
  public function extern "address" rptr{rptr{void}} address(rptr{void} mutable& ref) const;
  public function extern "address" crptr{rptr{void}} address1(rptr{void} const& ref) const;
  public function extern "allocate" rptr{rptr{void}} allocate(size_type n, rptr{crptr{rptr{void}}} hint);
  public function extern "construct" void construct(rptr{rptr{void}} ptr, rptr{void} const& value);
  public function extern "deallocate" void deallocate(rptr{rptr{void}} ptr);
  public function extern "destroy" void destroy(rptr{rptr{void}} ptr);
}
public metafunction btAlignedFreeFunc meta::list{void, rptr{void}};
public threaded struct extern "::btAlignedObjectArray<btActionInterface*>" btAlignedObjectArray_btActionInterface_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btActionInterface} const& at(int n) const;
  public function extern "at" rptr{btActionInterface} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btActionInterface} const& fillData);
  public function extern "expandNonInitializing" rptr{btActionInterface} mutable& expandNonInitializing();
  public function extern "expand" rptr{btActionInterface} mutable& expand_(rptr{btActionInterface} const& fillValue);
  public function extern "push_back" void push_back(rptr{btActionInterface} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btActionInterface} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btActionInterface} const& key) const;
  public function extern "remove" void remove(rptr{btActionInterface} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btActionInterface_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btActionInterface*>::less" "nodefault" btAlignedObjectArray_btActionInterface_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btBroadphaseInterface*>" btAlignedObjectArray_btBroadphaseInterface_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btBroadphaseInterface} const& at(int n) const;
  public function extern "at" rptr{btBroadphaseInterface} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btBroadphaseInterface} const& fillData);
  public function extern "expandNonInitializing" rptr{btBroadphaseInterface} mutable& expandNonInitializing();
  public function extern "expand" rptr{btBroadphaseInterface} mutable& expand_(rptr{btBroadphaseInterface} const& fillValue);
  public function extern "push_back" void push_back(rptr{btBroadphaseInterface} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btBroadphaseInterface} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btBroadphaseInterface} const& key) const;
  public function extern "remove" void remove(rptr{btBroadphaseInterface} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBroadphaseInterface_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btBroadphaseInterface*>::less" "nodefault" btAlignedObjectArray_btBroadphaseInterface_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btBroadphasePair>" btAlignedObjectArray_btBroadphasePair {
  public function extern "size" int size() const;
  public function extern "at" btBroadphasePair const& at(int n) const;
  public function extern "at" btBroadphasePair mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btBroadphasePair const& fillData);
  public function extern "expandNonInitializing" btBroadphasePair mutable& expandNonInitializing();
  public function extern "expand" btBroadphasePair mutable& expand_(btBroadphasePair const& fillValue);
  public function extern "push_back" void push_back(btBroadphasePair const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btBroadphasePair const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btBroadphasePair const& key) const;
  public function extern "remove" void remove(btBroadphasePair const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBroadphasePair const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btBroadphasePair>::less" "nodefault" btAlignedObjectArray_btBroadphasePair_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btBvhSubtreeInfo>" btAlignedObjectArray_btBvhSubtreeInfo {
  public function extern "size" int size() const;
  public function extern "at" btBvhSubtreeInfo const& at(int n) const;
  public function extern "at" btBvhSubtreeInfo mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btBvhSubtreeInfo const& fillData);
  public function extern "expandNonInitializing" btBvhSubtreeInfo mutable& expandNonInitializing();
  public function extern "expand" btBvhSubtreeInfo mutable& expand_(btBvhSubtreeInfo const& fillValue);
  public function extern "push_back" void push_back(btBvhSubtreeInfo const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btBvhSubtreeInfo const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btBvhSubtreeInfo const& key) const;
  public function extern "remove" void remove(btBvhSubtreeInfo const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btBvhSubtreeInfo const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btBvhSubtreeInfo>::less" "nodefault" btAlignedObjectArray_btBvhSubtreeInfo_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btChunk*>" btAlignedObjectArray_btChunk_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btChunk} const& at(int n) const;
  public function extern "at" rptr{btChunk} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btChunk} const& fillData);
  public function extern "expandNonInitializing" rptr{btChunk} mutable& expandNonInitializing();
  public function extern "expand" rptr{btChunk} mutable& expand_(rptr{btChunk} const& fillValue);
  public function extern "push_back" void push_back(rptr{btChunk} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btChunk} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btChunk} const& key) const;
  public function extern "remove" void remove(rptr{btChunk} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btChunk_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btChunk*>::less" "nodefault" btAlignedObjectArray_btChunk_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject const*>" btAlignedObjectArray_btCollisionObject_const_p {
  public function extern "size" int size() const;
  public function extern "at" crptr{btCollisionObject} const& at(int n) const;
  public function extern "at" crptr{btCollisionObject} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, crptr{btCollisionObject} const& fillData);
  public function extern "expandNonInitializing" crptr{btCollisionObject} mutable& expandNonInitializing();
  public function extern "expand" crptr{btCollisionObject} mutable& expand_(crptr{btCollisionObject} const& fillValue);
  public function extern "push_back" void push_back(crptr{btCollisionObject} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(crptr{btCollisionObject} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(crptr{btCollisionObject} const& key) const;
  public function extern "remove" void remove(crptr{btCollisionObject} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionObject_const_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject const*>::less" "nodefault" btAlignedObjectArray_btCollisionObject_const_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject*>" btAlignedObjectArray_btCollisionObject_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btCollisionObject} const& at(int n) const;
  public function extern "at" rptr{btCollisionObject} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btCollisionObject} const& fillData);
  public function extern "expandNonInitializing" rptr{btCollisionObject} mutable& expandNonInitializing();
  public function extern "expand" rptr{btCollisionObject} mutable& expand_(rptr{btCollisionObject} const& fillValue);
  public function extern "push_back" void push_back(rptr{btCollisionObject} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionObject} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionObject} const& key) const;
  public function extern "remove" void remove(rptr{btCollisionObject} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionObject_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btCollisionObject*>::less" "nodefault" btAlignedObjectArray_btCollisionObject_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btCollisionShape*>" btAlignedObjectArray_btCollisionShape_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btCollisionShape} const& at(int n) const;
  public function extern "at" rptr{btCollisionShape} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btCollisionShape} const& fillData);
  public function extern "expandNonInitializing" rptr{btCollisionShape} mutable& expandNonInitializing();
  public function extern "expand" rptr{btCollisionShape} mutable& expand_(rptr{btCollisionShape} const& fillValue);
  public function extern "push_back" void push_back(rptr{btCollisionShape} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionShape} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionShape} const& key) const;
  public function extern "remove" void remove(rptr{btCollisionShape} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCollisionShape_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btCollisionShape*>::less" "nodefault" btAlignedObjectArray_btCollisionShape_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btCompoundShapeChild>" btAlignedObjectArray_btCompoundShapeChild {
  public function extern "size" int size() const;
  public function extern "at" btCompoundShapeChild const& at(int n) const;
  public function extern "at" btCompoundShapeChild mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btCompoundShapeChild const& fillData);
  public function extern "expandNonInitializing" btCompoundShapeChild mutable& expandNonInitializing();
  public function extern "expand" btCompoundShapeChild mutable& expand_(btCompoundShapeChild const& fillValue);
  public function extern "push_back" void push_back(btCompoundShapeChild const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btCompoundShapeChild const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btCompoundShapeChild const& key) const;
  public function extern "remove" void remove(btCompoundShapeChild const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btCompoundShapeChild const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btCompoundShapeChild>::less" "nodefault" btAlignedObjectArray_btCompoundShapeChild_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvtNode const*>" btAlignedObjectArray_btDbvtNode_const_p {
  public function extern "size" int size() const;
  public function extern "at" crptr{btDbvtNode} const& at(int n) const;
  public function extern "at" crptr{btDbvtNode} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, crptr{btDbvtNode} const& fillData);
  public function extern "expandNonInitializing" crptr{btDbvtNode} mutable& expandNonInitializing();
  public function extern "expand" crptr{btDbvtNode} mutable& expand_(crptr{btDbvtNode} const& fillValue);
  public function extern "push_back" void push_back(crptr{btDbvtNode} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(crptr{btDbvtNode} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(crptr{btDbvtNode} const& key) const;
  public function extern "remove" void remove(crptr{btDbvtNode} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvtNode_const_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btDbvtNode const*>::less" "nodefault" btAlignedObjectArray_btDbvtNode_const_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvtProxy*>" "nodefault" btAlignedObjectArray_btDbvtProxy_p private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNN>" btAlignedObjectArray_btDbvt_sStkNN {
  public function extern "size" int size() const;
  public function extern "at" btDbvt_sStkNN const& at(int n) const;
  public function extern "at" btDbvt_sStkNN mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btDbvt_sStkNN const& fillData);
  public function extern "expandNonInitializing" btDbvt_sStkNN mutable& expandNonInitializing();
  public function extern "expand" btDbvt_sStkNN mutable& expand_(btDbvt_sStkNN const& fillValue);
  public function extern "push_back" void push_back(btDbvt_sStkNN const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNN const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNN const& key) const;
  public function extern "remove" void remove(btDbvt_sStkNN const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNN const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNN>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNN_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNP>" btAlignedObjectArray_btDbvt_sStkNP {
  public function extern "size" int size() const;
  public function extern "at" btDbvt_sStkNP const& at(int n) const;
  public function extern "at" btDbvt_sStkNP mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btDbvt_sStkNP const& fillData);
  public function extern "expandNonInitializing" btDbvt_sStkNP mutable& expandNonInitializing();
  public function extern "expand" btDbvt_sStkNP mutable& expand_(btDbvt_sStkNP const& fillValue);
  public function extern "push_back" void push_back(btDbvt_sStkNP const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNP const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNP const& key) const;
  public function extern "remove" void remove(btDbvt_sStkNP const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNP const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNPS>" btAlignedObjectArray_btDbvt_sStkNPS {
  public function extern "size" int size() const;
  public function extern "at" btDbvt_sStkNPS const& at(int n) const;
  public function extern "at" btDbvt_sStkNPS mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btDbvt_sStkNPS const& fillData);
  public function extern "expandNonInitializing" btDbvt_sStkNPS mutable& expandNonInitializing();
  public function extern "expand" btDbvt_sStkNPS mutable& expand_(btDbvt_sStkNPS const& fillValue);
  public function extern "push_back" void push_back(btDbvt_sStkNPS const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNPS const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNPS const& key) const;
  public function extern "remove" void remove(btDbvt_sStkNPS const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btDbvt_sStkNPS const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNPS>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNPS_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btDbvt::sStkNP>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNP_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btHashInt>" btAlignedObjectArray_btHashInt {
  public function extern "size" int size() const;
  public function extern "at" btHashInt const& at(int n) const;
  public function extern "at" btHashInt mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btHashInt const& fillData);
  public function extern "expandNonInitializing" btHashInt mutable& expandNonInitializing();
  public function extern "expand" btHashInt mutable& expand_(btHashInt const& fillValue);
  public function extern "push_back" void push_back(btHashInt const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btHashInt const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btHashInt const& key) const;
  public function extern "remove" void remove(btHashInt const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashInt const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btHashInt>::less" "nodefault" btAlignedObjectArray_btHashInt_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btHashPtr>" btAlignedObjectArray_btHashPtr {
  public function extern "size" int size() const;
  public function extern "at" btHashPtr const& at(int n) const;
  public function extern "at" btHashPtr mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btHashPtr const& fillData);
  public function extern "expandNonInitializing" btHashPtr mutable& expandNonInitializing();
  public function extern "expand" btHashPtr mutable& expand_(btHashPtr const& fillValue);
  public function extern "push_back" void push_back(btHashPtr const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btHashPtr const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btHashPtr const& key) const;
  public function extern "remove" void remove(btHashPtr const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashPtr const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btHashPtr>::less" "nodefault" btAlignedObjectArray_btHashPtr_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btHashString>" btAlignedObjectArray_btHashString {
  public function extern "size" int size() const;
  public function extern "at" btHashString const& at(int n) const;
  public function extern "at" btHashString mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btHashString const& fillData);
  public function extern "expandNonInitializing" btHashString mutable& expandNonInitializing();
  public function extern "expand" btHashString mutable& expand_(btHashString const& fillValue);
  public function extern "push_back" void push_back(btHashString const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btHashString const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btHashString const& key) const;
  public function extern "remove" void remove(btHashString const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btHashString const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btHashString>::less" "nodefault" btAlignedObjectArray_btHashString_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btIndexedMesh>" btAlignedObjectArray_btIndexedMesh {
  public function extern "size" int size() const;
  public function extern "at" btIndexedMesh const& at(int n) const;
  public function extern "at" btIndexedMesh mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btIndexedMesh const& fillData);
  public function extern "expandNonInitializing" btIndexedMesh mutable& expandNonInitializing();
  public function extern "expand" btIndexedMesh mutable& expand_(btIndexedMesh const& fillValue);
  public function extern "push_back" void push_back(btIndexedMesh const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btIndexedMesh const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btIndexedMesh const& key) const;
  public function extern "remove" void remove(btIndexedMesh const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btIndexedMesh const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btIndexedMesh>::less" "nodefault" btAlignedObjectArray_btIndexedMesh_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>" btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btMultiSapBroadphase_btBridgeProxy} const& at(int n) const;
  public function extern "at" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btMultiSapBroadphase_btBridgeProxy} const& fillData);
  public function extern "expandNonInitializing" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& expandNonInitializing();
  public function extern "expand" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& expand_(rptr{btMultiSapBroadphase_btBridgeProxy} const& fillValue);
  public function extern "push_back" void push_back(rptr{btMultiSapBroadphase_btBridgeProxy} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMultiSapBroadphase_btBridgeProxy} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMultiSapBroadphase_btBridgeProxy} const& key) const;
  public function extern "remove" void remove(rptr{btMultiSapBroadphase_btBridgeProxy} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy*>::less" "nodefault" btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>" btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btMultiSapBroadphase_btMultiSapProxy} const& at(int n) const;
  public function extern "at" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btMultiSapBroadphase_btMultiSapProxy} const& fillData);
  public function extern "expandNonInitializing" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& expandNonInitializing();
  public function extern "expand" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& expand_(rptr{btMultiSapBroadphase_btMultiSapProxy} const& fillValue);
  public function extern "push_back" void push_back(rptr{btMultiSapBroadphase_btMultiSapProxy} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key) const;
  public function extern "remove" void remove(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy*>::less" "nodefault" btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btOptimizedBvhNode>" btAlignedObjectArray_btOptimizedBvhNode {
  public function extern "size" int size() const;
  public function extern "at" btOptimizedBvhNode const& at(int n) const;
  public function extern "at" btOptimizedBvhNode mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btOptimizedBvhNode const& fillData);
  public function extern "expandNonInitializing" btOptimizedBvhNode mutable& expandNonInitializing();
  public function extern "expand" btOptimizedBvhNode mutable& expand_(btOptimizedBvhNode const& fillValue);
  public function extern "push_back" void push_back(btOptimizedBvhNode const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btOptimizedBvhNode const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btOptimizedBvhNode const& key) const;
  public function extern "remove" void remove(btOptimizedBvhNode const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btOptimizedBvhNode const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btOptimizedBvhNode>::less" "nodefault" btAlignedObjectArray_btOptimizedBvhNode_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btPersistentManifold*>" btAlignedObjectArray_btPersistentManifold_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btPersistentManifold} const& at(int n) const;
  public function extern "at" rptr{btPersistentManifold} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btPersistentManifold} const& fillData);
  public function extern "expandNonInitializing" rptr{btPersistentManifold} mutable& expandNonInitializing();
  public function extern "expand" rptr{btPersistentManifold} mutable& expand_(rptr{btPersistentManifold} const& fillValue);
  public function extern "push_back" void push_back(rptr{btPersistentManifold} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btPersistentManifold} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btPersistentManifold} const& key) const;
  public function extern "remove" void remove(rptr{btPersistentManifold} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btPersistentManifold_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btPersistentManifold*>::less" "nodefault" btAlignedObjectArray_btPersistentManifold_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btPointerUid>" btAlignedObjectArray_btPointerUid {
  public function extern "size" int size() const;
  public function extern "at" btPointerUid const& at(int n) const;
  public function extern "at" btPointerUid mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btPointerUid const& fillData);
  public function extern "expandNonInitializing" btPointerUid mutable& expandNonInitializing();
  public function extern "expand" btPointerUid mutable& expand_(btPointerUid const& fillValue);
  public function extern "push_back" void push_back(btPointerUid const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btPointerUid const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btPointerUid const& key) const;
  public function extern "remove" void remove(btPointerUid const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btPointerUid const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btPointerUid>::less" "nodefault" btAlignedObjectArray_btPointerUid_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btQuantizedBvhNode>" btAlignedObjectArray_btQuantizedBvhNode {
  public function extern "size" int size() const;
  public function extern "at" btQuantizedBvhNode const& at(int n) const;
  public function extern "at" btQuantizedBvhNode mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btQuantizedBvhNode const& fillData);
  public function extern "expandNonInitializing" btQuantizedBvhNode mutable& expandNonInitializing();
  public function extern "expand" btQuantizedBvhNode mutable& expand_(btQuantizedBvhNode const& fillValue);
  public function extern "push_back" void push_back(btQuantizedBvhNode const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btQuantizedBvhNode const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btQuantizedBvhNode const& key) const;
  public function extern "remove" void remove(btQuantizedBvhNode const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btQuantizedBvhNode const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btQuantizedBvhNode>::less" "nodefault" btAlignedObjectArray_btQuantizedBvhNode_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btRigidBody*>" btAlignedObjectArray_btRigidBody_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btRigidBody} const& at(int n) const;
  public function extern "at" rptr{btRigidBody} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btRigidBody} const& fillData);
  public function extern "expandNonInitializing" rptr{btRigidBody} mutable& expandNonInitializing();
  public function extern "expand" rptr{btRigidBody} mutable& expand_(rptr{btRigidBody} const& fillValue);
  public function extern "push_back" void push_back(rptr{btRigidBody} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btRigidBody} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btRigidBody} const& key) const;
  public function extern "remove" void remove(rptr{btRigidBody} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btRigidBody_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btRigidBody*>::less" "nodefault" btAlignedObjectArray_btRigidBody_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btSolverBody>" btAlignedObjectArray_btSolverBody {
  public function extern "size" int size() const;
  public function extern "at" btSolverBody const& at(int n) const;
  public function extern "at" btSolverBody mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btSolverBody const& fillData);
  public function extern "expandNonInitializing" btSolverBody mutable& expandNonInitializing();
  public function extern "expand" btSolverBody mutable& expand_(btSolverBody const& fillValue);
  public function extern "push_back" void push_back(btSolverBody const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btSolverBody const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btSolverBody const& key) const;
  public function extern "remove" void remove(btSolverBody const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSolverBody const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btSolverBody>::less" "nodefault" btAlignedObjectArray_btSolverBody_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btSolverConstraint>" btAlignedObjectArray_btSolverConstraint {
  public function extern "size" int size() const;
  public function extern "at" btSolverConstraint const& at(int n) const;
  public function extern "at" btSolverConstraint mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btSolverConstraint const& fillData);
  public function extern "expandNonInitializing" btSolverConstraint mutable& expandNonInitializing();
  public function extern "expand" btSolverConstraint mutable& expand_(btSolverConstraint const& fillValue);
  public function extern "push_back" void push_back(btSolverConstraint const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btSolverConstraint const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btSolverConstraint const& key) const;
  public function extern "remove" void remove(btSolverConstraint const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btSolverConstraint const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btSolverConstraint>::less" "nodefault" btAlignedObjectArray_btSolverConstraint_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btTriangleInfo>" btAlignedObjectArray_btTriangleInfo {
  public function extern "size" int size() const;
  public function extern "at" btTriangleInfo const& at(int n) const;
  public function extern "at" btTriangleInfo mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btTriangleInfo const& fillData);
  public function extern "expandNonInitializing" btTriangleInfo mutable& expandNonInitializing();
  public function extern "expand" btTriangleInfo mutable& expand_(btTriangleInfo const& fillValue);
  public function extern "push_back" void push_back(btTriangleInfo const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btTriangleInfo const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btTriangleInfo const& key) const;
  public function extern "remove" void remove(btTriangleInfo const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTriangleInfo const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btTriangleInfo>::less" "nodefault" btAlignedObjectArray_btTriangleInfo_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>" btAlignedObjectArray_btTypedConstraint_btConstraintInfo1 {
  public function extern "size" int size() const;
  public function extern "at" btTypedConstraint_btConstraintInfo1 const& at(int n) const;
  public function extern "at" btTypedConstraint_btConstraintInfo1 mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btTypedConstraint_btConstraintInfo1 const& fillData);
  public function extern "expandNonInitializing" btTypedConstraint_btConstraintInfo1 mutable& expandNonInitializing();
  public function extern "expand" btTypedConstraint_btConstraintInfo1 mutable& expand_(btTypedConstraint_btConstraintInfo1 const& fillValue);
  public function extern "push_back" void push_back(btTypedConstraint_btConstraintInfo1 const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btTypedConstraint_btConstraintInfo1 const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btTypedConstraint_btConstraintInfo1 const& key) const;
  public function extern "remove" void remove(btTypedConstraint_btConstraintInfo1 const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTypedConstraint_btConstraintInfo1 const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::less" "nodefault" btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint*>" btAlignedObjectArray_btTypedConstraint_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{btTypedConstraint} const& at(int n) const;
  public function extern "at" rptr{btTypedConstraint} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{btTypedConstraint} const& fillData);
  public function extern "expandNonInitializing" rptr{btTypedConstraint} mutable& expandNonInitializing();
  public function extern "expand" rptr{btTypedConstraint} mutable& expand_(rptr{btTypedConstraint} const& fillValue);
  public function extern "push_back" void push_back(rptr{btTypedConstraint} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTypedConstraint} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTypedConstraint} const& key) const;
  public function extern "remove" void remove(rptr{btTypedConstraint} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btTypedConstraint_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btTypedConstraint*>::less" "nodefault" btAlignedObjectArray_btTypedConstraint_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btVector3>" btAlignedObjectArray_btVector3 {
  public function extern "size" int size() const;
  public function extern "at" btVector3 const& at(int n) const;
  public function extern "at" btVector3 mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btVector3 const& fillData);
  public function extern "expandNonInitializing" btVector3 mutable& expandNonInitializing();
  public function extern "expand" btVector3 mutable& expand_(btVector3 const& fillValue);
  public function extern "push_back" void push_back(btVector3 const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btVector3 const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btVector3 const& key) const;
  public function extern "remove" void remove(btVector3 const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btVector3 const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btVector3>::less" "nodefault" btAlignedObjectArray_btVector3_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<btWheelInfo>" btAlignedObjectArray_btWheelInfo {
  public function extern "size" int size() const;
  public function extern "at" btWheelInfo const& at(int n) const;
  public function extern "at" btWheelInfo mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, btWheelInfo const& fillData);
  public function extern "expandNonInitializing" btWheelInfo mutable& expandNonInitializing();
  public function extern "expand" btWheelInfo mutable& expand_(btWheelInfo const& fillValue);
  public function extern "push_back" void push_back(btWheelInfo const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(btWheelInfo const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(btWheelInfo const& key) const;
  public function extern "remove" void remove(btWheelInfo const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_btWheelInfo const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<btWheelInfo>::less" "nodefault" btAlignedObjectArray_btWheelInfo_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<char const*>" btAlignedObjectArray_char_const_p {
  public function extern "size" int size() const;
  public function extern "at" crptr{char} const& at(int n) const;
  public function extern "at" crptr{char} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, crptr{char} const& fillData);
  public function extern "expandNonInitializing" crptr{char} mutable& expandNonInitializing();
  public function extern "expand" crptr{char} mutable& expand_(crptr{char} const& fillValue);
  public function extern "push_back" void push_back(crptr{char} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(crptr{char} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(crptr{char} const& key) const;
  public function extern "remove" void remove(crptr{char} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_char_const_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<char const*>::less" "nodefault" btAlignedObjectArray_char_const_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<char*>" btAlignedObjectArray_char_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{char} const& at(int n) const;
  public function extern "at" rptr{char} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{char} const& fillData);
  public function extern "expandNonInitializing" rptr{char} mutable& expandNonInitializing();
  public function extern "expand" rptr{char} mutable& expand_(rptr{char} const& fillValue);
  public function extern "push_back" void push_back(rptr{char} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{char} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{char} const& key) const;
  public function extern "remove" void remove(rptr{char} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_char_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<char*>::less" "nodefault" btAlignedObjectArray_char_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<float>" btAlignedObjectArray_float {
  public function extern "size" int size() const;
  public function extern "at" float const& at(int n) const;
  public function extern "at" float mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, float const& fillData);
  public function extern "expandNonInitializing" float mutable& expandNonInitializing();
  public function extern "expand" float mutable& expand_(float const& fillValue);
  public function extern "push_back" void push_back(float const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(float const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(float const& key) const;
  public function extern "remove" void remove(float const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_float const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<float>::less" "nodefault" btAlignedObjectArray_float_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<int>" btAlignedObjectArray_int {
  public function extern "size" int size() const;
  public function extern "at" int const& at(int n) const;
  public function extern "at" int mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, int const& fillData);
  public function extern "expandNonInitializing" int mutable& expandNonInitializing();
  public function extern "expand" int mutable& expand_(int const& fillValue);
  public function extern "push_back" void push_back(int const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(int const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(int const& key) const;
  public function extern "remove" void remove(int const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_int const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<int>::less" "nodefault" btAlignedObjectArray_int_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<short>" btAlignedObjectArray_short {
  public function extern "size" int size() const;
  public function extern "at" short const& at(int n) const;
  public function extern "at" short mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, short const& fillData);
  public function extern "expandNonInitializing" short mutable& expandNonInitializing();
  public function extern "expand" short mutable& expand_(short const& fillValue);
  public function extern "push_back" void push_back(short const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(short const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(short const& key) const;
  public function extern "remove" void remove(short const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_short const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<short>::less" "nodefault" btAlignedObjectArray_short_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<short*>" btAlignedObjectArray_short_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{short} const& at(int n) const;
  public function extern "at" rptr{short} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{short} const& fillData);
  public function extern "expandNonInitializing" rptr{short} mutable& expandNonInitializing();
  public function extern "expand" rptr{short} mutable& expand_(rptr{short} const& fillValue);
  public function extern "push_back" void push_back(rptr{short} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{short} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{short} const& key) const;
  public function extern "remove" void remove(rptr{short} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_short_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<short*>::less" "nodefault" btAlignedObjectArray_short_p_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<unsigned int>" btAlignedObjectArray_unsigned_int {
  public function extern "size" int size() const;
  public function extern "at" uint const& at(int n) const;
  public function extern "at" uint mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, uint const& fillData);
  public function extern "expandNonInitializing" uint mutable& expandNonInitializing();
  public function extern "expand" uint mutable& expand_(uint const& fillValue);
  public function extern "push_back" void push_back(uint const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(uint const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(uint const& key) const;
  public function extern "remove" void remove(uint const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_unsigned_int const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<unsigned int>::less" "nodefault" btAlignedObjectArray_unsigned_int_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<unsigned short>" btAlignedObjectArray_unsigned_short {
  public function extern "size" int size() const;
  public function extern "at" ushort const& at(int n) const;
  public function extern "at" ushort mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, ushort const& fillData);
  public function extern "expandNonInitializing" ushort mutable& expandNonInitializing();
  public function extern "expand" ushort mutable& expand_(ushort const& fillValue);
  public function extern "push_back" void push_back(ushort const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(ushort const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(ushort const& key) const;
  public function extern "remove" void remove(ushort const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_unsigned_short const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<unsigned short>::less" "nodefault" btAlignedObjectArray_unsigned_short_less private()  {
}
public threaded struct extern "::btAlignedObjectArray<void*>" btAlignedObjectArray_void_p {
  public function extern "size" int size() const;
  public function extern "at" rptr{void} const& at(int n) const;
  public function extern "at" rptr{void} mutable& at1(int n);
  public function extern "clear" void clear();
  public function extern "pop_back" void pop_back();
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize);
  public function extern "resize" void resize(int newsize, rptr{void} const& fillData);
  public function extern "expandNonInitializing" rptr{void} mutable& expandNonInitializing();
  public function extern "expand" rptr{void} mutable& expand_(rptr{void} const& fillValue);
  public function extern "push_back" void push_back(rptr{void} const& _Val);
  public function extern "capacity" int capacity() const;
  public function extern "reserve" void reserve(int _Count);
  public function extern "swap" void swap(int index0, int index1);
  public function extern "findBinarySearch" int findBinarySearch(rptr{void} const& key) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{void} const& key) const;
  public function extern "remove" void remove(rptr{void} const& key);
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer, int size, int capacity);
  public function extern "copyFromArray" void copyFromArray(btAlignedObjectArray_void_p const& otherArray);
}
public threaded struct extern "::btAlignedObjectArray<void*>::less" "nodefault" btAlignedObjectArray_void_p_less private()  {
}
public metafunction btAllocFunc meta::list{rptr{void}, size_t};
public threaded struct extern "::btAngularLimit" btAngularLimit {
  public function extern "set" void set(btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
  public function extern "test" void test(btScalar const angle);
  public function extern "getSoftness" btScalar getSoftness() const;
  public function extern "getBiasFactor" btScalar getBiasFactor() const;
  public function extern "getRelaxationFactor" btScalar getRelaxationFactor() const;
  public function extern "getCorrection" btScalar getCorrection() const;
  public function extern "getSign" btScalar getSign() const;
  public function extern "getHalfRange" btScalar getHalfRange() const;
  public function extern "isLimit" bool isLimit() const;
  public function extern "fit" void fit(btScalar mutable& angle) const;
  public function extern "getError" btScalar getError() const;
  public function extern "getLow" btScalar getLow() const;
  public function extern "getHigh" btScalar getHigh() const;
}
public threaded struct extern "::btAxisSweep3" "nodefault" btAxisSweep3(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, ushort maxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator)  {
  public metafunction __base__ {btAxisSweep3Internal_unsigned_short};
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>" "nodefault" btAxisSweep3Internal_unsigned_int(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, uint handleMask, uint handleSentinel, uint userMaxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator)  {
  public function extern "getNumHandles" uint getNumHandles() const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "addHandle" uint addHandle(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} pOwner, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "removeHandle" void removeHandle(uint handle, rptr{btDispatcher} dispatcher);
  public function extern "updateHandle" void updateHandle(uint handle, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_int_Handle} getHandle(uint index) const;
  public function extern "resetPool" void resetPool(rptr{btDispatcher} _0);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "quantize" void quantize(rptr{uint} out, btVector3 const& point, int isMax) const;
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} getOverlappingPairCache1() const;
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback);
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "printStats" void printStats();
  public metafunction __base__ {btBroadphaseInterface};
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>::Edge" "nodefault" btAxisSweep3Internal_unsigned_int_Edge private()  {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned int>::Handle" "nodefault" btAxisSweep3Internal_unsigned_int_Handle private()  {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>" "nodefault" btAxisSweep3Internal_unsigned_short(btVector3 const& worldAabbMin, btVector3 const& worldAabbMax, ushort handleMask, ushort handleSentinel, ushort userMaxHandles, rptr{btOverlappingPairCache} pairCache, bool disableRaycastAccelerator)  {
  public function extern "getNumHandles" ushort getNumHandles() const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "addHandle" ushort addHandle(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} pOwner, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "removeHandle" void removeHandle(ushort handle, rptr{btDispatcher} dispatcher);
  public function extern "updateHandle" void updateHandle(ushort handle, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_short_Handle} getHandle(ushort index) const;
  public function extern "resetPool" void resetPool(rptr{btDispatcher} _0);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "quantize" void quantize(rptr{ushort} out, btVector3 const& point, int isMax) const;
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} getOverlappingPairCache1() const;
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback);
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "printStats" void printStats();
  public metafunction __base__ {btBroadphaseInterface};
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>::Edge" "nodefault" btAxisSweep3Internal_unsigned_short_Edge private()  {
}
public threaded struct extern "::btAxisSweep3Internal<unsigned short>::Handle" "nodefault" btAxisSweep3Internal_unsigned_short_Handle private()  {
}
public threaded struct extern "::btBU_Simplex1to4" "noncopyable" btBU_Simplex1to4 {
  public function extern "reset" void reset();
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "addVertex" void addVertex(btVector3 const& pt);
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "getIndex" int getIndex(int i) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "getName" crptr{char} getName() const;
  public metafunction __base__ {btPolyhedralConvexAabbCachingShape};
}
public threaded struct extern "::btBlock" btBlock {
  public rptr{btBlock} previous;
  public rptr{uchar} address;
}
public threaded struct extern "::btBoxShape" "nodefault" btBoxShape(btVector3 const& boxHalfExtents)  {
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "getPlaneEquation" void getPlaneEquation(btVector4 mutable& plane, int i) const;
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public metafunction __base__ {btPolyhedralConvexShape};
}
public threaded struct extern "::btBroadphaseAabbCallback" "noncopyable" btBroadphaseAabbCallback {
  public function extern "process" bool process(crptr{btBroadphaseProxy} proxy);
}
public threaded struct extern "::btBroadphaseInterface" "noncopyable" btBroadphaseInterface {
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} getOverlappingPairCache1() const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public function extern "printStats" void printStats();
}
public threaded struct extern "::btBroadphasePair" btBroadphasePair {
  public rptr{btBroadphaseProxy} m_pProxy0;
  public rptr{btBroadphaseProxy} m_pProxy1;
  public rptr{btCollisionAlgorithm} m_algorithm;
}
public metafunction btBroadphasePairArray btAlignedObjectArray_btBroadphasePair;
public threaded struct extern "::btBroadphasePairSortPredicate" btBroadphasePairSortPredicate {
}
/* skip btBroadphasePair_26 : unnamed */
public threaded struct extern "::btBroadphaseProxy" btBroadphaseProxy {
  public rptr{void} m_clientObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
  public function extern "getUid" int getUid() const;
}
public threaded struct extern "::btBroadphaseRayCallback" btBroadphaseRayCallback {
  public btVector3 m_rayDirectionInverse;
  public rawarray{uint, 3} m_signs;
  public btScalar m_lambda_max;
  public metafunction __base__ {btBroadphaseAabbCallback};
}
public threaded struct extern "::btBvhSubtreeInfo" btBvhSubtreeInfo {
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public int m_rootNodeIndex;
  public int m_subtreeSize;
  public rawarray{int, 3} m_padding;
  public function extern "setAabbFromQuantizeNode" void setAabbFromQuantizeNode(btQuantizedBvhNode const& quantizedNode);
}
public threaded struct extern "::btBvhSubtreeInfoData" btBvhSubtreeInfoData {
  public int m_rootNodeIndex;
  public int m_subtreeSize;
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
}
public threaded struct extern "::btBvhTriangleMeshShape" "nodefault" btBvhTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface, bool useQuantizedAabbCompression, bool buildBvh)  {
  public function extern "getOwnsBvh" bool getOwnsBvh() const;
  public function extern "performRaycast" void performRaycast(rptr{btTriangleCallback} callback, btVector3 const& raySource, btVector3 const& rayTarget);
  public function extern "performConvexcast" void performConvexcast(rptr{btTriangleCallback} callback, btVector3 const& boxSource, btVector3 const& boxTarget, btVector3 const& boxMin, btVector3 const& boxMax);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "refitTree" void refitTree(btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "partialRefitTree" void partialRefitTree(btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "getName" crptr{char} getName() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getOptimizedBvh" rptr{btOptimizedBvh} getOptimizedBvh();
  public function extern "setOptimizedBvh" void setOptimizedBvh(rptr{btOptimizedBvh} bvh, btVector3 const& localScaling);
  public function extern "buildOptimizedBvh" void buildOptimizedBvh();
  public function extern "usesQuantizedAabbCompression" bool usesQuantizedAabbCompression() const;
  public function extern "setTriangleInfoMap" void setTriangleInfoMap(rptr{btTriangleInfoMap} triangleInfoMap);
  public function extern "getTriangleInfoMap" crptr{btTriangleInfoMap} getTriangleInfoMap() const;
  public function extern "getTriangleInfoMap" rptr{btTriangleInfoMap} getTriangleInfoMap1();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "serializeSingleBvh" void serializeSingleBvh(rptr{btSerializer} serializer) const;
  public function extern "serializeSingleTriangleInfoMap" void serializeSingleTriangleInfoMap(rptr{btSerializer} serializer) const;
  public metafunction __base__ {btTriangleMeshShape};
}
public threaded struct extern "::btCapsuleShape" "nodefault" btCapsuleShape(btScalar radius, btScalar height)  {
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btConvexInternalShape};
}
public threaded struct extern "::btCapsuleShapeData" btCapsuleShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public int m_upAxis;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btCapsuleShapeX" "nodefault" btCapsuleShapeX(btScalar radius, btScalar height)  {
  public function extern "getName" crptr{char} getName() const;
  public metafunction __base__ {btCapsuleShape};
}
public threaded struct extern "::btCapsuleShapeZ" "nodefault" btCapsuleShapeZ(btScalar radius, btScalar height)  {
  public function extern "getName" crptr{char} getName() const;
  public metafunction __base__ {btCapsuleShape};
}
public threaded struct extern "::btCharIndexTripletData" btCharIndexTripletData {
  public rawarray{uchar, 3} m_values;
  public char m_pad;
}
public threaded struct extern "::btChunk" btChunk {
  public int m_chunkCode;
  public int m_length;
  public rptr{void} m_oldPtr;
  public int m_dna_nr;
  public int m_number;
}
public threaded struct extern "::btClock" btClock {
  public function extern "reset" void reset();
  public function extern "getTimeMilliseconds" uclong getTimeMilliseconds();
  public function extern "getTimeMicroseconds" uclong getTimeMicroseconds();
}
public threaded struct extern "::btClockData" "nodefault" btClockData private()  {
}
public threaded struct extern "::btCollisionAlgorithm" "noncopyable" btCollisionAlgorithm {
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0, rptr{btCollisionObject} body1, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray);
}
public threaded struct extern "::btCollisionAlgorithmConstructionInfo" btCollisionAlgorithmConstructionInfo {
  public rptr{btDispatcher} m_dispatcher1;
  public rptr{btPersistentManifold} m_manifold;
}
public threaded struct extern "::btCollisionAlgorithmCreateFunc" "noncopyable" btCollisionAlgorithmCreateFunc {
  public bool m_swapped;
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap);
}
public threaded struct extern "::btCollisionConfiguration" "noncopyable" btCollisionConfiguration {
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
  public function extern "getStackAllocator" rptr{btStackAlloc} getStackAllocator();
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0, int proxyType1);
}
public threaded struct extern "::btCollisionDispatcher" "nodefault" btCollisionDispatcher(rptr{btCollisionConfiguration} collisionConfiguration)  {
  public function extern "getDispatcherFlags" int getDispatcherFlags() const;
  public function extern "setDispatcherFlags" void setDispatcherFlags(int flags);
  public function extern "registerCollisionCreateFunc" void registerCollisionCreateFunc(int proxyType0, int proxyType1, rptr{btCollisionAlgorithmCreateFunc} createFunc);
  public function extern "getNumManifolds" int getNumManifolds() const;
  public function extern "getInternalManifoldPointer" rptr{rptr{btPersistentManifold}} getInternalManifoldPointer();
  public function extern "getManifoldByIndexInternal" rptr{btPersistentManifold} getManifoldByIndexInternal(int index);
  public function extern "getManifoldByIndexInternal" crptr{btPersistentManifold} getManifoldByIndexInternal1(int index) const;
  public function extern "getNewManifold" rptr{btPersistentManifold} getNewManifold(crptr{btCollisionObject} b0, crptr{btCollisionObject} b1);
  public function extern "releaseManifold" void releaseManifold(rptr{btPersistentManifold} manifold);
  public function extern "clearManifold" void clearManifold(rptr{btPersistentManifold} manifold);
  public function extern "findAlgorithm" rptr{btCollisionAlgorithm} findAlgorithm(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, rptr{btPersistentManifold} sharedManifold);
  public function extern "needsCollision" bool needsCollision(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "needsResponse" bool needsResponse(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "dispatchAllCollisionPairs" void dispatchAllCollisionPairs(rptr{btOverlappingPairCache} pairCache, btDispatcherInfo const& dispatchInfo, rptr{btDispatcher} dispatcher);
  public function extern "setNearCallback" void setNearCallback(btNearCallback nearCallback);
  public function extern "getNearCallback" btNearCallback getNearCallback() const;
  public function extern "allocateCollisionAlgorithm" rptr{void} allocateCollisionAlgorithm(int size);
  public function extern "freeCollisionAlgorithm" void freeCollisionAlgorithm(rptr{void} ptr);
  public function extern "getCollisionConfiguration" rptr{btCollisionConfiguration} getCollisionConfiguration();
  public function extern "getCollisionConfiguration" crptr{btCollisionConfiguration} getCollisionConfiguration1() const;
  public function extern "setCollisionConfiguration" void setCollisionConfiguration(rptr{btCollisionConfiguration} config);
  public function extern "getInternalManifoldPool" rptr{btPoolAllocator} getInternalManifoldPool();
  public function extern "getInternalManifoldPool" crptr{btPoolAllocator} getInternalManifoldPool1() const;
  public metafunction __base__ {btDispatcher};
}
public threaded struct extern "::btCollisionObject" "noncopyable" btCollisionObject {
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction, int frictionMode);
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode) const;
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold);
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape);
  public function extern "getCollisionShape" crptr{btCollisionShape} getCollisionShape() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape1();
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer);
  public function extern "getActivationState" int getActivationState() const;
  public function extern "setActivationState" void setActivationState(int newState) const;
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time);
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "forceActivationState" void forceActivationState(int newState) const;
  public function extern "activate" void activate(bool forceActivation) const;
  public function extern "isActive" bool isActive() const;
  public function extern "setRestitution" void setRestitution(btScalar rest);
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "setFriction" void setFriction(btScalar frict);
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict);
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "getInternalType" int getInternalType() const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& getWorldTransform1() const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans);
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} getBroadphaseHandle1() const;
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle);
  public function extern "getInterpolationWorldTransform" btTransform const& getInterpolationWorldTransform() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform1();
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans);
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel);
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel);
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "setIslandTag" void setIslandTag(int tag);
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "setCompanionId" void setCompanionId(int id);
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction);
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "setCollisionFlags" void setCollisionFlags(int flags);
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius);
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer);
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer) const;
}
public metafunction btCollisionObjectArray btAlignedObjectArray_btCollisionObject_p;
public threaded struct extern "::btCollisionObjectDoubleData" btCollisionObjectDoubleData {
  public rptr{void} m_broadphaseHandle;
  public rptr{void} m_collisionShape;
  public rptr{btCollisionShapeData} m_rootCollisionShape;
  public rptr{char} m_name;
  public btTransformDoubleData m_worldTransform;
  public btTransformDoubleData m_interpolationWorldTransform;
  public btVector3DoubleData m_interpolationLinearVelocity;
  public btVector3DoubleData m_interpolationAngularVelocity;
  public btVector3DoubleData m_anisotropicFriction;
  public double m_contactProcessingThreshold;
  public double m_deactivationTime;
  public double m_friction;
  public double m_rollingFriction;
  public double m_restitution;
  public double m_hitFraction;
  public double m_ccdSweptSphereRadius;
  public double m_ccdMotionThreshold;
  public int m_hasAnisotropicFriction;
  public int m_collisionFlags;
  public int m_islandTag1;
  public int m_companionId;
  public int m_activationState1;
  public int m_internalType;
  public int m_checkCollideWith;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btCollisionObjectFloatData" btCollisionObjectFloatData {
  public rptr{void} m_broadphaseHandle;
  public rptr{void} m_collisionShape;
  public rptr{btCollisionShapeData} m_rootCollisionShape;
  public rptr{char} m_name;
  public btTransformFloatData m_worldTransform;
  public btTransformFloatData m_interpolationWorldTransform;
  public btVector3FloatData m_interpolationLinearVelocity;
  public btVector3FloatData m_interpolationAngularVelocity;
  public btVector3FloatData m_anisotropicFriction;
  public float m_contactProcessingThreshold;
  public float m_deactivationTime;
  public float m_friction;
  public float m_rollingFriction;
  public float m_restitution;
  public float m_hitFraction;
  public float m_ccdSweptSphereRadius;
  public float m_ccdMotionThreshold;
  public int m_hasAnisotropicFriction;
  public int m_collisionFlags;
  public int m_islandTag1;
  public int m_companionId;
  public int m_activationState1;
  public int m_internalType;
  public int m_checkCollideWith;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btCollisionObjectWrapper" "nodefault" btCollisionObjectWrapper(crptr{btCollisionObjectWrapper} parent, crptr{btCollisionShape} shape, crptr{btCollisionObject} collisionObject, btTransform const& worldTransform)  {
  public crptr{btCollisionObjectWrapper} m_parent;
  public crptr{btCollisionShape} m_shape;
  public crptr{btCollisionObject} m_collisionObject;
  /* skip field m_worldTransform */
  public function extern "getWorldTransform" btTransform const& getWorldTransform() const;
  public function extern "getCollisionObject" crptr{btCollisionObject} getCollisionObject() const;
  public function extern "getCollisionShape" crptr{btCollisionShape} getCollisionShape() const;
}
public threaded struct extern "::btCollisionResult" "nodefault" btCollisionResult private()  {
}
public threaded struct extern "::btCollisionShape" "noncopyable" btCollisionShape {
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center, btScalar mutable& radius) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor) const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btVector3 mutable& temporalAabbMin, btVector3 mutable& temporalAabbMax) const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr);
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer) const;
}
public threaded struct extern "::btCollisionShapeData" btCollisionShapeData {
  public rptr{char} m_name;
  public int m_shapeType;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btCollisionWorld" "nodefault" btCollisionWorld(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} broadphasePairCache, rptr{btCollisionConfiguration} collisionConfiguration)  {
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache);
  public function extern "getBroadphase" crptr{btBroadphaseInterface} getBroadphase() const;
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase1();
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getDispatcher" crptr{btDispatcher} getDispatcher1() const;
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj);
  public function extern "updateAabbs" void updateAabbs();
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer);
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform, crptr{btCollisionShape} shape, btVector3 const& color);
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld, btVector3 const& rayToWorld, btCollisionWorld_RayResultCallback mutable& resultCallback) const;
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape, btTransform const& from, btTransform const& to, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedCcdPenetration) const;
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA, rptr{btCollisionObject} colObjB, btCollisionWorld_ContactResultCallback mutable& resultCallback);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject, short collisionFilterGroup, short collisionFilterMask);
  public function extern "getCollisionObjectArray" btCollisionObjectArray mutable& getCollisionObjectArray();
  public function extern "getCollisionObjectArray" btCollisionObjectArray const& getCollisionObjectArray1() const;
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject);
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& getDispatchInfo1() const;
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer);
}
public threaded struct extern "::btCollisionWorld::AllHitsRayResultCallback" "nodefault" btCollisionWorld_AllHitsRayResultCallback(btVector3 const& rayFromWorld, btVector3 const& rayToWorld)  {
  public btAlignedObjectArray_btCollisionObject_const_p m_collisionObjects;
  public btVector3 m_rayFromWorld;
  public btVector3 m_rayToWorld;
  public btAlignedObjectArray_btVector3 m_hitNormalWorld;
  public btAlignedObjectArray_btVector3 m_hitPointWorld;
  public btAlignedObjectArray_float m_hitFractions;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult, bool normalInWorldSpace);
  public metafunction __base__ {btCollisionWorld_RayResultCallback};
}
public threaded struct extern "::btCollisionWorld::ClosestConvexResultCallback" "nodefault" btCollisionWorld_ClosestConvexResultCallback(btVector3 const& convexFromWorld, btVector3 const& convexToWorld)  {
  public btVector3 m_convexFromWorld;
  public btVector3 m_convexToWorld;
  public btVector3 m_hitNormalWorld;
  public btVector3 m_hitPointWorld;
  public crptr{btCollisionObject} m_hitCollisionObject;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalConvexResult mutable& convexResult, bool normalInWorldSpace);
  public metafunction __base__ {btCollisionWorld_ConvexResultCallback};
}
public threaded struct extern "::btCollisionWorld::ClosestRayResultCallback" "nodefault" btCollisionWorld_ClosestRayResultCallback(btVector3 const& rayFromWorld, btVector3 const& rayToWorld)  {
  public btVector3 m_rayFromWorld;
  public btVector3 m_rayToWorld;
  public btVector3 m_hitNormalWorld;
  public btVector3 m_hitPointWorld;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult, bool normalInWorldSpace);
  public metafunction __base__ {btCollisionWorld_RayResultCallback};
}
public threaded struct extern "::btCollisionWorld::ContactResultCallback" "noncopyable" btCollisionWorld_ContactResultCallback {
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public function extern "addSingleResult" btScalar addSingleResult(btManifoldPoint mutable& cp, crptr{btCollisionObjectWrapper} colObj0Wrap, int partId0, int index0, crptr{btCollisionObjectWrapper} colObj1Wrap, int partId1, int index1);
}
public threaded struct extern "::btCollisionWorld::ConvexResultCallback" "noncopyable" btCollisionWorld_ConvexResultCallback {
  public btScalar m_closestHitFraction;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalConvexResult mutable& convexResult, bool normalInWorldSpace);
}
public threaded struct extern "::btCollisionWorld::LocalConvexResult" "nodefault" btCollisionWorld_LocalConvexResult(crptr{btCollisionObject} hitCollisionObject, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo, btVector3 const& hitNormalLocal, btVector3 const& hitPointLocal, btScalar hitFraction)  {
  public crptr{btCollisionObject} m_hitCollisionObject;
  public rptr{btCollisionWorld_LocalShapeInfo} m_localShapeInfo;
  public btVector3 m_hitNormalLocal;
  public btVector3 m_hitPointLocal;
  public btScalar m_hitFraction;
}
public threaded struct extern "::btCollisionWorld::LocalRayResult" "nodefault" btCollisionWorld_LocalRayResult(crptr{btCollisionObject} collisionObject, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo, btVector3 const& hitNormalLocal, btScalar hitFraction)  {
  public crptr{btCollisionObject} m_collisionObject;
  public rptr{btCollisionWorld_LocalShapeInfo} m_localShapeInfo;
  public btVector3 m_hitNormalLocal;
  public btScalar m_hitFraction;
}
public threaded struct extern "::btCollisionWorld::LocalShapeInfo" btCollisionWorld_LocalShapeInfo {
  public int m_shapePart;
  public int m_triangleIndex;
}
public threaded struct extern "::btCollisionWorld::RayResultCallback" "noncopyable" btCollisionWorld_RayResultCallback {
  public btScalar m_closestHitFraction;
  public crptr{btCollisionObject} m_collisionObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public uint m_flags;
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0) const;
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult, bool normalInWorldSpace);
}
public threaded struct extern "::btCompoundShape" "nodefault" btCompoundShape(bool enableDynamicAabbTree)  {
  public function extern "addChildShape" void addChildShape(btTransform const& localTransform, rptr{btCollisionShape} shape);
  public function extern "removeChildShape" void removeChildShape(rptr{btCollisionShape} shape);
  public function extern "removeChildShapeByIndex" void removeChildShapeByIndex(int childShapeindex);
  public function extern "getNumChildShapes" int getNumChildShapes() const;
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index);
  public function extern "getChildShape" crptr{btCollisionShape} getChildShape1(int index) const;
  public function extern "getChildTransform" btTransform mutable& getChildTransform(int index);
  public function extern "getChildTransform" btTransform const& getChildTransform1(int index) const;
  public function extern "updateChildTransform" void updateChildTransform(int childIndex, btTransform const& newChildTransform, bool shouldRecalculateLocalAabb);
  public function extern "getChildList" rptr{btCompoundShapeChild} getChildList();
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "recalculateLocalAabb" void recalculateLocalAabb();
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getDynamicAabbTree" crptr{btDbvt} getDynamicAabbTree() const;
  public function extern "getDynamicAabbTree" rptr{btDbvt} getDynamicAabbTree1();
  public function extern "createAabbTreeFromChildren" void createAabbTreeFromChildren();
  public function extern "calculatePrincipalAxisTransform" void calculatePrincipalAxisTransform(rptr{btScalar} masses, btTransform mutable& principal, btVector3 mutable& inertia) const;
  public function extern "getUpdateRevision" int getUpdateRevision() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btCollisionShape};
}
public threaded struct extern "::btCompoundShapeChild" btCompoundShapeChild {
  public btTransform m_transform;
  public rptr{btCollisionShape} m_childShape;
  public int m_childShapeType;
  public btScalar m_childMargin;
  public rptr{btDbvtNode} m_node;
}
public threaded struct extern "::btCompoundShapeChildData" btCompoundShapeChildData {
  public btTransformFloatData m_transform;
  public rptr{btCollisionShapeData} m_childShape;
  public int m_childShapeType;
  public float m_childMargin;
}
public threaded struct extern "::btCompoundShapeData" btCompoundShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public rptr{btCompoundShapeChildData} m_childShapePtr;
  public int m_numChildShapes;
  public float m_collisionMargin;
}
public threaded struct extern "::btConcaveShape" "noncopyable" btConcaveShape {
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public metafunction __base__ {btCollisionShape};
}
public threaded struct extern "::btConeShape" "nodefault" btConeShape(btScalar radius, btScalar height)  {
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex);
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public metafunction __base__ {btConvexInternalShape};
}
public threaded struct extern "::btConeShapeX" "nodefault" btConeShapeX(btScalar radius, btScalar height)  {
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public metafunction __base__ {btConeShape};
}
public threaded struct extern "::btConeShapeZ" "nodefault" btConeShapeZ(btScalar radius, btScalar height)  {
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public metafunction __base__ {btConeShape};
}
public threaded struct extern "::btConeTwistConstraint" "nodefault" btConeTwistConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& rbAFrame, btTransform const& rbBFrame)  {
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btMatrix3x3 const& invInertiaWorldA, btMatrix3x3 const& invInertiaWorldB);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& bodyA, btSolverBody mutable& bodyB, btScalar timeStep);
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "getRigidBodyA" btRigidBody const& getRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody const& getRigidBodyB() const;
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly);
  public function extern "setLimit" void setLimit(int limitIndex, btScalar limitValue);
  public function extern "setLimit" void setLimit1(btScalar _swingSpan1, btScalar _swingSpan2, btScalar _twistSpan, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
  public function extern "getAFrame" btTransform const& getAFrame();
  public function extern "getBFrame" btTransform const& getBFrame();
  public function extern "getSolveTwistLimit" int getSolveTwistLimit();
  public function extern "getSolveSwingLimit" int getSolveSwingLimit();
  public function extern "getTwistLimitSign" btScalar getTwistLimitSign();
  public function extern "calcAngleInfo" void calcAngleInfo();
  public function extern "calcAngleInfo2" void calcAngleInfo2(btTransform const& transA, btTransform const& transB, btMatrix3x3 const& invInertiaWorldA, btMatrix3x3 const& invInertiaWorldB);
  public function extern "getSwingSpan1" btScalar getSwingSpan1();
  public function extern "getSwingSpan2" btScalar getSwingSpan2();
  public function extern "getTwistSpan" btScalar getTwistSpan();
  public function extern "getTwistAngle" btScalar getTwistAngle();
  public function extern "isPastSwingLimit" bool isPastSwingLimit();
  public function extern "setDamping" void setDamping(btScalar damping);
  public function extern "enableMotor" void enableMotor(bool b);
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse);
  public function extern "setMaxMotorImpulseNormalized" void setMaxMotorImpulseNormalized(btScalar maxMotorImpulse);
  public function extern "getFixThresh" btScalar getFixThresh();
  public function extern "setFixThresh" void setFixThresh(btScalar fixThresh);
  public function extern "setMotorTarget" void setMotorTarget(btQuaternion const& q);
  public function extern "setMotorTargetInConstraintSpace" void setMotorTargetInConstraintSpace(btQuaternion const& q);
  public function extern "GetPointForAngle" btVector3 GetPointForAngle(btScalar fAngleInRadians, btScalar fLength) const;
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "getFrameOffsetA" btTransform const& getFrameOffsetA() const;
  public function extern "getFrameOffsetB" btTransform const& getFrameOffsetB() const;
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btTypedConstraint};
}
public threaded struct extern "::btConeTwistConstraintData" btConeTwistConstraintData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public float m_swingSpan1;
  public float m_swingSpan2;
  public float m_twistSpan;
  public float m_limitSoftness;
  public float m_biasFactor;
  public float m_relaxationFactor;
  public float m_damping;
  public rawarray{char, 4} m_pad;
}
public tsvaluetype struct extern "::btConeTwistFlags" "extenum" btConeTwistFlags { }
public extern "BT_CONETWIST_FLAGS_LIN_CFM" btConeTwistFlags BT_CONETWIST_FLAGS_LIN_CFM;
public extern "BT_CONETWIST_FLAGS_LIN_ERP" btConeTwistFlags BT_CONETWIST_FLAGS_LIN_ERP;
public extern "BT_CONETWIST_FLAGS_ANG_CFM" btConeTwistFlags BT_CONETWIST_FLAGS_ANG_CFM;
public metafunction btConstraintArray btAlignedObjectArray_btSolverConstraint;
public tsvaluetype struct extern "::btConstraintParams" "extenum" btConstraintParams { }
public extern "BT_CONSTRAINT_ERP" btConstraintParams BT_CONSTRAINT_ERP;
public extern "BT_CONSTRAINT_STOP_ERP" btConstraintParams BT_CONSTRAINT_STOP_ERP;
public extern "BT_CONSTRAINT_CFM" btConstraintParams BT_CONSTRAINT_CFM;
public extern "BT_CONSTRAINT_STOP_CFM" btConstraintParams BT_CONSTRAINT_STOP_CFM;
public threaded struct extern "::btConstraintRow" btConstraintRow {
  public rawarray{btScalar, 3} m_normal;
  public btScalar m_rhs;
  public btScalar m_jacDiagInv;
  public btScalar m_lowerLimit;
  public btScalar m_upperLimit;
  public btScalar m_accumImpulse;
}
public threaded struct extern "::btConstraintSetting" btConstraintSetting {
  public btScalar m_tau;
  public btScalar m_damping;
  public btScalar m_impulseClamp;
}
public threaded struct extern "::btConstraintSolver" "noncopyable" btConstraintSolver {
  public function extern "prepareSolve" void prepareSolve(int _0, int _1);
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies, int numBodies, rptr{rptr{btPersistentManifold}} manifold, int numManifolds, rptr{rptr{btTypedConstraint}} constraints, int numConstraints, btContactSolverInfo const& info, rptr{btIDebugDraw} debugDrawer, rptr{btStackAlloc} stackAlloc, rptr{btDispatcher} dispatcher);
  public function extern "allSolved" void allSolved(btContactSolverInfo const& _0, rptr{btIDebugDraw} _1, rptr{btStackAlloc} _2);
  public function extern "reset" void reset();
}
public tsvaluetype struct extern "::btContactManifoldTypes" "extenum" btContactManifoldTypes { }
public extern "MIN_CONTACT_MANIFOLD_TYPE" btContactManifoldTypes MIN_CONTACT_MANIFOLD_TYPE;
public extern "BT_PERSISTENT_MANIFOLD_TYPE" btContactManifoldTypes BT_PERSISTENT_MANIFOLD_TYPE;
public threaded struct extern "::btContactSolverInfo" btContactSolverInfo {
  public metafunction __base__ {btContactSolverInfoData};
}
public threaded struct extern "::btContactSolverInfoData" btContactSolverInfoData {
  public btScalar m_tau;
  public btScalar m_damping;
  public btScalar m_friction;
  public btScalar m_timeStep;
  public btScalar m_restitution;
  public int m_numIterations;
  public btScalar m_maxErrorReduction;
  public btScalar m_sor;
  public btScalar m_erp;
  public btScalar m_erp2;
  public btScalar m_globalCfm;
  public int m_splitImpulse;
  public btScalar m_splitImpulsePenetrationThreshold;
  public btScalar m_splitImpulseTurnErp;
  public btScalar m_linearSlop;
  public btScalar m_warmstartingFactor;
  public int m_solverMode;
  public int m_restingContactRestitutionThreshold;
  public int m_minimumSolverBatchSize;
  public btScalar m_maxGyroscopicForce;
  public btScalar m_singleAxisRollingFrictionThreshold;
}
public threaded struct extern "::btContactSolverInfoDoubleData" btContactSolverInfoDoubleData {
  public double m_tau;
  public double m_damping;
  public double m_friction;
  public double m_timeStep;
  public double m_restitution;
  public double m_maxErrorReduction;
  public double m_sor;
  public double m_erp;
  public double m_erp2;
  public double m_globalCfm;
  public double m_splitImpulsePenetrationThreshold;
  public double m_splitImpulseTurnErp;
  public double m_linearSlop;
  public double m_warmstartingFactor;
  public double m_maxGyroscopicForce;
  public double m_singleAxisRollingFrictionThreshold;
  public int m_numIterations;
  public int m_solverMode;
  public int m_restingContactRestitutionThreshold;
  public int m_minimumSolverBatchSize;
  public int m_splitImpulse;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btContactSolverInfoFloatData" btContactSolverInfoFloatData {
  public float m_tau;
  public float m_damping;
  public float m_friction;
  public float m_timeStep;
  public float m_restitution;
  public float m_maxErrorReduction;
  public float m_sor;
  public float m_erp;
  public float m_erp2;
  public float m_globalCfm;
  public float m_splitImpulsePenetrationThreshold;
  public float m_splitImpulseTurnErp;
  public float m_linearSlop;
  public float m_warmstartingFactor;
  public float m_maxGyroscopicForce;
  public float m_singleAxisRollingFrictionThreshold;
  public int m_numIterations;
  public int m_solverMode;
  public int m_restingContactRestitutionThreshold;
  public int m_minimumSolverBatchSize;
  public int m_splitImpulse;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btConvexHullShape" "nodefault" btConvexHullShape(crptr{btScalar} points, int numPoints, int stride)  {
  public function extern "addPoint" void addPoint(btVector3 const& point);
  public function extern "getUnscaledPoints" rptr{btVector3} getUnscaledPoints();
  public function extern "getUnscaledPoints" crptr{btVector3} getUnscaledPoints1() const;
  public function extern "getPoints" crptr{btVector3} getPoints() const;
  public function extern "getScaledPoint" btVector3 getScaledPoint(int i) const;
  public function extern "getNumPoints" int getNumPoints() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& minProj, btScalar mutable& maxProj, btVector3 mutable& witnesPtMin, btVector3 mutable& witnesPtMax) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btPolyhedralConvexAabbCachingShape};
}
public threaded struct extern "::btConvexHullShapeData" btConvexHullShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rptr{btVector3FloatData} m_unscaledPointsFloatPtr;
  public rptr{btVector3DoubleData} m_unscaledPointsDoublePtr;
  public int m_numUnscaledPoints;
  public rawarray{char, 4} m_padding3;
}
public threaded struct extern "::btConvexInternalAabbCachingShape" "nodefault" btConvexInternalAabbCachingShape private()  {
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public metafunction __base__ {btConvexInternalShape};
}
public threaded struct extern "::btConvexInternalShape" "nodefault" btConvexInternalShape private()  {
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions);
  public function extern "setSafeMargin" void setSafeMargin(btScalar minDimension, btScalar defaultMarginMultiplier);
  public function extern "setSafeMargin" void setSafeMargin1(btVector3 const& halfExtents, btScalar defaultMarginMultiplier);
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btConvexShape};
}
public threaded struct extern "::btConvexInternalShapeData" btConvexInternalShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public btVector3FloatData m_localScaling;
  public btVector3FloatData m_implicitShapeDimensions;
  public float m_collisionMargin;
  public int m_padding;
}
public threaded struct extern "::btConvexPenetrationDepthSolver" "nodefault" btConvexPenetrationDepthSolver private()  {
}
public threaded struct extern "::btConvexPolyhedron" "nodefault" btConvexPolyhedron private()  {
}
public threaded struct extern "::btConvexSeparatingDistanceUtil" "nodefault" btConvexSeparatingDistanceUtil(btScalar boundingRadiusA, btScalar boundingRadiusB)  {
  public function extern "getConservativeSeparatingDistance" btScalar getConservativeSeparatingDistance();
  public function extern "updateSeparatingDistance" void updateSeparatingDistance(btTransform const& transA, btTransform const& transB);
  public function extern "initSeparatingDistance" void initSeparatingDistance(btVector3 const& separatingVector, btScalar separatingDistance, btTransform const& transA, btTransform const& transB);
}
public threaded struct extern "::btConvexShape" "noncopyable" btConvexShape {
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec) const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec) const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "project" void project(btTransform const& trans, btVector3 const& dir, btScalar mutable& min, btScalar mutable& max) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public metafunction __base__ {btCollisionShape};
}
public threaded struct extern "::btConvexTriangleMeshShape" "nodefault" btConvexTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface, bool calcAabb)  {
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} getMeshInterface1() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculatePrincipalAxisTransform" void calculatePrincipalAxisTransform(btTransform mutable& principal, btVector3 mutable& inertia, btScalar mutable& volume) const;
  public metafunction __base__ {btPolyhedralConvexAabbCachingShape};
}
public threaded struct extern "::btCylinderShape" "nodefault" btCylinderShape(btVector3 const& halfExtents)  {
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "setMargin" void setMargin(btScalar collisionMargin);
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getName" crptr{char} getName() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btConvexInternalShape};
}
public threaded struct extern "::btCylinderShapeData" btCylinderShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public int m_upAxis;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btCylinderShapeX" "nodefault" btCylinderShapeX(btVector3 const& halfExtents)  {
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getRadius" btScalar getRadius() const;
  public metafunction __base__ {btCylinderShape};
}
public threaded struct extern "::btCylinderShapeZ" "nodefault" btCylinderShapeZ(btVector3 const& halfExtents)  {
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getRadius" btScalar getRadius() const;
  public metafunction __base__ {btCylinderShape};
}
public threaded struct extern "::btDbvt" "noncopyable" btDbvt {
  public rptr{btDbvtNode} m_root;
  public rptr{btDbvtNode} m_free;
  public int m_lkhd;
  public int m_leaves;
  public uint m_opath;
  public btAlignedObjectArray_btDbvt_sStkNN m_stkStack;
  public btAlignedObjectArray_btDbvtNode_const_p m_rayTestStack;
  public function extern "clear" void clear();
  public function extern "empty" bool empty() const;
  public function extern "optimizeBottomUp" void optimizeBottomUp();
  public function extern "optimizeTopDown" void optimizeTopDown(int bu_treshold);
  public function extern "optimizeIncremental" void optimizeIncremental(int passes);
  public function extern "insert" rptr{btDbvtNode} insert(btDbvtVolume const& box, rptr{void} data);
  public function extern "update" void update(rptr{btDbvtNode} leaf, int lookahead);
  public function extern "update" void update1(rptr{btDbvtNode} leaf, btDbvtVolume mutable& volume);
  public function extern "update" bool update2(rptr{btDbvtNode} leaf, btDbvtVolume mutable& volume, btVector3 const& velocity, btScalar margin);
  public function extern "update" bool update3(rptr{btDbvtNode} leaf, btDbvtVolume mutable& volume, btVector3 const& velocity);
  public function extern "update" bool update4(rptr{btDbvtNode} leaf, btDbvtVolume mutable& volume, btScalar margin);
  public function extern "remove" void remove(rptr{btDbvtNode} leaf);
  public function extern "write" void write(rptr{btDbvt_IWriter} iwriter) const;
  public function extern "clone" void clone(btDbvt mutable& dest, rptr{btDbvt_IClone} iclone) const;
  public function extern "collideTT" void collideTT(crptr{btDbvtNode} root0, crptr{btDbvtNode} root1, btDbvt_ICollide mutable& policy);
  public function extern "collideTTpersistentStack" void collideTTpersistentStack(crptr{btDbvtNode} root0, crptr{btDbvtNode} root1, btDbvt_ICollide mutable& policy);
  public function extern "collideTV" void collideTV(crptr{btDbvtNode} root, btDbvtVolume const& vol, btDbvt_ICollide mutable& policy) const;
  public function extern "rayTestInternal" void rayTestInternal(crptr{btDbvtNode} root, btVector3 const& rayFrom, btVector3 const& rayTo, btVector3 const& rayDirectionInverse, rptr{uint} signs, btScalar lambda_max, btVector3 const& aabbMin, btVector3 const& aabbMax, btDbvt_ICollide mutable& policy) const;
}
public threaded struct extern "::btDbvtAabbMm" btDbvtAabbMm {
  public function extern "Center" btVector3 Center() const;
  public function extern "Lengths" btVector3 Lengths() const;
  public function extern "Extents" btVector3 Extents() const;
  public function extern "Mins" btVector3 const& Mins() const;
  public function extern "Maxs" btVector3 const& Maxs() const;
  public function extern "Expand" void Expand(btVector3 const& e);
  public function extern "SignedExpand" void SignedExpand(btVector3 const& e);
  public function extern "Contain" bool Contain(btDbvtAabbMm const& a) const;
  public function extern "Classify" int Classify(btVector3 const& n, btScalar o, int s) const;
  public function extern "ProjectMinimum" btScalar ProjectMinimum(btVector3 const& v, uint signs) const;
  public function extern "tMins" btVector3 mutable& tMins();
  public function extern "tMaxs" btVector3 mutable& tMaxs();
}
public threaded struct extern "::btDbvtBroadphase" "nodefault" btDbvtBroadphase(rptr{btOverlappingPairCache} paircache)  {
  public rawarray{btDbvt, 2} m_sets;
  public rawarray{rptr{btDbvtProxy}, 3} m_stageRoots;
  public rptr{btOverlappingPairCache} m_paircache;
  public btScalar m_prediction;
  public int m_stageCurrent;
  public int m_fupdates;
  public int m_dupdates;
  public int m_cupdates;
  public int m_newpairs;
  public int m_fixedleft;
  public uint m_updates_call;
  public uint m_updates_done;
  public btScalar m_updates_ratio;
  public int m_pid;
  public int m_cid;
  public int m_gid;
  public bool m_releasepaircache;
  public bool m_deferedcollide;
  public bool m_needcleanup;
  public function extern "collide" void collide(rptr{btDispatcher} dispatcher);
  public function extern "optimize" void optimize();
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} getOverlappingPairCache1() const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "printStats" void printStats();
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public function extern "performDeferredRemoval" void performDeferredRemoval(rptr{btDispatcher} dispatcher);
  public function extern "setVelocityPrediction" void setVelocityPrediction(btScalar prediction);
  public function extern "getVelocityPrediction" btScalar getVelocityPrediction() const;
  public function extern "setAabbForceUpdate" void setAabbForceUpdate(rptr{btBroadphaseProxy} absproxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} _3);
  public metafunction __base__ {btBroadphaseInterface};
}
public threaded struct extern "::btDbvtNode" btDbvtNode {
  public btDbvtVolume volume;
  public rptr{btDbvtNode} parent;
  public function extern "isleaf" bool isleaf() const;
  public function extern "isinternal" bool isinternal() const;
}
/* skip btDbvtNode_29 : unnamed */
public threaded struct extern "::btDbvtProxy" "nodefault" btDbvtProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask)  {
  public rptr{btDbvtNode} leaf;
  public rawarray{rptr{btDbvtProxy}, 2} links;
  public int stage;
  public metafunction __base__ {btBroadphaseProxy};
}
public metafunction btDbvtProxyArray btAlignedObjectArray_btDbvtProxy_p;
public metafunction btDbvtVolume btDbvtAabbMm;
public threaded struct extern "::btDbvt::IClone" "noncopyable" btDbvt_IClone {
  public function extern "CloneLeaf" void CloneLeaf(rptr{btDbvtNode} _0);
}
public threaded struct extern "::btDbvt::ICollide" "noncopyable" btDbvt_ICollide {
  public function extern "Process" void Process(crptr{btDbvtNode} _0, crptr{btDbvtNode} _1);
  public function extern "Process" void Process1(crptr{btDbvtNode} _0);
  public function extern "Process" void Process2(crptr{btDbvtNode} n, btScalar _1);
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
}
public threaded struct extern "::btDbvt::IWriter" "noncopyable" btDbvt_IWriter {
  public function extern "Prepare" void Prepare(crptr{btDbvtNode} root, int numnodes);
  public function extern "WriteNode" void WriteNode(crptr{btDbvtNode} _0, int index, int parent, int child0, int child1);
  public function extern "WriteLeaf" void WriteLeaf(crptr{btDbvtNode} _0, int index, int parent);
}
public threaded struct extern "::btDbvt::sStkCLN" "nodefault" btDbvt_sStkCLN(crptr{btDbvtNode} n, rptr{btDbvtNode} p)  {
  public crptr{btDbvtNode} node;
  public rptr{btDbvtNode} parent;
}
public threaded struct extern "::btDbvt::sStkNN" btDbvt_sStkNN {
  public crptr{btDbvtNode} a;
  public crptr{btDbvtNode} b;
}
public threaded struct extern "::btDbvt::sStkNP" "nodefault" btDbvt_sStkNP(crptr{btDbvtNode} n, uint m)  {
  public crptr{btDbvtNode} node;
  public int mask;
}
public threaded struct extern "::btDbvt::sStkNPS" btDbvt_sStkNPS {
  public crptr{btDbvtNode} node;
  public int mask;
  public btScalar value;
}
public threaded struct extern "::btDefaultCollisionConfiguration" "nodefault" btDefaultCollisionConfiguration(btDefaultCollisionConstructionInfo const& constructionInfo)  {
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
  public function extern "getStackAllocator" rptr{btStackAlloc} getStackAllocator();
  public function extern "getSimplexSolver" rptr{btVoronoiSimplexSolver} getSimplexSolver();
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0, int proxyType1);
  public function extern "setConvexConvexMultipointIterations" void setConvexConvexMultipointIterations(int numPerturbationIterations, int minimumPointsPerturbationThreshold);
  public function extern "setPlaneConvexMultipointIterations" void setPlaneConvexMultipointIterations(int numPerturbationIterations, int minimumPointsPerturbationThreshold);
  public metafunction __base__ {btCollisionConfiguration};
}
public threaded struct extern "::btDefaultCollisionConstructionInfo" btDefaultCollisionConstructionInfo {
  public rptr{btStackAlloc} m_stackAlloc;
  public rptr{btPoolAllocator} m_persistentManifoldPool;
  public rptr{btPoolAllocator} m_collisionAlgorithmPool;
  public int m_defaultMaxPersistentManifoldPoolSize;
  public int m_defaultMaxCollisionAlgorithmPoolSize;
  public int m_customCollisionAlgorithmMaxElementSize;
  public int m_defaultStackAllocatorSize;
  public int m_useEpaPenetrationAlgorithm;
}
public threaded struct extern "::btDefaultMotionState" "nodefault" btDefaultMotionState(btTransform const& startTrans, btTransform const& centerOfMassOffset)  {
  public btTransform m_graphicsWorldTrans;
  public btTransform m_centerOfMassOffset;
  public btTransform m_startWorldTrans;
  public rptr{void} m_userPointer;
  public function extern "getWorldTransform" void getWorldTransform(btTransform mutable& centerOfMassWorldTrans) const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& centerOfMassWorldTrans);
  public metafunction __base__ {btMotionState};
}
public threaded struct extern "::btDefaultSerializer" "nodefault" btDefaultSerializer(int totalSize)  {
  public function extern "writeHeader" void writeHeader(rptr{uchar} buffer) const;
  public function extern "startSerialization" void startSerialization();
  public function extern "finishSerialization" void finishSerialization();
  public function extern "getUniquePointer" rptr{void} getUniquePointer(rptr{void} oldPtr);
  public function extern "getBufferPointer" crptr{uchar} getBufferPointer() const;
  public function extern "getCurrentBufferSize" int getCurrentBufferSize() const;
  public function extern "finalizeChunk" void finalizeChunk(rptr{btChunk} chunk, crptr{char} structType, int chunkCode, rptr{void} oldPtr);
  public function extern "internalAlloc" rptr{uchar} internalAlloc(size_t size);
  public function extern "allocate" rptr{btChunk} allocate(size_t size, int numElements);
  public function extern "findNameForPointer" crptr{char} findNameForPointer(crptr{void} ptr) const;
  public function extern "registerNameForPointer" void registerNameForPointer(crptr{void} ptr, crptr{char} name);
  public function extern "serializeName" void serializeName(crptr{char} name);
  public function extern "getSerializationFlags" int getSerializationFlags() const;
  public function extern "setSerializationFlags" void setSerializationFlags(int flags);
  public metafunction __base__ {btSerializer};
}
public threaded struct extern "::btDefaultVehicleRaycaster" "nodefault" btDefaultVehicleRaycaster(rptr{btDynamicsWorld} world)  {
  public function extern "castRay" rptr{void} castRay(btVector3 const& from, btVector3 const& to, btVehicleRaycaster_btVehicleRaycasterResult mutable& result);
  public metafunction __base__ {btVehicleRaycaster};
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface" "noncopyable" btDiscreteCollisionDetectorInterface {
  public function extern "getClosestPoints" void getClosestPoints(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input, btDiscreteCollisionDetectorInterface_Result mutable& output, rptr{btIDebugDraw} debugDraw, bool swapResults);
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface::ClosestPointInput" btDiscreteCollisionDetectorInterface_ClosestPointInput {
  public btTransform m_transformA;
  public btTransform m_transformB;
  public btScalar m_maximumDistanceSquared;
  public rptr{btStackAlloc} m_stackAlloc;
}
public threaded struct extern "::btDiscreteCollisionDetectorInterface::Result" "noncopyable" btDiscreteCollisionDetectorInterface_Result {
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0, int index0);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1, int index1);
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld, btVector3 const& pointInWorld, btScalar depth);
}
public threaded struct extern "::btDiscreteDynamicsWorld" "nodefault" btDiscreteDynamicsWorld(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} pairCache, rptr{btConstraintSolver} constraintSolver, rptr{btCollisionConfiguration} collisionConfiguration)  {
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep);
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "synchronizeSingleMotionState" void synchronizeSingleMotionState(rptr{btRigidBody} body);
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint, bool disableCollisionsBetweenLinkedBodies);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint);
  public function extern "addAction" void addAction(rptr{btActionInterface} _0);
  public function extern "removeAction" void removeAction(rptr{btActionInterface} _0);
  public function extern "getSimulationIslandManager" rptr{btSimulationIslandManager} getSimulationIslandManager();
  public function extern "getSimulationIslandManager" crptr{btSimulationIslandManager} getSimulationIslandManager1() const;
  public function extern "getCollisionWorld" rptr{btCollisionWorld} getCollisionWorld();
  public function extern "setGravity" void setGravity(btVector3 const& gravity);
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject, short collisionFilterGroup, short collisionFilterMask);
  public function extern "addRigidBody" void addRigidBody(rptr{btRigidBody} body);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body, short group, short mask);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject);
  public function extern "debugDrawConstraint" void debugDrawConstraint(rptr{btTypedConstraint} constraint);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver);
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index);
  public function extern "getConstraint" crptr{btTypedConstraint} getConstraint1(int index) const;
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "clearForces" void clearForces();
  public function extern "applyGravity" void applyGravity();
  public function extern "setNumTasks" void setNumTasks(int numTasks);
  public function extern "updateVehicles" void updateVehicles(btScalar timeStep);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle);
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character);
  public function extern "setSynchronizeAllMotionStates" void setSynchronizeAllMotionStates(bool synchronizeAll);
  public function extern "getSynchronizeAllMotionStates" bool getSynchronizeAllMotionStates() const;
  public function extern "setApplySpeculativeContactRestitution" void setApplySpeculativeContactRestitution(bool enable);
  public function extern "getApplySpeculativeContactRestitution" bool getApplySpeculativeContactRestitution() const;
  public function extern "serialize" void serialize(rptr{btSerializer} serializer);
  public metafunction __base__ {btDynamicsWorld};
}
public threaded struct extern "::btDispatcher" "noncopyable" btDispatcher {
  public function extern "findAlgorithm" rptr{btCollisionAlgorithm} findAlgorithm(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, rptr{btPersistentManifold} sharedManifold);
  public function extern "getNewManifold" rptr{btPersistentManifold} getNewManifold(crptr{btCollisionObject} b0, crptr{btCollisionObject} b1);
  public function extern "releaseManifold" void releaseManifold(rptr{btPersistentManifold} manifold);
  public function extern "clearManifold" void clearManifold(rptr{btPersistentManifold} manifold);
  public function extern "needsCollision" bool needsCollision(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "needsResponse" bool needsResponse(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "dispatchAllCollisionPairs" void dispatchAllCollisionPairs(rptr{btOverlappingPairCache} pairCache, btDispatcherInfo const& dispatchInfo, rptr{btDispatcher} dispatcher);
  public function extern "getNumManifolds" int getNumManifolds() const;
  public function extern "getManifoldByIndexInternal" rptr{btPersistentManifold} getManifoldByIndexInternal(int index);
  public function extern "getInternalManifoldPointer" rptr{rptr{btPersistentManifold}} getInternalManifoldPointer();
  public function extern "getInternalManifoldPool" rptr{btPoolAllocator} getInternalManifoldPool();
  public function extern "getInternalManifoldPool" crptr{btPoolAllocator} getInternalManifoldPool1() const;
  public function extern "allocateCollisionAlgorithm" rptr{void} allocateCollisionAlgorithm(int size);
  public function extern "freeCollisionAlgorithm" void freeCollisionAlgorithm(rptr{void} ptr);
}
public threaded struct extern "::btDispatcherInfo" btDispatcherInfo {
  public btScalar m_timeStep;
  public int m_stepCount;
  public int m_dispatchFunc;
  public btScalar m_timeOfImpact;
  public bool m_useContinuous;
  public rptr{btIDebugDraw} m_debugDraw;
  public bool m_enableSatConvex;
  public bool m_enableSPU;
  public bool m_useEpa;
  public btScalar m_allowedCcdPenetration;
  public bool m_useConvexConservativeDistanceUtil;
  public btScalar m_convexConservativeDistanceThreshold;
  public rptr{btStackAlloc} m_stackAllocator;
}
public threaded struct extern "::btDynamicsWorld" "nodefault" btDynamicsWorld(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} broadphase, rptr{btCollisionConfiguration} collisionConfiguration)  {
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint, bool disableCollisionsBetweenLinkedBodies);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint);
  public function extern "addAction" void addAction(rptr{btActionInterface} action);
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action);
  public function extern "setGravity" void setGravity(btVector3 const& gravity);
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "addRigidBody" void addRigidBody(rptr{btRigidBody} body);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body, short group, short mask);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body);
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver);
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index);
  public function extern "getConstraint" crptr{btTypedConstraint} getConstraint1(int index) const;
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "clearForces" void clearForces();
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb, rptr{void} worldUserInfo, bool isPreTick);
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo);
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle);
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character);
  public metafunction __base__ {btCollisionWorld};
}
public threaded struct extern "::btDynamicsWorldDoubleData" btDynamicsWorldDoubleData {
  public btContactSolverInfoDoubleData m_solverInfo;
  public btVector3DoubleData m_gravity;
}
public threaded struct extern "::btDynamicsWorldFloatData" btDynamicsWorldFloatData {
  public btContactSolverInfoFloatData m_solverInfo;
  public btVector3FloatData m_gravity;
}
public tsvaluetype struct extern "::btDynamicsWorldType" "extenum" btDynamicsWorldType { }
public extern "BT_SIMPLE_DYNAMICS_WORLD" btDynamicsWorldType BT_SIMPLE_DYNAMICS_WORLD;
public extern "BT_DISCRETE_DYNAMICS_WORLD" btDynamicsWorldType BT_DISCRETE_DYNAMICS_WORLD;
public extern "BT_CONTINUOUS_DYNAMICS_WORLD" btDynamicsWorldType BT_CONTINUOUS_DYNAMICS_WORLD;
public extern "BT_SOFT_RIGID_DYNAMICS_WORLD" btDynamicsWorldType BT_SOFT_RIGID_DYNAMICS_WORLD;
public threaded struct extern "::btEmptyShape" "noncopyable" btEmptyShape {
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} _0, btVector3 const& _1, btVector3 const& _2) const;
  public metafunction __base__ {btConcaveShape};
}
public metafunction btFreeFunc meta::list{void, rptr{void}};
public threaded struct extern "::btGearConstraint" "nodefault" btGearConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& axisInA, btVector3 const& axisInB, btScalar ratio)  {
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public metafunction __base__ {btTypedConstraint};
}
public threaded struct extern "::btGeneric6DofConstraint" "nodefault" btGeneric6DofConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA)  {
  public bool m_useSolveConstraintObsolete;
  public function extern "calculateTransforms" void calculateTransforms(btTransform const& transA, btTransform const& transB);
  public function extern "calculateTransforms" void calculateTransforms1();
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "getFrameOffsetA" btTransform const& getFrameOffsetA() const;
  public function extern "getFrameOffsetB" btTransform const& getFrameOffsetB() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA1();
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB1();
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "getAxis" btVector3 getAxis(int axis_index) const;
  public function extern "getAngle" btScalar getAngle(int axis_index) const;
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index) const;
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index);
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower);
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper);
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper);
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower);
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower);
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper);
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper);
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index);
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "setLimit" void setLimit(int axis, btScalar lo, btScalar hi);
  public function extern "isLimited" bool isLimited(int limitIndex);
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btVector3 const& angVelA, btVector3 const& angVelB, rptr{btTypedConstraint_btConstraintInfo2} info, int row, btVector3 mutable& ax1, int rotational, int rotAllowed);
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "setAxis" void setAxis(btVector3 const& axis1, btVector3 const& axis2);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btTypedConstraint};
}
public threaded struct extern "::btGeneric6DofConstraintData" btGeneric6DofConstraintData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public btVector3FloatData m_linearUpperLimit;
  public btVector3FloatData m_linearLowerLimit;
  public btVector3FloatData m_angularUpperLimit;
  public btVector3FloatData m_angularLowerLimit;
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
}
public threaded struct extern "::btGeneric6DofSpringConstraint" "nodefault" btGeneric6DofSpringConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA)  {
  public function extern "enableSpring" void enableSpring(int index, bool onOff);
  public function extern "setStiffness" void setStiffness(int index, btScalar stiffness);
  public function extern "setDamping" void setDamping(int index, btScalar damping);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint();
  public function extern "setEquilibriumPoint" void setEquilibriumPoint1(int index);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint2(int index, btScalar val);
  public function extern "setAxis" void setAxis(btVector3 const& axis1, btVector3 const& axis2);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btGeneric6DofConstraint};
}
public threaded struct extern "::btGeneric6DofSpringConstraintData" btGeneric6DofSpringConstraintData {
  public btGeneric6DofConstraintData m_6dofData;
  public rawarray{int, 6} m_springEnabled;
  public rawarray{float, 6} m_equilibriumPoint;
  public rawarray{float, 6} m_springStiffness;
  public rawarray{float, 6} m_springDamping;
}
public threaded struct extern "::btHashInt" "nodefault" btHashInt(int uid)  {
  public function extern "getUid1" int getUid1() const;
  public function extern "setUid1" void setUid1(int uid);
  public function extern "equals" bool equals(btHashInt const& other) const;
  public function extern "getHash" uint getHash() const;
}
public threaded struct extern "::btHashMap<btHashInt, btTriangleInfo>" btHashMap_btHashInt_btTriangleInfo {
  public function extern "insert" void insert(btHashInt const& key, btTriangleInfo const& value);
  public function extern "remove" void remove(btHashInt const& key);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{btTriangleInfo} getAtIndex(int index) const;
  public function extern "getAtIndex" rptr{btTriangleInfo} getAtIndex1(int index);
  public function extern "find" crptr{btTriangleInfo} find(btHashInt const& key) const;
  public function extern "find" rptr{btTriangleInfo} find1(btHashInt const& key);
  public function extern "findIndex" int findIndex(btHashInt const& key) const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btHashMap<btHashInt, int>" btHashMap_btHashInt_int {
  public function extern "insert" void insert(btHashInt const& key, int const& value);
  public function extern "remove" void remove(btHashInt const& key);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{int} getAtIndex(int index) const;
  public function extern "getAtIndex" rptr{int} getAtIndex1(int index);
  public function extern "find" crptr{int} find(btHashInt const& key) const;
  public function extern "find" rptr{int} find1(btHashInt const& key);
  public function extern "findIndex" int findIndex(btHashInt const& key) const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btHashMap<btHashPtr, btPointerUid>" btHashMap_btHashPtr_btPointerUid {
  public function extern "insert" void insert(btHashPtr const& key, btPointerUid const& value);
  public function extern "remove" void remove(btHashPtr const& key);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{btPointerUid} getAtIndex(int index) const;
  public function extern "getAtIndex" rptr{btPointerUid} getAtIndex1(int index);
  public function extern "find" crptr{btPointerUid} find(btHashPtr const& key) const;
  public function extern "find" rptr{btPointerUid} find1(btHashPtr const& key);
  public function extern "findIndex" int findIndex(btHashPtr const& key) const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btHashMap<btHashPtr, char const*>" btHashMap_btHashPtr_char_const_p {
  public function extern "insert" void insert(btHashPtr const& key, crptr{char} const& value);
  public function extern "remove" void remove(btHashPtr const& key);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{crptr{char}} getAtIndex(int index) const;
  public function extern "getAtIndex" rptr{crptr{char}} getAtIndex1(int index);
  public function extern "find" crptr{crptr{char}} find(btHashPtr const& key) const;
  public function extern "find" rptr{crptr{char}} find1(btHashPtr const& key);
  public function extern "findIndex" int findIndex(btHashPtr const& key) const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btHashMap<btHashPtr, void*>" btHashMap_btHashPtr_void_p {
  public function extern "insert" void insert(btHashPtr const& key, rptr{void} const& value);
  public function extern "remove" void remove(btHashPtr const& key);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{rptr{void}} getAtIndex(int index) const;
  public function extern "getAtIndex" rptr{rptr{void}} getAtIndex1(int index);
  public function extern "find" crptr{rptr{void}} find(btHashPtr const& key) const;
  public function extern "find" rptr{rptr{void}} find1(btHashPtr const& key);
  public function extern "findIndex" int findIndex(btHashPtr const& key) const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btHashMap<btHashString, int>" btHashMap_btHashString_int {
  public function extern "insert" void insert(btHashString const& key, int const& value);
  public function extern "remove" void remove(btHashString const& key);
  public function extern "size" int size() const;
  public function extern "getAtIndex" crptr{int} getAtIndex(int index) const;
  public function extern "getAtIndex" rptr{int} getAtIndex1(int index);
  public function extern "find" crptr{int} find(btHashString const& key) const;
  public function extern "find" rptr{int} find1(btHashString const& key);
  public function extern "findIndex" int findIndex(btHashString const& key) const;
  public function extern "clear" void clear();
}
public threaded struct extern "::btHashPtr" "nodefault" btHashPtr(crptr{void} ptr)  {
  public function extern "getPointer" crptr{void} getPointer() const;
  public function extern "equals" bool equals(btHashPtr const& other) const;
  public function extern "getHash" uint getHash() const;
}
/* skip btHashPtr_27 : unnamed */
public threaded struct extern "::btHashString" "nodefault" btHashString(crptr{char} name)  {
  public crptr{char} m_string;
  public uint m_hash;
  public function extern "getHash" uint getHash() const;
  public function extern "portableStringCompare" int portableStringCompare(crptr{char} src, crptr{char} dst) const;
  public function extern "equals" bool equals(btHashString const& other) const;
}
public threaded struct extern "::btHashedOverlappingPairCache" "noncopyable" btHashedOverlappingPairCache {
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1, rptr{btDispatcher} dispatcher);
  public function extern "needsBroadphaseCollision" bool needsBroadphaseCollision(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1) const;
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher);
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} getOverlappingPairArrayPtr1() const;
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "getOverlappingPairArray" btBroadphasePairArray const& getOverlappingPairArray1() const;
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair, rptr{btDispatcher} dispatcher);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "GetCount" int GetCount() const;
  public function extern "getOverlapFilterCallback" rptr{btOverlapFilterCallback} getOverlapFilterCallback();
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public metafunction __base__ {btOverlappingPairCache};
}
public threaded struct extern "::btHinge2Constraint" "nodefault" btHinge2Constraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 mutable& anchor, btVector3 mutable& axis1, btVector3 mutable& axis2)  {
  public function extern "getAnchor" btVector3 const& getAnchor();
  public function extern "getAnchor2" btVector3 const& getAnchor2();
  public function extern "getAxis1" btVector3 const& getAxis1();
  public function extern "getAxis2" btVector3 const& getAxis2();
  public function extern "getAngle1" btScalar getAngle1();
  public function extern "getAngle2" btScalar getAngle2();
  public function extern "setUpperLimit" void setUpperLimit(btScalar ang1max);
  public function extern "setLowerLimit" void setLowerLimit(btScalar ang1min);
  public metafunction __base__ {btGeneric6DofSpringConstraint};
}
public threaded struct extern "::btHingeConstraint" "nodefault" btHingeConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& pivotInA, btVector3 const& pivotInB, btVector3 const& axisInA, btVector3 const& axisInB, bool useReferenceFrameA)  {
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "getInfo2Internal" void getInfo2Internal(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "getInfo2InternalUsingFrameOffset" void getInfo2InternalUsingFrameOffset(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& angVelA, btVector3 const& angVelB);
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "getRigidBodyA" btRigidBody const& getRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody const& getRigidBodyB() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA1();
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB1();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly);
  public function extern "enableAngularMotor" void enableAngularMotor(bool enableMotor, btScalar targetVelocity, btScalar maxMotorImpulse);
  public function extern "enableMotor" void enableMotor(bool enableMotor);
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse);
  public function extern "setMotorTarget" void setMotorTarget(btQuaternion const& qAinB, btScalar dt);
  public function extern "setMotorTarget" void setMotorTarget1(btScalar targetAngle, btScalar dt);
  public function extern "setLimit" void setLimit(btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
  public function extern "setAxis" void setAxis(btVector3 mutable& axisInA);
  public function extern "getLowerLimit" btScalar getLowerLimit() const;
  public function extern "getUpperLimit" btScalar getUpperLimit() const;
  public function extern "getHingeAngle" btScalar getHingeAngle();
  public function extern "getHingeAngle" btScalar getHingeAngle1(btTransform const& transA, btTransform const& transB);
  public function extern "testLimit" void testLimit(btTransform const& transA, btTransform const& transB);
  public function extern "getAFrame" btTransform const& getAFrame() const;
  public function extern "getBFrame" btTransform const& getBFrame() const;
  public function extern "getAFrame" btTransform mutable& getAFrame1();
  public function extern "getBFrame" btTransform mutable& getBFrame1();
  public function extern "getSolveLimit" int getSolveLimit();
  public function extern "getLimitSign" btScalar getLimitSign();
  public function extern "getAngularOnly" bool getAngularOnly();
  public function extern "getEnableAngularMotor" bool getEnableAngularMotor();
  public function extern "getMotorTargetVelosity" btScalar getMotorTargetVelosity();
  public function extern "getMaxMotorImpulse" btScalar getMaxMotorImpulse();
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btTypedConstraint};
}
public threaded struct extern "::btHingeConstraintDoubleData" btHingeConstraintDoubleData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformDoubleData m_rbAFrame;
  public btTransformDoubleData m_rbBFrame;
  public int m_useReferenceFrameA;
  public int m_angularOnly;
  public int m_enableAngularMotor;
  public float m_motorTargetVelocity;
  public float m_maxMotorImpulse;
  public float m_lowerLimit;
  public float m_upperLimit;
  public float m_limitSoftness;
  public float m_biasFactor;
  public float m_relaxationFactor;
}
public threaded struct extern "::btHingeConstraintFloatData" btHingeConstraintFloatData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public int m_useReferenceFrameA;
  public int m_angularOnly;
  public int m_enableAngularMotor;
  public float m_motorTargetVelocity;
  public float m_maxMotorImpulse;
  public float m_lowerLimit;
  public float m_upperLimit;
  public float m_limitSoftness;
  public float m_biasFactor;
  public float m_relaxationFactor;
}
public tsvaluetype struct extern "::btHingeFlags" "extenum" btHingeFlags { }
public extern "BT_HINGE_FLAGS_CFM_STOP" btHingeFlags BT_HINGE_FLAGS_CFM_STOP;
public extern "BT_HINGE_FLAGS_ERP_STOP" btHingeFlags BT_HINGE_FLAGS_ERP_STOP;
public extern "BT_HINGE_FLAGS_CFM_NORM" btHingeFlags BT_HINGE_FLAGS_CFM_NORM;
public threaded struct extern "::btIDebugDraw" "noncopyable" btIDebugDraw {
  public function extern "drawLine" void drawLine(btVector3 const& from, btVector3 const& to, btVector3 const& color);
  public function extern "drawLine" void drawLine1(btVector3 const& from, btVector3 const& to, btVector3 const& fromColor, btVector3 const& toColor);
  public function extern "drawSphere" void drawSphere(btScalar radius, btTransform const& transform, btVector3 const& color);
  public function extern "drawSphere" void drawSphere1(btVector3 const& p, btScalar radius, btVector3 const& color);
  public function extern "drawTriangle" void drawTriangle(btVector3 const& v0, btVector3 const& v1, btVector3 const& v2, btVector3 const& _3, btVector3 const& _4, btVector3 const& _5, btVector3 const& color, btScalar alpha);
  public function extern "drawTriangle" void drawTriangle1(btVector3 const& v0, btVector3 const& v1, btVector3 const& v2, btVector3 const& color, btScalar _4);
  public function extern "drawContactPoint" void drawContactPoint(btVector3 const& PointOnB, btVector3 const& normalOnB, btScalar distance, int lifeTime, btVector3 const& color);
  public function extern "reportErrorWarning" void reportErrorWarning(crptr{char} warningString);
  public function extern "draw3dText" void draw3dText(btVector3 const& location, crptr{char} textString);
  public function extern "setDebugMode" void setDebugMode(int debugMode);
  public function extern "getDebugMode" int getDebugMode() const;
  public function extern "drawAabb" void drawAabb(btVector3 const& from, btVector3 const& to, btVector3 const& color);
  public function extern "drawTransform" void drawTransform(btTransform const& transform, btScalar orthoLen);
  public function extern "drawArc" void drawArc(btVector3 const& center, btVector3 const& normal, btVector3 const& axis, btScalar radiusA, btScalar radiusB, btScalar minAngle, btScalar maxAngle, btVector3 const& color, bool drawSect, btScalar stepDegrees);
  public function extern "drawSpherePatch" void drawSpherePatch(btVector3 const& center, btVector3 const& up, btVector3 const& axis, btScalar radius, btScalar minTh, btScalar maxTh, btScalar minPs, btScalar maxPs, btVector3 const& color, btScalar stepDegrees);
  public function extern "drawBox" void drawBox(btVector3 const& bbMin, btVector3 const& bbMax, btVector3 const& color);
  public function extern "drawBox" void drawBox1(btVector3 const& bbMin, btVector3 const& bbMax, btTransform const& trans, btVector3 const& color);
  public function extern "drawCapsule" void drawCapsule(btScalar radius, btScalar halfHeight, int upAxis, btTransform const& transform, btVector3 const& color);
  public function extern "drawCylinder" void drawCylinder(btScalar radius, btScalar halfHeight, int upAxis, btTransform const& transform, btVector3 const& color);
  public function extern "drawCone" void drawCone(btScalar radius, btScalar height, int upAxis, btTransform const& transform, btVector3 const& color);
  public function extern "drawPlane" void drawPlane(btVector3 const& planeNormal, btScalar planeConst, btTransform const& transform, btVector3 const& color);
}
public threaded struct extern "::btIndexedMesh" btIndexedMesh {
  public int m_numTriangles;
  public crptr{uchar} m_triangleIndexBase;
  public int m_triangleIndexStride;
  public int m_numVertices;
  public crptr{uchar} m_vertexBase;
  public int m_vertexStride;
  public PHY_ScalarType m_indexType;
  public PHY_ScalarType m_vertexType;
}
public threaded struct extern "::btIntIndexData" btIntIndexData {
  public int m_value;
}
public metafunction btInternalTickCallback rptr{meta::list{void, rptr{btDynamicsWorld}, btScalar}};
public threaded struct extern "::btInternalTriangleIndexCallback" "noncopyable" btInternalTriangleIndexCallback {
  public function extern "internalProcessTriangleIndex" void internalProcessTriangleIndex(rptr{btVector3} triangle, int partId, int triangleIndex);
}
public metafunction btInternalTriangleInfoMap btHashMap_btHashInt_btTriangleInfo;
public threaded struct extern "::btJacobianEntry" btJacobianEntry {
  public btVector3 m_linearJointAxis;
  public btVector3 m_aJ;
  public btVector3 m_bJ;
  public btVector3 m_0MinvJt;
  public btVector3 m_1MinvJt;
  public btScalar m_Adiag;
  public function extern "getDiagonal" btScalar getDiagonal() const;
  public function extern "getNonDiagonal" btScalar getNonDiagonal(btJacobianEntry const& jacB, btScalar const massInvA) const;
  public function extern "getNonDiagonal" btScalar getNonDiagonal1(btJacobianEntry const& jacB, btScalar const massInvA, btScalar const massInvB) const;
  public function extern "getRelativeVelocity" btScalar getRelativeVelocity(btVector3 const& linvelA, btVector3 const& angvelA, btVector3 const& linvelB, btVector3 const& angvelB);
}
public threaded struct extern "::btJointFeedback" btJointFeedback {
  public btVector3 m_appliedForceBodyA;
  public btVector3 m_appliedTorqueBodyA;
  public btVector3 m_appliedForceBodyB;
  public btVector3 m_appliedTorqueBodyB;
}
public metafunction btManifoldArray btAlignedObjectArray_btPersistentManifold_p;
public threaded struct extern "::btManifoldPoint" btManifoldPoint {
  public btVector3 m_localPointA;
  public btVector3 m_localPointB;
  public btVector3 m_positionWorldOnB;
  public btVector3 m_positionWorldOnA;
  public btVector3 m_normalWorldOnB;
  public btScalar m_distance1;
  public btScalar m_combinedFriction;
  public btScalar m_combinedRollingFriction;
  public btScalar m_combinedRestitution;
  public int m_partId0;
  public int m_partId1;
  public int m_index0;
  public int m_index1;
  public rptr{void} m_userPersistentData;
  public bool m_lateralFrictionInitialized;
  public btScalar m_appliedImpulse;
  public btScalar m_appliedImpulseLateral1;
  public btScalar m_appliedImpulseLateral2;
  public btScalar m_contactMotion1;
  public btScalar m_contactMotion2;
  public btScalar m_contactCFM1;
  public btScalar m_contactCFM2;
  public int m_lifeTime;
  public btVector3 m_lateralFrictionDir1;
  public btVector3 m_lateralFrictionDir2;
  public function extern "getDistance" btScalar getDistance() const;
  public function extern "getLifeTime" int getLifeTime() const;
  public function extern "getPositionWorldOnA" btVector3 const& getPositionWorldOnA() const;
  public function extern "getPositionWorldOnB" btVector3 const& getPositionWorldOnB() const;
  public function extern "setDistance" void setDistance(btScalar dist);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
}
public threaded struct extern "::btManifoldResult" "noncopyable" btManifoldResult {
  public function extern "setPersistentManifold" void setPersistentManifold(rptr{btPersistentManifold} manifoldPtr);
  public function extern "getPersistentManifold" crptr{btPersistentManifold} getPersistentManifold() const;
  public function extern "getPersistentManifold" rptr{btPersistentManifold} getPersistentManifold1();
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0, int index0);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1, int index1);
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld, btVector3 const& pointInWorld, btScalar depth);
  public function extern "refreshContactPoints" void refreshContactPoints();
  public function extern "getBody0Wrap" crptr{btCollisionObjectWrapper} getBody0Wrap() const;
  public function extern "getBody1Wrap" crptr{btCollisionObjectWrapper} getBody1Wrap() const;
  public function extern "setBody0Wrap" void setBody0Wrap(crptr{btCollisionObjectWrapper} obj0Wrap);
  public function extern "setBody1Wrap" void setBody1Wrap(crptr{btCollisionObjectWrapper} obj1Wrap);
  public function extern "getBody0Internal" crptr{btCollisionObject} getBody0Internal() const;
  public function extern "getBody1Internal" crptr{btCollisionObject} getBody1Internal() const;
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
}
public threaded struct extern "::btMatrix3x3" btMatrix3x3 {
  public function extern "getColumn" btVector3 getColumn(int i) const;
  public function extern "getRow" btVector3 const& getRow(int i) const;
  public function extern "setFromOpenGLSubMatrix" void setFromOpenGLSubMatrix(crptr{btScalar} m);
  public function extern "setValue" void setValue(btScalar const& xx, btScalar const& xy, btScalar const& xz, btScalar const& yx, btScalar const& yy, btScalar const& yz, btScalar const& zx, btScalar const& zy, btScalar const& zz);
  public function extern "setRotation" void setRotation(btQuaternion const& q);
  public function extern "setEulerYPR" void setEulerYPR(btScalar const& yaw, btScalar const& pitch, btScalar const& roll);
  public function extern "setEulerZYX" void setEulerZYX(btScalar eulerX, btScalar eulerY, btScalar eulerZ);
  public function extern "setIdentity" void setIdentity();
  public function extern "getOpenGLSubMatrix" void getOpenGLSubMatrix(rptr{btScalar} m) const;
  public function extern "getRotation" void getRotation(btQuaternion mutable& q) const;
  public function extern "getEulerYPR" void getEulerYPR(btScalar mutable& yaw, btScalar mutable& pitch, btScalar mutable& roll) const;
  public function extern "getEulerZYX" void getEulerZYX(btScalar mutable& yaw, btScalar mutable& pitch, btScalar mutable& roll, uint solution_number) const;
  public function extern "scaled" btMatrix3x3 scaled(btVector3 const& s) const;
  public function extern "determinant" btScalar determinant() const;
  public function extern "adjoint" btMatrix3x3 adjoint() const;
  public function extern "absolute" btMatrix3x3 absolute() const;
  public function extern "transpose" btMatrix3x3 transpose() const;
  public function extern "inverse" btMatrix3x3 inverse() const;
  public function extern "transposeTimes" btMatrix3x3 transposeTimes(btMatrix3x3 const& m) const;
  public function extern "timesTranspose" btMatrix3x3 timesTranspose(btMatrix3x3 const& m) const;
  public function extern "tdotx" btScalar tdotx(btVector3 const& v) const;
  public function extern "tdoty" btScalar tdoty(btVector3 const& v) const;
  public function extern "tdotz" btScalar tdotz(btVector3 const& v) const;
  public function extern "diagonalize" void diagonalize(btMatrix3x3 mutable& rot, btScalar threshold, int maxSteps);
  public function extern "cofac" btScalar cofac(int r1, int c1, int r2, int c2) const;
  public function extern "serialize" void serialize(btMatrix3x3FloatData mutable& dataOut) const;
  public function extern "serializeFloat" void serializeFloat(btMatrix3x3FloatData mutable& dataOut) const;
  public function extern "deSerialize" void deSerialize(btMatrix3x3FloatData const& dataIn);
  public function extern "deSerializeFloat" void deSerializeFloat(btMatrix3x3FloatData const& dataIn);
  public function extern "deSerializeDouble" void deSerializeDouble(btMatrix3x3DoubleData const& dataIn);
}
public threaded struct extern "::btMatrix3x3DoubleData" btMatrix3x3DoubleData {
  public rawarray{btVector3DoubleData, 3} m_el;
}
public threaded struct extern "::btMatrix3x3FloatData" btMatrix3x3FloatData {
  public rawarray{btVector3FloatData, 3} m_el;
}
public threaded struct extern "::btMeshPartData" btMeshPartData {
  public rptr{btVector3FloatData} m_vertices3f;
  public rptr{btVector3DoubleData} m_vertices3d;
  public rptr{btIntIndexData} m_indices32;
  public rptr{btShortIntIndexTripletData} m_3indices16;
  public rptr{btCharIndexTripletData} m_3indices8;
  public rptr{btShortIntIndexData} m_indices16;
  public int m_numTriangles;
  public int m_numVertices;
}
public threaded struct extern "::btMotionState" "noncopyable" btMotionState {
  public function extern "getWorldTransform" void getWorldTransform(btTransform mutable& worldTrans) const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans);
}
public threaded struct extern "::btMultiSapBroadphase" "nodefault" btMultiSapBroadphase(int maxProxies, rptr{btOverlappingPairCache} pairCache)  {
  public function extern "getBroadphaseArray" btSapBroadphaseArray mutable& getBroadphaseArray();
  public function extern "getBroadphaseArray" btSapBroadphaseArray const& getBroadphaseArray1() const;
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "addToChildBroadphase" void addToChildBroadphase(rptr{btMultiSapBroadphase_btMultiSapProxy} parentMultiSapProxy, rptr{btBroadphaseProxy} childProxy, rptr{btBroadphaseInterface} childBroadphase);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} getOverlappingPairCache1() const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "buildTree" void buildTree(btVector3 const& bvhAabbMin, btVector3 const& bvhAabbMax);
  public function extern "printStats" void printStats();
  public function extern "quicksort" void quicksort(btBroadphasePairArray mutable& a, int lo, int hi);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher);
  public metafunction __base__ {btBroadphaseInterface};
}
public threaded struct extern "::btMultiSapBroadphase::btBridgeProxy" "nodefault" btMultiSapBroadphase_btBridgeProxy private()  {
}
public threaded struct extern "::btMultiSapBroadphase::btMultiSapProxy" "nodefault" btMultiSapBroadphase_btMultiSapProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask)  {
  public btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p m_bridgeProxies;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
  public int m_shapeType;
  public metafunction __base__ {btBroadphaseProxy};
}
public threaded struct extern "::btMultiSphereShape" "nodefault" btMultiSphereShape(crptr{btVector3} positions, crptr{btScalar} radi, int numSpheres)  {
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "getSphereCount" int getSphereCount() const;
  public function extern "getSpherePosition" btVector3 const& getSpherePosition(int index) const;
  public function extern "getSphereRadius" btScalar getSphereRadius(int index) const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btConvexInternalAabbCachingShape};
}
public threaded struct extern "::btMultiSphereShapeData" btMultiSphereShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rptr{btPositionAndRadius} m_localPositionArrayPtr;
  public int m_localPositionArraySize;
  public rawarray{char, 4} m_padding;
}
public metafunction btNearCallback rptr{meta::list{void, rawref{btBroadphasePair}, rawref{btCollisionDispatcher}, crawref{btDispatcherInfo}}};
public threaded struct extern "::btNodeOverlapCallback" "noncopyable" btNodeOverlapCallback {
  public function extern "processNode" void processNode(int subPart, int triangleIndex);
}
public threaded struct extern "::btNullPairCache" "noncopyable" btNullPairCache {
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} getOverlappingPairArrayPtr1() const;
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& _0, rptr{btDispatcher} _1);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} _0, rptr{btDispatcher} _1);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} _0);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} _1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1);
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} _0);
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} _0, rptr{btBroadphaseProxy} _1, rptr{btDispatcher} _2);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} _0, rptr{btDispatcher} _1);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher);
  public metafunction __base__ {btOverlappingPairCache};
}
public threaded struct extern "::btOptimizedBvh" "noncopyable" btOptimizedBvh {
  public function extern "build" void build(rptr{btStridingMeshInterface} triangles, bool useQuantizedAabbCompression, btVector3 const& bvhAabbMin, btVector3 const& bvhAabbMax);
  public function extern "refit" void refit(rptr{btStridingMeshInterface} triangles, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "refitPartial" void refitPartial(rptr{btStridingMeshInterface} triangles, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "updateBvhNodes" void updateBvhNodes(rptr{btStridingMeshInterface} meshInterface, int firstNode, int endNode, int index);
  public function extern "serializeInPlace" bool serializeInPlace(rptr{void} o_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian) const;
  public metafunction __base__ {btQuantizedBvh};
}
public threaded struct extern "::btOptimizedBvhNode" btOptimizedBvhNode {
  public btVector3 m_aabbMinOrg;
  public btVector3 m_aabbMaxOrg;
  public int m_escapeIndex;
  public int m_subPart;
  public int m_triangleIndex;
  public rawarray{char, 20} m_padding;
}
public threaded struct extern "::btOptimizedBvhNodeDoubleData" btOptimizedBvhNodeDoubleData {
  public btVector3DoubleData m_aabbMinOrg;
  public btVector3DoubleData m_aabbMaxOrg;
  public int m_escapeIndex;
  public int m_subPart;
  public int m_triangleIndex;
  public rawarray{char, 4} m_pad;
}
public threaded struct extern "::btOptimizedBvhNodeFloatData" btOptimizedBvhNodeFloatData {
  public btVector3FloatData m_aabbMinOrg;
  public btVector3FloatData m_aabbMaxOrg;
  public int m_escapeIndex;
  public int m_subPart;
  public int m_triangleIndex;
  public rawarray{char, 4} m_pad;
}
public threaded struct extern "::btOverlapCallback" "noncopyable" btOverlapCallback {
  public function extern "processOverlap" bool processOverlap(btBroadphasePair mutable& pair);
}
public threaded struct extern "::btOverlapFilterCallback" "noncopyable" btOverlapFilterCallback {
  public function extern "needBroadphaseCollision" bool needBroadphaseCollision(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1) const;
}
public threaded struct extern "::btOverlappingPairCache" "noncopyable" btOverlappingPairCache {
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} getOverlappingPairArrayPtr1() const;
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair, rptr{btDispatcher} dispatcher);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback);
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher);
  public metafunction __base__ {btOverlappingPairCallback};
}
public threaded struct extern "::btOverlappingPairCallback" "noncopyable" btOverlappingPairCallback {
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1, rptr{btDispatcher} dispatcher);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0, rptr{btDispatcher} dispatcher);
}
public threaded struct extern "::btPersistentManifold" btPersistentManifold {
  public int m_companionIdA;
  public int m_companionIdB;
  public int m_index1a;
  public function extern "getBody0" crptr{btCollisionObject} getBody0() const;
  public function extern "getBody1" crptr{btCollisionObject} getBody1() const;
  public function extern "setBodies" void setBodies(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
  public function extern "clearUserCache" void clearUserCache(btManifoldPoint mutable& pt);
  public function extern "getNumContacts" int getNumContacts() const;
  public function extern "setNumContacts" void setNumContacts(int cachedPoints);
  public function extern "getContactPoint" btManifoldPoint const& getContactPoint(int index) const;
  public function extern "getContactPoint" btManifoldPoint mutable& getContactPoint1(int index);
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold() const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "setContactBreakingThreshold" void setContactBreakingThreshold(btScalar contactBreakingThreshold);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold);
  public function extern "getCacheEntry" int getCacheEntry(btManifoldPoint const& newPoint) const;
  public function extern "addManifoldPoint" int addManifoldPoint(btManifoldPoint const& newPoint, bool isPredictive);
  public function extern "removeContactPoint" void removeContactPoint(int index);
  public function extern "replaceContactPoint" void replaceContactPoint(btManifoldPoint const& newPoint, int insertIndex);
  public function extern "validContactDistance" bool validContactDistance(btManifoldPoint const& pt) const;
  public function extern "refreshContactPoints" void refreshContactPoints(btTransform const& trA, btTransform const& trB);
  public function extern "clearManifold" void clearManifold();
  public metafunction __base__ {btTypedObject};
}
public threaded struct extern "::btPoint2PointConstraint" "nodefault" btPoint2PointConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& pivotInA, btVector3 const& pivotInB)  {
  public bool m_useSolveConstraintObsolete;
  public btConstraintSetting m_setting;
  public function extern "buildJacobian" void buildJacobian();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& body0_trans, btTransform const& body1_trans);
  public function extern "updateRHS" void updateRHS(btScalar timeStep);
  public function extern "setPivotA" void setPivotA(btVector3 const& pivotA);
  public function extern "setPivotB" void setPivotB(btVector3 const& pivotB);
  public function extern "getPivotInA" btVector3 const& getPivotInA() const;
  public function extern "getPivotInB" btVector3 const& getPivotInB() const;
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btTypedConstraint};
}
public threaded struct extern "::btPoint2PointConstraintDoubleData" btPoint2PointConstraintDoubleData {
  public btTypedConstraintData m_typeConstraintData;
  public btVector3DoubleData m_pivotInA;
  public btVector3DoubleData m_pivotInB;
}
public threaded struct extern "::btPoint2PointConstraintFloatData" btPoint2PointConstraintFloatData {
  public btTypedConstraintData m_typeConstraintData;
  public btVector3FloatData m_pivotInA;
  public btVector3FloatData m_pivotInB;
}
public tsvaluetype struct extern "::btPoint2PointFlags" "extenum" btPoint2PointFlags { }
public extern "BT_P2P_FLAGS_ERP" btPoint2PointFlags BT_P2P_FLAGS_ERP;
public extern "BT_P2P_FLAGS_CFM" btPoint2PointFlags BT_P2P_FLAGS_CFM;
public threaded struct extern "::btPointerUid" btPointerUid {
}
/* skip btPointerUid_28 : unnamed */
public threaded struct extern "::btPolyhedralConvexAabbCachingShape" "noncopyable" btPolyhedralConvexAabbCachingShape {
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax, btScalar margin) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public metafunction __base__ {btPolyhedralConvexShape};
}
public threaded struct extern "::btPolyhedralConvexShape" "noncopyable" btPolyhedralConvexShape {
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin);
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getEdge" void getEdge(int i, btVector3 mutable& pa, btVector3 mutable& pb) const;
  public function extern "getVertex" void getVertex(int i, btVector3 mutable& vtx) const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal, btVector3 mutable& planeSupport, int i) const;
  public function extern "isInside" bool isInside(btVector3 const& pt, btScalar tolerance) const;
  public metafunction __base__ {btConvexInternalShape};
}
public threaded struct extern "::btPoolAllocator" "nodefault" btPoolAllocator private()  {
}
public threaded struct extern "::btPositionAndRadius" btPositionAndRadius {
  public btVector3FloatData m_pos;
  public float m_radius;
}
public threaded struct extern "::btQuadWord" btQuadWord {
  public function extern "getX" btScalar const& getX() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "setX" void setX(btScalar _x);
  public function extern "setY" void setY(btScalar _y);
  public function extern "setZ" void setZ(btScalar _z);
  public function extern "setW" void setW(btScalar _w);
  public function extern "x" btScalar const& x() const;
  public function extern "y" btScalar const& y() const;
  public function extern "z" btScalar const& z() const;
  public function extern "w" btScalar const& w() const;
  public function extern "setValue" void setValue(btScalar const& _x, btScalar const& _y, btScalar const& _z);
  public function extern "setValue" void setValue1(btScalar const& _x, btScalar const& _y, btScalar const& _z, btScalar const& _w);
  public function extern "setMax" void setMax(btQuadWord const& other);
  public function extern "setMin" void setMin(btQuadWord const& other);
}
public threaded struct extern "::btQuantizedBvh" "noncopyable" btQuantizedBvh {
  public function extern "setQuantizationValues" void setQuantizationValues(btVector3 const& bvhAabbMin, btVector3 const& bvhAabbMax, btScalar quantizationMargin);
  public function extern "getLeafNodeArray" QuantizedNodeArray mutable& getLeafNodeArray();
  public function extern "buildInternal" void buildInternal();
  public function extern "reportAabbOverlappingNodex" void reportAabbOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "reportRayOverlappingNodex" void reportRayOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& raySource, btVector3 const& rayTarget) const;
  public function extern "reportBoxCastOverlappingNodex" void reportBoxCastOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback, btVector3 const& raySource, btVector3 const& rayTarget, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "quantize" void quantize(rptr{ushort} out, btVector3 const& point, int isMax) const;
  public function extern "quantizeWithClamp" void quantizeWithClamp(rptr{ushort} out, btVector3 const& point2, int isMax) const;
  public function extern "unQuantize" btVector3 unQuantize(crptr{ushort} vecIn) const;
  public function extern "setTraversalMode" void setTraversalMode(btTraversalMode traversalMode);
  public function extern "getQuantizedNodeArray" QuantizedNodeArray mutable& getQuantizedNodeArray();
  public function extern "getSubtreeInfoArray" BvhSubtreeInfoArray mutable& getSubtreeInfoArray();
  public function extern "calculateSerializeBufferSize" uint calculateSerializeBufferSize() const;
  public function extern "serialize" bool serialize(rptr{void} o_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian) const;
  public function extern "calculateSerializeBufferSizeNew" int calculateSerializeBufferSizeNew() const;
  public function extern "serialize" crptr{char} serialize1(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "deSerializeFloat" void deSerializeFloat(btQuantizedBvhFloatData mutable& quantizedBvhFloatData);
  public function extern "deSerializeDouble" void deSerializeDouble(btQuantizedBvhDoubleData mutable& quantizedBvhDoubleData);
  public function extern "isQuantized" bool isQuantized();
}
public threaded struct extern "::btQuantizedBvhDoubleData" btQuantizedBvhDoubleData {
  public btVector3DoubleData m_bvhAabbMin;
  public btVector3DoubleData m_bvhAabbMax;
  public btVector3DoubleData m_bvhQuantization;
  public int m_curNodeIndex;
  public int m_useQuantization;
  public int m_numContiguousLeafNodes;
  public int m_numQuantizedContiguousNodes;
  public rptr{btOptimizedBvhNodeDoubleData} m_contiguousNodesPtr;
  public rptr{btQuantizedBvhNodeData} m_quantizedContiguousNodesPtr;
  public int m_traversalMode;
  public int m_numSubtreeHeaders;
  public rptr{btBvhSubtreeInfoData} m_subTreeInfoPtr;
}
public threaded struct extern "::btQuantizedBvhFloatData" btQuantizedBvhFloatData {
  public btVector3FloatData m_bvhAabbMin;
  public btVector3FloatData m_bvhAabbMax;
  public btVector3FloatData m_bvhQuantization;
  public int m_curNodeIndex;
  public int m_useQuantization;
  public int m_numContiguousLeafNodes;
  public int m_numQuantizedContiguousNodes;
  public rptr{btOptimizedBvhNodeFloatData} m_contiguousNodesPtr;
  public rptr{btQuantizedBvhNodeData} m_quantizedContiguousNodesPtr;
  public rptr{btBvhSubtreeInfoData} m_subTreeInfoPtr;
  public int m_traversalMode;
  public int m_numSubtreeHeaders;
}
public threaded struct extern "::btQuantizedBvhNode" btQuantizedBvhNode {
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public int m_escapeIndexOrTriangleIndex;
  public function extern "isLeafNode" bool isLeafNode() const;
  public function extern "getEscapeIndex" int getEscapeIndex() const;
  public function extern "getTriangleIndex" int getTriangleIndex() const;
  public function extern "getPartId" int getPartId() const;
}
public threaded struct extern "::btQuantizedBvhNodeData" btQuantizedBvhNodeData {
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public int m_escapeIndexOrTriangleIndex;
}
public threaded struct extern "::btQuaternion" btQuaternion {
  public function extern "setRotation" void setRotation(btVector3 const& axis, btScalar const& _angle);
  public function extern "setEuler" void setEuler(btScalar const& yaw, btScalar const& pitch, btScalar const& roll);
  public function extern "setEulerZYX" void setEulerZYX(btScalar const& yaw, btScalar const& pitch, btScalar const& roll);
  public function extern "dot" btScalar dot(btQuaternion const& q) const;
  public function extern "length2" btScalar length2() const;
  public function extern "length" btScalar length() const;
  public function extern "normalize" btQuaternion mutable& normalize();
  public function extern "normalized" btQuaternion normalized() const;
  public function extern "angle" btScalar angle(btQuaternion const& q) const;
  public function extern "getAngle" btScalar getAngle() const;
  public function extern "getAxis" btVector3 getAxis() const;
  public function extern "inverse" btQuaternion inverse() const;
  public function extern "farthest" btQuaternion farthest(btQuaternion const& qd) const;
  public function extern "nearest" btQuaternion nearest(btQuaternion const& qd) const;
  public function extern "slerp" btQuaternion slerp(btQuaternion const& q, btScalar const& t) const;
  public function extern "getW" btScalar const& getW() const;
  public metafunction __base__ {btQuadWord};
}
public threaded struct extern "::btRaycastVehicle" "nodefault" btRaycastVehicle(btRaycastVehicle_btVehicleTuning const& tuning, rptr{btRigidBody} chassis, rptr{btVehicleRaycaster} raycaster)  {
  public btAlignedObjectArray_btWheelInfo m_wheelInfo;
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld, btScalar step);
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer);
  public function extern "getChassisWorldTransform" btTransform const& getChassisWorldTransform() const;
  public function extern "rayCast" btScalar rayCast(btWheelInfo mutable& wheel);
  public function extern "updateVehicle" void updateVehicle(btScalar step);
  public function extern "resetSuspension" void resetSuspension();
  public function extern "getSteeringValue" btScalar getSteeringValue(int wheel) const;
  public function extern "setSteeringValue" void setSteeringValue(btScalar steering, int wheel);
  public function extern "applyEngineForce" void applyEngineForce(btScalar force, int wheel);
  public function extern "getWheelTransformWS" btTransform const& getWheelTransformWS(int wheelIndex) const;
  public function extern "updateWheelTransform" void updateWheelTransform(int wheelIndex, bool interpolatedTransform);
  public function extern "addWheel" btWheelInfo mutable& addWheel(btVector3 const& connectionPointCS0, btVector3 const& wheelDirectionCS0, btVector3 const& wheelAxleCS, btScalar suspensionRestLength, btScalar wheelRadius, btRaycastVehicle_btVehicleTuning const& tuning, bool isFrontWheel);
  public function extern "getNumWheels" int getNumWheels() const;
  public function extern "getWheelInfo" btWheelInfo const& getWheelInfo(int index) const;
  public function extern "getWheelInfo" btWheelInfo mutable& getWheelInfo1(int index);
  public function extern "updateWheelTransformsWS" void updateWheelTransformsWS(btWheelInfo mutable& wheel, bool interpolatedTransform);
  public function extern "setBrake" void setBrake(btScalar brake, int wheelIndex);
  public function extern "setPitchControl" void setPitchControl(btScalar pitch);
  public function extern "updateSuspension" void updateSuspension(btScalar deltaTime);
  public function extern "updateFriction" void updateFriction(btScalar timeStep);
  public function extern "getRigidBody" rptr{btRigidBody} getRigidBody();
  public function extern "getRigidBody" crptr{btRigidBody} getRigidBody1() const;
  public function extern "getRightAxis" int getRightAxis() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getForwardAxis" int getForwardAxis() const;
  public function extern "getForwardVector" btVector3 getForwardVector() const;
  public function extern "getCurrentSpeedKmHour" btScalar getCurrentSpeedKmHour() const;
  public function extern "setCoordinateSystem" void setCoordinateSystem(int rightIndex, int upIndex, int forwardIndex);
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public metafunction __base__ {btActionInterface};
}
public threaded struct extern "::btRaycastVehicle::btVehicleTuning" btRaycastVehicle_btVehicleTuning {
  public btScalar m_suspensionStiffness;
  public btScalar m_suspensionCompression;
  public btScalar m_suspensionDamping;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_frictionSlip;
  public btScalar m_maxSuspensionForce;
}
public threaded struct extern "::btRigidBody" "nodefault" btRigidBody(btRigidBody_btRigidBodyConstructionInfo const& constructionInfo)  {
  public int m_contactSolverType;
  public int m_frictionSolverType;
  public function extern "proceedToTransform" void proceedToTransform(btTransform const& newTrans);
  public function extern "predictIntegratedTransform" void predictIntegratedTransform(btScalar step, btTransform mutable& predictedTransform);
  public function extern "saveKinematicState" void saveKinematicState(btScalar step);
  public function extern "applyGravity" void applyGravity();
  public function extern "setGravity" void setGravity(btVector3 const& acceleration);
  public function extern "getGravity" btVector3 const& getGravity() const;
  public function extern "setDamping" void setDamping(btScalar lin_damping, btScalar ang_damping);
  public function extern "getLinearDamping" btScalar getLinearDamping() const;
  public function extern "getAngularDamping" btScalar getAngularDamping() const;
  public function extern "getLinearSleepingThreshold" btScalar getLinearSleepingThreshold() const;
  public function extern "getAngularSleepingThreshold" btScalar getAngularSleepingThreshold() const;
  public function extern "applyDamping" void applyDamping(btScalar timeStep);
  public function extern "getCollisionShape" crptr{btCollisionShape} getCollisionShape() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape1();
  public function extern "setMassProps" void setMassProps(btScalar mass, btVector3 const& inertia);
  public function extern "getLinearFactor" btVector3 const& getLinearFactor() const;
  public function extern "setLinearFactor" void setLinearFactor(btVector3 const& linearFactor);
  public function extern "getInvMass" btScalar getInvMass() const;
  public function extern "getInvInertiaTensorWorld" btMatrix3x3 const& getInvInertiaTensorWorld() const;
  public function extern "integrateVelocities" void integrateVelocities(btScalar step);
  public function extern "setCenterOfMassTransform" void setCenterOfMassTransform(btTransform const& xform);
  public function extern "applyCentralForce" void applyCentralForce(btVector3 const& force);
  public function extern "getTotalForce" btVector3 const& getTotalForce() const;
  public function extern "getTotalTorque" btVector3 const& getTotalTorque() const;
  public function extern "getInvInertiaDiagLocal" btVector3 const& getInvInertiaDiagLocal() const;
  public function extern "setInvInertiaDiagLocal" void setInvInertiaDiagLocal(btVector3 const& diagInvInertia);
  public function extern "setSleepingThresholds" void setSleepingThresholds(btScalar linear, btScalar angular);
  public function extern "applyTorque" void applyTorque(btVector3 const& torque);
  public function extern "applyForce" void applyForce(btVector3 const& force, btVector3 const& rel_pos);
  public function extern "applyCentralImpulse" void applyCentralImpulse(btVector3 const& impulse);
  public function extern "applyTorqueImpulse" void applyTorqueImpulse(btVector3 const& torque);
  public function extern "applyImpulse" void applyImpulse(btVector3 const& impulse, btVector3 const& rel_pos);
  public function extern "clearForces" void clearForces();
  public function extern "updateInertiaTensor" void updateInertiaTensor();
  public function extern "getCenterOfMassPosition" btVector3 const& getCenterOfMassPosition() const;
  public function extern "getOrientation" btQuaternion getOrientation() const;
  public function extern "getCenterOfMassTransform" btTransform const& getCenterOfMassTransform() const;
  public function extern "getLinearVelocity" btVector3 const& getLinearVelocity() const;
  public function extern "getAngularVelocity" btVector3 const& getAngularVelocity() const;
  public function extern "setLinearVelocity" void setLinearVelocity(btVector3 const& lin_vel);
  public function extern "setAngularVelocity" void setAngularVelocity(btVector3 const& ang_vel);
  public function extern "getVelocityInLocalPoint" btVector3 getVelocityInLocalPoint(btVector3 const& rel_pos) const;
  public function extern "translate" void translate(btVector3 const& v);
  public function extern "getAabb" void getAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "computeImpulseDenominator" btScalar computeImpulseDenominator(btVector3 const& pos, btVector3 const& normal) const;
  public function extern "computeAngularImpulseDenominator" btScalar computeAngularImpulseDenominator(btVector3 const& axis) const;
  public function extern "updateDeactivation" void updateDeactivation(btScalar timeStep);
  public function extern "wantsSleeping" bool wantsSleeping();
  public function extern "getBroadphaseProxy" crptr{btBroadphaseProxy} getBroadphaseProxy() const;
  public function extern "getBroadphaseProxy" rptr{btBroadphaseProxy} getBroadphaseProxy1();
  public function extern "setNewBroadphaseProxy" void setNewBroadphaseProxy(rptr{btBroadphaseProxy} broadphaseProxy);
  public function extern "getMotionState" rptr{btMotionState} getMotionState();
  public function extern "getMotionState" crptr{btMotionState} getMotionState1() const;
  public function extern "setMotionState" void setMotionState(rptr{btMotionState} motionState);
  public function extern "setAngularFactor" void setAngularFactor(btVector3 const& angFac);
  public function extern "setAngularFactor" void setAngularFactor1(btScalar angFac);
  public function extern "getAngularFactor" btVector3 const& getAngularFactor() const;
  public function extern "isInWorld" bool isInWorld() const;
  public function extern "checkCollideWithOverride" bool checkCollideWithOverride(crptr{btCollisionObject} co) const;
  public function extern "addConstraintRef" void addConstraintRef(rptr{btTypedConstraint} c);
  public function extern "removeConstraintRef" void removeConstraintRef(rptr{btTypedConstraint} c);
  public function extern "getConstraintRef" rptr{btTypedConstraint} getConstraintRef(int index);
  public function extern "getNumConstraintRefs" int getNumConstraintRefs() const;
  public function extern "setFlags" void setFlags(int flags);
  public function extern "getFlags" int getFlags() const;
  public function extern "computeGyroscopicForce" btVector3 computeGyroscopicForce(btScalar maxGyroscopicForce) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer) const;
  public metafunction __base__ {btCollisionObject};
}
public threaded struct extern "::btRigidBodyDoubleData" btRigidBodyDoubleData {
  public btCollisionObjectDoubleData m_collisionObjectData;
  public btMatrix3x3DoubleData m_invInertiaTensorWorld;
  public btVector3DoubleData m_linearVelocity;
  public btVector3DoubleData m_angularVelocity;
  public btVector3DoubleData m_angularFactor;
  public btVector3DoubleData m_linearFactor;
  public btVector3DoubleData m_gravity;
  public btVector3DoubleData m_gravity_acceleration;
  public btVector3DoubleData m_invInertiaLocal;
  public btVector3DoubleData m_totalForce;
  public btVector3DoubleData m_totalTorque;
  public double m_inverseMass;
  public double m_linearDamping;
  public double m_angularDamping;
  public double m_additionalDampingFactor;
  public double m_additionalLinearDampingThresholdSqr;
  public double m_additionalAngularDampingThresholdSqr;
  public double m_additionalAngularDampingFactor;
  public double m_linearSleepingThreshold;
  public double m_angularSleepingThreshold;
  public int m_additionalDamping;
  public rawarray{char, 4} m_padding;
}
public tsvaluetype struct extern "::btRigidBodyFlags" "extenum" btRigidBodyFlags { }
public extern "BT_DISABLE_WORLD_GRAVITY" btRigidBodyFlags BT_DISABLE_WORLD_GRAVITY;
public extern "BT_ENABLE_GYROPSCOPIC_FORCE" btRigidBodyFlags BT_ENABLE_GYROPSCOPIC_FORCE;
public threaded struct extern "::btRigidBodyFloatData" btRigidBodyFloatData {
  public btCollisionObjectFloatData m_collisionObjectData;
  public btMatrix3x3FloatData m_invInertiaTensorWorld;
  public btVector3FloatData m_linearVelocity;
  public btVector3FloatData m_angularVelocity;
  public btVector3FloatData m_angularFactor;
  public btVector3FloatData m_linearFactor;
  public btVector3FloatData m_gravity;
  public btVector3FloatData m_gravity_acceleration;
  public btVector3FloatData m_invInertiaLocal;
  public btVector3FloatData m_totalForce;
  public btVector3FloatData m_totalTorque;
  public float m_inverseMass;
  public float m_linearDamping;
  public float m_angularDamping;
  public float m_additionalDampingFactor;
  public float m_additionalLinearDampingThresholdSqr;
  public float m_additionalAngularDampingThresholdSqr;
  public float m_additionalAngularDampingFactor;
  public float m_linearSleepingThreshold;
  public float m_angularSleepingThreshold;
  public int m_additionalDamping;
}
public threaded struct extern "::btRigidBody::btRigidBodyConstructionInfo" "nodefault" btRigidBody_btRigidBodyConstructionInfo(btScalar mass, rptr{btMotionState} motionState, rptr{btCollisionShape} collisionShape, btVector3 const& localInertia)  {
  public btScalar m_mass;
  public rptr{btMotionState} m_motionState;
  public btTransform m_startWorldTransform;
  public rptr{btCollisionShape} m_collisionShape;
  public btVector3 m_localInertia;
  public btScalar m_linearDamping;
  public btScalar m_angularDamping;
  public btScalar m_friction;
  public btScalar m_rollingFriction;
  public btScalar m_restitution;
  public btScalar m_linearSleepingThreshold;
  public btScalar m_angularSleepingThreshold;
  public bool m_additionalDamping;
  public btScalar m_additionalDampingFactor;
  public btScalar m_additionalLinearDampingThresholdSqr;
  public btScalar m_additionalAngularDampingThresholdSqr;
  public btScalar m_additionalAngularDampingFactor;
}
public threaded struct extern "::btRotationalLimitMotor" btRotationalLimitMotor {
  public btScalar m_loLimit;
  public btScalar m_hiLimit;
  public btScalar m_targetVelocity;
  public btScalar m_maxMotorForce;
  public btScalar m_maxLimitForce;
  public btScalar m_damping;
  public btScalar m_limitSoftness;
  public btScalar m_normalCFM;
  public btScalar m_stopERP;
  public btScalar m_stopCFM;
  public btScalar m_bounce;
  public bool m_enableMotor;
  public btScalar m_currentLimitError;
  public btScalar m_currentPosition;
  public int m_currentLimit;
  public btScalar m_accumulatedImpulse;
  public function extern "isLimited" bool isLimited();
  public function extern "needApplyTorques" bool needApplyTorques();
  public function extern "testLimitValue" int testLimitValue(btScalar test_value);
  public function extern "solveAngularLimits" btScalar solveAngularLimits(btScalar timeStep, btVector3 mutable& axis, btScalar jacDiagABInv, rptr{btRigidBody} body0, rptr{btRigidBody} body1);
}
public metafunction btSapBroadphaseArray btAlignedObjectArray_btBroadphaseInterface_p;
public metafunction btScalar float;
public threaded struct extern "::btScaledBvhTriangleMeshShape" "nodefault" btScaledBvhTriangleMeshShape(rptr{btBvhTriangleMeshShape} childShape, btVector3 const& localScaling)  {
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getChildShape" rptr{btBvhTriangleMeshShape} getChildShape();
  public function extern "getChildShape" crptr{btBvhTriangleMeshShape} getChildShape1() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btConcaveShape};
}
public threaded struct extern "::btScaledTriangleMeshShapeData" btScaledTriangleMeshShapeData {
  public btTriangleMeshShapeData m_trimeshShapeData;
  public btVector3FloatData m_localScaling;
}
public threaded struct extern "::btSequentialImpulseConstraintSolver" "noncopyable" btSequentialImpulseConstraintSolver {
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies, int numBodies, rptr{rptr{btPersistentManifold}} manifold, int numManifolds, rptr{rptr{btTypedConstraint}} constraints, int numConstraints, btContactSolverInfo const& info, rptr{btIDebugDraw} debugDrawer, rptr{btStackAlloc} stackAlloc, rptr{btDispatcher} dispatcher);
  public function extern "reset" void reset();
  public function extern "btRand2" uclong btRand2();
  public function extern "btRandInt2" int btRandInt2(int n);
  public function extern "setRandSeed" void setRandSeed(uclong seed);
  public function extern "getRandSeed" uclong getRandSeed() const;
  public metafunction __base__ {btConstraintSolver};
}
public tsvaluetype struct extern "::btSerializationFlags" "extenum" btSerializationFlags { }
public extern "BT_SERIALIZE_NO_BVH" btSerializationFlags BT_SERIALIZE_NO_BVH;
public extern "BT_SERIALIZE_NO_TRIANGLEINFOMAP" btSerializationFlags BT_SERIALIZE_NO_TRIANGLEINFOMAP;
public extern "BT_SERIALIZE_NO_DUPLICATE_ASSERT" btSerializationFlags BT_SERIALIZE_NO_DUPLICATE_ASSERT;
public threaded struct extern "::btSerializer" "noncopyable" btSerializer {
  public function extern "getBufferPointer" crptr{uchar} getBufferPointer() const;
  public function extern "getCurrentBufferSize" int getCurrentBufferSize() const;
  public function extern "allocate" rptr{btChunk} allocate(size_t size, int numElements);
  public function extern "finalizeChunk" void finalizeChunk(rptr{btChunk} chunk, crptr{char} structType, int chunkCode, rptr{void} oldPtr);
  public function extern "findPointer" rptr{void} findPointer(rptr{void} oldPtr);
  public function extern "getUniquePointer" rptr{void} getUniquePointer(rptr{void} oldPtr);
  public function extern "startSerialization" void startSerialization();
  public function extern "finishSerialization" void finishSerialization();
  public function extern "findNameForPointer" crptr{char} findNameForPointer(crptr{void} ptr) const;
  public function extern "registerNameForPointer" void registerNameForPointer(crptr{void} ptr, crptr{char} name);
  public function extern "serializeName" void serializeName(crptr{char} ptr);
  public function extern "getSerializationFlags" int getSerializationFlags() const;
  public function extern "setSerializationFlags" void setSerializationFlags(int flags);
}
public threaded struct extern "::btShortIntIndexData" btShortIntIndexData {
  public short m_value;
  public rawarray{char, 2} m_pad;
}
public threaded struct extern "::btShortIntIndexTripletData" btShortIntIndexTripletData {
  public rawarray{short, 3} m_values;
  public rawarray{char, 2} m_pad;
}
public threaded struct extern "::btSimpleBroadphase" "nodefault" btSimpleBroadphase(int maxProxies, rptr{btOverlappingPairCache} overlappingPairCache)  {
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin, btVector3 const& aabbMax, int shapeType, rptr{void} userPtr, short collisionFilterGroup, short collisionFilterMask, rptr{btDispatcher} dispatcher, rptr{void} multiSapProxy);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy, btVector3 const& aabbMin, btVector3 const& aabbMax, rptr{btDispatcher} dispatcher);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom, btVector3 const& rayTo, btBroadphaseRayCallback mutable& rayCallback, btVector3 const& aabbMin, btVector3 const& aabbMax);
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin, btVector3 const& aabbMax, btBroadphaseAabbCallback mutable& callback);
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} getOverlappingPairCache1() const;
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "printStats" void printStats();
  public metafunction __base__ {btBroadphaseInterface};
}
public threaded struct extern "::btSimpleBroadphaseProxy" btSimpleBroadphaseProxy {
  public int m_nextFree;
  public function extern "SetNextFree" void SetNextFree(int next);
  public function extern "GetNextFree" int GetNextFree() const;
  public metafunction __base__ {btBroadphaseProxy};
}
public threaded struct extern "::btSimpleDynamicsWorld" "nodefault" btSimpleDynamicsWorld(rptr{btDispatcher} dispatcher, rptr{btBroadphaseInterface} pairCache, rptr{btConstraintSolver} constraintSolver, rptr{btCollisionConfiguration} collisionConfiguration)  {
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep);
  public function extern "setGravity" void setGravity(btVector3 const& gravity);
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "addRigidBody" void addRigidBody(rptr{btRigidBody} body);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body, short group, short mask);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "addAction" void addAction(rptr{btActionInterface} action);
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject);
  public function extern "updateAabbs" void updateAabbs();
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver);
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "clearForces" void clearForces();
  public metafunction __base__ {btDynamicsWorld};
}
public threaded struct extern "::btSimulationIslandManager" "nodefault" btSimulationIslandManager private()  {
}
public threaded struct extern "::btSliderConstraint" "nodefault" btSliderConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btTransform const& frameInA, btTransform const& frameInB, bool useLinearReferenceFrameA)  {
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info, btTransform const& transA, btTransform const& transB, btVector3 const& linVelA, btVector3 const& linVelB, btScalar rbAinvMass, btScalar rbBinvMass);
  public function extern "getRigidBodyA" btRigidBody const& getRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody const& getRigidBodyB() const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "getFrameOffsetA" btTransform const& getFrameOffsetA() const;
  public function extern "getFrameOffsetB" btTransform const& getFrameOffsetB() const;
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA1();
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB1();
  public function extern "getLowerLinLimit" btScalar getLowerLinLimit();
  public function extern "setLowerLinLimit" void setLowerLinLimit(btScalar lowerLimit);
  public function extern "getUpperLinLimit" btScalar getUpperLinLimit();
  public function extern "setUpperLinLimit" void setUpperLinLimit(btScalar upperLimit);
  public function extern "getLowerAngLimit" btScalar getLowerAngLimit();
  public function extern "setLowerAngLimit" void setLowerAngLimit(btScalar lowerLimit);
  public function extern "getUpperAngLimit" btScalar getUpperAngLimit();
  public function extern "setUpperAngLimit" void setUpperAngLimit(btScalar upperLimit);
  public function extern "getUseLinearReferenceFrameA" bool getUseLinearReferenceFrameA();
  public function extern "getSoftnessDirLin" btScalar getSoftnessDirLin();
  public function extern "getRestitutionDirLin" btScalar getRestitutionDirLin();
  public function extern "getDampingDirLin" btScalar getDampingDirLin();
  public function extern "getSoftnessDirAng" btScalar getSoftnessDirAng();
  public function extern "getRestitutionDirAng" btScalar getRestitutionDirAng();
  public function extern "getDampingDirAng" btScalar getDampingDirAng();
  public function extern "getSoftnessLimLin" btScalar getSoftnessLimLin();
  public function extern "getRestitutionLimLin" btScalar getRestitutionLimLin();
  public function extern "getDampingLimLin" btScalar getDampingLimLin();
  public function extern "getSoftnessLimAng" btScalar getSoftnessLimAng();
  public function extern "getRestitutionLimAng" btScalar getRestitutionLimAng();
  public function extern "getDampingLimAng" btScalar getDampingLimAng();
  public function extern "getSoftnessOrthoLin" btScalar getSoftnessOrthoLin();
  public function extern "getRestitutionOrthoLin" btScalar getRestitutionOrthoLin();
  public function extern "getDampingOrthoLin" btScalar getDampingOrthoLin();
  public function extern "getSoftnessOrthoAng" btScalar getSoftnessOrthoAng();
  public function extern "getRestitutionOrthoAng" btScalar getRestitutionOrthoAng();
  public function extern "getDampingOrthoAng" btScalar getDampingOrthoAng();
  public function extern "setSoftnessDirLin" void setSoftnessDirLin(btScalar softnessDirLin);
  public function extern "setRestitutionDirLin" void setRestitutionDirLin(btScalar restitutionDirLin);
  public function extern "setDampingDirLin" void setDampingDirLin(btScalar dampingDirLin);
  public function extern "setSoftnessDirAng" void setSoftnessDirAng(btScalar softnessDirAng);
  public function extern "setRestitutionDirAng" void setRestitutionDirAng(btScalar restitutionDirAng);
  public function extern "setDampingDirAng" void setDampingDirAng(btScalar dampingDirAng);
  public function extern "setSoftnessLimLin" void setSoftnessLimLin(btScalar softnessLimLin);
  public function extern "setRestitutionLimLin" void setRestitutionLimLin(btScalar restitutionLimLin);
  public function extern "setDampingLimLin" void setDampingLimLin(btScalar dampingLimLin);
  public function extern "setSoftnessLimAng" void setSoftnessLimAng(btScalar softnessLimAng);
  public function extern "setRestitutionLimAng" void setRestitutionLimAng(btScalar restitutionLimAng);
  public function extern "setDampingLimAng" void setDampingLimAng(btScalar dampingLimAng);
  public function extern "setSoftnessOrthoLin" void setSoftnessOrthoLin(btScalar softnessOrthoLin);
  public function extern "setRestitutionOrthoLin" void setRestitutionOrthoLin(btScalar restitutionOrthoLin);
  public function extern "setDampingOrthoLin" void setDampingOrthoLin(btScalar dampingOrthoLin);
  public function extern "setSoftnessOrthoAng" void setSoftnessOrthoAng(btScalar softnessOrthoAng);
  public function extern "setRestitutionOrthoAng" void setRestitutionOrthoAng(btScalar restitutionOrthoAng);
  public function extern "setDampingOrthoAng" void setDampingOrthoAng(btScalar dampingOrthoAng);
  public function extern "setPoweredLinMotor" void setPoweredLinMotor(bool onOff);
  public function extern "getPoweredLinMotor" bool getPoweredLinMotor();
  public function extern "setTargetLinMotorVelocity" void setTargetLinMotorVelocity(btScalar targetLinMotorVelocity);
  public function extern "getTargetLinMotorVelocity" btScalar getTargetLinMotorVelocity();
  public function extern "setMaxLinMotorForce" void setMaxLinMotorForce(btScalar maxLinMotorForce);
  public function extern "getMaxLinMotorForce" btScalar getMaxLinMotorForce();
  public function extern "setPoweredAngMotor" void setPoweredAngMotor(bool onOff);
  public function extern "getPoweredAngMotor" bool getPoweredAngMotor();
  public function extern "setTargetAngMotorVelocity" void setTargetAngMotorVelocity(btScalar targetAngMotorVelocity);
  public function extern "getTargetAngMotorVelocity" btScalar getTargetAngMotorVelocity();
  public function extern "setMaxAngMotorForce" void setMaxAngMotorForce(btScalar maxAngMotorForce);
  public function extern "getMaxAngMotorForce" btScalar getMaxAngMotorForce();
  public function extern "getLinearPos" btScalar getLinearPos() const;
  public function extern "getAngularPos" btScalar getAngularPos() const;
  public function extern "getSolveLinLimit" bool getSolveLinLimit();
  public function extern "getLinDepth" btScalar getLinDepth();
  public function extern "getSolveAngLimit" bool getSolveAngLimit();
  public function extern "getAngDepth" btScalar getAngDepth();
  public function extern "calculateTransforms" void calculateTransforms(btTransform const& transA, btTransform const& transB);
  public function extern "testLinLimits" void testLinLimits();
  public function extern "testAngLimits" void testAngLimits();
  public function extern "getAncorInA" btVector3 getAncorInA();
  public function extern "getAncorInB" btVector3 getAncorInB();
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff);
  public function extern "setFrames" void setFrames(btTransform const& frameA, btTransform const& frameB);
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btTypedConstraint};
}
public threaded struct extern "::btSliderConstraintData" btSliderConstraintData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public float m_linearUpperLimit;
  public float m_linearLowerLimit;
  public float m_angularUpperLimit;
  public float m_angularLowerLimit;
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
}
public tsvaluetype struct extern "::btSliderFlags" "extenum" btSliderFlags { }
public extern "BT_SLIDER_FLAGS_CFM_DIRLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_DIRLIN;
public extern "BT_SLIDER_FLAGS_ERP_DIRLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_DIRLIN;
public extern "BT_SLIDER_FLAGS_CFM_DIRANG" btSliderFlags BT_SLIDER_FLAGS_CFM_DIRANG;
public extern "BT_SLIDER_FLAGS_ERP_DIRANG" btSliderFlags BT_SLIDER_FLAGS_ERP_DIRANG;
public extern "BT_SLIDER_FLAGS_CFM_ORTLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_ORTLIN;
public extern "BT_SLIDER_FLAGS_ERP_ORTLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_ORTLIN;
public extern "BT_SLIDER_FLAGS_CFM_ORTANG" btSliderFlags BT_SLIDER_FLAGS_CFM_ORTANG;
public extern "BT_SLIDER_FLAGS_ERP_ORTANG" btSliderFlags BT_SLIDER_FLAGS_ERP_ORTANG;
public extern "BT_SLIDER_FLAGS_CFM_LIMLIN" btSliderFlags BT_SLIDER_FLAGS_CFM_LIMLIN;
public extern "BT_SLIDER_FLAGS_ERP_LIMLIN" btSliderFlags BT_SLIDER_FLAGS_ERP_LIMLIN;
public extern "BT_SLIDER_FLAGS_CFM_LIMANG" btSliderFlags BT_SLIDER_FLAGS_CFM_LIMANG;
public extern "BT_SLIDER_FLAGS_ERP_LIMANG" btSliderFlags BT_SLIDER_FLAGS_ERP_LIMANG;
public threaded struct extern "::btSolverBody" btSolverBody {
  public btTransform m_worldTransform;
  public btVector3 m_deltaLinearVelocity;
  public btVector3 m_deltaAngularVelocity;
  public btVector3 m_angularFactor;
  public btVector3 m_linearFactor;
  public btVector3 m_invMass;
  public btVector3 m_pushVelocity;
  public btVector3 m_turnVelocity;
  public btVector3 m_linearVelocity;
  public btVector3 m_angularVelocity;
  public rptr{btRigidBody} m_originalBody;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTransform);
  public function extern "getWorldTransform" btTransform const& getWorldTransform() const;
  public function extern "getVelocityInLocalPointObsolete" void getVelocityInLocalPointObsolete(btVector3 const& rel_pos, btVector3 mutable& velocity) const;
  public function extern "getAngularVelocity" void getAngularVelocity(btVector3 mutable& angVel) const;
  public function extern "applyImpulse" void applyImpulse(btVector3 const& linearComponent, btVector3 const& angularComponent, btScalar const impulseMagnitude);
  public function extern "internalApplyPushImpulse" void internalApplyPushImpulse(btVector3 const& linearComponent, btVector3 const& angularComponent, btScalar impulseMagnitude);
  public function extern "getDeltaLinearVelocity" btVector3 const& getDeltaLinearVelocity() const;
  public function extern "getDeltaAngularVelocity" btVector3 const& getDeltaAngularVelocity() const;
  public function extern "getPushVelocity" btVector3 const& getPushVelocity() const;
  public function extern "getTurnVelocity" btVector3 const& getTurnVelocity() const;
  public function extern "internalGetDeltaLinearVelocity" btVector3 mutable& internalGetDeltaLinearVelocity();
  public function extern "internalGetDeltaAngularVelocity" btVector3 mutable& internalGetDeltaAngularVelocity();
  public function extern "internalGetAngularFactor" btVector3 const& internalGetAngularFactor() const;
  public function extern "internalGetInvMass" btVector3 const& internalGetInvMass() const;
  public function extern "internalSetInvMass" void internalSetInvMass(btVector3 const& invMass);
  public function extern "internalGetPushVelocity" btVector3 mutable& internalGetPushVelocity();
  public function extern "internalGetTurnVelocity" btVector3 mutable& internalGetTurnVelocity();
  public function extern "internalGetVelocityInLocalPointObsolete" void internalGetVelocityInLocalPointObsolete(btVector3 const& rel_pos, btVector3 mutable& velocity) const;
  public function extern "internalGetAngularVelocity" void internalGetAngularVelocity(btVector3 mutable& angVel) const;
  public function extern "internalApplyImpulse" void internalApplyImpulse(btVector3 const& linearComponent, btVector3 const& angularComponent, btScalar const impulseMagnitude);
  public function extern "writebackVelocity" void writebackVelocity();
  public function extern "writebackVelocityAndTransform" void writebackVelocityAndTransform(btScalar timeStep, btScalar splitImpulseTurnErp);
}
public threaded struct extern "::btSolverConstraint" btSolverConstraint {
  public btVector3 m_relpos1CrossNormal;
  public btVector3 m_contactNormal;
  public btVector3 m_relpos2CrossNormal;
  public btVector3 m_angularComponentA;
  public btVector3 m_angularComponentB;
  public btScalar m_appliedPushImpulse;
  public btScalar m_appliedImpulse;
  public btScalar m_friction;
  public btScalar m_jacDiagABInv;
  public btScalar m_rhs;
  public btScalar m_cfm;
  public btScalar m_lowerLimit;
  public btScalar m_upperLimit;
  public btScalar m_rhsPenetration;
  public int m_overrideNumSolverIterations;
  public int m_frictionIndex;
  public int m_solverBodyIdA;
  public int m_solverBodyIdB;
}
public tsvaluetype struct extern "::btSolverConstraintType" "extenum" btSolverConstraintType { }
public extern "BT_SOLVER_CONTACT_1D" btSolverConstraintType BT_SOLVER_CONTACT_1D;
public extern "BT_SOLVER_FRICTION_1D" btSolverConstraintType BT_SOLVER_FRICTION_1D;
/* skip btSolverConstraint_32 : unnamed */
public tsvaluetype struct extern "::btSolverMode" "extenum" btSolverMode { }
public extern "SOLVER_RANDMIZE_ORDER" btSolverMode SOLVER_RANDMIZE_ORDER;
public extern "SOLVER_FRICTION_SEPARATE" btSolverMode SOLVER_FRICTION_SEPARATE;
public extern "SOLVER_USE_WARMSTARTING" btSolverMode SOLVER_USE_WARMSTARTING;
public extern "SOLVER_USE_2_FRICTION_DIRECTIONS" btSolverMode SOLVER_USE_2_FRICTION_DIRECTIONS;
public extern "SOLVER_ENABLE_FRICTION_DIRECTION_CACHING" btSolverMode SOLVER_ENABLE_FRICTION_DIRECTION_CACHING;
public extern "SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION" btSolverMode SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION;
public extern "SOLVER_CACHE_FRIENDLY" btSolverMode SOLVER_CACHE_FRIENDLY;
public extern "SOLVER_SIMD" btSolverMode SOLVER_SIMD;
public extern "SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS" btSolverMode SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS;
public extern "SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS" btSolverMode SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS;
public threaded struct extern "::btSortedOverlappingPairCache" "noncopyable" btSortedOverlappingPairCache {
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1, rptr{btDispatcher} dispatcher);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair, rptr{btDispatcher} dispatcher);
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy, rptr{btDispatcher} dispatcher);
  public function extern "needsBroadphaseCollision" bool needsBroadphaseCollision(rptr{btBroadphaseProxy} proxy0, rptr{btBroadphaseProxy} proxy1) const;
  public function extern "getOverlappingPairArray" btBroadphasePairArray mutable& getOverlappingPairArray();
  public function extern "getOverlappingPairArray" btBroadphasePairArray const& getOverlappingPairArray1() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} getOverlappingPairArrayPtr1() const;
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "getOverlapFilterCallback" rptr{btOverlapFilterCallback} getOverlapFilterCallback();
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback);
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher);
  public metafunction __base__ {btOverlappingPairCache};
}
public threaded struct extern "::btSphereShape" "nodefault" btSphereShape(btScalar radius)  {
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "setUnscaledRadius" void setUnscaledRadius(btScalar radius);
  public function extern "getName" crptr{char} getName() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getMargin" btScalar getMargin() const;
  public metafunction __base__ {btConvexInternalShape};
}
public threaded struct extern "::btSphereSphereCollisionAlgorithm" "nodefault" btSphereSphereCollisionAlgorithm(rptr{btPersistentManifold} mf, btCollisionAlgorithmConstructionInfo const& ci, crptr{btCollisionObjectWrapper} col0Wrap, crptr{btCollisionObjectWrapper} col1Wrap)  {
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap, crptr{btCollisionObjectWrapper} body1Wrap, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0, rptr{btCollisionObject} body1, btDispatcherInfo const& dispatchInfo, rptr{btManifoldResult} resultOut);
  public function extern "getAllContactManifolds" void getAllContactManifolds(btManifoldArray mutable& manifoldArray);
  public metafunction __base__ {btActivatingCollisionAlgorithm};
}
public threaded struct extern "::btSphereSphereCollisionAlgorithm::CreateFunc" "noncopyable" btSphereSphereCollisionAlgorithm_CreateFunc {
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& ci, crptr{btCollisionObjectWrapper} col0Wrap, crptr{btCollisionObjectWrapper} col1Wrap);
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
}
public threaded struct extern "::btStackAlloc" "nodefault" btStackAlloc(uint size)  {
  public function extern "create" void create(uint size);
  public function extern "destroy" void destroy();
  public function extern "getAvailableMemory" int getAvailableMemory() const;
  public function extern "allocate" rptr{uchar} allocate(uint size);
  public function extern "beginBlock" rptr{btBlock} beginBlock();
  public function extern "endBlock" void endBlock(rptr{btBlock} block);
}
public threaded struct extern "::btStaticPlaneShape" "nodefault" btStaticPlaneShape(btVector3 const& planeNormal, btScalar planeConstant)  {
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getPlaneNormal" btVector3 const& getPlaneNormal() const;
  public function extern "getPlaneConstant" btScalar const& getPlaneConstant() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btConcaveShape};
}
public threaded struct extern "::btStaticPlaneShapeData" btStaticPlaneShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public btVector3FloatData m_localScaling;
  public btVector3FloatData m_planeNormal;
  public float m_planeConstant;
  public rawarray{char, 4} m_pad;
}
public threaded struct extern "::btStorageResult" "noncopyable" btStorageResult {
  public btVector3 m_normalOnSurfaceB;
  public btVector3 m_closestPointInB;
  public btScalar m_distance;
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld, btVector3 const& pointInWorld, btScalar depth);
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
}
public threaded struct extern "::btStridingMeshInterface" "noncopyable" btStridingMeshInterface {
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin, btVector3 mutable& aabbMax);
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& stride, rptr{rptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart);
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& stride, rptr{crptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart);
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart) const;
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "preallocateVertices" void preallocateVertices(int numverts);
  public function extern "preallocateIndices" void preallocateIndices(int numindices);
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin, rptr{btVector3} aabbMax) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
}
public threaded struct extern "::btStridingMeshInterfaceData" btStridingMeshInterfaceData {
  public rptr{btMeshPartData} m_meshPartsPtr;
  public btVector3FloatData m_scaling;
  public int m_numMeshParts;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btTransform" btTransform {
  public function extern "mult" void mult(btTransform const& t1, btTransform const& t2);
  public function extern "getBasis" btMatrix3x3 mutable& getBasis();
  public function extern "getBasis" btMatrix3x3 const& getBasis1() const;
  public function extern "getOrigin" btVector3 mutable& getOrigin();
  public function extern "getOrigin" btVector3 const& getOrigin1() const;
  public function extern "getRotation" btQuaternion getRotation() const;
  public function extern "setFromOpenGLMatrix" void setFromOpenGLMatrix(crptr{btScalar} m);
  public function extern "getOpenGLMatrix" void getOpenGLMatrix(rptr{btScalar} m) const;
  public function extern "setOrigin" void setOrigin(btVector3 const& origin);
  public function extern "invXform" btVector3 invXform(btVector3 const& inVec) const;
  public function extern "setBasis" void setBasis(btMatrix3x3 const& basis);
  public function extern "setRotation" void setRotation(btQuaternion const& q);
  public function extern "setIdentity" void setIdentity();
  public function extern "inverse" btTransform inverse() const;
  public function extern "inverseTimes" btTransform inverseTimes(btTransform const& t) const;
  public function extern "serialize" void serialize(btTransformFloatData mutable& dataOut) const;
  public function extern "serializeFloat" void serializeFloat(btTransformFloatData mutable& dataOut) const;
  public function extern "deSerialize" void deSerialize(btTransformFloatData const& dataIn);
  public function extern "deSerializeDouble" void deSerializeDouble(btTransformDoubleData const& dataIn);
  public function extern "deSerializeFloat" void deSerializeFloat(btTransformFloatData const& dataIn);
}
public threaded struct extern "::btTransformDoubleData" btTransformDoubleData {
  public btMatrix3x3DoubleData m_basis;
  public btVector3DoubleData m_origin;
}
public threaded struct extern "::btTransformFloatData" btTransformFloatData {
  public btMatrix3x3FloatData m_basis;
  public btVector3FloatData m_origin;
}
public threaded struct extern "::btTransformUtil" btTransformUtil {
}
public threaded struct extern "::btTranslationalLimitMotor" btTranslationalLimitMotor {
  public btVector3 m_lowerLimit;
  public btVector3 m_upperLimit;
  public btVector3 m_accumulatedImpulse;
  public btScalar m_limitSoftness;
  public btScalar m_damping;
  public btScalar m_restitution;
  public btVector3 m_normalCFM;
  public btVector3 m_stopERP;
  public btVector3 m_stopCFM;
  public rawarray{bool, 3} m_enableMotor;
  public btVector3 m_targetVelocity;
  public btVector3 m_maxMotorForce;
  public btVector3 m_currentLimitError;
  public btVector3 m_currentLinearDiff;
  public rawarray{int, 3} m_currentLimit;
  public function extern "isLimited" bool isLimited(int limitIndex);
  public function extern "needApplyForce" bool needApplyForce(int limitIndex);
  public function extern "testLimitValue" int testLimitValue(int limitIndex, btScalar test_value);
  public function extern "solveLinearAxis" btScalar solveLinearAxis(btScalar timeStep, btScalar jacDiagABInv, btRigidBody mutable& body1, btVector3 const& pointInA, btRigidBody mutable& body2, btVector3 const& pointInB, int limit_index, btVector3 const& axis_normal_on_a, btVector3 const& anchorPos);
}
public tsvaluetype struct extern "::btTraversalMode" "extenum" btTraversalMode { }
public extern "TRAVERSAL_STACKLESS" btTraversalMode TRAVERSAL_STACKLESS;
public extern "TRAVERSAL_STACKLESS_CACHE_FRIENDLY" btTraversalMode TRAVERSAL_STACKLESS_CACHE_FRIENDLY;
public extern "TRAVERSAL_RECURSIVE" btTraversalMode TRAVERSAL_RECURSIVE;
public threaded struct extern "::btTriangleCallback" "noncopyable" btTriangleCallback {
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle, int partId, int triangleIndex);
}
public threaded struct extern "::btTriangleIndexVertexArray" "noncopyable" btTriangleIndexVertexArray {
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh, PHY_ScalarType indexType);
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& vertexStride, rptr{rptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart);
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase, int mutable& numverts, PHY_ScalarType mutable& type, int mutable& vertexStride, rptr{crptr{uchar}} indexbase, int mutable& indexstride, int mutable& numfaces, PHY_ScalarType mutable& indicestype, int subpart) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart);
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart) const;
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "getIndexedMeshArray" IndexedMeshArray mutable& getIndexedMeshArray();
  public function extern "getIndexedMeshArray" IndexedMeshArray const& getIndexedMeshArray1() const;
  public function extern "preallocateVertices" void preallocateVertices(int numverts);
  public function extern "preallocateIndices" void preallocateIndices(int numindices);
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin, rptr{btVector3} aabbMax) const;
  public metafunction __base__ {btStridingMeshInterface};
}
public threaded struct extern "::btTriangleInfo" btTriangleInfo {
  public int m_flags;
  public btScalar m_edgeV0V1Angle;
  public btScalar m_edgeV1V2Angle;
  public btScalar m_edgeV2V0Angle;
}
public threaded struct extern "::btTriangleInfoData" btTriangleInfoData {
  public int m_flags;
  public float m_edgeV0V1Angle;
  public float m_edgeV1V2Angle;
  public float m_edgeV2V0Angle;
}
public threaded struct extern "::btTriangleInfoMap" "noncopyable" btTriangleInfoMap {
  public btScalar m_convexEpsilon;
  public btScalar m_planarEpsilon;
  public btScalar m_equalVertexThreshold;
  public btScalar m_edgeDistanceThreshold;
  public btScalar m_maxEdgeAngleThreshold;
  public btScalar m_zeroAreaThreshold;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public function extern "deSerialize" void deSerialize(btTriangleInfoMapData mutable& tmapData);
  public metafunction __base__ {btHashMap_btHashInt_btTriangleInfo};
}
public threaded struct extern "::btTriangleInfoMapData" btTriangleInfoMapData {
  public rptr{int} m_hashTablePtr;
  public rptr{int} m_nextPtr;
  public rptr{btTriangleInfoData} m_valueArrayPtr;
  public rptr{int} m_keyArrayPtr;
  public float m_convexEpsilon;
  public float m_planarEpsilon;
  public float m_equalVertexThreshold;
  public float m_edgeDistanceThreshold;
  public float m_zeroAreaThreshold;
  public int m_nextSize;
  public int m_hashTableSize;
  public int m_numValues;
  public int m_numKeys;
  public rawarray{char, 4} m_padding;
}
public threaded struct extern "::btTriangleMesh" "nodefault" btTriangleMesh(bool use32bitIndices, bool use4componentVertices)  {
  public btScalar m_weldingThreshold;
  public function extern "getUse32bitIndices" bool getUse32bitIndices() const;
  public function extern "getUse4componentVertices" bool getUse4componentVertices() const;
  public function extern "addTriangle" void addTriangle(btVector3 const& vertex0, btVector3 const& vertex1, btVector3 const& vertex2, bool removeDuplicateVertices);
  public function extern "getNumTriangles" int getNumTriangles() const;
  public function extern "preallocateVertices" void preallocateVertices(int numverts);
  public function extern "preallocateIndices" void preallocateIndices(int numindices);
  public function extern "findOrAddVertex" int findOrAddVertex(btVector3 const& vertex, bool removeDuplicateVertices);
  public function extern "addIndex" void addIndex(int index);
  public metafunction __base__ {btTriangleIndexVertexArray};
}
public threaded struct extern "::btTriangleMeshShape" "nodefault" btTriangleMeshShape private()  {
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback, btVector3 const& aabbMin, btVector3 const& aabbMax) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} getMeshInterface1() const;
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "getName" crptr{char} getName() const;
  public metafunction __base__ {btConcaveShape};
}
public threaded struct extern "::btTriangleMeshShapeData" btTriangleMeshShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public btStridingMeshInterfaceData m_meshInterface;
  public rptr{btQuantizedBvhFloatData} m_quantizedFloatBvh;
  public rptr{btQuantizedBvhDoubleData} m_quantizedDoubleBvh;
  public rptr{btTriangleInfoMapData} m_triangleInfoMap;
  public float m_collisionMargin;
  public rawarray{char, 4} m_pad3;
}
public threaded struct extern "::btTypedConstraint" "nodefault" btTypedConstraint(btTypedConstraintType type, btRigidBody mutable& rbA)  {
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations);
  public function extern "buildJacobian" void buildJacobian();
  public function extern "setupSolverConstraint" void setupSolverConstraint(btConstraintArray mutable& ca, int solverBodyA, int solverBodyB, btScalar timeStep);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info);
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "setEnabled" void setEnabled(bool enabled);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "getRigidBodyA" btRigidBody const& getRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody const& getRigidBodyB() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA1();
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB1();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid);
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr);
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback);
  public function extern "getJointFeedback" crptr{btJointFeedback} getJointFeedback() const;
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback1();
  public function extern "getUid" int getUid() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize);
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "setParam" void setParam(int num, btScalar value, int axis);
  public function extern "getParam" btScalar getParam(int num, int axis) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer, rptr{btSerializer} serializer) const;
  public metafunction __base__ {btTypedObject};
}
public threaded struct extern "::btTypedConstraintData" btTypedConstraintData {
  public rptr{btRigidBodyFloatData} m_rbA;
  public rptr{btRigidBodyFloatData} m_rbB;
  public rptr{char} m_name;
  public int m_objectType;
  public int m_userConstraintType;
  public int m_userConstraintId;
  public int m_needsFeedback;
  public float m_appliedImpulse;
  public float m_dbgDrawSize;
  public int m_disableCollisionsBetweenLinkedBodies;
  public int m_overrideNumSolverIterations;
  public float m_breakingImpulseThreshold;
  public int m_isEnabled;
}
public tsvaluetype struct extern "::btTypedConstraintType" "extenum" btTypedConstraintType { }
public extern "POINT2POINT_CONSTRAINT_TYPE" btTypedConstraintType POINT2POINT_CONSTRAINT_TYPE;
public extern "HINGE_CONSTRAINT_TYPE" btTypedConstraintType HINGE_CONSTRAINT_TYPE;
public extern "CONETWIST_CONSTRAINT_TYPE" btTypedConstraintType CONETWIST_CONSTRAINT_TYPE;
public extern "D6_CONSTRAINT_TYPE" btTypedConstraintType D6_CONSTRAINT_TYPE;
public extern "SLIDER_CONSTRAINT_TYPE" btTypedConstraintType SLIDER_CONSTRAINT_TYPE;
public extern "CONTACT_CONSTRAINT_TYPE" btTypedConstraintType CONTACT_CONSTRAINT_TYPE;
public extern "D6_SPRING_CONSTRAINT_TYPE" btTypedConstraintType D6_SPRING_CONSTRAINT_TYPE;
public extern "GEAR_CONSTRAINT_TYPE" btTypedConstraintType GEAR_CONSTRAINT_TYPE;
public extern "MAX_CONSTRAINT_TYPE" btTypedConstraintType MAX_CONSTRAINT_TYPE;
/* skip btTypedConstraint_33 : unnamed */
public threaded struct extern "::btTypedConstraint::btConstraintInfo1" btTypedConstraint_btConstraintInfo1 {
  public int m_numConstraintRows;
  public int nub;
}
public threaded struct extern "::btTypedConstraint::btConstraintInfo2" btTypedConstraint_btConstraintInfo2 {
  public btScalar fps;
  public btScalar erp;
  public rptr{btScalar} m_J1linearAxis;
  public rptr{btScalar} m_J1angularAxis;
  public rptr{btScalar} m_J2linearAxis;
  public rptr{btScalar} m_J2angularAxis;
  public int rowskip;
  public rptr{btScalar} m_constraintError;
  public rptr{btScalar} cfm;
  public rptr{btScalar} m_lowerLimit;
  public rptr{btScalar} m_upperLimit;
  public rptr{int} findex;
  public int m_numIterations;
  public btScalar m_damping;
}
public threaded struct extern "::btTypedObject" "nodefault" btTypedObject(int objectType)  {
  public int m_objectType;
  public function extern "getObjectType" int getObjectType() const;
}
public threaded struct extern "::btUniformScalingShape" "nodefault" btUniformScalingShape(rptr{btConvexShape} convexChildShape, btScalar uniformScalingFactor)  {
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec) const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors, rptr{btVector3} supportVerticesOut, int numVectors) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass, btVector3 mutable& inertia) const;
  public function extern "getUniformScalingFactor" btScalar getUniformScalingFactor() const;
  public function extern "getChildShape" rptr{btConvexShape} getChildShape();
  public function extern "getChildShape" crptr{btConvexShape} getChildShape1() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getAabb" void getAabb(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t, btVector3 mutable& aabbMin, btVector3 mutable& aabbMax) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling);
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "setMargin" void setMargin(btScalar margin);
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index, btVector3 mutable& penetrationVector) const;
  public metafunction __base__ {btConvexShape};
}
public threaded struct extern "::btUniversalConstraint" "nodefault" btUniversalConstraint(btRigidBody mutable& rbA, btRigidBody mutable& rbB, btVector3 const& anchor, btVector3 const& axis1, btVector3 const& axis2)  {
  public function extern "getAnchor" btVector3 const& getAnchor();
  public function extern "getAnchor2" btVector3 const& getAnchor2();
  public function extern "getAxis1" btVector3 const& getAxis1();
  public function extern "getAxis2" btVector3 const& getAxis2();
  public function extern "getAngle1" btScalar getAngle1();
  public function extern "getAngle2" btScalar getAngle2();
  public function extern "setUpperLimit" void setUpperLimit(btScalar ang1max, btScalar ang2max);
  public function extern "setLowerLimit" void setLowerLimit(btScalar ang1min, btScalar ang2min);
  public function extern "setAxis" void setAxis(btVector3 const& axis1, btVector3 const& axis2);
  public metafunction __base__ {btGeneric6DofConstraint};
}
public threaded struct extern "::btVector3" btVector3 {
  public rawarray{btScalar, 4} m_floats;
  public function extern "dot" btScalar dot(btVector3 const& v) const;
  public function extern "length2" btScalar length2() const;
  public function extern "length" btScalar length() const;
  public function extern "distance2" btScalar distance2(btVector3 const& v) const;
  public function extern "distance" btScalar distance(btVector3 const& v) const;
  public function extern "safeNormalize" btVector3 mutable& safeNormalize();
  public function extern "normalize" btVector3 mutable& normalize();
  public function extern "normalized" btVector3 normalized() const;
  public function extern "rotate" btVector3 rotate(btVector3 const& wAxis, btScalar const _angle) const;
  public function extern "angle" btScalar angle(btVector3 const& v) const;
  public function extern "absolute" btVector3 absolute() const;
  public function extern "cross" btVector3 cross(btVector3 const& v) const;
  public function extern "triple" btScalar triple(btVector3 const& v1, btVector3 const& v2) const;
  public function extern "minAxis" int minAxis() const;
  public function extern "maxAxis" int maxAxis() const;
  public function extern "furthestAxis" int furthestAxis() const;
  public function extern "closestAxis" int closestAxis() const;
  public function extern "setInterpolate3" void setInterpolate3(btVector3 const& v0, btVector3 const& v1, btScalar rt);
  public function extern "lerp" btVector3 lerp(btVector3 const& v, btScalar const& t) const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "setX" void setX(btScalar _x);
  public function extern "setY" void setY(btScalar _y);
  public function extern "setZ" void setZ(btScalar _z);
  public function extern "setW" void setW(btScalar _w);
  public function extern "x" btScalar const& x() const;
  public function extern "y" btScalar const& y() const;
  public function extern "z" btScalar const& z() const;
  public function extern "w" btScalar const& w() const;
  public function extern "setMax" void setMax(btVector3 const& other);
  public function extern "setMin" void setMin(btVector3 const& other);
  public function extern "setValue" void setValue(btScalar const& _x, btScalar const& _y, btScalar const& _z);
  public function extern "getSkewSymmetricMatrix" void getSkewSymmetricMatrix(rptr{btVector3} v0, rptr{btVector3} v1, rptr{btVector3} v2) const;
  public function extern "setZero" void setZero();
  public function extern "isZero" bool isZero() const;
  public function extern "fuzzyZero" bool fuzzyZero() const;
  public function extern "serialize" void serialize(btVector3FloatData mutable& dataOut) const;
  public function extern "deSerialize" void deSerialize(btVector3FloatData const& dataIn);
  public function extern "serializeFloat" void serializeFloat(btVector3FloatData mutable& dataOut) const;
  public function extern "deSerializeFloat" void deSerializeFloat(btVector3FloatData const& dataIn);
  public function extern "serializeDouble" void serializeDouble(btVector3DoubleData mutable& dataOut) const;
  public function extern "deSerializeDouble" void deSerializeDouble(btVector3DoubleData const& dataIn);
  public function extern "maxDot" int maxDot(crptr{btVector3} array, int array_count, btScalar mutable& dotOut) const;
  public function extern "minDot" int minDot(crptr{btVector3} array, int array_count, btScalar mutable& dotOut) const;
  public function extern "dot3" btVector3 dot3(btVector3 const& v0, btVector3 const& v1, btVector3 const& v2) const;
}
public threaded struct extern "::btVector3DoubleData" btVector3DoubleData {
  public rawarray{double, 4} m_floats;
}
public threaded struct extern "::btVector3FloatData" btVector3FloatData {
  public rawarray{float, 4} m_floats;
}
public threaded struct extern "::btVector4" btVector4 {
  public function extern "absolute4" btVector4 absolute4() const;
  public function extern "getW" btScalar getW() const;
  public function extern "maxAxis4" int maxAxis4() const;
  public function extern "minAxis4" int minAxis4() const;
  public function extern "closestAxis4" int closestAxis4() const;
  public function extern "setValue" void setValue(btScalar const& _x, btScalar const& _y, btScalar const& _z, btScalar const& _w);
  public metafunction __base__ {btVector3};
}
public threaded struct extern "::btVehicleRaycaster" "noncopyable" btVehicleRaycaster {
  public function extern "castRay" rptr{void} castRay(btVector3 const& from, btVector3 const& to, btVehicleRaycaster_btVehicleRaycasterResult mutable& result);
}
public threaded struct extern "::btVehicleRaycaster::btVehicleRaycasterResult" btVehicleRaycaster_btVehicleRaycasterResult {
  public btVector3 m_hitPointInWorld;
  public btVector3 m_hitNormalInWorld;
  public btScalar m_distFraction;
}
public threaded struct extern "::btVehicleTuning" "nodefault" btVehicleTuning private()  {
}
public threaded struct extern "::btVoronoiSimplexSolver" "nodefault" btVoronoiSimplexSolver private()  {
}
public threaded struct extern "::btWheelInfo" "nodefault" btWheelInfo(btWheelInfoConstructionInfo mutable& ci)  {
  public btWheelInfo_RaycastInfo m_raycastInfo;
  public btTransform m_worldTransform;
  public btVector3 m_chassisConnectionPointCS;
  public btVector3 m_wheelDirectionCS;
  public btVector3 m_wheelAxleCS;
  public btScalar m_suspensionRestLength1;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_wheelsRadius;
  public btScalar m_suspensionStiffness;
  public btScalar m_wheelsDampingCompression;
  public btScalar m_wheelsDampingRelaxation;
  public btScalar m_frictionSlip;
  public btScalar m_steering;
  public btScalar m_rotation;
  public btScalar m_deltaRotation;
  public btScalar m_rollInfluence;
  public btScalar m_maxSuspensionForce;
  public btScalar m_engineForce;
  public btScalar m_brake;
  public bool m_bIsFrontWheel;
  public rptr{void} m_clientInfo;
  public btScalar m_clippedInvContactDotSuspension;
  public btScalar m_suspensionRelativeVelocity;
  public btScalar m_wheelsSuspensionForce;
  public btScalar m_skidInfo;
  public function extern "getSuspensionRestLength" btScalar getSuspensionRestLength() const;
  public function extern "updateWheel" void updateWheel(btRigidBody const& chassis, btWheelInfo_RaycastInfo mutable& raycastInfo);
}
public threaded struct extern "::btWheelInfoConstructionInfo" btWheelInfoConstructionInfo {
  public btVector3 m_chassisConnectionCS;
  public btVector3 m_wheelDirectionCS;
  public btVector3 m_wheelAxleCS;
  public btScalar m_suspensionRestLength;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_wheelRadius;
  public btScalar m_suspensionStiffness;
  public btScalar m_wheelsDampingCompression;
  public btScalar m_wheelsDampingRelaxation;
  public btScalar m_frictionSlip;
  public btScalar m_maxSuspensionForce;
  public bool m_bIsFrontWheel;
}
public threaded struct extern "::btWheelInfo::RaycastInfo" btWheelInfo_RaycastInfo {
  public btVector3 m_contactNormalWS;
  public btVector3 m_contactPointWS;
  public btScalar m_suspensionLength;
  public btVector3 m_hardPointWS;
  public btVector3 m_wheelDirectionWS;
  public btVector3 m_wheelAxleWS;
  public bool m_isInContact;
  public rptr{void} m_groundObject;
}
public metafunction size_type int;
public threaded function extern "::btAabbSupport" btVector3 btAabbSupport(btVector3 const& halfExtents, btVector3 const& supportDir);
public threaded function extern "::btAcos" btScalar btAcos(btScalar x);
public threaded function extern "::btAdjustAngleToLimits" btScalar btAdjustAngleToLimits(btScalar angleInRadians, btScalar angleLowerLimitInRadians, btScalar angleUpperLimitInRadians);
public threaded function extern "::btAlignedAllocInternal" rptr{void} btAlignedAllocInternal(size_t size, int alignment);
public threaded function extern "::btAlignedAllocSetCustom" void btAlignedAllocSetCustom(rptr{btAllocFunc} allocFunc, rptr{btFreeFunc} freeFunc);
public threaded function extern "::btAlignedAllocSetCustomAligned" void btAlignedAllocSetCustomAligned(rptr{btAlignedAllocFunc} allocFunc, rptr{btAlignedFreeFunc} freeFunc);
public threaded function extern "::btAlignedFreeInternal" void btAlignedFreeInternal(rptr{void} ptr);
public threaded function extern "::btAngle" btScalar btAngle_btQuaternion_btQuaternion(btQuaternion const& q1, btQuaternion const& q2);
public threaded function extern "::btAngle" btScalar btAngle_btVector3_btVector3(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btAsin" btScalar btAsin(btScalar x);
public threaded function extern "::btAtan" btScalar btAtan(btScalar x);
public threaded function extern "::btAtan2" btScalar btAtan2(btScalar x, btScalar y);
public threaded function extern "::btAtan2Fast" btScalar btAtan2Fast(btScalar y, btScalar x);
public threaded function extern "::btBroadphaseProxy::isPolyhedral" "nocdecl" bool btBroadphaseProxy_isPolyhedral(int proxyType);
public threaded function extern "::btBroadphaseProxy::isConvex" "nocdecl" bool btBroadphaseProxy_isConvex(int proxyType);
public threaded function extern "::btBroadphaseProxy::isNonMoving" "nocdecl" bool btBroadphaseProxy_isNonMoving(int proxyType);
public threaded function extern "::btBroadphaseProxy::isConcave" "nocdecl" bool btBroadphaseProxy_isConcave(int proxyType);
public threaded function extern "::btBroadphaseProxy::isCompound" "nocdecl" bool btBroadphaseProxy_isCompound(int proxyType);
public threaded function extern "::btBroadphaseProxy::isSoftBody" "nocdecl" bool btBroadphaseProxy_isSoftBody(int proxyType);
public threaded function extern "::btBroadphaseProxy::isInfinite" "nocdecl" bool btBroadphaseProxy_isInfinite(int proxyType);
public threaded function extern "::btBroadphaseProxy::isConvex2d" "nocdecl" bool btBroadphaseProxy_isConvex2d(int proxyType);
public threaded function extern "::btCollisionDispatcher::defaultNearCallback" "nocdecl" void btCollisionDispatcher_defaultNearCallback(btBroadphasePair mutable& collisionPair, btCollisionDispatcher mutable& dispatcher, btDispatcherInfo const& dispatchInfo);
public threaded function extern "::btCollisionWorld::rayTestSingle" "nocdecl" void btCollisionWorld_rayTestSingle(btTransform const& rayFromTrans, btTransform const& rayToTrans, rptr{btCollisionObject} collisionObject, crptr{btCollisionShape} collisionShape, btTransform const& colObjWorldTransform, btCollisionWorld_RayResultCallback mutable& resultCallback);
public threaded function extern "::btCollisionWorld::rayTestSingleInternal" "nocdecl" void btCollisionWorld_rayTestSingleInternal(btTransform const& rayFromTrans, btTransform const& rayToTrans, crptr{btCollisionObjectWrapper} collisionObjectWrap, btCollisionWorld_RayResultCallback mutable& resultCallback);
public threaded function extern "::btCollisionWorld::objectQuerySingle" "nocdecl" void btCollisionWorld_objectQuerySingle(crptr{btConvexShape} castShape, btTransform const& rayFromTrans, btTransform const& rayToTrans, rptr{btCollisionObject} collisionObject, crptr{btCollisionShape} collisionShape, btTransform const& colObjWorldTransform, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedPenetration);
public threaded function extern "::btCollisionWorld::objectQuerySingleInternal" "nocdecl" void btCollisionWorld_objectQuerySingleInternal(crptr{btConvexShape} castShape, btTransform const& convexFromTrans, btTransform const& convexToTrans, crptr{btCollisionObjectWrapper} colObjWrap, btCollisionWorld_ConvexResultCallback mutable& resultCallback, btScalar allowedPenetration);
public threaded function extern "::btCos" btScalar btCos(btScalar x);
public threaded function extern "::btCross" btVector3 btCross(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btDbvt::maxdepth" "nocdecl" int btDbvt_maxdepth(crptr{btDbvtNode} node);
public threaded function extern "::btDbvt::countLeaves" "nocdecl" int btDbvt_countLeaves(crptr{btDbvtNode} node);
public threaded function extern "::btDbvt::extractLeaves" "nocdecl" void btDbvt_extractLeaves(crptr{btDbvtNode} node, btAlignedObjectArray_btDbvtNode_const_p mutable& leaves);
public threaded function extern "::btDbvt::benchmark" "nocdecl" void btDbvt_benchmark();
public threaded function extern "::btDbvt::enumNodes" "nocdecl" void btDbvt_enumNodes(crptr{btDbvtNode} root, btDbvt_ICollide mutable& policy);
public threaded function extern "::btDbvt::enumLeaves" "nocdecl" void btDbvt_enumLeaves(crptr{btDbvtNode} root, btDbvt_ICollide mutable& policy);
public threaded function extern "::btDbvt::rayTest" "nocdecl" void btDbvt_rayTest(crptr{btDbvtNode} root, btVector3 const& rayFrom, btVector3 const& rayTo, btDbvt_ICollide mutable& policy);
public threaded function extern "::btDbvt::collideKDOP" "nocdecl" void btDbvt_collideKDOP(crptr{btDbvtNode} root, crptr{btVector3} normals, crptr{btScalar} offsets, int count, btDbvt_ICollide mutable& policy);
public threaded function extern "::btDbvt::collideOCL" "nocdecl" void btDbvt_collideOCL(crptr{btDbvtNode} root, crptr{btVector3} normals, crptr{btScalar} offsets, btVector3 const& sortaxis, int count, btDbvt_ICollide mutable& policy, bool fsort);
public threaded function extern "::btDbvt::collideTU" "nocdecl" void btDbvt_collideTU(crptr{btDbvtNode} root, btDbvt_ICollide mutable& policy);
public threaded function extern "::btDbvt::nearest" "nocdecl" int btDbvt_nearest(crptr{int} i, crptr{btDbvt_sStkNPS} a, btScalar v, int l, int h);
public threaded function extern "::btDbvt::allocate" "nocdecl" int btDbvt_allocate(btAlignedObjectArray_int mutable& ifree, btAlignedObjectArray_btDbvt_sStkNPS mutable& stock, btDbvt_sStkNPS const& value);
public threaded function extern "::btDbvtAabbMm::FromCE" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromCE(btVector3 const& c, btVector3 const& e);
public threaded function extern "::btDbvtAabbMm::FromCR" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromCR(btVector3 const& c, btScalar r);
public threaded function extern "::btDbvtAabbMm::FromMM" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromMM(btVector3 const& mi, btVector3 const& mx);
public threaded function extern "::btDbvtAabbMm::FromPoints" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromPoints(crptr{btVector3} pts, int n);
public threaded function extern "::btDbvtAabbMm::FromPoints" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromPoints1(rptr{crptr{btVector3}} ppts, int n);
public threaded function extern "::btDbvtBroadphase::benchmark" "nocdecl" void btDbvtBroadphase_benchmark(rptr{btBroadphaseInterface} _0);
public threaded function extern "::btDegrees" btScalar btDegrees(btScalar x);
public threaded function extern "::btDistance" btScalar btDistance(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btDistance2" btScalar btDistance2(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btDot" btScalar btDot(btVector3 const& v1, btVector3 const& v2);
public threaded function extern "::btEqual" bool btEqual(btScalar a, btScalar eps);
public threaded function extern "::btExp" btScalar btExp(btScalar x);
public threaded function extern "::btFabs" btScalar btFabs(btScalar x);
public threaded function extern "::btFmod" btScalar btFmod(btScalar x, btScalar y);
public threaded function extern "::btFsel" btScalar btFsel(btScalar a, btScalar b, btScalar c);
public threaded function extern "::btFuzzyZero" bool btFuzzyZero(btScalar x);
public threaded function extern "::btGetVersion" int btGetVersion();
public threaded function extern "::btGreaterEqual" bool btGreaterEqual(btScalar a, btScalar eps);
public threaded function extern "::btIsNegative" int btIsNegative(btScalar x);
public threaded function extern "::btLog" btScalar btLog(btScalar x);
public threaded function extern "::btMachineIsLittleEndian" bool btMachineIsLittleEndian();
public threaded function extern "::btManifoldResult::calculateCombinedRestitution" "nocdecl" btScalar btManifoldResult_calculateCombinedRestitution(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
public threaded function extern "::btManifoldResult::calculateCombinedFriction" "nocdecl" btScalar btManifoldResult_calculateCombinedFriction(crptr{btCollisionObject} body0, crptr{btCollisionObject} body1);
public threaded function extern "::btMatrix3x3::getIdentity" "nocdecl" btMatrix3x3 const& btMatrix3x3_getIdentity();
public threaded function extern "::btNormalizeAngle" btScalar btNormalizeAngle(btScalar angleInRadians);
public threaded function extern "::btOptimizedBvh::deSerializeInPlace" "nocdecl" rptr{btOptimizedBvh} btOptimizedBvh_deSerializeInPlace(rptr{void} i_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian);
public threaded function extern "::btOutcode" int btOutcode(btVector3 const& p, btVector3 const& halfExtent);
public threaded function extern "::btPow" btScalar btPow(btScalar x, btScalar y);
public threaded function extern "::btQuantizedBvh::deSerializeInPlace" "nocdecl" rptr{btQuantizedBvh} btQuantizedBvh_deSerializeInPlace(rptr{void} i_alignedDataBuffer, uint i_dataBufferSize, bool i_swapEndian);
public threaded function extern "::btQuantizedBvh::getAlignmentSerializationPadding" "nocdecl" uint btQuantizedBvh_getAlignmentSerializationPadding();
public threaded function extern "::btQuaternion::getIdentity" "nocdecl" btQuaternion const& btQuaternion_getIdentity();
public threaded function extern "::btRadians" btScalar btRadians(btScalar x);
public threaded function extern "::btRayAabb" bool btRayAabb(btVector3 const& rayFrom, btVector3 const& rayTo, btVector3 const& aabbMin, btVector3 const& aabbMax, btScalar mutable& param, btVector3 mutable& normal);
public threaded function extern "::btRayAabb2" bool btRayAabb2(btVector3 const& rayFrom, btVector3 const& rayInvDirection, crptr{uint} raySign, crptr{btVector3} bounds, btScalar mutable& tmin, btScalar lambda_min, btScalar lambda_max);
public threaded function extern "::btRigidBody::upcast" "nocdecl" crptr{btRigidBody} btRigidBody_upcast(crptr{btCollisionObject} colObj);
public threaded function extern "::btRigidBody::upcast" "nocdecl" rptr{btRigidBody} btRigidBody_upcast1(rptr{btCollisionObject} colObj);
public threaded function extern "::btSelect" float btSelect_uint_float_float(uint condition, float valueIfConditionNonZero, float valueIfConditionZero);
public threaded function extern "::btSelect" int btSelect_uint_int_int(uint condition, int valueIfConditionNonZero, int valueIfConditionZero);
public threaded function extern "::btSelect" uint btSelect_uint_uint_uint(uint condition, uint valueIfConditionNonZero, uint valueIfConditionZero);
public threaded function extern "::btSimpleBroadphase::aabbOverlap" "nocdecl" bool btSimpleBroadphase_aabbOverlap(rptr{btSimpleBroadphaseProxy} proxy0, rptr{btSimpleBroadphaseProxy} proxy1);
public threaded function extern "::btSin" btScalar btSin(btScalar x);
public threaded function extern "::btSqrt" btScalar btSqrt(btScalar y);
public threaded function extern "::btStrLen" int btStrLen(crptr{char} str);
public threaded function extern "::btSwapEndian" uint btSwapEndian_int(int val);
public threaded function extern "::btSwapEndian" ushort btSwapEndian_short(short val);
public threaded function extern "::btSwapEndian" uint btSwapEndian_uint(uint val);
public threaded function extern "::btSwapEndian" ushort btSwapEndian_ushort(ushort val);
public threaded function extern "::btSwapEndianDouble" void btSwapEndianDouble(double d, rptr{uchar} dst);
public threaded function extern "::btSwapEndianFloat" uint btSwapEndianFloat(float d);
public threaded function extern "::btSwapScalarEndian" void btSwapScalarEndian(btScalar const& sourceVal, btScalar mutable& destVal);
public threaded function extern "::btSwapVector3Endian" void btSwapVector3Endian(btVector3 const& sourceVec, btVector3 mutable& destVec);
public threaded function extern "::btTan" btScalar btTan(btScalar x);
public threaded function extern "::btTransform::getIdentity" "nocdecl" btTransform const& btTransform_getIdentity();
public threaded function extern "::btTransformAabb" void btTransformAabb_btVector3_btVector3_btScalar_btTransform_btVector3_btVector3(btVector3 const& localAabbMin, btVector3 const& localAabbMax, btScalar margin, btTransform const& trans, btVector3 mutable& aabbMinOut, btVector3 mutable& aabbMaxOut);
public threaded function extern "::btTransformAabb" void btTransformAabb_btVector3_btScalar_btTransform_btVector3_btVector3(btVector3 const& halfExtents, btScalar margin, btTransform const& t, btVector3 mutable& aabbMinOut, btVector3 mutable& aabbMaxOut);
public threaded function extern "::btTransformUtil::integrateTransform" "nocdecl" void btTransformUtil_integrateTransform(btTransform const& curTrans, btVector3 const& linvel, btVector3 const& angvel, btScalar timeStep, btTransform mutable& predictedTransform);
public threaded function extern "::btTransformUtil::calculateVelocityQuaternion" "nocdecl" void btTransformUtil_calculateVelocityQuaternion(btVector3 const& pos0, btVector3 const& pos1, btQuaternion const& orn0, btQuaternion const& orn1, btScalar timeStep, btVector3 mutable& linVel, btVector3 mutable& angVel);
public threaded function extern "::btTransformUtil::calculateDiffAxisAngleQuaternion" "nocdecl" void btTransformUtil_calculateDiffAxisAngleQuaternion(btQuaternion const& orn0, btQuaternion const& orn1a, btVector3 mutable& axis, btScalar mutable& angle);
public threaded function extern "::btTransformUtil::calculateVelocity" "nocdecl" void btTransformUtil_calculateVelocity(btTransform const& transform0, btTransform const& transform1, btScalar timeStep, btVector3 mutable& linVel, btVector3 mutable& angVel);
public threaded function extern "::btTransformUtil::calculateDiffAxisAngle" "nocdecl" void btTransformUtil_calculateDiffAxisAngle(btTransform const& transform0, btTransform const& transform1, btVector3 mutable& axis, btScalar mutable& angle);
public threaded function extern "::btTriple" btScalar btTriple(btVector3 const& v1, btVector3 const& v2, btVector3 const& v3);
public threaded function extern "::btTypedConstraint::getFixedBody" "nocdecl" btRigidBody mutable& btTypedConstraint_getFixedBody();
public threaded function extern "::btUnSwapVector3Endian" void btUnSwapVector3Endian(btVector3 mutable& vector);
public threaded function extern "::btUnswapEndianDouble" double btUnswapEndianDouble(crptr{uchar} src);
public threaded function extern "::btUnswapEndianFloat" float btUnswapEndianFloat(uint a);
