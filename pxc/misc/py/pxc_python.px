public namespace pxc_python "use-unsafe";
public import common -;
public import fuga -;
public import meta m;

{
  register_class{fuga::fuga}();
}

public function {t} void register_class()
{
  register_class_caller_c{register_class_caller{t}} c;
  c.do_register();
}

private struct extern "pxc_python::register_class_caller_c" {caller}
register_class_caller_c {
  function extern "do_register" void do_register();
}

private struct {klass} register_class_caller {
  function void call() {
    register_class_internal{klass}();
  }
}

private function {klass} void register_class_internal()
{
  extern "emit" m::concat{cdef{klass}, mfdefs{klass}, flddefs{klass}};
}

private metafunction pyname{t}
  m::subst{
    m::subst{
      m::subst{m::full_string{t}, "::", "_"},
    "{", ""},
  "}", ""};
private metafunction cdef{t}
  m::concat{
    "boost::python::class_< ", m::csymbol{t}, " >(\"", pyname{t},
    "\"", inidef{t}, ")"};
private metafunction concat_sep{lst, sep}
  m::fold{
    lst,
    metafunction{x, y} m::cond{m::eq{x, ""}, y, m::concat{x, ", ", y}},
    ""};
private metafunction arg_cdecl{arg}
  m::concat{
    m::csymbol{m::at{arg, 1}},
    m::cond{m::at{arg, 3}, "", " const"},
    m::cond{m::at{arg, 2}, " &", ""}};
private metafunction inidef{t}
  m::cond{
    m::eq{m::arg_size{t}, 0},
    "",
    m::concat{
      ", boost::python::init< ",
      concat_sep{m::map{m::args{t}, arg_cdecl}, ", "},
      " >()"}};
private metafunction mfdef{t, f}
  m::concat{".def(\"", f, "\", &", m::csymbol{t}, "::", m::csymbol{f}, ")"};
private metafunction mfdefs{t}
  m::fold{
    m::map{m::member_functions{t}, metafunction{f} mfdef{t, f}},
    m::concat, ""};
private metafunction flddef{t, i}
  m::concat{
    m::cond{m::at3{m::at{m::fields{t}, i}},
      ".def_readwrite(\"",
      ".def_readonly(\""},
    m::at{m::field_names{t}, i}, "\", &",
    m::csymbol{t}, "::", m::csymbol{t, i}, ")"};
private metafunction flddefs{t}
  m::fold{
    m::map{m::seq{m::size{m::fields{t}}}, metafunction{i} flddef{t, i}},
    m::concat, ""};

extern "types" inline

#include <string>
#include <boost/python.hpp>

namespace pxc_python {

struct init_chain {
  void (*func)();
  init_chain *next;
};

static void add_init_chain(init_chain *p);

template <typename Tcaller> struct register_class_caller_c {
  void do_register() {
    init_chain_value.func = &call;
    init_chain_value.next = 0;
    add_init_chain(&init_chain_value);
  }
  static void call() {
    Tcaller caller;
    caller.call$f();
  }
  static init_chain init_chain_value;
};

template <typename Tcaller> init_chain
register_class_caller_c<Tcaller>::init_chain_value;

}; // namespace pxc_python

;

extern "implementation" inline

#include <string>
#include <boost/python.hpp>

namespace pxc_python {

typedef pxcrt::pxcvector<unsigned char> pxcstring;
typedef pxcrt::cstrref cstrref;

struct pystr_to_pxcstr {
  pystr_to_pxcstr() {
    boost::python::converter::registry::push_back(
      &convertible, &construct, boost::python::type_id<pxcstring>());
  }
  static void *convertible(PyObject *obj) {
    if (!PyString_Check(obj)) { return 0; }
    return obj;
  }
  static void construct(PyObject *obj,
    boost::python::converter::rvalue_from_python_stage1_data *data) {
    char *sval = 0;
    Py_ssize_t len = 0;
    PyString_AsStringAndSize(obj, &sval, &len);
    if (sval == 0) { boost::python::throw_error_already_set(); }
    void *storage =
      ((boost::python::converter::rvalue_from_python_storage<pxcstring>*)data)
	->storage.bytes;
    const unsigned char *p = reinterpret_cast<const unsigned char *>(sval);
    new (storage) pxcstring(p, len);
    data->convertible = storage;
  }
};

struct pystr_to_cstrref {
  pystr_to_cstrref() {
    boost::python::converter::registry::push_back(
      &convertible, &construct, boost::python::type_id<cstrref>());
  }
  static void *convertible(PyObject *obj) {
    if (!PyString_Check(obj)) { return 0; }
    return obj;
  }
  static void construct(PyObject *obj,
    boost::python::converter::rvalue_from_python_stage1_data *data) {
    char *sval = 0;
    Py_ssize_t len = 0;
    PyString_AsStringAndSize(obj, &sval, &len);
    if (sval == 0) { boost::python::throw_error_already_set(); }
    void *storage =
      ((boost::python::converter::rvalue_from_python_storage<cstrref>*)data)
	->storage.bytes;
    const unsigned char *p = reinterpret_cast<const unsigned char *>(sval);
    new (storage) cstrref(p, len);
    data->convertible = storage;
  }
};

static init_chain *init_chain_top;

static void add_init_chain(init_chain *p)
{
  p->next = init_chain_top;
  init_chain_top = p;
}

static void pxc_python_init()
{
  pystr_to_pxcstr();
  pystr_to_cstrref();
  boost::python::class_<pxcstring>("string", boost::python::init<cstrref>());
  boost::python::implicitly_convertible<pxcstring, cstrref>();
}

}; // namespace pxc_python

extern "C" int pxc_library_init();

BOOST_PYTHON_MODULE(pxc_python)
{
  pxc_library_init();
  pxc_python::pxc_python_init();
  pxc_python::init_chain *p = pxc_python::init_chain_top;
  while (p != 0) {
    (*(p->func))();
    p = p->next;
  }
}

;

extern "incdir"
  "`python -c 'from distutils.sysconfig import *; print get_python_inc()'`";
extern "ldflags" "-lboost_python";

/* pxc --no-execute -p /etc/pxc_dynamic.profile -g pxc_python.px */

