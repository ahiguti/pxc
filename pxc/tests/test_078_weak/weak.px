public namespace weak "use-unsafe";
import common -;
import meta m;

valuetype struct extern "pxcrt::weak" {t} weak(t const& v0) {
  // TODO t must be defcon
  t value = v0;
}

valuetype struct extern "pxcrt::strong" {t} strong (t const& p0) {
  check_tparam_for_strong{t} pointer = p0;
}

private metafunction check_tparam_for_strong{t}
  m::cond{
    m::and{
      m::eq{m::full_string{m::base{t}}, "pointer::ptr{}"},
      m::eq{m::full_string{m::base{m::at0{t}}}, "weak::weak{}"}
    },
    t,
    m::error{m::concat{"invalid type: ", m::full_string{t}}}};

extern "types" inline
namespace pxcrt {

template <typename T> struct weak {
  weak(const T& v) : value(v), strong_count(0) { }
  weak(const weak& x) : value(x.value), strong_count(0) { }
  weak& operator =(const weak& x) {
    if (this != &x) {
      value = x.value;
    }
    return *this;
  }
  void strong_incref() {
    ++strong_count;
  }
  void strong_decref() {
    if (--strong_count == 0) {
      value = T();
    }
  }
  T value;
  size_t strong_count;
};

template <typename T> struct strong {
  strong(const T& p) : pointer(p) {
    pointer->value.strong_incref();
  }
  strong(const strong& x) : pointer(x.pointer) {
    pointer->value.strong_incref();
  }
  strong& operator =(const strong& x) {
    if (&x != this) {
      x.pointer->value.strong_incref();
      pointer->value.strong_decref();
      pointer = x.pointer;
    }
    return *this;
  }
  ~strong() {
    pointer->value.strong_decref();
  }
  T pointer;
};

}; // namespace pxcrt
;

