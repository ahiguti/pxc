namespace svr;
import common "";
import io "";
import io::file "";
import io::errno "";
import io::net::addrinfo "";
import io::net::socket "";
import thread "";

multithreaded struct server_thread(ioptr const& i, tptr{bool} const& rp,
  tptr{string} const& s)
{
  ioptr const iop = i;
  tptr{bool} readyp = rp;
  tptr{string} str_r = s;
  function void main()
  {
    var gaieh = gai_eh(error::policy_throw);
    var ioeh = errno_eh(error::policy_throw);
    var ai = addrinfo(iop, "localhost", "9999", AF_INET, SOCK_STREAM,
      PROTO_UNSPEC, AI_PASSIVE, gaieh);
    var sf = socket_factory(iop, true, ai.get_sockaddr(), SOCK_STREAM,
      PROTO_UNSPEC, 1024, ioeh);
    *readyp = true;
    var peer_addr = sockaddr_storage();
    var sock = socket(sf, peer_addr, ioeh);
    string s;
    size_t len = 10;
    sock.read(s, len, ioeh);
    *str_r = s;
  }
}

multithreaded struct client_thread(ioptr const& i, tptr{bool} const& rp)
{
  ioptr const iop = i;
  tptr{bool} readyp = rp;
  function void main()
  {
    while (!*readyp) { io_usleep(iop, 1); } // TODO: condition variable
    var gaieh = gai_eh(error::policy_throw);
    var ioeh = errno_eh(error::policy_throw);
    var ai = addrinfo(iop, "localhost", "9999", AF_INET, SOCK_STREAM,
      PROTO_UNSPEC, 0, gaieh);
    var sf = socket_factory(iop, false, ai.get_sockaddr(), SOCK_STREAM,
      PROTO_UNSPEC, 0, ioeh);
    var peer_addr = sockaddr_storage();
    var sock = socket(sf, peer_addr, ioeh);
    sock.write("hoge", ioeh);
  }
}

function void t1()
{
  var readyp = tptr(bool(false));
  var strp = tptr(string());
  var sthr = thread_create(server_thread(io::io, readyp, strp));
  var cthr = thread_create(client_thread(io::io, readyp));
  sthr.join();
  cthr.join();
  println(*strp);
}

t1();

