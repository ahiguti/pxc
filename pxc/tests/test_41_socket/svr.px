namespace svr;
import common -;
import io -;
import io::file -;
import io::errno -;
import io::standard -;
import io::net::addrinfo -;
import io::net::socket -;
import io::signal -;
import thread -;

multithreaded struct server_thread(io const& i, tptr{bool} const& rp,
  tptr{string} const& s)
{
  io const iop = i;
  tptr{bool} readyp = rp;
  tptr{string} str_r = s;
  function void notify()
  {
    var lck = lockobject{bool}(readyp);
    *lck = true;
    lck.notify_one();
  }
  function void main()
  {
    try {
      file_println(get_stderr(iop), "svr");
      var sf = create_acceptor(iop, "localhost", "9999", AF_INET, SOCK_STREAM,
	1024, 0); // TODO: fix EADDRINUSE
      file_println(get_stderr(iop), "accepted");
      notify();
      errno_t ern;
      var peer_addr = sockaddr_storage();
      var sock = accept(sf, peer_addr, ern);
      string s;
      size_t len = 10;
      sock.read(s, len, ern);
      *str_r = s;
    } catch (exception::common::exception e) {
      file_println(get_stderr(iop), "thrown");
      notify();
    } catch (io::errno::errno_t e) {
      file_println(get_stderr(iop), "thrown errno");
      notify();
    }
  }
}

multithreaded struct client_thread(io const& i, tptr{bool} const& rp)
{
  io const iop = i;
  tptr{bool} readyp = rp;
  function void main()
  {
    {
      var lck = clockobject{bool}(readyp);
      while (true) {
	if (*lck) { break; }
	lck.wait();
      }
    }
    file_println(get_stderr(iop), "got notification");
    errno_t ern;
    var sf = create_connector(iop, "localhost", "9999", AF_INET, SOCK_STREAM,
      10);
    var sock = connect(sf, ern);
    sock.write("hoge", ern);
  }
}

function void t1()
{
  errno_t ern;
  signal(io::system, SIGPIPE, SIG_IGN, ern);
  var readyp = tptr(bool(false));
  var strp = tptr(string());
  var sthr = create_thread(server_thread(io::system, readyp, strp));
  var cthr = create_thread(client_thread(io::system, readyp));
  sthr.join();
  cthr.join();
  println(*strp);
}

t1();

