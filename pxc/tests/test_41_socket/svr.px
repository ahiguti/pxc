namespace svr;
import common -;
import io -;
import io::file -;
import io::errno -;
import io::standard -;
import io::net::addrinfo -;
import io::net::socket -;
import io::signal -;
import thread -;

multithreaded struct server_thread(ioptr const& i, tptr{bool} const& rp,
  tptr{string} const& s)
{
  ioptr const iop = i;
  tptr{bool} readyp = rp;
  tptr{string} str_r = s;
  function void main()
  {
    var ioeh = errno_eh(error::policy_throw);
    var sf = socket_acceptor(iop, "localhost", "9999", AF_INET, SOCK_STREAM,
      1024);
    {
      var lck = lockobject{bool}(readyp);
      *lck = true;
      lck.notify_one();
    }
    var peer_addr = sockaddr_storage();
    var sock = socket(sf, peer_addr, ioeh);
    string s;
    size_t len = 10;
    sock.read(s, len, ioeh);
    *str_r = s;
  }
}

multithreaded struct client_thread(ioptr const& i, tptr{bool} const& rp)
{
  ioptr const iop = i;
  tptr{bool} readyp = rp;
  function void main()
  {
    {
      var lck = clockobject{bool}(readyp);
      while (true) {
	if (*lck) { break; }
	lck.wait();
      }
    }
    var ioeh = errno_eh(error::policy_throw);
    var sf = socket_connector(iop, "localhost", "9999", AF_INET, SOCK_STREAM,
      10);
    var peer_addr = sockaddr_storage();
    var sock = socket(sf, peer_addr, ioeh);
    sock.write("hoge", ioeh);
  }
}

function void t1()
{
  var ioeh = errno_eh(error::policy_throw);
  signal(io::io, SIGPIPE, SIG_IGN, ioeh);
  var readyp = tptr(bool(false));
  var strp = tptr(string());
  var sthr = thread_create(server_thread(io::io, readyp, strp));
  var cthr = thread_create(client_thread(io::io, readyp));
  sthr.join();
  cthr.join();
  println(*strp);
}

t1();

