import test_common "";

namespace thread;

public multithreaded extern "pxcthread::thread_impl" struct thread { }
public macro thread_t tptr{thread};
public threaded extern "pxcthread::thread_join"
  function void thread_join(thread_t const& thr);
public threaded function {targs} thread_t create_thread(targs const& args)
{
  tptr{thrdata} r = tptr{thrdata_impl{targs}}(thrdata_impl{targs}(args));
  return create_thread_impl(r);
}

private multithreaded interface thrdata {
  function void main();
}
private multithreaded struct {targs} thrdata_impl(targs const& a) : thrdata : {
  targs args = a;
  function void main() {
    args.main();
  }
}
private threaded extern "pxcthread::create_thread_impl"
  function thread_t create_thread_impl(tptr{thrdata} const& f);

extern "type" inline
namespace pxcthread {
struct thread_impl;
};

extern "fdecl" inline
namespace pxcthread {
typedef pxcrt::rcptr< pxcrt::trcval<thread_impl> > thread_ptr;
typedef pxcrt::rcptr< thread$n::thrdata$i > thrdata_ptr;
typedef thread$n::thrdata$i *thrdata_rawptr;
struct thread_impl {
  thread_impl(thrdata_ptr const& m) : tid(), need_join(false), mptr(m) { }
  thread_impl() : tid(), need_join(false), mptr() { }
  ~thread_impl() { join(); }
  void join();
  pthread_t tid;
  bool need_join;
  thrdata_ptr mptr;
private:
  thread_impl(const thread_impl&);
  thread_impl& operator =(const thread_impl&);
};
thread_ptr create_thread_impl(thrdata_ptr const& m);
void thread_join(thread_ptr const& t);
};

extern "fdef" inline
#define DBG(x)
namespace pxcthread {
void *pxc_thread_child_main(void *arg)
{
  thrdata_rawptr m = static_cast<thrdata_rawptr>(arg);
  /* pxcrt::lockobject lck(m->get_mutex$z()); */ /* not necessary */
  try {
    m->main$f();
  } catch (...) {
    /* ignore? */
  }
  return 0;
}
thread_ptr create_thread_impl(thrdata_ptr const& m)
{
  thread_ptr thr = thread_ptr(pxcrt::boxing(), m);
  thread_impl& impl = thr->value$z;
  if (pthread_create(&impl.tid, 0, pxc_thread_child_main, m.get()) != 0) {
    DBG(fprintf(stderr, "failed to create thread\n"));
  } else {
    DBG(fprintf(stderr, "create thread\n"));
    impl.need_join = true;
  }
  return thr;
}
void thread_join(thread_ptr const& t)
{
  if (t == 0) {
    return;
  }
  pxcrt::lockobject lck(t->get_mutex$z());
  t->value$z.join();
}
void thread_impl::join()
{
  if (!need_join) {
    DBG(fprintf(stderr, "no need to join\n"));
    return;
  }
  if (tid == pthread_self()) {
    DBG(fprintf(stderr, "detach\n"));
    const int e = pthread_detach(tid);
    assert(e == 0);
  } else {
    DBG(fprintf(stderr, "join\n"));
    const int e = pthread_join(tid, 0);
    assert(e == 0);
  }
  need_join = false;
}
};
#undef DBG

