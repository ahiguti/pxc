namespace sock4;
import common -;
import exception::common -;
import io -;
import io::file -;
import io::errno -;
import io::standard -;
import io::net::addrinfo -;
import io::net::socket -;
import io::signal -;
import thread -;
import orb -;
import transport_file -;

public threaded interface ifoo <remote> {
  function int fold(cslice{int} const& x, int v0, ptr{ibinop} const& o);
}

public threaded struct foo <ifoo> {
  function int fold(cslice{int} const& x, int v0, ptr{ibinop} const& o) {
    var r = v0;
    for (size_t i, int v : x) {
      r = o->op(r, v);
    }
    return r;
  }
}

public threaded interface ibinop <remote> {
  function int op(int x, int y);
}

public threaded struct binop_add <ibinop> {
  function int op(int x, int y) {
    return x + y;
  }
}

private function void client_test_main(file const& f)
{
  var op = ptr(orb_handle{ifoo}(ptr(transport_file(f))));
  var st = op->create_stub();
  farray{int, 10} arr;
  for (int i : 0 .. 10) { arr[i] = i + 1; }
  var o = ptr(binop_add());
  var z = st->fold(arr, 0, o); /* o is called back from the server */
  println(z);
}

private multithreaded struct server_thread(io const& s, file const& f) {
  io const sys = s;
  file const sock = f;
  function void main() {
    var op = ptr(orb_handle{ifoo}(ptr(transport_file(sock))));
    var obj = ptr(foo());
    op->start_server(obj);
  }
}

private function void main()
{
  errno_t ern;
  signal(io::system, SIGPIPE, SIG_IGN, ern);
  var spv = socketpair(io::system, AF_UNIX, SOCK_STREAM, PROTO_UNSPEC, ern);
  var sthr = create_thread(server_thread(io::system, spv[1]));
  client_test_main(spv[0]);
  spv.clear();
}

main();

