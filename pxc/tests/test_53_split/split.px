namespace split;
import common -;
import text::conversion -;
import meta m;
import meta::family mf;

public metafunction va_argname{i} m::concat{"a", i};
public metafunction va_argnames{lst} m::map{m::seq{m::size{lst}}, va_argname};

public metafunction va_argdecls_const_ref{lst}
  m::map{m::seq{m::size{lst}}, va_arginfo_const_ref, lst};
public metafunction va_argdecls_mutable_ref{lst}
  m::map{m::seq{m::size{lst}}, va_arginfo_mutable_ref, lst};

private metafunction va_arginfo_const_ref{lst, i}
  m::list{va_argname{i}, m::at0{m::at{lst, i}}, 1, 0};
private metafunction va_arginfo_mutable_ref{lst, i}
  m::list{va_argname{i}, m::at0{m::at{lst, i}}, 1, 1};

/* split(str, delim, ret0, ret1, ...) */
public function {lst} bool split(expand(
  m::joinv{
    m::list{m::list{"str", cstrref, 1, 0}, m::list{"delim", uchar, 0, 0}},
    m::slice{va_argdecls_mutable_ref{lst}, 2}})) 
{
  size_t const sz = str.size();
  size_t curpos = 0;
  expand (arg, idx : m::slice{va_argnames{lst}, 2}) {
    {
      if (m::ne{idx, 0}) {
	if (curpos == sz) {
	  return false;
	}
	++curpos;
      }
      size_t const dp = find_mapped(str, curpos, delim);
      metafunction telem m::at0{m::at{lst, m::add{idx, 2}}};
      if (mf::is_string_or_slice_type{telem}) {
	arg = str[curpos .. dp];
      } else {
	cstrref s1 = str[curpos .. dp];
	arg = deserialize_from_string{m::at0{m::at{lst, m::add{idx, 2}}}}(s1);
      }
      curpos = dp;
    }
  }
  return true;
}

