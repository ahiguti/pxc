namespace split;
import common -;
import io::file -;
import io::errno -;
import io::buffered -;
import string::conversion -;
import meta::common m;

public metafunction va_argname{i} m::concat{"a", i};
public metafunction va_argnames{lst} m::map{m::seq{m::size{lst}}, va_argname};

public metafunction va_argdecls_const_ref{lst}
  m::map{m::seq{m::size{lst}}, va_arginfo_const_ref, lst};
public metafunction va_argdecls_mutable_ref{lst}
  m::map{m::seq{m::size{lst}}, va_arginfo_mutable_ref, lst};

private metafunction va_arginfo_const_ref{lst, i}
  m::list{va_argname{i}, m::at{lst, i}, 1, 0};
private metafunction va_arginfo_mutable_ref{lst, i}
  m::list{va_argname{i}, m::at{lst, i}, 1, 1};

public function {lst} bool split(expand(
  m::join_all{
    m::list{m::list{"str", cstrref, 1, 0}, m::list{"delim", uchar, 0, 0}},
    m::slice{va_argdecls_mutable_ref{lst}, 2}})) 
{
  size_t const sz = str.size();
  size_t curpos = 0;
  size_t epos = 0;
  expand (arg, idx : m::slice{va_argnames{lst}, 2}) {
    {
      if (m::ne{idx, 0}) {
	if (curpos == sz) {
	  return false;
	}
	++curpos;
      }
      size_t const dp = str.find(curpos, delim);
      metafunction telem m::at{lst, m::add{idx, 2}};
      if (container::string::is_string_family_type{telem}) {
	arg = str[curpos .. dp];
      } else {
	cstrref s1 = str[curpos .. dp];
	arg = deserialize_from_string{m::at{lst, m::add{idx, 2}}}(s1, epos);
	if (epos != 0) {
	  return false;
	}
      }
      curpos = dp;
    }
  }
  return true;
}

