public namespace dvalue;
public import common -;
public import meta m;

/* dynamically-typed value */
public threaded union dvalue
{
  public long i;
  public double f;
  public string s;
  public ptr{darray{dvalue}} a;
}

/* implicit conversion to dvalue */
public metafunction int___to{tto, tfrom} int_to_dvalue{tfrom};
public metafunction long___to{tto, tfrom} int_to_dvalue{tfrom};
public metafunction float___to{tto, tfrom} float_to_dvalue{tfrom};
public metafunction double___to{tto, tfrom} float_to_dvalue{tfrom};
public metafunction strlit___to{tto, tfrom} string_to_dvalue{tfrom};
public metafunction varray___to{tto, tfrom} string_to_dvalue{tfrom};
public metafunction cslice___to{tto, tfrom} string_to_dvalue{tfrom};
public metafunction tuple___to{tto, tfrom} tuple_to_dvalue{tfrom};

/* private */

private threaded function {tfrom} dvalue int_to_dvalue(tfrom x)
{
  dvalue a;
  a.i = static_cast{long}(x);
  return a;
}

private threaded function {tfrom} dvalue float_to_dvalue(tfrom x)
{
  dvalue a;
  a.f = static_cast{double}(x);
  return a;
}

private threaded function {tfrom} dvalue string_to_dvalue(tfrom const& x)
{
  dvalue a;
  a.s = x;
  return a;
}

private threaded function {tfrom} dvalue tuple_to_dvalue(tfrom const& v)
{
  size_t const sz = m::size{m::fields{tfrom}};
  const p = make_ptr{darray{dvalue}}(sz, dvalue());
  mutable& arr = *p;
  expand (sym, idx: m::field_names{tfrom}) {
    arr[idx] = v.sym;
  }
  dvalue a;
  a.a = p;
  return a;
}

