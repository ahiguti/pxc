
TODO:
- depth_texture使えるときに使う 
- androidでhighpためす
- モディファイヤ(頂点リストを変換する関数)を渡せるようにする
- 法線を軸に回転し押し出し(側面は四角形にならない)
  - 押し出さないで双方蓋をする
  - 押し出さないで描画もしない
- 押し出し、縦横それぞれ異なる比率で拡大縮小
- 単純な押し出しはモディファイヤをパラメータに取る。
- フラグメントシェーダが単純なときのiOSでの性能見る
- 物体が遠いときは細かい部分は描かない仕組み
  - ディテールは頂点配列の後ろのほうに寄せる。
  - 距離に応じて頂点配列の途中までをglDrawElementsする。
- シェーダ構造体を作る。uniformとattributeをフィールドとして持つ
  - あとはglutilにshaderを渡してattributeの設定をgenericに
- instancedを試す
- 文字列表示はタイルベースのテクスチャマップを使えば高速化できる
- normalを頂点ごとに
- vertexの比較を止めて、polygonの三角形分割をそのままつっこむ?
  - normalを頂点ごとにもたせれば頂点共通化しやすいので現状のほうがよい？
- androidでベンチマーク


glgeometry:
- 回転により膨らませる
  - 一辺を軸として回転により膨らませる
  - 一頂点に接する線分を軸として回転により膨らませる
  - 多角形の外部にある線分を軸として回転により膨らませる
- ひねる
  - 膨らませてひねる
  - 凸多角形の各辺の中点を頂点とする内接多角形
- dup
- 多角形頂点のスタックor配列にpushするfuncobj, それをpopするfuncobj

[基本の正多角形]
パラメータ: 頂点の数

[四角形等分割]
パラメータ: n, m
縦横n, m倍に分割する

[三角形分割]
三角形を一辺に平行な線分で複数に分割
パラメータ: 頂点, 分割数

[筒]
パラメータ: yz点列(y>0, zでソート)
yの値は倍率、
奥の面は元平面と同一
手前の面は元平面のzをずらせたもの
各頂点の手前と奥を長方形で結ぶ

(変換結果、四角形が平面にならない場合はどうするか？)
三角形に分割。どちらに分割するするかはパラメータで指定

------------------------
 \                    /
  \                  /
   \                /
    ----------------
UV 左上が(0,0), 右下が(1,1)

五角形以上は三角形の扇に分割し、底辺を(0,0)-(1,0)、頂点を(1,0)
例えば底辺に水平なラインを入れる法線マップ

生成する多角形と、基準となる向きを指定する変換行列も出力

筒を作るときは、各辺を伸ばした平面のUVの向きをパラメータとして取る。

テクスチャ・法線マップ
  +-----+
  |\ 3 /|
  | \ / |
  |2 x 1|
  | / \ |
  |/ 0 \|
  +-----+
3x3のビットマップから変換するか？
  -3-
  2-1
  -0-
2x2のビットマップから変換するか？
  23
  01


[子オブジェクト]
基本姿勢の位置への変換行列
可動部パラメータが与えられるとさらに変換

[]
与えられた面の中心を取る
面の基底は、
 (v0, v1)がEy
 (v1, v2)がEx
 その外積がEz

- 複数の子フラグメントのn番めにだけ適用したい、とかどうするか

tupleから引くのではなく、関数の合成としてデータを式で書けるようにしたい。
const geo =
  regular_polygon(2.0, 10,
    bump(0.3, 0.7, 3,
      bump(0.01, 0.9, 1, draw(), ()),
      fill()),
    bump(0.01, 0.9, 1, fill(), fill()));
regular_polygon等は関数ではなく関数オブジェクト。

/* 引数poly、返値voidの関数オブジェクト */
interface gfunc {
  function void __call(cslice{vec3} const& poly);
}

struct regular_polygon(float radius, size_t n, gfunc const& c0,
  gfunc const& c1) <gfunc>
{
  function void __call(cslice{vec3} const& poly) {
    ...
    c0(poly0);
    ...
    c1(poly1);
  }
}

glgeometryの関数はpoly_t以外を引数に取ることもあるかも
そうであっても最後の引数だけ未評価の関数オブジェクトをpublicに

カメラ位置と方向
vec3 camera_pos
quat camera_angle (長さは常に1)

対象の位置と方向とスケール
vec3 pos
quat angle_scale
mat4().translate(pos).multiply(angle_scale);

struct gobject_node {
  vec3 pos;
  quat angle_scale;
  size_t gobject_id;
  varray{ptr{gobject_node}} children;
}
drawではloc_mvpとloc_normal_matrix

edgeの変換行列を作る方法
多角形の中心を(px, py, pz)
最初の頂点から、反対側の頂点への線分をEx
法線ベクトルがEy
外積取ってEz
(Ex, Ey, Ez)
transform(px, py, pz)
mat3(Ex, Ey, Ez)

タイル
16x16のタイルが16x16個。(0,0)のタイルはフラット塗りつぶし。
各頂点のuvの下位4bitはタイル座標(xyそれぞれ0-16)を表す。
頂点シェーダがそれをテクスチャの座標へ変換
各頂点uvの8bitでタイル繰り返し回数を指定する
頂点シェーダからフラグメントシェーダへ渡すデータ:
  varying vec2 tile;
  varying vec2 tile_rep;
tileは四角形の頂点で1ずつ異なる値を持つ。
フラグメントシェーダでtile.xとtile.yをfloor()を取って
整数部分がタイル番号、小数部分をtile_rep倍してfract()
  vec2 tile0 = floor(tile);
  vec2 tile_fract = fract((tile - tile0) * tile_rep);
  vec2 uv = (tile0 + tile_fract) * 16.0;

512x512解像度、32x32のタイルを16回リピート
uv1: 0..512
uvi: 0..512 整数

ドット絵作成方法
32x32のタイル、偶数行タイルには法線マップ、奇数行タイルは色。
イメージをロードするときに合成しテクスチャにする。

メモ: FBOでシャドウマップ
(0) depth buffer用テクスチャ
マップの大きさ(sm_width, sm_height)とする。
glGenTextures(1, &dbuf);
glBindTexture(GL_TEXTURE_2D, dbuf);
glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, sm_width, sm_height, 0,
  GL_DEPTH_COMPONENT /* ??? */, GL_UNSIGNED_BYTE /* ??? */, 0);
glBindTexture(GL_TEXTURE_2D, 0);
(1) テクスチャへ描画するための準備
glGenFramebuffers(1, &fb);
glBindFramebuffer(GL_FRAMEBUFFER, fb);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D,
  dbuf, 0); /* FBOにテクスチャをアタッチする */
glDrawBuffer(GL_NONE); /* カラーは描かなくてよいのでNONE */
glReadBuffer(GL_NONE); /* glReadPixelsで読まないのでNONE? */
glBinfFramebuffer(GL_FRAMEBUFFER, 0);
(2) 描画
glBindFramebuffer(GL_FRAMEBUFFER, fb);
glClear(GL_DEPTH_BUFFER_BIT);

https://www.opengl.org/registry/specs/ARB/depth_texture.txt

depth_textureが無い場合はRGBA値に書き込めばいい

シャドウマップ参照
シャドウマップの時のmvp行列で頂点を変換する。
xyzそれぞれ(-1,1)から(0,1)へ変換
テクスチャを引く
引いた値とz値を比較、不一致なら影


vtx8 300x300 48fps

