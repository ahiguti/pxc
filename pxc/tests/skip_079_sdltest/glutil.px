public namespace glutil "export-unsafe";
import common -;
import pointer::raw -;
import numeric::fpmath -;
import numeric::quaternion -;
import SDL2 -;
import SDL2::Image -;
import GL::gles2 -;
import GL::glm glm;
import io::time -;
import meta m;
import exception -;

public tsvaluetype struct vertex {
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec2 uv;
}

public multithreaded struct vertices {
  public varray{uint} elements;
  public varray{float} vertex_values;
  public tree_map{vertex, uint} value_to_id;
  public uint vbo_values;
  public uint vbo_elems;
  public function void push(vertex const& value) {
    if (const id: value_to_id[value]) {
      elements.push_back(id);
      // debug_log("push", value, "id", id);
    } else {
      const id = static_cast{uint}(vertex_values.size() / 8);
      vertex_values.push_back(value.position.x);
      vertex_values.push_back(value.position.y);
      vertex_values.push_back(value.position.z);
      vertex_values.push_back(value.normal.x);
      vertex_values.push_back(value.normal.y);
      vertex_values.push_back(value.normal.z);
      vertex_values.push_back(value.uv.x);
      vertex_values.push_back(value.uv.y);
      value_to_id[value] = id;
      elements.push_back(id);
      // debug_log("push", value, "id", id);
    }
  }
}

function void check_error()
{
  const v = glGetError();
  if (v == GL_NO_ERROR) {
    return;
  }
  // debug_log(string_join{""}("glutil::check_error", static_cast{int}(v)));
  throw runtime_error_template{"glutil::check_error"}(
    to_string(static_cast{int}(v)));
}

public function bool vertices_create_vbo(vertices mutable& vs)
{
  farray{uint, 2} vbos;
  glGenBuffers(2, vbos.rawptr());
  check_error();
  if (vbos[0] == 0 || vbos[1] == 0) {
    return false;
  }
  glBindBuffer(GL_ARRAY_BUFFER, vbos[0]);
  check_error();
  glBufferData(GL_ARRAY_BUFFER,
    static_cast{GLsizeiptr}(vs.vertex_values.size()) * 4,
    vs.vertex_values.crawptr().void(), GL_STATIC_DRAW);
  check_error();
  glBindBuffer(GL_ARRAY_BUFFER, 0);
  check_error();
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[1]);
  check_error();
  glBufferData(GL_ELEMENT_ARRAY_BUFFER,
    static_cast{GLsizeiptr}(vs.elements.size()) * 4,
    vs.elements.crawptr().void(), GL_STATIC_DRAW);
  check_error();
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
  check_error();
  vs.vbo_values = vbos[0];
  vs.vbo_elems = vbos[1];
  println("values=", vs.vertex_values.size() / 8,
    "elems=", vs.elements.size());
  return true;
}

public function void vertices_draw(vertices const& vs, GLenum mode,
  size_t elem_offset, size_t elem_num, int attr_position, int attr_normal,
  int attr_uv)
{
  if (elem_offset + elem_num < elem_offset ||
    elem_offset + elem_num > vs.elements.size()) {
    throw runtime_error_template{"glutil::vertices_draw"}("range");
  }
  // println(attr_position, attr_normal);
  glBindBuffer(GL_ARRAY_BUFFER, vs.vbo_values);
  check_error();
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vs.vbo_elems);
  check_error();
  if (attr_position >= 0) {
    glEnableVertexAttribArray(static_cast{uint}(attr_position));
    check_error();
    glVertexAttribPointer(static_cast{uint}(attr_position), 3, GL_FLOAT, 0, 32,
      offset_to_void_cp(0));
    check_error();
  }
  if (attr_normal >= 0) {
    glEnableVertexAttribArray(static_cast{uint}(attr_normal));
    check_error();
    glVertexAttribPointer(static_cast{uint}(attr_normal), 3, GL_FLOAT, 0, 32,
      offset_to_void_cp(12));
    check_error();
  }
  if (attr_uv >= 0) {
    glEnableVertexAttribArray(static_cast{uint}(attr_uv));
    check_error();
    glVertexAttribPointer(static_cast{uint}(attr_uv), 2, GL_FLOAT, 0, 32,
      offset_to_void_cp(24));
    check_error();
  }
  glDrawElements(mode, static_cast{GLsizei}(elem_num), GL_UNSIGNED_INT,
    offset_to_void_cp(elem_offset * 4));
  check_error();
  if (attr_uv >= 0) {
    glDisableVertexAttribArray(static_cast{uint}(attr_uv));
    check_error();
  }
  if (attr_normal >= 0) {
    glDisableVertexAttribArray(static_cast{uint}(attr_normal));
    check_error();
  }
  if (attr_position != 0) {
    glDisableVertexAttribArray(static_cast{uint}(attr_position));
    check_error();
  }
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
  check_error();
  glBindBuffer(GL_ARRAY_BUFFER, 0);
  check_error();
}

