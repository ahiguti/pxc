public namespace recobj "export-unsafe";
import common -;
import pointer::raw -;
import numeric::fpmath -;
import SDL2 -;
import SDL2::Image -;
import SDL2::TTF -;
import GL::gles2 -;
import GL::gl30 -;
import GL::glm glm;
import io::time -;
import io::environ -;
import exception -;
import meta m;
import text::string::positional -;

import glshader -;
import gldraw -;
import glgeometry -;

private float distance_max = 1000.0;

metafunction enable_shadowmapping 1;

valuetype struct main_uniforms
{
  public glm::mat4 view_projection_matrix;
  public glm::mat4 model_matrix;
  public glm::mat3 normal_matrix;
  public int sampler;
  public int sampler_sm;
  public glm::vec3 camera_pos;
  public glm::vec3 light_pos;
  public glm::mat4 shadowmap_mvp;
}

valuetype struct main_vertex_attributes
{
  public glm::vec3 position;
  public glm::vec3 normal;
  public glm::vec4 tangent;
  public glm::vec2 uv;
}

valuetype struct shadowmap_uniforms
{
  public glm::mat4 shadowmap_mvp;
}

metafunction shadowmap_vertex_attributes main_vertex_attributes;

valuetype struct font_uniforms
{
  public int sampler;
}

valuetype struct font_vertex_attributes
{
  public glm::vec2 pos;
  public glm::vec2 uvpos;
}

metafunction main_shader shader{main_uniforms, main_vertex_attributes};
metafunction main_shader_ptr cptr{main_shader};
metafunction shadowmap_shader
  shader{shadowmap_uniforms, shadowmap_vertex_attributes};
metafunction shadowmap_shader_ptr cptr{shadowmap_shader};
metafunction font_shader shader{font_uniforms, font_vertex_attributes};
metafunction font_shader_ptr cptr{font_shader};

valuetype struct main_texture_info
{
  public uint surface_w;
  public uint surface_h;
  public uint main_texture_id;
}

valuetype struct font_texture_info
{
  public varray{uint} char_x;
  public uint char_h;
  public uint surface_w;
  public uint surface_h;
  public uint font_texture_id;
}

valuetype struct camera_info
{
  public glm::mat4 projection;
  public glm::quat camera_angle;
  public glm::vec3 camera_pos;
  public int screen_width;
  public int screen_height;
  public bool proj_light;
  public shadowmap_fbo sm;
  public glm::mat4 sm_projection;
  public glm::quat light_angle;
  public glm::vec3 light_pos;
}

function void build_vertices(buffer_object{main_vertex_attributes} mutable& bo)
{
  metafunction tattr m::symbol{main_shader, "vertex_attributes_type"};
  metafunction fill_v fill{tattr};
  metafunction edge_v edge{tattr};
  if (false) {
  /* vtx0 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx0 = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t0 = fill_v(vtx0);
    regular_polygon(0.3, 100,
      bump_rec(0.04, 0.5, 1, t0, t0),
      bump_rec(0.01, 0.9, 5,
	t0,
	sphere(10, t0)))
      (poly_t(), mesh_pos());
  }
  /* vtx1 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx1 = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t1 = fill_v(vtx1);
    regular_polygon(0.1, 4,
      bump_rec(8.0, 1.0, 1, t1, t1),
      t1)
      (poly_t(), mesh_pos());
  }
  /* vtx2 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx2 = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t2 = fill_v(vtx2);
    regular_polygon(10.0, 100,
      bump_rec(1.0, 1.0, 1, edge_v(vtx2, 0, hole()), hole()),
      hole())
      (poly_t(), mesh_pos());
  }
  /* vtx3 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx3 = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t3 = fill_v(vtx3);
    regular_polygon(0.2, 4,
      bump_rec(0.2828, 1.0, 1, t3, t3),
      t3)
      (poly_t(), mesh_pos());
  }
  /* vtx4 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx4 = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t4 = fill_v(vtx4);
    regular_polygon(30.0, 4, 
      rectangle_split(60, 60, edge_v(vtx4, 3, hole())),
      hole())
      (poly_t(), mesh_pos());
  }
  /* vtx5 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx5 = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t5 = fill_v(vtx5);
    const cube = bump_rec(0.0, 0.5, 1, hole(),
      lid(bump_rec(1.0, 1.0, 1, t5, t5), t5));
    regular_polygon(500.0, 4, 
      rectangle_split(100, 100, cube),
      hole())
      (poly_t(), mesh_pos());
  }
  }
  if (true) {
  /* vtx7 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t = fill_v(vtx);
    regular_polygon(170.0, 50, 
      bump_rec(-1.0, 1.0, 1, edge_v(vtx, 1, hole()), hole()),
      hole())
      (poly_t(), mesh_pos());
  }
  /* vtx6 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx6 = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t6 = fill_v(vtx6);
    const rnd = make_rand_generator(1U);
    regular_polygon(5.0, 4,
      bump_rec(1.0, 1.0, 1,
	t6,
	rand_bump(10, 0.08, 0.02, 0.08, 0.02, 0.08, 0.05, 0.100, rnd,
	  t6, t6, t6)),
      t6)
      (poly_t(), mesh_pos());
  }
  }
  /* vtx8 */
  {
    bo.vs_arr.push_back(vertex_set{tattr}());
    const vtx = bo.vs_arr[bo.vs_arr.size() - 1].vtxs;
    const t = fill_v(vtx);
    const rnd = make_rand_generator(1U);
    regular_polygon(20.0, 4,
      rectangle_split(300, 300,
	rand_bump(1, 0.8, 0.2, 0.8, 0.2, 0.8, 0.2, 0.8, rnd,
	  t, t, t)), hole())
      (poly_t(), mesh_pos());
  }
  for (const i, const& a: bo.vs_arr) {
    println(i, "vtxs", a.vtxs->vertex_values.size(), "elems",
      a.vtxs->elements.size());
  }
}

function uint draw_frame(camera_info mutable& cam, main_shader_ptr const& sdr,
  shadowmap_fbo const& sfbo, shadowmap_shader_ptr const& smsdr,
  buffer_object{main_vertex_attributes} const& bo, font_shader_ptr const& psdr,
  font_texture_info const& fti, cstrref const& mess)
{
  // println("draw_frame enter");
  const sn = bo.instantiate_scene(2);
  /* shadowmap view and view-projection matrix */
  {
    // cam.light_pos = cam.camera_pos + glm::make_vec3(15.0, -15.0, 0.0);
    cam.light_pos = cam.camera_pos +
      cam.camera_angle.to_mat3() * glm::make_vec3(3.0, 3.0, 8.0);
    cam.light_angle = cam.camera_angle;
  }
  const sm_view = (
    glm::mat4().translate(cam.light_pos) * cam.light_angle.to_mat4())
    .inverse();
  const sm_vp = cam.sm_projection * sm_view;
  if (m::ne{enable_shadowmapping, 0}) {
    check_error();
    int saved_fb;
    glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
    check_error();
    // sdllog(string_join{" "}("saved_fb", saved_fb));
    /* shadowmap */
    // sdllog(string_join{" "}("draw_frame smsdr", smsdr->program));
    glUseProgram(smsdr->program);
    check_error();
    if (true) {
      glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo);
      check_error();
      glViewport(0, 0, static_cast{GLsizei}(sfbo.sm_width),
	static_cast{GLsizei}(sfbo.sm_height));
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      check_error();
    }
    else {
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
    glEnable(GL_CULL_FACE);
    // glFrontFace(GL_CW);
    // glCullFace(GL_FRONT);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glDisable(GL_BLEND);
    {
      if (false) {
	const y = sm_view * glm::make_vec4(0.0, 0.0, 0.0, 1.0);
	println("sm_mv(0) =>", y);
	mutable x = sm_vp * glm::make_vec4(0.0, 0.0, 0.0, 1.0);
	println("sm_mvp(0) =>", x);
	glm::mat4 mutable view;
	view = (view.translate(cam.camera_pos) * cam.camera_angle.to_mat4())
	  .inverse();
	mutable aa = cam.projection * view * glm::make_vec4(0.0, 0.0, 0.0, 1.0);
	println("cam_mvp(0) =>", aa);
      }
      function void set_uniform_cb(glm::mat4 const& model_mat)
      {
	const sm_mvp = sm_vp * model_mat;
	glUniformMatrix4fv(smsdr->u_shadowmap_mvp, 1, 0, sm_mvp.crawptr());
	// println("shadowmap_mvp(L)", sm_mvp.cslice());
	// glUniformMatrix4fv(smsdr->u_shadowmap_mvp, 1, 0, m.crawptr());
	check_error();
      }
      sn->draw{set_uniform_cb, shadowmap_vertex_attributes, shadowmap_shader}(
	bo, glm::mat4(), *smsdr);
      check_error();
      if (false) {
	farray{int, 4} view;
	/*
	if (cam.proj_light) {
	  glGetIntegerv(GL_VIEWPORT, view.rawptr());
	  // println(view);
	} else {
	*/
	  view[2] = sfbo.sm_width;
	  view[3] = sfbo.sm_height;
	/*
	}
	*/
	mutable dbuf = darray{uchar}(
	  static_cast{size_t}(view[2] * view[3] * 4), 0);
	glReadPixels(0, 0, view[2], view[3], GL_RGBA,
	  GL_UNSIGNED_BYTE, dbuf.rawptr().void());
	const sli = dbuf[0 .. 10];
	println("readpixels", sli);
	/*
	float avg = 0.0f;
	float minval = 2.0f;
	float maxval = -2.0f;
	for (const i, const v: dbuf) {
	  avg += v;
	  if (v < minval) { minval = v; }
	  if (v > maxval) { maxval = v; }
	}
	avg /= static_cast{float}(dbuf.size());
	// println("avg", avg, "min", minval, "max", maxval);
	{
	  float const perspective_distance = 1.0;
	  float const min_distance = 0.2;
	  const d = cast_float(perspective_distance);
	  const near = cast_float(d - min_distance);
	  const far = cast_float(d + min_distance + distance_max);
	  const distance = far * near / (avg * (far - near) - far);
	  // println("dbuf avg", avg, "distance", distance);
	}
	*/
      }
    }
    glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  }
  uint const tick_shadowmapping_shader = SDL_GetTicks();
  /* main */
  glViewport(0, 0, static_cast{GLsizei}(cam.screen_width),
    static_cast{GLsizei}(cam.screen_height));
  if (true) {
    glUseProgram(sdr->program);
    check_error();
    glEnable(GL_CULL_FACE);
    // glFrontFace(GL_CCW);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    // glDepthFunc(GL_LESS);
    // glDepthRange(0.1, 1000.0); // FIXME
    /*
    {
    farray{float, 2} params;
    glGetFloatv(GL_DEPTH_RANGE, params.rawptr());
    check_error();
    println(params);
    }
    */
    glDisable(GL_BLEND);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /*
    const light = glm::make_vec3(2500.0, 2500.0, -2500.0);
    */
    const camera_target = cam.camera_angle.to_mat3() *
      glm::make_vec3(0.0, 0.0, -20.0);
    glUniform3fv(sdr->u_light_pos, 1, cam.light_pos.crawptr());
    check_error();
    glUniform3fv(sdr->u_camera_pos, 1, cam.camera_pos.crawptr());
    mutable view = glm::mat4();
    if (cam.proj_light) {
      view = (view.translate(cam.light_pos) * cam.light_angle.to_mat4())
	.inverse();
    } else {
      view = (view.translate(cam.camera_pos) * cam.camera_angle.to_mat4())
	.inverse();
      // println("camerapos", cam.camera_pos);
    }
    const vp = cam.projection * view;
    glUniformMatrix4fv(sdr->u_view_projection_matrix, 1, 0, vp.crawptr());
    const red = make_farray{float}(0.8, 0.1, 0.0, 1.0);
    glUniform1i(sdr->u_sampler, 1);
    check_error();
    glUniform1i(sdr->u_sampler_sm, 2);
    check_error();
    const model_cur = glm::mat4();
    function void set_uniform_cb(glm::mat4 const& model_mat)
    {
      glUniformMatrix4fv(sdr->u_model_matrix, 1, 0, model_mat.crawptr());
      /* const nm = model_mat.inverse().transpose().to_3(); */
      const nm = model_mat.to_3();
      glUniformMatrix3fv(sdr->u_normal_matrix, 1, 0, nm.crawptr());
      // println("m", model_mat * glm::make_vec4(0.0, 0.0, 0.0, 1.0));
      // println("mv", view * model_mat * glm::make_vec4(0.0, 0.0, 0.0, 1.0));
      const sm_mvp = sm_vp * model_mat;	
      glUniformMatrix4fv(sdr->u_shadowmap_mvp, 1, 0, sm_mvp.crawptr());
      // println("shadowmap_mvp(M)", sm_mvp.cslice());
      check_error();
    }
    sn->draw{set_uniform_cb, main_vertex_attributes, main_shader}(bo,
      model_cur, *sdr);
    check_error();
    if (false) {
      farray{int, 4} view;
      glGetIntegerv(GL_VIEWPORT, view.rawptr());
      println(view);
      mutable dbuf = darray{float}(static_cast{size_t}(view[2] * view[3]),
	0.0f);
      glReadPixels(view[0], view[1], view[2], view[3], GL_DEPTH_COMPONENT,
	GL_FLOAT, dbuf.rawptr().void());
      float avg = 0.0f;
      for (const i, const v: dbuf) {
	avg += v;
      }
      avg /= static_cast{float}(dbuf.size());
      {
	float const perspective_distance = 1.0;
	float const min_distance = 0.2;
	const d = cast_float(perspective_distance);
	const near = cast_float(d - min_distance);
	const far = cast_float(d + min_distance + distance_max);
	const distance = far * near / (avg * (far - near) - far);
	println("dbuf avg", avg, distance, near, far);
      }
    }
  }
  /* panel */
  glUseProgram(psdr->program);
  check_error();
  glDisable(GL_CULL_FACE);
  check_error();
  glDisable(GL_DEPTH_TEST);
  check_error();
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  check_error();
  glEnable(GL_BLEND);
  check_error();
  glUniform1i(psdr->u_sampler, 0);
  check_error();
  const lpp = cast_uint(psdr->a_pos);
  const lpu = cast_uint(psdr->a_uvpos);
  glEnableVertexAttribArray(lpp);
  check_error();
  glEnableVertexAttribArray(lpu);
  check_error();
  varray{float} pvals;
  varray{float} uvals;
  uint cur_x = 0;
  uint cur_y = 0;
  for (size_t i, const ch: mess) {
    if (ch < 0x20) {
      continue;
    }
    const tx0 = (ch > 0x20) ? fti.char_x[ch - 0x20 - 1] : 0;
    const tx1 = fti.char_x[ch - 0x20];
    const ty0 = fti.char_h;
    const ty1 = 0;
    const tw = tx1 - tx0;
    const th = fti.char_h;
    const x0 = cast_float(cur_x) * 2.0f
      / cast_float(cam.screen_width) - 1.0f;
    const y0 = cast_float(cur_y) * 2.0f
      / cast_float(cam.screen_height) - 1.0f;
    const x1 = cast_float(cur_x + tw) * 2.0f
      / cast_float(cam.screen_width) - 1.0f;
    const y1 = cast_float(cur_y + th) * 2.0f
      / cast_float(cam.screen_height) - 1.0f;
    const u0 = cast_float(tx0) / cast_float(fti.surface_w);
    const v0 = cast_float(ty0) / cast_float(fti.surface_h);
    const u1 = cast_float(tx1) / cast_float(fti.surface_w);
    const v1 = 0.0f;
    /* println(x0, y0, x1, y1, u0, v0, u1, v1); */
    pvals.push_back(x0);
    pvals.push_back(y0);
    pvals.push_back(x0);
    pvals.push_back(y1);
    pvals.push_back(x1);
    pvals.push_back(y0);
    pvals.push_back(x1);
    pvals.push_back(y0);
    pvals.push_back(x0);
    pvals.push_back(y1);
    pvals.push_back(x1);
    pvals.push_back(y1);
    uvals.push_back(u0);
    uvals.push_back(v0);
    uvals.push_back(u0);
    uvals.push_back(v1);
    uvals.push_back(u1);
    uvals.push_back(v0);
    uvals.push_back(u1);
    uvals.push_back(v0);
    uvals.push_back(u0);
    uvals.push_back(v1);
    uvals.push_back(u1);
    uvals.push_back(v1);
    cur_x += tw;
  }
  if (pvals.size() > 0) {
    glVertexAttribPointer(lpp, 2, GL_FLOAT, 0, 0, pvals.crawptr().void());
    check_error();
    glVertexAttribPointer(lpu, 2, GL_FLOAT, 0, 0, uvals.crawptr().void());
    check_error();
    glDrawArrays(GL_TRIANGLES, 0, cast_int(pvals.size() / 2));
    check_error();
    glDisableVertexAttribArray(lpp);
    check_error();
    glDisableVertexAttribArray(lpu);
    check_error();
  }
  return tick_shadowmapping_shader;
}

function void reshape(camera_info mutable& cam, int width, int height)
{ 
  cam.screen_width = width;
  cam.screen_height = height;
  update_mvp(cam);
}

function void update_mvp(camera_info mutable& cam)
{
  float const perspective_distance = 1.0;
  float const min_distance = 0.2;
  const h = cast_float(cam.screen_height)
    / cast_float(cam.screen_width);
  glViewport(0, 0, static_cast{GLsizei}(cam.screen_width),
    static_cast{GLsizei}(cam.screen_height));
  const d = cast_float(perspective_distance);
  {
    const near = cast_float(d - min_distance);
    const far = cast_float(d + min_distance + distance_max);
    const left = cast_float(-1.0 * ((d - min_distance) / d));
    const right = cast_float(1.0 * ((d - min_distance) / d));
    const bottom = cast_float(-h * ((d - min_distance) / d));
    const top = cast_float(h * ((d - min_distance) / d));
    /*
      const rat = 50.0f;
      cam.projection = glm::ortho{float}(-rat, rat, -rat * h, rat * h, near,
	far);
    */
    cam.projection = glm::frustum{float}(left, right, bottom, top, near, far);
  }
  {
    const near = cast_float(d - min_distance);
    const far = cast_float(d + min_distance + 1000.0);
    const left = cast_float(-1.0 * ((d - min_distance) / d));
    const right = cast_float(1.0 * ((d - min_distance) / d));
    const bottom = cast_float(-1.0 * ((d - min_distance) / d));
    const top = cast_float(1.0 * ((d - min_distance) / d));
    cam.sm_projection = glm::frustum{float}(left, right, bottom, top, near,
      far);
  }
}

threaded function {t} t power_of_2(t v)
{
  mutable t r = static_cast{t}(1);
  while (r != 0 && r < v) { r <<= 1; }
  return r;
}

metafunction gl_precision m::cond{m::eq{m::profile{"platform"}, "ios"},
  "precision highp float;\n", ""};

valuetype struct shadowmap_fbo {
  public uint fbo;
  public uint sm_texture;
  public int sm_width;
  public int sm_height;
}

function void init_shadowmap_fbo(shadowmap_fbo mutable& sfbo)
{
  int saved_fb;
  glGetIntegerv(GL_FRAMEBUFFER_BINDING, address(saved_fb));
  sfbo.sm_width = 2048;
  sfbo.sm_height = 2048;
  /* texture */
  glActiveTexture(GL_TEXTURE2);
  check_error();
  glGenTextures(1, address(sfbo.sm_texture));
  check_error();
  glBindTexture(GL_TEXTURE_2D, sfbo.sm_texture);
  check_error();
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, cast_int(GL_NEAREST));
  check_error();
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
    cast_int(GL_NEAREST));
  check_error();
  /*
  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_DEPTH_COMPONENT), sfbo.sm_width,
    sfbo.sm_height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE,
    offset_to_void_cp(0));
  */
  glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA), sfbo.sm_width,
    sfbo.sm_height, 0, GL_RGBA, GL_UNSIGNED_BYTE,
    offset_to_void_cp(0));
  check_error();
  glGenFramebuffers(1, address(sfbo.fbo));
  check_error();
  glBindFramebuffer(GL_FRAMEBUFFER, sfbo.fbo);
  check_error();
  /*
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D,
    sfbo.sm_texture, 0);
  */
  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
    sfbo.sm_texture, 0);
  check_error();
  /*
  glDrawBuffer(GL_NONE); // MacOSX requires this
  */
  /*
  GLenum x;
  glDrawBuffers(0, caddress(x));
  */
  /*
  glReadBuffer(GL_NONE);
  */
  int orig_rb;
  glGetIntegerv(GL_RENDERBUFFER_BINDING, address(orig_rb));
  println("orig_rb", orig_rb);
  check_error();
  uint depthbuf;
  glGenRenderbuffers(1, address(depthbuf));
  check_error();
  glBindRenderbuffer(GL_RENDERBUFFER, depthbuf);
  check_error();
  /*
  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, sfbo.sm_width,
    sfbo.sm_height);
  */
  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, sfbo.sm_width,
    sfbo.sm_height);
  check_error();
  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
    GL_RENDERBUFFER, depthbuf);
  check_error();
  glBindRenderbuffer(GL_RENDERBUFFER, static_cast{uint}(orig_rb));
  /*
  */
  /*
  GLenum drawbuffer = GL_COLOR_ATTACHMENT0;
  glDrawBuffers(1, caddress(drawbuffer));
  check_error();
  */
  const e = glCheckFramebufferStatus(GL_FRAMEBUFFER);
  if (e != GL_FRAMEBUFFER_COMPLETE) {
    println("incompete framebuffer", cast_int(e));
  } else {
    println("compete framebuffer");
  }
  check_error();
  // glBindTexture(GL_TEXTURE_2D, 0);
  check_error();
  glBindFramebuffer(GL_FRAMEBUFFER, static_cast{uint}(saved_fb));
  check_error();
}

function shadowmap_shader_ptr
init_shadowmap_shader()
{
  const vert = m::concat{
    gl_precision,
    "uniform mat4 shadowmap_mvp;\n",
    "attribute vec3 position;\n",
    /*
    "varying float vary_z;\n",
    */
    "varying vec4 vary_smpos;\n",
    "void main(void) {\n",
    /*
    */
    "  vec4 p = shadowmap_mvp * vec4(position, 1.0);\n",
    /*
    "  vary_z = (p.z/p.w + 1.0) / 2.0;\n",
    */
    "  gl_Position = p;\n",
    "  vary_smpos = p;\n",
    "}\n"};
  const frag = m::concat{
    gl_precision,
    /*
    "varying float vary_z;\n",
    */
    "uniform mat4 shadowmap_mvp;\n",
    "varying vec4 vary_smpos;\n",
    "void main(void) {\n",
    "  vec4 p = vary_smpos;\n",
    "  float pz = (p.z/p.w + 1.0) / 2.0;\n",
    // "  float z = vary_z * 256.0;\n", /* [0.0, 256.0] */
    "  float z = pz * 256.0;\n", /* [0.0, 256.0] */
    "  float z0 = floor(z);\n", /* [0, 256] */
    "  z = (z - z0) * 256.0;\n", /* [0.0, 256.0) */
    "  float z1 = floor(z);\n", /* [0, 256) */
    "  z = (z - z1) * 256.0;\n", /* [0.0, 256.0) */
    "  float z2 = floor(z);\n",  /* [0, 256) */
    "  gl_FragColor = vec4(z0 / 255.0, z1 / 255.0, z2 / 255.0, 1.0);\n",
    "}\n"};
  return make_shader_ptr{shadowmap_uniforms, shadowmap_vertex_attributes}(
    vert, frag);
}

function main_shader_ptr
init_main_shader()
{
  const vert = m::concat{
    gl_precision,
    "uniform mat4 view_projection_matrix;\n",
    "uniform mat4 model_matrix;\n",
    "uniform mat3 normal_matrix;\n",
    "uniform mat4 shadowmap_mvp;\n",
    "attribute vec3 position;\n",
    "attribute vec3 normal;\n",
    "attribute vec4 tangent;\n",
    "attribute vec2 uv;\n",
    "varying vec3 vary_position;\n",
    "varying vec3 vary_normal;\n",
    "varying vec3 vary_tangent;\n",
    "varying vec3 vary_binormal;\n",
    "varying vec2 vary_uv;\n",
    m::cond{enable_shadowmapping,
    "varying vec4 vary_smpos;\n",
    ""
    },
    "void main(void) {\n",
    "  vec4 pos4 = vec4(position, 1.0);\n",
    "  vec4 gpos4 = model_matrix * pos4;\n",
    "  gl_Position = view_projection_matrix * gpos4;\n",
    "  vary_position = gpos4.xyz;\n",
    "  vary_normal = normal_matrix * normal;\n",
    "  vary_tangent = normal_matrix * tangent.xyz;\n",
    "  vary_binormal = cross(vary_normal, vary_tangent) * tangent.w;\n",
    "  vary_uv = uv;\n",
    m::cond{enable_shadowmapping,
    "  vary_smpos = shadowmap_mvp * pos4;\n",
    ""
    },
    "}\n"};
  const frag = m::concat{
    gl_precision,
    "uniform sampler2D sampler;\n",
    "uniform sampler2D sampler_sm;\n",
    "uniform vec3 camera_pos;\n",
    "uniform vec3 light_pos;\n",
    "uniform mat4 shadowmap_mvp;\n",
    "varying vec3 vary_position;\n",
    "varying vec3 vary_normal;\n",
    "varying vec3 vary_tangent;\n",
    "varying vec3 vary_binormal;\n",
    "varying vec2 vary_uv;\n",
    "varying vec4 vary_pposition;\n",
    "varying vec4 vary_smpos;\n",
    /* */
    "void main(void) {\n",
    "  vec3 nor = vary_normal;\n",
    "  vec2 uv1 = (vary_uv + 0.5) * 256.0;\n",
    "  vec2 uvi = floor(uv1);\n",
    "  vec2 uvj = uv1 - uvi;\n",
    "  vec2 uvi_fr = fract(uvi / 32.0) * 32.0;\n",
    "  vec4 c0 = texture2D(sampler, uvi_fr / 128.0);\n",
    "  int alv = int(c0.a * 255.0 + 0.5);\n",
    "  c0 *= 0.1;\n",
    "  int ut1 = 0;\n",
    "  int vt1 = 0;\n",
    /* */
    "  int left_top = int(uvj.y - uvj.x >= 0.0);\n",
    "  int left_bottom  = int(uvj.y + uvj.x <= 1.0);\n",
    "  ut1 += int(alv == 4) - int(alv == 8);\n",
    "  ut1 += int(alv == 3) * (1 - left_bottom);\n",
    "  ut1 += int(alv == 5) * (1 - left_top);\n",
    "  ut1 += -int(alv == 7) * left_bottom;\n",
    "  ut1 += -int(alv == 1) * left_top;\n",
    "  vt1 += int(alv == 6) - int(alv == 2);\n",
    "  vt1 += int(alv == 5) * left_top;\n",
    "  vt1 += int(alv == 7) * (1 - left_bottom);\n",
    "  vt1 += -int(alv == 1) * (1 - left_top);\n",
    "  vt1 += -int(alv == 3) * left_bottom;\n",
    /* */
    "  nor += float(ut1) * vary_tangent * 0.2;\n",
    "  nor += float(vt1) * vary_binormal * 0.2;\n",
    /* */
    "  nor = normalize(nor);\n",
    "  vec3 light_dir = normalize(light_pos - vary_position);\n",
    /* */
    "  vec3 reflection_vec = reflect(-light_dir, nor);\n",
    "  vec3 camera_dir = normalize(camera_pos - vary_position);\n",
    "  float cos_angle = max(0.0, dot(camera_dir, reflection_vec));\n",
    "  float light_distance = length(light_pos - vary_position);\n",
    "  float dist = min(20.0 / light_distance, 1.0);\n",
    "  float specular = pow(cos_angle, 16.0);\n",
    "  float diffuse = max(dot(light_dir, nor), 0.0);\n",
    /* */
    "  vec4 color1 = vec4(0.15, 0.16, 0.13, 1.0);\n",
    "  vec4 color2 = vec4(0.2, 0.2, 0.2, 1.0);\n",
    "  vec4 color3 = vec4(1.0, 1.0, 1.0, 1.0);\n",
    /* */
    m::cond{enable_shadowmapping,
    m::concat{
    "  vec4 smp = vary_smpos;\n",
    "  vec3 smpos = ((smp.xyz / smp.w) + 1.0) * 0.5;\n",
    "  float lflag = float(int(smpos.x <= 0.0) + int(smpos.x >= 1.0)",
    "    + int(smpos.y <= 0.0) + int(smpos.y >= 1.0) == 0);\n",
    "  vec4 smz = texture2D(sampler_sm, smpos.xy * lflag);\n",
    "  float z0 = floor(smz.r * 255.0 + 0.5);\n",
    "  float z1 = floor(smz.g * 255.0 + 0.5);\n",
    "  float z2 = floor(smz.b * 255.0 + 0.5);\n",
    "  float zval = z0 * 65536.0 + z1 * 256.0 + z2;\n",
    "  float lstr = float(smpos.z * 16770000.0 < zval) * lflag;\n",
    "  vec4 color = color1 + (color2 * diffuse + color3 * specular) ",
    "    * dist * lstr;\n"
    },
    "  vec4 color = color1 + (color2 * diffuse + color3 * specular);\n"
    },
    "  gl_FragColor = color;\n",
    "}\n"};
  return make_shader_ptr{main_uniforms, main_vertex_attributes}(vert, frag);
}

function font_shader_ptr
init_font_shader()
{
  const vert = m::concat{
    gl_precision,
    "attribute vec2 pos;\n",
    "attribute vec2 uvpos;\n",
    "varying vec2 texcoord;\n",
    "void main(void) {\n",
    "  gl_Position = vec4(pos, 0.0, 1.0);\n",
    "  texcoord = uvpos;\n",
    "}\n"
  };
  const frag = m::concat{
    gl_precision,
    "uniform sampler2D sampler;\n",
    "varying vec2 texcoord;\n",
    "void main(void) {\n",
    "  vec4 col = texture2D(sampler, texcoord);\n",
    "  gl_FragColor = col;\n",
    "}\n"};
  return make_shader_ptr{font_uniforms, font_vertex_attributes}(vert, frag);
}

function void
init_texture(main_texture_info mutable& mti, font_texture_info mutable& fti)
{
  {
    /* font */
    const fnames = make_farray{string}(
      "LiberationMono-Bold.ttf",
      "/Library/Fonts/Osaka.ttf",
      "/usr/share/fonts/liberation/LiberationMono-Bold.ttf");
    option{ptr{TTF_Font}} font;
    for (size_t i, const& fn: fnames) {
      font = TTF_OpenFont(fn, 16);
      if (case font.some) {
	break;
      }
    }
    SDL_Color mutable fg;
    fg.r = 255;
    fg.g = 255;
    fg.b = 255;
    fg.a = 255;
    uint hmax = 0;
    uint wtotal = 0;
    varray{ptr{SDL_Surface}} sur_arr;
    for (const i: 0 .. 0x60) {
      farray{uchar, 1} z;
      z[0] = static_cast{uchar}(i + 0x20);
      const sur = TTF_RenderUTF8_Blended(font.some, z, fg).some;
      /* println(z, sur.W(), sur.H()); */
      sur_arr.push_back(sur);
      hmax = max(hmax, sur.H());
      wtotal += sur.W();
    }
    const sur_chars = SDL_CreateRGBSurface(
      cast_int(power_of_2(wtotal)),
      cast_int(power_of_2(hmax)), 32, 0, 0, 0, 0).some;
    println("wtotal, hmax", wtotal, hmax);
    fti.char_x.clear();
    uint xcur = 0;
    for (const i, const e: sur_arr) {
      SDL_Rect r0;
      SDL_Rect r1;
      r0.x = 0;
      r0.y = 0;
      r0.w = cast_int(e.W());
      r0.h = cast_int(e.H());
      r1.x = cast_int(xcur);
      r1.y = 0;
      r1.w = r0.w;
      r1.h = r1.h;
      const v = SDL_BlitSurface(e, r0, sur_chars, r1);
      xcur += cast_uint(r1.w);
      fti.char_x.push_back(xcur);
    }
    fti.char_h = hmax;
    fti.surface_w = sur_chars.W();
    fti.surface_h = sur_chars.H();
    const sur = sur_chars;
    const sur_chars_buf = sur_chars.Pixels();
    for (const x: 0 .. sur_chars.W()) {
      for (const y: 0 .. sur_chars.H()) {
	const i = (y * sur_chars.W() + x) * 4;
	sur_chars_buf[i+0] = 255;
	sur_chars_buf[i+1] = 255;
	sur_chars_buf[i+2] = 255;
      }
    }
    /* texture */
    glActiveTexture(GL_TEXTURE0);
    check_error();
    glGenTextures(1, address(fti.font_texture_id));
    check_error();
    glBindTexture(GL_TEXTURE_2D, fti.font_texture_id);
    check_error();
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(GL_RGBA),
      cast_int(sur.W()), cast_int(sur.H()),
      0, GL_RGBA, GL_UNSIGNED_BYTE, sur.Pixels().crawptr().void());
    check_error();
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    check_error();
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
    check_error();
  }
  {
    // const sur = IMG_Load("img-c1024.jpg").some;
    const sur0 = IMG_Load("test.png").some;
    const bpp = sur0.BytesPerPixel();
    if (bpp != 4 && bpp != 3) {
      throw runtime_error_template{"img_load"}("1");
    }
    const sur0_w = sur0.W();
    const sur0_h = sur0.H();
    const sur1 = SDL_CreateRGBSurface(
      cast_int(power_of_2(sur0_w)),
      cast_int(power_of_2(sur0_h)), 32, 0, 0, 0, 0).some;
    const sur1_w = sur1.W();	
    const sur1_h = sur1.H();	
    const sur0buf = sur0.Pixels();
    const sur1buf = sur1.Pixels();
    for (const x: 0 .. sur0_w) {
      for (const y: 0 .. sur0_h) {
	const tx = x % 32;
	const ty = y % 32;
	const mx = 32U - tx - 1;
	const my = 32U - ty - 1;
	uchar alpha_value = 0;
	const uint brd = 1;
	if (tx == ty && tx < brd) {
	  alpha_value = 1;
	} else if (ty < brd && ty < tx && ty < mx) {
	  alpha_value = 2;
	} else if (mx == ty && mx < brd) {
	  alpha_value = 3;
	} else if (mx < brd && mx < ty && mx < my) {
	  alpha_value = 4;
	} else if (mx < brd && mx == my) {
	  alpha_value = 5;
	} else if (my < brd && my < x && my < mx) {
	  alpha_value = 6;
	} else if (my == tx && my < brd) {
	  alpha_value = 7;
	} else if (tx < brd && tx < ty && tx < my) {
	  alpha_value = 8;
	}
	const offset0 = (y * sur0_w + x) * bpp;
	const offset1 = (y * sur1_w + x) * 4;
	sur1buf[offset1+0] = sur0buf[offset0+0];
	sur1buf[offset1+1] = sur0buf[offset0+1];
	sur1buf[offset1+2] = sur0buf[offset0+2];
	sur1buf[offset1+3] = alpha_value;
      }
    }
    const mode = GL_RGBA;
    glActiveTexture(GL_TEXTURE1);
    check_error();
    glGenTextures(1, address(mti.main_texture_id));
    check_error();
    glBindTexture(GL_TEXTURE_2D, mti.main_texture_id);
    check_error();
    glTexImage2D(GL_TEXTURE_2D, 0, cast_int(mode),
      cast_int(sur1.W()), cast_int(sur1.H()),
      0, mode, GL_UNSIGNED_BYTE, sur1.Pixels().crawptr().void());
    check_error();
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
      cast_int(GL_NEAREST));
    check_error();
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
      cast_int(GL_NEAREST));
    check_error();
    mti.surface_w = sur1.W();
    mti.surface_h = sur1.H();
  }
}

function void check_error()
{
  const v = glGetError();
  if (v == GL_NO_ERROR) {
    return;
  }
  sdllog(string_join{""}("error: ", cast_int(v)));
  // io::system.abort();
  // throw runtime_error_template{"gl_error"}("1");
}

function void sdllog(cstrref const& mess)
{
  SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, mess);
}

{
  camera_info cam;
  sdllog("PXC-SDL2 main");
  const ini = SDL_Init(SDL_INIT_VIDEO);
  int init_w = 512;
  int init_h = 512;
  const num_modes = SDL_GetNumDisplayModes(0);
  for (int i: 0 .. num_modes) {
    SDL_DisplayMode mode;
    SDL_GetDisplayMode(0, i, mode);
    if (mode.w * mode.h > init_w * init_h) {
      // init_w = mode.w;
      // init_h = mode.h;
    }
    if (mode.w * mode.h < init_w * init_h) {
      // init_w = mode.w;
      // init_h = mode.h;
    }
    sdllog(string_join{" "}("displaymode", mode.w, mode.h));
  }
  SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
  SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
  mutable wflags = SDL_WINDOW_OPENGL;
  wflags |= SDL_WINDOW_RESIZABLE;
  wflags |= SDL_WINDOW_ALLOW_HIGHDPI;
  /*
  */
  /*
  wflags |= SDL_WINDOW_FULLSCREEN;
   */
  if (get_option("-f") == "1") { wflags |= SDL_WINDOW_FULLSCREEN; }
  mutable vsync = 1;
  if (get_option("-v") == "1") { vsync = 0; }

  sdllog(string_join{" "}("create_window", init_w, init_h));
  const wnd = SDL_CreateWindow("PXC-SDL2", 0, 0, init_w, init_h, wflags).some;
  SDL_GL_GetDrawableSize(wnd, init_w, init_h);
  sdllog(string_join{" "}("drawable size", init_w, init_h));
  const glctx = SDL_GL_CreateContext(wnd);
  SDL_GL_SetSwapInterval(vsync);

  sdllog("PXC-SDL2 init0");
  shadowmap_fbo sfbo;
  if (m::ne{enable_shadowmapping, 0}) {
    init_shadowmap_fbo(sfbo);
  }
  const sdr = init_main_shader();
  const smsdr = init_shadowmap_shader();
  const psdr = init_font_shader();
  check_error();
  main_texture_info mti;
  font_texture_info fti;
  init_texture(mti, fti);
  sdllog("PXC-SDL2 initialized");

  sdllog("PXC-SDL2 reshape");
  reshape(cam, init_w, init_h);
  check_error();

  uint tprevsec = 0;
  uint tprev = SDL_GetTicks();
  uint frames = 0;
  float mutable fps = 0.0;
  cam.camera_angle = glm::make_quat_wxyz(1.0, 0.0, 0.0, 0.0);
  println("cang", cam.camera_angle.to_mat3() * glm::make_vec3(1.0, 2.0, 3.0));
  cam.camera_pos = glm::make_vec3(0.0, 0.0, 10.0);

  cam.light_angle = glm::make_quat_angle_axis(30.0, 1.0, 1.0, 0.0);
  cam.light_pos = cam.light_angle.to_mat3() * glm::make_vec3(0.0, 0.0, 20.0);

  farray{uint, 2} mutable frame_tdiffs;
  for (const i, mutable& e: frame_tdiffs) {
    e = 1000U / cast_uint(frame_tdiffs.size());
  }
  float mutable frame_speed_mul = 1.0f;

  metafunction ticks_t farray{uint, 6};
  ticks_t ticks;
  ticks_t ticks_sum;
  ticks_t ticks_sum_prev;
  for (const i, mutable& e : ticks) {
    e = tprev;
  }
  function void save_ticks(size_t idx) {
    const prev_tick = ticks[idx == 0 ? ticks.size() - 1 : idx - 1];
    mutable& cur_tick = ticks[idx];
    cur_tick = SDL_GetTicks();
    ticks_sum[idx] += cur_tick - prev_tick;
  }

  buffer_object{main_vertex_attributes} bo;
  {
    const t0 = system.gettimeofday_double();
    build_vertices(bo);
    const t1 = system.gettimeofday_double();
    bo.create_vbo();
    const t2 = system.gettimeofday_double();
    sdllog(string_join{" "}("build vertex", t1 - t0, t2 - t1));
  }

  bool done = false;
  bool paused = false;
  function void camera_rotate(float x, float y, float z, float angle) {
    const qq = glm::make_quat_angle_axis(angle * frame_speed_mul, x, y, z);
    cam.camera_angle = (cam.camera_angle * qq).normalize();
  }
  function void camera_move(float x, float y, float z) {
    cam.camera_pos += cam.camera_angle.to_mat3() * glm::make_vec3(x, y, z)
      * frame_speed_mul;
  }
  varray{SDL_FingerID} fingerids;
  farray{bool, 2} fingdown;
  farray{size_t, 2} fingerdown_time;
  farray{glm::vec2, 2} start_pos;
  farray{glm::vec2, 2} cur_pos;
  glm::vec2 finger_xyrotate_delta;
  // glm::vec2 finger_xymove_delta;
  // float finger_zrotate_delta;
  float finger_zmove_delta;
  int finger_zmove_mode = 0;
  function void finger_motion(float x, float y, float dx, float dy,
    SDL_FingerID fng) {
    size_t fid = 2;
    if (fingerids.size() > 0 && fingerids[0] == fng) {
      fid = 0;
    } else if (fingerids.size() > 1 && fingerids[1] == fng) {
      fid = 1;
    }
    if (fid < 2) {
      cur_pos[fid] = glm::make_vec2(x, y);
      /*
      sdllog(string_join{" "}("finger_motion", x, y, fid, fng));
      */
    } else {
      /*
      sdllog(string_join{" "}("finger_motion(ignored)", x, y, fng,
	"fingerids:", fingerids));
      */
    }
  }
  function void finger_down(float x, float y, SDL_FingerID fng) {
    size_t fid = 2;
    if (fingerids.size() > 0 && fingerids[0] == fng) {
      fid = 0;
    } else if (fingerids.size() > 1 && fingerids[1] == fng) {
      fid = 1;
    } else if (fingerids.size() < 2) {
      fid = fingerids.size();
      fingerids.push_back(fng);
    }
    if (fid < 2) {
      fingdown[fid] = true;
      start_pos[fid] = glm::make_vec2(x, y);
      cur_pos[fid] = start_pos[fid];
      /*
      sdllog(string_join{" "}("finger_down", x, y, fid));
      */
      fingerdown_time[0] = 0;
      fingerdown_time[1] = 0;
      finger_zmove_mode = 0;
    }
    /*
    sdllog(string_join{" "}("finger_down_post", fingerids));
    */
  }
  function void finger_up(SDL_FingerID fng) {
    size_t fid = 2;
    if (fingerids.size() > 0 && fingerids[0] == fng) {
      fid = 0;
    } else if (fingerids.size() > 1 && fingerids[1] == fng) {
      fid = 1;
    }
    if (fid < 2) {
      fingdown[fid] = false;
      /*
      sdllog(string_join{" "}("finger_up", fid));
      */
      if (fid == 1) {
	start_pos[0] = cur_pos[0];
	fingerids.resize(1, 0);
	fingdown[1] = false;
      } else {
	fingerids.erase(0, 1);
	if (fingerids.empty()) {
	  fingdown[0] = false;
	} else {
	  cur_pos[0] = cur_pos[1];
	  start_pos[0] = cur_pos[1];
	  fingdown[0] = fingdown[1];
	  fingdown[1] = false;
	}
      }
      fingerdown_time[0] = 0;
      fingerdown_time[1] = 0;
      finger_zmove_mode = 0;
    }
    /*
    sdllog(string_join{" "}("finger_up_post", fingerids));
    */
  }
  function void finger_action_one_finger(size_t fid) {
    mutable dx = (cur_pos[fid].x - start_pos[fid].x);
    mutable dy = (cur_pos[fid].y - start_pos[fid].y);
    const d = glm::distance(start_pos[fid], cur_pos[fid]);
    if (d > 3.0) {
      dx /= d / 3.0;
      dy /= d / 3.0;
    }
    /*
    sdllog(string_join{" "}("onefinger", dx, dy));
    */
    camera_rotate(1.0, 0.0, 0.0, -dy * 2.0);
    camera_rotate(0.0, 1.0, 0.0, -dx * 2.0);
    finger_xyrotate_delta.x = dx;
    finger_xyrotate_delta.y = dy;
  }
  function void finger_action_two_fingers() {
    const d0 = cur_pos[0] - start_pos[0];
    const d1 = cur_pos[1] - start_pos[1];
    if (glm::dot(d0, d1) < 0.0f) {
      /* z move */
      if (finger_zmove_mode != 2) {
	const distance_start = glm::distance(start_pos[0], start_pos[1]);
	mutable distance_cur = glm::distance(cur_pos[0], cur_pos[1]);
	if (distance_cur <= 0.0001f) {
	  distance_cur = 0.0001f;
	}
	const rat = distance_start / distance_cur;
	const prev = finger_zmove_delta;
	if (rat > 1.2) {
	  finger_zmove_delta += 0.0003;
	  if (finger_zmove_delta >= 1.0) {
	    finger_zmove_delta = 1.0;
	  }
	  finger_zmove_mode = 1;
	} else if (rat < 0.8) {
	  finger_zmove_delta -= 0.0003;
	  if (finger_zmove_delta <= -1.0) {
	    finger_zmove_delta = -1.0;
	  }
	  finger_zmove_mode = 1;
	}
	if ((prev < 0.0f && finger_zmove_delta > 0.0f) ||
	  (prev > 0.0f && finger_zmove_delta < 0.0f)) {
	  /* stop */
	  finger_zmove_delta = 0.0f;
	  finger_zmove_mode = 2;
	}
      }
    } else {
      /* xy move */
      const d0 = cur_pos[0] - start_pos[0];
      const d1 = cur_pos[1] - start_pos[1];
      mutable avg = (d0 + d1) / 2.0f;
      const d = (glm::distance(start_pos[0], cur_pos[0]),
	glm::distance(start_pos[1], cur_pos[0])) / 2.0f;
      if (d > 3.0) {
	avg /= d / 3.0;
      }
      avg /= 32.0f;
      camera_move(avg.x, -avg.y, 0.0);
    }
  }
  function void finger_action_step() {
    /*
    sdllog(string_join{" "}("finger_action_step", fingdown[0], fingdown[1]));
    */
    if (fingdown[0] && !fingdown[1]) {
      if (fingerdown_time[0] >= 2) {
	finger_action_one_finger(0);
      } else {
	start_pos[0] = (start_pos[0] + cur_pos[0]) / 2.0f;
	fingerdown_time[0] += 1;
      }
      if (fingerids[0] == 0) {
	/* mouse button */
	/*
	finger_zmove_delta -= 0.0001;
	if (finger_zmove_delta <= -0.01) {
	  finger_zmove_delta = -0.01;
	}
	*/
      }
    } else if (!fingdown[0] && fingdown[1]) {
      if (fingerdown_time[1] >= 2) {
	finger_action_one_finger(0);
      } else {
	start_pos[1] = (start_pos[1] + cur_pos[1]) / 2.0f;
	fingerdown_time[1] += 1;
      }
    } else if (fingdown[0] && fingdown[1]) {
      if (fingerdown_time[0] >= 2 && fingerdown_time[1] >= 2) {
	finger_action_two_fingers();
      } else {
	start_pos[0] = (start_pos[0] + cur_pos[0]) / 2.0f;
	fingerdown_time[0] += 1;
	start_pos[1] = (start_pos[1] + cur_pos[1]) / 2.0f;
	fingerdown_time[1] += 1;
      }
    } else {
      const len = glm::length(finger_xyrotate_delta);
      camera_rotate(1.0, 0.0, 0.0, -finger_xyrotate_delta.y * 2.0);
      camera_rotate(0.0, 1.0, 0.0, -finger_xyrotate_delta.x * 2.0);
      /*
      sdllog(string_join{" "}("len", len));
      */
      const decay = 0.03f * frame_speed_mul;
      if (len < decay) {
	finger_xyrotate_delta = glm::make_vec2(0.0f, 0.0f);
      } else {
	finger_xyrotate_delta -= finger_xyrotate_delta * decay / len;
      }
    }
    camera_move(0.0, 0.0, finger_zmove_delta);
  }
  double time_after_swapwindow = io::system.gettimeofday_double();
  while (!done) {
    save_ticks(0);
    SDL_Event ev;
    while (SDL_PollEvent(ev)) {
      const etype = ev.type;
      /*
       sdllog(string_join{" "}("event", cast_int(ev.type)));
       */
      if (etype == SDL_WINDOWEVENT) {
	if (ev.window.event == SDL_WINDOWEVENT_RESIZED) {
	  int w;
	  int h;
	  SDL_GL_GetDrawableSize(wnd, w, h);
	  reshape(cam, w, h);
	  sdllog(string_join{""}("resized w=", w, " h=", h));
	} else if (ev.window.event == SDL_WINDOWEVENT_HIDDEN) {
	  /* sdllog("hidden"); */
/*
	} else if (ev.window.event == SDL_WINDOWEVENT_MINIMIZED ||
	    ev.window.event == SDL_WINDOWEVENT_FOCUS_LOST) {
	  paused = true;
	  sdllog("paused");
*/
	} else if (ev.window.event == SDL_WINDOWEVENT_RESTORED ||
	    ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) {
	  paused = false;
	  sdllog("restored");
	} else {
	  /*
	  sdllog(string_join{" "}("window event ",
		cast_int(ev.window.event)));
	  */
	}
      } else if (etype == SDL_MOUSEBUTTONDOWN) {
//	cam.proj_light = !cam.proj_light;
	update_mvp(cam);
	/*
	sdllog(string_join{" "}("mousedown", ev.button.x, ev.button.y,
	  ev.button.button));
	finger_down(
	  cast_float(ev.button.x)
	    / cast_float(cam.screen_width),
	  cast_float(ev.button.y)
	    / cast_float(cam.screen_height),
	  0);
	*/
      } else if (etype == SDL_MOUSEBUTTONUP) {
	/*
	sdllog(string_join{" "}("mouseup", ev.button.button));
	finger_up(0);
	 */
      } else if (etype == SDL_MOUSEMOTION) {
	/*
	sdllog(string_join{" "}("mousemotion", ev.button.x, ev.button.y,
	  ev.button.button));
	 */
      } else if (etype == SDL_FINGERDOWN) {
	/*
	sdllog(string_join{" "}("fingerdown", ev.tfinger.x, ev.tfinger.y,
	  ev.tfinger.fingerId));
	*/
	finger_down(ev.tfinger.x, ev.tfinger.y, ev.tfinger.fingerId);
      } else if (etype == SDL_FINGERUP) {
	/*
	sdllog(string_join{" "}("fingerup", ev.tfinger.fingerId));
	*/
	finger_up(ev.tfinger.fingerId);
      } else if (etype == SDL_FINGERMOTION) {
	finger_motion(ev.tfinger.x, ev.tfinger.y, ev.tfinger.dx, ev.tfinger.dy,
	  ev.tfinger.fingerId);
/*
*/
	/*
	sdllog(string_join{" "}("fingermotion", ev.tfinger.x, ev.tfinger.y,
	  ev.tfinger.dx, ev.tfinger.dy, ev.tfinger.fingerId));
	*/
      } else if (etype == SDL_APP_WILLENTERBACKGROUND) {
	sdllog(string_join{""}("paused"));
	paused = true;
      } else if (etype == SDL_APP_DIDENTERFOREGROUND) {
	sdllog(string_join{""}("resumed"));
	paused = false;
	int w;
	int h;
	SDL_GL_GetDrawableSize(wnd, w, h);
	reshape(cam, w, h);
      } else if (etype == SDL_QUIT) {
	done = true;
	break;
      } else if (etype == SDL_MULTIGESTURE) {
      } else {
	string s;
	integral_to_hexadecimal{int}(cast_int(ev.type), s);
	/*
	sdllog(string_join{" "}("unknown event", s));
	*/
      }
    }
    check_error();
    if (paused) {
      SDL_Delay(100);
      tprev = SDL_GetTicks();
      tprevsec = tprev;
      continue;
    }
    save_ticks(1);
    {
      const mess = string_join{" "}(fps,
	frame_speed_mul,
	ticks_sum_prev,
	finger_zmove_delta,
	cam.camera_angle);
      const tick_sm = draw_frame(cam, sdr, sfbo, smsdr, bo, psdr, fti, mess);
      save_ticks(2);
      save_ticks(3);
      ++frames;
      uint t = SDL_GetTicks();
      if (t - tprevsec >= 1000) {
	const seconds = cast_float(t - tprevsec) / 1000.0;
	fps = cast_float(frames) / seconds;
	/*
	sdllog(string_join{" "}(frames, "frames in", seconds, "seconds =",
	    fps, "fps"));
	sdllog(string_join{" "}("ticks: ", ticks_sum));
	*/
	ticks_sum_prev = ticks_sum;
	ticks_sum = ticks_t();
	tprevsec = t;
	frames = 0;
      }
      mutable tdiff = cast_int(t - tprev);
      tprev = t;

      uint tdiff_frame_sum = cast_uint(tdiff);
      for (const i: 1 .. frame_tdiffs.size()) {
	tdiff_frame_sum += frame_tdiffs[i];
	frame_tdiffs[i - 1] = frame_tdiffs[i];
      }
      frame_tdiffs[frame_tdiffs.size() - 1] = cast_uint(tdiff);

      if (tdiff_frame_sum < 98 || tdiff_frame_sum > 102) {
	frame_speed_mul = cast_float(tdiff_frame_sum)
	  * 60.0f / 1000.0f / cast_float(frame_tdiffs.size());
      }
      if (frame_speed_mul > 0.90f && frame_speed_mul < 1.10f) {
	frame_speed_mul = 1.0f;
      }
      if (frame_speed_mul < 0.01f) {
	frame_speed_mul = 0.01f;
      }
      /*
      */
      /* println("frame_speed_mul", frame_speed_mul, tdiff_frame_sum,
       frame_tdiffs); */

      {
	SDL_KeyboardState const ks;
	if (ks.Key(SDL_SCANCODE_ESCAPE) != 0) {
	  done = true;
	}
	if (ks.Key(SDL_SCANCODE_UP) != 0) {
	  camera_rotate(1.0, 0.0, 0.0, 1.0);
	}
	if (ks.Key(SDL_SCANCODE_DOWN) != 0) {
	  camera_rotate(1.0, 0.0, 0.0, -1.0);
	}
	if (ks.Key(SDL_SCANCODE_LEFT) != 0) {
	  camera_rotate(0.0, 1.0, 0.0, 1.0);
	}
	if (ks.Key(SDL_SCANCODE_RIGHT) != 0) {
	  camera_rotate(0.0, 1.0, 0.0, -1.0);
	}
	if (ks.Key(SDL_SCANCODE_SPACE) != 0) {
	  finger_zmove_delta -= 0.0003;
	  if (finger_zmove_delta <= -1.0) {
	    finger_zmove_delta = -1.0;
	  }
	  finger_zmove_mode = 1;
	}
	if (ks.Key(SDL_SCANCODE_LSHIFT) != 0) {
	  finger_zmove_delta += 0.0003;
	  if (finger_zmove_delta >= 1.0) {
	    finger_zmove_delta = 1.0;
	  }
	  finger_zmove_mode = 1;
	}
	if (ks.Key(SDL_SCANCODE_A) != 0) {
	  camera_move(-0.02, 0.0, 0.0);
	}
	if (ks.Key(SDL_SCANCODE_D) != 0) {
	  camera_move(0.02, 0.0, 0.0);
	}
	if (ks.Key(SDL_SCANCODE_S) != 0) {
	  camera_move(0.0, -0.02, 0.0);
	}
	if (ks.Key(SDL_SCANCODE_W) != 0) {
	  camera_move(0.0, 0.02, 0.0);
	}
	if (ks.Key(SDL_SCANCODE_Z) != 0) {
	  camera_rotate(0.0, 0.0, 1.0, -1.0);
	}
	if (ks.Key(SDL_SCANCODE_X) != 0) {
	  camera_rotate(0.0, 0.0, 1.0, 1.0);
	}
	if (ks.Key(SDL_SCANCODE_RETURN) != 0) {
	  finger_zmove_delta = 0.0;
	  finger_zmove_mode = 1;
	}
	finger_action_step();
      }
    }
    save_ticks(4);
    double latency_target = 0.0;
    // uint latency_target = 16; /* 60 fps */
    // double latency_target = 0.0310;
    if (latency_target > 0.0) {
      const now = io::system.gettimeofday_double();
      const td = time_after_swapwindow - now;
      if (latency_target > td) {
	io::system.usleep(static_cast{uint}((latency_target - td) * 1000000.0));
	// println(latency_target - td);
      }
      /*
      io::system.usleep(static_cast{uint}(0.032 * 1000000.0));
      */
    }
    check_error();
    SDL_GL_SwapWindow(wnd);
    check_error();
    save_ticks(5);
    time_after_swapwindow = io::system.gettimeofday_double();
  }
  io::system._exit(0);
}

