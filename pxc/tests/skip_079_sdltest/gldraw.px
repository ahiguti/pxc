public namespace gldraw "export-unsafe";
public import common -;
public import pointer::raw -;
public import numeric::fpmath -;
public import SDL2 -;
public import SDL2::Image -;
public import GL::gles20 -;
public import GL::gl30 -;
public import GL::glm glm;
public import io::time -;
public import meta m;
public import exception -;
public import glshader -;

metafunction is_ios m::eq{m::profile{"platform"}, "ios"};
metafunction is_android m::eq{m::profile{"platform"}, "android"};
metafunction is_macos m::eq{m::profile{"platform"}, "Darwin"};
metafunction is_linux m::eq{m::profile{"platform"}, "Linux"};
metafunction is_gles m::or{is_ios, is_android};
metafunction is_gl3 m::not{is_gles}; // is_macos; // linux

metafunction use_instanced m::not{is_android};
metafunction use_primitive_restart 0; // is_gl3;
metafunction use_draw_range 0; // is_gl3;

public valuetype struct node_joint
{
  public size_t joint_sort;
  public glm::mat4 trans; /* or quat and vec3 ? */
}

private metafunction num_float_struct{t}
  m::fold{m::map{m::field_types{t}, num_float_fld}, m::add, 0};
private metafunction num_float_fld{t}
  m::cond{
    m::eq{t, float}, 1,
    m::eq{t, glm::vec2}, 2,
    m::eq{t, glm::vec3}, 3,
    m::eq{t, glm::vec4}, 4,
    m::error{"invalid type"}};

private threaded function {t} void
push_float(varray{float} mutable& arr, t const& v)
{
  if (m::eq{t, float}) {
    arr.push_back(v);
  } else {
    expand (fld: m::field_names{t}) {
    push_float(arr, v.fld);
    }
  }
}

public multithreaded struct {tattr} vertices
{
  private metafunction num_float_per_vertex num_float_struct{tattr};
  public varray{float} vertex_values;
  public varray{uint} elements;
  public tree_map{tattr, uint} value_to_id;
  public varray{node_joint} joints;
  /*
  public function void push_vertex_dedup(tattr const& value)
  {
    if (const id: value_to_id[value]) {
      elements.push_back(id);
      // debug_log("push", value, "id", id);
    } else {
      const id = static_cast{uint}(
	vertex_values.size() / num_float_per_vertex);
      push_float{tattr}(vertex_values, value);
      value_to_id[value] = id;
      elements.push_back(id);
      // debug_log("push", value, "id", id);
    }
  }
*/
  public function void push_polygon_distinct(cslice{tattr} const& vals)
  {
    /* no dedup */
    const first_id = vertex_values.size() / num_float_per_vertex;
    for (const i, const& val: vals) {
      push_float{tattr}(vertex_values, val);
    }
    /* polygon to triangles */
    if (m::ne{use_primitive_restart, 0}) {
      elements.push_back(0xffffffffU);
      for (const i, const& val: vals) {
	elements.push_back(static_cast{uint}(first_id + i));
      }
    } else {
      for (const i: 0 .. vals.size() - 2) {
	elements.push_back(static_cast{uint}(first_id));
	elements.push_back(static_cast{uint}(first_id + i + 1));
	elements.push_back(static_cast{uint}(first_id + i + 2));
      }
    }
  }
  public function void push_joint(node_joint const& e)
  {
    joints.push_back(e);
  }
}

public threaded struct {tattr} vertex_set()
{
  public string name; /* unused */
  public ptr{vertices{tattr}} vtxs = make_ptr{vertices{tattr}}();
  public size_t vertex_values_offset;
  public size_t elements_offset;
}

private threaded struct instance_data {
  public uint vbo_inst;
  public varray{float} client_buffer;
}

public threaded struct {tattr} buffer_object
{
  public metafunction vertex_attributes_type tattr;
  public varray{vertex_set{vertex_attributes_type}} vs_arr;
  public tree_map{string, size_t} vs_names;
  public uint vbo_values;
  public uint vbo_elems;
  public varray{ptr{instance_data}} instances;
  public size_t num_vertex_values;
  public size_t num_elements;
}

public function {tattr} bool
buffer_object_create_vbo(buffer_object{tattr} mutable& bo)
{
  varray{float} vertex_values;
  varray{uint} elements;
  size_t num_v = 0;
  size_t num_e = 0;
  for (const i, const& be: bo.vs_arr) {
    num_v += be.vtxs->vertex_values.size();
    num_e += be.vtxs->elements.size();
  }
  vertex_values.resize(num_v, 0.0);
  elements.resize(num_e, 0);
  bo.num_vertex_values = num_v;
  bo.num_elements = num_e;
  num_v = 0;
  num_e = 0;
  for (const i, mutable& be: bo.vs_arr) {
    for (const j, const& v: be.vtxs->vertex_values) {
      vertex_values[num_v + j] = v;
    }
    for (const j, const& e: be.vtxs->elements) {
      if (e == 0xffffffffU) {
	elements[num_e + j] = e;
      } else {
	elements[num_e + j] = e +
	  (static_cast{uint}(num_v) / num_float_struct{tattr});
      }
    }
    be.vertex_values_offset = num_v;
    be.elements_offset = num_e;
    num_v += be.vtxs->vertex_values.size();
    num_e += be.vtxs->elements.size();
  }
  {
    farray{uint, 2} vbos;
    glGenBuffers(2, vbos.rawptr());
    bo.vbo_values = vbos[0];
    bo.vbo_elems = vbos[1];
    if (vbos[0] == 0 || vbos[1] == 0) {
      return false;
    }
    glBindBuffer(GL_ARRAY_BUFFER, vbos[0]);
    glBufferData(GL_ARRAY_BUFFER,
      static_cast{GLsizeiptr}(vertex_values.size()) * 4,
      vertex_values.crawptr().void(), GL_STATIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbos[1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,
      static_cast{GLsizeiptr}(elements.size()) * 4,
      elements.crawptr().void(), GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
  }
  for (const i: 0 .. bo.vs_arr.size()) {
    bo.instances.push_back(make_ptr{instance_data}());
  }
  if (m::ne{use_instanced, 0}) {
    for (const i, const& vs: bo.vs_arr) {
      farray{uint, 1} vbos;
      glGenBuffers(1, vbos.rawptr());
      if (vbos[0] == 0) {
	return false;
      }
      bo.instances[i]->vbo_inst = vbos[0];
    }
  }
  return true;
}

private metafunction get_vattr{tshader}
  m::symbol{tshader, "vertex_attributes_type"};

private function {tbo, tshader} void
buffer_object_draw_pre(tbo const& bo, tshader const& sdr)
{
  metafunction tattr_bo m::symbol{tbo, "vertex_attributes_type"};
  metafunction tattr_sh m::symbol{tshader, "vertex_attributes_type"};
  metafunction is_sublist{xs, ys}
    m::and{
      m::le{m::size{xs}, m::size{ys}},
      m::eq{xs, m::slice{ys, 0, m::size{xs}}}};
  /* makes sure that tattr_sh is a sub-struct of tattr_bo */
  if (m::not{is_sublist{m::fields{tattr_sh}, m::fields{tattr_bo}}}) {
    m::error{m::concat{
      "incompatible type: ", m::fields{tattr_sh},
      ", expecting a subtype of: ", m::fields{tattr_bo}}};
  }
  /* */
  glBindBuffer(GL_ARRAY_BUFFER, bo.vbo_values);
  metafunction stride_byte m::mul{4, num_float_struct{tattr_bo}};
  size_t offset = 0;
  expand (sym, idx: m::map{m::field_names{tattr_sh},
    metafunction{s} m::concat{"a_", s}})
  {
  if (sdr.sym >= 0) {
    glEnableVertexAttribArray(static_cast{uint}(sdr.sym));
    int const nfloat = num_float_fld{m::at{m::field_types{tattr_sh}, idx}};
    glVertexAttribPointer(static_cast{uint}(sdr.sym), nfloat, GL_FLOAT, 0,
      stride_byte, offset_to_void_cp(offset));
    offset += static_cast{size_t}(nfloat) * 4;
  }
  }
  glBindBuffer(GL_ARRAY_BUFFER, 0);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bo.vbo_elems);
  if (m::ne{use_primitive_restart, 0}) {
    glEnable(GL_PRIMITIVE_RESTART);
    glPrimitiveRestartIndex(0xffffffff);
  }
}

private function {tbo, tshader} void
buffer_object_draw_post(tbo const& bo, tshader const& sdr)
{
  metafunction tattr_sh m::symbol{tshader, "vertex_attributes_type"};
  expand (sym, idx: m::map{m::field_names{tattr_sh},
    metafunction{s} m::concat{"a_", s}})
  {
  if (sdr.sym >= 0) {
    glDisableVertexAttribArray(static_cast{uint}(sdr.sym));
  }
  }
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
  if (m::ne{use_primitive_restart, 0}) {
    glDisable(GL_PRIMITIVE_RESTART);
  }
}

private function {tattr} void
buffer_object_draw_elems(buffer_object{tattr} const& bo, size_t vs_id)
{
  const& be = bo.vs_arr[vs_id];
  const elem_offset = be.elements_offset;
  const elem_num = be.vtxs->elements.size();
  GLenum mode = use_primitive_restart ? GL_TRIANGLE_FAN : GL_TRIANGLES;
  if (m::ne{use_draw_range, 0}) {
    private metafunction num_float_per_vertex num_float_struct{tattr};
    const arr_offset = be.vertex_values_offset / num_float_per_vertex;
    const arr_num = be.vtxs->vertex_values.size() / num_float_per_vertex;
    /*
    if (elem_num > 0) {
      println("DrawRangeElements", arr_offset, arr_num,
	be.vtxs->elements[elem_num-1]);
    }
    */
    glDrawRangeElements(mode,
      static_cast{GLuint}(arr_offset),
      static_cast{GLuint}(arr_offset + arr_num - 1),
      static_cast{GLsizei}(elem_num), GL_UNSIGNED_INT,
      offset_to_void_cp(elem_offset * 4));
  } else {
    glDrawElements(mode, static_cast{GLsizei}(elem_num), GL_UNSIGNED_INT,
      offset_to_void_cp(elem_offset * 4));
  }
}

private function {tattr} void
buffer_object_draw_elems_instanced(buffer_object{tattr} const& bo,
  size_t vs_id, size_t num_instance)
{
  size_t elem_offset;
  size_t elem_num;
  {
    const& be = bo.vs_arr[vs_id];
    elem_offset = be.elements_offset;
    elem_num = be.vtxs->elements.size();
  }
  GLenum mode = use_primitive_restart ? GL_TRIANGLE_FAN : GL_TRIANGLES;
  glDrawElementsInstanced(mode, static_cast{GLsizei}(elem_num),
    GL_UNSIGNED_INT, offset_to_void_cp(elem_offset * 4),
    static_cast{GLsizei}(num_instance));
}

public function {tbo, tshader} void
buffer_object_draw(tbo const& bo, size_t vs_id, tshader const& sdr)
{
  /*
  if (m::ne{m::symbol{tshader, "vertex_attributes_type"}, tattr}) {
    m::errror{"invalid type"};
  }
  */
  buffer_object_draw_pre(bo, sdr);
  buffer_object_draw_elems(bo, vs_id);
  buffer_object_draw_post(bo, sdr);
}

public threaded struct scene_node()
{
  public int vs_id = -1;
  public glm::mat4 trans;
  public glm::mat4 trans_initial;
  public varray{ptr{scene_node}} children;
  public tree_set{int} joint_sorts;
}

public function {tattr} ptr{scene_node}
buffer_object_instantiate_scene(buffer_object{tattr} const& bo, int vs_id)
{
  const r = make_ptr{scene_node}();
  r->vs_id = vs_id;
  if (vs_id >= 0) {
    r->joint_sorts[vs_id] = unit();
    const& vs = bo.vs_arr[static_cast{size_t}(vs_id)];
    for (size_t i, const& e: vs.vtxs->joints) {
      const p = bo.instantiate_scene(static_cast{int}(e.joint_sort));
      p->trans = e.trans;
      p->trans_initial = e.trans;
      r->children.push_back(p);
      for (const i, const x: p->joint_sorts) {
	r->joint_sorts[i] = unit();
      }
    }
  }
  return r;
}

private function {set_normal_func, tbo} void
scene_node_draw_rec(scene_node const& sn, tbo const& bo,
  glm::mat4 const& model_mat)
{
  const mm = model_mat * sn.trans;
  {
    set_normal_func(mm);
    if (sn.vs_id >= 0) {
      bo.draw_elems(static_cast{size_t}(sn.vs_id));
    }
  }
  for (const i, const& snp: sn.children) {
    scene_node_draw_rec{set_normal_func, tbo}(*snp, bo, mm);
  }
}

public function {set_normal_func, tbo, tshader} void
scene_node_draw(scene_node const& sn, tbo const& bo,
  glm::mat4 const& model_mat, tshader const& sdr)
{
  /*
  if (m::ne{m::symbol{tshader, "vertex_attributes_type"}, tattr}) {
    m::errror{"invalid type"};
  }
  */
  bo.draw_pre(sdr);
  scene_node_draw_rec{set_normal_func, tbo}(sn, bo, model_mat);
  bo.draw_post(sdr);
}

private function {tbo} void
scene_node_push_instance_rec(scene_node const& sn, glm::mat4 const& model_mat,
  tbo const& bo)
{
  const mm = model_mat * sn.trans;
  mutable& instance = *bo.instances[static_cast{size_t}(sn.vs_id)];
  mutable& arr = instance.client_buffer;
  arr.append(mm.cslice());
  for (const i, const& snp: sn.children) {
    scene_node_push_instance_rec{tbo}(*snp, mm, bo);
  }
}

public function {tbo} void
scene_node_prepare_instances(scene_node const& sn, tbo const& bo,
  glm::mat4 const& model_mat)
{
  for (const i, const x: sn.joint_sorts) {
    mutable& instance = *bo.instances[static_cast{size_t}(i)];
    mutable& arr = instance.client_buffer;
    arr.clear();
  }
  scene_node_push_instance_rec{tbo}(sn, model_mat, bo);
  for (const i, const x: sn.joint_sorts) {
    if (m::ne{use_instanced, 0}) {
      mutable& instance = *bo.instances[static_cast{size_t}(i)];
      mutable& arr = instance.client_buffer;
      glBindBuffer(GL_ARRAY_BUFFER, instance.vbo_inst);
      glBufferData(GL_ARRAY_BUFFER, static_cast{GLsizeiptr}(arr.size()) * 4,
	arr.crawptr().void(), GL_STATIC_DRAW);
      glBindBuffer(GL_ARRAY_BUFFER, 0);
    }
    // println("instances", i, arr.size());
  }
}

public function {tbo, tshader} void
scene_node_draw_instanced(scene_node const& sn, tbo const& bo,
  glm::mat4 const& model_mat, tshader const& sdr)
{
  if (sdr.u_model_matrix < 0) {
    return;
  }
  const loc = static_cast{uint}(sdr.u_model_matrix);
  bo.draw_pre(sdr);
  if (m::ne{use_instanced, 0}) {
    glEnableVertexAttribArray(loc + 0);
    glEnableVertexAttribArray(loc + 1);
    glEnableVertexAttribArray(loc + 2);
    glEnableVertexAttribArray(loc + 3);
    glVertexAttribDivisor(loc + 0, 1);
    glVertexAttribDivisor(loc + 1, 1);
    glVertexAttribDivisor(loc + 2, 1);
    glVertexAttribDivisor(loc + 3, 1);
  }
  for (const i, const x: sn.joint_sorts) {
    mutable& instance = *bo.instances[static_cast{size_t}(i)];
    mutable& arr = instance.client_buffer;
    /*
    arr.clear();
    scene_node_push_instance_rec{tbo}(sn, i, model_mat, arr);
    */
    if (m::ne{use_instanced, 0}) {
      glBindBuffer(GL_ARRAY_BUFFER, instance.vbo_inst);
      /*
      glBufferData(GL_ARRAY_BUFFER, static_cast{GLsizeiptr}(arr.size()) * 4,
	arr.crawptr().void(), GL_STATIC_DRAW);
      */
      int const nfloat = 4;
      int const stride_byte = nfloat * 4 * 4;
      glVertexAttribPointer(loc + 0, nfloat, GL_FLOAT, 0,
	stride_byte, offset_to_void_cp(0));
      glVertexAttribPointer(loc + 1, nfloat, GL_FLOAT, 0,
	stride_byte, offset_to_void_cp(16));
      glVertexAttribPointer(loc + 2, nfloat, GL_FLOAT, 0,
	stride_byte, offset_to_void_cp(32));
      glVertexAttribPointer(loc + 3, nfloat, GL_FLOAT, 0,
	stride_byte, offset_to_void_cp(48));
      glBindBuffer(GL_ARRAY_BUFFER, 0);
      bo.draw_elems_instanced(static_cast{size_t}(i), 
	arr.size() / 16);
      // println("draw", i, arr.size());
    } else {
      for (const j : 0U .. arr.size() / 16U) {
	glVertexAttrib4fv(loc + 0, arr.crawptr() + j * 16U +  0U);
	glVertexAttrib4fv(loc + 1, arr.crawptr() + j * 16U +  4U);
	glVertexAttrib4fv(loc + 2, arr.crawptr() + j * 16U +  8U);
	glVertexAttrib4fv(loc + 3, arr.crawptr() + j * 16U + 12U);
	bo.draw_elems(static_cast{size_t}(i));
      }
    }
  }
  if (m::ne{use_instanced, 0}) {
    glVertexAttribDivisor(loc + 0, 0);
    glVertexAttribDivisor(loc + 1, 0);
    glVertexAttribDivisor(loc + 2, 0);
    glVertexAttribDivisor(loc + 3, 0);
    glDisableVertexAttribArray(loc + 0);
    glDisableVertexAttribArray(loc + 1);
    glDisableVertexAttribArray(loc + 2);
    glDisableVertexAttribArray(loc + 3);
  }
  bo.draw_post(sdr);
}

