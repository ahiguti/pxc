
private namespace symbols;
public import numeric::integral -;
public import meta::common -;

private metafunction nslist{ns} imports_transitive{ns};
private metafunction is_concrete{t}
  and{eq{num_tparams{t}, num_targs{t}}, not{eq{t, void}}};
private metafunction filter_concrete{fs} filter{fs, is_concrete};
private metafunction has_byref_iter{f, n, i}
  cond{eq{n, i}, 0, or{argbyref{f, i}, has_byref_iter{f, n, add{i, 1}}}};
private metafunction norefarg{f} not{has_byref_iter{f, argnum{f}, 0}};
private metafunction filter_norefarg{fs} filter{fs, norefarg};
private metafunction nsfuncs{ns}
  filter_norefarg{filter_concrete{join{map{nslist{ns}, functions}}}};
private metafunction nstypes{ns} filter_concrete{join{map{nslist{ns}, types}}};
private metafunction atypes_one{f} join_all{list{rettype{f}}, argtypes{f}};
private metafunction atypes{fs}
  filter_concrete{join{map{filter_concrete{fs}, atypes_one}}};
private metafunction ftypes{ts}
  filter_concrete{join{map{ts, field_types}}};
private metafunction mfatypes{ts} atypes{join{map{ts, member_functions}}};
private metafunction tatypes{ts} join{map{ts, targs}};
private metafunction init_types{ns}
  unique{join_all{nstypes{ns}, atypes{nsfuncs{ns}}}};
private metafunction step_types{ts}
  unique{join_all{ts, ftypes{ts}, mfatypes{ts}, tatypes{ts}}};
private metafunction rep_types{ts, tsn}
  cond{eq{ts, tsn}, ts, rep_types{tsn, step_types{tsn}}};

public metafunction all_functions{ns} map{nsfuncs{ns}, full_string};
public metafunction all_types{ns}
  rep_types{init_types{ns}, step_types{init_types{ns}}};

