
/* $Id: gears.c,v 1.2 1999/10/21 16:39:06 brianp Exp $ */

/*
 * 3-D gear wheels.  This program is in the public domain.
 *
 * Command line options:
 *    -info      print GL implementation information
 *
 *
 * Brian Paul
 */

/* Conversion to GLUT by Mark J. Kilgard */

/*
 * $Log: gears.c,v $
 * Revision 1.2  1999/10/21 16:39:06  brianp
 * added -info command line option
 *
 * Revision 1.1.1.1  1999/08/19 00:55:40  jtg
 * Imported sources
 *
 * Revision 3.2  1999/06/03 17:07:36  brianp
 * an extra quad was being drawn in front and back faces
 *
 * Revision 3.1  1998/11/03 02:49:10  brianp
 * added fps output
 *
 * Revision 3.0  1998/02/14 18:42:29  brianp
 * initial rev
 *
 */

namespace sdlgears;
import common -;
import numeric::fpmath -;
import SDL -;
import GL::gl11 -;
import io::time -;

float const M_PI = 3.14159265;

function void gear(float inner_radius, float outer_radius, float width,
  int teeth_i, float tooth_depth)
{
  float teeth = static_cast{float}(teeth_i);
  int i;
  float r0;
  float r1;
  float r2;
  float angle;
  float da;
  float u;
  float v;
  float len;

  r0 = inner_radius;
  r1 = outer_radius - tooth_depth / 2.0;
  r2 = outer_radius + tooth_depth / 2.0;

  da = float(2.0) * M_PI / teeth / 4.0;

  glShadeModel(GL_FLAT);

  glNormal3f(0.0, 0.0, 1.0);

  /* draw front face */
  glBegin(GL_QUAD_STRIP);
  for (i = 0; i <= teeth_i; ++i) {
    angle = M_PI * 2.0 * static_cast{float}(i) / teeth;
    glVertex3f(r0 * cosf(angle), r0 * sinf(angle), width * 0.5);
    glVertex3f(r1 * cosf(angle), r1 * sinf(angle), width * 0.5);
    if (i < teeth_i) {
      glVertex3f(r0 * cosf(angle), r0 * sinf(angle), width * 0.5);
      glVertex3f(r1 * cosf(angle + da * 3.0), r1 * sinf(angle + da * 3.0),
	width * 0.5);
    }
  }
  glEnd();

  /* draw front sides of teeth */
  glBegin(GL_QUADS);
  da = M_PI * 2.0 / teeth / 4.0;
  for (i = 0; i < teeth_i; ++i) {
    angle = M_PI * 2.0 * static_cast{float}(i) / teeth;

    glVertex3f(r1 * cosf(angle), r1 * sinf(angle), width * 0.5);
    glVertex3f(r2 * cosf(angle + da), r2 * sinf(angle + da), width * 0.5);
    glVertex3f(r2 * cosf(angle + da * 2.0), r2 * sinf(angle + da * 2.0),
      width * 0.5);
    glVertex3f(r1 * cosf(angle + da * 3.0), r1 * sinf(angle + da * 3.0),
      width * 0.5);
  }
  glEnd();

  glNormal3f(0.0, 0.0, -1.0);

  /* draw back face */
  glBegin(GL_QUAD_STRIP);
  for (i = 0; i <= teeth_i; ++i) {
    angle = M_PI * 2.0 * static_cast{float}(i) / teeth;
    glVertex3f(r1 * cosf(angle), r1 * sinf(angle), -width * 0.5);
    glVertex3f(r0 * cosf(angle), r0 * sinf(angle), -width * 0.5);
    if (i < teeth_i) {
      glVertex3f(r1 * cosf(angle + da * 3.0), r1 * sinf(angle + da * 3.0),
	-width * 0.5);
      glVertex3f(r0 * cosf(angle), r0 * sinf(angle), -width * 0.5);
    }
  }
  glEnd();

  /* draw back sides of teeth */
  glBegin(GL_QUADS);
  da = M_PI * 2.0 / teeth / 4.0;
  for (i = 0; i < teeth_i; ++i) {
    angle = M_PI * 2.0 * static_cast{float}(i) / teeth;

    glVertex3f(r1 * cosf(angle + da * 3.0), r1 * sinf(angle + da * 3.0),
      -width * 0.5);
    glVertex3f(r2 * cosf(angle + da * 2.0), r2 * sinf(angle + da * 2.0),
      -width * 0.5);
    glVertex3f(r2 * cosf(angle + da), r2 * sinf(angle + da), -width * 0.5);
    glVertex3f(r1 * cosf(angle), r1 * sinf(angle), -width * 0.5);
  }
  glEnd();

  /* draw outward faces of teeth */
  glBegin(GL_QUAD_STRIP);
  for (i = 0; i < teeth_i; ++i) {
    angle = M_PI * 2.0 * static_cast{float}(i) / teeth;

    glVertex3f(r1 * cosf(angle), r1 * sinf(angle), width * 0.5);
    glVertex3f(r1 * cosf(angle), r1 * sinf(angle), -width * 0.5);
    u = r2 * cosf(angle + da) - r1 * cosf(angle);
    v = r2 * sinf(angle + da) - r1 * sinf(angle);
    len = sqrtf(u * u + v * v);
    u /= len;
    v /= len;
    glNormal3f(v, -u, 0.0);
    glVertex3f(r2 * cosf(angle + da), r2 * sinf(angle + da), width * 0.5);
    glVertex3f(r2 * cosf(angle + da), r2 * sinf(angle + da), -width * 0.5);
    glNormal3f(cosf(angle), sinf(angle), 0.0);
    glVertex3f(r2 * cosf(angle + da * 2.0), r2 * sinf(angle + da * 2.0),
      width * 0.5);
    glVertex3f(r2 * cosf(angle + da * 2.0), r2 * sinf(angle + da * 2.0),
      -width * 0.5);
    u = r1 * cosf(angle + da * 3.0) - r2 * cosf(angle + da * 2.0);
    v = r1 * sinf(angle + da * 3.0) - r2 * sinf(angle + da * 2.0);
    glNormal3f(v, -u, 0.0);
    glVertex3f(r1 * cosf(angle + da * 3.0), r1 * sinf(angle + da * 3.0),
      width * 0.5);
    glVertex3f(r1 * cosf(angle + da * 3.0), r1 * sinf(angle + da * 3.0),
      -width * 0.5);
    glNormal3f(cosf(angle), sinf(angle), 0.0);
  }

  float cos0 = 1.0;
  float sin0 = 0.0;
  glVertex3f(r1 * cos0, r1 * sin0, width * 0.5);
  glVertex3f(r1 * cos0, r1 * sin0, -width * 0.5);

  glEnd();

  glShadeModel(GL_SMOOTH);

  /* draw inside radius cylinder */
  glBegin(GL_QUAD_STRIP);
  for (i = 0; i <= teeth_i; ++i) {
    angle = M_PI * 2.0 * static_cast{float}(i) / teeth;
    glNormal3f(-cosf(angle), -sinf(angle), 0.0);
    glVertex3f(r0 * cosf(angle), r0 * sinf(angle), -width * 0.5);
    glVertex3f(r0 * cosf(angle), r0 * sinf(angle), width * 0.5);
  }
  glEnd();

}

float view_rotx = 20.0;
float view_roty = 30.0;
float view_rotz = 0.0;
uint gear1;
uint gear2;
uint gear3;
float gears_angle = 0.0;

function void draw(ptr{SDL} const& sdl)
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glPushMatrix();
  glRotatef(view_rotx, 1.0, 0.0, 0.0);
  glRotatef(view_roty, 0.0, 1.0, 0.0);
  glRotatef(view_rotz, 0.0, 0.0, 1.0);

  glPushMatrix();
  glTranslatef(-3.0, -2.0, 0.0);
  glRotatef(gears_angle, 0.0, 0.0, 1.0);
  glCallList(gear1);
  glPopMatrix();

  glPushMatrix();
  glTranslatef(3.1, -2.0, 0.0);
  glRotatef(gears_angle * static_cast{float}(-2.0) - 9.0, 0.0, 0.0, 1.0);
  glCallList(gear2);
  glPopMatrix();

  glPushMatrix();
  glTranslatef(-3.1, 4.2, 0.0);
  glRotatef(gears_angle * static_cast{float}(-2.0) - 25.0, 0.0, 0.0, 1.0);
  glCallList(gear3);
  glPopMatrix();

  glPopMatrix();
}

function void reshape(uint width, uint height)
{ 
  double h = static_cast{double}(height) / static_cast{double}(width);
  glViewport(0, 0, static_cast{GLsizei}(width), static_cast{GLsizei}(height));
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glFrustum(-1.0, 1.0, -h, h, 5.0, 60.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef(0.0, 0.0, -40.0);
}


function void init()
{
  farray{float, 4} pos;
  pos[0] = 5.0;
  pos[1] = 5.0;
  pos[2] = 10.0;
  pos[3] = 0.0;
  farray{float, 4} red;
  red[0] = 0.8;
  red[1] = 0.1;
  red[2] = 0.0;
  red[3] = 1.0;
  farray{float, 4} green;
  green[0] = 0.0;
  green[1] = 0.8;
  green[2] = 0.2;
  green[3] = 1.0;
  farray{float, 4} blue;
  blue[0] = 0.2;
  blue[1] = 0.2;
  blue[2] = 1.0;
  blue[3] = 1.0;

  glLightfv(GL_LIGHT0, GL_POSITION, pos);
  glEnable(GL_CULL_FACE);
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);

  /* make the gears */
  gear1 = glGenLists(1);
  glNewList(gear1, GL_COMPILE);
  glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, red);
  gear(1.0, 4.0, 1.0, 20, 0.7);
  glEndList();

  gear2 = glGenLists(1);
  glNewList(gear2, GL_COMPILE);
  glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, green);
  gear(0.5, 2.0, 2.0, 10, 0.7);
  glEndList();

  gear3 = glGenLists(1);
  glNewList(gear3, GL_COMPILE);
  glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, blue);
  gear(1.3, 2.0, 0.5, 10, 0.7);
  glEndList();

  glEnable(GL_NORMALIZE);
}

{
  const sdl = SDL::Init(system, SDL_INIT_VIDEO);
  const uint init_w = 300;
  const uint init_h = 300;
  const s = sdl.SetVideoMode(init_w, init_h, 16, SDL_OPENGL | SDL_RESIZABLE);
  // sdl.GL_SetAttribute(SDL_GL_SWAP_CONTROL, 1);
  sdl.WM_SetCaption("PXC-SDLGears", "pxc-sdlgears");

  init();
  reshape(init_w, init_h);

  uint t0 = 0;
  uint t1 = 0;
  uint frames = 0;

  bool done = false;
  while (!done) {
    Event ev;
    while (sdl.PollEvent(ev)) {
      EventType const etype = ev.Type();
      if (etype == SDL_VIDEORESIZE) {
	const uint w = static_cast{uint}(ev.ResizeW());
	const uint h = static_cast{uint}(ev.ResizeH());
	const nw = sdl.SetVideoMode(w, h, 16, SDL_OPENGL | SDL_RESIZABLE);
	reshape(w, h);
      } else if (etype == SDL_QUIT) {
	done = true;
	break;
      }
    }
    draw(sdl);
    sdl.GL_SwapBuffers();
    {
      ++frames;
      uint t = sdl.GetTicks();
      if (t - t0 >= 5000) {
	float seconds = static_cast{float}(t - t0) / 1000.0;
	float fps = static_cast{float}(frames) / seconds;

	println(join{" "}(frames, "frames in", seconds, "seconds =", fps,
	  "fps"));
	t0 = t;
	frames = 0;
      }
      if (t - t1 >= 10) {
	t1 += 10;
	gears_angle += 1.0;
	const ks = sdl.GetKeyState();
	if (ks.Key(SDLK_ESCAPE) != 0) {
	  done = 1;
	}
	if (ks.Key(SDLK_UP) != 0) {
	  view_rotx += 1.0;
	}
	if (ks.Key(SDLK_DOWN) != 0) {
	  view_rotx -= 1.0;
	}
	if (ks.Key(SDLK_LEFT) != 0) {
	  view_roty += 1.0;
	}
	if (ks.Key(SDLK_RIGHT) != 0) {
	  view_roty -= 1.0;
	}
      }
    }
  }
}

