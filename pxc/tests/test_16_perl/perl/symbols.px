
private namespace perl::symbols;
import meta::common -;
import numeric::integral -;

private metafunction nslist{ns} imports_transitive{ns};
private metafunction is_concrete{t}
  and{eq{num_tparams{t}, num_targs{t}}, not{eq{t, void}},
    not{attribute{t, "ephemeral"}}};
private metafunction filter_concrete{fs} filter{fs, is_concrete};
private metafunction has_byref_iter{f, n, i}
  cond{eq{n, i}, 0, or{argbyref{f, i}, has_byref_iter{f, n, add{i, 1}}}};
private metafunction norefarg{f} not{has_byref_iter{f, argnum{f}, 0}};
private metafunction filter_norefarg{fs} filter{fs, norefarg};
private metafunction nsfuncs{ns}
  filter_norefarg{filter_concrete{join{map{nslist{ns}, functions}}}};
private metafunction nstypes{ns} filter_concrete{join{map{nslist{ns}, types}}};
private metafunction atypes_one{f} joinv{list{rettype{f}}, argtypes{f}};
private metafunction atypes{fs} filter_concrete{join{map{fs, atypes_one}}};
private metafunction ftypes{ts} filter_concrete{join{map{ts, field_types}}};
private metafunction mfatypes{ts} atypes{join{map{ts, member_functions}}};
private metafunction tatypes{ts} filter_concrete{join{map{ts, targs}}};
private metafunction is_nonvoid{t} not{eq{t, void}};
private metafunction init_types{ns}
  unique{joinv{nstypes{ns}, atypes{nsfuncs{ns}}}};
private metafunction step_types{ts}
  unique{joinv{ts, ftypes{ts}, mfatypes{ts}, tatypes{ts}}};
private metafunction rep_types{ts, tsn}
  cond{eq{ts, tsn}, ts, rep_types{tsn, step_types{tsn}}};

public metafunction all_functions{ns} nsfuncs{ns};
public metafunction all_types{ns}
  rep_types{init_types{ns}, step_types{init_types{ns}}};

