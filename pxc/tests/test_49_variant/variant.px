namespace variant;
import common -;
import meta::common m;
import numeric::cast n;
import exception::common -;
import string::positional -;
import downcast -;

public multithreaded union variant {
  unit unitval;
  long longval;
  ulong ulongval;
  double doubleval;
  string stringval;
  tptr{idynamic} tptrval;
}

public multithreaded interface idynamic {
  function variant invoke(cstrref const& name, cslice{variant} const& args);
}

private macro is_string_family_type{t}
  m::or{
    m::eq{t, string},
    m::eq{t, strlit},
    m::eq{t, strref},
    m::eq{t, cstrref}};

private macro is_range_type{t}
  m::or{
    m::eq{m::family{t}, "slice"},
    m::eq{m::family{t}, "cslice"},
    m::eq{m::family{t}, "tree_map_range"},
    m::eq{m::family{t}, "tree_map_crange"}};

private macro to_non_ephemeral{t}
  m::metaif{is_string_family_type{t}, string,
  m::metaif{is_range_type{t}, m::local{t, "non_ephemeral_type"},
  t}};

public threaded function {t} variant to_variant(t const& x)
{
  variant r;
  if (m::eq{t, unit}) {
    r.unitval = unit();
  } else if (n::is_signed_integral{t}) {
    r.longval = n::static_cast{long, t}(x);
  } else if (n::is_unsigned_integral{t}) {
    r.ulongval = n::static_cast{ulong, t}(x);
  } else if (n::is_fp{t}) {
    r.doubleval = x;
  } else if (is_string_family_type{t}) {
    r.stringval = x;
  } else if (m::eq{t, variant}) {
    r = x;
  } else if (m::eq{t, tptr{idynamic}}) {
    r.tptrval = x;
  } else {
    r.tptrval = tptr{stub_idynamic{t}}(stub_idynamic{t}(x));
  }
  return r;
}

public threaded function {t} t from_variant(variant const& x)
{
  if (m::eq{t, unit}) {
    return unit();
  } else if (n::is_integral_enum_bitmask{t}) {
    if (case x.longval) {
      return n::static_cast{t, long}(x.longval);
    } else if (case x.ulongval) {
      return n::static_cast{t, ulong}(x.ulongval);
    } else if (case x.doubleval) {
      return n::static_cast{t, double}(x.doubleval);
    } else if (case x.stringval) {
      return decimal_to_integral_nocheck{t}(x.stringval);
    } else if (case x.unitval) {
      return 0;
    }
  } else if (n::is_fp{t}) {
    if (case x.doubleval) {
      return n::static_cast{t, double}(x.doubleval);
    } else if (case x.longval) {
      return n::static_cast{t, long}(x.longval);
    } else if (case x.ulongval) {
      return n::static_cast{t, ulong}(x.ulongval);
    } else if (case x.stringval) {
      return decimal_to_fp_nocheck{t}(x.stringval);
    } else if (case x.unitval) {
      return 0.0;
    }
  } else if (m::eq{t, string}) {
    if (case x.stringval) {
      return x.stringval;
    } else if (case x.longval) {
      return to_string(x.longval);
    } else if (case x.ulongval) {
      return to_string(x.ulongval);
    } else if (case x.doubleval) {
      return to_string(x.doubleval);
    } else if (case x.unitval) {
      return to_string(x.unitval);
    }
  } else if (m::eq{t, variant}) {
    return x;
  } else if (m::eq{t, tptr{idynamic}}) {
    return x.tptrval;
  } else {
    return downcast_mutable{stub_idynamic{t}, idynamic}(*(x.tptrval)).value;
  }
  throw invalid_field();
}

private macro stub_idynamic_args{t}
  m::metaif{
    m::is_copyable_type{t},
    m::list{m::list{0, "x", t, 0, 1}},
    m::args{t}};
private macro argexp{arg}
  m::list{
    argname{arg}, // a0, a1, a2, ...
    m::add{m::mul{m::at{arg, 3}, 2}, m::at{arg, 4}}}; // byref * 2 + mutable
private macro argname{arg} m::concat{"a", m::at{arg, 0}};
private macro argnames{t, fsym}
  m::metamap{m::args{m::local{t, m::to_string{fsym}}}, argname};
private macro seqstr{n} m::metamap{m::seq{n}, m::to_string};
private macro mfuncstr{t} m::metamap{m::member_functions{t}, m::to_string};
private macro argexp_list{t, fsym}
  m::metamap{m::args{m::local{t, m::to_string{fsym}}}, argexp};
private macro argtype_noneph{t, fsym, idx}
  to_non_ephemeral{m::at{m::at{m::args{m::local{t, fsym}}, idx}, 2}};

public multithreaded struct {t}
stub_idynamic(expand(a : stub_idynamic_args{t})) : idynamic :
{
  expand(dummy : m::list{m::list{"dummy", m::is_copyable_type{t}}}) {
    t value = t(expand(a : m::argnames{t}; a));
    t value = x;
  }
  function variant invoke(cstrref const& name, cslice{variant} const& args) {
    expand(fsym : mfuncstr{t}) {
      if (m::to_string{fsym} == name) {
	expand(ae, idx : argexp_list{t, fsym}) {
	  /* const value */
	  argtype_noneph{t, fsym, idx} ae =
	    from_variant{argtype_noneph{t, fsym, idx}}(args[idx]);
	  /* mutable value */
	  argtype_noneph{t, fsym, idx} ae =
	    from_variant{argtype_noneph{t, fsym, idx}}(args[idx]);
	  /* const reference */
	  argtype_noneph{t, fsym, idx} const& ae =
	    downcast_const{
	      stub_idynamic{argtype_noneph{t, fsym, idx}}, idynamic
	    }(*(args[idx].tptrval)).value;
	  /* mutable reference */
	  argtype_noneph{t, fsym, idx} mutable& ae =
	    downcast_mutable{
	      stub_idynamic{argtype_noneph{t, fsym, idx}}, idynamic
	    }(*(args[idx].tptrval)).value;
	}
	if (m::eq{m::rettype{m::local{t, m::to_string{fsym}}}, void}) {
	  value.fsym(expand(a : argnames{t, fsym}; a));
	  return variant();
	} else {
	  return to_variant{m::rettype{m::local{t, m::to_string{fsym}}}}(
	    value.fsym(expand(a : argnames{t, fsym}; a)));
	}
      }
    }
    return variant();
  }
}

