#!/usr/bin/env pxc
public namespace echosvr;
import common -;
import io -;
import io::file -;
import io::errno -;
import io::standard -;
import io::addrinfo -;
import io::socket -;
import io::signal -;
import io::fcntl -;
import thread::func -;
import io::epoll -;
import io::poll -;
import meta m;

private metafunction svr_host "127.0.0.1";
private metafunction svr_port "5001";

private metafunction use_epoll 1;
expand (dummy: m::seq{use_epoll}) {
//private metafunction POLLIN m::trace{io::epoll::EPOLLIN};
private metafunction POLLOUT io::epoll::EPOLLOUT;
private metafunction poll io::epoll::epoll;
private metafunction poll_event io::epoll::epoll_event;
}
expand (dummy: m::seq{m::not{use_epoll}}) {
//private metafunction POLLIN m::trace{io::poll::POLLIN};
private metafunction POLLOUT io::poll::POLLOUT;
private metafunction poll io::poll::poll;
private metafunction poll_event io::poll::poll_event;
}

multithreaded struct
worker_shared(io const& sys0, file_mt const& lsn0)
{
  public io const sys = sys0;
  public file_mt const lsn = lsn0;
}

multithreaded struct
conn_data(file_mt const& fp)
{
  file_mt const file = fp;
  string read_buffer;
  string write_buffer;
}

threaded function void
worker_main(tptr{worker_shared} const& shared, int thr_id)
{
  const sys = shared->sys;
  const err = sys.stderr();
  metafunction entry_type option{ptr{conn_data}};
  vector{entry_type} conns;
  threaded function entry_type get_conn(int fd) {
    if (fd < 0 || static_cast{size_t}(fd) >= conns.size()) {
      return entry_type();
    }
    return conns[static_cast{size_t}(fd)];
  }
  threaded function void set_conn(int fd, entry_type const& v) {
    if (fd < 0) {
      return;
    }
    const p = static_cast{size_t}(fd);
    if (p >= conns.size()) {
      conns.resize(p + 1, entry_type());
    }
    conns[p] = v;
  }
  try {
    const lsn = shared->lsn;
    mutable pl = epoll(io::system);
    pl.add(lsn, EPOLLIN);
    mutable peer_addr = sockaddr_storage();
    vector{epoll_event} events;
    string buffer;
    err.println(string_join{" "}("ready", thr_id));
    while (true) {
      events.clear();
      pl.wait(100, 1000, events);
      for (const i, const ev: events) {
	const revents = ev.events();
	const fd = ev.fileno();
	const oconn = get_conn(fd);
	if (const pconn : oconn.some) {
	  const& conn = *pconn;
	  if ((revents & EPOLLIN) != 0) {
	    buffer.clear();
	    const r = conn.file.read(buffer, 100);
	    if (buffer.empty()) {
	      bool close_flag = false;
	      if (const e : r.errno) {
		if (e != EAGAIN && e != EWOULDBLOCK && e != EINTR) {
		  err.println(string_join{" "}("err:", fd, thr_id, e));
		  close_flag = true;
		}
	      } else {
		err.println(string_join{" "}("eof:", fd, thr_id));
		close_flag = true;
	      }
	      if (close_flag) {
		pl.remove(conn.file);
		set_conn(fd, entry_type());
	      }
	    } else {
	      err.print(string_join{" "}("read:", fd, thr_id, buffer));
	      conn.file.write(buffer); /* fixme: drops if EWOULDBLOCK */
	    }
	  }
	} else if (fd == lsn.fileno()) {
	  const a = lsn.accept(peer_addr);
	  if (const sock : a.value) {
	    err.println(string_join{" "}("acc:", sock.fileno(), thr_id));
	    sock.setfl(O_RDWR | O_NONBLOCK);
	    pl.add(sock, EPOLLIN);
	    entry_type v;
	    v.some = make_ptr{conn_data}(sock);
	    set_conn(sock.fileno(), v);
	  }
	}
      }
    }
  } catch (exception::c_exception e) {
    err.println(string_join{" "}("thrown:", thr_id, to_string(e)));
  } catch (io::errno::errno_t e) {
    err.println(string_join{" "}("errno:", thr_id, to_string(e)));
  }
}

{
  io::system.signal(SIGPIPE, SIG_IGN);
  const lsn = io::system.listen(svr_host, svr_port, AF_INET,
    SOCK_STREAM, IPPROTO_TCP, 1024, true);
  lsn.setfl(O_RDONLY | O_NONBLOCK);
  vector{ptr{uneval{void}}} workers;
  for (const i: 0 .. 2) {
    const pshared = make_tptr{worker_shared}(io::system, lsn);
    const sthr = make_thread_func{worker_main}(pshared, i);
    workers.push_back(sthr);
  }
}

