
// FIXME: don't use this

namespace thread;
import io;

public multithreaded extern "pxcthread::system_impl" struct system { }
public macro system_ref tref{system};
public multithreaded extern "pxcthread::thread_impl" struct thread { }
public macro thread_ref tref{thread};

private multithreaded struct {tshared, func} thread_main_impl : thread_main : {
  tshared shared;
  function void main() {
    func(shared);
  }
}
public threaded function {tshared, func}
  thread_ref system_create_thread_func(system_ref sys, tshared shared)
{
  thread_main_impl{tshared, func} impl;
  tref{thread_main} r = impl(shared);
  return system_create_thread(sys, r);
}

public multithreaded interface thread_main { function void main(); }
public macro thread_main_ref tref{thread_main};

public extern "pxcthread::sys" system_ref sys;

public threaded extern "pxcthread::system_create_thread"
  function thread_ref system_create_thread(system_ref s, thread_main_ref f);
public threaded extern "pxcthread::thread_join"
  function void thread_join(thread_ref thr);

extern "type" inline
namespace pxcthread {
struct system_impl;
struct thread_impl;
};

extern "fdecl" inline
namespace pxcthread {
typedef pxcrt::rcptr< pxcrt::trcval<system_impl> > system_ptr;
typedef pxcrt::rcptr< pxcrt::trcval<thread_impl> > thread_ptr;
typedef pxcrt::rcptr< thread$n::thread_main$i > main_ptr;
struct system_impl { };
struct thread_impl {
  thread_impl() : tid(), need_join(false) { }
  ~thread_impl() { join(); }
  void join();
  pthread_t tid;
  bool need_join;
  main_ptr mptr;
};
thread_ptr system_create_thread(system_ptr::rawptr s, main_ptr::rawptr m);
void thread_join(thread_ptr::rawptr t);
extern system_ptr sys;
};

extern "fdef" inline
#define DBG(x)
namespace pxcthread {
system_ptr sys;
void *pxc_thread_start(void *arg)
{
  main_ptr::rawptr m = static_cast<main_ptr::rawptr>(arg);
  pxcrt::lockobject lck(m->get_mutex$z()); /* lock the main object */
  try {
    m->main$f();
  } catch (...) {
    /* FIXME */
  }
  return 0;
}
thread_ptr system_create_thread(system_ptr::rawptr s, main_ptr::rawptr m)
{
  thread_ptr thr = thread_ptr(pxcrt::boxing());
  thread_impl& impl = thr->value$z;
  impl.mptr = m; /* root */
  if (pthread_create(&impl.tid, 0, pxc_thread_start, m) != 0) {
    thr = thread_ptr();
    DBG(fprintf(stderr, "failed to create thread\n"));
  } else {
    DBG(fprintf(stderr, "create thread\n"));
    impl.need_join = true;
  }
  return thr;
}
void thread_join(thread_ptr::rawptr t)
{
  if (t == 0) {
    return;
  }
  pxcrt::lockobject lck(t->get_mutex$z());
  t->value$z.join();
}
void thread_impl::join()
{
  if (!need_join) {
    DBG(fprintf(stderr, "no need to join\n"));
    return;
  }
  DBG(fprintf(stderr, "join\n"));
  const int e = pthread_join(tid, 0);
  assert(e == 0);
  need_join = false;
}
};
#undef DBG

