namespace orb;
public import common -;
public import string::conversion -;
public import ordered::compare -;
public import exception::common -;
public import downcast -;
public import meta::common m;
public import meta::family mf;

public threaded struct orb {
  ns_functions funcs;
  vector{methods} mets;
  string rbuf;
  string wbuf;
}

public threaded interface remote { }

public threaded function void execute(orb& o)
{
  try {
    uchar req = o.rbuf[0];
    if (req == 'F') {
      call_ns_function(o, 2);
    } else {
      o.wbuf.append("T\tunknown_request\n");
    }
  } catch (runtime_error e) {
    o.wbuf.clear();
    o.wbuf.append("T\t");
    string s = "runtime_error\n";
    string tr = get_stack_trace(e);
    s.append(tr);
    serialize_to_string{string}(s, o.wbuf);
    o.wbuf.append("\n");
  }
}

public threaded function void call_ns_function(orb& o, size_t const rbuf_pos)
{
  ns_functions_slice fs = o.funcs;
  size_t const delimpos = o.rbuf.find(rbuf_pos, '\t');
  size_t const rbuf_args_pos =
    delimpos < o.rbuf.size() ? delimpos + 1 : delimpos;
  size_t const p = binary_search{func_entry, cstrref, compare_func_entry}(
    fs, o.rbuf[rbuf_pos .. delimpos]);
  if (p < fs.size()) {
    fs[p].func->call(o, rbuf_args_pos);
  } else {
    o.wbuf.append("T\tfunction_not_found\n");
  }
}

public threaded function void call_method(orb& o, size_t const rbuf_pos,
  size_t tid, remote& obj)
{
  methods_slice ms = o.mets[tid];
  size_t const delimpos = o.rbuf.find(rbuf_pos, '\t');
  size_t const rbuf_args_pos =
    delimpos < o.rbuf.size() ? delimpos + 1 : delimpos;
  size_t const p = binary_search{method_entry, cstrref, compare_method_entry}(
    ms, o.rbuf[rbuf_pos .. delimpos]);
  if (p < ms.size()) {
    ms[p].method->call(o, rbuf_args_pos, obj);
  } else {
    o.wbuf.append("T\tmethod_not_found\n");
  }
}

public threaded struct func_entry (strlit const& k,
  ptr{i_marshal_fcall} const& f)
{
  strlit name = k;
  ptr{i_marshal_fcall} func = f;
}

public threaded struct method_entry (strlit const& k,
  ptr{i_marshal_method} const& f)
{
  strlit name = k;
  ptr{i_marshal_method} method = f;
}

public metafunction ns_functions vector{func_entry};
public metafunction ns_functions_slice cslice{func_entry};

public metafunction methods vector{method_entry};
public metafunction methods_slice cslice{method_entry};

public threaded function {ns} ns_functions create_ns_functions()
{
  ns_functions fs;
  expand (fsym, idx : m::sort{m::map{m::functions{ns}, m::to_string}}) {
    {
      strlit k = m::to_string{fsym};
      metafunction fc marshal_fcall{m::symbol{fsym, ns}};
      ptr{i_marshal_fcall} p = ptr{fc}(fc());
      func_entry e = func_entry(k, p);
      fs.push_back(e);
    }
  }
  return fs;
}

public threaded function {t} methods create_methods()
{
  methods ms;
  expand (fsym, idx : m::map{member_functions_sorted{t}, m::to_string}) {
    {
      strlit k = m::to_string{fsym};
      metafunction mt marshal_method{t, idx};
      ptr{i_marshal_method} p = ptr{mt}(mt());
      method_entry e = method_entry(k, p);
      ms.push_back(e);
    }
  }
  return ms;
}

private threaded interface i_marshal_fcall
{
  function void call(orb& o, size_t pos) const;
}

private threaded struct {f} marshal_fcall <i_marshal_fcall>
{
  function void call(orb& o, size_t pos) const {
    expand (asym, idx : func_argexp_list{f}) {
      func_argtype_ne{f, idx} asym =
	unmarshal_value{func_argtype_ne{f, idx}}(o.rbuf, pos);
    }
    o.rbuf.clear();
    if (m::ne{m::rettype{f}, void}) {
      m::rettype{f} r = f(expand(a : func_argnames{f}; a));
      o.wbuf.append("R\t");
      marshal_value(o.wbuf, r);
      o.wbuf.append("\n");
    } else {
      o.wbuf.append("R\t");
      f(expand(a : func_argnames{f}; a));
      o.wbuf.append("\n");
    }
  }
}

private threaded interface i_marshal_method
{
  function void call(orb& o, size_t pos, remote& obj) const;
}

private threaded struct {t, mi} marshal_method <i_marshal_method>
{
  function void call(orb& o, size_t pos, remote& obj) const {
    t mutable& objt = downcast_mutable{t, remote}(obj);
    metafunction f m::at{member_functions_sorted{t}, mi};
    expand (asym, idx : func_argexp_list{f}) {
      func_argtype_ne{f, idx} asym =
	unmarshal_value{func_argtype_ne{f, idx}}(o.rbuf, pos);
    }
    o.rbuf.clear();
    expand (fsym : m::list{m::list{m::to_string{f}, 0}}) {
      if (m::ne{m::rettype{f}, void}) {
	m::rettype{f} r = objt.fsym(expand(a : func_argnames{f}; a));
	o.wbuf.append("R\t");
	marshal_value(o.wbuf, r);
	o.wbuf.append("\n");
      } else {
	o.wbuf.append("R\t");
	obj.fsym(expand(a : func_argnames{f}; a));
	o.wbuf.append("\n");
      }
    }
  }
}

private threaded function {t, tk, cmp} size_t binary_search(cslice{t} const& s,
  tk const& k)
{
  size_t first = 0;
  size_t last = s.size();
  while (last - first > 0) {
    extern "disable_bounds_checking" 1; /* s[middle] is always safe */
    size_t const middle = first + ((last - first) >> 1);
    int const c = cmp(s[middle], k);
    if (c < 0) {
      first = middle + 1;
    } else if (c > 0) {
      last = middle;
    } else {
      return middle;
    }
  }
  return s.size();
}

private threaded function int compare_func_entry(func_entry const& ent,
  cstrref const& k)
{
  return compare{cstrref}(ent.name, k);
}

private threaded function int compare_method_entry(method_entry const& ent,
  cstrref const& k)
{
  return compare{cstrref}(ent.name, k);
}

private threaded function {t} t unmarshal_value(string const& buf, size_t& pos)
{
  size_t delimpos = buf.find(pos, '\t');
  cstrref tok = buf[pos .. delimpos];
  pos = delimpos < buf.size() ? delimpos + 1 : delimpos;
  return deserialize_from_string{t}(tok);
}

private threaded function {t} void marshal_value(string& buf, t const& x)
{
  serialize_to_string{t}(x, buf);
}

private metafunction member_functions_sorted{t}
  sort_by_string{m::member_functions{t}};
private metafunction sort_by_string{lst}
  m::map{m::sort{m::map{lst, string_and_value}}, m::at1};
private metafunction string_and_value{v} m::list{m::to_string{v}, v};

private metafunction func_argexp_list{f}
  m::map{m::seq{m::size{m::args{f}}}, argexp};
private metafunction argexp{idx}
  m::list{m::concat{"a", idx}, 0};
private metafunction func_argnames{f}
  m::map{m::seq{m::size{m::args{f}}}, argname};
private metafunction argname{idx}
  m::concat{"a", idx};
private metafunction func_argtype_ne{f, idx}
 mf::to_non_ephemeral_type{m::at{m::argtypes{f}, idx}};

