
namespace container;
public import generic;

public multithreaded extern "container::vector" "varray"
struct {t} vector {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type slice{t};
  public macro crange_type cslice{t};
  public extern "size" function size_t size() const;
  public extern "empty" function bool empty() const;
  public extern "resize" function void resize(size_t v);
  public extern "clear" function void clear();
  public extern "push_back" function void push(t v);
  public extern "pop_back" function t pop();
}

public multithreaded extern "container::farray" "farray"
struct {t, n} farray {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type slice{t};
  public macro crange_type cslice{t};
  public extern "size" function size_t size() const;
  public extern "empty" function bool empty() const;
}

public multithreaded extern "container::slice" "slice"
struct {t} slice {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type slice{t};
  public macro crange_type cslice{t};
  public extern "size" function size_t size() const;
  public extern "empty" function bool empty() const;
}

public multithreaded extern "container::cslice" "cslice"
struct {t} cslice {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type cslice{t};
  public macro crange_type cslice{t};
  public extern "size" function size_t size() const;
}

public macro tree_map{t, s}
  tree_map_compare{t, s, compare_function_object{t}};
public macro tree_map_range{t, s}
  tree_map_compare_range{t, s, compare_function_object{t}};
public macro tree_map_crange{t, s}
  tree_map_compare_crange{t, s, compare_function_object{t}};

private multithreaded struct {t} compare_function_object {
  public function int call(t x, t y) { return generic::compare(x, y); }
}

private multithreaded extern "container::tree_map_compare" "tree_map"
struct {t, s, f} tree_map_compare {
  public macro key_type t;
  public macro mapped_type s;
  public macro range_type tree_map_range{t, s};
  public macro crange_type tree_map_crange{t, s};
  public extern "size" function size_t size() const;
  public extern "empty" function bool empty() const;
  public extern "clear" function void clear();
}

private multithreaded extern "container::tree_map_range" "tree_map_range"
struct {t, s, f} tree_map_compare_range {
  public macro key_type t;
  public macro mapped_type s;
  public macro range_type tree_map_compare_range{t, s, f};
  public macro crange_type tree_map_compare_crange{t, s, f};
  public extern "size" function size_t size() const;
}

private multithreaded extern "container::tree_map_range" "tree_map_crange"
struct {t, s, f} tree_map_compare_crange {
  public macro key_type t;
  public macro mapped_type s;
  public macro range_type tree_map_compare_crange{t, s, f};
  public macro crange_type tree_map_compare_crange{t, s, f};
  public extern "size" function size_t size() const;
}

extern "type" inline
#include <vector>
#include <map>
#include <stdint.h>
#include <stdio.h>
namespace container {
template <typename T>
struct vector {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::refvar_igrd;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd;
  typedef typename std::vector<T>::size_type size_type;
  typedef typename std::vector<T>::iterator iterator;
  typedef typename std::vector<T>::const_iterator const_iterator;
  vector() : invalidate_guard_count(0) { }
  vector(const vector& x) : v(x.v), invalidate_guard_count(0) { }
  vector& operator =(const vector& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  size_type size() const { return v.size(); }
  bool empty() const { return v.empty(); }
  T& operator [](size_type idx) {
    if (idx >= v.size()) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= v.size()) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  void resize(size_type sz) {
    check_resize();
    v.resize(sz);
  }
  void clear() {
    check_resize();
    v.clear();
  }
  void push_back(const T& x) {
    check_resize();
    v.push_back(x);
  }
  T pop_back() {
    check_resize();
    if (v.empty()) { pxcrt::throw_invalid_index(); }
    const T r = v.back();
    v.pop_back();
    return r;
  }
  iterator begin() { return v.begin(); }
  const_iterator begin() const { return v.begin(); }
  iterator end() { return v.end(); }
  const_iterator end() const { return v.end(); }
  T *rawarr() { return &v[0]; }
  const T *rawarr() const { return &v[0]; }
private:
  void check_resize() {
    if (invalidate_guard_count != 0) { pxcrt::throw_would_invalidate(); }
  }
  void inc_invalidate_guard() const {
    ++invalidate_guard_count;
  }
  void dec_invalidate_guard() const {
    --invalidate_guard_count;
  }
private:
  std::vector<T> v;
  mutable size_t invalidate_guard_count;
};
template <typename T, size_t len>
struct farray {
  typedef size_t size_type;
  farray() : v() { }
  size_t size() const { return len; }
  bool empty() const { return len == 0; }
  T& operator [](size_type idx) {
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  T *rawarr() { return v; }
  const T *rawarr() const { return v; }
private:
  T v[len];
};
template <typename T>
struct slice {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::refvar_igrd;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd;
  typedef size_t size_type;
  slice() : v(0), len(0) { }
  template <typename Tc> slice(Tc& c, size_t o1, size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  size_type size() const { return len; }
  T& operator [](size_type idx) const {
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  T *rawarr() const { return v; }
private:
  void inc_invalidate_guard() const { }
  void dec_invalidate_guard() const { }
private:
  T *v;
  size_t len;
};
template <typename T>
struct cslice {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::refvar_igrd;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd;
  typedef size_t size_type;
  cslice() : v(0), len(0) { }
  cslice(const slice<T>& x) : v(x.rawarr()), len(x.size()){ }
  template <typename Tc> cslice(const Tc& c, size_t o1, size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  size_type size() const { return len; }
  const T& operator [](size_type idx) const {
    if (idx >= len) { pxcrt::throw_invalid_index(); }
    return v[idx];
  }
  const T *rawarr() const { return v; }
private:
  void inc_invalidate_guard() const { }
  void dec_invalidate_guard() const { }
private:
  const T *v;
  size_t len;
};
template <typename Tf>
struct compare_less {
  Tf f;
  template <typename Tk> inline bool operator ()(const Tk& x, const Tk& y) {
    return f.call$f(x, y) < 0;
  }
};
template <typename Tk, typename Tm, typename Tf>
struct tree_map_compare {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::refvar_igrd;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd;
  typedef std::map< Tk, Tm, compare_less<Tf> > map_type;
  typedef typename map_type::size_type size_type;
  typedef typename map_type::iterator iterator;
  typedef typename map_type::const_iterator const_iterator;
  tree_map_compare() : invalidate_guard_count(0) { }
  tree_map_compare(const tree_map_compare& x)
    : v(x.v), invalidate_guard_count(0) { }
  tree_map_compare& operator =(const tree_map_compare& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  Tm& operator [](const Tk& k) { return v[k]; }
  size_type size() const { return v.size(); }
  void erase(const Tk& k) {
    check_resize();
    v.erase(k);
  }
  void clear() {
    check_resize();
    v.clear();
  }
  iterator begin() { return v.begin(); }
  const_iterator begin() const { return v.begin(); }
  iterator end() { return v.end(); }
  const_iterator end() const { return v.end(); }
private:
  void check_resize() {
    if (invalidate_guard_count != 0) { pxcrt::throw_would_invalidate(); }
  }
  void inc_invalidate_guard() const { ++invalidate_guard_count; }
  void dec_invalidate_guard() const { --invalidate_guard_count; }
private:
  map_type v;
  mutable size_t invalidate_guard_count;
};
template <typename Tk, typename Tm, typename Tf>
struct tree_map_compare_range {
  template <typename Tc> friend struct pxcrt::refvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::refvar_igrd;
  template <typename Tc> friend struct pxcrt::valvar_igrd_nn;
  template <typename Tc> friend struct pxcrt::valvar_igrd;
  typedef std::map< Tk, Tm, compare_less<Tf> > map_type;
  typedef typename map_type::iterator iterator;
  typedef typename map_type::const_iterator const_iterator;
  tree_map_compare_range() : start(), finish() { }
  template <typename Ti> tree_map_compare_range(const Ti& st, const Ti& fi)
    : start(st), finish(fi) { }
private:
  void inc_invalidate_guard() const { }
  void dec_invalidate_guard() const { }
private:
  iterator start;
  iterator finish;
};
}; // namespace container

