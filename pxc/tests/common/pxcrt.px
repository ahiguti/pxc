
namespace pxcrt;

public multithreaded extern "pxcrt::vector" "varray" struct {t} vector {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type slice{t};
  public macro crange_type cslice{t};
  public extern "size" function size_t size() const;
  public extern "empty" function bool empty() const;
  public extern "resize" function void resize(size_t v);
  public extern "clear" function void clear();
  public extern "push_back" function void push(t v);
  public extern "pop_back" function t pop();
}

public multithreaded extern "pxcrt::farray" "farray" struct {t, n} farray {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type slice{t};
  public macro crange_type cslice{t};
  public extern "size" function size_t size() const;
}

public multithreaded extern "pxcrt::slice" "slice" struct {t} slice {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type slice{t};
  public macro crange_type cslice{t};
  public extern "size" function size_t size() const;
}

public multithreaded extern "pxcrt::cslice" "cslice" struct {t} cslice {
  public macro key_type size_t;
  public macro mapped_type t;
  public macro range_type cslice{t};
  public macro crange_type cslice{t};
  public extern "size" function size_t size() const;
}

public multithreaded extern "pxcrt::map" "map" struct {t,s} tree_map {
  public macro key_type t;
  public macro mapped_type t;
  public extern "size" function size_t size() const;
  public extern "empty" function bool empty() const;
  public extern "clear" function void clear();
}

public threaded extern "pxcrt::string_size"
  function size_t string_size(string s);
public threaded extern "pxcrt::string_empty"
  function bool string_empty(string s);
public threaded extern "pxcrt::string_resize"
  function void string_resize(string& s, size_t len);
public threaded extern "pxcrt::string_clear"
  function void string_clear(string& s);
public threaded extern "pxcrt::string_append"
  function void string_append(string& s, string v);
public threaded extern "pxcrt::string_prepend"
  function void string_prepend(string& s, string v);

public threaded extern "pxcrt::unit_to_string"
  function string unit_to_string(unit x);
public threaded extern "pxcrt::bool_to_string"
  function string bool_to_string(bool x);
public threaded extern "pxcrt::uchar_to_string"
  function string uchar_to_string(uchar x);
public threaded extern "pxcrt::char_to_string"
  function string char_to_string(char x);
public threaded extern "pxcrt::ushort_to_string"
  function string ushort_to_string(ushort x);
public threaded extern "pxcrt::short_to_string"
  function string short_to_string(short x);
public threaded extern "pxcrt::uint_to_string"
  function string uint_to_string(uint x);
public threaded extern "pxcrt::int_to_string"
  function string int_to_string(int x);
public threaded extern "pxcrt::ulong_to_string"
  function string ulong_to_string(ulong x);
public threaded extern "pxcrt::long_to_string"
  function string long_to_string(long x);
public threaded extern "pxcrt::size_t_to_string"
  function string size_t_to_string(size_t x);
public threaded extern "pxcrt::float_to_string"
  function string float_to_string(float x);
public threaded extern "pxcrt::double_to_string"
  function string double_to_string(double x);

public threaded extern "pxcrt::string_to_void"
  function void string_to_void(string x);
public threaded extern "pxcrt::string_to_unit"
  function unit string_to_unit(string x);
public threaded extern "pxcrt::string_to_bool"
  function bool string_to_bool(string x);
public threaded extern "pxcrt::string_to_uchar"
  function uchar string_to_ucahr(string x);
public threaded extern "pxcrt::string_to_char"
  function char string_to_char(string x);
public threaded extern "pxcrt::string_to_ushort"
  function ushort string_to_ushort(string x);
public threaded extern "pxcrt::string_to_short"
  function short string_to_short(string x);
public threaded extern "pxcrt::string_to_uint"
  function uint string_to_uint(string x);
public threaded extern "pxcrt::string_to_int"
  function int string_to_int(string x);
public threaded extern "pxcrt::string_to_ulong"
  function ulong string_to_ulong(string x);
public threaded extern "pxcrt::string_to_long"
  function long string_to_long(string x);
public threaded extern "pxcrt::string_to_size_t"
  function size_t string_to_size_t(string x);
public threaded extern "pxcrt::string_to_float"
  function float string_to_float(string x);
public threaded extern "pxcrt::string_to_double"
  function double string_to_double(string x);

public multithreaded extern "pxcrt::ref" "ref" struct {t} ref { } 
public multithreaded extern "pxcrt::cref" "cref" struct {t} cref { }
public multithreaded extern "pxcrt::tref" "tref" struct {t} tref { }
public multithreaded extern "pxcrt::tcref" "tcref" struct {t} tcref { }

public multithreaded extern "pxcrt::invalid_index" ""
  struct invalid_index { }
public multithreaded extern "pxcrt::invalid_field" ""
  struct invalid_field { }
public multithreaded extern "pxcrt::null_dereference" ""
  struct null_dereference { }
public multithreaded extern "pxcrt::would_invalidate" ""
  struct would_invalidate { }

extern "type" inline
#include <vector>
#include <string>
#include <map>
#include <stdint.h>
#include <stdexcept>
#include <stdio.h>
#include <pthread.h>
#include <assert.h>
#include <unistd.h>
#ifdef PXCRT_DBG_RC
#define DBG_RC(x) x
#else
#define DBG_RC(x)
#endif
#ifdef PXCRT_DBG_MTX
#define DBG_MTX(x) x
#else
#define DBG_MTX(x)
#endif
namespace pxcrt {
void throw_invalid_index() __attribute__((noreturn));
void throw_null_dereference() __attribute__((noreturn));
void throw_invalid_field() __attribute__((noreturn));
void throw_would_invalidate() __attribute__((noreturn));
void throw_virtual_function_call() __attribute__((noreturn));
int main_nothrow(void (*main_f)(void));
typedef std::string string;
struct tpdummy;
struct unit {
  unit() { }
  unit(int) { }
  bool operator ==(const unit&) { return true; }
  bool operator <(const unit&) { return false; }
};
template <typename T>
struct vector {
  template <typename Tc> friend struct refvar_igrd_nn;
  template <typename Tc> friend struct refvar_igrd;
  template <typename Tc> friend struct valvar_igrd_nn;
  template <typename Tc> friend struct valvar_igrd;
  typedef T data_type;
  typedef typename std::vector<T>::size_type size_type;
  typedef typename std::vector<T>::iterator iterator;
  typedef typename std::vector<T>::const_iterator const_iterator;
  vector() : invalidate_guard_count(0) { }
  vector(const vector& x) : v(x.v), invalidate_guard_count(0) { }
  vector& operator =(const vector& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  size_type size() const { return v.size(); }
  bool empty() const { return v.empty(); }
  T& operator [](size_type idx) {
    if (idx >= v.size()) { throw_invalid_index(); }
    return v[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= v.size()) { throw_invalid_index(); }
    return v[idx];
  }
  void resize(size_type sz) {
    check_resize();
    v.resize(sz);
  }
  void clear() {
    check_resize();
    v.clear();
  }
  void push_back(const T& x) {
    check_resize();
    v.push_back(x);
  }
  T pop_back() {
    check_resize();
    if (v.empty()) { throw_invalid_index(); }
    const T r = v.back();
    v.pop_back();
    return r;
  }
  iterator begin() { return v.begin(); }
  const_iterator begin() const { return v.begin(); }
  iterator end() { return v.end(); }
  const_iterator end() const { return v.end(); }
  T *rawarr() { return &v[0]; }
  const T *rawarr() const { return &v[0]; }
private:
  void check_resize() {
    if (invalidate_guard_count != 0) { throw_would_invalidate(); }
    // printf("chk cnt=%lu\n", invalidate_guard_count);
  }
  void inc_invalidate_guard() const {
    ++invalidate_guard_count;
    // printf("inc cnt=%lu\n", invalidate_guard_count);
  }
  void dec_invalidate_guard() const {
    --invalidate_guard_count;
    // printf("dec cnt=%lu\n", invalidate_guard_count);
  }
private:
  std::vector<T> v;
  mutable size_t invalidate_guard_count;
};
template <typename T, size_t len>
struct farray {
  typedef size_t size_type;
  farray() : v() { }
  size_type size() const { return len; }
  T& operator [](size_type idx) {
    if (idx >= len) { throw_invalid_index(); }
    return v[idx];
  }
  const T& operator [](size_type idx) const {
    if (idx >= len) { throw_invalid_index(); }
    return v[idx];
  }
  T *rawarr() { return v; }
  const T *rawarr() const { return v; }
private:
  T v[len];
};
template <typename Tk, typename Tm>
struct map {
  template <typename Tc> friend struct refvar_igrd_nn;
  template <typename Tc> friend struct refvar_igrd;
  template <typename Tc> friend struct valvar_igrd_nn;
  template <typename Tc> friend struct valvar_igrd;
  typedef Tm data_type;
  typedef typename std::map<Tk, Tm>::size_type size_type;
  typedef typename std::map<Tk, Tm>::iterator iterator;
  typedef typename std::map<Tk, Tm>::const_iterator const_iterator;
  map() : invalidate_guard_count(0) { }
  map(const map& x) : v(x.v), invalidate_guard_count(0) { }
  map& operator =(const map& x) {
    check_resize();
    v = x.v;
    return *this;
  }
  Tm& operator [](const Tk& k) { return v[k]; }
  size_type size() const { return v.size(); }
  void erase(const Tk& k) {
    check_resize();
    v.erase(k);
  }
  void clear() {
    check_resize();
    v.clear();
  }
  iterator begin() { return v.begin(); }
  const_iterator begin() const { return v.begin(); }
  iterator end() { return v.end(); }
  const_iterator end() const { return v.end(); }
private:
  void check_resize() {
    if (invalidate_guard_count != 0) { throw_would_invalidate(); }
  }
  void inc_invalidate_guard() const { ++invalidate_guard_count; }
  void dec_invalidate_guard() const { --invalidate_guard_count; }
private:
  std::map<Tk, Tm> v;
  mutable size_t invalidate_guard_count;
};
template <typename T>
struct slice {
  template <typename Tc> friend struct refvar_igrd_nn;
  template <typename Tc> friend struct refvar_igrd;
  template <typename Tc> friend struct valvar_igrd_nn;
  template <typename Tc> friend struct valvar_igrd;
  typedef size_t size_type;
  slice() : v(0), len(0) { }
  template <typename Tc> slice(Tc& c, size_t o1, size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  size_type size() const { return len; }
  T& operator [](size_type idx) const {
    if (idx >= len) { throw_invalid_index(); }
    return v[idx];
  }
  T *rawarr() const { return v; }
private:
  void inc_invalidate_guard() const { }
  void dec_invalidate_guard() const { }
private:
  T *v;
  size_t len;
};
template <typename T>
struct cslice {
  template <typename Tc> friend struct refvar_igrd_nn;
  template <typename Tc> friend struct refvar_igrd;
  template <typename Tc> friend struct valvar_igrd_nn;
  template <typename Tc> friend struct valvar_igrd;
  typedef size_t size_type;
  cslice() : v(0), len(0) { }
  cslice(const slice<T>& x) : v(x.rawarr()), len(x.size()){ }
  template <typename Tc> cslice(const Tc& c, size_t o1, size_t o2) {
    if (o2 > c.size()) { o2 = c.size(); }
    if (o1 > o2) { o1 = o2; }
    v = c.rawarr() + o1;
    len = o2 - o1;
  }
  size_type size() const { return len; }
  const T& operator [](size_type idx) const {
    if (idx >= len) { throw_invalid_index(); }
    return v[idx];
  }
  const T *rawarr() const { return v; }
private:
  void inc_invalidate_guard() const { }
  void dec_invalidate_guard() const { }
private:
  const T *v;
  size_t len;
};
template <typename Tc>
struct refvar_igrd_nn {
  refvar_igrd_nn(Tc& c) : c(c) {
    c.inc_invalidate_guard();
  }
  ~refvar_igrd_nn() {
    c.dec_invalidate_guard();
  }
  Tc& get() const {
    return c;
  }
private:
  Tc& c;
  refvar_igrd_nn(const refvar_igrd_nn&);
  refvar_igrd_nn& operator =(const refvar_igrd_nn&);
};
template <typename Tc>
struct refvar_igrd {
  refvar_igrd() : cp(0) { }
  refvar_igrd(Tc& c) : cp(&c) {
    c.inc_invalidate_guard();
  }
  ~refvar_igrd() {
    if (cp != 0) { cp->dec_invalidate_guard(); }
  }
  Tc& set(Tc& c) {
    if (cp != 0) { cp->dec_invalidate_guard(); }
    cp = &c;
    return c;
  }
  Tc& get() const {
    return *cp;
  }
private:
  Tc *cp;
  refvar_igrd(const refvar_igrd&);
  refvar_igrd& operator =(const refvar_igrd&);
};
template <typename Tc>
struct valvar_igrd_nn {
  valvar_igrd_nn(const Tc& x) : c(x) {
    c.inc_invalidate_guard();
  }
  ~valvar_igrd_nn() {
    c.dec_invalidate_guard();
  }
  Tc& get() const {
    return c;
  }
private:
  Tc c;
  valvar_igrd_nn(const valvar_igrd_nn&);
  valvar_igrd_nn& operator =(const valvar_igrd_nn&);
};
template <typename Tc>
struct valvar_igrd {
  valvar_igrd() : c() {
    c.inc_invalidate_guard();
  }
  valvar_igrd(const Tc& x) : c(x) {
    c.inc_invalidate_guard();
  }
  Tc& set(const Tc& x) {
    c = x;
    c.inc_invalidate_guard();
    return c;
  }
  Tc& get() const {
    return c;
  }
private:
  Tc c;
  valvar_igrd(const valvar_igrd&);
  valvar_igrd& operator =(const valvar_igrd&);
};
struct mutex {
  friend struct lockobject;
  mutex() {
    init();
  }
  mutex(const mutex&) {
    init();
  }
  mutex& operator =(const mutex&) {
    return *this;
  }
  ~mutex() {
    const int __attribute__((unused)) e = pthread_mutex_destroy(&mtx);
    assert(e == 0);
  }
  void lock() {
    DBG_MTX(fprintf(stderr, "lock %p\n", &mtx));
    const int __attribute__((unused)) e = pthread_mutex_lock(&mtx);
    assert(e == 0);
  }
  void unlock() {
    DBG_MTX(fprintf(stderr, "unlock %p\n", &mtx));
    const int __attribute__((unused)) e = pthread_mutex_unlock(&mtx);
    assert(e == 0);
  }
private:
  void init() {
    pthread_mutexattr_t mattr;
    pthread_mutexattr_init(&mattr);
    pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);
    const int e = pthread_mutex_init(&mtx, &mattr);
    pthread_mutexattr_destroy(&mattr);
    if (e != 0) {
      throw std::runtime_error("pthread_mutex_init"); // FIXME
    }
  }
private:
  pthread_mutex_t mtx;
};
struct lockobject {
  lockobject(mutex& x) : m(x) { m.lock(); }
  ~lockobject() { m.unlock(); }
private:
  mutex& m;
private:
  lockobject(lockobject&);
  lockobject& operator =(lockobject&);
};
struct boxing { };
template <typename T>
struct trcval {
  trcval() : count$z(1), value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit trcval(const T& v) : count$z(1), value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0>
  trcval(const T0& a0)
    : count$z(1), value$z(a0) { }
  template <typename T0, typename T1>
  trcval(const T0& a0, const T1& a1)
    : count$z(1), value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  trcval(const T0& a0, const T1& a1, const T2& a2)
    : count$z(1), value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    __sync_fetch_and_add(&count$z, 1); /* gcc >= 4 */
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (__sync_fetch_and_add(&count$z, -1) == 1) { /* gcc >= 4 */
      delete this;
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
  pxcrt::mutex& get_mutex$z() const { return mutex$z; }
private:
  mutable long count$z;
  mutable pxcrt::mutex mutex$z;
public:
  T value$z;
private:
  trcval(const trcval&);
  trcval& operator =(const trcval&);
};
template <typename T>
struct rcval {
  rcval() : count$z(1), value$z() {
    DBG_RC(fprintf(stdout, "c1 %p\n", this));
  }
  explicit rcval(const T& v) : count$z(1), value$z(v) {
    DBG_RC(fprintf(stdout, "c2 %p\n", this));
  }
  template <typename T0>
  rcval(const T0& a0)
    : count$z(1), value$z(a0) { }
  template <typename T0, typename T1>
  rcval(const T0& a0, const T1& a1)
    : count$z(1), value$z(a0, a1) { }
  template <typename T0, typename T1, typename T2>
  rcval(const T0& a0, const T1& a1, const T2& a2)
    : count$z(1), value$z(a0, a1, a2) { }
  void incref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld +1\n", this, count$z));
    ++count$z;
  }
  void decref$z() const {
    DBG_RC(fprintf(stdout, "%p %ld -1\n", this, count$z));
    if (--count$z == 0) {
      delete this;
      DBG_RC(fprintf(stdout, "d  %p\n", this));
    }
  }
private:
  mutable long count$z;
public:
  T value$z;
private:
  rcval(const rcval&);
  rcval& operator =(const rcval&);
};
template <typename T>
struct rcptr { /* T must have an intrusive count */
  typedef T *rawptr;
  template <typename Tx> friend struct rcptr;
  rcptr() : ptr(new T()) { }
  rcptr(const rcptr& x) : ptr(x.ptr) { if (ptr) ptr->incref$z(); }
  rcptr(T *x) : ptr(x) { if (ptr) ptr->incref$z(); }
  /* ref{foo} to ref{ifoo} */
  template <typename Tx> rcptr(const rcptr<Tx>& x) : ptr(x.get()) {
    if (ptr) ptr->incref$z();
  }
  /* boxing foo to ref{ifoo} */
  template <typename Tx> explicit rcptr(const Tx& x) : ptr(new T(x)) { }
  /* boxing */
  explicit rcptr(const boxing& c) : ptr(new T()) { }
  template <typename T0>
  rcptr(const boxing& c, const T0& a0)
    : ptr(new T(a0)) { }
  template <typename T0, typename T1>
  rcptr(const boxing& c, const T0& a0, const T1& a1)
    : ptr(new T(a0, a1)) { }
  template <typename T0, typename T1, typename T2>
  rcptr(const boxing& c, const T0& a0, const T1& a1, const T2& a2)
    : ptr(new T(a0, a1, a2)) { }
  ~rcptr() { if (ptr) ptr->decref$z(); }
  rcptr& operator =(T *x) { return set(x); }
  template <typename Tx> rcptr& operator =(Tx *x) { return set(x); }
  rcptr& operator =(const rcptr& x) { return set(x.ptr); }
  template <typename Tx> rcptr& operator =(const rcptr<Tx>& x) {
    return set(x.ptr);
  }
  operator T *() const { return ptr; }
  T *get() const { return ptr; }
  T& operator *() const { return *ptr; }
  T *operator ->() const { return ptr; }
private:
  T *ptr;
private:
  rcptr& set(T *x) {
    if (x) x->incref$z();
    if (ptr) ptr->decref$z();
    ptr = x;
    return *this;
  }
};
struct invalid_index : public std::logic_error { invalid_index(); };
struct invalid_field : public std::logic_error { invalid_field(); };
struct null_dereference : public std::logic_error { null_dereference(); };
struct would_invalidate : public std::logic_error { would_invalidate(); };
struct virtual_function_call : public std::logic_error
  { virtual_function_call(); };
}; // namespace pxcrt

extern "fdecl" inline
namespace pxcrt {
#if 0
template <typename T> inline void deref(T& ptr) // TODO: remove
{
  // if (ptr == 0) throw_null_dereference();
}
template <typename T> inline void deref(const T& ptr) // TODO: remove
{
  // if (ptr == 0) throw_null_dereference();
}
template <typename T> inline void deref(T *ptr) // TODO: remove
{
  // if (ptr == 0) throw_null_dereference();
}
template <typename T> inline void deref(const T *ptr) // TODO: remove
{
  // if (ptr == 0) throw_null_dereference();
}
#endif
string void_to_string(void);
string unit_to_string(unit v);
string bool_to_string(bool v);
string uchar_to_string(unsigned char v);
string char_to_string(char v);
string ushort_to_string(unsigned short v);
string short_to_string(short v);
string uint_to_string(unsigned int v);
string int_to_string(int v);
string ulong_to_string(unsigned long long v);
string long_to_string(long long v);
string size_t_to_string(size_t v);
string double_to_string(double v);
string float_to_string(float v);
void string_to_void(const string& v);
unit string_to_unit(const string& v);
bool string_to_bool(const string& v);
unsigned char string_to_uchar(const string& v);
char string_to_char(const string& v);
unsigned short string_to_ushort(const string& v);
short string_to_short(const string& v);
unsigned int string_to_uint(const string& v);
int string_to_int(const string& v);
unsigned long long string_to_ulong(const string& v);
long long string_to_long(const string& v);
size_t string_to_size_t(const string& v);
double string_to_double(const string& v);
float string_to_float(const string& v);
inline size_t string_size(const std::string& s)
  { return s.size(); }
inline bool string_empty(const std::string& s)
  { return s.empty(); }
inline void string_resize(std::string& s, unsigned long long len)
  { s.resize(len); }
inline void string_clear(std::string& s)
  { s.clear(); }
inline void string_append(std::string& s, const std::string& x)
  { s += x; }
inline void string_prepend(std::string& s, const std::string& x)
  { s.insert(s.begin(), x.begin(), x.end()); }
}; // namespace pxcrt

extern "fdef" inline
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
namespace pxcrt {
// vector<string> pxc_argv;
string void_to_string(void)
{
  return string();
}
string unit_to_string(unit x)
{
  return string();
}
string bool_to_string(bool v)
{
  static const string str_t("true");
  static const string str_f("false");
  return v ? str_t : str_f;
}
string uchar_to_string(unsigned char v)
{
  char buf[4];
  const int len = snprintf(buf, sizeof(buf), "%hhu", v);
  return string(buf, buf + len);
}
string char_to_string(char v)
{
  char buf[4];
  const int len = snprintf(buf, sizeof(buf), "%hhd", v);
  return string(buf, buf + len);
}
string ushort_to_string(unsigned short v)
{
  char buf[8];
  const int len = snprintf(buf, sizeof(buf), "%hu", v);
  return string(buf, buf + len);
}
string short_to_string(short v)
{
  char buf[8];
  const int len = snprintf(buf, sizeof(buf), "%hd", v);
  return string(buf, buf + len);
}
string uint_to_string(unsigned int v)
{
  char buf[16];
  const int len = snprintf(buf, sizeof(buf), "%u", v);
  return string(buf, buf + len);
}
string int_to_string(int v)
{
  char buf[16];
  const int len = snprintf(buf, sizeof(buf), "%d", v);
  return string(buf, buf + len);
}
string ulong_to_string(unsigned long long v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%llu", v);
  return string(buf, buf + len);
}
string long_to_string(long long v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%lld", v);
  return string(buf, buf + len);
}
string size_t_to_string(size_t v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%zu", v);
  return string(buf, buf + len);
}
string double_to_string(double v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%f", v);
  return string(buf, buf + len);
}
string float_to_string(float v)
{
  char buf[32];
  const int len = snprintf(buf, sizeof(buf), "%f", double(v));
  return string(buf, buf + len);
}
void string_to_void(const string& v)
{
}
unit string_to_unit(const string& v)
{
  return unit();
}
bool string_to_bool(const string& v)
{
  const string::size_type len = v.size();
  if (len == 4 && memcmp(v.data(), "true", 4) == 0) {
    return true;
  }
  if (len == 5 && memcmp(v.data(), "false", 5) == 0) {
    return false;
  }
  if (len == 1 && v.data()[0] == '0') {
    return false;
  }
  return true;
}
unsigned char string_to_uchar(const string& v)
{
  return strtoul(v.c_str(), 0, 10);
}
char string_to_char(const string& v)
{
  return strtol(v.c_str(), 0, 10);
}
unsigned short string_to_ushort(const string& v)
{
  return strtoul(v.c_str(), 0, 10);
}
short string_to_short(const string& v)
{
  return strtol(v.c_str(), 0, 10);
}
unsigned int string_to_uint(const string& v)
{
  return strtoul(v.c_str(), 0, 10);
}
int string_to_int(const string& v)
{
  return strtol(v.c_str(), 0, 10);
}
unsigned long long string_to_ulong(const string& v)
{
  return strtoull(v.c_str(), 0, 10);
}
long long string_to_long(const string& v)
{
  return strtoll(v.c_str(), 0, 10);
}
size_t string_to_size_t(const string& v)
{
  return strtoull(v.c_str(), 0, 10);
}
double string_to_double(const string& v)
{
  return atof(v.c_str());
}
float string_to_float(const string& v)
{
  return atof(v.c_str());
}
invalid_index::invalid_index() : std::logic_error("invalid_index") { }
invalid_field::invalid_field() : std::logic_error("invalid_field") { }
null_dereference::null_dereference() : std::logic_error("null_dereference") { }
would_invalidate::would_invalidate() : std::logic_error("would_invalidate") { }
virtual_function_call::virtual_function_call()
  : std::logic_error("virtual_function_call") { }
void throw_invalid_index() { throw invalid_index(); }
void throw_invalid_field() { throw invalid_field(); }
void throw_null_dereference() { throw null_dereference(); }
void throw_would_invalidate() { throw would_invalidate(); }
void throw_virtual_function_call() { throw virtual_function_call(); }
int main_nothrow(void (*main_f)(void))
{
  try {
    (*main_f)();
  } catch (const std::exception& e) {
    std::string mess(e.what());
    if (!mess.empty() && mess[mess.size() - 1] != '\n') {
      mess += "\n";
    }
    ::write(2, mess.data(), mess.size());
    return 1;
  } catch (...) {
    const std::string mess = "unknown exception\n";
    ::write(2, mess.data(), mess.size());
    return 1;
  }
  return 0;
}
}; // namespace pxcrt

