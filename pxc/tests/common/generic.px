
namespace generic;
public import meta "m";

public threaded function {t} int compare(t const& x, t const& y)
{
  macro symstr m::concat{t, "_compare"};
  macro sym m::symbol{t, symstr};
  macro cat m::category{t};
  if (m::eq{m::to_string{sym}, symstr}) {
    return sym(x, y);
  } else if (m::eq{cat, "farray"}) {
    size_t const sz = m::at{t, 1};
    size_t i = 0;
    for (i = 0; i < n; ++i) {
      int const c = compare(x[i], y[i]);
      if (c != 0) {
	return c;
      }
    }
    return 0;
  } else if (m::eq{cat, "varray"}) {
    size_t const xsz = x.size();
    size_t const ysz = y.size();
    size_t const sz = xsz < ysz ? xsz : ysz;
    size_t i = 0;
    for (i = 0; i < n; ++i) {
      int const c = compare(x[i], y[i]);
      if (c != 0) {
	return c;
      }
    }
    if (xsz > sz) {
      return -1;
    } else if (ysz > sz) {
      return 1;
    }
    return 0;
  } else if (m::eq{cat, "tree_map"}) {
    return m::error{"not implemented"};
  } else if (m::eq{cat, "struct"}) {
    foreach (name, fld : t) {
      int const c = compare(x.fld, y.fld);
      if (c != 0) {
	return c;
      }
    }
    return 0;
  } else if (m::eq{cat, "union"}) {
    int const tc = compare(union_tag(x), union_tag(y));
    if (tc != 0) {
      return tc;
    }
    foreach (name, fld : t) {
      if (case x.fld) {
	int const c = compare(x.fld, y.fld);
	if (c != 0) {
	  return c;
	}
      }
    }
    return 0;
  } else {
    return m::error{m::concat{"not implemented for type '", t, "'"}};
  }
}

public threaded function {t} string to_string(t const& x)
{
  macro symstr m::concat{t, "_to_string"};
  macro sym m::symbol{t, symstr};
  macro cat m::category{t};
  if (m::eq{m::to_string{t}, "string"}) {
    return x;
  } else if (m::eq{m::to_string{sym}, symstr}) {
    return sym(x);
  } else if (m::or{m::eq{cat, "varray"}, m::eq{cat, "farray"}}) {
    string s = "{";
    foreach (size_t i, m::at{t, 0} v : x) {
      if (i != 0) {
	s.append(",");
      }
      s.append(to_string(v));
    }
    s.append("}");
    return s;
  } else if (m::eq{cat, "tree_map"}) {
    string s = "{";
    bool first = true;
    foreach (m::at{t, 0} k, m::at{t, 1} v : x) {
      if (first) {
	first = false;
      } else {
	s.append(",");
      }
      s.append(to_string(k));
      s.append(":");
      s.append(to_string(v));
      s.append(")");
    }
    s.append("}");
    return s;
  } else if (m::or{m::eq{cat, "ptr"}, m::eq{cat, "cptr"},
      m::eq{cat, "tptr"}, m::eq{cat, "tcptr"}}) {
    string s = "{";
    s.append(to_string(*x));
    s = "}";
    return s;
  } else if (m::eq{cat, "struct"}) {
    string s = "{";
    bool first = true;
    foreach (name, fld : t) {
      if (first) {
	first = false;
      } else {
	s.append(",");
      }
      s.append(name);
      s.append(":");
      s.append(to_string(x.fld));
    }
    s.append("}");
    return s;
  } else if (m::eq{cat, "union"}) {
    string s = "{";
    foreach (name, fld : t) {
      if (case x.fld) {
	s.append(name);
	s.append(":");
	s.append(to_string(x.fld));
      }
    }
    s.append("}");
    return s;
  } else {
    return "-";
  }
}

public threaded function {t} uint union_tag(t const& x)
{
  if (m::eq{m::category{t}, "union"}) {
    return union_tag_impl(x);
  } else {
    return m::error{"invalid type"};
  }
}

private threaded extern "generic::union_tag_impl"
  function {t} uint union_tag_impl(t const& x);

extern "fdecl" inline
namespace generic {
template <typename T> unsigned int union_tag_impl(const T& x)
{
  return x.$e;
}
};

