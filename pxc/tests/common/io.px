
namespace io;

public import meta;
public import type::builtin "";
public import type::container;

public extern "pxcio::pxc_argv" type::container::vector{string} argv;
public extern "pxcio::mainio" ioptr main;

public macro ioptr tptr{io};
public macro fileptr ptr{file};

public tsvaluetype extern "pxcio::off_t" "uint" struct off_t { }

public multithreaded extern "pxcio::statbuf" struct statbuf {
  ulong st_dev;
  ulong st_ino;
  ulong st_mode;
  ulong st_nlink;
  ulong st_uid;
  ulong st_gid;
  ulong st_rdev;
  ulong st_size;
  ulong st_blksize;
  ulong st_blocks;
  ulong st_atime;
  ulong st_mtime;
  ulong st_ctime;
}

public extern "O_RDONLY"	int O_RDONLY;
public extern "O_WRONLY"	int O_WRONLY;
public extern "O_RDWR"		int O_RDWR;
public extern "O_CREAT"		int O_CREAT;
public extern "O_EXCL"		int O_EXCL;
public extern "O_TRUNC"		int O_TRUNC;
public extern "O_APPEND"	int O_APPEND;
public extern "O_NONBLOCK"	int O_NONBLOCK;
public extern "O_SYNC"		int O_SYNC;
public extern "O_FSYNC"		int O_FSYNC;
public extern "O_ASYNC"		int O_ASYNC;

public extern "SEEK_SET"	int SEEK_SET;
public extern "SEEK_CUR"	int SEEK_CUR;
public extern "SEEK_END"	int SEEK_END;

public threaded extern "pxcio::io_open"
  function fileptr io_open(ioptr const& i, string const& fn, int flags,
    int mode);
public threaded extern "pxcio::file_read"
  function size_t file_read(fileptr const& f, string& buf, size_t len);
public threaded extern "pxcio::file_write"
  function size_t file_write(fileptr const& f, string const& buf);
public threaded extern "pxcio::file_lseek"
  function off_t file_lseek(fileptr const& f, off_t offset, int whence);
public threaded extern "pxcio::file_errno"
  function int file_errno(fileptr const& f);
public threaded extern "pxcio::io_stat"
  function int io_stat(ioptr const& i, string const& fn, statbuf& buf);
public threaded extern "pxcio::io_errno"
  function int io_errno(ioptr const& i);
public threaded extern "pxcio::io_sleep"
  function uint io_sleep(ioptr const& i, uint sec);

public threaded function fileptr io_open_r(ioptr const& i, string const& fn)
  { return io_open(i, fn, O_RDONLY, 0); }
public threaded function fileptr io_creat(ioptr const& i, string const& fn)
  { return io_open(i, fn, O_WRONLY | O_CREAT | O_TRUNC, 0); }
public threaded function fileptr io_open_w(ioptr const& i, string const& fn)
  { return io_open(i, fn, O_WRONLY, 0); }
public threaded function fileptr io_open_a(ioptr const& i, string const& fn)
  { return io_open(i, fn, O_WRONLY | O_APPEND, 0); }
public threaded function int file_read_all(fileptr const& f, string& buf) {
  while (true) {
    size_t r = file_read(f, buf, 16384);
    if (r == 0) {
      return file_errno(f);
    }
  }
  return 0;
}
public threaded function int io_read_file(ioptr const& i, string const& fn,
  string& buf) {
  fileptr f = io_open_r(i, fn);
  if (file_errno(f) != 0) { return file_errno(f); }
  return file_read_all(f, buf);
}
public threaded function int io_write_file(ioptr const& i, string const& fn,
  string const& buf) {
  fileptr f = io_open_w(i, fn);
  if (file_errno(f) != 0) { return file_errno(f); }
  return file_write(f, buf);
}

public threaded function {t} void io_stdout_print(ioptr const& i, t const& x)
{
  if (meta::eq{t, type::builtin::string}) {
    io_stdout_print_string(i, x);
  } else {
    io_stdout_print_string(i,
      meta::symbol{t, meta::concat{t, "_to_string"}}(x));
  }
}

public threaded function {t} void io_stdout_println(ioptr const& i, t const& x)
{
  if (meta::eq{t, type::builtin::string}) {
    string s = x;
    s.append("\n");
    io_stdout_print_string(i, s);
  } else {
    string s = meta::symbol{t, meta::concat{t, "_to_string"}}(x);
    s.append("\n");
    io_stdout_print_string(i, s);
  }
}

public function {t} void print(t const& x)
{
  io_stdout_print(main, x);
}

public function {t} void println(t const& x)
{
  io_stdout_println(main, x);
}

public multithreaded extern "pxcio::io_impl" "linear" struct io { }
public multithreaded extern "pxcio::file_impl" "linear" struct file { }

private threaded extern "pxcio::io_initialize"
  function int io_initialize(ioptr const& i);
private threaded extern "pxcio::io_stdout_print_string"
  function void io_stdout_print_string(ioptr const& i, string const& x);

io_initialize(main);

extern "type" inline
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
namespace pxcio {
typedef struct ::stat statbuf;
typedef ::off_t off_t;
struct io_impl {
  io_impl() { }
private:
  io_impl(const io_impl&);
  io_impl& operator =(const io_impl&);
};
struct file_impl {
  file_impl() : fd(-1), err(0) { }
  ~file_impl() { if (fd >= 0) close(fd); }
  int fd;
  int err;
private:
  file_impl(const file_impl&);
  file_impl& operator =(const file_impl&);
};
typedef pxcrt::rcptr< pxcrt::trcval<io_impl> > io_ptr;
typedef pxcrt::rcptr< pxcrt::rcval<file_impl> > file_ptr;
};

extern "fdecl" inline
namespace pxcio {
extern container::vector<pxcrt::bt_string> pxc_argv;
extern io_ptr mainio;
};

extern "fdef" inline
namespace pxcio {
#include <stdlib.h>
#include <limits.h>
container::vector<pxcrt::bt_string> pxc_argv;
io_ptr mainio;
file_ptr io_open(io_ptr const& i, pxcrt::bt_string const& fn,
  pxcrt::bt_int flags, pxcrt::bt_int md)
{
  file_ptr f(new file_ptr::value_type());
  file_impl& fref = f->value$z;
  fref.fd = ::open(fn.c_str(), flags, md);
  fref.err = (fref.fd < 0 ? errno : 0);
  return f;
}
off_t file_lseek(file_ptr const& f, off_t offset, pxcrt::bt_int whence)
{
  file_impl& fref = f->value$z;
  if (fref.err != 0) {
    return 0;
  }
  const off_t r = ::lseek(fref.fd, offset, whence);
  fref.err = (r == (off_t)-1) ? errno : 0;
  return r;
}
pxcrt::size_type file_read(file_ptr const& f, pxcrt::bt_string& buf,
  pxcrt::size_type len)
{
  file_impl& fref = f->value$z;
  if (fref.err != 0 || len < 0) {
    return 0;
  }
  if (len > SSIZE_MAX) {
    len = SSIZE_MAX;
  }
  const size_t oldsz = buf.size();
  const size_t newsz = oldsz + len;
  if (newsz < oldsz) {
    throw std::bad_alloc();
  }
  buf.resize(oldsz + len);
  char *const ptr = &buf[oldsz];
  const ssize_t rlen = ::read(fref.fd, ptr, len);
  if (rlen >= 0) {
    buf.resize(oldsz + (rlen >= 0 ? rlen : 0));
    return rlen;
  } else {
    buf.resize(oldsz);
    fref.err = errno;
    return 0;
  }
}
size_t file_write(file_ptr const& f, pxcrt::bt_string const& buf)
{
  file_impl& fref = f->value$z;
  if (fref.err != 0) {
    return 0;
  }
  size_t sz = buf.size();
  if (sz > SSIZE_MAX) {
    sz = SSIZE_MAX;
  }
  const char *const ptr = &buf[0];
  const ssize_t wlen = ::write(fref.fd, ptr, sz);
  fref.err = (wlen >= 0 ? 0 : errno);
  return wlen;
}
pxcrt::bt_int io_stat(io_ptr const& i, pxcrt::bt_string const& fn,
  pxcio::statbuf& buf)
{
  return ::stat(fn.c_str(), &buf);
}
pxcrt::bt_int file_errno(file_ptr const& f)
{
  return f->value$z.err;
}
pxcrt::bt_int io_errno(io_ptr const& i)
{
  return errno;
}
pxcrt::bt_uint io_sleep(io_ptr const& i, pxcrt::bt_uint sec)
{
  return sleep(sec);
}
void io_stdout_print_string(io_ptr const& i, pxcrt::bt_string const& x)
{
  fwrite(x.data(), x.size(), 1, stdout);
}
pxcrt::bt_int io_initialize(io_ptr const& i)
{
  static int init_flag = 0;
  if (!init_flag) {
    init_flag = 1;
  }
  char buf[64];
  int c = 0;
  while (true) {
    snprintf(buf, sizeof(buf), "PXC_ARG%d", c++);
    const char *ent = getenv(buf);
    if (ent == 0) {
      break;
    }
    const pxcrt::bt_string s(ent);
    pxc_argv.push_back(s);
  }
  return 0;
}
};

