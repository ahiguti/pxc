
0202 463
---------------------------------------------------------------------
FIXME/TODO M1

- invalidate guardとmutex lockを共通化

- split point分割はもはや不要では？
  - 文頭しか変数定義できないようにしたので

- condition variableのwaitをどのような文法で実現するか
  - waitする際にはmutexをlock済みでなければならない

- socket_factory整理
- setsockopt
- signal SIGHUP

- union の初期化を一発でできる構文を用意

- object counter

- structのコンストラクタがexternのとき、引数がnoncopyableであっても
  pxcエラーチェックできずC++エラーになってしまう。引数がcopyableであ
  ることを要請する手段が必要。(ただしptr{file}のようにfast boxingで
  きるときはnoncopyableでもよいことに注意)
  -> struct等にmacro __check__が定義されていればevalする
  -> ポインタについては引数型はcopyableでなくてよい
  -> それ以外のテンプレ型についてはcopyableを要請
  -> farray, darrayはdefconも要請
  
- pxcvectorにstringと同じだけのメソッド定義

- enum, bitmaskのコンパイル時リフレクション
- external int/uintを整数リテラルからコンストラクトできない
- 算術演算子は左右どちらへも変換できるように


ephemeral型まわり
- test: globalやstructには参照変数などは置けないように
- test: 構造体にslice等のephemeral型を含む型のfieldを置けないように

- structコンストラクタに対するcheck_return_expr()

- too many argument for ... を共通化

---------------------------------------------------------------------
FIXME/TODO M2

- darrayのalloca使った実装

- C++名前空間をすべて絶対参照で

- expr.cppで組み込み型にtype::builtinをセットしているのをやめて、
  serializeなどではtype::builtinではない名前空間を使うようにする

実装が不明確なところ
- threadまわりの仕様再整理せよ
- 演算子の一通りテスト作成。コンテナ含め。
- type categoryの仕様文書化
- 決定済みの仕様をメモに蓄積、テストケースと関連付け。
- 全ポインタ型とinterfaceの組み合わせ(モニタ等埋め込みが正しいか)確認

---------------------------------------------------------------------
TEST TODO M3

- test_14_root/refvar.px
- test_14_root/condtemp.px refvarが無いエラーになるように
- std::vector<bool>を使ってしまうと要素への参照が取れない

---------------------------------------------------------------------
TEST TODO M4

- tpupを引数で参照渡しするときのconstnessが正しいコードを吐いているか
- fn_check_rootテスト
- check_return_exprテスト
- テスト: fn_check_root廃止、rootはchecktypeの中で。
- ユーザ定義constructorを持つ型のdefault constructible判定が正しいか
- 型のパラメータにclosureやメソッドを使うと正しくエラーになるか？
- 型パラメータの文字列と数値がescapeされているか確認

---------------------------------------------------------------------
FIXME/TODO M5

- gcc-4.4.4のバグ？ -Wswitch-enumが効いていない しばらくgcc34を使う
- cflagsの与え方など確定
- interfaceの配列のように、テンプレパラメータが具体型でないといけない
  ケースのチェック。特にC++テンプレ型(固定長配列)。
- 文字列リテラルのテスト

---------------------------------------------------------------------
FIXME/TODO M6

- private namespace. 親namespaceからのみシンボルが参照できる.
- multimap, set, multiset, list
- foreach: multimap, set, multiset, list
- 例外の整理とstacktrace
- 構造体や配列の初期化式

---------------------------------------------------------------------
TODO

- 可変長引数の代わりとなる演算子を決めよ。 cout << ... のようなもの。
- 配列範囲チェックを非デバッグ時等に無効化するプラグマ?
- intの範囲を超えるenum/bitmask
- 構造体の中でenumを定義できるようにする？
- enumのint値を省略できるように
- enum int値に型式を書けるように
- enumがエラーメッセージではintとして見えてしまう
- mutexのlock保持スレッドを記録する実装
- 演算子を総称関数に自動で置き換え、ユーザが演算子定義できるように
- block-scope lock is not implemented これを出す条件は何?
- multithreaded structのコンストラクタ引数はmultithreaded型でなくても
  よい?
- import元を制限する構文(実装を隠すのに便利)
- check_overflow pragma? 実行時にオーバーフローを検出
- if (int v : foo.fld) { ... } // unionのフィールドは左辺値取れない
- C++が定義する関数については宣言だけはemitする(誤った宣言で問題を起
  こさないようにするため) -> 非template関数については実装済み。
  template関数と型がexternな場合については未実装
- public extern "@0void" "@0void" struct void { } こういうの無くす?
- realloc-safeかどうかpxcで判断し、それに応じて使うコンテナ実装を
  切り替える?
- foreach 参照渡し、constの組み合わせをすべてサポート?
  - keyは常にconst値or参照、mappedはconstまたはmutable参照でよいのでは？
  - keyがconst値であるかconst参照であるかは、意味的に差が起き得ない？
- fork()したときにファイルデスクリプタをどうするか？
- blockscopeのlockobject - 19/blkscope_lock.px
- evalのエラーメッセージ改善
- list, set
- tptr/tcptrのロックをreader/writerロックに。そのためにはguard count
  をatomicにしなければならないのでやめたほうがよい？ immutable ptrも
  同じようにguard countを考慮必要。
- add_root_requirement_container_elementsのexpr_has_lvalue止め?
- 代入演算子は値を返さないようにすると少し速くできる
- ptrをconst byvalで渡すときは生ポインタで受ける?
- テンプレート引数にtrueが使えない？
- inline_cに色々装飾付けられるが、エラー
- arr.resize()のように参照引数が一個だけでthreadedならinvguardしなく
  てよい。
- 定義前参照の可能性を解消
- 情報をロスするような自動変換は止める
- pure関数ならrootを省略できるケース
- multi-indexコンテナ
- 条件変数を構造体に埋め込めるようにする？普通にfieldとしてユーザが
  定義できるようにする？
- interface名と同名のmethodを定義すると変になる？
- メタ関数の評価が超遅いのは改善する？
- call traitがrawptrの型を作れるようにする? perlsvをそれにするべし
- 配列のスライスを参照渡しできるように。文字列のsubstr。
- call traitがbyvalueの型を作れるようにする?
- constnessがポインタの指す先にも伝播するようにする?
  (mtsafeの扱いとあわせて検討)
- type safe bitmask
- type safe enum
- infoファイルのescape
- getenv("HOME")だとsudoしたときに困らないか
- block_id_nsは何に使うのか整理(動的にblockを作成してはならない理由)
- コンテナforeachの中でcontinueやbreakを使えるように
- const変数宣言
- union fieldのrootをvectorと同様にするか？
- ifdef?
- namespace宣言が正しいかチェック?
- 実行形式を生成してexecするようにする？
- 複数ファイルコンパイル
- coptionsのオプション取得にpkg-config的なものをサポート
- pure(static?), synchronized
- volatile?
- constnessがptr先にも影響するように?
- boxing時の無駄なコピーを無くす
- struct定義時に実装するinterfaceを明示しなくてよいようにできるか？
  (implements宣言を分離。)
- いつterm_tostr_instance_chain()を必要とするのか確認
- interface型の一時変数を禁止(そもそもできない？)
- namespace義務付け？
- コンパイル全段階でatomicな更新を
- 無名関数はテンプレート引数を持てない？
- null値を持てないなptrとcptr
- macroの右辺をte以外の式も許可
- aliasを展開後の式をコンパイル(って何？)
- expr以外のterm、intなどをtermへ
- 配列とmapのイテレート方法を考えよ
- operator []をユーザ定義できるようにするには？
- リテラルnull、複合型リテラル
- const変数(varは変更可能だがconstは不可)
- extern関数へのpointer渡し、const pointer渡し
- extern enum
- switch
- 定数
- 参照カウントデバッグ
- リフレクションと文字列変換
- stringbuffer(文字列を引数として渡すときはstring_refとcstrに)
- string実装を複数(参照カウントしない版など)
- unstableな値を返す関数(substringのように)
- コンパイル整合性チェック(全モジュールmd5)
- posixモジュール
- 文字列との暗黙変換やめる
- interface間の継承
- this
- ネストされたテンプレートは必要？
- テンプレート引数に数値などを使えるように
- instance化はconstness関係なしにおこなわれるが問題ないのか？
- nonnullな参照型
- テンプレート型の間のinherit(is_sub_type)
- 関数型の変数を定義できないように？
- import pxcrtするとエラー
- マクロ 
- namespaceの継承？
- 上位シンボルとの衝突チェック?おきない？
- variantテスト
- variantのstabilizeテスト
- interfaceのcloneは用意すべき？
- mt safeにするために必要なものを整理
- variantのfieldが全部unitのときはenumを生成したほうが性能良い
- namespace宣言義務付け?
- downcast
- pure関数
- 引数渡しの際のstableでない値をstable化(テスト)
- リンカオプション指定
- perl sv/av/hv
- perl exception
- restricted pointer (raw reference)
- string optimization
- ユーザ定義コンストラクタのより良いコード生成(C++フィールド初期化)
- perl module

---------------------------------------------------------------------
ARGUABLE

- 数値型の変換チェック numeric_convertible
  - 現在の実装は浮動小数点数がieee754, 整数が2の補数であることを
    仮定している
interfaceまわり
- interfaceの仮想関数の引数型は先に定義しなくていいのか？
- test_03/interf_constr3_1_fixme.px1
- 型定義順依存を調べるために再帰的型を定義するテストを作る
- std::mapで foo["abc"] = "xyz" するとmudflapが怒る
- unionがunitだけでできていたときmudflapが怒る(バージョン？)
  (STLのバグ？)
- 仕様決め: catch は常にconst byref?

---------------------------------------------------------------------
DONE

- type familyに改名(done)
- struct foo { function {t} void bar() { ... } } がtest_symbols通らない
  (done)
- fldfe: フィールドの型を取れるように(done)
- fileのfdはimmutableにする。そうでないとaccept()でロックが要る(done)
- injectns使うと分割コンパイルで不整合がおきうる。無効化する。(done)
- generate_exe(done)
- weak pointerと区別するためにslice等はweak型と呼ばずにephemeral型と
  よぶ(done)
- to_stringは文字列へ追加する形へ(done)
- extern enumを型パラメータにしたときのエンコードがintになってしまう
  と衝突するのでダメ(done)
- io::fileはerrno_t参照を引数にとる(done)
- error{errno_t}(done)
- 16進、8進、文字リテラル(done)
- line_fixme.px1: upvalueを取れていない(done)
- privateメンバ、コンストラクタ。抽象データ型は作れるように(done)
- slice(done)
- boxing自動変換を廃止(done)
- namespace義務付け(done)
- pimplイディオムが使えることを確認(done)
- operatorと組み込み関数について整理。大小比較は全型に？(done)
- linear型の変数を宣言できないようになっているか(done)
- enum/bitmask型(done)
- 整数の暗黙変換を安全なものだけに制限(done)
- threadedではない型の変数をglobalに定義できないように(グローバル変数
  が初期化される前にそれをアクセスしてしまえないようにするため)(done)
- ユーザ定義コンストラクタ内に書ける文についての制限を決め(done)
- defconでない型(linear?)を引数無しで呼んだらエラーにせよ(done)
- ユーザ定義コンストラクタのemitを関数プロトタイプ群の後にしないと
  未定義関数を呼ぶことになる(done)
- is_copyableとis_assignableは構造体のフィールドにも制限を受ける(done)
- コンテナにnoncopyableな型は使えないように(done)
- pxcvectorとtree_mapのsliceからコンストラクタ(done)
- pxcvectorのappend(done)
- noncopyable/linearを引数付きコンストラクタで構築する方法(done)
- extern structにユーザ定義コンストラクタ(done)
- iptr/tiptr実装できている？(done)
- namespace宣言義務付け(done)
- foo{bar}: fooがtsvaluetypeでbarがthreadedな「関数」だった場合この型式
  は何装飾？ -> tsvaluetypeのまま。get_term_threading_attribute() は
  そのようになっているように見える。(done)
- global変数はthreadedな型を持たねばならない。初期化順序の問題が起きない
  ように。expr_var::check_typeの中のif 0を有効化せよ。(done)
- 短絡boxingを再び有効に(done)
- externならephemeral又はrefを返すメンバ関数を許可、thisをrootする(done)
- ephemeral型を初期化以外の代入の左辺にできないように(done)
- pxcvectorなどのインラインメンバ関数は"type"ではなく"fdecl"に移さ
  ないと型定義順依存がおきる -> ない。メンバ関数ごとにインスタンス
  化される(done)
- darrayは代入不可(done)
- threadedなclosureがupvalueとして非threadedな型を使えてしまわないか
  -> test_31_thrattr/up*.px (done)
- closureのthread属性？ -> test_31_thrattr/up*.px (done)
- guard countがmtsafeでないのはどうするか -> valuetypeとtsvaluetype
  (done)
- iptr, valuetype (done)
- コンストラクタからメンバ関数を呼べてしまうのをエラーにせよ(done)
- tsvaluetype darray実装(done)
- if (int const& x : foo[k]) { ... } のif-defined構文(done)
- int_compareなどの比較関数を無くし、基本型は > で比較するように(done)
- global変数にephemeral型は使えないようにせよ(11/fe_sli.px mudflap)(done)
- interfaceなどのようにcopyableではないものをコピーしたときのエラー(done)
- byrefであればintrface型もvarとtempvarに許容(done)
- string以外のコンテナにもappend(done)
- pxcのcharはc++のcharではなくint8_t(done)
- stringをcharではなくuchar(done)
- sliceからコンテナへ変換(done)
- foreachの中ではoperator []の範囲チェック不要 (done)
- コンストラクタへの引数がメンバ関数から見えてしまわないか？
  07/strarg.px (done)
- expr_feach::emit(): map, rangeに対するemit (done)
- pxcrt を compiler::runtimeへ (done)
- c++名前空間を::始まりで指定しないと途中の名前空間にマッチしてしまう
  (done)
- if (!x) がsyntax error (done)
- 25/val.px 関数の返値をblockscope rootしていない (done)
- farrayからsliceへの暗黙変換するとエラー(done)
- size_tを組み込みから外す(done)
- デフォルト名前空間からint等の基本型を消す(done)
- マクロ展開後の数値は何型？ long型。test_02_type/tmplint.px (done)
- eval.cppの sym_ns = "builtin" 削除 (done)
- symbol_table.cppの pname = "builtin::" + fullname 削除 (done)
- 組み込み型は名前空間"type::builtin"に属するように(done)
- test_16_perl/perl/symbols.pxでvoidを除外しないと動かないのを直す
  (done)
- 非メンバ関数にconst装飾つけるとエラーにならない(done)
- interface型を値で持てないように(done)
- interfaceへの代入はエラーにする(done)
- ptr{foo} = ptr(foo(...))で型推論してくれないのを直せ(done)
- ptr{ifoo}(foo(...))のようにインタフェースへのポインタを構築しようと
  するとエラーにせよ(done)
- require_lvalue廃止(done)
- variant fieldへの代入はset関数呼び出しに置き換える(done)
- rangeに対するoperator * (done)
- add_root_requirementのcheckonly廃止(done)
- 関数でないものでもoperator ()を適用できてしまう(done)
- test_01_px/i1_fixme : 仮想関数の実装を後ろに回さないといけないが、
  そもそも、ptrの指し先アロケートを廃止して仮想関数のダミー実装を必要
  なくすようにするべし(done)
- variantの最初のフィールドにはptrを置けないように(done)
- ポインタをdefault_constructibleではなくす。(done)
  ただしグローバル変数と構造体メンバについてはnull初期化せざるをえない
- c++実装のデフォルトコンストラクタをnull初期化するように(done)
- forやifでの定義初期化分離をなくす(done)
- foo(int x = bar())
  これをemitするのにbar()呼び出しを2回おこなっている
  int x = bar()を独立させたので参照時には単に「x」とするべし
  (test_23_emit/cmplx.px) (done)
- int x = ...の式をさらにtempvar作っているのは無駄 (done)
- 引数のpassby_e_unspecified(call trait)をやめる(done)
- コンテナからrangeへの自動変換(done)
- mutable&渡しの際にinterfaceへのupcastがあったらエラーになる問題(done)
- sliceの要素がlvalueを要してもslice自体はlvalueいらず、sliceかcslice
  であるかによってlvalueを持つかが決まる(check_lvalueの修正)(done)
  - add_root_requirementの'[]'についても同様の修正必要(FIXME印を見よ)
- add_root_requirement()するケースの整理、複数要求がある場合の処理。(done)
- 自動変換が入ったら左辺値を取れないように?(check_lvalue)(done)
- if文がboolでなかった場合のエラーメッセージに行番号が出ない？(done)
- variantのtagからintへの変換(done)
- test_22_error/tparam.px (done)
- 引数のconst/mutable参照渡し/値渡し明示。(done)
- integralやpointer downcast以外の自動変換を止める？(done)
- foreachをsliceにも(done)
- main.printlnがエラー(done)
- ioをmultithreaded方式に置き換え(done)
- perlマーシャラ、参照でマーシャルするもの。(done)
- 仮想関数を持つクラスにmutexを埋め込め(done)
- 文字列リテラルのescapeがおかしい(done)
- インタフェース型にデフォルトのダミー実装を入れる(done)
- デフォルトコンストラクト可能でないものを定義したらエラーに(done)
- ポインタnull排除(done)
- pimplの中身のコンストラクタを禁止する手段を用意(done)
- clone時にtype_of_this_exprをクリアする必要があるものをクリア(done)
- threads(done)
- グローバル変数にperlsvを置いていると終了時不正メモリアクセス(グロー
  バルに置けないようにする)(done)
- ptr{foo} p = foo(...)を一時オブジェクト作らずにboxing(done)
- '::'を@local使って実装(done)
- インポートされた側を先にコンパイル(done)
- 参照引数(done)
- 分割コンパイルした際、コンパイル時に読まれたモジュールの違いにより
  メタ関数の評価結果が変わってしまうと問題では？たとえばsymbolを探す
  処理。 -> 変わらないようにする(done)
- expr_foldfe(done)
- macrodefの引数がシンボルテーブルに定義されてしまう(done)
- tempvarを作るタイミングは正しいか？(done)
  (部分式の評価順序はコンパイラが勝手に決める)
- foreachの対象をrootしているか?(done)
- 総称的to_stringに必要なメタ関数を用意(done)
- 総称的な文字列への変換。io::println()を全ての型に対応。(done)
- to_stringを基本型に制限(done)
- if条件がメタ関数で、偽に評価されるときはブロックの中を消す(done)
- foreach: structとvariant(done)
- foreach: 引数の型チェック(done)
- 固定長配列(done)
- catchは常にconst参照で受けるのは大丈夫なのか？rootされているか？
  (大丈夫。throwは常に引数をコピーするから)
- 型定義順を再整理(C++テンプレートが絡むケース require_definition?)
  (done)
- profile(done)
- ソース検索パス(done)
- coptionsをinfファイルに書く(done)
- coptionsをccコンパイル時に反映(done)
- コンパイルの流れを確定(done)
- 作業ディレクトリ決め(done)
- 並列コンパイル防止lock(done)
- infoを消す前にccとoとsoを消す(done)
- md5sumコマンドと値が異なる理由(ファイル名も含めていた)
- 型のテンプレ引数としてclosureやメンバ関数を指定するとエラーに(done)
- 具体型からインタフェースptrへの変換を許可(done)
- interfaceのメンバテンプレートは禁止(done)
- extern struct型の変数の初期化されているか確認(done)
- if (x) の型チェック(done)
- interface, variant等もテンプレートパラメータ持てるように(done)
- inheritに型パラメータを使えるように(done)
- int i = i + 3 の初期化を漏らさないように (done)
- ユーザ定義コンストラクタ (done)
- argdeclはinterface型を持てるように(done)
- upvalueの名前が(idだけだと)衝突するのでnsを付ける。(done)
- up5.px (teを引くコンテキストが構造体の中になってしまっている？)(done)
- up6.px (テンプレート引数不足をチェックできていない)(done)
- up7.px (関数の中でマクロ定義したら動かない？)(done)
- closureがテンプレート引数を持つケース(done)
- テンプレート引数に関数オブジェクトがあるとき(done)
- []の中を型チェックしてない？(done)
- const method から nonconst methodを呼べないように(done)
- non-const methodを呼ぶときにオブジェクトがconstであるか確認(done)
- 生成コードにconst(done)
- inheritの際にconstnessの一致をチェック(done)
- foo{int}(x, y); expr_symbolとexpr_teを統一する？(done)
- inheritされたときの実装チェックと型一致チェック(done)
- メンバ関数をその下のネストされた関数から呼べるように(done)
- 関数型の変数を定義したらエラーに(done)
- nestされたstructの下側から上側のメンバ関数等を参照できないように
  (done)
- リファクタリング: tvmapを文字列キーに。(done)
- リファクタリング: C++のテンプレートもinstantiate処理。(done)
- eval整理(expr_teを返すのをやめる)(done)
- ptrとcptrをexpr_structへ(done)
- 「&」廃止(done)
- externの文法統一(done)
- 型パラ付き型もfoo()で自動インスタンス化できるように？(done)
- typedefとctypeを分離してtypedefをaliasに改名(done)
- alias(typedef)に引数を持てるように(done)
- グローバル変数の寿命をグローバルに＆closureに渡す必要無し(done)
- extern functionにCの名前を指定できるように(done)
- termをimmutable参照型に(done)
- エラーを投げる関数を統一(done)
- extern function(定義が空)(done)
- extern typedef(done)
- extern struct(定義が空)(done)
- 明示的キャスト(done)
- コンパイラ/リンカオプション(-I, -L, -lxx) (done)
  incdir, libdir, library
- alias list(t) ptr(cons(t)) (done)
- '!'演算子(done)
- 単項演算子の'case'(done)
- double(done)
- list*.px (done)
- union.px (done)
- 総称関数の自動マッチ(fib2.px)(done)
- template(done)
- 型名() でのオブジェクト作成を全ての型に(done)
- 自動テストフォルダ作成(done)
- define_variablesとcheck_typesに分ける。(done)
- 全ての型式(のalias)でデフォルトコンストラクタを呼べるように。(だぶ
  んdone)
- expand_type_aliasの場所(型式のevalするタイミング)を明確に。(done)
- r1636でエラーだったものが解消した理由調べよ(done)変数定義最適化が
  効かないようにエンバグしたのが原因だった。
- interface型の変数を宣言できないように(done)
- implementsのメソッド実装チェック(done)
- グローバル変数もupvalueに(done)
- 直和型(done)
- struct foo と namespace foo の衝突回避(done)
- c++ 例外(done)
- breakとcontinueの位置チェック(done)
- returnがあるかチェック(done)
- null参照外しエラーチェック(done)
- vectorにempty()などのメソッドを定義(done)
- foo.bar()をns::bar(foo)に自動で置き換える(done)
- 明示的キャスト(done)
- byref引数(done)
- lvalue check(done)
- cptrからptrへの変換をエラーに(done)
- typedef (alias)
- interface
- auto boxing (operator &廃止?)
- メンバ関数が上位値を持ったらダメでは？(done)
- メンバ関数の中で定義されているクロージャから同じ関数のメンバ関数を
  よぶのは無理では？(done)

---------------------------------------------------------------------
廃案

- evalのhas_unbound_tparam()のときに未評価のまま返すのをやめよ
  -> マクロの部分的評価を実現するには必要

---------------------------------------------------------------------
Cの名前の使い方

t$0 一時変数
foo::bar$n namespace
foo$f   関数名
foo$f0  ローカルに定義された関数の関数オブジェクト(struct)名
foo$fi  ローカルに定義された関数の関数オブジェクトインスタンス
foo$t   typedef(enum, bitmask)の名前
foo$t0  typedef(enum, bitmask)のenum要素
foo$s   構造体
foo$s0  ローカルに定義された構造体
foo$v   直和型のstruct名
foo$v0  ローカルに定義された直和型のstruct名
foo$i   インタフェースのstruct名
foo$i0  ローカルに定義されたインタフェースのstruct名
foo$    auto変数、グローバル変数、メンバ変数、関数引数
foo$ns0 auto変数、グローバル変数、関数引数？ 名前空間付き
foo$ns0p0 fast boxingコンストラクタが使う生ポインタ
foo$e   variantのenum要素
foo$fg  foreachのguardオブジェクト
foo$fe  foreachのkey, mapped値, guardオブジェクト
$e      variantのenum
this$up メンバ関数の下の関数からメンバ関数を呼ぶための上位this
??      変数
$ic     ネストされたテンプレートに使う
str$ls  テンプレート引数の文字列リテラル
100$li  テンプレート引数の数値リテラル
aaa$c   名前空間の初期化関数
aaa$cm  名前空間のエントリ
i$it    if(v:c[k])が使うイテレータ

構造体に追加することのある名前
init$z 初期化補助関数
conunt$z 参照カウンタ
incref$z 参照カウンタ用
decref$z 参照カウンタ用

---------------------------------------------------------------------
キモ

- PerlのデータとC++のデータの両方を扱えること
- Perl/C++とのデータやりとりでオーバヘッドが無いこと
- Perlの例外とC++の例外の両方を安全に(リークせず)使えること
- Perlの拡張として動き、動的コンパイル即実行できること
- C++呼び出しが別途リンクせずにできること
- C++のコードを書かない限りSEGVらないこと -> stack詰んだ場合は許容

---------------------------------------------------------------------
まあまあ重要

- インタフェース
- コンテナを使える(静的型付け)
- スマートポインタ(静的型付け)
- ある程度クロージャをサポート
- C++のコードをインラインで書ける

---------------------------------------------------------------------
割り切り

- 配列の境界チェックはon/off? -> 常にon
- 参照外しチェック(ぬるぽ)は毎回チェックorSEGVフック？ -> null廃止
- C++のキーワードは識別子の名前に使えない(連携しやすくするため)
- スレッドは使えない -> mtsafeチェックして使えるように
- 参照カウント
- コンテナにイテレータは無い -> かわりにrange

---------------------------------------------------------------------
injectns使うと分割コンパイルで不整合がおきうる。

Bar inject Fooのとき、BarをimportするかどうかによってFooに対する
名前引き結果が異なってしまう。

---------------------------------------------------------------------
condition variableのwaitをどのような文法で実現するか

waitする際にはmutexをlock済みでなければならない


