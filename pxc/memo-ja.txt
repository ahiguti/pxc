
0623 800
---------------------------------------------------------------------
FIXME/TODO M1

- function_body_stmtにc_enumval_stmtを追加したことで問題起きないか確認

- expandをネストしなくてよいように、置換シンボルに複数渡せるように
  する。

- expandをネストするとコピーされた内側のexpandの数だけ再帰呼び出し
  することになってしまう。expr_expand::check_errorの実装の都合。

- import hoge でhogeが存在しなくてエラーになると、直してコンパイル
  しても namespace '' not found になってしまう。inf生成の問題。(done)

- metalistのカンマ区切りは、最後にカンマがついていても受理

- expr_stmts::check_typeにtry-catch、ただしexpandを除外。

- bool allow_noheap_container = !is_passby_mutable(varinfo.passby);
  これは推移的に定数オブジェクトであるときに限らなくいいのか？
  -> 限らなくてよい。排除せねばならないのはvarrayのpush_backにより
    コンテナ自体より短い寿命のものが要素に作られてしまうケース。
    function foo(varray{cstrref} mutable& vs) {
      cstrref s = "hoge";
      vs.push_back(s); // fooを抜けると無効な値がvsに残る
    }

- darraystはcopyableだけどもreturn式には使えないようにする?
  コピーコンストラクタを許可してしまうとコピコン除去により呼び出し先
  でallocaしたポインタが呼び出し元のオブジェクトに渡ってしまう
  - darray型の変数を定義し

- struct constructorでreturn式は使えないことを確認
  checktype.cpp expr_block::check_typeのFIXME

- platformを'uname -o'の文字列に変える。macosなどとハードコードしてい
  る箇所を除去。リンクに使うコマンドはプロファイルで指定。

- inject_statement, inject_function, inject_block
  プロファイルにこれらが指定されていると、指定されたマクロのnsをimport
  しているコードの全ての文、関数、ブロックに対して、そのマクロを展開
  したコードを埋め込む
  metafunction inject_block{function_name, lineno};

- macosxでboostをbrewで入れるとboost pythonが入っていない

- pod_array_compare等はxとyの型が異なっていても使えるように(done)

- sstringはhash_sstring/eq_sstringがhashとeqのデフォルトになるように
  array_or_sliceでis_raw_array、要素が基本型ならばeq, hash, compareを
    pod_array_eq
    pod_array_hash
    pod_array_compare
  eq: array_or_sliceで要素が基本型ならvarray_eq等
  hash: array_or_sliceで要素が基本型なら

- sort関数をcompare_strict_weak限定に(done)

- darrayを、小さいときはスタック、ただしmake_darrayは常にヒープ

- extern "linear" は noncopyableに統合できるのではないか

- get/setrlimit

- operator () が __call() に置き換わらないケースがある(文法的に特定の
  式でしか置き換わらない)
  funccallのfuncは expr_teかexpr_symbolかexpr_opの「.」のみ
  x()
  x.f()
  foo()()

- compare_strict_weakのパラメタに順序入れ替えを

- ephemeral と noheap 統一

- コンテナからrange/sliceを作る簡単な式を用意
  中身のrootされることを確認

- algebraicはなくす？

- stdin等を関数ではなくfieldに

- 名前空間の命名規則として、なるべく構造で分類する。
    ordered -> 順序構造
    equality -> 等値型
    vector -> ベクトル空間
    monoid -> モノイド構造
    boolean -> ブール代数構造
  具体型については構造の名前空間の下には入れない
  (複数の構造をもつことがあるから)
    container::array
  構造の間に包含関係があっても下に入れないこともある？

- numeric/quaternion削除(done)
- quaternionをglmのものに(done)
  
- 一般化されたfold

- __fooが定義されていたら..のような処理について、定義されているか
  どうかはm::symbolが0を返すかどうかで判定する。m::symbolが返すもの
  はメタ関数の可能性があるから、文字列として比較するのはよくない。

- 辞書式順序で

- 複数のpxから使われている型や関数について、すべてのコンパイル単位で
  同じC++コードを生成していることを保証するにはどうすればよいか
  - メタ関数が純関数的であること
  - マクロ展開が純関数的であること

- catchの引数もconst byrefなどを指定できるようにするか

- for (size_t i, int v: arr) { ... } をguardせずに実行するように
  配列やスライスはmappedがbyvalのときguardせずに実行できる
  連想配列はイテレータ無効化の可能性があるからguard外せない

- tree_map_compareという名前になるのが面倒

- algebraic整理 -> tupleとeitherに分離

- コンテナの rebind{u} は m::baseなどを使って実現できるので要らない。
  (done)

- operator::eqなどのboolを返す演算のstructに対する定義

- static_cast無しでfloatだけで計算できるように

- シバンに pxc -p=unsafe のように書けるように
- cdriver: pxファイル名にスペース等が入っていないかチェック

- x86_64用adt-bundle-linuxのaaptコマンドが32bitのlibz.so.1を要求...

- boost/cstdint.hpp __GLIBC_PREREQが定義されていない場合のworkaround

- eq{sstring}が無限再帰 is_equality_typeなどの判定をコンパイラ側と
  食い違いがおきないように考えよ
  expr_misc: is_ordered_typeから文字列型を排除

- ordered::compare  sort()はstrict weak orderを要求する

- foo[key] = val の式はコンテナの場合でもfoo.__setelem(key, val)に
  置き換える。そうすればguardしなくてよくなる。

- hash_mapのrange式はエラーに

- swap

- findが返すのはiteratorではなくfind_typeにする。hashmapはiterator
  よりもfind_typeのほうが小さくできる。find_typeは偽のときみつから
  なかったことを表し、参照外しで中身を取れる(生ポインタ)。

- ordered::compare -> ordered

- privateなフィールドがメタ関数でとれてしまっている

- privateをデフォルトに

- TypeError: No to_python (by-value) converter found for C++ type
  が出るとboost::pythonがリークしている。 136/t8, 136/v2

- chm2
  - バケツのサイズのリストを素数選んであらかじめ決めておく。
  - その素数での剰余を除数定数でコンパイルした関数を用意。
  - boost/unordered/detail/util.hpp BOOST_UNORDERED_PRIMES

- sstringとstrlit: 8byte境界まで0fill、比較を速く

- errnoのto_stringは"EINTR"など

- error処理整理
- echosvr整理
- mysql
- opengl モデル読み込み

- NOTE: meta::symbolはコンテキストによって結果が変わることがあること
  に注意。importしている名前空間のリストによってヒットするシンボルが
  変わることがあるから。

- nsextendsをたどった結果curnsから間接importしていない名前空間を
  引いてしまっている。curnsからの間接importにbが含まれるときのみ
  a nsextends b のbを引くべき。
  テストケース: 143_lookup

- 082_invoke

- alias無しimportでprefix無しで参照できてしまっている

- platformごとに処理を分ける方法を決める
  epollが使えるならepoll, 使えないならpoll, のように

- evalmetaのシンボル取得メタ関数はcompiledチェックをしたうえで
  generatedなものも返すようにする

- memfld引きは nogen モードを用意しなければならない。nogenは生成された
  シンボルは見ないが、その型のコンパイル完了前でもエラーにならない。
  (done)

- resolve_nameのエラーメッセージ: 位置を示す

- __getfld復活 (done)

- 名前空間省略してグローバル名を参照したとき、curnsはno-generated,
  allow-not-compiledでシンボルを探す。(042/lim) (done)

- import meta::vararg va; として va::hoge と参照すると、後で定義した
  名前空間vaを一度引いてしまう。 (108_fixme/va.px) (done)

- __invokeみたいなのはgeneratedであったら無視しないと分割コンパイル
  不整合がおきる可能性がある? シンボルの有無で処理分岐する場合には
  対象の名前空間がコンパイル済みであることを確認してからでないと
  いけない。
  - resolve_name_nothrowなよびだしは、memfldについては対象型がcompiled
    であることを確認。グローバルシンボルについてはその名前空間が
    compiledであることを確認
  - generated_flagは廃止

- boost::pythonの可変長引数にはリミットがあるので避ける

- 関数オブジェクト __call(...) (done)
- py/t16 tupleでないとしぬ (done)
- pythonのキーワード引数 (done)

- userdef opなどで生成したコードに一応fn_set_namespaceするように

- python: pxc noncopyable (done)
- python クラス二重登録防止 (done)

- __has_fldop__ やめて foo___getfldの有無で判断 (done)
- python del文 (done)
- Expression 'py::module("sys").exc_type' is of type void (done)
- pxcstringをpython::objectにwrapしないようにする？ (done)
- 136/python (done)

- C++に渡せる関数であるかどうか(closureではないか)判定するメタ関数

- __attribute__ monitor 効いてるのか？

- memcpyなどはintなどの配列にたいしては速くない

- 関数呼び出しの式について、対象がvariadic functionであったときと同じ
  ように variadic metafunctionであっても引数型を渡すようにする?

- serializeをvariadic metafunction使ってoptを無指定にできるように

- 汎用tableパーザ
  - 先にrcvector欲しい(done)
  - 次: transform: fieldに関数適用(done)
  - 次: regex split (done)
  - 比較関数を指定できるように (done)
  - container::tableに移動 (done)

- forコンテナのmappedをmutable& にできるように

- bulkではなくグローバルへ返せるようなスレッドローカルアロケータ


- openglのsafe interfaceをどう作るか

- svectorのカバレッジ

- コンストラクタが例外投げたときのコンテナの動作などをテスト

- guard_ref/guard_val

- 代入演算子はvoidを返す

- vectorとguard改革案整理

- sliceの代入演算子を潰していないのはなぜ？

- TODO棚卸し

- コンテナからその要素参照を取り出すような関数は、返値のrootにコンテナ
  の要素ガードが必要であるが、そのことをコンパイラに知らせる手段が
  必要か

- pointerのserializeは、指す先のserializeと等価にする

- serializeのオプション渡し方法決定

- 型式に負の数を許可

- 数値リテラルの範囲チェック

- vectorがreallocで伸ばせるケースを拡大。たとえばvector{vector{t}}。

- term_tostrで tparamsのシリアライズを必要とする理由を調べる。
  termとして canonical ではないものが渡されているということか？

- 地の文はブロックで囲むことを要求する

- defconとunionについて再整理

- インスタンス化していないブロックにcompiled_flag=trueをセットして
  問題ないのか？

- meta整理: functions, types, symbolなどをnsと型の両方取れるように

- meta::metafunction_names ?

- regex/posix immutable ptrとして保持。const regex_tはマルチスレッド
  セーフ。(glibcの実装はlockしている模様)

- fpclassifyなどは -lm が必要

- expandのパラメータに式を文字列として渡せば式を展開する。文法的に
  問題無い箇所であるかもチェックする。

- expand等のテンプレパラメータに変数を指定すると空文字列になるのは
  わかりにくいので、変数名を文字列化するようにするか

- 制約緩和第二弾: noheapや参照をfieldにも置けるようにする。

- -Wall -Werrorで通す

- make_ptr{foo, m::list}(); コンパイラがループ
  108/lp1.px

- m[x] = y は mのmappedがdefconでなくてもコンパイルできるように

- 範囲式 v[a .. b] もユーザ定義可能に
- フィールドのget/setもユーザ定義可能に

- 引数型のpartial evalを止めることができればevalがシンプルになる。
  - eval()とは別にpartial_eval()を用意するか。関数引数の型式を簡約
    するだけのeval。

- metaの命名規則を整理
  m::argnames, m::argtypes を arg_names, arg_types など

- lock_guard効いてることを確認するてすと

- backtrace()を可能な限りすべてのプラットフォームで。

- body付きextern関数は、メンバ関数でなければextern名は無視される

- 参照やephemeralを返す関数のrootルールを整理&テスト
  - externなら、thisか最初の引数をroot
  - そうでないならエラー
  - checktype.cppのadd_root_requirement()

- ephemeral型の制約緩和: vector{cstrref}などが使えるように
  - テンプレパラメータやフィールドにephemeralなものを使うことを許可
  - ただしそれらを使った型はそれ自体がephemeralになる
    - テンプレパラメータにephemeralなものを含むならephemeral
    - フィールドにephemeralなものを含むならephemeral
      - フィールドは無理？ フィールドにephemeralなものを含めて、メンバ
        関数から渡ってきたephemeralな値をそこへ代入してしまったら？
	初期化以外の代入が許可されていないからよいのか？
  - ephemeral: 初期化以外の代入不可、要素取得以外のreturn不可

- Cシンボル名を指定するけどpxcで定義する関数

- dense hash map実装
- threaded namespaceは初期化関数を省略

- get_stdin()の効率改善

- local poolの後始末を__attribute__((destructor))使わずに実現できるか

- list

- 連結リストから削除する処理をどう実現するか
  mapped const参照を引数にとりboolを返すclosureを引数に取る関数

- farrayとdarrayをdefconでない型で初期化するためのmake関数。

- list, set, multimap, multiset
  - list{t}はkey_typeがunit, mapped_typeがtであるようなmultimap
  - set{t}はkey_typeがt, mapped_typeがunit(done)

- mapのfind的なもの
  - range_gt, range_ge, range_lt, range_le

- map_rangeのerase_front(): guard_countが1でないとthrow。そうで
  ないならrangeの最初の要素をmapから削除する。

- expandで生成された無名関数はシンボルのuniquenessを確保できないので
  テンプレパラメータに使えないようにする

- externなテンプレ関数にはテンプレ引数に型or整数しかわたせないように
  しないといけない。C++のテンプレ関数の制限。

- perl再整理
  - 型のコンストラクタを関数としてexport(done)
    - pxfunc_obj{f}().call()のfが型のとき、placement newで構築(done)
  - svarrのget(i)でperlsvを構築するのは遅いので生SV*を返す(done)
  - 返値をperlsvではなく生SV*(done)
  - field(done)
  - global variables(done)
  - extval, enum val(done)
  - pseudo-member function。関数の最初の引数の型名が関数名のprefix
    となる(done)
  - グローバル変数の型をperlに登録する
  - unionのtagを取得する関数
  - 継承
    - 各型について、全派生型のstashとstash名をmapで保存。mappedには
      upcast関数を保存。void * -> foo * -> super * -> void * の変換。
    - get_value_ivを、ポインタの参照を取るように変更
  - perlsvに演算子実装

- orb再整理
  - 一方向リクエスト・レスポンスのときはpipelining可能なように

- 実装を自動で埋めるmethod。to_stringのように。

- return x が抜けていてもエラーにならない？ expandを使うと起きる？

- noncopyableな値を返す関数は実現できないか？

- genericsとvariant


- private namespace. 親namespaceからのみシンボルが参照できる.

- glm

- resolve_nameが遅いのでinternする

- to_untyped()どうするか決めよ
  cslice{uchar}だとstrict aliasing ruleに反する


- --cleanはフォルダが存在しなければ.lockを作らない

- sdl: オブジェクトはboxedにしないとコンストラクタ複数作りたいとき困る

- metafunctionのデバグのためのエラーメッセージが不十分

- cname_teというのを作って extern "hoge" などのcnameにマクロを使える
  ようにする

- toplevelの繋ぎかえ処理があるのでexpandがtoplevelの最初や最後にきて
  はならない。ダミーのstatementを入れるか？

- get_fields()はブロックをコンパイル前だったらエラーにしないと
  symbolをイテレートしているメタ関数やそれから呼ばれるコンパイラ関数
  は、ブロックをコンパイル前に実行されたらエラーにする

- fpclassify等のdouble/float出し分けは末尾にfつけないのか？
  -> つけない。こいつらはマクロであると定義されている。

- extern "%" double cos(double x); 
  pxcシンボル名をpxcが生成したものをそのまま使う

- GLfloatとfloatの間の変換が超絶面倒なので何か考える

- auto_ptrやQObjectのようなownership方式をどうやって実現するか
  この方式は懸垂ポインタが起きないことをコンパイラが保証すること
  は不可能なのでは？ コンサバgc？
  - QObjectの削除はdeleteLaterのみを使えばイベントループに戻るとき
    のみ無効化されるようにできる。イベントループ境界でQObjectポインタ
    を保持できないようにすれば無効化はおきない。可能？

- py: defconではないときにno_initを付ける

- ネストされたstructなどについてのterm_tostrは正しいのか？



- externを許可するパス、許可しないパス

- pool allocatorのうまい扱いかたを考えよ
  1. multithread safeなオブジェクトだけを渡すエントリ関数を介し、一時
     的にarenaを置き換えるような機能
  2. 名前をつけたアロケータにオブジェクトを置けるようにする
  3. 利用カウントを付けて、0であれば解放可能にすると性能的にどうか

- ポインタとコンテナにアロケータを指定するしくみ

- atexitでlocal_poolをクリアすると、その後でグローバル変数のデストラ
  クタが走ると困る。グローバル変数の解放のあとに何かを実行させるには
  どうすればいいのか？現状gccのfunction attribute使っている。

- tircvalのインタフェース版は作らないのか？

- thread-local pool allocator - skip_76

- os依存部分を切り離す方法

- ioを一通り用意せよ

- extern ... "source.cpp"

- pointer実装を複数持てるように、相互に変換可能なptr/cptr/iptrを
  取得する方法を用意。コンテナのrange_typeのように。

- weak pointerをどう実現するか

- tree_mapのrange: k0 < k1にしてから lower_bound/upper_bound すれば
  finishがstartからreachableであることが保証されるか？

- std::mapは比較関数がStrict Weak Orderingではなかったときに全てが
  未定義になるのではないか？ 比較関数に勝手なユーザ定義関数を与えても
  メモリ安全にするためには、std::map使えないのではないか？
  - 比較関数はcompareに固定する。
  - 比較関数をユーザ定義するにはexternを要求する。

- rangeに対してはtruncate_front/truncate_backで統一？

- tree_map_rangeにoperator []するとc++エラー

- familyが同じであっても実装が違うときはconvert_typeはエラーを返す

- vectorをarrayに改名

- pxcシンボルはextern "C"でよい

- evalの再帰上限調査

- コンストラクタだけprivateにすることを許可せよ(private_udcon)

- ptrはコンストラクタだけprivateに

- 環境変数への読み書きを許可するか。たとえばjvmの中では自前のlockで
  環境変数の排他処理しているはずで、もしpxcが自前のlockで排他処理
  したとしても混ぜると問題がおきる。
  - 初期化時に保存しておいた環境変数は常に読み出し可能
  - 環境変数読み書きはthreadedではない

- 変数定義の文法を整理

- 副作用を持つ演算子を複数回使ったら怒る？

- なんでpxcvectorよりpodvectorのほうが遅い？

- その他のコンテナ

- テキスト処理

- dunion: alignmentをどのように指定するか

- デストラクタの例外は握りつぶす。ただしフックを呼べるようにする。

- if (foo x : ...) の値渡し、参照渡しを網羅 (done)
- for (foo x : ...) の値渡し、参照渡しを網羅


- has_unbound_tparam, term_has_unevaluated_exprの意味を整理

- term_tostrのterm_bindとterm_lambda

- termの同一性とterm_tostr_strictの同一性は一致しなければならない
  シンボル生成にterm_tostr_strictを使っているから。

- term.cpp: operator <のlambdaはtparamsも比較

- 関数呼び出しをexpandする? - blockのかわりに

- インスタンス化しないときにargsの型を評価するのをやめる?

- inheritsに同じものを複数回指定するとどうなるか？

- rpc: remoteハンドルに対して関数を呼び出す
  orb { ns_functions funcs; string rbuf; string wbuf; } のように

- orb: exceptions

- trace_meta should not be an extern pragma

- まずmarshal by reference無しのRPC作る

- string/util.px split

- create_fooに統一する？

- tagged unionの$eと$uをやめる。gdbで見るとき困る。

- expand型foreachを削除

- 演算子オーバーロードは、組み込み型以外のopに対して関数呼び出し式を
  evalすることによって実装チェック、その関数を呼ぶようにemit。
  代入演算子は値を持たないように(done)

- ccだけ吐くモード -> androidに必要
- ヘッダファイルを吐くモード

- プロセスをforkしてpipe経由で通信するパターン
  - バイト列の通信(popen的なもの)
  - ORB的なもの

- 名前空間整理

- numeric/positionalからserialize/numericへ移動

- stringをpxcvectorに統合?

- test_07_constr/ud4fixme.px ユーザ定義コンストラクタが無いのに実行文
  をstructに書くとエラーになる。
  -> udconでなければ実行文を書けないようにする(done)
  -> 引数が空のudconを作れるようにする。そのような型はdefcon。

- tagged unionの実装がstrict-aliasing rulesを破っている。これを直す
  にはC++11のunionが必要。-fno-strict-aliasつけておく。C++11前提に
  するならunrestricted unionを使ってtagged union実装する。
  -> may_alias属性を付ければC++11要らないが、gccの警告が動作怪しい。
  -> std::mapの中でもstrict aliasing警告出る...
    struct compare{bool operator()(const int&x, const int&y)
      { return x<y; } };
    (http://gcc.gnu.org/bugzilla/show_bug.cgi?id=42087
     Bug 42087 - stl::map breaks strict-aliasing rules)
  -> tagged unionの実装はstrict aliasing ruleを破ることはないのでは。
     ある型のポインタと別の無関係型のポインタがaliasすることは無い、
     というのはtagged unionの実装でも成り立つ。同時に別の型の中身が
     有効となることはありえないから。

- awk的なもの

- from_stringを用意してbuiltin.pxのstring_to_*を削除。

- byvalueを要求されたら参照を返す関数のかわりに値を返す関数をemit
  無効化されるのを防ぐため。-> 確認

- lockobject{int} lck = sobj;  これが通るように
- var lck = lockobject(sobj); これも

- injectns消す

- union の初期化を一発でできる構文を用意

- object counter

- structのコンストラクタがexternのとき、引数がnoncopyableであっても
  pxcエラーチェックできずC++エラーになってしまう。引数がcopyableであ
  ることを要請する手段が必要。(ただしptr{file}のようにfast boxingで
  きるときはnoncopyableでもよいことに注意)
  -> struct等にmacro __check__が定義されていればevalする
  -> ポインタについては引数型はcopyableでなくてよい
  -> それ以外のテンプレ型についてはcopyableを要請
  -> farray, darrayはdefconも要請
  
- pxcvectorにstringと同じだけのメソッド定義
  - insertとerase(done)
  - findはいらない？

- enum, bitmaskのコンパイル時リフレクション
- external int/uintを整数リテラルからコンストラクトできない
- 算術演算子は左右どちらへも変換できるように

- std::set_new_handlerでstd::bad_allocではなくpxcrt::bad_allocを投げる

ephemeral型まわり
- test: globalやstructには参照変数などは置けないように
- test: 構造体にslice等のephemeral型を含む型のfieldを置けないように

- structコンストラクタに対するcheck_return_expr()

- too many argument for ... を共通化

---------------------------------------------------------------------
FIXME/TODO M2

- darrayのalloca使った実装

- C++名前空間をすべて絶対参照で

- expr.cppで組み込み型にtype::builtinをセットしているのをやめて、
  serializeなどではtype::builtinではない名前空間を使うようにする

実装が不明確なところ
- threadまわりの仕様再整理せよ
- 演算子の一通りテスト作成。コンテナ含め。
- type familyの仕様文書化
- 決定済みの仕様をメモに蓄積、テストケースと関連付け。
- 全ポインタ型とinterfaceの組み合わせ(モニタ等埋め込みが正しいか)確認

---------------------------------------------------------------------
TEST TODO M3

- test_14_root/refvar.px
- test_14_root/condtemp.px refvarが無いエラーになるように
- std::vector<bool>を使ってしまうと要素への参照が取れない

---------------------------------------------------------------------
TEST TODO M4

- tpupを引数で参照渡しするときのconstnessが正しいコードを吐いているか
- fn_check_rootテスト
- check_return_exprテスト
- テスト: fn_check_root廃止、rootはchecktypeの中で。
- ユーザ定義constructorを持つ型のdefault constructible判定が正しいか
- 型のパラメータにclosureやメソッドを使うと正しくエラーになるか？
- 型パラメータの文字列と数値がescapeされているか確認

---------------------------------------------------------------------
FIXME/TODO M5

- gcc-4.4.4のバグ？ -Wswitch-enumが効いていない しばらくgcc34を使う
- cflagsの与え方など確定
- interfaceの配列のように、テンプレパラメータが具体型でないといけない
  ケースのチェック。特にC++テンプレ型(固定長配列)。
- 文字列リテラルのテスト

---------------------------------------------------------------------
FIXME/TODO M6

- multimap, set, multiset, list
- foreach: multimap, set, multiset, list
- 例外の整理とstacktrace
- 構造体や配列の初期化式

---------------------------------------------------------------------
TODO

- expandを再帰的に展開できるようにすればbinary searchのインライン化
  が可能になるか？(done)
- meta lambda(done)
- 配列範囲チェックを非デバッグ時等に無効化するプラグマ?(done)
- intの範囲を超えるenum/bitmask
- 構造体の中でenumを定義できるようにする？
- enumのint値を省略できるように
- enum int値に型式を書けるように
- enumがエラーメッセージではintとして見えてしまう
- mutexのlock保持スレッドを記録する実装
- 演算子を総称関数に自動で置き換え、ユーザが演算子定義できるように
  (done)
- check_overflow pragma? 実行時にオーバーフローを検出
- if (int v : foo.fld) { ... } // unionのフィールドは左辺値取れない
- C++が定義する関数については宣言だけはemitする(誤った宣言で問題を起
  こさないようにするため) -> 非template関数については実装済み。
  template関数と型がexternな場合については未実装
- public extern "@0void" "@0void" struct void { } こういうの無くす?
- realloc-safeかどうかpxcで判断し、それに応じて使うコンテナ実装を
  切り替える?
- foreach 参照渡し、constの組み合わせをすべてサポート?
  - keyは常にconst値or参照、mappedはconstまたはmutable参照でよいのでは？
  - keyがconst値であるかconst参照であるかは、意味的に差が起き得ない？
- fork()したときにファイルデスクリプタをどうするか？
- blockscopeのlockobject - 19/blkscope_lock.px
- evalのエラーメッセージ改善
- list, set
- tptr/tcptrのロックをreader/writerロックに。そのためにはguard count
  をatomicにしなければならないのでやめたほうがよい？ immutable ptrも
  同じようにguard countを考慮必要。
- add_root_requirement_container_elementsのexpr_has_lvalue止め?
- 代入演算子は値を返さないようにすると少し速くできる
- ptrをconst byvalで渡すときは生ポインタで受ける?
- テンプレート引数にtrueが使えない？
- inline_cに色々装飾付けられるが、エラー
- arr.resize()のように参照引数が一個だけでthreadedならinvguardしなく
  てよい。
- 定義前参照の可能性を解消
- 情報をロスするような自動変換は止める
- pure関数ならrootを省略できるケース
- multi-indexコンテナ
- 条件変数を構造体に埋め込めるようにする？普通にfieldとしてユーザが
  定義できるようにする？
- interface名と同名のmethodを定義すると変になる？
- メタ関数の評価が超遅いのは改善する？
- call traitがrawptrの型を作れるようにする? perlsvをそれにするべし
- 配列のスライスを参照渡しできるように。文字列のsubstr。
- call traitがbyvalueの型を作れるようにする?
- constnessがポインタの指す先にも伝播するようにする?
  (mtsafeの扱いとあわせて検討)
- type safe bitmask
- type safe enum
- infoファイルのescape
- getenv("HOME")だとsudoしたときに困らないか
- block_id_nsは何に使うのか整理(動的にblockを作成してはならない理由)
- コンテナforeachの中でcontinueやbreakを使えるように
- const変数宣言
- union fieldのrootをvectorと同様にするか？
- ifdef?
- struct定義時に実装するinterfaceを明示しなくてよいようにできるか？
  (implements宣言を分離。)
- いつterm_tostr_instance_chain()を必要とするのか確認
- interface型の一時変数を禁止(そもそもできない？)
- 無名関数はテンプレート引数を持てない？
- const変数(varは変更可能だがconstは不可)
- extern関数へのpointer渡し、const pointer渡し
- extern enum
- switch
- 定数
- 参照カウントデバッグ
- unstableな値を返す関数(substringのように)
- posixモジュール
- 文字列との暗黙変換やめる
- interface間の継承
- this
- ネストされたテンプレートは必要？
- テンプレート引数に数値などを使えるように
- instance化はconstness関係なしにおこなわれるが問題ないのか？
- nonnullな参照型
- テンプレート型の間のinherit(is_sub_type)
- 関数型の変数を定義できないように？
- import pxcrtするとエラー
- 上位シンボルとの衝突チェック?おきない？
- variantテスト
- variantのstabilizeテスト
- interfaceのcloneは用意すべき？
- mt safeにするために必要なものを整理
- variantのfieldが全部unitのときはenumを生成したほうが性能良い
- namespace宣言義務付け?
- downcast
- pure関数
- 引数渡しの際のstableでない値をstable化(テスト)
- リンカオプション指定
- perl sv/av/hv
- perl exception
- restricted pointer (raw reference)
- string optimization
- ユーザ定義コンストラクタのより良いコード生成(C++フィールド初期化)
- perl module

---------------------------------------------------------------------
ARGUABLE

- 数値型の変換チェック numeric_convertible
  - 現在の実装は浮動小数点数がieee754, 整数が2の補数であることを
    仮定している
interfaceまわり
- interfaceの仮想関数の引数型は先に定義しなくていいのか？
- test_03/interf_constr3_1_fixme.px1
- 型定義順依存を調べるために再帰的型を定義するテストを作る
- std::mapで foo["abc"] = "xyz" するとmudflapが怒る
- unionがunitだけでできていたときmudflapが怒る(バージョン？)
  (STLのバグ？)
- 仕様決め: catch は常にconst byref?
- block_id_nsをなくせないか
  - なくせない
  - ローカル関数をテンプレートパラメータに渡してインスタンス化した
    場合にインスタンス同士を区別するためにblock_id_nsが必要
  - 変数を上位値として渡した場合に名前の衝突を避けるのにblock_id_ns
    が必要
  - 方針: @expandによって生成したコードにはblock_id_ns=0をセット
    する。もしblock_id_ns==0なブロック上のシンボルをテンプレート
    引数に使ってしまったらエラー。現状そのように実装している。

---------------------------------------------------------------------
DONE

- thread/implをthreadへ(done)
- for (const i, mutable& e: arr) はarrがsliceならarr自体はconstでも
  許可(done)
- シンボル引きの結果の違いによってコンパイル単位間不整合が起きるような
  ことがないことを、struct symbol_table が保証(done)
  - resolve_name()の引数no_generatedが
    - trueのとき、生成されたシンボルは返さない
    - falseのとき、生成されたシンボルも返すが、その名前空間が未コンパ
      イルならエラー
    (done)
  - evalmetaの、nsのシンボル一覧を取得するようなメタ関数については、
    シンボル一覧を取る関数を用意してsymbol_table::findは無くす
    (done)
- threadをfuncのみにする(done)
- make_farrayなどの中の型キャストはやめる(done)
- operator { } は tuple を構築する (done)
  (一時tupleを除去しなくてもgccが最適化してくれる模様)
- tuple___toを定義すれば { ... } から任意の型へ変換 (done)
- container::array::vectorは varray に改名する。(done)
- glm ベクタや行列？のスカラ倍、スカラ除算 (done)
- 四元数をglm使う (done)
- python: 動的フィールドget/set foo.bar (done)
- bind EADDRINUSE (done)
- expt_metafdef::is_variadic消去(done)
- 無名variadic metafunction (done)
- popen, fcntl, poll, epoll (done)
- 可変長引数メタ関数: metafunction {x*} ... (done)
  - transposevは要らない (done)
  - joinはjoin_listに、joinvはjoinに (done)
  - apply_listを用意 (done)
- 132_constmem_bugfix (done)
- vectorのようにパラメータを取るテンプレはmeta lambdaとして使える
  ように、引数が与えられなかったら評価しないで値としてメタ関数に
  渡せるようにする。metafunction{x} ...との扱いを共通化するため。
  (done)
- io::file::openをvarargsに (done)
- range等に対する operator * のexpr_has_lvalueが正しくない (done)
- コンテナには中身がconstであるものも用意必要 (done)
- マクロ置換でシンボルが空白だったらエラーになるか確認(done)
- timingもtest_*に含め、実行時引数で長時間timingを実行するようにする
  (done)
- vectorとsvectorの性能比較 (done)
- 直接malloc呼ぶのをやめる (done)
- local_allocate_nつかう (done)
- allocatorを別ファイルに (done)
- 暗黙変換がbyref又はnoheap型を返すとエラー(done)
- add_root_requirement: function returning value && passby reference
  && blockscope のときstore_tempvarするが、functionだけでなく値を返す
  opでも同様のことをやる必要は無いのか。またconversionがあったときは？
  - store_tempvarが必要なのは型にguardがある場合だけ。guardが無い場合
    は const foo& x = func_ret_foo() の式はブロック末まで有効になる
    ことがc++的に保証されているのと、mutable refで受けるのはpxc的に
    許容していない。(done)
  - 組み込みopについてはblockscopeなら常にstore_tempvarしている(bscpval)
    (25/blockscope_val3) (done)
  - conversion結果値を返す式については？ conversion結果、値を返し、
    それをblockscope passby referenceでrootされるケース？-> implicit
    conversionでstringに変換し、その[3]をblockscope byref ->
    どうやって？ -> わからないがstore_tempvarにチェックを入れる(done)
  - implicit_conversion適用された場合、store_tempvarで変換元をroot
    したところで、変換先のblockscope rootは保証されないのでは？
    -> エラーになるようにした(done)
- 108/staticif_dupname -> 109/staticif_dupname (done)
- store_tempvar(bscpval)は operator || などの非strict関数の右辺も評価
  してしまわないか？ (done)
- 三項演算子の : をstore_tempvarしてはいけない (done)
- 三項演算子をblockscopeでrootするには？ -> noheap型を返すときはエラー
  とする(125/condvar) (done)
- bugfix: 025/val.px, blockscope_val?.px(done)

- private namespace(done)
- evalmetaからprivate namespaceの中は引けないように(done)
- meta::condを可変長(done)
- deserializeの効率改善(done)
- make_default(done)
- m::symbolはシンボルをevalしないといけないのではないか(done)
- m::symbolは見つからなかったら第3引数を返す(done)
- meta::find(done)
- meta::localとmeta::lsymbol廃止(done)
- tptr{file_mt}がlock_guardを作れないことを確認。
  -> 043_file/filptr3 (done)
- interfaceを実装する型がboxing時にコピーコンストラクタ実行すると
  参照カウントどうなるのか - stack上におかれる限りrefcnt==1で、
  最初にbox化されたときにもrefcnt==1、ptrのコピーでincrefされる。
  (done)
- get_count$z => refnct$z (done)
- io/file.px の FIXME : interfaceのconst refをrootしようとしてしまう
  (done)
- 型が実装するinterfaceについても名前引き候補とする(done)
- floatの operator < は strict weak ordering ではないのでstd::mapの
  キーにはできない。どうするか。-> wrap (done)
- meta::character : 文字コード又はリストを取り文字列を返す (done)
- meta::code_at : 文字を取り文字コードを返す (done)
- 配列インデックスの型チェック (done)
- metaのオーバーフローとゼロ除算チェック (done)
- 数値リテラルからキャストしなくてすむように (done)
- safe mode: pathの最後はunsafe不可にする(done)
- 103/queueをcoreへ (done)
- v1 = make_vector{cslice}(sli1) で sli1がblockscopeでrootされていない
  (done)
- meta::transpose (done)
- meta::mapの仕様簡略化 (done)
- metaの命名ルール確定 (done)
- is_const_member_function やめて is_mutable...にする。mutableなら1に
  統一するため。 (done)
- metaの可変長引数なものを明確化 (done)
- make_ptrの引数がcrefに固定されている 114/mp1 (done)
- expandのindexは式セレクタがリストであっても1つとカウント(done)
- expand: セレクタが指定されない場合は全stmtを選択 (done)
- expand: セレクタとしてリストを許可 (done)
- expr_to_termでevaluatedが付いていれば二回evalしてしまう (done)
- function expand(done)
- function expand以外の関数はexpandできないように(done)
- slice::next -> increment_front decrement_back (done)
- 自動テスト速くするためにnsのコンパイルを共通化 (done)
- cslice{int} const& y; darray{int} const x = y; がエラー
  -> 109/darr.px (done)
- 108/ret.px -> 112/ret1.px (done)
- runtime_error_templateは実行時に文字列引数を取る(done)
- 例外のto_string(done)
- io::fileのerrno_tを返す関数は、errno_or_valueを使う。(done)
- io::standardをメソッド式呼び出し対応(done)
- フィールドを持つかどうか調べるために、見つからなかっても例外投げな
  いmeta::localが必要 -> meta::lsymbol (done)
- operatorをbinop使うように変更(done)
- operator binopのreturn type(done)
- operator unaryop(done)
- operator::implicit_conversion{tto, tfrom} (done)
- convert_typeを例外吐く形に変更(done)
- implicit_conversion_funcが正しいシグニチャを持つかコンパイラ側が
  確認する(done)
- to_ptr -> make_ptr (done)
- threadのインタフェースを変更。make_thread{func}の形に。(done)
- 引数を取るオプションは -p=hoge のように指定する形にするか(done)
- C++インタフェースを実装するpxcモジュールをロード実行する手段(done)
- ヘッダファイルを出力する -> PXC_IMPORT_HEADER(done)
- プラグイン(done)
  - dlopenして初期化関数を呼ぶのをmulti-thread safeにできるように(done)
  - 初期化を必要としないnamespace -> threaded namespace? (done)
  - 特定のinterfaceの実装を持つdllをコンパイル・ロードする手段(done)
- hs2インタフェース(done)
- tbl_bug1.px.fixme (done)
- deque(done)
- sliceとrangeのpop_front/pop_backを改名。next_front(), prev_back()?
  (done)
- rawptr{t}, crawptr{t} (done)
- プラットフォームごとのpath(done)
- 連想配列の[]はmappedがdefcondであることを要求(done)
- expr_misc is_ordered_type()の判定はfamilyでなく型名で判定する。deque
  を入れたときのため。is_string_type()も同様。(done)
- 例外無しモード(done)
- sort関数 (done)
- 構造体fieldをupvalueとして使うと名前が衝突する可能性がある(done)
- operator.pxの総称関数は組み込み型に対しても使えるようにする(done)
- expr_miscのis_ordered_typeの定義、operator.pxとmeta/family.pxの定義
  と合わせる(done)
- arrayのfindは消す。genericなfindはpodならmemcmpになるような実装を
  用意。(done)
- operator.pxは全てthreadedつけなければならないか？(done)
- vectorの要素を探すfindがoperatorを使うように(done)
- full_string{}が文字列とシンボルを区別できるように(done)
- bt_intなど -> pxcではintなど、C++ではbt_intのまま (done)
- show_outなくす(done)
- 演算子を非メンバ関数で (done)
- value$z をやめて単に value に(done)
- emit_vardef_constructor_fast_boxingの継承使っているケース、
  create_rawptrは引数0か1個のときしか定義されていないからそれ以外の
  ケースでエラーになるのではないか test_85_fastbox/fb1.px (done)
- プラットフォームをメタ関数で取得(done)
- extern "ldflags"などをメタ関数で出し分けられるように(done)
- weak pointer (done)
- リンクだけ実行されたときldflagsが無視されている(done)
- inline_cに埋め込み式(done)

- pointer/raw.px pxcrt::rawptr<>::type をemitできるように(done)
- externな関数はephemeral typeを返すことができて、その呼び出しをroot
  するには引数をrootする (done)
- slice以外のephemeral typeを作れるように(done)
- unsafe/safe (done)
- SDL: mainを複数回呼ばれた場合はmainの名前空間の本体だけを複数回実行(done)
- SDL: undef SDL_ANDROID_BLOCK_ON_PAUSE でないと端末回転させると固まる(done)
- SDLActivity.javaのflipEGL() eglWaitNativeとeglWaitGL削除(done)
- gen_ccのときは.oを作らないように(done)
- pxc_android.profile.profileとなるのは何？(done)
- __getelem/__setelem(done)
- __invoke (done)
- <<=と>>=が無い (done)
- glmのwrapper作る前に演算子オーバーロードを。 (done)
- ioはerrno_or_valueを使うように(done)
- fn/の下のファイル名エンコード方法変更。_をエスケープしない(done)
- 例外の仮想基底クラス整理(done)
- socket等のエラーチェック方法(done)
- stringをvector{uchar}に(done)
- hoge/common.pxにするくらいならhoge.pxにせよ(done)
- in-placeにオブジェクト構築する方法を考えよ (done)
- io/standard join_string -> split::string_join (done)
- --generate(done)
- for文なども型推論(done)
- cleanするときにフォルダがないとエラーになるのは無視するべき(done)
- 配列をsliceからconstructできるように。特にstring("abc") (done)
- ptr(foo(...)) の式が変数定義の右辺ではないとき、fooのコピーコンスト
  ラクタを要求してしまう(skip_49_variant_fixme3)
  変数定義の右辺以外でのptr構築を禁止、box()を使うよう強制。(done)
- 再リンク必要なケースで漏らしている。間接的privateインポートしている
  ファイルが更新されたとき、exeを再リンク必要だがされていない。
  test_72_priimportでnspri.pxを書き換えれば再現できる。 (done)
- エラーメッセージをきちんと文頭大文字に。(done)
- pxcvectorのpop_backまちがってる(done)
- 72/fixme_t1(done)
- 型推論をもっと有効に(done)
- テンプレ引数の一部分だけを自動マッチ(done)
- グローバルブロックについてはgeneratedなものはsymtblをenumuerate
  しても見せない。enumerateした場合以外でも見せてはならない。コンパイ
  ル前後で内容が変わる可能性があるから。どのみち現在はglobalブロック
  でexpandは許容していないので二重の安全策。(done)
- throw 型名 とやるとエラー(done)
- グローバル変数はdefault-constructibleでなくてはならないようにする
  (done)
- ポインタのデフォルトコンストラクタを消し、nullチェックをなくす(done)
- globalにdefconでない型の変数を置くとエラー(done)
- unionの代入演算子は例外安全でない。フィールドへの代入も。(done)
- ptrをnon nullableに(done)
- union bodyのexpand (done)
- generated symbolsがメタ関数から見えてしまっているのはいいのか？
  いずれにせよcompiled_flagが真なブロックであることを確認すれば
  generatedなものを見せても問題ない。(done)
- threaded等のデグレードをm::listの中も探って適用 (done)
- 65/sock2のようなケースでの循環参照を解消(skeletonsをクリア)(done)
- fixme_66/concat_comma2.px -> 47/fixed_comma.px (done)
- 65/fixme_inherit.px inherit_transitiveを読む前に必ず計算しなければ
  ならない -> 03/inherit_ok.px (done)
- socketpair, orb (done)
- デストラクタ(done)
- if (foo x : hoge[...]) コード生成おかしい fixme_64_remote (done)
- cnameのあるメソッドをオーバーライドするとき、そっちもcnameを
  吐く(done)
- fn_check_finalから無駄にresolve_texpr()されて遅い(done)
- metafunctionはlexical contextを持つようにする(done)
- cの予約語(intとか)にメソッド名などがかぶったとき(done)
- inline C syntax (done)
- operator = for strlit (done)
- for文やcatchなど、const refなど装飾を整理 (done)
- threadのmainまで例外が飛んできたらどうするか (done)
- interface extern (done)
- mainでget_stack_trace() (done)
- 文法の変更 struct extern "hoge" hoge { } (done)
- downcastは多相型でないとc++でエラーになるはず(done)
- interface間継承のupcastがコンパイルエラーになる(done)
- serializeのfieldを名前順に(done)
- is_expand_dummy削除(done)
- 関数の最後にfunction定義があると、control reaches ... になる(done)
- meta::common::fields(done)
- deserialize: e_rはエラー時の残り長さ+1の値をセットする(done)
- decimal_to_integralなどを, cstrref&を取って先頭だけ読む方式に(done)
- 菱形継承でc++エラーになるはず。interface間継承はvirtualに(done)
- from_string仕様きめ(done)
- obj.func は、その場所からプレフィックス無しでtobj_funcという名前が
  引ければそれに解決する(done)
- nodefconファミリが必要。コンストラクトできないがコピー可能。(done)
- metaif -> cond (done)
- metamap -> map (done)
- コンストラクタの中のフィールド定義でnoncopyableな型のフィールド定義
  でコピーコンストラクタ使ってしまっている(done)
- variant: グローバル変数、関数(done)
- meta argsとglobal_variablesが最初にindex値を入れているのをやめる
  (done)
- expand argdeclsが最初にindex値を期待しているのをやめる(done)
- meta typeofはlazyである必要ないのでは(done)
- variant: structに空引数udconを許可せねばならない(done)
- variant: 変数定義をexpandで生成できるようにせねばならない(done)
- 推移的に実装しているインタフェースについてfunc実装確認(done)
- expr_misc check_interface_impl() (done)
- expr_misc implements_interface() (done)
- interface間継承でthreading属性のチェックしていることをテスト(done)
- interface間継承で同名の関数を宣言するとエラー(done)
- meta::common::functionsなどの結果は、その名前空間をコンパイル中で
  あれば変化してしまうことがある。コンパイル単位の間で一貫性を保証
  するにはどうすればよいか。-> expandによって生成されたシンボルは
  メタ関数からは見えないようにする(done)
- macro -> metafunction に改名すべし(done)
- expr_variant -> expr_dunion に改名すべし(done)
- argdeclへのexpandはシンボルを指定する必要がないので消す(done)
- skip_variant_fixme2 (done)
- 可変長引数関数はmetalistをメタ引数に取る関数で実現できる。自動
  マッチさせる方法を考えよ。(done)
- expandのbaseexprが空だとしぬ(done)
- expand型foreachをexpandで置き換え(done)
- expand(sym, idx : ... ) のようにindexを渡さないと使いにくい(done)
- expand、文字列に置換するかシンボルに置換するかは文脈で決める(done)
- expand, リストの真ん中に埋め込めるようにする?(done)
- is_expand_dummyはtoplevelまでたどる必要がある(done)
- 名前空間にbuiltinを使うのを止める -> とりあえずcommonにし、大きく
  なってきたら分離(done)
- control reaches end of ... は最後がthrowだったらok(done)
- dynamic_cast相当のdowncastが必要。iinvokeからfoo_iinvokeへdowncast
  しないと元オブジェクトを取り出せない。(done)
- externな関数は返値をbyrefで返せるように。downcastを実装(done)
- meta::symbolを何とかせよ(done)
- 浮動小数点数のserialize(done)
- vectorのinsertとeraseテスト(done)
- prefix省略したシンボルを引くとき、テンプレートのインスタンス化の
  際にテンプレートを定義した側のルールで引いているか。(done)
- floatのto_stringおかしい(done)
- interfaceのlock/unlock/wait(done)
- interfaceを実装すると常にmutex埋め込むのは無くせないか(done)
- invalidate guardとmutex lockを共通化(done)
- condition variableのwaitを実現(done)
- cond_signal/broadcast(done)
- threadのmain関数の中でmultithreadedではない型を使うとエラーになって
  しまう(done)
- foo[x] = 3; でfooをguardしてしまうのは直したい。(done)
- socket_factory整理(done)
- signal SIGHUP(done)
- get_mutex廃止(done)
- lockobject廃止(done)
- block-scope lock (done)
- type familyに改名(done)
- struct foo { function {t} void bar() { ... } } がtest_symbols通らない
  (done)
- fldfe: フィールドの型を取れるように(done)
- fileのfdはimmutableにする。そうでないとaccept()でロックが要る(done)
- injectns使うと分割コンパイルで不整合がおきうる。無効化する。(done)
- generate_exe(done)
- weak pointerと区別するためにslice等はweak型と呼ばずにephemeral型と
  よぶ(done)
- to_stringは文字列へ追加する形へ(done)
- extern enumを型パラメータにしたときのエンコードがintになってしまう
  と衝突するのでダメ(done)
- io::fileはerrno_t参照を引数にとる(done)
- error{errno_t}(done)
- 16進、8進、文字リテラル(done)
- line_fixme.px1: upvalueを取れていない(done)
- privateメンバ、コンストラクタ。抽象データ型は作れるように(done)
- slice(done)
- boxing自動変換を廃止(done)
- namespace義務付け(done)
- pimplイディオムが使えることを確認(done)
- operatorと組み込み関数について整理。大小比較は全型に？(done)
- linear型の変数を宣言できないようになっているか(done)
- enum/bitmask型(done)
- 整数の暗黙変換を安全なものだけに制限(done)
- threadedではない型の変数をglobalに定義できないように(グローバル変数
  が初期化される前にそれをアクセスしてしまえないようにするため)(done)
- ユーザ定義コンストラクタ内に書ける文についての制限を決め(done)
- defconでない型(linear?)を引数無しで呼んだらエラーにせよ(done)
- ユーザ定義コンストラクタのemitを関数プロトタイプ群の後にしないと
  未定義関数を呼ぶことになる(done)
- is_copyableとis_assignableは構造体のフィールドにも制限を受ける(done)
- コンテナにnoncopyableな型は使えないように(done)
- pxcvectorとtree_mapのsliceからコンストラクタ(done)
- pxcvectorのappend(done)
- noncopyable/linearを引数付きコンストラクタで構築する方法(done)
- extern structにユーザ定義コンストラクタ(done)
- iptr/tiptr実装できている？(done)
- namespace宣言義務付け(done)
- foo{bar}: fooがtsvaluetypeでbarがthreadedな「関数」だった場合この型式
  は何装飾？ -> tsvaluetypeのまま。get_term_threading_attribute() は
  そのようになっているように見える。(done)
- global変数はthreadedな型を持たねばならない。初期化順序の問題が起きない
  ように。expr_var::check_typeの中のif 0を有効化せよ。(done)
- 短絡boxingを再び有効に(done)
- externならephemeral又はrefを返すメンバ関数を許可、thisをrootする(done)
- ephemeral型を初期化以外の代入の左辺にできないように(done)
- pxcvectorなどのインラインメンバ関数は"type"ではなく"fdecl"に移さ
  ないと型定義順依存がおきる -> ない。メンバ関数ごとにインスタンス
  化される(done)
- darrayは代入不可(done)
- threadedなclosureがupvalueとして非threadedな型を使えてしまわないか
  -> test_31_thrattr/up*.px (done)
- closureのthread属性？ -> test_31_thrattr/up*.px (done)
- guard countがmtsafeでないのはどうするか -> valuetypeとtsvaluetype
  (done)
- iptr, valuetype (done)
- コンストラクタからメンバ関数を呼べてしまうのをエラーにせよ(done)
- tsvaluetype darray実装(done)
- if (int const& x : foo[k]) { ... } のif-defined構文(done)
- int_compareなどの比較関数を無くし、基本型は > で比較するように(done)
- global変数にephemeral型は使えないようにせよ(11/fe_sli.px mudflap)(done)
- interfaceなどのようにcopyableではないものをコピーしたときのエラー(done)
- byrefであればintrface型もvarとtempvarに許容(done)
- string以外のコンテナにもappend(done)
- pxcのcharはc++のcharではなくint8_t(done)
- stringをcharではなくuchar(done)
- sliceからコンテナへ変換(done)
- foreachの中ではoperator []の範囲チェック不要 (done)
- コンストラクタへの引数がメンバ関数から見えてしまわないか？
  07/strarg.px (done)
- expr_feach::emit(): map, rangeに対するemit (done)
- pxcrt を compiler::runtimeへ (done)
- c++名前空間を::始まりで指定しないと途中の名前空間にマッチしてしまう
  (done)
- if (!x) がsyntax error (done)
- 25/val.px 関数の返値をblockscope rootしていない (done)
- farrayからsliceへの暗黙変換するとエラー(done)
- size_tを組み込みから外す(done)
- デフォルト名前空間からint等の基本型を消す(done)
- マクロ展開後の数値は何型？ long型。test_02_type/tmplint.px (done)
- eval.cppの sym_ns = "builtin" 削除 (done)
- symbol_table.cppの pname = "builtin::" + fullname 削除 (done)
- 組み込み型は名前空間"type::builtin"に属するように(done)
- test_16_perl/perl/symbols.pxでvoidを除外しないと動かないのを直す
  (done)
- 非メンバ関数にconst装飾つけるとエラーにならない(done)
- interface型を値で持てないように(done)
- interfaceへの代入はエラーにする(done)
- ptr{foo} = ptr(foo(...))で型推論してくれないのを直せ(done)
- ptr{ifoo}(foo(...))のようにインタフェースへのポインタを構築しようと
  するとエラーにせよ(done)
- require_lvalue廃止(done)
- variant fieldへの代入はset関数呼び出しに置き換える(done)
- rangeに対するoperator * (done)
- add_root_requirementのcheckonly廃止(done)
- 関数でないものでもoperator ()を適用できてしまう(done)
- test_01_px/i1_fixme : 仮想関数の実装を後ろに回さないといけないが、
  そもそも、ptrの指し先アロケートを廃止して仮想関数のダミー実装を必要
  なくすようにするべし(done)
- variantの最初のフィールドにはptrを置けないように(done)
- ポインタをdefault_constructibleではなくす。(done)
  ただしグローバル変数と構造体メンバについてはnull初期化せざるをえない
- c++実装のデフォルトコンストラクタをnull初期化するように(done)
- forやifでの定義初期化分離をなくす(done)
- foo(int x = bar())
  これをemitするのにbar()呼び出しを2回おこなっている
  int x = bar()を独立させたので参照時には単に「x」とするべし
  (test_23_emit/cmplx.px) (done)
- int x = ...の式をさらにtempvar作っているのは無駄 (done)
- 引数のpassby_e_unspecified(call trait)をやめる(done)
- コンテナからrangeへの自動変換(done)
- mutable&渡しの際にinterfaceへのupcastがあったらエラーになる問題(done)
- sliceの要素がlvalueを要してもslice自体はlvalueいらず、sliceかcslice
  であるかによってlvalueを持つかが決まる(check_lvalueの修正)(done)
  - add_root_requirementの'[]'についても同様の修正必要(FIXME印を見よ)
- add_root_requirement()するケースの整理、複数要求がある場合の処理。(done)
- 自動変換が入ったら左辺値を取れないように?(check_lvalue)(done)
- if文がboolでなかった場合のエラーメッセージに行番号が出ない？(done)
- variantのtagからintへの変換(done)
- test_22_error/tparam.px (done)
- 引数のconst/mutable参照渡し/値渡し明示。(done)
- integralやpointer downcast以外の自動変換を止める？(done)
- foreachをsliceにも(done)
- main.printlnがエラー(done)
- ioをmultithreaded方式に置き換え(done)
- perlマーシャラ、参照でマーシャルするもの。(done)
- 仮想関数を持つクラスにmutexを埋め込め(done)
- 文字列リテラルのescapeがおかしい(done)
- インタフェース型にデフォルトのダミー実装を入れる(done)
- デフォルトコンストラクト可能でないものを定義したらエラーに(done)
- ポインタnull排除(done)
- pimplの中身のコンストラクタを禁止する手段を用意(done)
- clone時にtype_of_this_exprをクリアする必要があるものをクリア(done)
- threads(done)
- グローバル変数にperlsvを置いていると終了時不正メモリアクセス(グロー
  バルに置けないようにする)(done)
- ptr{foo} p = foo(...)を一時オブジェクト作らずにboxing(done)
- '::'を@local使って実装(done)
- インポートされた側を先にコンパイル(done)
- 参照引数(done)
- 分割コンパイルした際、コンパイル時に読まれたモジュールの違いにより
  メタ関数の評価結果が変わってしまうと問題では？たとえばsymbolを探す
  処理。 -> 変わらないようにする(done)
- expr_foldfe(done)
- macrodefの引数がシンボルテーブルに定義されてしまう(done)
- tempvarを作るタイミングは正しいか？(done)
  (部分式の評価順序はコンパイラが勝手に決める)
- foreachの対象をrootしているか?(done)
- 総称的to_stringに必要なメタ関数を用意(done)
- 総称的な文字列への変換。io::println()を全ての型に対応。(done)
- to_stringを基本型に制限(done)
- if条件がメタ関数で、偽に評価されるときはブロックの中を消す(done)
- foreach: structとvariant(done)
- foreach: 引数の型チェック(done)
- 固定長配列(done)
- catchは常にconst参照で受けるのは大丈夫なのか？rootされているか？
  (大丈夫。throwは常に引数をコピーするから)
- 型定義順を再整理(C++テンプレートが絡むケース require_definition?)
  (done)
- profile(done)
- ソース検索パス(done)
- coptionsをinfファイルに書く(done)
- coptionsをccコンパイル時に反映(done)
- コンパイルの流れを確定(done)
- 作業ディレクトリ決め(done)
- 並列コンパイル防止lock(done)
- infoを消す前にccとoとsoを消す(done)
- md5sumコマンドと値が異なる理由(ファイル名も含めていた)
- 型のテンプレ引数としてclosureやメンバ関数を指定するとエラーに(done)
- 具体型からインタフェースptrへの変換を許可(done)
- interfaceのメンバテンプレートは禁止(done)
- extern struct型の変数の初期化されているか確認(done)
- if (x) の型チェック(done)
- interface, variant等もテンプレートパラメータ持てるように(done)
- inheritに型パラメータを使えるように(done)
- int i = i + 3 の初期化を漏らさないように (done)
- ユーザ定義コンストラクタ (done)
- argdeclはinterface型を持てるように(done)
- upvalueの名前が(idだけだと)衝突するのでnsを付ける。(done)
- up5.px (teを引くコンテキストが構造体の中になってしまっている？)(done)
- up6.px (テンプレート引数不足をチェックできていない)(done)
- up7.px (関数の中でマクロ定義したら動かない？)(done)
- closureがテンプレート引数を持つケース(done)
- テンプレート引数に関数オブジェクトがあるとき(done)
- []の中を型チェックしてない？(done)
- const method から nonconst methodを呼べないように(done)
- non-const methodを呼ぶときにオブジェクトがconstであるか確認(done)
- 生成コードにconst(done)
- inheritの際にconstnessの一致をチェック(done)
- foo{int}(x, y); expr_symbolとexpr_teを統一する？(done)
- inheritされたときの実装チェックと型一致チェック(done)
- メンバ関数をその下のネストされた関数から呼べるように(done)
- 関数型の変数を定義したらエラーに(done)
- nestされたstructの下側から上側のメンバ関数等を参照できないように
  (done)
- リファクタリング: tvmapを文字列キーに。(done)
- リファクタリング: C++のテンプレートもinstantiate処理。(done)
- eval整理(expr_teを返すのをやめる)(done)
- ptrとcptrをexpr_structへ(done)
- 「&」廃止(done)
- externの文法統一(done)
- 型パラ付き型もfoo()で自動インスタンス化できるように？(done)
- typedefとctypeを分離してtypedefをaliasに改名(done)
- alias(typedef)に引数を持てるように(done)
- グローバル変数の寿命をグローバルに＆closureに渡す必要無し(done)
- extern functionにCの名前を指定できるように(done)
- termをimmutable参照型に(done)
- エラーを投げる関数を統一(done)
- extern function(定義が空)(done)
- extern typedef(done)
- extern struct(定義が空)(done)
- 明示的キャスト(done)
- コンパイラ/リンカオプション(-I, -L, -lxx) (done)
  incdir, libdir, library
- alias list(t) ptr(cons(t)) (done)
- '!'演算子(done)
- 単項演算子の'case'(done)
- double(done)
- list*.px (done)
- union.px (done)
- 総称関数の自動マッチ(fib2.px)(done)
- template(done)
- 型名() でのオブジェクト作成を全ての型に(done)
- 自動テストフォルダ作成(done)
- define_variablesとcheck_typesに分ける。(done)
- 全ての型式(のalias)でデフォルトコンストラクタを呼べるように。(だぶ
  んdone)
- expand_type_aliasの場所(型式のevalするタイミング)を明確に。(done)
- r1636でエラーだったものが解消した理由調べよ(done)変数定義最適化が
  効かないようにエンバグしたのが原因だった。
- interface型の変数を宣言できないように(done)
- implementsのメソッド実装チェック(done)
- グローバル変数もupvalueに(done)
- 直和型(done)
- struct foo と namespace foo の衝突回避(done)
- c++ 例外(done)
- breakとcontinueの位置チェック(done)
- returnがあるかチェック(done)
- null参照外しエラーチェック(done)
- vectorにempty()などのメソッドを定義(done)
- foo.bar()をns::bar(foo)に自動で置き換える(done)
- 明示的キャスト(done)
- byref引数(done)
- lvalue check(done)
- cptrからptrへの変換をエラーに(done)
- typedef (alias)
- interface
- auto boxing (operator &廃止?)
- メンバ関数が上位値を持ったらダメでは？(done)
- メンバ関数の中で定義されているクロージャから同じ関数のメンバ関数を
  よぶのは無理では？(done)

---------------------------------------------------------------------
廃案

- evalのhas_unbound_tparam()のときに未評価のまま返すのをやめよ
  -> マクロの部分的評価を実現するには必要

---------------------------------------------------------------------
Cの名前の使い方

t$0 一時変数
foo::bar$n namespace
foo$f   関数名
foo$f0  ローカルに定義された関数の関数オブジェクト(struct)名
foo$fi  ローカルに定義された関数の関数オブジェクトインスタンス
foo$t   typedef(enum, bitmask)の名前
foo$t0  typedef(enum, bitmask)のenum要素
foo$s   構造体
foo$s0  ローカルに定義された構造体
foo$v   直和型のstruct名
foo$v0  ローカルに定義された直和型のstruct名
foo$i   インタフェースのstruct名
foo$i0  ローカルに定義されたインタフェースのstruct名
foo$    auto変数、グローバル変数、メンバ変数、関数引数
foo$ns0 auto変数、グローバル変数、関数引数？ 名前空間付き
foo$ns0p0 fast boxingコンストラクタが使う生ポインタ
foo$e   variantのenum要素
foo$fg  foreachのguardオブジェクト
foo$fe  foreachのkey, mapped値, guardオブジェクト
$e      variantのenum
_0$up   間接的に利用する上位値引数
this$up メンバ関数の下の関数からメンバ関数を呼ぶための上位this(廃止)
??      変数
$ic     ネストされたテンプレートに使う
str$ls  テンプレート引数の文字列リテラル
100$li  テンプレート引数の数値リテラル
aaa$c   名前空間の初期化関数
aaa$cm  名前空間のエントリ
i$it    if(v:c[k])が使うイテレータ
$p$XXX$q$YYY$r$ テンプレート引数 {XXX,YYY}

構造体に追加することのある名前
init$z 初期化補助関数
conunt$z 参照カウンタ
incref$z 参照カウンタ用
decref$z 参照カウンタ用

---------------------------------------------------------------------
キモ

- PerlのデータとC++のデータの両方を扱えること
- Perl/C++とのデータやりとりでオーバヘッドが無いこと
- Perlの例外とC++の例外の両方を安全に(リークせず)使えること
- Perlの拡張として動き、動的コンパイル即実行できること
- C++呼び出しが別途リンクせずにできること
- C++のコードを書かない限りSEGVらないこと -> stack詰んだ場合は許容

---------------------------------------------------------------------
まあまあ重要

- インタフェース
- コンテナを使える(静的型付け)
- スマートポインタ(静的型付け)
- ある程度クロージャをサポート
- C++のコードをインラインで書ける

---------------------------------------------------------------------
割り切り

- 配列の境界チェックはon/off? -> 常にon
- 参照外しチェック(ぬるぽ)は毎回チェックorSEGVフック？ -> null廃止
- C++のキーワードは識別子の名前に使えない(連携しやすくするため)
- スレッドは使えない -> mtsafeチェックして使えるように
- 参照カウント
- コンテナにイテレータは無い -> かわりにrange

---------------------------------------------------------------------
要件整理

- memory safe
- multithread safe
- (exception safe) --- 意味が不明確。リークしないというだけか。
- 形無しlambda計算に基づくmetaprogramming
- compile-time reflection
- late bindingもサポート
- C++との互換
  - inlined C++ code
  - C++テンプレ型を使える
  - const correctness

---------------------------------------------------------------------
injectns使うと分割コンパイルで不整合がおきうる。

Bar inject Fooのとき、BarをimportするかどうかによってFooに対する
名前引き結果が異なってしまう。

---------------------------------------------------------------------
condition variableのwaitをどのような文法で実現するか

waitする際にはmutexをlock済みでなければならない

条件変数を構造体に埋め込む
struct foo {
  compiler::runtime::condition cond;
};
foo& obj = *ptr;
obj.cond.wait();

---------------------------------------------------------------------
guardまわりシンプル化

現状:
  - checktype.cpp: add_root_requirementのTOK_PTR_DEREFのケース、
    スマポをstore_tempvarすることにより参照無効化を防止している
  - emit.cpp: expr_op::emit_valueのTOK_PTR_DEREFのケース、tptrかtcptr
    ならばlockobjectを作り、その中の参照を返している。interfaceか
    どうかでコード出しわけ。
    非インタフェース: (lockobject((p)->get_mutex$z()), p)->value$z
    インタフェース:   *(lockobject((p)->get_mutex$z()), p)

    配列要素:
      guard_ref< vector<int> > t0((vec));
      int& elem = (t0.get())[15];
    guard_refのコンストラクタ・デストラクタでvec.inc_invalidate_guard()
    とvec.dec_invalidate_guard()を呼んでいる。ポインタ型はC++では全て
    rcptr<>なので、rcptrクラスにinc_invalidate_guard/decを定義し、その
    中でptr->incref$z()とptr->decref$z()を呼べばよい。
    rootするためにポインタをaddref必要なときはguard_val、そうでないとき
    はguard_refを使う。
      guard_ref<T>
      guard_ref<const T>
      guard_val<T>
      guard_val<const T>

    rcptrにinc_invalidate_guard/decを追加する。

    guard_ref/valのget()はコンテナ自体を返すことに注意。


---------------------------------------------------------------------
演算子・関数呼び出しを組み合わせたときのroot必要の判断

副作用を持つ関数又は演算子を呼ぶと、呼ぶ前に有効であった参照を無効化
する可能性がある。C++は部分式の評価順序が決まっていないから、どのよう
な順で評価されても無効化されない場合以外はrootせねばならない。

・pure関数は副作用を持たない。pure関数は以下の条件を満たす関数:
  - threaded関数
  - 引数(メンバ関数のときはthisも含み、closureのときは上位値も含む)が
    全てtsvaluetype型、mutable参照以外の渡しかた
・pureではない関数はすべて副作用を持つ可能性があることを考慮すべし
・副作用をもつ演算子:
  - 代入演算子
  - +=のような副作用付き演算子
foo(bar(), baz())

---------------------------------------------------------------------
演算子の左辺・右辺のroot方針

x + y の左辺と右辺はconst_valueかconst_refのどちらでrootしてもよい。
値でrootするとコピーのコストがかかることがあり、参照でrootすると
配列のガードのコストがかかることがある。

---------------------------------------------------------------------
配列要素やunionフィールドなどをbyvalueで取得する安全な方法

mapped_type(arr[idx]) という式は、副作用を持つ式の一部として評価
された場合、評価順によっては、arr[idx]評価後にその参照を無効化される
可能性がある。そのため参照を返す演算子/関数のかわりに値を返すものを
用意し、それを呼ぶようにする。
ポインタ参照外し: deref(), deref_value$z()
variant field: value$$r() これは常に値を返すのでok
配列要素: get_value(idx)
rangeの参照外し: 常に有効なのでok

---------------------------------------------------------------------
interfaceのlock/unlock/wait
- 実装クラスがmultithreadedならmonitorを埋め込む。tsvaluetypeであっ
  てもmonitorが必要。tptrが指すことができるから。非interfaceな型に
  ついてはrcval/trcvalのラップ使い分けによってtiptrがmonitorを埋め込
  むのを避けられるが、interfaceではできない。
- lock$z, unlock$z, wait$z, notify_one$z, notify_all$zを仮想関数に
  し、実装クラスがmultithreadedならmonitorにたいして処理実行、そう
  でないならnoop。-> multithreadedでないならlock$zなどの関数を用意
  しない。

---------------------------------------------------------------------
awk的なもの

行の型をXとすると、Xのmonoid構造についてのfold演算の結果を取る処理。

行を分割
各カラムを各々の型に変換
インデックス構築

x: string, y: int

合計
  int sum;
  foreach { sum += y; }
キーごとの合計
  tree_map{string, int} m;
  foreach { m[x] += y; }

---------------------------------------------------------------------
汎用展開マクロ

@expand(sym : metalist) expr
exprが式であるか、文であるか、引数宣言であるか等によって結合方法
は判断する。式ならカンマ区切り、文ならstmts, 引数宣言ならargdecls。
struct proxy_stub{ifoo} : ifoo : {
  ptr{invoke} handle;
  @expand(funcsym : functions) function rettype{local{ifoo, funcsym}}
  funcsym(
    @expand(sym : seq{argnum{local{ifoo, funcsym}}, "a"})
    argtype{local{ifoo, funcsym}, substr{sym, 1}} sym)
  {
    var rci = remotee_call_info(to_string{sym}, *handle);
    @expand(sym : seq{argnum{local{ifoo, funcsym}}, "a"}) rci.argument(sym);
    rci.call();
    if (ne{rettype{local{ifoo, funcsym}}, void}) {
      var rv = rci.retval();
      return rv;
    }
  }
}

---------------------------------------------------------------------
expand 文

- expand(i, sym : metalist) [ stmt_list ]
- metalistは行列になっていて、各行は次のフォーマット
  { symstr, stmtnum, ... }
- metalistの各行について、stmt_listのうちのstmtnum番目の式を取り出し、
  そのstmt中のiをその行で置き換え、またsymをsymstrという名前のシンボル
  で置き換えたstmtを作り、それらを連結したstmtsで置き換える

---------------------------------------------------------------------
可変長引数関数

function {ts} foo(expand(i, sym : names{ts})) {
  ...
}
呼ぶときには
foo(x, y, z)
とやるとtsがx, y, zの型のリストとしてfooをインスタンス化する

---------------------------------------------------------------------
variant

関数引数の個数だけseqを生成
metamapで、各要素に対して{"a0", passby}のリストを作る

macro f m::local{t, m::to_string{fsym}};
macro arginfo{args, n}
  m::list{
    m::concat{"a", m::at{args, 0}}, 
    m::add{m::mul{m::at{args, 3}, 2}, m::at{args, 4}}};
macro arginfo_list m::metamap{m::args{f}, arginfo};

invokeが取るvariant型引数を型付けられた引数に変換する:
byvalならばfrom_variantで変換した値を保持
byrefならばiinvokeの中身をdowncastして参照を保持
sliceを引数にとる関数を呼ぶときは何に変換するのか？

from_variantの動作:
- tがintegral, fp, 文字列ならば極力変換
- tptrvalの指す先をtにdowncastして返す

to_variantの動作:
- tがintegral, fp, 文字列ならばそのまま格納
- それ以外はtptrvalにbox化

関数呼び出し
interface icall { variant call(cslice{variant} const& args); }
struct stub_func{f} <icall> { ... }
- variant call(...) の実装はstub_iinvokeのinvokeとほぼ同様

コンストラクタ呼び出し
struct stub_constr{t} <icall> { ... }
- 関数と同じように構造体のコンストラクタを呼べるように
- noncopyableな型については、stub_idynamic{t}のコンストラクタは
  tと同じコンストラクタ引数を持ち、中でそのままtを構築するのに使う
- copyableな型については、stub_idynamic{t}のコンストラクタはtで、
  そのままコピーコンストラクトする。このようにしないとtを返す関数
  の結果からstub_idynamic{t}オブジェクトを構築できなくて困る。
- variant版構造体コンストラクタの実装:
  - copyableな型なら v.tptrval = tptr(stub_idynamic{t}(t(...)));
  - noncopyablenなら v.tptrval = tptr(stub_idynamic{t}(...));
- 非メンバ関数呼び出しとコンストラクタ呼び出しは共通のコードで。
  - 名前空間の関数と型を呼び出せる
- struct以外の型: typedef, union, enum, bitmask
- enumやbitmaskの値(enumval)も関数のように呼び出せるように
- グローバル変数は

variant型だと実行できない処理:
- 参照外し
- 左辺値を返す配列要素、range
- 参照を返す関数
どのように代替するか？なくても困らないか？

サポートしない機能:
- 参照を返す関数。たとえばdowncastなど。
- ephemeral型。range、sliceなど。これらの型を引数に取る関数はかわりに
  コンテナを指定すればよい。
- 配列要素への参照。



---------------------------------------------------------------------
関数が必要とする上位変数の計算

(2013/10 この内容は古い)

- 関数の中身をchecktypeするときに、フレーム(funcdef/struct)のcallee_list
  にfunccall先を書いてゆく。
- 関数がどのupvalueを必要としているかは、自分が参照しているupvalueに
  加えて、推移的にcallee_listにあるupvalueを加えたものになる。
- メンバ関数やその子孫の関数は、参照しなくてもthisをupvalueとして必要
  になる。constメンバ関数かどうかでthisをconstにするかどうかを決める。
  struct内の実行文(=コンストラクタ)もthisをupvalueとして必要。
- this以外の上位変数がconstかどうかは単純にその変数自体がconstかどうか
  で決まる。this(とメンバ変数)がconstかどうかはthisupがconstかどうかも
  影響。
- 依存するthisのクラスがそもそも呼び出し元と先で異なるような場合はコン
  パイルエラー。meta式によってメンバ関数を取得した場合に起きうる。
- 関数を呼ぶ時点でupvalueが定義されていないといけない。これは各関数呼び
  出し箇所について、推移的上位変数のうち自分と同一のblockで定義されてい
  るものが、その呼び出し箇所よりも前の文に定義があることをチェックする。

手順:
- 関数呼び出しのすべてについてcallee_vecに呼び出し先funcdefを書く。
- 各funcdefについて、callee_vecを推移的にたどり、callee_vec_transitiveを
  作る。相互再帰に注意。callee_vec_tr_doneフラグをtrueに。
- 各funcdefについて

function void x()
{
  int z;
  function void baz() { z = 3; }
  function void foo() {
    twice{baz}();
  }
}
fooがbarを呼び、barがbazを呼び、bazがclosureのとき

呼び出しのチェインのうち、どこでその変数を定義しているか判定
- 呼び出し元のframeがその変数の定義しているframeと一致する箇所。

tpupにはその関数が参照しているupvalueのリストが入る
- add_..._direct()ではそのfuncdefのbodyの中で参照している上位変数
- add_..._tparam()ではそのfuncdefのテンプレ引数関数が参照している

---------------------------------------------------------------------
例外ツリー

std::exceptionをpxcのインタフェースにする。
interface exception { }
interface logic_error { }
interface runtime_error { }

---------------------------------------------------------------------
型情報無しserialize

unit: 何も書かない
整数: nnnxxxxx 上の3bitに後続バイト長さ。ただし111のときは後続8バイト
enum/bitmask: 整数と同じ
浮動小数点数: べた
配列: 最初に長さを整数エンコードで書く。残りは各要素を詰める
  ただし要素型が2byte以下のときは要素固定長で
連想配列: 配列と同じ
構造体: 各フィールドを詰める
union: 最初にタグ、次に要素

---------------------------------------------------------------------
from_string

引数には読み込みバッファの末尾までを渡す。パース失敗したら残りの長さ
を例外に含める。

string "hoge"
number 0.1
struct, union {fldname0=value0,fldname1=value1}
pointer {value}
map {key0=value0,key1=value1}
array {value0,value1}

トークン区切りは'{', '}', '=', ','の4つ

・文字列をquoteするのをやめる
・エラーになってもトークン区切りまでは読み飛ばす
・'='をやめて','区切りにする(done)
・構造体のフィールド順序を名前順に固定し、deserializeを速くする
・mapと構造体を互換に
・数値と文字列を互換に
・不要値を読み飛ばす

pointer_endは該当する'}'まで読み飛ばす

文字列、数値のパース
- まずトークン区切り記号を探す
- もし'{'だったら対応する'}'まで読み飛ばし、最初の要素をパースする
- それ以外だったら区切り文字の前までをパースし値を返す

---------------------------------------------------------------------
from_stringを変更に強くする

stringは引用符使わない

structはfield名の順にserializeする。
deserializeの際にもfield名の順に。
expand (fld : fields) {
  fldname = deserialize_symbol();
  if (fldname < fld) {
    このデータは空読み。
  } else if (fldname > fld) {
    fldnameをunreadして次のfldへ。
  } else {
    このデータをdeserialize。
  }
}

---------------------------------------------------------------------
lambda

lambda{x} lambda{y} add{x, y}
x := 3を適用
=> lambda{y} add{3, y}
y := 5を適用
=> add{3, 5}
=> 8

lambda抽象がすべて外れた時まで適用を遅らせる
lambda{f} lambda{x} lambda{y} f{x, y}
f := add
=> lambda{x} lambda{y} f{x, y} ( f := add )
x := 3
=> lambda{y} f{x, y} ( f := add, x := 3 )
y := 5
=> f{x, y} ( f := add, x := 3, y := 5 )
ここで適用？

各lambda式について、自身のlambda変数だけでなく上位のlambda変数について
も値を保持しなければならない
termを構築する際に、上位lambda変数を再帰的に渡す

lambda{y} f{x, y}
  引数: y
  上位変数: f, x
  適用: ()
  式: f{x, y}

lambda{x} lambda{y} f{x, y}
  引数: x
  上位変数: f
  適用: ()
  式: lambda{y} f{x, y}

lambda{f} lambda{x} lambda{y} f{x, y}
  引数: f: 
  上位変数: なし
  適用: ()
  式: lambda{x} lambda{y} f{x, y}

lambda適用時の処理
lambda{f} lambda{x} lambda{y} f{x, y}  .  add
f := add をバインドして 中身をevalする。
結果は
  (f := add) lambda{x} lambda{y} f{x, y}
x := 3 をバインドし、中身をevalする
結果は
  (f := add, x := 3) lambda{y} f{x, y}
y := 5 をバインドし、中身をevalする
結果は
  (f := add, x := 3, y := 5) f{x, y}
  頭が
  => add{3, y}

lambda抽象式を値として返すときには、その上位値のバインドを
同時に保持しておかねばならない

lambda_bindというtermを作る?

# evalの処理
# termがterm_lambdaまたはterm_bindだった場合の処理を追加
# termがargsを持たない場合
#   - 現在のbindをwrapしたtermを返す
# termがargsを持つ場合、それはlambda適用である
#   - 引数にargsを適用するようなbindを作る。
#   - さらに上位変数のbindを持つ場合はそれも加える。
#   - できあがったbindをpushして式をevalする

(1) eval_contextにbindを追加。term_bindへのポインタ。eval_contextのbindは、
現在評価中の式のlexical contextがmetafdefの中の式であるときに、その位置の
変数のbind一覧がセットされるもの。再帰的に別の式をevalするときは退避復旧
する必要あり。

(2)
eval_apply_internal(term x, term_list args, eval_context c, bool args_evd)
{
  xは評価済み。yはargs_evdなら評価済み。
  xがterm_lambdaかterm_bindなら
    lambda式の引数にargsの各々を代入するようなbindをxにかぶせる
    もしbindの深さがlambda抽象の深さに一致したら
      簡約可能なので、そのbindをctxにセットしてxのlambda右辺を
      eval_term_internalする
    そうでないなら
      まだbind不足で簡約できないからbindをかぶせたtermをそのまま返す
  xがexprなら
    そのexprにargsをつけたtermを作り、eval_term_internalする
  xがそれ以外なら
    エラー
}

(3)
metafdef_to_term(expr_metafdef *mf, ...)
{
  rhsをte_to_term()する
  lambdaに引数があるときは
    引数とrhs式をセットしたterm_lambdaを作り、それを返す
  引数が無いとき
    rhs式をそのまま返す
}

(4) tparamsのevalにたいして、param_defがnullだったらeval_contextのbindから
探す処理を追加。
(local_tparams_bindingはあとで削除。)
(変更後はmetafdef引数のtparamsはparam_defが常にnullになる。)

(5)
ここから一気に。
te_to_term(expr_i *te, ...)の処理
teがexpr_teじゃないとき、もしそれがmetafdefなら、metafdef_to_term()
を呼ぶように変更

(6)
eval_term_internal2()
case expr_e_metafdefの場合
  expr_metafdefをmetadef_to_term()で変換してevalし、それとargsを
  eval_apply_internal()する。argsが無いときはそのまま返す。

save_upvalue_bindはどこで実行するべきか
lambda{lst} lambda{a} map{lst, lambda{x} add{x, a}}
{lst:={1,2,3}} {a:=5} lambda{lst} lambda{a} map{lst, lambda{x} add{x, a}}
-> map{{1,2,3}, lambda{x} add{x, 5}}
evalするときにbindをectxにセット
evalした結果にlambdaが含まれているとき、その中に上位値として参照する
変数がectxのbindに含まれていることがあるが、それをeval後も覚えておく
必要がある。evalした結果にlambdaが含まれているとき、そのlambdaは一度
中でevalされているはず(eager evaluationなら?)。


---------------------------------------------------------------------
lambda lazy化

term_bindにtpv_evaluated

eval_apply:
  lambda applicationで適用するたびにterm_bindをwrapするところ、
  tpvをevalしてからセットしているのをevalせずにする
  ectxにtpbindがあればそれをterm_bindに付ける。

find_tparam_bind:
  bindの中から見つかったら、それのtpv_evaluatedが空ならtpvをeval
  する。その際にはtpbindをセット。

cycleの可能性をなくすには
tpv_evaluatedがmutableであるのが問題
ectx.tpbind は upvalueだけでなく全ての変数束縛が入る
- eval_term_with_bindでtpbindをセットしている
  1. tparamsのparam_defがnullだった場合にそこから束縛値を取るが、
     その際に遅延評価のために上位値をtpbindにセットしてから束縛値
     を評価する
  2. lambda適用が可能となった段階でtpbindにすべての変数束縛をセット
     してからlambda右辺を評価する
- find_tparam_bindでtpbindを参照している
  これはtparamsの束縛値をさがすのに、tpbindの中から探すから。
- save_upvalue_bind
  lambda式のlexical contextを保存するのに、tpbindをイテレートし、
  term_lambdaの直前にterm_bindを各上位変数についてかぶせる。
  -> これはもし評価済みであれば評価済みの値をかぶせる？

---------------------------------------------------------------------
targs_evaluated

除去して常にfalseであるような動作をするよう変更

eval_term_list_internal()
  trueなら評価、そうでないならそのまま
eval_term_with_bind()
  eval_term_internalにそのまま渡す
eval_apply()
  targs_evaluatedが偽なら引数を評価してからbindのチェインを作成
eval_term_internal()
eval_apply_expr()

---------------------------------------------------------------------
リモートオブジェクト

var svr = tptr(object_server{foo}());
multithreaded struct foo {
  function tptr{ibar} create_skeleton(client_info const& ci);
}
multithreaded interface ibar {
  function int hoge(int x);
  function tptr{ibar} fuga(ibaz& x);
}
struct stub{ibar} <ibar> {
  orb_client orb;
  function int hoge(int x) {
    return orb_client_call{int, m::list{m::list{int, 0}}}(orb, x);
  }
}
stub{ibar}
リモート化可能なインタフェースは、各メソッドが以下を満たす必要がある。
- 参照引数にはリモート化可能なインタフェースしか使われていない
- 返値は値渡し可能な型
リモート化可能な型:


---------------------------------------------------------------------
ORBに必要なもの

・参照でmarshalすることができるのはインタフェースだけ
  それ以外はdynamic_object interfaceを使えば参照でmarshal可能
  dynamic_objectはIDispatch的なもの
  interfaece ifoo {
    function int foo(int x);
    function string bar(string x, string y);
  }
・参照でmarshalするかどうかは、remote interfaceを実装しているかどうか
  で決める。remote interface自体は何もメソッドを持たない。
・リモート呼び出しでインタフェースを実装するクラス(stub)
  interface ifoo {
    function int foo(int x);
    function string bar(string x, string y);
  }
  interface stub { /* からっぽ */ }
  struct stub_ifoo <ifoo, stub> {
    ptr{orb_handle} const hnd;
    function int foo(int x) {
      marshal{int}(*hnd, x);
      remote_call(*hnd, "foo");
      int r = unmarshal{int}(*hnd);
      remote_call_end(*hnd);
      return r;
    }
    function string bar(string x, string y) {
      marshal{string}(*hnd, x);
      marshal{string}(*hnd, y);
      remote_call(*hnd, "bar");
      string r = unmarshal{int}(*hnd);
      remote_call_end(*hnd);
      return r;
    }
  }
・サーバ側でリクエストを受けてオブジェクトへメソッド呼び出しを実行
  (skeleton)
  interface skeleton {
    function void inovoke(orb_handle& hnd);
  }
  struct skeleton_ifoo <skeleton> {
    ptr{ifoo} const realobject;
    function void invoke(orb_handle& hnd) {
      if (req.method_id == "foo") {
	x = unmarshal{tx}(hnd);
	r = realobject->foo(x);
	marshal{tr}(hnd, r);
      }
    }
  }
・保持関係
  - stubはconnを共有保持。逆方向は弱参照を持つ(stub pool)。
  - connはskeletonを占有保持。(skeleton pool)。
・TCPでlisten, acceptし、接続毎にスレッド一本。 
  - 接続を受けるとクライアントからのリクエストを待つ。
  - 接続毎にskeleton poolを持っている。接続直後は空。
    skeleton poolはskeletenオブジェクトへの強参照を持っている。
  - 接続毎にstub poolを持っている。接続直後は空。stub poolはオブジェクト
    への弱参照を持っている。
  - メソッド呼出に含まれる情報:
    - thisのobject id(空なら
    - 引数のリスト
    - 返答が必要かどうかのフラグ
    - メソッド名(文字列？)
  - メソッド返答に含まれる情報:
    - 返値または例外の値
    - 参照渡し引数のリスト(あとで実装)
    - 返値であるか例外であるか
  - メソッド呼び出しのほかに、オブジェクト削除リクエストも来る
    - object idが指定される。指定されたオブジェクトをプールから削除
    - これは相手側でデストラクタが呼ばれたときに呼ばれる
    - これには返答は無い
・stubのメソッド実装(リモート呼び出し)
  - 引数をハンドルにmarshal
  - remote_call実行
  - 返値をunmarshal
  - remote_call_end実行
・skeletonのinvoke実装(リモートからの呼び出し)
  - 引数をunmarshal
  - realobjectへメソッド実行
  - 返値をmarshal
・orbサーバには引数としてmultithreadedなfactoryオブジェクトを渡す。
  接続毎にfactoryからインスタンスを作る。
  multithreaded interface {t} factory{t} {
    function ptr{t} create();
  };
  tはremoteを継承するインタフェース。接続を受けるとこれを一つ作り、
  skeleton poolへ入れ、そのidをクライアントに返す。
・orbクライアントには引数として接続先情報(host, serv)を取る。テンプレ
  引数としてinitial instanceの型(interface)を取る。
  function ptr{t} connect(address const& addr);
  - まずorbを作る。それはskeleton poolとstub poolを持つ。
  - addrへ接続しinitial instanceのidを得る。
  - stubを作る。
・orbクラサバ共通なのはskeleton poolとstub poolを持つこと。

非メンバ関数のskeleton
  interface skeleton {
    function void inovoke(cstrref const& req, string& res);
  }
  struct skeleton_foo <skeleton> {
    function void invoke(cstrref& req, string& res) {
      x = unmarshal{tx}(req);
      y = unmarshal{ty}(req);
      r = foo(x, y);
      marshal{tr}(res, r);
    }
  }
非メンバ関数のstub
各関数ごとにstubを作るか、nsごとにstubを作るか
function int foo(int x, int y);
function int stub_foo(orb& o, int x, int y) { ... }
function {f} rettype{f} remote_function(orb& o, argtypes{f}) { ... }

---------------------------------------------------------------------
RPC1

呼び出しをunmarshalするコードを作る。unmarshalしたものから関数を呼び
出すコードを作る。

function {t} t unmarshal(cstrref& buf)
  tab区切りで引数を取り出し、unmarshalする。取り出した引数はbufから
  pop_frontする。

リモート可能な関数・メソッドは？
- 引数と返値がすべてmarshal/unmarshalできればok
- remoteを実装する型へのポインタは参照でmarshalされる
- (option) remoteを実装する型のみmutable byrefで受けられる

関数呼び出し
  F foo 10 20
メソッド呼び出し
  M %1 bar 10 20
リターン
  R 50
例外
  T hogefuga

struct orb {
  ns_functions our_funcs;
  string rbuf;
  string wbuf;
  void expect_response()
  {
    while (true) {
      write_and_read(); // wbufを書いてrbufへ読む
      if (is_request()) {
	dispatch();
      } else {
	break;
      }
    }
  }
  void dispatch()
  {
    cslice req = rbuf[ .. ]; // リクエスト一つを切り出す
    read_token(req, 'F');
    call_ns_function(our_funcs, req, wbuf); // 中でreqを消す
  }
}

各orbにはbyref型マーシャラの配列を持っていて、各objectのskeletonには
その型に応じたマーシャラのidが同時に記録されている。

---------------------------------------------------------------------
RPC つぎ

61_remote/ot3.pxでメソッド呼びだしdone。
リモートへ払い出したオブジェクトにidをふり、またmethodsテーブルの番号
を保持し、ptr{obj}との3つ組をskeletonsにつっこむ。
idは生ポインタにする。ポインタからidを引く処理を省略できる

remoteオブジェクトのうち、stubはorbへの共有ポインタを持つ。
orbがstubsとskeletons、methods_tblを持つ。
stubsはリモート側の実オブジェクトに対して生成したstubの集まり。
  map{size_t, size_t};
    リモート実オブジェクトのid -> stubオブジェクトへの弱ポインタ
    (stubはorbの強参照をもつので反対方向は弱参照)
    (反対向きはstubの中に持っている)
skeletonsはローカル側の実オブジェクトの集まり。
  map{size_t, pair{ptr{remote}, size_t}};
    リモートobject_id -> (実オブジェクト, methodsインデックス)
methods_tblは
  vector{methods};
  各型についてのメソッドリスト。
methodsは
  vector{method_entry};
  メソッドリスト。名前順にソートされている。
method_entryは
  { string name; ptr{i_marshal_method} method; };

marshal_referenceの動作
  もしオブジェクトがstubsに入っているなら、そのidをシリアライズ
  そうでないなら、skeletonsから探す＆登録、そのidをシリアライズ
unmarshal_referenceの動作
  もしidがstub印がついていれば、stubから探し、強ポインタへ変換
    stubにないなら新たに作成
  そうでないなら、skeletonsから探し、ポインタを返す
    skeletonsにないならエラー

stubの中身
struct {t} remote_stub <t> {
  ptr{orb} shared_orb;
  size_t remote_id;
}

次: func_argexp_list: 型がptr{remote}ならbyrefでマーシャル

クライアントの動作
wbufにリクエストを積む
wbufをfileに書き込む
wbufをクリア
fileからrbufに読み出す
rbufからレスポンスをパース(レスポンスで無かったら?)
rbufをクリア
return

サーバの動作
rbufからリクエストをパース
引数をunmarshal
メソッド実行
返値をmarshal
レスポンスをwbufに書く
wbufからfileに書き込む

pipeline化を許可するには、再帰の深さをリクエスト/レスポンスに含める。

レスポンスを読む関数を作る。とりあえずpipeline化は不許可。
expect_response()
{
  /* レスポンスを待つ番のときに呼ばれる */
  while (true) {
    send_writebuf_and_fill_readbuf();
      /* wbufが空でないときは、rbufを空にする */
    if (!is_request()) {
      break;
    }
    execute_request();
  }
}

execute_request()
{
  /* rbufにたまったリクエストを実行し、wbufにレスポンスを返す */
  unmarshal args;
  call method;
  marshal retval;
}

サーバが接続を受けると特定クラスのインスタンスを作り、それを返値
としてクライアントに返す。
クライアントは接続からレスポンスを受け取り、それをunmarshalした
stubオブジェクトを返す。

サーバ側
transportを引数にしてorbを作る
初期realobjectをpush_return_valueする
exchange_loopを回す

クライアント側
transportを引数にしてorbを作る
exchange_loopを回す
初期stubをpop_return_valueで取り出す


---------------------------------------------------------------------
nullable ptr

union {
  unit nothing;
  ptr{foo} value;
}
fieldは二つであり、最初のフィールドはunit、二つめのフィールドはポインタ
であること。

union_tag関数の実装も変えねば。

---------------------------------------------------------------------
unionの代入演算子は例外安全でない。フィールドへの代入も。

同じ問題がboost::variantでも。
http://www.boost.org/doc/libs/1_53_0/doc/html/variant/design.html

ヒープ使わないようにするには、unitなメンバを追加して、構築中に
例外がなげればそのメンバにセットしてしまうのがよい。例外が起きたとき
以外はそのメンバにセットされることはない。
podなメンバが既に存在するときはメンバ追加しない。

---------------------------------------------------------------------
テーブルデータ処理

fileから改行区切り、tabまたは空白で列区切り。

列xをキーにして列yの値の総和を求め、多い順に出力
1. keyとする列番号と型の一覧
2. mappedとする列番号とモノイドの一覧
3. 表示する順序

---------------------------------------------------------------------
変数定義の文法

auto変数
  全5種
  int mutable& x
  int mutable x
  int const& x
  int const x
  int x
  (以下は型推論)
  mutable& x
  mutable x
  const& x
  const x
関数引数
  全5種
  int mutable& x
  int mutable x
  int const& x
  int const x
  int x
  (型推論は無し)
フィールド
  全3種 参照渡しが無い
  int mutable x
  int const x
  int x
  (以下は型推論)
  mutable x
  const x
forrange_argdecl [ for (i : 0 .. 100) { ... } ]
  常に暗黙裡にconst_value
foreach_argdecl [ for (k, v: arr) { ... } ]
  '&'は省略、mutableが明示されないとconst - FIXME
  const_reference + const_reference
  const_reference + mutable_reference
ifdef_argdecl
  関数引数と同じ全5種
catch_stmt
  常に暗黙裡にconst_reference?

---------------------------------------------------------------------
初期化関数の無駄打ちをやめる

1. private importとpimplイディオムが使えることを確認
2. 名前空間の初期化有無を調べるようにする
3. 初期化有無をinfファイルに書くようにする
4. 初期化が有る時だけinitを吐くようにする

---------------------------------------------------------------------
in-placeオブジェクト構築

struct foo { int x, int y };
vector{foo} v;
v.create_back(int x, int y) とされると、
foo(x, y)がvの末尾で実行され、そこにfooオブジェクトが構築される。
create_backはテンプレ

function void create_back(int x, int y)
{
  size_t const sz = size();
  foo mutable& p = push_back_uninitialized();
    /* 末尾にスペースを用意しアドレスを返すが、foo未構築 */
  extern "uninitialized" p = foo(x, y);
    /* 代入式だがplacement newをemitする */
    /* 例外投げることもあるが、vectorの場合はcatch不要 */
  set_valid_length(sz + 1);
}

catch allほしくなる。

extern "uninitialized"は、代入演算子のかわりにplacement newを
emitせよ、という意味。
代入演算子にplacement_newフラグを追加。
  -> やめ。未初期化代入演算子を用意。


---------------------------------------------------------------------
ioの下

io::file
  fcntl
io::dir
  unlink
  opendir
  readdir
  mkdir
  rmdir
  stat
  lstat
  link
  symlink
  readlink
  chdir
io::process
  _exit
  exit
  abort
  execv
  execvp

---------------------------------------------------------------------
メンバ関数的関数のlookup

namespace xにstruct foo定義
namespace y imports x
yでfooのメンバ関数的な関数を定義したい

namespace y;
public import x +;
function void foo_hoge() { ... }

namespace xのadditional lookupsとしてyを登録する。
x::foo_???のルックアップ時に、additional lookupsも探すようにする

---------------------------------------------------------------------
芋蔓importを楽に

namespace y imports x
xのすべてのシンボルをyのシンボルとして見えるようにしたい
yをprefixなしでimportすればxもprefixなしで見えるようにしたい

namespace foo;
import bar -; // fooの中からprefixなしでbarのシンボルを参照できる
import bar +; // fooをimportすると、bar::hogeとやるとfoo::hogeも探す
import bar *; // fooをimportすると、foo::hogeとやるとbar::hogeも探す

---------------------------------------------------------------------
弱ポインタをどう実現するか

strong+weakのカウンタ、strongのみのカウンタの二つを持つ。
前者のカウンタが0になったときに開放される。
後者のカウンタが0になると、指す先の値がnullに変わり、weakからstrong
を作れなくなる。

struct {t} weak_object {
  public t value;
    // tはデフォルト値を持つ型でなくてはならない
  private size_t strong_refcount;
    // strongがinc/decし、0でvalueをデフォルト値へリセット
}

struct {t} strong {
  t pointer; // t はweak_objectへのポインタ(ptr等)でなくてはならない
}

---------------------------------------------------------------------
thread-local pool allocator

8, 16, 32, 48, 64byte用プールを用意
(sz + 7) >> 3が
1,  2,  3,  4,  5,  6,  7,  8, 9以上
8, 16, 32, 32, 48, 48, 64, 64, ?


---------------------------------------------------------------------
Python

pxc_python
  function {t} void register_class()
    型tを登録する。実装は、init_chainに初期化関数をpushする。
    モジュールの地の文で呼ぶことを想定。
  register_class{t}をCから呼ぶのはどうやるか？

---------------------------------------------------------------------
弱ポインタを使った例

相互参照を含む複合オブジェクトをプールに作成
struct node {
  option{ptr{weak{node}}} next;
  option{ptr{weak{node}}} prev;
  string value;
}
struct object_pool {
  vector{strong{ptr{weak{node}}}} pool;
}

---------------------------------------------------------------------
SDL2 on Android

- SDL: 端末回転させると固まるのは、pause状態だとSDLThreadは
  Android_ResumeSem待ちで止まり、onDestroyが投げたQUITイベントを拾え
  ないから。SDL_ANDROID_BLOCK_ON_PAUSEが0だとおきない。
- SDL: SDL_ANDROID_BLOCK_ON_PAUSEを0にすると回転で固まらないが、
  激しくリーク。
- SDL: そもそも回転させるとonDestroyが呼ばれるのもおかしい。
  http://developer.android.com/guide/topics/resources/runtime-changes.html
  AndroidManifest.xmlの<activity>にandroid:configChangesを設定すると
  configuraionの変化でonDestroyが呼ばれなくなる
- SDL: 方針:
  - onDestroyは回転などで呼ばれないようにする
  - SDL_ANDROID_BLOCK_ON_PAUSEは0にする
  - onDestroyが呼ばれてmainが終了するときには_exit()してしまう。

---------------------------------------------------------------------
unsafe/use_unsafe

- namespaceでuse_unsafeかunsafeのどちらかを宣言しないとexternを使えない
- unsafeな名前空間をimportする場合も宣言が必要
- unsafeな名前空間をpublic importする場合はunsafeでなければならない?
  厳しすぎて使いにくい?
unsafe/use_unsafeなnamespaceでのみ使えるもの:
- expr_op::extop (placement-new)
- externなstruct, dunion, typedef, funcdef, interface
- expr_inline_c
- enumval
- plagma array bounds -> inline_cに含まれる

---------------------------------------------------------------------
演算子

二項 + - * / % | & ^ == != < > <= >= << >> 
単項 +-~!

---------------------------------------------------------------------
__getelem/__setelem

foo[x]の式は、fooがelemguardをサポートするコンテナではないとき、
operator::getelem(foo, x)へ置換する。ただし、foo[x] = 3 のように
代入の左辺だった場合は operator::setelem(foo, x, 3)へ置換する。
代入演算子としては'='のみ許す。

---------------------------------------------------------------------
variant的型へのmarshal方法再考

- int等の基本型は値でmarshal
- mutable byref引数は変更が反映されないが仕方なし
- byrefを返す関数、ephemeralを返す関数はscriptから呼べない
  それらはcopyableでないかもしれないから

---------------------------------------------------------------------
genericsとvariant

型に要求する条件がわからないとインスタンス化してよいか判断できない。
variantは常にインスタンス化できるべきでは？
それを実現するには...
- なんらかの型が受け入れられる箇所は全てvariantも受け入れる
  - if (hoge)
  - for でコンテナのイテレート
  - 全ての演算子

---------------------------------------------------------------------
noncopyableな値を返す関数は実現できないか？

RVO相当のことを常時おこなうような実装にすればよい。
const bar x = foo(a, b);
barがnoncopyableのとき、xのアロケートは呼び出し側が行い、fooへの隠し
引数としてポインタを渡す。呼ばれた時点ではまだbarオブジェクトとして
初期化はされていない。fooの中身についての制約がいくつか必要。
function bar foo(int a, int b)
{
  bar r = bar(a, b);
  ...
  return r;
}
function bar foo(int a, int b)
{
  return hoge(a, b);
}
1. fooの中のreturn式はすべて同じ変数を返す
2. fooの中のreturn式はすべて関数呼び出し
のどちらか。

例外が投げられたときはどうするか。
fooで例外が投げられたときはbarは未初期化に戻す。

void foo(int a, int b, bar& r__)
{
  new(r__) bar(a, b);
  /* r__が初期化されたので、これ以降例外が投げられると未初期化に戻す */
  try {
    ...
  } catch (...) {
    r__.~bar();
    throw;
  }
}
void foo(int a, int b, bar& r__)
{
  /* r__の初期化はhogeの中なので、fooではなにもしない */
  return hoge(a, b, r__);
}
呼び出し側
rvo<bar> x;
foo(a, b, x.get());
bar& x = x.get();
フィールドをrvoにした場合
struct fubar {
  rvo<bar> x;
  fubar(int a, int b) : x(foo(a, b, x)) { }
}

template <typename T> rvo : public T {
  rvo(const dummy& x) { }
  T& get() { return reinterpret_cast<T>(&buf); }
  T const& get() const { return reinterpret_cast<T>(&buf); }
  char buf[sizeof(T)];
};

rvoはdummyを受けるコンストラクタを持ち、中身は空
RVO可能な型は全てdummyコンストラクタを持つようにするか？
->ダメ。その型がnodefaultなフィールドを持つとそれを初期化できない。
  やはりwrapperをかぶせる?
全ての型にnoinitコンストラクタ持たせられるか？

rvo関数によってフィールドを初期化するようなコンストラクタを
どのように書くかが問題。

案1
- rvo可能な型はnoinitコンストラクタを持つ。
- noncopyableな型は必ずrvo可能。
- noncopyableなフィールドを持つ型のnoinitコンストラクタをどう実装するか？
  rvo可能でないフィールドも持っていることがあるが、それをnoinitする手段が無い
- フィールドの初期化にはrvo関数を使えないようにするか？

案2
- rvo可能な型はコンストラクタを使わずに初期化する

案3
- 全ての型にnoinitコンストラクタを持たせる
  ただしpodは不要
- rvo関数はdummyを返し、それをnoinitコンストラクタへ渡す

案4
- rvo初期化するフィールドだけはwrapperにし、フィールドアクセスはget()する。
  rvo初期化しないフィールドについてはwrapperを使わない
- wrapperはコピーコンストラクタとデストラクタは中身型のものにする。
- rvo初期化する変数はwrapperを定義してから参照変数を作る。

---------------------------------------------------------------------
perl.px整理

px関数呼び出しは、引数を一旦名前有り変数に置く(done)
  wrapされたオブジェクトのときはmutable byrefで
perl::symbols廃止、meta::symbol使う(done)
meta::symbolは型フィルタと関数フィルタを引数で指定できるようにする?
  型フィルタは is_concrete
  関数フィルタは 返値がbyrefでなくephemeralでもない
  最後に関数フィルタ適用するだけでよい？
  最後に型フィルタとしてcopyableなものに制限が必要

px関数呼び出しの引数
すべてのpx型はperlsvにwrapできる。
intやstringなどの型はperlの値をそのまま値渡しすることもできる。
値変換可能な型については、svの中身を見てwrap値か変換かを決める。

- pxメンバ関数をperlから呼べるようにする
- svarr.get()は生のSV*を返すようにし、無駄にperlsvを作らない。
- 型コンストラクタは型名のpackageのnewに定義
- メンバ関数やメンバぽい関数は型名のpackageに定義

---------------------------------------------------------------------
コンテナ要素の参照についての保証

コンテナ要素の参照は、その参照が有効な間、参照を取得した位置の
コンテナ要素の別名でありつづけることが保証される。つまり、その要素を
書き換えると、コンテナのその位置の要素が書き換わる。
参照をコンテナからデタッチするような方法で参照有効性を保証するような
やりかただと、上の性質が保証されなくなってしまう。

---------------------------------------------------------------------
コンテナ分類

                      key      mapped   multi    range
farray{t, n}          size_t   t        no       slice
darray{t}             size_t   t        no       slice
vector{t}             size_t   t        no       slice
deque{t}              size_t   t        no       slice
list{t}               unit     t        yes      map_range
tree_map{t, s}        t        s        no       map_range
tree_multimap{t, s}   t        s        yes      map_range
set{t}                t        unit     no       map_range
multiset{t}           t        unit     yes      map_range

---------------------------------------------------------------------
check_use_before_def

各フレームについて呼び出される。
そのフレームを前からイテレートし、
関数呼び出しがあればそのupvalueをuvarsに入れる
変数定義があれば、それがuvarsに既に入っていたらuse before defエラー
入れ子のblockもイテレートするが、入れ子のフレームは読み飛ばす。


---------------------------------------------------------------------
threadedなdllをコンパイル・ロードする手段

- 対象namespaceに含まれる特定の名前の関数が、プロファイルで指定された
  シグニチャを持つことを要請する。またthreadedでなければならない。
- 対象がthreaded namespaceであることを要請。したがって地の文は持たな
  い。main()は空。
- その特定の関数へのポインタを返す関数をextern "C"でemitする。

profileに emit_threaded_dll=foo::bar と指定する。
foo::bar:args  引数の型など
foo::bar:ret   返値の型など
foo::bar:name  関数の名前(文字列)
このprofileを指定してpxc hoge.pxすると、hoge::(名前) の関数の型を
チェックしたうえで、その関数ポインタを返す関数をpxc_threaded_dll
としてemitする。hogeはthreaded namespaceでなければならない。

---------------------------------------------------------------------
thread改修

make_threadは関数をパラメタに取る。make_thread呼び出しにその関数の
パラメタを渡す。evalするとその関数の返値が返ってくる。
  interface {t} uneval { function t eval(); }
  function foo hoge(bar x) { ... }
  uneval{foo} x = make_thread{hoge}(x);
  foo y = x.eval();
現在のthread実装でこれをwrapする方法

interface {t} uneval { function t eval(); }
multithreaded struct {f}
uneval_thread_params(tptr{farg} const& a, tptr{fret} const& r)
{
  tptr{farg} argp = a;
  tptr{fret} retp = r;
  void main() {
    *retp = f(*argp);
  }
}
struct {f} uneval_thread(tptr{fargs} const& a) <uneval{t}> { 
  tptr{fret} retp = to_tptr{fret}();
  thread thr = make_thread(uneval_thread_params(a, retp));
  function fret eval() {
    thr.join();
    return *retp;
  }
}

---------------------------------------------------------------------
例外クラスの継承

logic_error_st/runtime_error_st/bad_alloc_st はそれぞれ
std::logic_error等をnon-virtualな基底クラスにしている。
これらの複数を継承するとexceptionへupcastできない。
 ... std::exception is an ambiguous base of foo

---------------------------------------------------------------------
例外再整理

インタフェース
c_exception                        : c++のstd::exception
c_logic_error <c_exception>        : c++のstd::logic_error
c_runtime_error <c_exception>      : c++のstd::runtime_error
c_bad_alloc <c_exception>          : c++のstd::bad_alloc
exception { function string message() const; }
logic_error <exception>
runtime_error <exception>
bad_alloc <exception>

pxcの例外は c++のレベルで
exception をvirtual、
c++のstd::runtime_error等を非virtual継承。

例外型は全てc_exceptionをc++のレベルでは継承しているが、pxcレベルでは
  exceptionはc_exceptionを継承していない。


具体型


---------------------------------------------------------------------
function expand

定義:
  function {args} void hoge() { expand (sym, idx : args) { ... } }
  展開の部品取り用関数。この関数は普通に呼ぶとエラーになるかもしれない。
適用:
  expand hoge{args};
  関数hogeの中のexpand式の内容が展開される。


---------------------------------------------------------------------
ephemeral型の制約緩和

vector{cstrref}などが使えるように
- テンプレパラメータやフィールドにephemeralなものを使うことを許可
- ただしそれらを使った型はそれ自体がephemeralになる
  - テンプレパラメータにephemeralなものを含むならephemeral
  - フィールドにephemeralなものを含むならephemeral
      - フィールドは無理？ フィールドにephemeralなものを含めて、メンバ
        関数から渡ってきたephemeralな値をそこへ代入してしまったら？
	初期化以外の代入が許可されていないからよいのか？
  - ephemeral: 初期化以外の代入不可、要素取得以外のreturn不可

is_partially_ephemeral_type (is_peph)
  1. typefamilyがrangeかephemeralなら真 (従来の定義はこれだけ)
  2. structのfieldにis_partially_ephemeral_typeのものを含めば真
  3. 既約型式がパラメタにis_partially_ephemeral_typeのものを含めば真

制約についての考え方
- 根本的には、ephemeralオブジェクトはstackが巻戻ると無効になる
- コンテナ要素に入れられるのは、そのコンテナより上位のephemeralオブ
  ジェクトだけである

案1 is_pephな型についての制約
- グローバル変数にはis_peph型は不許可。
- 初期化以外の代入の左辺には使えない。
  代入の左右で寿命が違うことがあるから。
- returnで返せない。ただしexternな関数は返すことができるが、その場合
  最初の引数が有効なうちは返した値が有効であるように実装せねばならい。
- mutable参照渡しできない。
- mutableメンバ関数を呼べるのは、そのオブジェクトを作ったブロックの中
  だけ。
    function foo(vector{cstrref} mutable& vs) {
      cstrref s = "hoge";
      vs.push_back(s); // fooを抜けると無効な値がvsに残る
    }
  mutableなpephは禁止しておく。

例: vector{cstrref}はどのような制約を加えれば安全か
- vector{cstrref}はglobal変数やfieldにはできない
- スタック上にconst変数を宣言するのはOK。
- make_vector{cstrref, tlst}の中ではvector{cstrref} mutableはOK。

is_noheap
  - ephemeralファミリ、rangeファミリはis_noheapである
  - コンテナであり、その要素がis_noheapならばis_noheapである

コンテナとrange以外のテンプレ型が、テンプレ引数にis_noheapを持つと
エラー。フィールドの型が、is_noheapであればエラー。

noheapの変数は、
  - スタック上の変数に限る。フィールドには使えない。
  - constに限る
ただしextern "disable-noheap-restriction" 1のときはチェックしない。
  - このディレクティブはmake_vector等がmutable変数を作るために使う。

改修手順:
  is_noheap_type()を定義。
  is_ephemeral_value_type()呼び出しをis_noheap_type()に置き換え
  check_term_validity()の中、
    const bool tp_allow_ephemeral =
      !is_type(t) || is_container_family(t) || is_cm_range_family(t)
  に変更
  ついでにallow_ephemeral -> allow_noheap にsed
  変数定義のcheck_term_validity()は、constならallow_noheap。
  make_farray等の中にextern "disable-noheap-restriction" 1を入れる
  disable-noheap-restrictionを実装
  is_ephemeral_value_type削除

制約緩和第二弾でnoheapをfieldにも置けるようにする。その場合構造体自体
もnoheapになる。fieldはconstでなければならない。

---------------------------------------------------------------------
ephemeral型の制約緩和#2

noheap型はヒープに置けない。ptr{t}はtがnoheapであったらエラー。


---------------------------------------------------------------------
数値リテラルからキャストしなくてすむように

暗黙の変換の範囲チェック。

数値リテラル: int_literal, unary op, teの評価結果がis_long()。

---------------------------------------------------------------------
metalistを { ... } で

metafunction hoge { x, y, z }; // リスト
metafunction hoge { x, y, z } fuga { x, y, z }; // hoge{x, y, z}の定義
TOK_METAFUNCTION TOK_SYMBOL type_arg ';'
TOK_METAFUNCTION TOK_SYMBOL type_arg type_arg ';'
仮引数宣言もtype_arg(expr_te)としてパースし、あとでexpr_tparamsへ変換

---------------------------------------------------------------------
fileの再整理

目的:
 - closeの実現とスレッド間共有を両立。
 - file自体はbox化してcopyableにする。
file_repがfile descriptorを保持し、デストラクタでclose。
明示的closeも可能にすると、file_repをmutableにする必要がある。
一方file_repをmutableにするとスレッド間共有で直列化してしまう。

実装案:
threaded file: ダミーのインタフェース
threaded file_st <file>: シングルスレッド、close可能
multithreaded file_mt <file>: マルチスレッド、close不可
ファイルを開く関数は_stと_mt両方用意するか、必要無いなら_mtだけ用意。
fileのC++実体はiptr{file_rep}。
_stも_mtもC++実体はfileを継承。
fileはインタフェースなのでincref$z, decref$z, get_count$z, lock$z,
  unlock$z, wait$z等を実装。_stはlock関連の実装は空。_mtはlock関連を
  実装する。

案2:
threaded file: ファイル共通のインタフェース。実装はfdを保持。
threaded file_st <file>: close可能
multithreaded file_mt <file>: close不可
multithreaded socket <file_mt>: socket操作が可能
multithreaded socket_listener <socket>: listenが可能

openはptr{file_st}を返す。open_mtはtcptr{file_mt}を返す。
socket関連はtcptr{socket}を返す。

file_stとfile_mtは両方継承してはいけない。それを防止するためには
これらをexternにして、pxcでは実装できない関数を純粋仮想関数にする。


---------------------------------------------------------------------
variantとinterface

049_variant
variant_invoke_impl(cslice{variant} const& args, obj?)
{
  /* 関数またはメソッドfの各引数について */
  expand (ae, idx: func_argexp_list{f}) {
    /* idynamicからstub_object{引数型}へdowncastし、それのvalueを
       取得 */
    func_arg_type_noneph{f, idx} const& ae =
      downcast_const{
	stub_object{func_arg_type_noneph{f, idx}}, idynamic
      }(*(args[idx].ptrval)).value;
    /* もし引数型がinterfaceならstub_object{インタフェース}をイン
       スタンス化して、はまる。 */
  }
}

---------------------------------------------------------------------
deserializeのコピー除去

defconでない -> pointer
defconで作ってその位置に構築したほうが速い -> コンテナ
defcon使わないほうが速い -> intなど

- deserialize_emplace_preferred{t}
  defconでないならfalse
  intのような単純型ならfalse
  それ以外ならtrue
- deserialize_emplaceはdefconのときのみ使える
- deserialize_constructはdefconでなくても使える
- deserialize_vardef{tpl, src, v}  変数宣言しdeserializeするマクロ

案2:
- make_defaultでpointerでもデフォルト値を作る
- deserializeはemplaceのみ -> だめ
- emplaceで不可能なケース
  assignableでない - darray, constなfieldをもつstruct
  - darrayとstructのみ
- emplaceのほうが効率悪いケース
  - cptrは指す先を作ってからboxしないといけないのでemplaceは効率悪い

- コンストラクタを持つstructはretval、そうでないならemplace
- コンテナは、darrayはretval、それ以外はemplace
- pointerは指す先がconstならretval, それ以外なら指す先のemplace方針

---------------------------------------------------------------------
private namespace

private namespaceのpublicシンボルは、親namespaceからのみ参照できる。
symbol_commonの参照元と参照先の名前空間を比較する
リフレクションではprivate namespaceの中身は見えない
importsはprivate namespaceをスキップ

---------------------------------------------------------------------
参照のblockscope root

- 暗黙変換がbyref又はnoheap型を返すとエラー(done)
- add_root_requirement: function returning value && passby reference
  && blockscope のときstore_tempvarするが、functionだけでなく値を返す
  opでも同様のことをやる必要は無いのか。またconversionがあったときは？
  - store_tempvarが必要なのは型にguardがある場合だけ。guardが無い場合
    は const foo& x = func_ret_foo() の式はブロック末まで有効になる
    ことがc++的に保証されているのと、mutable refで受けるのはpxc的に
    許容していない。(done)
  - 組み込みopについてはblockscopeなら常にstore_tempvarしている(bscpval)
    (25/blockscope_val3) (done)
  - conversion結果値を返す式については？ conversion結果、値を返し、
    それをblockscope passby referenceでrootされるケース？-> implicit
    conversionでstringに変換し、その[3]をblockscope byref ->
    どうやって？ -> わからないがstore_tempvarにチェックを入れる(done)
  - implicit_conversion適用された場合、store_tempvarで変換元をroot
    したところで、変換先のblockscope rootは保証されないのでは？
    -> エラーになるようにした(done)
- store_tempvar(bscpval)は operator || などの非strict関数の右辺も評価
  してしまわないか？ (done)
- 三項演算子の : をstore_tempvarしてはいけない (done)
- 三項演算子をblockscopeでrootするには？ -> noheap型を返すときはエラー
  とする(125/condvar) (done)
- bugfix: 025/val.px, blockscope_val?.px(done)

---------------------------------------------------------------------
svector

共有vector。参照カウントでrepを共有。svectorをthread間では共有できない。
書き換えてもrepを分離しない(copy-on-writeではない)。
リサイズしたら(realloc不要であっても)常にrepを分離する。
svectorのsliceは、ポインタ二つ + svector

---------------------------------------------------------------------
vectorとguard改革案整理

- vectorの実装は、svector
- sliceの実装は、svectorのslice
- vectorのコピーコンストラクタや代入演算子は中身のコピーを生じる
- sliceも参照保持するのは、sliceが無効化するまでにvector自体がリサイズ
  されてrepが分離しても、sliceの指す先は無効化されないようにするため。
- tree_mapなど他のコンテナについても同様に参照カウント実装に変える。
- guard_refとguard_valは廃止。tptrはlock_guard必須にする

---------------------------------------------------------------------
guard_ref/guard_val

guardを持つ型はそのメンバとしてguard_refとguard_valを定義する。
そのオブジェクトが消えるまでガードする。
コンテナがスライスされる場合のためにget_range()などを定義する。
Tc& get()
Tc::range_type get_range()
Tc::crange_type get_crange()


---------------------------------------------------------------------
svector

文字列リテラルやsliceから const svcetor をスタック上に作るとrefcnt==0
のrepを使う。構造体メンバとしてsvectorを作るときはだめ。
template <typename T, size_t sz> struct svector_ephemeral : svector {
  svector_rep eph_rep;
  T buf[sz];
  svector(T *p, size_t sz) { eph_rep.valid_len = sz; ptr = p; rep = &eph_rep; }
}
コピーさけられない。やめるか？


---------------------------------------------------------------------
汎用tableパーザ

fld1をそのままkeyに、fld2をmapped、たたみこみは加算
keyを関数にできるようにする。
mappedを関数にできるようにする。たたみこみと合わせて一つの関数。

各フィールド又は複数フィールドについて、
- それらの値を取り何らかの値を返す関数
- それらを集約する関数。しない場合はキーになる。
出力
- ソート関数

record型の上のmonoid構造についてのfoldingを、fieldのmonoid構造と
キーの指定によって定義する。
- レコードからキーを返す関数
- mappedの初期値を返す関数(キーを引数に取る?)
- mappedをfoldする関数(キーを引数にとる?)
select f1, sum(f2) from tbl group by f1

function void fold_records(trecs mutable& recs, trec const& rec)
{
}

keyが型tuple{int, string, int} フィールド{0, 1, 4}
mappedがadd{int} フィールド
list{0, int, 1, string, 4, int, 3, add{int}, 2, last{int}};
フィールド1, 4, 3をキーにしたmapを作り、
フィールド3の値については加算
フィールド2の値については上書き

各レコードをfieldsにsplitしたあと、必要なfieldだけを取り出す関数
を適用(その関数は関数アダプタで合成)する。それの結果の最初の引数
がキー、残りがmappedになる。

キーをmapから探し、レコード参照を取る。そのレコードのmappedの
フィールドに対し各々mapped関数を適用する。

ソート関数を適用。

records->recordsの関数の合成として実現する。レコード単位の変換と、
全レコード貯めるものとの二種類ある。foldやsortするのは後者。

continuation的に次段階の関数を受けとるか。

recordsからrecordsを返す関数を、保持するデータ型とrecordコールバックの
組で定義する。
struct table1(tcontinuation c) {
  /* some data  */
  bool push(tfield0 fld0, tfield1 fld1, ...) { }
  void end() { }
}
最終段でファイルに出力することができる。エラーは例外で。
struct {t} records_to_file(file ofile) {
  bool push(expand(...)) { }
  void end() { }
}
最終段はコンテナに値を格納することもできる。

後段は複数もつこともできる。
合成は、再終段のオブジェクトから順に作り前段のコンストラクタに渡す。

最前段は各レコードをパースして型付けられたfieldのリストに渡す処理。
またはコンテナから後段へ順に渡す処理。

一つのsourceを複数のsinkへコピーしたり、複数のsourceをmergeも。

- レコードをパースして各フィールドの開始オフセットを調べる。
- フィールド変換関数を呼び出す。
  { 0, string, { 1, 2 }, foo }

function {param, tsink} bool
convert_fields(tsink mutable& sink, cstrref const& str,
  cslice{size_t} const& offsets)
{
  expand(p: param) {
    t0 a0 = convert{?)(str[0]);
    t1 a1 = foo(convert{?}(str[0]), convert{?}(str[1]));
  }
  return sink.push(expand(a0, a1, ...));
}

一般に関数合成テンプレートをどう作るか。
[fubar, 0, 1, 2, hoge, 1, fuga, 3, foobar]
  0, 1, 2番めの引数をhogeに適用した結果をa0,
  1番めの引数をfugaに適用した結果をa1,
  3番めの引数をfoobarに適用した結果をa2
  これを引数にして関数fubar(a0, a1, a2)

メタ関数でつくるのではなく、単に関数
  fubar(hoge(a[0], a[1], a[2]), fuga(a[1]), foobar(a[3]))
を渡すようにするか。aはcsrefarr型。
 -> いまいち。csrefarr一つを引数とする場合にしか使えない。

composite{[fubar, [hoge, 0, 1, 2], [fuga, 1], [foobar, 3], 4]}
fubar(hoge(a0, a1, a2), fuga(a1), foobar(a3), a4)
  -> これは実装できそう。無名関数とちがって引数と返値型を指定不要。

read_recordsはcstrref複数引数の関数をテンプレパラメータとして取り、
レコード毎にそれを呼び出す。

tableオブジェクトは
フォーマットを表す型リストをtparamとして取る。
putメソッドは複数引数を取る。
foreachメソッドは複数引数の関数をtparamとして取る。

ifileは
foreachメソッドは複数引数の関数をtparamとして取る。

ofileは
putメソッドは複数引数を取る。
デストラクタでflushするか。

table, ifile, ofileのそれぞれの間に変換関数を挟み込む。

まずは function {delim} cstrref read_token(cstrref mutable& buf) を実装

datasource: foreach{cb}() でレコード毎にcbを呼び出すことができる。cbの
  引数は任意個、各々は任意の値型。
datasink: put(...)でレコードを追加できる。putの引数は任意個、各々は任意の
  値型。
datatrans: datasourceとdatasinkの間に入るテンプレート関数。datasinkの
  putをテンプレパラメータとして取り、datasourceからのcbに丁度合う関数
  を返す(実装する)。できることは、関数合成による変換、limit、フィルタ。

map: datasinkでもありdatasourceでもある。putでレコードを追加し、foreach
  で取り出す。最初のn個のfieldはキーであり残りはmapped。mappedは単なる
  値型ではなくmonoid。
  集約関数: sum, average, count, min, max
multimap: mapとのちがいは最初のn個のfieldについてsortするだけでfoldし
  ない点。
逆順をどう実現するか？

{
  {ifile{"stdin", string, int, int, int}},
  {table_map{[string, int], [sum{int}, min{int}]}, 0, 1, 2, 3},
  {table_multimap{[int, int], [string, int]}, 2, 3, 0, 1},
  {ofile{"stdout", string, int, int, int}, 0, 1, 2, 3}
}

if (mutable m : mapval[k]) {
  m += v;
} else {
  mapval.insert(k, v);
}

tableはread_recordsを実装。レコード毎にcbを呼び出す。
transformはin, outテーブルと変換関数を引数にとる。
ifileは行を区切るしかしない。フィールドに分けるのは変換関数。
ofileも行のみを受ける。フィールドを結合するのは変換関数。
  -> ofileは自分で結合したほうが効率良い。

変換関数: レコード単位の変換をおこなう関数
  フィールドを分割、結合 (tsplit, tsplit_re, tjoin)
  フィールドの順序を入れ替え、コピー、関数を適用する (tapply)
  特定条件のレコードをskipする、あるいは変換をそこで終了する。

変換関数も状態をもつことができる。文字列のエンコード処理などは
バッファを持たせたい。

function {itl, cb} bool tsplit(cstrref const& rec)
{
  /* cbの引数型をみて分割 */
  return cb(...);
}

function {itl, cb} bool tjoin(...)
{
  return 
}

function {app, itl, cb} bool tapply(...)
{
  return cb(expand(itlをappで順序いれかえたもの));
}

transformはin, out, レコード変換関数オブジェクトのリストを引数に取る。

struct {f} tr_function_object {
  function {cb} bool apply(arg_types{f}) {
    return f{cb}(args);
  }
}

118_table

---------------------------------------------------------------------
eval_apply_internal

term_lambda:
  std::vector<expr_tparams *> upvalues;
  expr_tparams *const tparams;
  const term v;
term_bind:
  expr_tparams *const tp;
  const term tpv;
  const term tpv_lexctx;
  const bool is_upvalue;
  const term_next; /* term_bind or term_lambda */


if (s == term_sort_lambda || s == term_sort_bind) {
  size_t nbind = 0;
  const term *cur = &tm; /* bindかlambdaを指す */
  while (tp != 0) { /* 既に適用済みのbindの数を計算 */
    ...
    cur = cur->get_bind_next(); /* curは次のbind又はlambdaへ移動 */
    ...
  }
  この時点でcurはlambdaを指している
  term ntm = tm; /* tmにさらにbindを追加した式をここに作る */
  expr_tparams *ltpms = cur->get_lambda_tparams();
  while (ltpms != 0) { /* lambdaが尽きるまで */
    while (ltpms != 0 && nbind > 0) {
      /* this param is already bound */
      ltpms = tlpms->rest;
      --nbind;
    }
    while (ltpms != 0 && args_bindcnt < args.size()) {
      /* bind this param */
      term arg = eval_if_unevaluated(args[args_bindcnt], targs_evaluated,
	ectx, pos); /* eager evaluation */
      ntm = term(ltpms, arg, term(), false, ntm); /* term_bind */
      ltpms = ltpms->rest;
      ++args_bindcnt;
    }
  }

}

---------------------------------------------------------------------
json

deserialize_macroの動作
cstrref mutable& srcの前から削り、ターゲット型へ変換する。
srcには無駄な空白があるかもしれないから削る必要がある。
des_struct_begin_condのようなcond関数は、期待するトークンであればtrue
を返す。trueを返したときはトークンは削られる。

- string_parse_tokenの最初にskip_space入れる
- string_parse_token_skipも同様。token_length使っている場所は同様。

055_serialize/json1.px

des_struct_sep_condを入れるのをループの末尾にするべし

---------------------------------------------------------------------
epoll

epoll_dataを構築するときに fd に関連付けられる。fdはcloseできてはなら
ないので、file_mt でなくてはならない。 epoll_dataのデストラクタが
関連付けを外す。epoll()が返すイベントリストの各エントリは、epoll_data
の参照カウントを1つ保持しなければならない。なぜならそのイベントが解放
されるまではepoll_dataは有効なポインタでなければならないから。

-> 複数スレッドで動かすとポインタの有効性が保証できなくなる

やりなおし
epoll_eventに生ポインタを付けるのはやめて、ファイルデスクリプタ番号
を付ける。fd再利用によってイベントが誤爆したところで何ら問題は起きない。
fdからハンドラオブジェクトへの対応はarrayなりmapで。

edge-triggeredのときにしかマルチスレッドで

---------------------------------------------------------------------
python

- 演算子
- double
- python例外オブジェクト
- pxc noncopyable
- pxc関数をpy関数に変換
- pxcstringをpyobjectにwrapするのはやめるか

---------------------------------------------------------------------
動的フィールド

x.foo の式は、次の条件を満たすと動的フィールド参照に置き換わる
- 右辺がシンボル(funccallではない)
- xの型がtxとすると、txの名前空間に tx___getfldが定義されている


---------------------------------------------------------------------
シンボルテーブルを引く処理

nsaliases[(u, astr)]
  iがこのリストに入っているのは、名前空間iをエイリアスastrの名前で
  名前空間uからimportされているとき。astrは空のときprefix無しimport。
  => ns無しシンボルを引くとき、(curns, "")のリストの各iについて、
     iを名前空間として付けたものも引く
  => ns付きシンボルを引くとき、(curns, ns)のリストの各iについて、
     名前空間をiに付け替えたものも引く。
nschains[u]
  iがこのリストに入っているのは、名前空間uがiを全importしているとき。
  => ns無しシンボルを引くとき、curnsがuをprefix無しimportしているとき
     は、iを名前空間に付けたものも引く
nsextends[u]
  iがuをextendしているとき。
  => uへのシンボル引きがあったときは名前空間をiに付け替えたものも引く。

名前空間付きfullname:
1. nspartがcurnsのaliasに入っている場合をのぞき、fullnameをglobalテーブル
   から引く。
2. nspartがcurnsのaliasではないなら、nsextends[nspart]の各々について、
   nspartをそれで置き換えたものを引く。
3. nspartがcurnsのaliasなら、nsaliases[(curns, nspart)]の各iについて、
   nspartをiで置き換えたものを引く。
   さらに各iについて、nsextends[nspart]の各jについて、nspartをjで置き換えた
   ものを引く

---------------------------------------------------------------------
error処理整理

- errno_or_value{t}の期待しないfieldが読まれると errno$$r() が呼ばれて
  invalid_field()が投げられる　
- pxcのコードがunion fieldでアクセスするときは、もっと親切な例外を投げる
  ようにしたい。

案:
- foo.fld の fooがunionだったら、operator::union_field{foo, "fld"}に
  置き換える

  if (const x : foo.fld) { ... }
  expr_ifのblock1->argdeclsが!=0で、condがeopで、op=='.'かTOK_ARROW

  case foo.fld
  parentがop==TOK_CASE

---------------------------------------------------------------------
chm2

hashmap_bucketsがそのままhash_map。
hashmap_buckets_hdrにrefcnt。
refcntが1より大きければrehashしない。
for文は専用の二重ループを用意する。
rangeは無い。

---------------------------------------------------------------------
openglのsafe wrapper

頂点配列は使わず、常に頂点バッファオブジェクトを使うことを前提。
プログラマブルシェーダ前提。

VBOハンドルが大きさ(bytes)を保持している。
glGenBuffers(1, &buf); でハンドルを作る
glBindBuffer(GL_ARRAY_BUFFER, &buf);
glBufferData(GL_ARRAY_BUFRER, src_bytes, src, GL_STATIC_DRAW); で転送

glGetActiveUniformとglGetActiveAttribでuniformとattributeの名前と型の
一覧が取れる。これを使えばmemory safeにできる。

VBOにはint配列やfloat配列などの型のデータを置ける。さらに「要素配列型」
のデータも置ける。これはglDrawElementsで使う要素配列。

VBOデータ作成

- glGenBuffers(1, &vbo_name) でVBO作成
- glBindBuffer(GL_ARRAY_BUFFER, &vbo_name)
  glBufferData(GL_ARRAY_BUFFER, src_bytes, src, GL_STATIC_DRAW)
- (要素配列を使うなら)
  glGenBuffers(1, &evbo_name) でVBO作成
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, &evbo_name)
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, src_bytes, src, GL_STATIC_DRAW)

描画の流れ

- 頂点のattrib変数をloc_vertex, 法線のattrib変数をloc_normalとする。
- glBindBuffer(GL_ARRAY_BUFFER, vbo_name) でVBOを指定
- attrib変数が要素ごとに可変であれば
    glEnableVertexAttribArray(loc_vertex)
  そうでないなら
    glVertexAttrib3f(loc_normal, 0.0, 0.0, 1.0)
  のように即値を指定する。
- glVertexAttribPointer(loc_vertex, 3, GL_FLOAT, 0, 0, offset)
  として、loc_vertexにつっこむ配列始点のVBO中オフセット位置を指定。
- (glDrawArraysのとき)
  - glDrawArrays(GL_TRIANGLES, 0, num) のようにして描画
- (glDrawElementsのとき)
  - glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo_name) で要素配列
    のVBO指定
  - glDrawElements(GL_TRIANGLES, num, GL_UNSIGNED_INT, offset)
    のようにして描画

memory safeにするために

要素配列のVBOは、どのVBOを指す要素配列なのかを指定したうえで、
glBufferDataでデータを流し込む際に、各値が、指す先の配列の範囲外
にならないかをチェックしなければならない。範囲チェックのためには
指す先の型(floatなど)を決めねばならない。また、データを流し込んだ
あとは、指す先のVBOが削除されてはならず、サイズを縮小してもなら
ない。
  element_array_uchar_float

シェーダをコンパイルしてglLinkProgramするとuniformなどのlocation
が取得可能になる。

---------------------------------------------------------------------
operator::eq

operator::eqなどのboolを返す演算のstructに対する定義
各fieldについてeqを取ったもののandだが、短絡評価できる。
{
  if (x.fld0 != y.fld0) { return false; }
  if (x.fld1 != y.fld1) { return false; }
  return true;
}

eq, ne, gt, lt, ge, le


---------------------------------------------------------------------
functor

型fooについて foo_fmap が定義されていればファンクタ。

fmapは、テンプレ引数として関数fを取り、引数としてリスト的な値を取る
f: t0 -> t1
fmap{foo, f}: foo{t0} -> foo{t1}

m::base{tx} で txの一番外側のテンプレを返す。例えば
m::base{vector{int}} => vector 。

function {f, tx} pair{m::ret_type{f}} pair_fmap(tx const& x)
{
  return make_pair(f(x.first), f(x.second));
}

function {f, tx} vector{m::ret_type{f}} vector_fmap(tx const& x)
{
  vector{m::ret_type{f}} r;
  r.resize(x.size());
  for (const& k, const& v: x) { r[k] = x; }
  return r;
}

連想配列の場合はmapped型に適用する
function {f, tx} tree_map{m::at0{tx}, m::ret_type{f}}
tree_map_fmap(tx const& x)
{
  tree_map{m::at0{tx}, m::ret_type{f}} r;
  for (const& k, const& v: x) { r[k] = f(x); }
  return r;
}

metafunction fmap_ret_type{f, tx} m::apply_list{m::base{tx}

function {f, tx}
m::ret_type{m::symbol{m::nsof{tx}, m::concat{tx, "_fmap"}}}
fmap(tx x)
{
  return m::symbol{m::nsof{tx}, m::concat{tx, "_fmap"}}(x);
}

---------------------------------------------------------------------
一般化されたfold

- 型tの構成子foo, barに対し、それぞれ関数hoge, fugaで置き換えた式
- 列コンテナだけが特殊で、nil/consが構成子と見做す
- function {funcs, t} ret_type{m::at0{funcs}} fold(t const& x)
  {
    if (const v: x.foo) { return m::at0{funcs}(v); }
    if (const v: x.bar) { return m::at1{funcs}(v); }
  }
- unionの構成子を関数として返すメタ関数が欲しいところ

---------------------------------------------------------------------
マクロ展開を許可するステートメント種類

toplevel_stmt
        : body_stmt
        | ext_stmt ダメ。namespaceやimportなど。
        | c_enumval_stmt 外部enum値。許可。
        | defs_stmt
        | enum_stmt
        | visi_vardef_stmt
        ;
function_body_stmt
        : body_stmt
        | defs_stmt
        | TOK_EXTERN TOK_STRLIT type_arg ';'
          { $$ = expr_inline_c_new(cur_fname, @1.first_line,
                arena_dequote_strdup($2), "", false, $3); }
          /* for pragma */
        ;

