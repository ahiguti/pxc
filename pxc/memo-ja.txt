
0616 779
---------------------------------------------------------------------
FIXME/TODO M1

- 例外の使い方

- test_61_remote

- te_to_term -> expr_to_term
  数値リテラルなどは変換してしまう
  termにterm_applyを用意してexpr_to_termで可能な限り変換、
  eval_apply_exprのswitchをなくす

- cleanするときにフォルダがないとエラーになるのは無視するべき

- fn_check_finalから無駄にresolve_texpr()されて遅い(done)

- EVAL_LAZYのcycle可能性を除去 やめ

- evalのtargs_evaluated除去
  strictメタ関数からもう一度evalされたときにtargs_evaluatedがtrue
  になるが、これらをnonstrictに変更すればよい？

- evalのterm_listコンストラクトのコスト除去

- has_unbound_tparam, term_has_unevaluated_exprの意味を整理

- term_tostrのterm_bindとterm_lambda

- termの同一性とterm_tostr_strictの同一性は一致しなければならない
  シンボル生成にterm_tostr_strictを使っているから。

- metafunctionはlexical contextを持つようにする(done)

- term.cpp: operator <のlambdaはtparamsも比較

- 関数呼び出しをexpandする? - blockのかわりに

- インスタンス化しないときにargsの型を評価するのをやめる?

- inheritsに同じものを複数回指定するとどうなるか？

- rpc: remoteハンドルに対して関数を呼び出す
  orb { ns_functions funcs; string rbuf; string wbuf; } のように

- orb: exceptions

- trace_meta should not be an extern pragma

- まずmarshal by reference無しのRPC作る

- string/util.px split

- create_fooに統一する？

- tagged unionの$eと$uをやめる。gdbで見るとき困る。

- ptr(foo(...)) の式が変数定義の右辺ではないとき、fooのコピーコンスト
  ラクタを要求してしまう(skip_49_variant_fixme3)

- expand型foreachを削除

- 演算子オーバーロードは、組み込み型以外のopに対して関数呼び出し式を
  evalすることによって実装チェック、その関数を呼ぶようにemit。

- ccだけ吐くモード -> androidに必要
- ヘッダファイルを吐くモード

- プロセスをforkしてpipe経由で通信するパターン
  - バイト列の通信(popen的なもの)
  - ORB的なもの

- 名前空間整理

- numeric/positionalからserialize/numericへ移動

- stringをpxcvectorに統合?

- globalにdefconでない型の変数を置くとエラー

- test_07_constr/ud4fixme.px ユーザ定義コンストラクタが無いのに実行文
  をstructに書くとエラーになる。
  -> udconでなければ実行文を書けないようにする(done)
  -> 引数が空のudconを作れるようにする。そのような型はdefcon。

- tagged unionの実装がstrict-aliasing rulesを破っている。これを直す
  にはC++11のunionが必要。-fno-strict-aliasつけておく。C++11前提に
  するならunrestricted unionを使ってtagged union実装する。
  -> may_alias属性を付ければC++11要らないが、gccの警告が動作怪しい。
  -> std::mapの中でもstrict aliasing警告出る...
    struct compare{bool operator()(const int&x, const int&y)
      { return x<y; } };
    (http://gcc.gnu.org/bugzilla/show_bug.cgi?id=42087
     Bug 42087 - stl::map breaks strict-aliasing rules)

- awk的なもの

- from_stringを用意してbuiltin.pxのstring_to_*を削除。

- byvalueを要求されたら参照を返す関数のかわりに値を返す関数をemit
  無効化されるのを防ぐため。-> 確認

- lockobject{int} lck = sobj;  これが通るように
- var lck = lockobject(sobj); これも

- injectns消す

- union の初期化を一発でできる構文を用意

- object counter

- structのコンストラクタがexternのとき、引数がnoncopyableであっても
  pxcエラーチェックできずC++エラーになってしまう。引数がcopyableであ
  ることを要請する手段が必要。(ただしptr{file}のようにfast boxingで
  きるときはnoncopyableでもよいことに注意)
  -> struct等にmacro __check__が定義されていればevalする
  -> ポインタについては引数型はcopyableでなくてよい
  -> それ以外のテンプレ型についてはcopyableを要請
  -> farray, darrayはdefconも要請
  
- pxcvectorにstringと同じだけのメソッド定義
  - insertとerase(done)
  - findはいらない？

- enum, bitmaskのコンパイル時リフレクション
- external int/uintを整数リテラルからコンストラクトできない
- 算術演算子は左右どちらへも変換できるように

- std::set_new_handlerでstd::bad_allocではなくpxcrt::bad_allocを投げる

ephemeral型まわり
- test: globalやstructには参照変数などは置けないように
- test: 構造体にslice等のephemeral型を含む型のfieldを置けないように

- structコンストラクタに対するcheck_return_expr()

- too many argument for ... を共通化

---------------------------------------------------------------------
FIXME/TODO M2

- darrayのalloca使った実装

- C++名前空間をすべて絶対参照で

- expr.cppで組み込み型にtype::builtinをセットしているのをやめて、
  serializeなどではtype::builtinではない名前空間を使うようにする

実装が不明確なところ
- threadまわりの仕様再整理せよ
- 演算子の一通りテスト作成。コンテナ含め。
- type familyの仕様文書化
- 決定済みの仕様をメモに蓄積、テストケースと関連付け。
- 全ポインタ型とinterfaceの組み合わせ(モニタ等埋め込みが正しいか)確認

---------------------------------------------------------------------
TEST TODO M3

- test_14_root/refvar.px
- test_14_root/condtemp.px refvarが無いエラーになるように
- std::vector<bool>を使ってしまうと要素への参照が取れない

---------------------------------------------------------------------
TEST TODO M4

- tpupを引数で参照渡しするときのconstnessが正しいコードを吐いているか
- fn_check_rootテスト
- check_return_exprテスト
- テスト: fn_check_root廃止、rootはchecktypeの中で。
- ユーザ定義constructorを持つ型のdefault constructible判定が正しいか
- 型のパラメータにclosureやメソッドを使うと正しくエラーになるか？
- 型パラメータの文字列と数値がescapeされているか確認

---------------------------------------------------------------------
FIXME/TODO M5

- gcc-4.4.4のバグ？ -Wswitch-enumが効いていない しばらくgcc34を使う
- cflagsの与え方など確定
- interfaceの配列のように、テンプレパラメータが具体型でないといけない
  ケースのチェック。特にC++テンプレ型(固定長配列)。
- 文字列リテラルのテスト

---------------------------------------------------------------------
FIXME/TODO M6

- private namespace. 親namespaceからのみシンボルが参照できる.
- multimap, set, multiset, list
- foreach: multimap, set, multiset, list
- 例外の整理とstacktrace
- 構造体や配列の初期化式

---------------------------------------------------------------------
TODO

- expandを再帰的に展開できるようにすればbinary searchのインライン化
  が可能になるか？
- meta lambda
- 可変長引数の代わりとなる演算子を決めよ。 cout << ... のようなもの。
- 配列範囲チェックを非デバッグ時等に無効化するプラグマ?
- intの範囲を超えるenum/bitmask
- 構造体の中でenumを定義できるようにする？
- enumのint値を省略できるように
- enum int値に型式を書けるように
- enumがエラーメッセージではintとして見えてしまう
- mutexのlock保持スレッドを記録する実装
- 演算子を総称関数に自動で置き換え、ユーザが演算子定義できるように
- multithreaded structのコンストラクタ引数はmultithreaded型でなくても
  よい?
- import元を制限する構文(実装を隠すのに便利)
- check_overflow pragma? 実行時にオーバーフローを検出
- if (int v : foo.fld) { ... } // unionのフィールドは左辺値取れない
- C++が定義する関数については宣言だけはemitする(誤った宣言で問題を起
  こさないようにするため) -> 非template関数については実装済み。
  template関数と型がexternな場合については未実装
- public extern "@0void" "@0void" struct void { } こういうの無くす?
- realloc-safeかどうかpxcで判断し、それに応じて使うコンテナ実装を
  切り替える?
- foreach 参照渡し、constの組み合わせをすべてサポート?
  - keyは常にconst値or参照、mappedはconstまたはmutable参照でよいのでは？
  - keyがconst値であるかconst参照であるかは、意味的に差が起き得ない？
- fork()したときにファイルデスクリプタをどうするか？
- blockscopeのlockobject - 19/blkscope_lock.px
- evalのエラーメッセージ改善
- list, set
- tptr/tcptrのロックをreader/writerロックに。そのためにはguard count
  をatomicにしなければならないのでやめたほうがよい？ immutable ptrも
  同じようにguard countを考慮必要。
- add_root_requirement_container_elementsのexpr_has_lvalue止め?
- 代入演算子は値を返さないようにすると少し速くできる
- ptrをconst byvalで渡すときは生ポインタで受ける?
- テンプレート引数にtrueが使えない？
- inline_cに色々装飾付けられるが、エラー
- arr.resize()のように参照引数が一個だけでthreadedならinvguardしなく
  てよい。
- 定義前参照の可能性を解消
- 情報をロスするような自動変換は止める
- pure関数ならrootを省略できるケース
- multi-indexコンテナ
- 条件変数を構造体に埋め込めるようにする？普通にfieldとしてユーザが
  定義できるようにする？
- interface名と同名のmethodを定義すると変になる？
- メタ関数の評価が超遅いのは改善する？
- call traitがrawptrの型を作れるようにする? perlsvをそれにするべし
- 配列のスライスを参照渡しできるように。文字列のsubstr。
- call traitがbyvalueの型を作れるようにする?
- constnessがポインタの指す先にも伝播するようにする?
  (mtsafeの扱いとあわせて検討)
- type safe bitmask
- type safe enum
- infoファイルのescape
- getenv("HOME")だとsudoしたときに困らないか
- block_id_nsは何に使うのか整理(動的にblockを作成してはならない理由)
- コンテナforeachの中でcontinueやbreakを使えるように
- const変数宣言
- union fieldのrootをvectorと同様にするか？
- ifdef?
- namespace宣言が正しいかチェック?
- 実行形式を生成してexecするようにする？
- 複数ファイルコンパイル
- coptionsのオプション取得にpkg-config的なものをサポート
- pure(static?), synchronized
- volatile?
- constnessがptr先にも影響するように?
- boxing時の無駄なコピーを無くす
- struct定義時に実装するinterfaceを明示しなくてよいようにできるか？
  (implements宣言を分離。)
- いつterm_tostr_instance_chain()を必要とするのか確認
- interface型の一時変数を禁止(そもそもできない？)
- namespace義務付け？
- コンパイル全段階でatomicな更新を
- 無名関数はテンプレート引数を持てない？
- null値を持てないなptrとcptr
- macroの右辺をte以外の式も許可
- aliasを展開後の式をコンパイル(って何？)
- expr以外のterm、intなどをtermへ
- 配列とmapのイテレート方法を考えよ
- operator []をユーザ定義できるようにするには？
- リテラルnull、複合型リテラル
- const変数(varは変更可能だがconstは不可)
- extern関数へのpointer渡し、const pointer渡し
- extern enum
- switch
- 定数
- 参照カウントデバッグ
- リフレクションと文字列変換
- stringbuffer(文字列を引数として渡すときはstring_refとcstrに)
- string実装を複数(参照カウントしない版など)
- unstableな値を返す関数(substringのように)
- コンパイル整合性チェック(全モジュールmd5)
- posixモジュール
- 文字列との暗黙変換やめる
- interface間の継承
- this
- ネストされたテンプレートは必要？
- テンプレート引数に数値などを使えるように
- instance化はconstness関係なしにおこなわれるが問題ないのか？
- nonnullな参照型
- テンプレート型の間のinherit(is_sub_type)
- 関数型の変数を定義できないように？
- import pxcrtするとエラー
- マクロ 
- namespaceの継承？
- 上位シンボルとの衝突チェック?おきない？
- variantテスト
- variantのstabilizeテスト
- interfaceのcloneは用意すべき？
- mt safeにするために必要なものを整理
- variantのfieldが全部unitのときはenumを生成したほうが性能良い
- namespace宣言義務付け?
- downcast
- pure関数
- 引数渡しの際のstableでない値をstable化(テスト)
- リンカオプション指定
- perl sv/av/hv
- perl exception
- restricted pointer (raw reference)
- string optimization
- ユーザ定義コンストラクタのより良いコード生成(C++フィールド初期化)
- perl module

---------------------------------------------------------------------
ARGUABLE

- 数値型の変換チェック numeric_convertible
  - 現在の実装は浮動小数点数がieee754, 整数が2の補数であることを
    仮定している
interfaceまわり
- interfaceの仮想関数の引数型は先に定義しなくていいのか？
- test_03/interf_constr3_1_fixme.px1
- 型定義順依存を調べるために再帰的型を定義するテストを作る
- std::mapで foo["abc"] = "xyz" するとmudflapが怒る
- unionがunitだけでできていたときmudflapが怒る(バージョン？)
  (STLのバグ？)
- 仕様決め: catch は常にconst byref?
- block_id_nsをなくせないか
  - なくせない
  - ローカル関数をテンプレートパラメータに渡してインスタンス化した
    場合にインスタンス同士を区別するためにblock_id_nsが必要
  - 変数を上位値として渡した場合に名前の衝突を避けるのにblock_id_ns
    が必要
  - 方針: @expandによって生成したコードにはblock_id_ns=0をセット
    する。もしblock_id_ns==0なブロック上のシンボルをテンプレート
    引数に使ってしまったらエラー。現状そのように実装している。

---------------------------------------------------------------------
DONE

- cの予約語(intとか)にメソッド名などがかぶったとき(done)
- inline C syntax (done)
- operator = for strlit (done)
- for文やcatchなど、const refなど装飾を整理 (done)
- threadのmainまで例外が飛んできたらどうするか (done)
- interface extern (done)
- mainでget_stack_trace() (done)
- 文法の変更 struct extern "hoge" hoge { } (done)
- downcastは多相型でないとc++でエラーになるはず(done)
- interface間継承のupcastがコンパイルエラーになる(done)
- serializeのfieldを名前順に(done)
- is_expand_dummy削除(done)
- 関数の最後にfunction定義があると、control reaches ... になる(done)
- meta::common::fields(done)
- deserialize: e_rはエラー時の残り長さ+1の値をセットする(done)
- decimal_to_integralなどを, cstrref&を取って先頭だけ読む方式に(done)
- 菱形継承でc++エラーになるはず。interface間継承はvirtualに(done)
- from_string仕様きめ(done)
- obj.func は、その場所からプレフィックス無しでtobj_funcという名前が
  引ければそれに解決する(done)
- nodefconファミリが必要。コンストラクトできないがコピー可能。(done)
- metaif -> cond (done)
- metamap -> map (done)
- コンストラクタの中のフィールド定義でnoncopyableな型のフィールド定義
  でコピーコンストラクタ使ってしまっている(done)
- variant: グローバル変数、関数(done)
- meta argsとglobal_variablesが最初にindex値を入れているのをやめる
  (done)
- expand argdeclsが最初にindex値を期待しているのをやめる(done)
- meta typeofはlazyである必要ないのでは(done)
- variant: structに空引数udconを許可せねばならない(done)
- variant: 変数定義をexpandで生成できるようにせねばならない(done)
- 推移的に実装しているインタフェースについてfunc実装確認(done)
- expr_misc check_interface_impl() (done)
- expr_misc implements_interface() (done)
- interface間継承でthreading属性のチェックしていることをテスト(done)
- interface間継承で同名の関数を宣言するとエラー(done)
- meta::common::functionsなどの結果は、その名前空間をコンパイル中で
  あれば変化してしまうことがある。コンパイル単位の間で一貫性を保証
  するにはどうすればよいか。-> expandによって生成されたシンボルは
  メタ関数からは見えないようにする(done)
- macro -> metafunction に改名すべし(done)
- expr_variant -> expr_dunion に改名すべし(done)
- argdeclへのexpandはシンボルを指定する必要がないので消す(done)
- skip_variant_fixme2 (done)
- 可変長引数関数はmetalistをメタ引数に取る関数で実現できる。自動
  マッチさせる方法を考えよ。(done)
- expandのbaseexprが空だとしぬ(done)
- expand型foreachをexpandで置き換え(done)
- expand(sym, idx : ... ) のようにindexを渡さないと使いにくい(done)
- expand、文字列に置換するかシンボルに置換するかは文脈で決める(done)
- expand, リストの真ん中に埋め込めるようにする?(done)
- is_expand_dummyはtoplevelまでたどる必要がある(done)
- 名前空間にbuiltinを使うのを止める -> とりあえずcommonにし、大きく
  なってきたら分離(done)
- control reaches end of ... は最後がthrowだったらok(done)
- dynamic_cast相当のdowncastが必要。iinvokeからfoo_iinvokeへdowncast
  しないと元オブジェクトを取り出せない。(done)
- externな関数は返値をbyrefで返せるように。downcastを実装(done)
- meta::symbolを何とかせよ(done)
- 浮動小数点数のserialize(done)
- vectorのinsertとeraseテスト(done)
- prefix省略したシンボルを引くとき、テンプレートのインスタンス化の
  際にテンプレートを定義した側のルールで引いているか。(done)
- floatのto_stringおかしい(done)
- interfaceのlock/unlock/wait(done)
- interfaceを実装すると常にmutex埋め込むのは無くせないか(done)
- invalidate guardとmutex lockを共通化(done)
- condition variableのwaitを実現(done)
- cond_signal/broadcast(done)
- threadのmain関数の中でmultithreadedではない型を使うとエラーになって
  しまう(done)
- foo[x] = 3; でfooをguardしてしまうのは直したい。(done)
- socket_factory整理(done)
- signal SIGHUP(done)
- get_mutex廃止(done)
- lockobject廃止(done)
- block-scope lock (done)
- type familyに改名(done)
- struct foo { function {t} void bar() { ... } } がtest_symbols通らない
  (done)
- fldfe: フィールドの型を取れるように(done)
- fileのfdはimmutableにする。そうでないとaccept()でロックが要る(done)
- injectns使うと分割コンパイルで不整合がおきうる。無効化する。(done)
- generate_exe(done)
- weak pointerと区別するためにslice等はweak型と呼ばずにephemeral型と
  よぶ(done)
- to_stringは文字列へ追加する形へ(done)
- extern enumを型パラメータにしたときのエンコードがintになってしまう
  と衝突するのでダメ(done)
- io::fileはerrno_t参照を引数にとる(done)
- error{errno_t}(done)
- 16進、8進、文字リテラル(done)
- line_fixme.px1: upvalueを取れていない(done)
- privateメンバ、コンストラクタ。抽象データ型は作れるように(done)
- slice(done)
- boxing自動変換を廃止(done)
- namespace義務付け(done)
- pimplイディオムが使えることを確認(done)
- operatorと組み込み関数について整理。大小比較は全型に？(done)
- linear型の変数を宣言できないようになっているか(done)
- enum/bitmask型(done)
- 整数の暗黙変換を安全なものだけに制限(done)
- threadedではない型の変数をglobalに定義できないように(グローバル変数
  が初期化される前にそれをアクセスしてしまえないようにするため)(done)
- ユーザ定義コンストラクタ内に書ける文についての制限を決め(done)
- defconでない型(linear?)を引数無しで呼んだらエラーにせよ(done)
- ユーザ定義コンストラクタのemitを関数プロトタイプ群の後にしないと
  未定義関数を呼ぶことになる(done)
- is_copyableとis_assignableは構造体のフィールドにも制限を受ける(done)
- コンテナにnoncopyableな型は使えないように(done)
- pxcvectorとtree_mapのsliceからコンストラクタ(done)
- pxcvectorのappend(done)
- noncopyable/linearを引数付きコンストラクタで構築する方法(done)
- extern structにユーザ定義コンストラクタ(done)
- iptr/tiptr実装できている？(done)
- namespace宣言義務付け(done)
- foo{bar}: fooがtsvaluetypeでbarがthreadedな「関数」だった場合この型式
  は何装飾？ -> tsvaluetypeのまま。get_term_threading_attribute() は
  そのようになっているように見える。(done)
- global変数はthreadedな型を持たねばならない。初期化順序の問題が起きない
  ように。expr_var::check_typeの中のif 0を有効化せよ。(done)
- 短絡boxingを再び有効に(done)
- externならephemeral又はrefを返すメンバ関数を許可、thisをrootする(done)
- ephemeral型を初期化以外の代入の左辺にできないように(done)
- pxcvectorなどのインラインメンバ関数は"type"ではなく"fdecl"に移さ
  ないと型定義順依存がおきる -> ない。メンバ関数ごとにインスタンス
  化される(done)
- darrayは代入不可(done)
- threadedなclosureがupvalueとして非threadedな型を使えてしまわないか
  -> test_31_thrattr/up*.px (done)
- closureのthread属性？ -> test_31_thrattr/up*.px (done)
- guard countがmtsafeでないのはどうするか -> valuetypeとtsvaluetype
  (done)
- iptr, valuetype (done)
- コンストラクタからメンバ関数を呼べてしまうのをエラーにせよ(done)
- tsvaluetype darray実装(done)
- if (int const& x : foo[k]) { ... } のif-defined構文(done)
- int_compareなどの比較関数を無くし、基本型は > で比較するように(done)
- global変数にephemeral型は使えないようにせよ(11/fe_sli.px mudflap)(done)
- interfaceなどのようにcopyableではないものをコピーしたときのエラー(done)
- byrefであればintrface型もvarとtempvarに許容(done)
- string以外のコンテナにもappend(done)
- pxcのcharはc++のcharではなくint8_t(done)
- stringをcharではなくuchar(done)
- sliceからコンテナへ変換(done)
- foreachの中ではoperator []の範囲チェック不要 (done)
- コンストラクタへの引数がメンバ関数から見えてしまわないか？
  07/strarg.px (done)
- expr_feach::emit(): map, rangeに対するemit (done)
- pxcrt を compiler::runtimeへ (done)
- c++名前空間を::始まりで指定しないと途中の名前空間にマッチしてしまう
  (done)
- if (!x) がsyntax error (done)
- 25/val.px 関数の返値をblockscope rootしていない (done)
- farrayからsliceへの暗黙変換するとエラー(done)
- size_tを組み込みから外す(done)
- デフォルト名前空間からint等の基本型を消す(done)
- マクロ展開後の数値は何型？ long型。test_02_type/tmplint.px (done)
- eval.cppの sym_ns = "builtin" 削除 (done)
- symbol_table.cppの pname = "builtin::" + fullname 削除 (done)
- 組み込み型は名前空間"type::builtin"に属するように(done)
- test_16_perl/perl/symbols.pxでvoidを除外しないと動かないのを直す
  (done)
- 非メンバ関数にconst装飾つけるとエラーにならない(done)
- interface型を値で持てないように(done)
- interfaceへの代入はエラーにする(done)
- ptr{foo} = ptr(foo(...))で型推論してくれないのを直せ(done)
- ptr{ifoo}(foo(...))のようにインタフェースへのポインタを構築しようと
  するとエラーにせよ(done)
- require_lvalue廃止(done)
- variant fieldへの代入はset関数呼び出しに置き換える(done)
- rangeに対するoperator * (done)
- add_root_requirementのcheckonly廃止(done)
- 関数でないものでもoperator ()を適用できてしまう(done)
- test_01_px/i1_fixme : 仮想関数の実装を後ろに回さないといけないが、
  そもそも、ptrの指し先アロケートを廃止して仮想関数のダミー実装を必要
  なくすようにするべし(done)
- variantの最初のフィールドにはptrを置けないように(done)
- ポインタをdefault_constructibleではなくす。(done)
  ただしグローバル変数と構造体メンバについてはnull初期化せざるをえない
- c++実装のデフォルトコンストラクタをnull初期化するように(done)
- forやifでの定義初期化分離をなくす(done)
- foo(int x = bar())
  これをemitするのにbar()呼び出しを2回おこなっている
  int x = bar()を独立させたので参照時には単に「x」とするべし
  (test_23_emit/cmplx.px) (done)
- int x = ...の式をさらにtempvar作っているのは無駄 (done)
- 引数のpassby_e_unspecified(call trait)をやめる(done)
- コンテナからrangeへの自動変換(done)
- mutable&渡しの際にinterfaceへのupcastがあったらエラーになる問題(done)
- sliceの要素がlvalueを要してもslice自体はlvalueいらず、sliceかcslice
  であるかによってlvalueを持つかが決まる(check_lvalueの修正)(done)
  - add_root_requirementの'[]'についても同様の修正必要(FIXME印を見よ)
- add_root_requirement()するケースの整理、複数要求がある場合の処理。(done)
- 自動変換が入ったら左辺値を取れないように?(check_lvalue)(done)
- if文がboolでなかった場合のエラーメッセージに行番号が出ない？(done)
- variantのtagからintへの変換(done)
- test_22_error/tparam.px (done)
- 引数のconst/mutable参照渡し/値渡し明示。(done)
- integralやpointer downcast以外の自動変換を止める？(done)
- foreachをsliceにも(done)
- main.printlnがエラー(done)
- ioをmultithreaded方式に置き換え(done)
- perlマーシャラ、参照でマーシャルするもの。(done)
- 仮想関数を持つクラスにmutexを埋め込め(done)
- 文字列リテラルのescapeがおかしい(done)
- インタフェース型にデフォルトのダミー実装を入れる(done)
- デフォルトコンストラクト可能でないものを定義したらエラーに(done)
- ポインタnull排除(done)
- pimplの中身のコンストラクタを禁止する手段を用意(done)
- clone時にtype_of_this_exprをクリアする必要があるものをクリア(done)
- threads(done)
- グローバル変数にperlsvを置いていると終了時不正メモリアクセス(グロー
  バルに置けないようにする)(done)
- ptr{foo} p = foo(...)を一時オブジェクト作らずにboxing(done)
- '::'を@local使って実装(done)
- インポートされた側を先にコンパイル(done)
- 参照引数(done)
- 分割コンパイルした際、コンパイル時に読まれたモジュールの違いにより
  メタ関数の評価結果が変わってしまうと問題では？たとえばsymbolを探す
  処理。 -> 変わらないようにする(done)
- expr_foldfe(done)
- macrodefの引数がシンボルテーブルに定義されてしまう(done)
- tempvarを作るタイミングは正しいか？(done)
  (部分式の評価順序はコンパイラが勝手に決める)
- foreachの対象をrootしているか?(done)
- 総称的to_stringに必要なメタ関数を用意(done)
- 総称的な文字列への変換。io::println()を全ての型に対応。(done)
- to_stringを基本型に制限(done)
- if条件がメタ関数で、偽に評価されるときはブロックの中を消す(done)
- foreach: structとvariant(done)
- foreach: 引数の型チェック(done)
- 固定長配列(done)
- catchは常にconst参照で受けるのは大丈夫なのか？rootされているか？
  (大丈夫。throwは常に引数をコピーするから)
- 型定義順を再整理(C++テンプレートが絡むケース require_definition?)
  (done)
- profile(done)
- ソース検索パス(done)
- coptionsをinfファイルに書く(done)
- coptionsをccコンパイル時に反映(done)
- コンパイルの流れを確定(done)
- 作業ディレクトリ決め(done)
- 並列コンパイル防止lock(done)
- infoを消す前にccとoとsoを消す(done)
- md5sumコマンドと値が異なる理由(ファイル名も含めていた)
- 型のテンプレ引数としてclosureやメンバ関数を指定するとエラーに(done)
- 具体型からインタフェースptrへの変換を許可(done)
- interfaceのメンバテンプレートは禁止(done)
- extern struct型の変数の初期化されているか確認(done)
- if (x) の型チェック(done)
- interface, variant等もテンプレートパラメータ持てるように(done)
- inheritに型パラメータを使えるように(done)
- int i = i + 3 の初期化を漏らさないように (done)
- ユーザ定義コンストラクタ (done)
- argdeclはinterface型を持てるように(done)
- upvalueの名前が(idだけだと)衝突するのでnsを付ける。(done)
- up5.px (teを引くコンテキストが構造体の中になってしまっている？)(done)
- up6.px (テンプレート引数不足をチェックできていない)(done)
- up7.px (関数の中でマクロ定義したら動かない？)(done)
- closureがテンプレート引数を持つケース(done)
- テンプレート引数に関数オブジェクトがあるとき(done)
- []の中を型チェックしてない？(done)
- const method から nonconst methodを呼べないように(done)
- non-const methodを呼ぶときにオブジェクトがconstであるか確認(done)
- 生成コードにconst(done)
- inheritの際にconstnessの一致をチェック(done)
- foo{int}(x, y); expr_symbolとexpr_teを統一する？(done)
- inheritされたときの実装チェックと型一致チェック(done)
- メンバ関数をその下のネストされた関数から呼べるように(done)
- 関数型の変数を定義したらエラーに(done)
- nestされたstructの下側から上側のメンバ関数等を参照できないように
  (done)
- リファクタリング: tvmapを文字列キーに。(done)
- リファクタリング: C++のテンプレートもinstantiate処理。(done)
- eval整理(expr_teを返すのをやめる)(done)
- ptrとcptrをexpr_structへ(done)
- 「&」廃止(done)
- externの文法統一(done)
- 型パラ付き型もfoo()で自動インスタンス化できるように？(done)
- typedefとctypeを分離してtypedefをaliasに改名(done)
- alias(typedef)に引数を持てるように(done)
- グローバル変数の寿命をグローバルに＆closureに渡す必要無し(done)
- extern functionにCの名前を指定できるように(done)
- termをimmutable参照型に(done)
- エラーを投げる関数を統一(done)
- extern function(定義が空)(done)
- extern typedef(done)
- extern struct(定義が空)(done)
- 明示的キャスト(done)
- コンパイラ/リンカオプション(-I, -L, -lxx) (done)
  incdir, libdir, library
- alias list(t) ptr(cons(t)) (done)
- '!'演算子(done)
- 単項演算子の'case'(done)
- double(done)
- list*.px (done)
- union.px (done)
- 総称関数の自動マッチ(fib2.px)(done)
- template(done)
- 型名() でのオブジェクト作成を全ての型に(done)
- 自動テストフォルダ作成(done)
- define_variablesとcheck_typesに分ける。(done)
- 全ての型式(のalias)でデフォルトコンストラクタを呼べるように。(だぶ
  んdone)
- expand_type_aliasの場所(型式のevalするタイミング)を明確に。(done)
- r1636でエラーだったものが解消した理由調べよ(done)変数定義最適化が
  効かないようにエンバグしたのが原因だった。
- interface型の変数を宣言できないように(done)
- implementsのメソッド実装チェック(done)
- グローバル変数もupvalueに(done)
- 直和型(done)
- struct foo と namespace foo の衝突回避(done)
- c++ 例外(done)
- breakとcontinueの位置チェック(done)
- returnがあるかチェック(done)
- null参照外しエラーチェック(done)
- vectorにempty()などのメソッドを定義(done)
- foo.bar()をns::bar(foo)に自動で置き換える(done)
- 明示的キャスト(done)
- byref引数(done)
- lvalue check(done)
- cptrからptrへの変換をエラーに(done)
- typedef (alias)
- interface
- auto boxing (operator &廃止?)
- メンバ関数が上位値を持ったらダメでは？(done)
- メンバ関数の中で定義されているクロージャから同じ関数のメンバ関数を
  よぶのは無理では？(done)

---------------------------------------------------------------------
廃案

- evalのhas_unbound_tparam()のときに未評価のまま返すのをやめよ
  -> マクロの部分的評価を実現するには必要

---------------------------------------------------------------------
Cの名前の使い方

t$0 一時変数
foo::bar$n namespace
foo$f   関数名
foo$f0  ローカルに定義された関数の関数オブジェクト(struct)名
foo$fi  ローカルに定義された関数の関数オブジェクトインスタンス
foo$t   typedef(enum, bitmask)の名前
foo$t0  typedef(enum, bitmask)のenum要素
foo$s   構造体
foo$s0  ローカルに定義された構造体
foo$v   直和型のstruct名
foo$v0  ローカルに定義された直和型のstruct名
foo$i   インタフェースのstruct名
foo$i0  ローカルに定義されたインタフェースのstruct名
foo$    auto変数、グローバル変数、メンバ変数、関数引数
foo$ns0 auto変数、グローバル変数、関数引数？ 名前空間付き
foo$ns0p0 fast boxingコンストラクタが使う生ポインタ
foo$e   variantのenum要素
foo$fg  foreachのguardオブジェクト
foo$fe  foreachのkey, mapped値, guardオブジェクト
$e      variantのenum
this$up メンバ関数の下の関数からメンバ関数を呼ぶための上位this
??      変数
$ic     ネストされたテンプレートに使う
str$ls  テンプレート引数の文字列リテラル
100$li  テンプレート引数の数値リテラル
aaa$c   名前空間の初期化関数
aaa$cm  名前空間のエントリ
i$it    if(v:c[k])が使うイテレータ
$p$XXX$q$YYY$r$ テンプレート引数 {XXX,YYY}

構造体に追加することのある名前
init$z 初期化補助関数
conunt$z 参照カウンタ
incref$z 参照カウンタ用
decref$z 参照カウンタ用

---------------------------------------------------------------------
キモ

- PerlのデータとC++のデータの両方を扱えること
- Perl/C++とのデータやりとりでオーバヘッドが無いこと
- Perlの例外とC++の例外の両方を安全に(リークせず)使えること
- Perlの拡張として動き、動的コンパイル即実行できること
- C++呼び出しが別途リンクせずにできること
- C++のコードを書かない限りSEGVらないこと -> stack詰んだ場合は許容

---------------------------------------------------------------------
まあまあ重要

- インタフェース
- コンテナを使える(静的型付け)
- スマートポインタ(静的型付け)
- ある程度クロージャをサポート
- C++のコードをインラインで書ける

---------------------------------------------------------------------
割り切り

- 配列の境界チェックはon/off? -> 常にon
- 参照外しチェック(ぬるぽ)は毎回チェックorSEGVフック？ -> null廃止
- C++のキーワードは識別子の名前に使えない(連携しやすくするため)
- スレッドは使えない -> mtsafeチェックして使えるように
- 参照カウント
- コンテナにイテレータは無い -> かわりにrange

---------------------------------------------------------------------
injectns使うと分割コンパイルで不整合がおきうる。

Bar inject Fooのとき、BarをimportするかどうかによってFooに対する
名前引き結果が異なってしまう。

---------------------------------------------------------------------
condition variableのwaitをどのような文法で実現するか

waitする際にはmutexをlock済みでなければならない

条件変数を構造体に埋め込む
struct foo {
  compiler::runtime::condition cond;
};
foo& obj = *ptr;
obj.cond.wait();

---------------------------------------------------------------------
guardまわりシンプル化

現状:
  - checktype.cpp: add_root_requirementのTOK_PTR_DEREFのケース、
    スマポをstore_tempvarすることにより参照無効化を防止している
  - emit.cpp: expr_op::emit_valueのTOK_PTR_DEREFのケース、tptrかtcptr
    ならばlockobjectを作り、その中の参照を返している。interfaceか
    どうかでコード出しわけ。
    非インタフェース: (lockobject((p)->get_mutex$z()), p)->value$z
    インタフェース:   *(lockobject((p)->get_mutex$z()), p)

    配列要素:
      guard_ref< vector<int> > t0((vec));
      int& elem = (t0.get())[15];
    guard_refのコンストラクタ・デストラクタでvec.inc_invalidate_guard()
    とvec.dec_invalidate_guard()を呼んでいる。ポインタ型はC++では全て
    rcptr<>なので、rcptrクラスにinc_invalidate_guard/decを定義し、その
    中でptr->incref$z()とptr->decref$z()を呼べばよい。
    rootするためにポインタをaddref必要なときはguard_val、そうでないとき
    はguard_refを使う。
      guard_ref<T>
      guard_ref<const T>
      guard_val<T>
      guard_val<const T>

    rcptrにinc_invalidate_guard/decを追加する。

    guard_ref/valのget()はコンテナ自体を返すことに注意。


---------------------------------------------------------------------
演算子・関数呼び出しを組み合わせたときのroot必要の判断

副作用を持つ関数又は演算子を呼ぶと、呼ぶ前に有効であった参照を無効化
する可能性がある。C++は部分式の評価順序が決まっていないから、どのよう
な順で評価されても無効化されない場合以外はrootせねばならない。

・pure関数は副作用を持たない。pure関数は以下の条件を満たす関数:
  - threaded関数
  - 引数(メンバ関数のときはthisも含み、closureのときは上位値も含む)が
    全てtsvaluetype型、mutable参照以外の渡しかた
・pureではない関数はすべて副作用を持つ可能性があることを考慮すべし
・副作用をもつ演算子:
  - 代入演算子
  - +=のような副作用付き演算子
foo(bar(), baz())

---------------------------------------------------------------------
演算子の左辺・右辺のroot方針

x + y の左辺と右辺はconst_valueかconst_refのどちらでrootしてもよい。
値でrootするとコピーのコストがかかることがあり、参照でrootすると
配列のガードのコストがかかることがある。

---------------------------------------------------------------------
配列要素やunionフィールドなどをbyvalueで取得する安全な方法

mapped_type(arr[idx]) という式は、副作用を持つ式の一部として評価
された場合、評価順によっては、arr[idx]評価後にその参照を無効化される
可能性がある。そのため参照を返す演算子/関数のかわりに値を返すものを
用意し、それを呼ぶようにする。
ポインタ参照外し: deref(), deref_value$z()
variant field: value$$r() これは常に値を返すのでok
配列要素: get_value(idx)
rangeの参照外し: 常に有効なのでok

---------------------------------------------------------------------
interfaceのlock/unlock/wait
- 実装クラスがmultithreadedならmonitorを埋め込む。tsvaluetypeであっ
  てもmonitorが必要。tptrが指すことができるから。非interfaceな型に
  ついてはrcval/trcvalのラップ使い分けによってtiptrがmonitorを埋め込
  むのを避けられるが、interfaceではできない。
- lock$z, unlock$z, wait$z, notify_one$z, notify_all$zを仮想関数に
  し、実装クラスがmultithreadedならmonitorにたいして処理実行、そう
  でないならnoop。-> multithreadedでないならlock$zなどの関数を用意
  しない。

---------------------------------------------------------------------
awk的なもの

行の型をXとすると、Xのmonoid構造についてのfold演算の結果を取る処理。

行を分割
各カラムを各々の型に変換
インデックス構築

x: string, y: int

合計
  int sum;
  foreach { sum += y; }
キーごとの合計
  tree_map{string, int} m;
  foreach { m[x] += y; }

---------------------------------------------------------------------
汎用展開マクロ

@expand(sym : metalist) expr
exprが式であるか、文であるか、引数宣言であるか等によって結合方法
は判断する。式ならカンマ区切り、文ならstmts, 引数宣言ならargdecls。
struct proxy_stub{ifoo} : ifoo : {
  ptr{invoke} handle;
  @expand(funcsym : functions) function rettype{local{ifoo, funcsym}}
  funcsym(
    @expand(sym : seq{argnum{local{ifoo, funcsym}}, "a"})
    argtype{local{ifoo, funcsym}, substr{sym, 1}} sym)
  {
    var rci = remotee_call_info(to_string{sym}, *handle);
    @expand(sym : seq{argnum{local{ifoo, funcsym}}, "a"}) rci.argument(sym);
    rci.call();
    if (ne{rettype{local{ifoo, funcsym}}, void}) {
      var rv = rci.retval();
      return rv;
    }
  }
}

---------------------------------------------------------------------
expand 文

- expand(i, sym : metalist) [ stmt_list ]
- metalistは行列になっていて、各行は次のフォーマット
  { symstr, stmtnum, ... }
- metalistの各行について、stmt_listのうちのstmtnum番目の式を取り出し、
  そのstmt中のiをその行で置き換え、またsymをsymstrという名前のシンボル
  で置き換えたstmtを作り、それらを連結したstmtsで置き換える

---------------------------------------------------------------------
可変長引数関数

function {ts} foo(expand(i, sym : names{ts})) {
  ...
}
呼ぶときには
foo(x, y, z)
とやるとtsがx, y, zの型のリストとしてfooをインスタンス化する

---------------------------------------------------------------------
variant

関数引数の個数だけseqを生成
metamapで、各要素に対して{"a0", passby}のリストを作る

macro f m::local{t, m::to_string{fsym}};
macro arginfo{args, n}
  m::list{
    m::concat{"a", m::at{args, 0}}, 
    m::add{m::mul{m::at{args, 3}, 2}, m::at{args, 4}}};
macro arginfo_list m::metamap{m::args{f}, arginfo};

invokeが取るvariant型引数を型付けられた引数に変換する:
byvalならばfrom_variantで変換した値を保持
byrefならばiinvokeの中身をdowncastして参照を保持
sliceを引数にとる関数を呼ぶときは何に変換するのか？

from_variantの動作:
- tがintegral, fp, 文字列ならば極力変換
- tptrvalの指す先をtにdowncastして返す

to_variantの動作:
- tがintegral, fp, 文字列ならばそのまま格納
- それ以外はtptrvalにbox化

関数呼び出し
interface icall { variant call(cslice{variant} const& args); }
struct stub_func{f} <icall> { ... }
- variant call(...) の実装はstub_iinvokeのinvokeとほぼ同様

コンストラクタ呼び出し
struct stub_constr{t} <icall> { ... }
- 関数と同じように構造体のコンストラクタを呼べるように
- noncopyableな型については、stub_idynamic{t}のコンストラクタは
  tと同じコンストラクタ引数を持ち、中でそのままtを構築するのに使う
- copyableな型については、stub_idynamic{t}のコンストラクタはtで、
  そのままコピーコンストラクトする。このようにしないとtを返す関数
  の結果からstub_idynamic{t}オブジェクトを構築できなくて困る。
- variant版構造体コンストラクタの実装:
  - copyableな型なら v.tptrval = tptr(stub_idynamic{t}(t(...)));
  - noncopyablenなら v.tptrval = tptr(stub_idynamic{t}(...));
- 非メンバ関数呼び出しとコンストラクタ呼び出しは共通のコードで。
  - 名前空間の関数と型を呼び出せる
- struct以外の型: typedef, union, enum, bitmask
- enumやbitmaskの値(enumval)も関数のように呼び出せるように
- グローバル変数は

variant型だと実行できない処理:
- 参照外し
- 左辺値を返す配列要素、range
- 参照を返す関数
どのように代替するか？なくても困らないか？

サポートしない機能:
- 参照を返す関数。たとえばdowncastなど。
- ephemeral型。range、sliceなど。これらの型を引数に取る関数はかわりに
  コンテナを指定すればよい。
- 配列要素への参照。



---------------------------------------------------------------------
関数が必要とする上位変数の計算

- 関数の中身をchecktypeするときに、フレーム(funcdef/struct)のcallee_list
  にfunccall先を書いてゆく。
- 関数がどのupvalueを必要としているかは、自分が参照しているupvalueに
  加えて、推移的にcallee_listにあるupvalueを加えたものになる。
- メンバ関数やその子孫の関数は、参照しなくてもthisをupvalueとして必要
  になる。constメンバ関数かどうかでthisをconstにするかどうかを決める。
  struct内の実行文(=コンストラクタ)もthisをupvalueとして必要。
- this以外の上位変数がconstかどうかは単純にその変数自体がconstかどうか
  で決まる。this(とメンバ変数)がconstかどうかはthisupがconstかどうかも
  影響。
- 依存するthisのクラスがそもそも呼び出し元と先で異なるような場合はコン
  パイルエラー。meta式によってメンバ関数を取得した場合に起きうる。
- 関数を呼ぶ時点でupvalueが定義されていないといけない。これは各関数呼び
  出し箇所について、推移的上位変数のうち自分と同一のblockで定義されてい
  るものが、その呼び出し箇所よりも前の文に定義があることをチェックする。

手順:
- 関数呼び出しのすべてについてcallee_vecに呼び出し先funcdefを書く。
- 各funcdefについて、callee_vecを推移的にたどり、callee_vec_transitiveを
  作る。相互再帰に注意。callee_vec_tr_doneフラグをtrueに。
- 各funcdefについて

function void x()
{
  int z;
  function void baz() { z = 3; }
  function void foo() {
    twice{baz}();
  }
}
fooがbarを呼び、barがbazを呼び、bazがclosureのとき

呼び出しのチェインのうち、どこでその変数を定義しているか判定
- 呼び出し元のframeがその変数の定義しているframeと一致する箇所。

tpupにはその関数が参照しているupvalueのリストが入る
- add_..._direct()ではそのfuncdefのbodyの中で参照している上位変数
- add_..._tparam()ではそのfuncdefのテンプレ引数関数が参照している

---------------------------------------------------------------------
例外ツリー

std::exceptionをpxcのインタフェースにする。
interface exception { }
interface logic_error { }
interface runtime_error { }

---------------------------------------------------------------------
型情報無しserialize

unit: 何も書かない
整数: nnnxxxxx 上の3bitに後続バイト長さ。ただし111のときは後続8バイト
enum/bitmask: 整数と同じ
浮動小数点数: べた
配列: 最初に長さを整数エンコードで書く。残りは各要素を詰める
  ただし要素型が2byte以下のときは要素固定長で
連想配列: 配列と同じ
構造体: 各フィールドを詰める
union: 最初にタグ、次に要素

---------------------------------------------------------------------
from_string

引数には読み込みバッファの末尾までを渡す。パース失敗したら残りの長さ
を例外に含める。

string "hoge"
number 0.1
struct, union {fldname0=value0,fldname1=value1}
pointer {value}
map {key0=value0,key1=value1}
array {value0,value1}

トークン区切りは'{', '}', '=', ','の4つ

・文字列をquoteするのをやめる
・エラーになってもトークン区切りまでは読み飛ばす
・'='をやめて','区切りにする(done)
・構造体のフィールド順序を名前順に固定し、deserializeを速くする
・mapと構造体を互換に
・数値と文字列を互換に
・不要値を読み飛ばす

pointer_endは該当する'}'まで読み飛ばす

文字列、数値のパース
- まずトークン区切り記号を探す
- もし'{'だったら対応する'}'まで読み飛ばし、最初の要素をパースする
- それ以外だったら区切り文字の前までをパースし値を返す

---------------------------------------------------------------------
from_stringを変更に強くする

stringは引用符使わない

structはfield名の順にserializeする。
deserializeの際にもfield名の順に。
expand (fld : fields) {
  fldname = deserialize_symbol();
  if (fldname < fld) {
    このデータは空読み。
  } else if (fldname > fld) {
    fldnameをunreadして次のfldへ。
  } else {
    このデータをdeserialize。
  }
}

---------------------------------------------------------------------
lambda

lambda{x} lambda{y} add{x, y}
x := 3を適用
=> lambda{y} add{3, y}
y := 5を適用
=> add{3, 5}
=> 8

lambda抽象がすべて外れた時まで適用を遅らせる
lambda{f} lambda{x} lambda{y} f{x, y}
f := add
=> lambda{x} lambda{y} f{x, y} ( f := add )
x := 3
=> lambda{y} f{x, y} ( f := add, x := 3 )
y := 5
=> f{x, y} ( f := add, x := 3, y := 5 )
ここで適用？

各lambda式について、自身のlambda変数だけでなく上位のlambda変数について
も値を保持しなければならない
termを構築する際に、上位lambda変数を再帰的に渡す

lambda{y} f{x, y}
  引数: y
  上位変数: f, x
  適用: ()
  式: f{x, y}

lambda{x} lambda{y} f{x, y}
  引数: x
  上位変数: f
  適用: ()
  式: lambda{y} f{x, y}

lambda{f} lambda{x} lambda{y} f{x, y}
  引数: f: 
  上位変数: なし
  適用: ()
  式: lambda{x} lambda{y} f{x, y}

lambda適用時の処理
lambda{f} lambda{x} lambda{y} f{x, y}  .  add
f := add をバインドして 中身をevalする。
結果は
  (f := add) lambda{x} lambda{y} f{x, y}
x := 3 をバインドし、中身をevalする
結果は
  (f := add, x := 3) lambda{y} f{x, y}
y := 5 をバインドし、中身をevalする
結果は
  (f := add, x := 3, y := 5) f{x, y}
  頭が
  => add{3, y}

lambda抽象式を値として返すときには、その上位値のバインドを
同時に保持しておかねばならない

lambda_bindというtermを作る?

# evalの処理
# termがterm_lambdaまたはterm_bindだった場合の処理を追加
# termがargsを持たない場合
#   - 現在のbindをwrapしたtermを返す
# termがargsを持つ場合、それはlambda適用である
#   - 引数にargsを適用するようなbindを作る。
#   - さらに上位変数のbindを持つ場合はそれも加える。
#   - できあがったbindをpushして式をevalする

(1) eval_contextにbindを追加。term_bindへのポインタ。eval_contextのbindは、
現在評価中の式のlexical contextがmetafdefの中の式であるときに、その位置の
変数のbind一覧がセットされるもの。再帰的に別の式をevalするときは退避復旧
する必要あり。

(2)
eval_apply_internal(term x, term_list args, eval_context c, bool args_evd)
{
  xは評価済み。yはargs_evdなら評価済み。
  xがterm_lambdaかterm_bindなら
    lambda式の引数にargsの各々を代入するようなbindをxにかぶせる
    もしbindの深さがlambda抽象の深さに一致したら
      簡約可能なので、そのbindをctxにセットしてxのlambda右辺を
      eval_term_internalする
    そうでないなら
      まだbind不足で簡約できないからbindをかぶせたtermをそのまま返す
  xがexprなら
    そのexprにargsをつけたtermを作り、eval_term_internalする
  xがそれ以外なら
    エラー
}

(3)
metafdef_to_term(expr_metafdef *mf, ...)
{
  rhsをte_to_term()する
  lambdaに引数があるときは
    引数とrhs式をセットしたterm_lambdaを作り、それを返す
  引数が無いとき
    rhs式をそのまま返す
}

(4) tparamsのevalにたいして、param_defがnullだったらeval_contextのbindから
探す処理を追加。
(local_tparams_bindingはあとで削除。)
(変更後はmetafdef引数のtparamsはparam_defが常にnullになる。)

(5)
ここから一気に。
te_to_term(expr_i *te, ...)の処理
teがexpr_teじゃないとき、もしそれがmetafdefなら、metafdef_to_term()
を呼ぶように変更

(6)
eval_term_internal2()
case expr_e_metafdefの場合
  expr_metafdefをmetadef_to_term()で変換してevalし、それとargsを
  eval_apply_internal()する。argsが無いときはそのまま返す。

save_upvalue_bindはどこで実行するべきか
lambda{lst} lambda{a} map{lst, lambda{x} add{x, a}}
{lst:={1,2,3}} {a:=5} lambda{lst} lambda{a} map{lst, lambda{x} add{x, a}}
-> map{{1,2,3}, lambda{x} add{x, 5}}
evalするときにbindをectxにセット
evalした結果にlambdaが含まれているとき、その中に上位値として参照する
変数がectxのbindに含まれていることがあるが、それをeval後も覚えておく
必要がある。evalした結果にlambdaが含まれているとき、そのlambdaは一度
中でevalされているはず(eager evaluationなら?)。


---------------------------------------------------------------------
lambda lazy化

term_bindにtpv_evaluated

eval_apply:
  lambda applicationで適用するたびにterm_bindをwrapするところ、
  tpvをevalしてからセットしているのをevalせずにする
  ectxにtpbindがあればそれをterm_bindに付ける。

find_tparam_bind:
  bindの中から見つかったら、それのtpv_evaluatedが空ならtpvをeval
  する。その際にはtpbindをセット。

cycleの可能性をなくすには
tpv_evaluatedがmutableであるのが問題
ectx.tpbind は upvalueだけでなく全ての変数束縛が入る
- eval_term_with_bindでtpbindをセットしている
  1. tparamsのparam_defがnullだった場合にそこから束縛値を取るが、
     その際に遅延評価のために上位値をtpbindにセットしてから束縛値
     を評価する
  2. lambda適用が可能となった段階でtpbindにすべての変数束縛をセット
     してからlambda右辺を評価する
- find_tparam_bindでtpbindを参照している
  これはtparamsの束縛値をさがすのに、tpbindの中から探すから。
- save_upvalue_bind
  lambda式のlexical contextを保存するのに、tpbindをイテレートし、
  term_lambdaの直前にterm_bindを各上位変数についてかぶせる。
  -> これはもし評価済みであれば評価済みの値をかぶせる？

---------------------------------------------------------------------
targs_evaluated

除去して常にfalseであるような動作をするよう変更

eval_term_list_internal()
  trueなら評価、そうでないならそのまま
eval_term_with_bind()
  eval_term_internalにそのまま渡す
eval_apply()
  targs_evaluatedが偽なら引数を評価してからbindのチェインを作成
eval_term_internal()
eval_apply_expr()

---------------------------------------------------------------------
リモートオブジェクト

var svr = tptr(object_server{foo}());
multithreaded struct foo {
  function tptr{ibar} create_skeleton(client_info const& ci);
}
multithreaded interface ibar {
  function int hoge(int x);
  function tptr{ibar} fuga(ibaz& x);
}
struct stub{ibar} <ibar> {
  orb_client orb;
  function int hoge(int x) {
    return orb_client_call{int, m::list{m::list{int, 0}}}(orb, x);
  }
}
stub{ibar}
リモート化可能なインタフェースは、各メソッドが以下を満たす必要がある。
- 参照引数にはリモート化可能なインタフェースしか使われていない
- 返値は値渡し可能な型
リモート化可能な型:


---------------------------------------------------------------------
ORBに必要なもの

・参照でmarshalすることができるのはインタフェースだけ
  それ以外はdynamic_object interfaceを使えば参照でmarshal可能
  dynamic_objectはIDispatch的なもの
  interfaece ifoo {
    function int foo(int x);
    function string bar(string x, string y);
  }
・参照でmarshalするかどうかは、remote interfaceを実装しているかどうか
  で決める。remote interface自体は何もメソッドを持たない。
・リモート呼び出しでインタフェースを実装するクラス(stub)
  interface ifoo {
    function int foo(int x);
    function string bar(string x, string y);
  }
  interface stub { /* からっぽ */ }
  struct stub_ifoo <ifoo, stub> {
    ptr{orb_handle} const hnd;
    function int foo(int x) {
      marshal{int}(*hnd, x);
      remote_call(*hnd, "foo");
      int r = unmarshal{int}(*hnd);
      remote_call_end(*hnd);
      return r;
    }
    function string bar(string x, string y) {
      marshal{string}(*hnd, x);
      marshal{string}(*hnd, y);
      remote_call(*hnd, "bar");
      string r = unmarshal{int}(*hnd);
      remote_call_end(*hnd);
      return r;
    }
  }
・サーバ側でリクエストを受けてオブジェクトへメソッド呼び出しを実行
  (skeleton)
  interface skeleton {
    function void inovoke(orb_handle& hnd);
  }
  struct skeleton_ifoo <skeleton> {
    ptr{ifoo} const realobject;
    function void invoke(orb_handle& hnd) {
      if (req.method_id == "foo") {
	x = unmarshal{tx}(hnd);
	r = realobject->foo(x);
	marshal{tr}(hnd, r);
      }
    }
  }
・保持関係
  - stubはconnを共有保持。逆方向は弱参照を持つ(stub pool)。
  - connはskeletonを占有保持。(skeleton pool)。
・TCPでlisten, acceptし、接続毎にスレッド一本。 
  - 接続を受けるとクライアントからのリクエストを待つ。
  - 接続毎にskeleton poolを持っている。接続直後は空。
    skeleton poolはskeletenオブジェクトへの強参照を持っている。
  - 接続毎にstub poolを持っている。接続直後は空。stub poolはオブジェクト
    への弱参照を持っている。
  - メソッド呼出に含まれる情報:
    - thisのobject id(空なら
    - 引数のリスト
    - 返答が必要かどうかのフラグ
    - メソッド名(文字列？)
  - メソッド返答に含まれる情報:
    - 返値または例外の値
    - 参照渡し引数のリスト(あとで実装)
    - 返値であるか例外であるか
  - メソッド呼び出しのほかに、オブジェクト削除リクエストも来る
    - object idが指定される。指定されたオブジェクトをプールから削除
    - これは相手側でデストラクタが呼ばれたときに呼ばれる
    - これには返答は無い
・stubのメソッド実装(リモート呼び出し)
  - 引数をハンドルにmarshal
  - remote_call実行
  - 返値をunmarshal
  - remote_call_end実行
・skeletonのinvoke実装(リモートからの呼び出し)
  - 引数をunmarshal
  - realobjectへメソッド実行
  - 返値をmarshal
・orbサーバには引数としてmultithreadedなfactoryオブジェクトを渡す。
  接続毎にfactoryからインスタンスを作る。
  multithreaded interface {t} factory{t} {
    function ptr{t} create();
  };
  tはremoteを継承するインタフェース。接続を受けるとこれを一つ作り、
  skeleton poolへ入れ、そのidをクライアントに返す。
・orbクライアントには引数として接続先情報(host, serv)を取る。テンプレ
  引数としてinitial instanceの型(interface)を取る。
  function ptr{t} connect(address const& addr);
  - まずorbを作る。それはskeleton poolとstub poolを持つ。
  - addrへ接続しinitial instanceのidを得る。
  - stubを作る。
・orbクラサバ共通なのはskeleton poolとstub poolを持つこと。

非メンバ関数のskeleton
  interface skeleton {
    function void inovoke(cstrref const& req, string& res);
  }
  struct skeleton_foo <skeleton> {
    function void invoke(cstrref& req, string& res) {
      x = unmarshal{tx}(req);
      y = unmarshal{ty}(req);
      r = foo(x, y);
      marshal{tr}(res, r);
    }
  }
非メンバ関数のstub
各関数ごとにstubを作るか、nsごとにstubを作るか
function int foo(int x, int y);
function int stub_foo(orb& o, int x, int y) { ... }
function {f} rettype{f} remote_function(orb& o, argtypes{f}) { ... }

---------------------------------------------------------------------
RPC1

呼び出しをunmarshalするコードを作る。unmarshalしたものから関数を呼び
出すコードを作る。

function {t} t unmarshal(cstrref& buf)
  tab区切りで引数を取り出し、unmarshalする。取り出した引数はbufから
  pop_frontする。

リモート可能な関数・メソッドは？
- 引数と返値がすべてmarshal/unmarshalできればok
- remoteを実装する型へのポインタは参照でmarshalされる
- (option) remoteを実装する型のみmutable byrefで受けられる

関数呼び出し
  F foo 10 20
メソッド呼び出し
  M %1 bar 10 20
リターン
  R 50
例外
  T hogefuga

struct orb {
  ns_functions our_funcs;
  string rbuf;
  string wbuf;
  void expect_response()
  {
    while (true) {
      write_and_read(); // wbufを書いてrbufへ読む
      if (is_request()) {
	dispatch();
      } else {
	break;
      }
    }
  }
  void dispatch()
  {
    cslice req = rbuf[ .. ]; // リクエスト一つを切り出す
    read_token(req, 'F');
    call_ns_function(our_funcs, req, wbuf); // 中でreqを消す
  }
}

各orbにはbyref型マーシャラの配列を持っていて、各objectのskeletonには
その型に応じたマーシャラのidが同時に記録されている。

---------------------------------------------------------------------
RPC つぎ

61_remote/ot3.pxでメソッド呼びだしdone。
リモートへ払い出したオブジェクトにidをふり、またmethodsテーブルの番号
を保持し、ptr{obj}との3つ組をskeletonsにつっこむ。
idは生ポインタにする。ポインタからidを引く処理を省略できる

remoteオブジェクトのうち、stubはorbへの共有ポインタを持つ。
orbがstubsとskeletons、methods_tblを持つ。
stubsはリモート側の実オブジェクトに対して生成したstubの集まり。
  map{size_t, size_t};
    stubオブジェクトへの弱ポインタ -> リモート実オブジェクトのid
    (stubはorbの強参照をもつので反対方向は弱参照)
skeletonsはローカル側の実オブジェクトの集まり。
  map{size_t, pair{ptr{remote}, size_t}};
    リモートobject_id -> (実オブジェクト, methodsインデックス)
methods_tblは
  vector{methods};
  各型についてのメソッドリスト。
methodsは
  vector{method_entry};
  メソッドリスト。名前順にソートされている。
method_entryは
  { string name; ptr{i_marshal_method} method; };

marshal_referenceの動作
  もしオブジェクトがstubsに入っているなら、そのidをシリアライズ
  そうでないなら、skeletonsから探す＆登録、そのidをシリアライズ
unmarshal_referenceの動作
  もしidがstub印がついていれば、stubから探し、強ポインタへ変換
    stubにないなら新たに作成
  そうでないなら、skeletonsから探し、ポインタを返す
    skeletonsにないならエラー

stubの動作

