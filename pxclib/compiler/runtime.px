namespace compiler::runtime;

public mtvaluetype extern "pxcrt::invalid_index" ""
  struct invalid_index { }
public mtvaluetype extern "pxcrt::invalid_field" ""
  struct invalid_field { }
public mtvaluetype extern "pxcrt::null_dereference" ""
  struct null_dereference { }
public mtvaluetype extern "pxcrt::would_invalidate" ""
  struct would_invalidate { }

extern "type" inline
#include <stdexcept>
namespace pxcrt {
void throw_invalid_index() __attribute__((noreturn));
void throw_null_dereference() __attribute__((noreturn));
void throw_invalid_field() __attribute__((noreturn));
void throw_would_invalidate() __attribute__((noreturn));
void throw_virtual_function_call() __attribute__((noreturn));
int main_nothrow(void (*main_f)(void));
template <typename Tc>
struct refvar_igrd_nn {
  refvar_igrd_nn(Tc& c) : c(c) {
    c.inc_invalidate_guard();
  }
  ~refvar_igrd_nn() {
    c.dec_invalidate_guard();
  }
  Tc& get() {
    return c;
  }
  typename Tc::range_type get_range()
    { return typename Tc::range_type(c); }
  typename Tc::crange_type get_crange()
    { return typename Tc::crange_type(c); }
private:
  Tc& c;
  refvar_igrd_nn(const refvar_igrd_nn&);
  refvar_igrd_nn& operator =(const refvar_igrd_nn&);
};
template <typename Tc>
struct refvar_igrd {
  refvar_igrd() : cp(0) { }
  refvar_igrd(Tc& c) : cp(&c) {
    c.inc_invalidate_guard();
  }
  ~refvar_igrd() {
    if (cp != 0) { cp->dec_invalidate_guard(); }
  }
  Tc& set(Tc& c) {
    if (cp != 0) { cp->dec_invalidate_guard(); }
    cp = &c;
    return c;
  }
  Tc& get() {
    return *cp;
  }
  typename Tc::range_type get_range()
    { return typename Tc::range_type(*cp); }
  typename Tc::crange_type get_crange()
    { return typename Tc::crange_type(*cp); }
private:
  Tc *cp;
  refvar_igrd(const refvar_igrd&);
  refvar_igrd& operator =(const refvar_igrd&);
};
template <typename Tc>
struct valvar_igrd_nn {
  valvar_igrd_nn(const Tc& x) : c(x) {
    c.inc_invalidate_guard();
  }
  ~valvar_igrd_nn() {
    c.dec_invalidate_guard();
  }
  Tc& get() {
    return c;
  }
  typename Tc::range_type get_range()
    { return typename Tc::range_type(c); }
  typename Tc::crange_type get_crange()
    { return typename Tc::crange_type(c); }
private:
  Tc c;
  valvar_igrd_nn(const valvar_igrd_nn&);
  valvar_igrd_nn& operator =(const valvar_igrd_nn&);
};
template <typename Tc>
struct valvar_igrd {
  valvar_igrd() : c() {
    c.inc_invalidate_guard();
  }
  valvar_igrd(const Tc& x) : c(x) {
    c.inc_invalidate_guard();
  }
  Tc& set(const Tc& x) {
    c = x;
    c.inc_invalidate_guard();
    return c;
  }
  Tc& get() {
    return c;
  }
  typename Tc::range_type get_range()
    { return typename Tc::range_type(c); }
  typename Tc::crange_type get_crange()
    { return typename Tc::crange_type(c); }
private:
  Tc c;
  valvar_igrd(const valvar_igrd&);
  valvar_igrd& operator =(const valvar_igrd&);
};
struct invalid_index : public std::logic_error { invalid_index(); };
struct invalid_field : public std::logic_error { invalid_field(); };
struct null_dereference : public std::logic_error { null_dereference(); };
struct would_invalidate : public std::logic_error { would_invalidate(); };
struct virtual_function_call : public std::logic_error
  { virtual_function_call(); };
}; // namespace pxcrt


extern "fdef" inline
#include <string>
#include <unistd.h>
namespace pxcrt {
invalid_index::invalid_index() : std::logic_error("invalid_index") { }
invalid_field::invalid_field() : std::logic_error("invalid_field") { }
null_dereference::null_dereference() : std::logic_error("null_dereference") { }
would_invalidate::would_invalidate() : std::logic_error("would_invalidate") { }
virtual_function_call::virtual_function_call()
  : std::logic_error("virtual_function_call") { }
void throw_invalid_index() { throw invalid_index(); }
void throw_invalid_field() { throw invalid_field(); }
void throw_null_dereference() { throw null_dereference(); }
void throw_would_invalidate() { throw would_invalidate(); }
void throw_virtual_function_call() { throw virtual_function_call(); }
int main_nothrow(void (*main_f)(void))
{
  try {
    (*main_f)();
  } catch (const std::exception& e) {
    std::string mess(e.what());
    if (!mess.empty() && mess[mess.size() - 1] != '\n') {
      mess += "\n";
    }
    ::write(2, mess.data(), mess.size());
    return 1;
  } catch (...) {
    const std::string mess = "unknown exception\n";
    ::write(2, mess.data(), mess.size());
    return 1;
  }
  return 0;
}
}; // namespace pxcrt

